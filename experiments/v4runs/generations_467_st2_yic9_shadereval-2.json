[["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{ \n\tvec3 n = s.zxy;\n\t\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);\n    if( l==3 && m==-2 ) return  k07*n.z*n.y*n.x;\n    if( l==3 && m==-1 ) return -k08*n.y*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 0 ) return  k09*n.z*(5.0*n.z*n.z-3.0);\n    if( l==3 && m== 1 ) return -k08*n.x*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 2 ) return  k10*n.z*(n.x*n.x-n.y*n.y);\n    if( l==3 && m== 3 ) return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 s ) {\n    return 1.0;\n}\nfloat SH_1_0( in vec3 s ) { vec3 n = s.zxy; return -k02*n.y; }\nfloat SH_1_1( in vec3 s ) { vec3 n = s.zxy; return  k02*n.z; }\nfloat SH_1_2( in vec3 s ) { vec3 n = s.zxy; return -k02*n.x; }\nfloat SH_2_0( in vec3 s ) { vec3 n = s.zxy; return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 s ) { vec3 n = s.zxy; return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 s ) { vec3 n = s.zxy; return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 s ) { vec3 n = s.zxy; return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 s ) { vec3 n = s.zxy; return  k05*(n.x*n.x-n.y*n.y); }\nfloat SH_3_0( in vec3 s ) { vec3 n = s.zxy; return -k06*n.y*(3.0*n.x*n.x-n.y*n.y); }\nfloat SH_3_1( in vec3 s ) { vec3 n = s.zxy; return  k07*n.z*n.y*n.x; }\nfloat SH_3_2( in vec3 s ) { vec3 n = s.zxy; return -k08*n.y*(5.0*n.z*n.z-1.0); }\nfloat SH_3_3( in vec3 s ) { vec3 n = s.zxy; return  k09*n.z*(5.0*n.z*n.z-3.0); }\nfloat SH_3_4( in vec3 s ) { vec3 n = s.zxy; return -k08*n.x*(5.0*n.z*n.z-1.0); }\nfloat SH_3_5( in vec3 s ) { vec3 n = s.zxy; return  k10*n.z*(n.x*n.x-n.y*n.y); }\nfloat SH_3_6( in vec3 s ) { vec3 n = s.zxy; return -k06*n.x*(n.x*n.x-3.0*n.y*n.y); }\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p - vec3( 0.00, 2.5,0.0);\n\tvec3 p01 = p - vec3(-1.25, 1.0,0.0);\n\tvec3 p02 = p - vec3( 0.00, 1.0,0.0);\n\tvec3 p03 = p - vec3( 1.25, 1.0,0.0);\n\tvec3 p04 = p - vec3(-2.50,-0.5,0.0);\n\tvec3 p05 = p - vec3(-1.25,-0.5,0.0);\n\tvec3 p06 = p - vec3( 0.00,-0.5,0.0);\n\tvec3 p07 = p - vec3( 1.25,-0.5,0.0);\n\tvec3 p08 = p - vec3( 2.50,-0.5,0.0);\n\tvec3 p09 = p - vec3(-3.75,-2.0,0.0);\n\tvec3 p10 = p - vec3(-2.50,-2.0,0.0);\n\tvec3 p11 = p - vec3(-1.25,-2.0,0.0);\n\tvec3 p12 = p - vec3( 0.00,-2.0,0.0);\n\tvec3 p13 = p - vec3( 1.25,-2.0,0.0);\n\tvec3 p14 = p - vec3( 2.50,-2.0,0.0);\n\tvec3 p15 = p - vec3( 3.75,-2.0,0.0);\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\td=length(p00); n=p00/d; r = SH_0_0( n ); s = SHAPE; res = s;\n\td=length(p01); n=p01/d; r = SH_1_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p02); n=p02/d; r = SH_1_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p03); n=p03/d; r = SH_1_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p04); n=p04/d; r = SH_2_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p05); n=p05/d; r = SH_2_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p06); n=p06/d; r = SH_2_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p07); n=p07/d; r = SH_2_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p08); n=p08/d; r = SH_2_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p09); n=p09/d; r = SH_3_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p10); n=p10/d; r = SH_3_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p11); n=p11/d; r = SH_3_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p12); n=p12/d; r = SH_3_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p13); n=p13/d; r = SH_3_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p14); n=p14/d; r = SH_3_5( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p15); n=p15/d; r = SH_3_6( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t\tm = res.yz;\n        t += h*0.3;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 0.314*iTime - 10.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(an),0.0,6.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.45,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    // bad dither\n    tot += (1.0/255.0)*fract(sin(fragCoord.x+1111.0*fragCoord.y)*1111.0);\n    \n    fragColor = vec4( tot, 1.0 );\n}\n"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n// distance to a line (can't get simpler than this)\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.yy;\n\tvec2 q = p;\n\t\n\tvec2 c = vec2(0.0);\n\tif( iMouse.z>0.0 ) c=(-iResolution.xy + 2.0*iMouse.xy) / iResolution.yy;\n\t\n    // background\t\n\tvec3 col = vec3(0.5,0.85,0.9)*(1.0-0.2*length(p));\n\tif( q.x>c.x && q.y>c.y ) col = pow(col,vec3(2.2));\n\n    // zoom in and out\t\n\tp *= 1.0 + 0.2*sin(iTime*0.4);\n\t\n\t\n\t// compute distance to a set of lines\n    float d = 1e20;\t\n\tfor( int i=0; i<7; i++ )\n\t{\n        float anA = 6.2831*float(i+0)/7.0 + 0.15*iTime;\n        float anB = 6.2831*float(i+3)/7.0 + 0.20*iTime;\n\t\tvec2 pA = 0.95*vec2( cos(anA), sin(anA) );\t\t\n        vec2 pB = 0.95*vec2( cos(anB), sin(anB) );\t\t\n\t\tfloat h = line( pA, pB, p );\n\t\td = min( d, h );\n\t}\n\n    // lines/start, left side of screen\t: not filtered\n\tif( q.x<c.x )\n\t{\n\t\tif( d<0.12 ) col = vec3(0.0,0.0,0.0); // black \n\t\tif( d<0.04 ) col = vec3(1.0,0.6,0.0); // orange\n\t}\n    // lines/start, right side of the screen: filtered\n\telse\n\t{\n\t\tfloat w = 0.5*fwidth(d); \n\t\tw *= 1.5; // extra blur\n\t\t\n\t\tif( q.y<c.y )\n\t\t{\n\t\tcol = mix( vec3(0.0,0.0,0.0), col, smoothstep(-w,w,d-0.12) ); // black\n\t\tcol = mix( vec3(1.0,0.6,0.0), col, smoothstep(-w,w,d-0.04) ); // orange\n\t\t}\n\t\telse\n\t\t{\n\t\tcol = mix( pow(vec3(0.0,0.0,0.0),vec3(2.2)), col, smoothstep(-w,w,d-0.12) ); // black\n\t\tcol = mix( pow(vec3(1.0,0.6,0.0),vec3(2.2)), col, smoothstep(-w,w,d-0.04) ); // orange\n\t\t}\n\t}\n\t\n\n\tif( q.x>c.x && q.y>c.y )\n\t\tcol = pow( col, vec3(1.0/2.2) );\n\t\n    // draw left/right separating line\n\tcol = mix( vec3(0.0), col, smoothstep(0.007,0.008,abs(q.x-c.x)) );\n\tcol = mix( col, vec3(0.0), (1.0-smoothstep(0.007,0.008,abs(q.y-c.y)))*step(0.0,q.x-c.x) );\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// various noise functions\nfloat Hash2d(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise2dT(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).y;\t// use constant here instead?\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat Density(vec3 p)\n{\n    //float ws = 0.06125*0.125;\n    //vec3 warp = vec3(noise(p*ws), noise(p*ws + 111.11), noise(p*ws + 7111.11));\n    float final = noise(p*0.06125);// + sin(iTime)*0.5-1.95 + warp.x*4.0;\n    float other = noise(p*0.06125 + 1234.567);\n    other -= 0.5;\n    final -= 0.5;\n    final = 0.1/(abs(final*final*other));\n    final += 0.5;\n    return final*0.0001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 70.0;\n\tvec3 pos = vec3(0,0,0);\n    float density = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 37; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n        pos = camPos + relVec * t;\n        float temp = Density(pos);\n        //temp *= saturate(t-1.0);\n\n        inc = 1.9 + temp*0.05;\t// add temp because this makes it look extra crazy!\n        density += temp * inc;\n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(0.01,0.1,1.0)* density*0.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// A useful trick to avoid certain type of discontinuities\n// during rendering and procedural content generation. More info:\n//\n// https://iquilezles.org/www/articles/dontflip/dontflip.htm\n\n\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r )\n{\n    return (dot(v,r)>0.0)? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : v-2.0*r*k;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : (v-r*k)*inversesqrt(1.0-k*k/dot(v,v));\n}\n\n//===============================================================\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    const float k = 3.0;\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n\n    if( p.x<w1 )\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n\n    if( pz.x>0.0 )\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n//===============================================================\n\nfloat line( in vec2 p, in vec2 a, in vec2 b, float w , float e)\n{\n    return 1.0 - smoothstep( -e, e, sdLine( p, a, b ) - w );\n}\n\nfloat arrow( in vec2 p, in vec2 a, in vec2 b, float w1, float w2, float e )\n{\n    return 1.0 - smoothstep( -e, e, sdArrow( p, a, b, w1, w2) );\n}\n\n//===============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord/iResolution.x;\n    vec2 q = p;\n    p.x = mod(p.x,1.0/3.0) - 1.0/6.0;\n    \n    p.y -= 0.5*iResolution.y/iResolution.x;\n    p.y += 0.04;\n    \n    float e = 1.0/iResolution.x;\n   \n    float time = iTime;\n    \n    //time = mod( time, 8.0 );\n    float an = 0.3*(1.0-smoothstep(-0.1,0.1,sin(0.125*6.283185*(time+1.0/2.0))));\n    \n    vec2 r = vec2( sin(an), cos(an) );\n    vec2 pe = r.yx*vec2(-1.0,1.0);\n    \n    vec3 col = vec3(0.15);\n    col = vec3(21,32,43)/255.0;\n\n    float wi = 0.0015;\n    float s = dot(p,r);\n    if( s>0.0 )\n    {\n        float r = length(p);\n        if( r<0.12 )\n        {\n            float nr = r/0.12;\n            col += 0.25*nr*nr;\n        }\n        col = mix(col,vec3(0.7), 1.0-smoothstep(-e,e,abs(r-0.12)-wi));\n    }\n\n    col = mix( col, vec3(0.7), arrow(p, vec2(0.0), r*0.18, wi, 0.01, e) );\n    col = mix( col, vec3(0.7), line(p, -0.12*pe, 0.12*pe, wi, e) );\n\n    {\n    float an = cos(0.5*6.283185*time);\n    vec2 v = vec2( -cos(an), sin(an) )*0.12;\n    vec2 f;\n         if( q.x<0.333 ) f = flipIfNeg( v, r );\n    else if( q.x<0.666 ) f = reflIfNeg( v, r );\n    else                 f = clipIfNeg( v, r );\n\n    col = mix( col, col+0.2, arrow(p, vec2(0.0), v, wi, 5.0*wi, e) );\n    col = mix( col, vec3(1.0,0.7,0.2), arrow(p, vec2(0.0), f, wi, 5.0*wi, e) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// A useful trick to avoid certain type of discontinuities\n// during rendering and procedural content generation. More info:\n//\n// https://iquilezles.org/www/articles/dontflip/dontflip.htm\n\n\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r )\n{\n    return dot(v,r)<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : (v-r*k)*inversesqrt(1.0-k*k/dot(v,v));\n}\n\n//===============================================================\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    const float k = 3.0;\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n\n    if( p.x<w1 )\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n\n    if( pz.x>0.0 )\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n//===============================================================\n\nfloat line( in vec2 p, in vec2 a, in vec2 b, float w , float e)\n{\n    return 1.0 - smoothstep( -e, e, sdLine( p, a, b ) - w );\n}\n\nfloat arrow( in vec2 p, in vec2 a, in vec2 b, float w1, float w2, float e )\n{\n    return 1.0 - smoothstep( -e, e, sdArrow( p, a, b, w1, w2) );\n}\n\n//===============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord/iResolution.x;\n    vec2 q = p;\n    p.x = mod(p.x,1.0/3.0) - 1.0/6.0;\n    \n    p.y -= 0.5*iResolution.y/iResolution.x;\n    p.y += 0.04;\n    \n    float e = 1.0/iResolution.x;\n   \n    float time = iTime;\n    \n    //time = mod( time, 8.0 );\n    float an = 0.3*(1.0-smoothstep(-0.1,0.1,sin(0.125*6.283185*(time+1.0/2.0))));\n    \n    vec2 r = vec2( sin(an), cos(an) );\n    vec2 pe = r.yx*vec2(-1.0,1.0);\n    \n    vec3 col = vec3(0.15);\n    col = vec3(21,32,43)/255.0;\n\n    float wi = 0.0015;\n    float s = dot(p,r);\n    if( s>0.0 )\n    {\n        float r = length(p);\n        if( r<0.12 )\n        {\n            float nr = r/0.12;\n            col += 0.25*nr*nr;\n        }\n        col = mix(col,vec3(0.7), 1.0-smoothstep(-e,e,abs(r-0.12)-wi));\n    }\n\n    col = mix( col, vec3(0.7), arrow(p, vec2(0.0), r*0.18, wi, 0.01, e) );\n    col = mix( col, vec3(0.7), line(p, -0.12*pe, 0.12*pe, wi, e) );\n\n    {\n    float an = cos(0.5*6.283185*time);\n    vec2 v = vec2( -cos(an), sin(an) )*0.12;\n    vec2 f;\n         if( q.x<0.333 ) f = flipIfNeg( v, r );\n    else if( q.x<0.666 ) f = reflIfNeg( v, r );\n    else                 f = clipIfNeg( v, r );\n\n    col = mix( col, col+0.2, arrow(p, vec2(0.0), v, wi, 5.0*wi, e) );\n    col = mix( col, vec3(1.0,0.7,0.2), arrow(p, vec2(0.0), f, wi, 5.0*wi, e) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// A useful trick to avoid certain type of discontinuities\n// during rendering and procedural content generation. More info:\n//\n// https://iquilezles.org/www/articles/dontflip/dontflip.htm\n\n\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : v-2.0*r*k;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r )\n{\n    return v.y<0.0? vec2(0.0) : v;\n}\n\n//===============================================================\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    const float k = 3.0;\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n\n    if( p.x<w1 )\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n\n    if( pz.x>0.0 )\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n//===============================================================\n\nfloat line( in vec2 p, in vec2 a, in vec2 b, float w , float e)\n{\n    return 1.0 - smoothstep( -e, e, sdLine( p, a, b ) - w );\n}\n\nfloat arrow( in vec2 p, in vec2 a, in vec2 b, float w1, float w2, float e )\n{\n    return 1.0 - smoothstep( -e, e, sdArrow( p, a, b, w1, w2) );\n}\n\n//===============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord/iResolution.x;\n    vec2 q = p;\n    p.x = mod(p.x,1.0/3.0) - 1.0/6.0;\n    \n    p.y -= 0.5*iResolution.y/iResolution.x;\n    p.y += 0.04;\n    \n    float e = 1.0/iResolution.x;\n   \n    float time = iTime;\n    \n    //time = mod( time, 8.0 );\n    float an = 0.3*(1.0-smoothstep(-0.1,0.1,sin(0.125*6.283185*(time+1.0/2.0))));\n    \n    vec2 r = vec2( sin(an), cos(an) );\n    vec2 pe = r.yx*vec2(-1.0,1.0);\n    \n    vec3 col = vec3(0.15);\n    col = vec3(21,32,43)/255.0;\n\n    float wi = 0.0015;\n    float s = dot(p,r);\n    if( s>0.0 )\n    {\n        float r = length(p);\n        if( r<0.12 )\n        {\n            float nr = r/0.12;\n            col += 0.25*nr*nr;\n        }\n        col = mix(col,vec3(0.7), 1.0-smoothstep(-e,e,abs(r-0.12)-wi));\n    }\n\n    col = mix( col, vec3(0.7), arrow(p, vec2(0.0), r*0.18, wi, 0.01, e) );\n    col = mix( col, vec3(0.7), line(p, -0.12*pe, 0.12*pe, wi, e) );\n\n    {\n    float an = cos(0.5*6.283185*time);\n    vec2 v = vec2( -cos(an), sin(an) )*0.12;\n    vec2 f;\n         if( q.x<0.333 ) f = flipIfNeg( v, r );\n    else if( q.x<0.666 ) f = reflIfNeg( v, r );\n    else                 f = clipIfNeg( v, r );\n\n    col = mix( col, col+0.2, arrow(p, vec2(0.0), v, wi, 5.0*wi, e) );\n    col = mix( col, vec3(1.0,0.7,0.2), arrow(p, vec2(0.0), f, wi, 5.0*wi, e) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// A useful trick to avoid certain type of discontinuities\n// during rendering and procedural content generation. More info:\n//\n// https://iquilezles.org/www/articles/dontflip/dontflip.htm\n\n\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : v-2.0*r*k;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : (v-r*k)*inversesqrt(1.0-k*k/dot(v,v));\n}\n\n//===============================================================\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix( w1, w2, h );\n}\n\n//===============================================================\n\nfloat line( in vec2 p, in vec2 a, in vec2 b, float w , float e)\n{\n    return 1.0 - smoothstep( -e, e, sdLine( p, a, b ) - w );\n}\n\nfloat arrow( in vec2 p, in vec2 a, in vec2 b, float w1, float w2, float e )\n{\n    return 1.0 - smoothstep( -e, e, sdArrow( p, a, b, w1, w2) );\n}\n\n//===============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord/iResolution.x;\n    vec2 q = p;\n    p.x = mod(p.x,1.0/3.0) - 1.0/6.0;\n    \n    p.y -= 0.5*iResolution.y/iResolution.x;\n    p.y += 0.04;\n    \n    float e = 1.0/iResolution.x;\n   \n    float time = iTime;\n    \n    //time = mod( time, 8.0 );\n    float an = 0.3*(1.0-smoothstep(-0.1,0.1,sin(0.125*6.283185*(time+1.0/2.0))));\n    \n    vec2 r = vec2( sin(an), cos(an) );\n    vec2 pe = r.yx*vec2(-1.0,1.0);\n    \n    vec3 col = vec3(0.15);\n    col = vec3(21,32,43)/255.0;\n\n    float wi = 0.0015;\n    float s = dot(p,r);\n    if( s>0.0 )\n    {\n        float r = length(p);\n        if( r<0.12 )\n        {\n            float nr = r/0.12;\n            col += 0.25*nr*nr;\n        }\n        col = mix(col,vec3(0.7), 1.0-smoothstep(-e,e,abs(r-0.12)-wi));\n    }\n\n    col = mix( col, vec3(0.7), arrow(p, vec2(0.0), r*0.18, wi, 0.01, e) );\n    col = mix( col, vec3(0.7), line(p, -0.12*pe, 0.12*pe, wi, e) );\n\n    {\n    float an = cos(0.5*6.283185*time);\n    vec2 v = vec2( -cos(an), sin(an) )*0.12;\n    vec2 f;\n         if( q.x<0.333 ) f = flipIfNeg( v, r );\n    else if( q.x<0.666 ) f = reflIfNeg( v, r );\n    else                 f = clipIfNeg( v, r );\n\n    col = mix( col, col+0.2, arrow(p, vec2(0.0), v, wi, 5.0*wi, e) );\n    col = mix( col, vec3(1.0,0.7,0.2), arrow(p, vec2(0.0), f, wi, 5.0*wi, e) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// The noise function in this was inspired by IQ's \"Terrain Tubes\" shader. I never really figured out\n// his function completely, so I'm not sure of the exact similarities. It's nice though because it\n// works the same on all computers (I think). It's not based on a hash that changes from computer to \n// computer. That means I can finally rely on the terrain being the same and make a camera path. :)\n// It's also a much faster noise function, although it can look a bit repetitive.\n\n#define MOTION_BLUR\n#define MOVING_SUN\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = sunDot * sunDot;\n    float sunDot3 = sunDot2 * sunDot;\n    float sunDot4 = sunDot3 * sunDot;\n    float sunDot5 = sunDot4 * sunDot;\n    float sunDot6 = sunDot5 * sunDot;\n    float sunDot7 = sunDot6 * sunDot;\n    float sunDot8 = sunDot7 * sunDot;\n    float sunDot9 = sunDot8 * sunDot;\n    float sunDot10 = sunDot9 * sunDot;\n    float sunDot11 = sunDot10 * sunDot;\n    float sunDot12 = sunDot11 * sunDot;\n    float sunDot13 = sunDot12 * sunDot;\n    float sunDot14 = sunDot13 * sunDot;\n    float sunDot15 = sunDot14 * sunDot;\n    float sunDot16 = sunDot15 * sunDot;\n    float sunDot17 = sunDot16 * sunDot;\n    float sunDot18 = sunDot17 * sunDot;\n    float sunDot19 = sunDot18 * sunDot;\n    float sunDot20 = sunDot19 * sunDot;\n    float sunDot21 = sunDot20 * sunDot;\n    float sunDot22 = sunDot21 * sunDot;\n    float sunDot23 = sunDot22 * sunDot;\n    float sunDot24 = sunDot23 * sunDot;\n    float sunDot25 = sunDot24 * sunDot;\n    float sunDot26 = sunDot25 * sunDot;\n    float sunDot27 = sunDot26 * sunDot;\n    float sunDot28 = sunDot27// incomplete generation!\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    float t2 = t*t;\n    float t3 = t*t*t;\n    return 0.5 *((2.0 * p1) +\n                 (-p0 + p2) * t +\n    \t\t\t (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n    \t\t\t (-p0 + 3.0 * p1- 3.0 * p2 + p3) * t3);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoiseD(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        n += abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\n// These are the xyz camera positions and a left/right facing angle relative to the path line\n// I think webgl glsl can only access arrays using a constant, so I'm writing all these out.\n// Someone please tell me if I'm wrong.\nvec4 c00 = vec4(3.5, 2.0, 13.1, 0.0);\t// start point\nvec4 c01 = vec4(12.5, 2.2, 17.0, 0.0);\t// run up to canyon 2 before hole in large rock face\nvec4 c02 = vec4(21.5, 4.0, 8.1, 0.0);\t// canyon 2 before hole in large rock face\nvec4 c03 = vec4(21.0, 5.0, 1.1, -0.5);\t// before hole in large rock face\nvec4 c04 = vec4(17.8, 5.4, -0.2, 0.0);\t// hole in large rock face\nvec4 c05 = vec4(14.7, 2.5, 1.4, 0.0);\t// after hole in large rock face\nvec4 c06 = vec4(7.9, 2.3, -2.1, 0.0);\nvec4 c07 = vec4(0.5, -0.7, -3.5, 1.0);\nvec4 c08 = vec4(-3.0, -1.0, -3.5, 1.3);\nvec4 c09 = vec4(-3.5, -1.0, 4.0, 1.3);\nvec4 c10 = vec4(3.0, -0.7, 3.3, 0.8);\nvec4 c11 = vec4(3.5, -1.0, -4.75, 0.0);\nvec4 c12 = vec4(-6.0, -0.2, 1.0, 3.14);\nvec4 c13 = vec4(-6.0, -1.0, 5.5, 0.0);\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nfloat camPathOffset = 0.0;\t// where to start on the camera path - parametric t var for catmull-rom spline\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\nfloat waterLevel = 1.5;\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamPos(float t)\n{\n    t = mod(t, 14.0);\t// repeat after 14 time units\n    float bigTime = floor(t);\n    float smallTime = fract(t);\n    // Can't do arrays right, so write this all out.\n    if (bigTime == 0.0) return CatmullRom(c00, c01, c02, c03, smallTime);\n    if (bigTime == 1.0) return CatmullRom(c01, c02, c03, c04, smallTime);\n    if (bigTime == 2.0) return CatmullRom(c02, c03, c04, c05, smallTime);\n    if (bigTime == 3.0) return CatmullRom(c03, c04, c05, c06, smallTime);\n    if (bigTime == 4.0) return CatmullRom(c04, c05, c06, c07, smallTime);\n    if (bigTime == 5.0) return CatmullRom(c05, c06, c07, c08, smallTime);\n    if (bigTime == 6.0) return CatmullRom(c06, c07, c08, c09, smallTime);\n\n    if (bigTime == 7.0) return CatmullRom(c07, c08, c09, c10, smallTime);\n    if (bigTime == 8.0) return CatmullRom(c08, c09, c10, c11, smallTime);\n    if (bigTime == 9.0) return CatmullRom(c09, c10, c11, c12, smallTime);\n    if (bigTime == 10.0) return CatmullRom(c10, c11, c12, c13, smallTime);\n    if (bigTime == 11.0) return CatmullRom(c11, c12, c13, c00, smallTime);\n    if (bigTime == 12.0) return CatmullRom(c12, c13, c00, c01, smallTime);\n    if (bigTime == 13.0) return CatmullRom(c13, c00, c01, c02, smallTime);\n    return vec4(0.0);\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale terrain features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t// small scale noise for variation\n\tfinal = min(final, length(p) - 1.99);\t// sphere in center\n    final = min(final, p.y + waterLevel);\t// water\n\t//final = min(final, length(p-camLookat) - 0.3);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n/*    if (iTime == 0.0)\t// for debugging with manual camera\n    {\n        camPos = cXX.xyz;\n        camLookat = vec3(0.0)*cXX.xyz;\n    }*/\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(5.2); \t// prp\n\n    // set time for moving camera along path\n    float timeLine = iTime*0.2 + camPathOffset;\n    camFacing = camLookat + camPos;\n    // without this if condition, the mac doesn't work. mysterious. :(\n    if (iTime != -1.0)\n    {\n        vec4 catmullA = CamPos(timeLine);\n        // get a smoother derivative even though the spline is not C2 continuous.\n        // Also look ahead a bit so the camera leads the motion\n        vec4 catmullB = CamPos(timeLine + 0.3);\n#ifdef MOTION_BLUR\n        vec4 catmullC = CamPos(timeLine + 0.004);\t// adjust for camera motion blur\n        vec4 catmullBlur = mix(catmullA, catmullC, Hash2d(uv));\t// motion blur along camera path\n        camPos = catmullBlur.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullBlur.w);\n#else\n        camPos = catmullA.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullA.w);\n#endif\n        camFacing = RotateY(camFacing, -mx);\n    \tcamLookat = camPos + camFacing;\n    }\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.05;\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n    for (int i = 0; i < 200; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.0075)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        t += dist * 0.25;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n    // This makes the sky fade at sunset\n    float skyMultiplier = saturate(sunDir.y+0.7);\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        /*if (pos.y <= waterLevel-2.995)\t// water waves?\n        {\n            normal += SpiralNoise3D(pos*32.0+vec3(iTime*8.0,0.0,0.0))*0.0001;\n            normal += SpiralNoise3D(pos*27.0+vec3(0.0,0.0, iTime* 10.333))*0.0001;\n            normal += SpiralNoiseD(pos*37.0+vec3(0.0,iTime* 14.333,0.0))*0.0002;\n        }*/\n        normal = normalize(normal);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        //ambient *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        float sunSet = saturate(sunDir.y*4.0); // sunset dims the sun\n        sunShadow = saturate(sunShadow) * sunSet;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // pulse the ball light source\n        vec3 ballGlow = vec3(0.1, 0.97, 0.1) * abs(SpiralNoise3D(vec3(iTime*1.3)));\n\n        // ------ Calculate texture color of the rock ------\n        // basic orange and white blended together with noise\n        vec3 texColor = mix(vec3(0.95, 1.0, 1.0),  vec3(0.9, 0.7, 0.5), pow(abs(SpiralNoise3D(pos*1.0)-1.0), 0.6) );\n        // make the undersides darker greenish\n        texColor = mix(vec3(0.2, 0.2, 0.1), texColor, saturate(normal.y));\n        // fade to reddish/orange closer to the water level\n        texColor = mix(texColor, vec3(0.64, 0.2, 0.1) , saturate(-0.4-pos.y));\n        // some more variation to the color vertically\n        texColor = mix(texColor, vec3(0.2, 0.13, 0.02) , pow(saturate(pos.y*0.125+0.5), 2.0));\n        // give the rock a stratified, layered look\n        float rockLayers = abs(cos(pos.y*1.5+ SpiralNoiseD(pos*vec3(1.0, 2.0, 1.0)*4.0)*0.2 ));\n        texColor += vec3(0.7, 0.4, 0.3)*(1.0-pow(rockLayers, 0.3));\n\n        // make the water orange. I'm trying for that \"nickel tailings\" look.\n        texColor = mix(texColor, vec3(1.4, 0.15, 0.05) + SpiralNoise3D(pos)*0.025, saturate((-pos.y-1.45)*17.0));\n        // make the sphere white\n        if (length(pos) <= 2.01) texColor = vec3(1.0);\n        // don't let it get too saturated or dark\n        texColor = max(texColor, 0.05);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(1.0, 0.75, 0.75) * saturate(dot(sunDir, normal)) * sunShadow*1.5;\n        // sky color, hemisphere light equation approximation, anbient occlusion, sunset multiplier\n        lightColor += vec3(1.0,0.3,0.6) * ( dot(sunDir, normal) * 0.5 + 0.5 ) * ambient * 0.25 * skyMultiplier;\n        // Make the ball cast light. Distance to the 4th light falloff looked best. Use local ambient occlusion.\n        float lp = length(pos) - 1.0;\n        lightColor += ambientS*(ballGlow*1.2 * saturate(dot(normal, -pos)*0.5+0.5) / (lp*lp*lp*lp));\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // Make the water reflect the sun (leaving out sky reflection for no good reason)\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunShadow * saturate(normal.y*normal.y) * saturate(-(pos.y+1.35)*16.0);\n\n        // make the ball itself glow\n        finalColor += pow(saturate(1.0 - length(pos)*0.4925), 0.65) * ballGlow*6.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.03));\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.5, 0.5), vec3(0.40, 0.25, 0.91), saturate(relVec.y))*skyMultiplier;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    //finalColor = vec3(Hash2d(uv)*0.91,  Hash2d(uv+47.0)*0.91, 0.0);\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// The noise function in this was inspired by IQ's \"Terrain Tubes\" shader. I never really figured out\n// his function completely, so I'm not sure of the exact similarities. It's nice though because it\n// works the same on all computers (I think). It's not based on a hash that changes from computer to \n// computer. That means I can finally rely on the terrain being the same and make a camera path. :)\n// It's also a much faster noise function, although it can look a bit repetitive.\n\n#define MOTION_BLUR\n#define MOVING_SUN\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 v0 = (p2 - p0) * 0.5;\n    vec4 v1 = (p3 - p1) * 0.5;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoiseD(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        n += abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\n// These are the xyz camera positions and a left/right facing angle relative to the path line\n// I think webgl glsl can only access arrays using a constant, so I'm writing all these out.\n// Someone please tell me if I'm wrong.\nvec4 c00 = vec4(3.5, 2.0, 13.1, 0.0);\t// start point\nvec4 c01 = vec4(12.5, 2.2, 17.0, 0.0);\t// run up to canyon 2 before hole in large rock face\nvec4 c02 = vec4(21.5, 4.0, 8.1, 0.0);\t// canyon 2 before hole in large rock face\nvec4 c03 = vec4(21.0, 5.0, 1.1, -0.5);\t// before hole in large rock face\nvec4 c04 = vec4(17.8, 5.4, -0.2, 0.0);\t// hole in large rock face\nvec4 c05 = vec4(14.7, 2.5, 1.4, 0.0);\t// after hole in large rock face\nvec4 c06 = vec4(7.9, 2.3, -2.1, 0.0);\nvec4 c07 = vec4(0.5, -0.7, -3.5, 1.0);\nvec4 c08 = vec4(-3.0, -1.0, -3.5, 1.3);\nvec4 c09 = vec4(-3.5, -1.0, 4.0, 1.3);\nvec4 c10 = vec4(3.0, -0.7, 3.3, 0.8);\nvec4 c11 = vec4(3.5, -1.0, -4.75, 0.0);\nvec4 c12 = vec4(-6.0, -0.2, 1.0, 3.14);\nvec4 c13 = vec4(-6.0, -1.0, 5.5, 0.0);\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nfloat camPathOffset = 0.0;\t// where to start on the camera path - parametric t var for catmull-rom spline\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\nfloat waterLevel = 1.5;\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamPos(float t)\n{\n    t = mod(t, 14.0);\t// repeat after 14 time units\n    float bigTime = floor(t);\n    float smallTime = fract(t);\n    // Can't do arrays right, so write this all out.\n    if (bigTime == 0.0) return CatmullRom(c00, c01, c02, c03, smallTime);\n    if (bigTime == 1.0) return CatmullRom(c01, c02, c03, c04, smallTime);\n    if (bigTime == 2.0) return CatmullRom(c02, c03, c04, c05, smallTime);\n    if (bigTime == 3.0) return CatmullRom(c03, c04, c05, c06, smallTime);\n    if (bigTime == 4.0) return CatmullRom(c04, c05, c06, c07, smallTime);\n    if (bigTime == 5.0) return CatmullRom(c05, c06, c07, c08, smallTime);\n    if (bigTime == 6.0) return CatmullRom(c06, c07, c08, c09, smallTime);\n\n    if (bigTime == 7.0) return CatmullRom(c07, c08, c09, c10, smallTime);\n    if (bigTime == 8.0) return CatmullRom(c08, c09, c10, c11, smallTime);\n    if (bigTime == 9.0) return CatmullRom(c09, c10, c11, c12, smallTime);\n    if (bigTime == 10.0) return CatmullRom(c10, c11, c12, c13, smallTime);\n    if (bigTime == 11.0) return CatmullRom(c11, c12, c13, c00, smallTime);\n    if (bigTime == 12.0) return CatmullRom(c12, c13, c00, c01, smallTime);\n    if (bigTime == 13.0) return CatmullRom(c13, c00, c01, c02, smallTime);\n    return vec4(0.0);\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale terrain features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t// small scale noise for variation\n\tfinal = min(final, length(p) - 1.99);\t// sphere in center\n    final = min(final, p.y + waterLevel);\t// water\n\t//final = min(final, length(p-camLookat) - 0.3);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n/*    if (iTime == 0.0)\t// for debugging with manual camera\n    {\n        camPos = cXX.xyz;\n        camLookat = vec3(0.0)*cXX.xyz;\n    }*/\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(5.2); \t// prp\n\n    // set time for moving camera along path\n    float timeLine = iTime*0.2 + camPathOffset;\n    camFacing = camLookat + camPos;\n    // without this if condition, the mac doesn't work. mysterious. :(\n    if (iTime != -1.0)\n    {\n        vec4 catmullA = CamPos(timeLine);\n        // get a smoother derivative even though the spline is not C2 continuous.\n        // Also look ahead a bit so the camera leads the motion\n        vec4 catmullB = CamPos(timeLine + 0.3);\n#ifdef MOTION_BLUR\n        vec4 catmullC = CamPos(timeLine + 0.004);\t// adjust for camera motion blur\n        vec4 catmullBlur = mix(catmullA, catmullC, Hash2d(uv));\t// motion blur along camera path\n        camPos = catmullBlur.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullBlur.w);\n#else\n        camPos = catmullA.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullA.w);\n#endif\n        camFacing = RotateY(camFacing, -mx);\n    \tcamLookat = camPos + camFacing;\n    }\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.05;\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n    for (int i = 0; i < 200; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.0075)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        t += dist * 0.25;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n    // This makes the sky fade at sunset\n    float skyMultiplier = saturate(sunDir.y+0.7);\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        /*if (pos.y <= waterLevel-2.995)\t// water waves?\n        {\n            normal += SpiralNoise3D(pos*32.0+vec3(iTime*8.0,0.0,0.0))*0.0001;\n            normal += SpiralNoise3D(pos*27.0+vec3(0.0,0.0, iTime* 10.333))*0.0001;\n            normal += SpiralNoiseD(pos*37.0+vec3(0.0,iTime* 14.333,0.0))*0.0002;\n        }*/\n        normal = normalize(normal);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        //ambient *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        float sunSet = saturate(sunDir.y*4.0); // sunset dims the sun\n        sunShadow = saturate(sunShadow) * sunSet;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // pulse the ball light source\n        vec3 ballGlow = vec3(0.1, 0.97, 0.1) * abs(SpiralNoise3D(vec3(iTime*1.3)));\n\n        // ------ Calculate texture color of the rock ------\n        // basic orange and white blended together with noise\n        vec3 texColor = mix(vec3(0.95, 1.0, 1.0),  vec3(0.9, 0.7, 0.5), pow(abs(SpiralNoise3D(pos*1.0)-1.0), 0.6) );\n        // make the undersides darker greenish\n        texColor = mix(vec3(0.2, 0.2, 0.1), texColor, saturate(normal.y));\n        // fade to reddish/orange closer to the water level\n        texColor = mix(texColor, vec3(0.64, 0.2, 0.1) , saturate(-0.4-pos.y));\n        // some more variation to the color vertically\n        texColor = mix(texColor, vec3(0.2, 0.13, 0.02) , pow(saturate(pos.y*0.125+0.5), 2.0));\n        // give the rock a stratified, layered look\n        float rockLayers = abs(cos(pos.y*1.5+ SpiralNoiseD(pos*vec3(1.0, 2.0, 1.0)*4.0)*0.2 ));\n        texColor += vec3(0.7, 0.4, 0.3)*(1.0-pow(rockLayers, 0.3));\n\n        // make the water orange. I'm trying for that \"nickel tailings\" look.\n        texColor = mix(texColor, vec3(1.4, 0.15, 0.05) + SpiralNoise3D(pos)*0.025, saturate((-pos.y-1.45)*17.0));\n        // make the sphere white\n        if (length(pos) <= 2.01) texColor = vec3(1.0);\n        // don't let it get too saturated or dark\n        texColor = max(texColor, 0.05);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(1.0, 0.75, 0.75) * saturate(dot(sunDir, normal)) * sunShadow*1.5;\n        // sky color, hemisphere light equation approximation, anbient occlusion, sunset multiplier\n        lightColor += vec3(1.0,0.3,0.6) * ( dot(sunDir, normal) * 0.5 + 0.5 ) * ambient * 0.25 * skyMultiplier;\n        // Make the ball cast light. Distance to the 4th light falloff looked best. Use local ambient occlusion.\n        float lp = length(pos) - 1.0;\n        lightColor += ambientS*(ballGlow*1.2 * saturate(dot(normal, -pos)*0.5+0.5) / (lp*lp*lp*lp));\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // Make the water reflect the sun (leaving out sky reflection for no good reason)\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunShadow * saturate(normal.y*normal.y) * saturate(-(pos.y+1.35)*16.0);\n\n        // make the ball itself glow\n        finalColor += pow(saturate(1.0 - length(pos)*0.4925), 0.65) * ballGlow*6.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.03));\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.5, 0.5), vec3(0.40, 0.25, 0.91), saturate(relVec.y))*skyMultiplier;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    //finalColor = vec3(Hash2d(uv)*0.91,  Hash2d(uv+47.0)*0.91, 0.0);\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// The noise function in this was inspired by IQ's \"Terrain Tubes\" shader. I never really figured out\n// his function completely, so I'm not sure of the exact similarities. It's nice though because it\n// works the same on all computers (I think). It's not based on a hash that changes from computer to \n// computer. That means I can finally rely on the terrain being the same and make a camera path. :)\n// It's also a much faster noise function, although it can look a bit repetitive.\n\n#define MOTION_BLUR\n#define MOVING_SUN\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    float t2 = t*t;\n    float t3 = t*t*t;\n    return 0.5 *((2.0 * p1) +\n                 (-p0 + p2) * t +\n    \t\t\t (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n    \t\t\t (-p0 + 3.0 * p1- 3.0 * p2 + p3) * t3);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += sin(freq * p.x + cos(freq * p.z + nudge)) * amp;\n\t\tfreq *= 1.73;\n\t\tamp *= 0.577;\n\t}\n\treturn n * normalizer;\n}\nfloat SpiralNoiseD(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        n += abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\n// These are the xyz camera positions and a left/right facing angle relative to the path line\n// I think webgl glsl can only access arrays using a constant, so I'm writing all these out.\n// Someone please tell me if I'm wrong.\nvec4 c00 = vec4(3.5, 2.0, 13.1, 0.0);\t// start point\nvec4 c01 = vec4(12.5, 2.2, 17.0, 0.0);\t// run up to canyon 2 before hole in large rock face\nvec4 c02 = vec4(21.5, 4.0, 8.1, 0.0);\t// canyon 2 before hole in large rock face\nvec4 c03 = vec4(21.0, 5.0, 1.1, -0.5);\t// before hole in large rock face\nvec4 c04 = vec4(17.8, 5.4, -0.2, 0.0);\t// hole in large rock face\nvec4 c05 = vec4(14.7, 2.5, 1.4, 0.0);\t// after hole in large rock face\nvec4 c06 = vec4(7.9, 2.3, -2.1, 0.0);\nvec4 c07 = vec4(0.5, -0.7, -3.5, 1.0);\nvec4 c08 = vec4(-3.0, -1.0, -3.5, 1.3);\nvec4 c09 = vec4(-3.5, -1.0, 4.0, 1.3);\nvec4 c10 = vec4(3.0, -0.7, 3.3, 0.8);\nvec4 c11 = vec4(3.5, -1.0, -4.75, 0.0);\nvec4 c12 = vec4(-6.0, -0.2, 1.0, 3.14);\nvec4 c13 = vec4(-6.0, -1.0, 5.5, 0.0);\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nfloat camPathOffset = 0.0;\t// where to start on the camera path - parametric t var for catmull-rom spline\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\nfloat waterLevel = 1.5;\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamPos(float t)\n{\n    t = mod(t, 14.0);\t// repeat after 14 time units\n    float bigTime = floor(t);\n    float smallTime = fract(t);\n    // Can't do arrays right, so write this all out.\n    if (bigTime == 0.0) return CatmullRom(c00, c01, c02, c03, smallTime);\n    if (bigTime == 1.0) return CatmullRom(c01, c02, c03, c04, smallTime);\n    if (bigTime == 2.0) return CatmullRom(c02, c03, c04, c05, smallTime);\n    if (bigTime == 3.0) return CatmullRom(c03, c04, c05, c06, smallTime);\n    if (bigTime == 4.0) return CatmullRom(c04, c05, c06, c07, smallTime);\n    if (bigTime == 5.0) return CatmullRom(c05, c06, c07, c08, smallTime);\n    if (bigTime == 6.0) return CatmullRom(c06, c07, c08, c09, smallTime);\n\n    if (bigTime == 7.0) return CatmullRom(c07, c08, c09, c10, smallTime);\n    if (bigTime == 8.0) return CatmullRom(c08, c09, c10, c11, smallTime);\n    if (bigTime == 9.0) return CatmullRom(c09, c10, c11, c12, smallTime);\n    if (bigTime == 10.0) return CatmullRom(c10, c11, c12, c13, smallTime);\n    if (bigTime == 11.0) return CatmullRom(c11, c12, c13, c00, smallTime);\n    if (bigTime == 12.0) return CatmullRom(c12, c13, c00, c01, smallTime);\n    if (bigTime == 13.0) return CatmullRom(c13, c00, c01, c02, smallTime);\n    return vec4(0.0);\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale terrain features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t// small scale noise for variation\n\tfinal = min(final, length(p) - 1.99);\t// sphere in center\n    final = min(final, p.y + waterLevel);\t// water\n\t//final = min(final, length(p-camLookat) - 0.3);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n/*    if (iTime == 0.0)\t// for debugging with manual camera\n    {\n        camPos = cXX.xyz;\n        camLookat = vec3(0.0)*cXX.xyz;\n    }*/\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(5.2); \t// prp\n\n    // set time for moving camera along path\n    float timeLine = iTime*0.2 + camPathOffset;\n    camFacing = camLookat + camPos;\n    // without this if condition, the mac doesn't work. mysterious. :(\n    if (iTime != -1.0)\n    {\n        vec4 catmullA = CamPos(timeLine);\n        // get a smoother derivative even though the spline is not C2 continuous.\n        // Also look ahead a bit so the camera leads the motion\n        vec4 catmullB = CamPos(timeLine + 0.3);\n#ifdef MOTION_BLUR\n        vec4 catmullC = CamPos(timeLine + 0.004);\t// adjust for camera motion blur\n        vec4 catmullBlur = mix(catmullA, catmullC, Hash2d(uv));\t// motion blur along camera path\n        camPos = catmullBlur.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullBlur.w);\n#else\n        camPos = catmullA.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullA.w);\n#endif\n        camFacing = RotateY(camFacing, -mx);\n    \tcamLookat = camPos + camFacing;\n    }\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.05;\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n    for (int i = 0; i < 200; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.0075)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        t += dist * 0.25;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n    // This makes the sky fade at sunset\n    float skyMultiplier = saturate(sunDir.y+0.7);\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        /*if (pos.y <= waterLevel-2.995)\t// water waves?\n        {\n            normal += SpiralNoise3D(pos*32.0+vec3(iTime*8.0,0.0,0.0))*0.0001;\n            normal += SpiralNoise3D(pos*27.0+vec3(0.0,0.0, iTime* 10.333))*0.0001;\n            normal += SpiralNoiseD(pos*37.0+vec3(0.0,iTime* 14.333,0.0))*0.0002;\n        }*/\n        normal = normalize(normal);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        //ambient *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        float sunSet = saturate(sunDir.y*4.0); // sunset dims the sun\n        sunShadow = saturate(sunShadow) * sunSet;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // pulse the ball light source\n        vec3 ballGlow = vec3(0.1, 0.97, 0.1) * abs(SpiralNoise3D(vec3(iTime*1.3)));\n\n        // ------ Calculate texture color of the rock ------\n        // basic orange and white blended together with noise\n        vec3 texColor = mix(vec3(0.95, 1.0, 1.0),  vec3(0.9, 0.7, 0.5), pow(abs(SpiralNoise3D(pos*1.0)-1.0), 0.6) );\n        // make the undersides darker greenish\n        texColor = mix(vec3(0.2, 0.2, 0.1), texColor, saturate(normal.y));\n        // fade to reddish/orange closer to the water level\n        texColor = mix(texColor, vec3(0.64, 0.2, 0.1) , saturate(-0.4-pos.y));\n        // some more variation to the color vertically\n        texColor = mix(texColor, vec3(0.2, 0.13, 0.02) , pow(saturate(pos.y*0.125+0.5), 2.0));\n        // give the rock a stratified, layered look\n        float rockLayers = abs(cos(pos.y*1.5+ SpiralNoiseD(pos*vec3(1.0, 2.0, 1.0)*4.0)*0.2 ));\n        texColor += vec3(0.7, 0.4, 0.3)*(1.0-pow(rockLayers, 0.3));\n\n        // make the water orange. I'm trying for that \"nickel tailings\" look.\n        texColor = mix(texColor, vec3(1.4, 0.15, 0.05) + SpiralNoise3D(pos)*0.025, saturate((-pos.y-1.45)*17.0));\n        // make the sphere white\n        if (length(pos) <= 2.01) texColor = vec3(1.0);\n        // don't let it get too saturated or dark\n        texColor = max(texColor, 0.05);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(1.0, 0.75, 0.75) * saturate(dot(sunDir, normal)) * sunShadow*1.5;\n        // sky color, hemisphere light equation approximation, anbient occlusion, sunset multiplier\n        lightColor += vec3(1.0,0.3,0.6) * ( dot(sunDir, normal) * 0.5 + 0.5 ) * ambient * 0.25 * skyMultiplier;\n        // Make the ball cast light. Distance to the 4th light falloff looked best. Use local ambient occlusion.\n        float lp = length(pos) - 1.0;\n        lightColor += ambientS*(ballGlow*1.2 * saturate(dot(normal, -pos)*0.5+0.5) / (lp*lp*lp*lp));\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // Make the water reflect the sun (leaving out sky reflection for no good reason)\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunShadow * saturate(normal.y*normal.y) * saturate(-(pos.y+1.35)*16.0);\n\n        // make the ball itself glow\n        finalColor += pow(saturate(1.0 - length(pos)*0.4925), 0.65) * ballGlow*6.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.03));\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.5, 0.5), vec3(0.40, 0.25, 0.91), saturate(relVec.y))*skyMultiplier;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    //finalColor = vec3(Hash2d(uv)*0.91,  Hash2d(uv+47.0)*0.91, 0.0);\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// The noise function in this was inspired by IQ's \"Terrain Tubes\" shader. I never really figured out\n// his function completely, so I'm not sure of the exact similarities. It's nice though because it\n// works the same on all computers (I think). It's not based on a hash that changes from computer to \n// computer. That means I can finally rely on the terrain being the same and make a camera path. :)\n// It's also a much faster noise function, although it can look a bit repetitive.\n\n#define MOTION_BLUR\n#define MOVING_SUN\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    float t2 = t*t;\n    float t3 = t*t*t;\n    return 0.5 *((2.0 * p1) +\n                 (-p0 + p2) * t +\n    \t\t\t (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n    \t\t\t (-p0 + 3.0 * p1- 3.0 * p2 + p3) * t3);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoiseD(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        n += abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\n// These are the xyz camera positions and a left/right facing angle relative to the path line\n// I think webgl glsl can only access arrays using a constant, so I'm writing all these out.\n// Someone please tell me if I'm wrong.\nvec4 c00 = vec4(3.5, 2.0, 13.1, 0.0);\t// start point\nvec4 c01 = vec4(12.5, 2.2, 17.0, 0.0);\t// run up to canyon 2 before hole in large rock face\nvec4 c02 = vec4(21.5, 4.0, 8.1, 0.0);\t// canyon 2 before hole in large rock face\nvec4 c03 = vec4(21.0, 5.0, 1.1, -0.5);\t// before hole in large rock face\nvec4 c04 = vec4(17.8, 5.4, -0.2, 0.0);\t// hole in large rock face\nvec4 c05 = vec4(14.7, 2.5, 1.4, 0.0);\t// after hole in large rock face\nvec4 c06 = vec4(7.9, 2.3, -2.1, 0.0);\nvec4 c07 = vec4(0.5, -0.7, -3.5, 1.0);\nvec4 c08 = vec4(-3.0, -1.0, -3.5, 1.3);\nvec4 c09 = vec4(-3.5, -1.0, 4.0, 1.3);\nvec4 c10 = vec4(3.0, -0.7, 3.3, 0.8);\nvec4 c11 = vec4(3.5, -1.0, -4.75, 0.0);\nvec4 c12 = vec4(-6.0, -0.2, 1.0, 3.14);\nvec4 c13 = vec4(-6.0, -1.0, 5.5, 0.0);\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nfloat camPathOffset = 0.0;\t// where to start on the camera path - parametric t var for catmull-rom spline\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\nfloat waterLevel = 1.5;\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamPos(float t)\n{\n    float tt = t * float(NUM_CAM_POINTS);\n    int i = int(tt);\n    if (i >= NUM_CAM_POINTS - 1)\n        return camPoints[NUM_CAM_POINTS - 1];\n    float t0 = float(i);\n    float t1 = t0 + 1.0;\n    float t2 = t1 + 1.0;\n    float t3 = t2 + 1.0;\n    vec4 p0 = camPoints[i];\n    vec4 p1 = camPoints[i + 1];\n    vec4 p2, p3;\n    if (i == 0)\n    {\n        p2 = camPoints[i + 2];\n        p3 = camPoints[i + 3];\n    }\n    else if (i == NUM_CAM_POINTS - 2)\n    {\n        p2 = camPoints[i + 1];\n        p3 = camPoints[i];\n    }\n    else\n    {\n        p2 = camPoints[i + 2];\n        p3 = camPoints[i + 3];\n    }\n    vec4 h0 = (p2 - p0) / 6.0;\n    vec4 h1 = (p3 - p1) / 6.0;\n    float t = tt - t0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    vec4 a = (2.0 * p1 - 2.0 * p2 + h0 + h1);\n    vec4 b = (-3.0 * p1 + 3.0 * p2 - 2.0 * h0 - h1);\n    vec4 c = h0;\n    vec4 d = p1;\n    return a * t3 + b * t2 + c * t + d;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale terrain features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t// small scale noise for variation\n\tfinal = min(final, length(p) - 1.99);\t// sphere in center\n    final = min(final, p.y + waterLevel);\t// water\n\t//final = min(final, length(p-camLookat) - 0.3);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n/*    if (iTime == 0.0)\t// for debugging with manual camera\n    {\n        camPos = cXX.xyz;\n        camLookat = vec3(0.0)*cXX.xyz;\n    }*/\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(5.2); \t// prp\n\n    // set time for moving camera along path\n    float timeLine = iTime*0.2 + camPathOffset;\n    camFacing = camLookat + camPos;\n    // without this if condition, the mac doesn't work. mysterious. :(\n    if (iTime != -1.0)\n    {\n        vec4 catmullA = CamPos(timeLine);\n        // get a smoother derivative even though the spline is not C2 continuous.\n        // Also look ahead a bit so the camera leads the motion\n        vec4 catmullB = CamPos(timeLine + 0.3);\n#ifdef MOTION_BLUR\n        vec4 catmullC = CamPos(timeLine + 0.004);\t// adjust for camera motion blur\n        vec4 catmullBlur = mix(catmullA, catmullC, Hash2d(uv));\t// motion blur along camera path\n        camPos = catmullBlur.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullBlur.w);\n#else\n        camPos = catmullA.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullA.w);\n#endif\n        camFacing = RotateY(camFacing, -mx);\n    \tcamLookat = camPos + camFacing;\n    }\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.05;\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n    for (int i = 0; i < 200; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.0075)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        t += dist * 0.25;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n    // This makes the sky fade at sunset\n    float skyMultiplier = saturate(sunDir.y+0.7);\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        /*if (pos.y <= waterLevel-2.995)\t// water waves?\n        {\n            normal += SpiralNoise3D(pos*32.0+vec3(iTime*8.0,0.0,0.0))*0.0001;\n            normal += SpiralNoise3D(pos*27.0+vec3(0.0,0.0, iTime* 10.333))*0.0001;\n            normal += SpiralNoiseD(pos*37.0+vec3(0.0,iTime* 14.333,0.0))*0.0002;\n        }*/\n        normal = normalize(normal);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        //ambient *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        float sunSet = saturate(sunDir.y*4.0); // sunset dims the sun\n        sunShadow = saturate(sunShadow) * sunSet;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // pulse the ball light source\n        vec3 ballGlow = vec3(0.1, 0.97, 0.1) * abs(SpiralNoise3D(vec3(iTime*1.3)));\n\n        // ------ Calculate texture color of the rock ------\n        // basic orange and white blended together with noise\n        vec3 texColor = mix(vec3(0.95, 1.0, 1.0),  vec3(0.9, 0.7, 0.5), pow(abs(SpiralNoise3D(pos*1.0)-1.0), 0.6) );\n        // make the undersides darker greenish\n        texColor = mix(vec3(0.2, 0.2, 0.1), texColor, saturate(normal.y));\n        // fade to reddish/orange closer to the water level\n        texColor = mix(texColor, vec3(0.64, 0.2, 0.1) , saturate(-0.4-pos.y));\n        // some more variation to the color vertically\n        texColor = mix(texColor, vec3(0.2, 0.13, 0.02) , pow(saturate(pos.y*0.125+0.5), 2.0));\n        // give the rock a stratified, layered look\n        float rockLayers = abs(cos(pos.y*1.5+ SpiralNoiseD(pos*vec3(1.0, 2.0, 1.0)*4.0)*0.2 ));\n        texColor += vec3(0.7, 0.4, 0.3)*(1.0-pow(rockLayers, 0.3));\n\n        // make the water orange. I'm trying for that \"nickel tailings\" look.\n        texColor = mix(texColor, vec3(1.4, 0.15, 0.05) + SpiralNoise3D(pos)*0.025, saturate((-pos.y-1.45)*17.0));\n        // make the sphere white\n        if (length(pos) <= 2.01) texColor = vec3(1.0);\n        // don't let it get too saturated or dark\n        texColor = max(texColor, 0.05);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(1.0, 0.75, 0.75) * saturate(dot(sunDir, normal)) * sunShadow*1.5;\n        // sky color, hemisphere light equation approximation, anbient occlusion, sunset multiplier\n        lightColor += vec3(1.0,0.3,0.6) * ( dot(sunDir, normal) * 0.5 + 0.5 ) * ambient * 0.25 * skyMultiplier;\n        // Make the ball cast light. Distance to the 4th light falloff looked best. Use local ambient occlusion.\n        float lp = length(pos) - 1.0;\n        lightColor += ambientS*(ballGlow*1.2 * saturate(dot(normal, -pos)*0.5+0.5) / (lp*lp*lp*lp));\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // Make the water reflect the sun (leaving out sky reflection for no good reason)\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunShadow * saturate(normal.y*normal.y) * saturate(-(pos.y+1.35)*16.0);\n\n        // make the ball itself glow\n        finalColor += pow(saturate(1.0 - length(pos)*0.4925), 0.65) * ballGlow*6.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.03));\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.5, 0.5), vec3(0.40, 0.25, 0.91), saturate(relVec.y))*skyMultiplier;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    //finalColor = vec3(Hash2d(uv)*0.91,  Hash2d(uv+47.0)*0.91, 0.0);\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// This will lower the framerate, but looks kinda cool\n//#define TOO_MUCH_FRACTAL\n\n//#define MOVING_SUN\nfloat outerSphereRad = 3.5;\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u) * 43758.5453);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\n// Variables for animating and rotating the sides of the object\nfloat chunkAnim = 0.0;\nmat3 rotMat;\nvec3 rotDir;\nfloat rotAmount;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = 0; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n       // wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n*500.0;\n}\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    //p += (1.0/p.y)*0.6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    if (dot(p, rotDir) > 1.0) p *= rotMat;\n\n    // Repeat our position so we can carve out many cylindrical-like things from our solid\n    vec3 rep = fract(p)-0.5;\n    //final = max(final, -(length(rep.xz*rep.xz)*1.0 - 0.0326));\n    float final = -(length(rep.xy*rep.xz) - 0.109);\n    final = max(final, -(length(rep.zy) - 0.33));\n\n    //final = max(final, -(length(rep.xz*rep.xz) - 0.03));\n    //final = max(final, -(length(rep.yz*rep.yz) - 0.03));\n    //final = max(final, -(length(rep.xy*rep.xy) - 0.030266));\n\n    // Repeat the process of carving things out for smaller scales\n    vec3 rep2 = fract(rep*2.0)-0.5;\n    final = max(final, -(length(rep2.xz)*0.5 - 0.125));\n    final = max(final, -(length(rep2.xy)*0.5 - 0.125));\n    final = max(final, -(length(rep2.zy)*0.5 - 0.125));\n\n    vec3 rep3 = fract(rep2*3.0)-0.5;\n    final = max(final, -(length(rep3.xz)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.xy)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.zy)*0.1667 - 0.25*0.1667));\n\n#ifdef TOO_MUCH_FRACTAL\n    vec3 rep4 = fract(rep3*3.0)-0.5;\n    final = max(final, -(length(rep4.xz)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.xy)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.yz)*0.0555 - 0.25*0.0555));\n\n    vec3 rep5 = fract(rep4*3.0)-0.5;\n    final = max(final, -(length(rep5.xz)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.xy)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.yz)*0.0185 - 0.25*0.0185));\n#endif\n\n    // Cut out stuff outside of outer sphere\n    final = max(final, (length(p) - outerSphereRad));\n    // Carve out inner sphere\n    final = max(final, -(length(p) - 2.8));\n    //final = max(final, abs(p.x) - 2.0);\t// for that space station look\n    //final = (length(p) - outerSphereRad);\t// for debugging texture and lighting\n    // Slice the object in a 3d grid so it can rotate like a rubik's cube\n    float slice = 0.02;\n    vec3 grid = -abs(fract(p.xyz)) + slice;\n    final = max(final, grid.x);\n    final = max(final, grid.y);\n    final = max(final, grid.z);\n    //final = min(final, abs(p.y));\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.8+0.1;//*PI/2.01;\n    // move camera in and out of the sphere\n    float smallTime = iTime*0.2;\n    float inOut = pow(abs(-cos(smallTime)), 0.6)* sign(-cos(smallTime));\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.35+inOut*2.0);\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n\n\t// -------------------------------- animate ---------------------------------------\n    float localTime = iTime*0.5;\n    float floorTime = floor(localTime);\n    float zeroToOne = max(0.0,fract(localTime)*1.0-0.0);// *4.0-3.0);\n    // This is the 0..1 for the rotation\n    chunkAnim = smoothstep(0.0, 1.0, zeroToOne);\n    // This is for brightening the outer sphere when a rotation happens\n    float pulse = saturate(-log(zeroToOne*30.0)+2.0);\n\n    //float mft = mod(floorTime, 6.0);\n    // Let's make it rotate a random part every time\n    float mft = Hash1d(floorTime * 2.34567);\n    mft = floor(mft * 5.9999);\t// get a random [0..6) integer\n    // randomize where the rotation slice is\n    float uglyRand = Hash1d(floorTime*1.234567);\n    uglyRand = floor(uglyRand*2.999);\t// get a random [0..3) integer\n    uglyRand = 1.0 / (uglyRand + 1.0);\n\n    // Check which axis we should rotate on and make a matrix for it.\n    if (mft <= 1.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(1.0, 0.0, 0.0,\n                      0.0, cos, sin,\n                      0.0, -sin, cos);\n        rotDir = vec3(uglyRand, 0.0, 0.0);\n    }\n    else if (mft <= 3.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, 0.0, -sin,\n                      0.0, 1.0, 0.0,\n                      sin, 0.0, cos);\n        rotDir = vec3(0.0, uglyRand, 0.0);\n    }\n    else\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, sin, 0.0,\n                      -sin, cos, 0.0,\n                      0.0, 0.0, 1.0);\n        rotDir = vec3(0.0, 0.0, uglyRand);\n    }\n    if (mod(floorTime, 2.0) == 0.0) rotDir = -rotDir;\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.15;\n\tfloat t = 0.2 + Hash2d(uv)*0.1;\t// fade things close to the camera\n\tfloat inc = 0.02;\n\tfloat maxDepth = 11.0;\n\tvec3 pos = vec3(0,0,0);\n    float glow = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 110; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.001)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        // Do some tricks for marching so that we can march the inner glow sphere\n        float lp = length(pos);\n        //if (lp > outerSphereRad + 0.9) break;\n        float inv = max(0.0, 0.1*dist / lp - 0.1);\n        dist = min(max(0.15,lp*0.6 - 0.1), dist);\n        glow += inv;//0.001\n        glow += 0.0025;\n\n        // no deformations messing up the distance function this time. Hurray for getting the math right!\n        t += dist;//*0.9995;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.0025, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.05;\n\t\tfor (int i = 0; i < 30; i++)\n        {\n            vec3 tempPos = pos + sunDir * iter;\n            //if (dot(tempPos, tempPos) > outerSphereRad*outerSphereRad+0.8) break;\n            if (iter > outerSphereRad + outerSphereRad) break;\n            float tempDist = DistanceToObject(tempPos);\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based???\n            iter += max(0.01, tempDist)*1.0;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // make sure the texture gets rotated along with the geometry.\n        vec3 posTex = pos;\n        if (dot(pos, rotDir) > 1.0) posTex = pos * rotMat;\n        posTex = abs(posTex);\t// make texture symetric so it doesn't pop after rotation\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(posTex*32.0);\n        n += noise(posTex*64.0);\n        n += noise(posTex*128.0);\n        n += noise(posTex*256.0);\n        n += noise(posTex*512.0);\n        n *= 0.8;\n        normal = normalize(normal + n*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(posTex*128.0);\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(posTex*8.0))-0.2));\n\n        // make outer edge a little brighter\n\t\ttexColor += (1.0 - vec3(19.0, 5.0, 2.0) * length(normalU))*ambientS;\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.5);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.5);\n        // blue glow light coming from the glow in the middle of the sphere\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n//        lightColor *= ambient;\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        //finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.003));\n        // pulse the outer edge color when something is about to rotate\n        if (dot(pos, rotDir) > 1.0) finalColor += vec3(0.2, 1.4, 0.8)*pulse*saturate(0.000001 / pow(abs(length(pos)-outerSphereRad), 2.0))*2.0;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        //finalColor = saturate(GetSunColorSmall(relVec, sunDir)*0.95-0.01);\n    }\n    // add the ray marching glow\n    finalColor += vec3(0.3, 0.5, 0.9) * glow;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// This will lower the framerate, but looks kinda cool\n//#define TOO_MUCH_FRACTAL\n\n//#define MOVING_SUN\nfloat outerSphereRad = 3.5;\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\n// Variables for animating and rotating the sides of the object\nfloat chunkAnim = 0.0;\nmat3 rotMat;\nvec3 rotDir;\nfloat rotAmount;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat z = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tn += abs(sin(p.x + p.y + p.z + z));\n\t\tp *= 1.3;\n\t\tz += 0.01;\n\t}\n\treturn n;\n}\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    //p += (1.0/p.y)*0.6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    if (dot(p, rotDir) > 1.0) p *= rotMat;\n\n    // Repeat our position so we can carve out many cylindrical-like things from our solid\n    vec3 rep = fract(p)-0.5;\n    //final = max(final, -(length(rep.xz*rep.xz)*1.0 - 0.0326));\n    float final = -(length(rep.xy*rep.xz) - 0.109);\n    final = max(final, -(length(rep.zy) - 0.33));\n\n    //final = max(final, -(length(rep.xz*rep.xz) - 0.03));\n    //final = max(final, -(length(rep.yz*rep.yz) - 0.03));\n    //final = max(final, -(length(rep.xy*rep.xy) - 0.030266));\n\n    // Repeat the process of carving things out for smaller scales\n    vec3 rep2 = fract(rep*2.0)-0.5;\n    final = max(final, -(length(rep2.xz)*0.5 - 0.125));\n    final = max(final, -(length(rep2.xy)*0.5 - 0.125));\n    final = max(final, -(length(rep2.zy)*0.5 - 0.125));\n\n    vec3 rep3 = fract(rep2*3.0)-0.5;\n    final = max(final, -(length(rep3.xz)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.xy)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.zy)*0.1667 - 0.25*0.1667));\n\n#ifdef TOO_MUCH_FRACTAL\n    vec3 rep4 = fract(rep3*3.0)-0.5;\n    final = max(final, -(length(rep4.xz)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.xy)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.yz)*0.0555 - 0.25*0.0555));\n\n    vec3 rep5 = fract(rep4*3.0)-0.5;\n    final = max(final, -(length(rep5.xz)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.xy)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.yz)*0.0185 - 0.25*0.0185));\n#endif\n\n    // Cut out stuff outside of outer sphere\n    final = max(final, (length(p) - outerSphereRad));\n    // Carve out inner sphere\n    final = max(final, -(length(p) - 2.8));\n    //final = max(final, abs(p.x) - 2.0);\t// for that space station look\n    //final = (length(p) - outerSphereRad);\t// for debugging texture and lighting\n    // Slice the object in a 3d grid so it can rotate like a rubik's cube\n    float slice = 0.02;\n    vec3 grid = -abs(fract(p.xyz)) + slice;\n    final = max(final, grid.x);\n    final = max(final, grid.y);\n    final = max(final, grid.z);\n    //final = min(final, abs(p.y));\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.8+0.1;//*PI/2.01;\n    // move camera in and out of the sphere\n    float smallTime = iTime*0.2;\n    float inOut = pow(abs(-cos(smallTime)), 0.6)* sign(-cos(smallTime));\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.35+inOut*2.0);\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n\n\t// -------------------------------- animate ---------------------------------------\n    float localTime = iTime*0.5;\n    float floorTime = floor(localTime);\n    float zeroToOne = max(0.0,fract(localTime)*1.0-0.0);// *4.0-3.0);\n    // This is the 0..1 for the rotation\n    chunkAnim = smoothstep(0.0, 1.0, zeroToOne);\n    // This is for brightening the outer sphere when a rotation happens\n    float pulse = saturate(-log(zeroToOne*30.0)+2.0);\n\n    //float mft = mod(floorTime, 6.0);\n    // Let's make it rotate a random part every time\n    float mft = Hash1d(floorTime * 2.34567);\n    mft = floor(mft * 5.9999);\t// get a random [0..6) integer\n    // randomize where the rotation slice is\n    float uglyRand = Hash1d(floorTime*1.234567);\n    uglyRand = floor(uglyRand*2.999);\t// get a random [0..3) integer\n    uglyRand = 1.0 / (uglyRand + 1.0);\n\n    // Check which axis we should rotate on and make a matrix for it.\n    if (mft <= 1.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(1.0, 0.0, 0.0,\n                      0.0, cos, sin,\n                      0.0, -sin, cos);\n        rotDir = vec3(uglyRand, 0.0, 0.0);\n    }\n    else if (mft <= 3.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, 0.0, -sin,\n                      0.0, 1.0, 0.0,\n                      sin, 0.0, cos);\n        rotDir = vec3(0.0, uglyRand, 0.0);\n    }\n    else\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, sin, 0.0,\n                      -sin, cos, 0.0,\n                      0.0, 0.0, 1.0);\n        rotDir = vec3(0.0, 0.0, uglyRand);\n    }\n    if (mod(floorTime, 2.0) == 0.0) rotDir = -rotDir;\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.15;\n\tfloat t = 0.2 + Hash2d(uv)*0.1;\t// fade things close to the camera\n\tfloat inc = 0.02;\n\tfloat maxDepth = 11.0;\n\tvec3 pos = vec3(0,0,0);\n    float glow = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 110; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.001)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        // Do some tricks for marching so that we can march the inner glow sphere\n        float lp = length(pos);\n        //if (lp > outerSphereRad + 0.9) break;\n        float inv = max(0.0, 0.1*dist / lp - 0.1);\n        dist = min(max(0.15,lp*0.6 - 0.1), dist);\n        glow += inv;//0.001\n        glow += 0.0025;\n\n        // no deformations messing up the distance function this time. Hurray for getting the math right!\n        t += dist;//*0.9995;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.0025, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.05;\n\t\tfor (int i = 0; i < 30; i++)\n        {\n            vec3 tempPos = pos + sunDir * iter;\n            //if (dot(tempPos, tempPos) > outerSphereRad*outerSphereRad+0.8) break;\n            if (iter > outerSphereRad + outerSphereRad) break;\n            float tempDist = DistanceToObject(tempPos);\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based???\n            iter += max(0.01, tempDist)*1.0;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // make sure the texture gets rotated along with the geometry.\n        vec3 posTex = pos;\n        if (dot(pos, rotDir) > 1.0) posTex = pos * rotMat;\n        posTex = abs(posTex);\t// make texture symetric so it doesn't pop after rotation\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(posTex*32.0);\n        n += noise(posTex*64.0);\n        n += noise(posTex*128.0);\n        n += noise(posTex*256.0);\n        n += noise(posTex*512.0);\n        n *= 0.8;\n        normal = normalize(normal + n*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(posTex*128.0);\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(posTex*8.0))-0.2));\n\n        // make outer edge a little brighter\n\t\ttexColor += (1.0 - vec3(19.0, 5.0, 2.0) * length(normalU))*ambientS;\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.5);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.5);\n        // blue glow light coming from the glow in the middle of the sphere\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n//        lightColor *= ambient;\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        //finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.003));\n        // pulse the outer edge color when something is about to rotate\n        if (dot(pos, rotDir) > 1.0) finalColor += vec3(0.2, 1.4, 0.8)*pulse*saturate(0.000001 / pow(abs(length(pos)-outerSphereRad), 2.0))*2.0;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        //finalColor = saturate(GetSunColorSmall(relVec, sunDir)*0.95-0.01);\n    }\n    // add the ray marching glow\n    finalColor += vec3(0.3, 0.5, 0.9) * glow;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// This will lower the framerate, but looks kinda cool\n//#define TOO_MUCH_FRACTAL\n\n//#define MOVING_SUN\nfloat outerSphereRad = 3.5;\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\n// Variables for animating and rotating the sides of the object\nfloat chunkAnim = 0.0;\nmat3 rotMat;\nvec3 rotDir;\nfloat rotAmount;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = 0; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n       // wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n*500.0;\n}\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    // This is the distance to the sphere\n    float d = length(p);\n\n    // This is the distance to the box\n    vec3 q = abs(p) - vec3(0.5);\n    float d2 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n    // This is the distance to the cylinder\n    vec2 r = vec2(length(p.xz), p.y);\n    float d3 = length(max(vec2(0.5, 1.0), r)) + min(max(0.5, r.x), 0.0) + min(max(1.0, r.y), 0.0);\n\n    // This is the distance to the torus\n    vec2 s = vec2(length(p.xz) - 0.5, p.y);\n    float d4 = length(s) - 0.2;\n\n    // This is the distance to the sphere\n    float d5 = length(p.xy) - 0.5;\n\n    // This is the distance to the sphere\n    float d6 = length(p.xz) - 0.5;\n\n    // This is the distance to the sphere\n    float d7 = length(p.yz) - 0.5;\n\n    // This is the distance to the sphere\n    float d8 = length(p.xy) - 0.5;\n\n    // This is the distance to the sphere\n    float d9 = length(p.xz) - 0.5;\n\n    // This is the distance to the sphere\n    float d10 = length(p.yz) - 0.5;\n\n    // This is the distance to the sphere\n    float d11 = length(p.xy) - 0.5;\n\n    // This is the distance to the sphere\n    float d12 = length(p.xz) - 0.5;\n\n    // This is the distance to the sphere\n    float d// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.8+0.1;//*PI/2.01;\n    // move camera in and out of the sphere\n    float smallTime = iTime*0.2;\n    float inOut = pow(abs(-cos(smallTime)), 0.6)* sign(-cos(smallTime));\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.35+inOut*2.0);\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n\n\t// -------------------------------- animate ---------------------------------------\n    float localTime = iTime*0.5;\n    float floorTime = floor(localTime);\n    float zeroToOne = max(0.0,fract(localTime)*1.0-0.0);// *4.0-3.0);\n    // This is the 0..1 for the rotation\n    chunkAnim = smoothstep(0.0, 1.0, zeroToOne);\n    // This is for brightening the outer sphere when a rotation happens\n    float pulse = saturate(-log(zeroToOne*30.0)+2.0);\n\n    //float mft = mod(floorTime, 6.0);\n    // Let's make it rotate a random part every time\n    float mft = Hash1d(floorTime * 2.34567);\n    mft = floor(mft * 5.9999);\t// get a random [0..6) integer\n    // randomize where the rotation slice is\n    float uglyRand = Hash1d(floorTime*1.234567);\n    uglyRand = floor(uglyRand*2.999);\t// get a random [0..3) integer\n    uglyRand = 1.0 / (uglyRand + 1.0);\n\n    // Check which axis we should rotate on and make a matrix for it.\n    if (mft <= 1.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(1.0, 0.0, 0.0,\n                      0.0, cos, sin,\n                      0.0, -sin, cos);\n        rotDir = vec3(uglyRand, 0.0, 0.0);\n    }\n    else if (mft <= 3.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, 0.0, -sin,\n                      0.0, 1.0, 0.0,\n                      sin, 0.0, cos);\n        rotDir = vec3(0.0, uglyRand, 0.0);\n    }\n    else\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, sin, 0.0,\n                      -sin, cos, 0.0,\n                      0.0, 0.0, 1.0);\n        rotDir = vec3(0.0, 0.0, uglyRand);\n    }\n    if (mod(floorTime, 2.0) == 0.0) rotDir = -rotDir;\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.15;\n\tfloat t = 0.2 + Hash2d(uv)*0.1;\t// fade things close to the camera\n\tfloat inc = 0.02;\n\tfloat maxDepth = 11.0;\n\tvec3 pos = vec3(0,0,0);\n    float glow = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 110; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.001)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        // Do some tricks for marching so that we can march the inner glow sphere\n        float lp = length(pos);\n        //if (lp > outerSphereRad + 0.9) break;\n        float inv = max(0.0, 0.1*dist / lp - 0.1);\n        dist = min(max(0.15,lp*0.6 - 0.1), dist);\n        glow += inv;//0.001\n        glow += 0.0025;\n\n        // no deformations messing up the distance function this time. Hurray for getting the math right!\n        t += dist;//*0.9995;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.0025, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.05;\n\t\tfor (int i = 0; i < 30; i++)\n        {\n            vec3 tempPos = pos + sunDir * iter;\n            //if (dot(tempPos, tempPos) > outerSphereRad*outerSphereRad+0.8) break;\n            if (iter > outerSphereRad + outerSphereRad) break;\n            float tempDist = DistanceToObject(tempPos);\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based???\n            iter += max(0.01, tempDist)*1.0;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // make sure the texture gets rotated along with the geometry.\n        vec3 posTex = pos;\n        if (dot(pos, rotDir) > 1.0) posTex = pos * rotMat;\n        posTex = abs(posTex);\t// make texture symetric so it doesn't pop after rotation\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(posTex*32.0);\n        n += noise(posTex*64.0);\n        n += noise(posTex*128.0);\n        n += noise(posTex*256.0);\n        n += noise(posTex*512.0);\n        n *= 0.8;\n        normal = normalize(normal + n*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(posTex*128.0);\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(posTex*8.0))-0.2));\n\n        // make outer edge a little brighter\n\t\ttexColor += (1.0 - vec3(19.0, 5.0, 2.0) * length(normalU))*ambientS;\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.5);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.5);\n        // blue glow light coming from the glow in the middle of the sphere\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n//        lightColor *= ambient;\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        //finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.003));\n        // pulse the outer edge color when something is about to rotate\n        if (dot(pos, rotDir) > 1.0) finalColor += vec3(0.2, 1.4, 0.8)*pulse*saturate(0.000001 / pow(abs(length(pos)-outerSphereRad), 2.0))*2.0;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        //finalColor = saturate(GetSunColorSmall(relVec, sunDir)*0.95-0.01);\n    }\n    // add the ray marching glow\n    finalColor += vec3(0.3, 0.5, 0.9) * glow;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// Set this to change detail level. [1 - 10] is a good range.\nconst int NUM_SIN_REPS = 9;\nconst int MAX_MARCH_REPS = 250;\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\n\nfloat localTime = 0.0;\n\n// some noise functions\nfloat Hash(float f)\n{\n    return fract(cos(f)*7561.0);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\n    float rand = fract(cos(f)*104729.0);\n    return rand;\n}\nvec2 Hash2(vec2 v)\n{\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nfloat mixS(float f0, float f1, float a)\n{\n    if (a < 0.5) return f0;\n    return f1;\n}\n\nfloat mixC(float f0, float f1, float a)\n{\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\n}\n\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 mixP2(vec2 v0, vec2 v1, float a)\n{\n    return mix(v0, v1, a*a*(3.0-2.0*a));\n}\n\nfloat mixSS(float f0, float f1, float a)\n{\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2dVec(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\n    vec2 xMix = mixP2(h0, h1, fr.x);\n    return mixC(xMix.x, xMix.y, fr.y);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = sunDot * sunDot;\n    float sunDot3 = sunDot2 * sunDot;\n    float sunDot4 = sunDot3 * sunDot;\n    float sunDot5 = sunDot4 * sunDot;\n    float sunDot6 = sunDot5 * sunDot;\n    float sunDot7 = sunDot6 * sunDot;\n    float sunDot8 = sunDot7 * sunDot;\n    float sunDot9 = sunDot8 * sunDot;\n    float sunDot10 = sunDot9 * sunDot;\n    float sunDot11 = sunDot10 * sunDot;\n    float sunDot12 = sunDot11 * sunDot;\n    float sunDot13 = sunDot12 * sunDot;\n    float sunDot14 = sunDot13 * sunDot;\n    float sunDot15 = sunDot14 * sunDot;\n    float sunDot16 = sunDot15 * sunDot;\n    float sunDot17 = sunDot16 * sunDot;\n    float sunDot18 = sunDot17 * sunDot;\n    float sunDot19 = sunDot18 * sunDot;\n    float sunDot20 = sunDot19 * sunDot;\n    float sunDot21 = sunDot20 * sunDot;\n    float sunDot22 = sunDot21 * sunDot;\n    float sunDot23 = sunDot22 * sunDot;\n    float sunDot24 = sunDot23 * sunDot;\n    float sunDot25 = sunDot24 * sunDot;\n    float sunDot26 = sunDot25 * sunDot;\n    float sunDot27 = sunDot26 * sunDot;\n    float sunDot28 = sunDot27// incomplete generation!\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\nfloat SinRep(float a)\n{\n    float h = 0.0;\n    float mult = 1.0;\n    for (int i = 0; i < NUM_SIN_REPS; i++)\n    {\n        h += (cos(a*mult)/(mult));\n        mult *= 2.0;\n    }\n    return h;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    float material = 0.0;\n    float h = 0.0;\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\n    material = h;\n    //h += SinRep(RotateX(p, p.y).z);\n    //h += SinRep(RotateZ(p, sin(h)).y);\n    //h += SinRep(RotateY(p, h*1.0).x);\n    //h += SinRep(p.x+h)*0.5;\n    //h += SinRep(p.y+h)*0.5;\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\n    return vec2(final, material);\n}\n\nfloat distFromSphere;\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 1.6;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\tvec3 iA, iB;\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.05, 0.0);\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n    // start and end the camera ray at the sphere intersections.\n    camPos = iA;\n    maxDepth = distance(iA, iB);\n\t// ray marching time\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\n            pos = camPos + relVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\n        }\n    }\n    else\n    {\n\t\tt = maxDepth + 1.0;\n        distAndMat.x = 1.0;\n    }\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // ------ Calculate texture color of the rock ------\n        // base texture can be swirled noise.\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\n        n = saturate(n*0.25 * 0.95 + 0.05);\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\n\n        // fade to reddish texture on outside\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\n        // give it green-blue texture that matches the shape using normal length\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\n        // Give it a reddish-rust color in the middle\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\n        // make sure it's not too saturated so it looks realistic\n        texColor = max(vec3(0.02),texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, anbient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // specular highlights - just a little\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog that fades to sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*/\n\n// Number of times the fractal repeats\n#define RECURSION_LEVELS 4\n// Animation splits the sphere in different directions\n// This ended up running a significantly slower fps and not looking very different. :(\n//#define SPLIT_ANIM\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t// gamma correct\n    return tex;\n}*/\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    vec3 envColor = vec3(0.0);\n\n    // Fade from bottom to top.\n    float fade = 1.0 - rayDir.y;\n    fade = pow(fade, 2.0);\n\n    // Add the softbox.\n    float softbox = 1.0 - dot(rayDir, sunDir);\n    softbox = pow(softbox, 2.0);\n    envColor += vec3(0.5, 0.7, 1.0) * softbox * 0.5;\n\n    // Add the lights.\n    float lightDist = 1.0;\n    float lightSize = 0.05;\n    vec3 lightDir = vec3(0.0, 0.0, 0.0);\n    lightDir.x = cos(Time * 0.1) * lightDist;\n    lightDir.z = sin(Time * 0.1) * lightDist;\n    lightDir.y = 0.0;\n    lightDir = normalize(lightDir);\n    float light = 1.0 - dot(rayDir, lightDir);\n    light = pow(light, 2.0);\n    envColor += vec3(1.0, 0.5, 0.2) * light * lightSize;\n\n    lightDir = vec3(0.0, 0.0, 0.0);\n    lightDir.x = cos(Time * 0.1 + 1.0) * lightDist;\n    lightDir.z = sin(Time * 0.1 + 1.0) * lightDist;\n    lightDir.y = 0.0;\n    lightDir = normalize(lightDir);\n    light = 1.0 - dot(rayDir, lightDir);\n    light = pow(light, 2.0);\n    envColor += vec3(0.2, 1.0, 0.5) * light * lightSize;\n\n/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t// fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        // rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);\n#endif\n        // main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        // subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        // calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        // subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        // make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t// 1/sqrt(2) to keep distance field normalized\n        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));\n        // subtract sphere from fins so they don't intersect the inner spheres.\n        // also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        // smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t// recurse\n        // do a material-min with the last iteration\n        final = matMin(final, vec2(d, float(i)));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25/blender);\n#endif\n        // Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        // Scale things for the next iteration / recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    // Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matMin(final, vec2(d, 6.0));\n    return final;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 distMat = sphereIter(p, 5.2 / outness, cut);\n    return distMat;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 24.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    // intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 5.6);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        // ray marching time\n        for (int i = 0; i < 290; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * 0.7;\n            //if (t > maxDepth) break;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    // --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\t//if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        // Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + normal*0.02;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);// vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        //texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);// sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        //if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        // reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;\n        finalColor += refColor * 0.35 * ambient;// * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n    //finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    // vignette?\n    //finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    //finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*/\n\n// Number of times the fractal repeats\n#define RECURSION_LEVELS 4\n// Animation splits the sphere in different directions\n// This ended up running a significantly slower fps and not looking very different. :(\n//#define SPLIT_ANIM\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t// gamma correct\n    return tex;\n}*/\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t// fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        // rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);\n#endif\n        // main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        // subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        // calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        // subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        // make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t// 1/sqrt(2) to keep distance field normalized\n        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));\n        // subtract sphere from fins so they don't intersect the inner spheres.\n        // also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        // smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t// recurse\n        // do a material-min with the last iteration\n        final = matMin(final, vec2(d, float(i)));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25/blender);\n#endif\n        // Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        // Scale things for the next iteration / recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    // Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matMin(final, vec2(d, 6.0));\n    return final;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 distMat = sphereIter(p, 5.2 / outness, cut);\n    return distMat;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 24.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    // intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 5.6);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        // ray marching time\n        for (int i = 0; i < 290; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * 0.7;\n            //if (t > maxDepth) break;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    // --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\t//if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        // Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + normal*0.02;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);// vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        //texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);// sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        //if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        // reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;\n        finalColor += refColor * 0.35 * ambient;// * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n    //finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    // vignette?\n    //finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    //finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*/\n\n// Number of times the fractal repeats\n#define RECURSION_LEVELS 4\n// Animation splits the sphere in different directions\n// This ended up running a significantly slower fps and not looking very different. :(\n//#define SPLIT_ANIM\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t// gamma correct\n    return tex;\n}*/\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t// fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        // rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);\n#endif\n        // main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        // subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        // calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        // subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        // make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t// 1/sqrt(2) to keep distance field normalized\n        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));\n        // subtract sphere from fins so they don't intersect the inner spheres.\n        // also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        // smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t// recurse\n        // do a material-min with the last iteration\n        final = matMin(final, vec2(d, float(i)));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25/blender);\n#endif\n        // Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        // Scale things for the next iteration / recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    // Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matMin(final, vec2(d, 6.0));\n    return final;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 distMat = sphereIter(p, 5.2 / outness, cut);\n    return distMat;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 posToSphere = spherePos - pos;\n    float t = dot(posToSphere, dirVecPLZNormalizeMeFirst);\n    if (t < 0.0)\n        return -1.0;\n    float d2 = dot(posToSphere, posToSphere) - t * t;\n    if (d2 > rad * rad)\n        return -1.0;\n    return t - sqrt(rad * rad - d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 24.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    // intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 5.6);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        // ray marching time\n        for (int i = 0; i < 290; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * 0.7;\n            //if (t > maxDepth) break;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    // --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\t//if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        // Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + normal*0.02;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);// vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        //texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);// sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        //if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        // reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;\n        finalColor += refColor * 0.35 * ambient;// * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n    //finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    // vignette?\n    //finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    //finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*/\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t// gamma correct\n    return tex;\n}*/\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t// fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\n\nconst float thick = 0.85;\nconst float spacer = 0.01;\nconst float thickSpace = thick - spacer;\nfloat Disc(vec3 p, float scale)\n{\n    float len = length(p.xz);\n    // infinite cylinder\n    float dist = len - scale;\n    // cut out the inner disc\n    dist = max(dist, -(len - thick*scale));\n    //dist = max(dist, -(length(p.xz + vec2(thick*scale, 0.0)) - thick*scale*0.15));\n    // cut off half the disc because that looks cool maybe.\n    dist = max(dist, -p.z);\n    // make it flat, but with nice rounded edges so reflections look good. (slow)\n    dist = -smin(-dist, -(abs(p.y)-0.025), 0.015*scale);\n    //dist = max(dist, abs(p.y)-0.025);\n    return dist;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 d = vec2(0.0);\n    d.x = DistanceToSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    d.y = DistanceToSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    return d;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.125;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime - 0.125;\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 21.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    // intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 8.0);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        // ray marching time\n        for (int i = 0; i < 120; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // move along the ray\n            t += distAndMat.x;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            //marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    // --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\t//if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        // Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + ref*0.3;// normal*0.02;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 9.0) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);// vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        //texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n        //texColor += vec3(1.0, 0.0, 0.0) * 8.0/length(pos);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);// sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n       // if (distAndMat.y == 6.0) finalColor += vec3(0.91, 0.032, 0.01)*0.2;\n        //if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        // reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;// * (length(normalU)/smallVec.x-0.875)*8.0;\n        finalColor += refColor * 0.35 * ambient;// * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n    //finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    // vignette?\n    //finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    //finalColor *= 1.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n\n//\n// Computes the curvature of a parametric curve f(x) as \n//\n// c(f) = |f'|^3 / | f' x f''|\n//\n// More info here: https://en.wikipedia.org/wiki/Curvature\n//\n\n\n//----------------------------------------\n\nvec3 a, b, c, m, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y = sin(p.x * 2.0) * 0.5 + 0.5;\n    p.z = sin(p.x * 2.0) * 0.5 + 0.5;\n    return p;\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return pow(length(r1),3.0) / length(cross(r1,r2));\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); // clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        // compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        // light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n\n//\n// Computes the curvature of a parametric curve f(x) as \n//\n// c(f) = |f'|^3 / | f' x f''|\n//\n// More info here: https://en.wikipedia.org/wiki/Curvature\n//\n\n\n//----------------------------------------\n\nvec3 a, b, c, m, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    vec3 p = map(t);\n    float e = 0.001;\n    vec3 dp = map(t + e) - map(t - e);\n    return normalize(dp);\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return pow(length(r1),3.0) / length(cross(r1,r2));\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); // clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        // compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        // light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n\n//\n// Computes the curvature of a parametric curve f(x) as \n//\n// c(f) = |f'|^3 / | f' x f''|\n//\n// More info here: https://en.wikipedia.org/wiki/Curvature\n//\n\n\n//----------------------------------------\n\nvec3 a, b, c, m, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    return d2p;\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return pow(length(r1),3.0) / length(cross(r1,r2));\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); // clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        // compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        // light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n\n//\n// Computes the curvature of a parametric curve f(x) as \n//\n// c(f) = |f'|^3 / | f' x f''|\n//\n// More info here: https://en.wikipedia.org/wiki/Curvature\n//\n\n\n//----------------------------------------\n\nvec3 a, b, c, m, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return pow(length(r1),3.0) / length(cross(r1,r2));\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( dot(pa-h*ba,pa-h*ba), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); // clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        // compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        // light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n\n//\n// Computes the curvature of a parametric curve f(x) as \n//\n// c(f) = |f'|^3 / | f' x f''|\n//\n// More info here: https://en.wikipedia.org/wiki/Curvature\n//\n\n\n//----------------------------------------\n\nvec3 a, b, c, m, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return pow(length(r1),3.0) / length(cross(r1,r2));\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec3 ab = b-a;\n    vec3 da = a-o;\n    vec3 db = b-o;\n    float t = dot(da,d);\n    float l = dot(ab,ab);\n    float p = clamp( t/l, 0.0, 1.0 );\n    vec3 c = a + p*ab;\n    vec3 dc = c-o;\n    return vec2( dot(dc,dc), p );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); // clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        // compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        // light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Signed distance to a 2D rounded box. Tutorials explaining\n// how it works: \n//\n// https://www.youtube.com/watch?v=62-pRVZuS5c\n// https://www.youtube.com/watch?v=s5NGeUV2EyU\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n  vec2 w = abs(p) - b;\n  float d = length(max(w,0.0)) + min(max(w.x,w.y),0.0);\n  return d - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tvec2 si = vec2(0.9,0.6) + 0.3*cos(iTime+vec2(0,2));\n    vec4 ra = 0.3 + 0.3*cos( 2.0*iTime + vec4(0,1,2,3) );\n    ra = min(ra,min(si.x,si.y));\n\n\tfloat d = sdRoundBox( p, si, ra );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundBox(m, si, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return a - floor(a);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat length8(vec2 v)\n{\n\treturn pow(pow(abs(v.x),8.0) + pow(abs(v.y), 8.0), 1.0/8.0);\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n   \tfloat a = atan(p.x, p.z);\n    float subs = 2.0;\n\ta = sin(a*subs+localTime*4.0+offset*3.234567);\n\tvec2 q = vec2(length(p.xz)-t.x-a*0.1,p.y);\n\treturn length8(q)-t.y;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat length8(vec2 v)\n{\n    return max(abs(v.x), abs(v.y));\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n   \tfloat a = atan(p.x, p.z);\n    float subs = 2.0;\n\ta = sin(a*subs+localTime*4.0+offset*3.234567);\n\tvec2 q = vec2(length(p.xz)-t.x-a*0.1,p.y);\n\treturn length8(q)-t.y;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat length8(vec2 v)\n{\n\treturn pow(pow(abs(v.x),8.0) + pow(abs(v.y), 8.0), 1.0/8.0);\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n   \tfloat a = atan(p.x, p.z);\n    float subs = 2.0;\n\ta = sin(a*subs+localTime*4.0+offset*3.234567);\n\tvec2 q = vec2(length(p.xz)-t.x-a*0.1,p.y);\n\treturn length8(q)-t.y;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat length8(vec2 v)\n{\n\treturn pow(pow(abs(v.x),8.0) + pow(abs(v.y), 8.0), 1.0/8.0);\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q) - t.y + offset;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat length8(vec2 v)\n{\n\treturn pow(pow(abs(v.x),8.0) + pow(abs(v.y), 8.0), 1.0/8.0);\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n   \tfloat a = atan(p.x, p.z);\n    float subs = 2.0;\n\ta = sin(a*subs+localTime*4.0+offset*3.234567);\n\tvec2 q = vec2(length(p.xz)-t.x-a*0.1,p.y);\n\treturn length8(q)-t.y;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n    vec3 balloonCenter = vec3(0.0, 0.0, 0.0);\n    vec3 balloonSize = vec3(1.0, 1.0, 1.0);\n    vec3 balloonPosition = currentRayPosition - balloonCenter;\n    balloonPosition.y = abs(balloonPosition.y);\n    balloonPosition.z = abs(balloonPosition.z);\n    balloonPosition.x = abs(balloonPosition.x);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.y);\n    balloonPosition.x = max(balloonPosition.x, balloonPosition.z);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){\n\n  // distance to thing 1\n  float d1 = distance( thing1, vUv );\n  // distance to thing 2\n  float d2 = distance( thing2, vUv );\n\n  // if d1 is less than d2\n  if( d1 < d2 ){\n    // return thing 1\n    return thing1;\n  }\n  // if d2 is less than d1\n  if( d2 < d1 ){\n    // return thing 2\n    return thing2;\n  }\n  // if they are equal\n  if( d1 == d2 ){\n    // return thing 1\n    return thing1;\n  }\n\n  // return thing 1\n  return thing1;\n\n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n    // This is the distance to the closest thing in the world\n    float closestDistance = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance2 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance3 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance4 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance5 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance6 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance7 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance8 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance9 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance10 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance11 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance12 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance13 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance14 = 10000.0;\n\n    // This is the distance to the closest thing in the world\n    float closestDistance1// incomplete generation!\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n\n\t// We are going to use a small value to figure out\n\t// the direction of the surface.\n\tfloat epsilon = 0.0001;\n\n\t// We are going to use the SDF function to figure out\n\t// the direction of the surface.\n\tvec3 normal = vec3(\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.\n\t\t// We are going to use the SDF function to figure out\n\t\t// the direction of the surface.// incomplete generation!\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n    return vec3(0.0, 0.0, 0.0);\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit, vec3 normalOfSurface ){\n  vec3 color = vec3(0.0,0.0,0.0);\n  vec3 lightDirection = normalize(vec3(1.0,1.0,1.0));\n  float lightIntensity = max(0.0,dot(normalOfSurface,lightDirection));\n  color = vec3(lightIntensity);\n  return color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo, vec3 eyePosition, vec3 rayDirection ){\n\n\t// this is the color of the world\n\tvec3 worldColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the sky\n\tvec3 skyColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the ground\n\tvec3 groundColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the sun\n\tvec3 sunColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the moon\n\tvec3 moonColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the stars\n\tvec3 starColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the clouds\n\tvec3 cloudColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the fog\n\tvec3 fogColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the water\n\tvec3 waterColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the sand\n\tvec3 sandColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the grass\n\tvec3 grassColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the tree\n\tvec3 treeColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the rock\n\tvec3 rockColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the snow\n\tvec3 snowColor = vec3(0.0,0.0,0.0// incomplete generation!\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n"], ["// Made by Dominik Schmid\n// MIT license\n\n\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n  return pow(x, log(b) / log(0.5));\n}\n\n\nfloat PI = 3.1415926;\n#define t iTime\n#define bias_number 0.4*sin(iTime) + 0.5\n\nfloat formula(float x) {\n    return bias(x, bias_number);\n}\nbool isClose(float a, float b) { return abs(a-b) < 0.005; }\nvoid plot(out vec4 fragColor, in vec2 uv )\n{\n    float px = 2.0 / iResolution.x;\n    float py = 2.0 / iResolution.y;\n   \n\n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 blue  = vec4(0.1, 0.1, 0.9, 1.0);\n    if (isClose(uv.x, 0.5)) color = blue;\n    if (isClose(uv.x, 1.5)) color = blue;\n    if (isClose(uv.y, 0.5)) color = blue;\n    if (isClose(uv.y, 1.0)) color = blue;\n\t\n    \n    float x = (uv.x - .5);\n    float y = formula(x);\n    float y2 = formula(x + px*.5);\n    float dy = max(px*4.0, abs(y2 - y));\n    \n    float modX = floor(.5+10.0*(uv.x-.5)) / 10.0;\n    float fmodX = formula(modX);\n\n    // 2d samples\n    // ok but wonky and horribly inefficient\n    float avg = 0.0;\n    float screen_y = 0.0;\n    float stroke = 1.0;\n    float dist = 0.0;\n    for (float step_x = -1.0; step_x < 1.0; step_x += .1)\n    {\n        x = (uv.x - .5 +3.0*stroke*(-step_x)*px);\n        \n        for (float step_y = -1.0; step_y < 1.0; step_y += .1)\n        {\n            \n            y = formula(x);\n            screen_y = uv.y + stroke*(-step_y)*py;\n            dist = step_x*step_x + step_y*step_y;\n            dist /= stroke*stroke;\n            avg += (1.0 - min(1.0,(abs(screen_y-.5  - .5*y)/py))) /dist;\n        }\n    }\n    avg /= 100.0;\n    color.r -= avg;\n    color.g -= avg; \n    color.b -= avg;\n    fragColor = color;\n}\n\n\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    p /= iResolution.xy;\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.2377))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec2 p){\n    return clamp(rand(p)*1.005, 0.0, 1.0); \n}\n\n\nvoid applyBias(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(\n        bias(rand_inclusive(fragCoord), bias_number)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (isClose(uv.x, 0.5)) {\n        fragColor = vec4(0.5);\n    }\n    else if (uv.x < 0.5) {\n        uv += vec2(0.4, 0.3);\n        uv -= vec2(0.5);\n        uv *= vec2(3.0, 1.0);\n        uv += vec2(0.5);\n        //uv += vec2(0.5, 0.0);\n        plot(fragColor, uv);\n    }\n    else {\n        applyBias(fragColor, fragCoord);\n    }\n}"], ["// Made by Dominik Schmid\n// MIT license\n\n\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}\n\n\nfloat PI = 3.1415926;\n#define t iTime\n#define bias_number 0.4*sin(iTime) + 0.5\n\nfloat formula(float x) {\n    return bias(x, bias_number);\n}\nbool isClose(float a, float b) { return abs(a-b) < 0.005; }\nvoid plot(out vec4 fragColor, in vec2 uv )\n{\n    float px = 2.0 / iResolution.x;\n    float py = 2.0 / iResolution.y;\n   \n\n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 blue  = vec4(0.1, 0.1, 0.9, 1.0);\n    if (isClose(uv.x, 0.5)) color = blue;\n    if (isClose(uv.x, 1.5)) color = blue;\n    if (isClose(uv.y, 0.5)) color = blue;\n    if (isClose(uv.y, 1.0)) color = blue;\n\t\n    \n    float x = (uv.x - .5);\n    float y = formula(x);\n    float y2 = formula(x + px*.5);\n    float dy = max(px*4.0, abs(y2 - y));\n    \n    float modX = floor(.5+10.0*(uv.x-.5)) / 10.0;\n    float fmodX = formula(modX);\n\n    // 2d samples\n    // ok but wonky and horribly inefficient\n    float avg = 0.0;\n    float screen_y = 0.0;\n    float stroke = 1.0;\n    float dist = 0.0;\n    for (float step_x = -1.0; step_x < 1.0; step_x += .1)\n    {\n        x = (uv.x - .5 +3.0*stroke*(-step_x)*px);\n        \n        for (float step_y = -1.0; step_y < 1.0; step_y += .1)\n        {\n            \n            y = formula(x);\n            screen_y = uv.y + stroke*(-step_y)*py;\n            dist = step_x*step_x + step_y*step_y;\n            dist /= stroke*stroke;\n            avg += (1.0 - min(1.0,(abs(screen_y-.5  - .5*y)/py))) /dist;\n        }\n    }\n    avg /= 100.0;\n    color.r -= avg;\n    color.g -= avg; \n    color.b -= avg;\n    fragColor = color;\n}\n\n\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec2 p){\n    return clamp(rand(p)*1.005, 0.0, 1.0); \n}\n\n\nvoid applyBias(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(\n        bias(rand_inclusive(fragCoord), bias_number)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (isClose(uv.x, 0.5)) {\n        fragColor = vec4(0.5);\n    }\n    else if (uv.x < 0.5) {\n        uv += vec2(0.4, 0.3);\n        uv -= vec2(0.5);\n        uv *= vec2(3.0, 1.0);\n        uv += vec2(0.5);\n        //uv += vec2(0.5, 0.0);\n        plot(fragColor, uv);\n    }\n    else {\n        applyBias(fragColor, fragCoord);\n    }\n}"], ["// Made by Dominik Schmid\n// MIT license\n\n\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}\n\n\nfloat PI = 3.1415926;\n#define t iTime\n#define bias_number 0.4*sin(iTime) + 0.5\n\nfloat formula(float x) {\n    return bias(x, bias_number);\n}\nbool isClose(float a, float b) { return abs(a-b) < 0.005; }\nvoid plot(out vec4 fragColor, in vec2 uv )\n{\n    float px = 2.0 / iResolution.x;\n    float py = 2.0 / iResolution.y;\n   \n\n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 blue  = vec4(0.1, 0.1, 0.9, 1.0);\n    if (isClose(uv.x, 0.5)) color = blue;\n    if (isClose(uv.x, 1.5)) color = blue;\n    if (isClose(uv.y, 0.5)) color = blue;\n    if (isClose(uv.y, 1.0)) color = blue;\n\t\n    \n    float x = (uv.x - .5);\n    float y = formula(x);\n    float y2 = formula(x + px*.5);\n    float dy = max(px*4.0, abs(y2 - y));\n    \n    float modX = floor(.5+10.0*(uv.x-.5)) / 10.0;\n    float fmodX = formula(modX);\n\n    // 2d samples\n    // ok but wonky and horribly inefficient\n    float avg = 0.0;\n    float screen_y = 0.0;\n    float stroke = 1.0;\n    float dist = 0.0;\n    for (float step_x = -1.0; step_x < 1.0; step_x += .1)\n    {\n        x = (uv.x - .5 +3.0*stroke*(-step_x)*px);\n        \n        for (float step_y = -1.0; step_y < 1.0; step_y += .1)\n        {\n            \n            y = formula(x);\n            screen_y = uv.y + stroke*(-step_y)*py;\n            dist = step_x*step_x + step_y*step_y;\n            dist /= stroke*stroke;\n            avg += (1.0 - min(1.0,(abs(screen_y-.5  - .5*y)/py))) /dist;\n        }\n    }\n    avg /= 100.0;\n    color.r -= avg;\n    color.g -= avg; \n    color.b -= avg;\n    fragColor = color;\n}\n\n\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    p /= iResolution.xy;\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.2377))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec2 p){\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n\nvoid applyBias(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(\n        bias(rand_inclusive(fragCoord), bias_number)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (isClose(uv.x, 0.5)) {\n        fragColor = vec4(0.5);\n    }\n    else if (uv.x < 0.5) {\n        uv += vec2(0.4, 0.3);\n        uv -= vec2(0.5);\n        uv *= vec2(3.0, 1.0);\n        uv += vec2(0.5);\n        //uv += vec2(0.5, 0.0);\n        plot(fragColor, uv);\n    }\n    else {\n        applyBias(fragColor, fragCoord);\n    }\n}"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/d1, 0.0, 1.0 );\n    return mix( d2, d1, h ) - h*h*h*d1*(1.0/6.0);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    return min(d1,d2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    q.xy *= mat2(cos(yaw),-sin(yaw),sin(yaw),cos(yaw));\n    return q;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x) return o1;\n    return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    float d = 1e10;\n    float id = -1.;\n\n    // sphere\n    float d1 = length(p) - 1.;\n    if (d1 < d) {\n        d = d1;\n        id = 1.;\n    }\n\n    // box\n    vec3 q = abs(p) - vec3(.5,.5,.5);\n    float d2 = length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n    if (d2 < d) {\n        d = d2;\n        id = 2.;\n    }\n\n    // torus\n    vec2 q1 = vec2(length(p.xz) -.5, p.y);\n    float d3 = length(q1) -.1;\n    if (d3 < d) {\n        d = d3;\n        id = 3.;\n    }\n\n    // cylinder\n    vec2 q2 = vec2(length(p.xz) -.2, p.y);\n    float d4 = length(q2) -.1;\n    if (d4 < d) {\n        d = d4;\n        id = 4.;\n    }\n\n    // cone\n    vec2 q3 = vec2(length(p.xz), p.y);\n    float d5 = length(q3) -.2;\n    if (d5 < d) {\n        d = d5;\n        id = 5.;\n    }\n\n    // plane\n    float d6 = p.y + 1.;\n    if (d6 < d) {\n        d = d6;\n        id = 6.;\n    }\n\n    return vec2(d, id);\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfloat hit = 0.0;\n\tfor(int i=0; i<MAX_MARCHING_STEPS; i++)\n\t{\n\t\tvec3 p = ro + rd*t;\n\t\tfloat d = map(p);\n\t\tif(d<0.001)\n\t\t{\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tif(t>MAX_DISTANCE)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec2(t, hit);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = map(pos);\n        if (d < 0.001)\n        {\n            col = vec3(0.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross( vec3(sin(roll), cos(roll),0.0), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{\n    if (id == 0.0) return color0;\n    if (id == 1.0) return color1;\n    if (id == 2.0) return color2;\n    if (id == 3.0) return color3;\n    if (id == 4.0) return color4;\n    if (id == 5.0) return color5;\n    if (id == 6.0) return color6;\n    if (id == 7.0) return color7;\n    if (id == 8.0) return color8;\n    if (id == 9.0) return color9;\n    if (id == 10.0) return color10;\n    if (id == 11.0) return color11;\n    if (id == 12.0) return color12;\n    if (id == 13.0) return color13;\n    if (id == 14.0) return color14;\n    if (id == 15.0) return color15;\n    if (id == 16.0) return color16;\n    if (id == 17.0) return color17;\n    if (id == 18.0) return color18;\n    if (id == 19.0) return color19;\n    if (id == 20.0) return color20;\n    if (id == 21.0) return color21;\n    if (id == 22.0) return color22;\n    if (id == 23.0) return color23;\n    if (id == 24.0) return color24;\n    if (id == 25.0) return color25;\n    if (id == 26.0) return color26;\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float h = clamp(0.5 - 0.5*(d2-d1)/(d2+d1), 0.0, 1.0);\n    float d = mix(d2, d1, h);\n    float a1 = o1.a;\n    float a2 = o2.a;\n    float a = mix(a2, a1, h);\n    vec3 c1 = o1.rgb;\n    vec3 c2 = o2.rgb;\n    vec3 c = mix(c2, c1, h);\n    return vec4(d, c, a);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n\treturn max(d1,-d2);\n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    return lightPos;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // ~~~~~~~ sphere\n    // sphere is a simple object, it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n// .x = distance travelled by ray\n// .y = hit object's ID\n// .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    float t = 0.0;\n    float hitID = 0.0;\n    float hitDist = 1000.0;\n    float hitRatio = 0.0;\n    float hitDist2 = 1000.0;\n    float hitID2 = 0.0;\n    float hitRatio2 = 0.0;\n    float hitDist3 = 1000.0;\n    float hitID3 = 0.0;\n    float hitRatio3 = 0.0;\n    float hitDist4 = 1000.0;\n    float hitID4 = 0.0;\n    float hitRatio4 = 0.0;\n    float hitDist5 = 1000.0;\n    float hitID5 = 0.0;\n    float hitRatio5 = 0.0;\n    float hitDist6 = 1000.0;\n    float hitID6 = 0.0;\n    float hitRatio6 = 0.0;\n    float hitDist7 = 1000.0;\n    float hitID7 = 0.0;\n    float hitRatio7 = 0.0;\n    float hitDist8 = 1000.0;\n    float hitID8 = 0.0;\n    float hitRatio8 = 0.0;\n    float hitDist9 = 1000.0;\n    float hitID9 = 0.0;\n    float hitRatio9 = 0.0;\n    float hitDist10 = 1000.0;\n    float hitID10 = 0.0;\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    float shadow = 1.0;\n    vec3 dir = lp - sp;\n    float len = length(dir);\n    dir = normalize(dir);\n    float t = 0.0;\n    for(int i = 0; i < 10; i++)\n    {\n        vec3 pos = sp + dir * t;\n        float h = getHeight(pos);\n        float d = (h - t) / len;\n        shadow = min(shadow, smoothstep(0.0, 1.0, d));\n        t += 0.25;\n    }\n    return shadow;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    float d = 0.0;\n    float t = 0.0;\n    float tMax = 1.0;\n    float tMin = 0.0;\n    float tStep = 0.001;\n    float tMaxStep = 100.0;\n    float tMaxStepCount = 0.0;\n    float tMaxStepCountMax = 100.0;\n    float tMaxStepCountMin = 10.0;\n    float tMaxStepCountMinStep = 0.001;\n    float tMaxStepCountMinStepMax = 0.01;\n    float tMaxStepCountMinStepMaxStep = 0.00001;\n    float tMaxStepCountMinStepMaxStepMax = 0.0000001;\n    float tMaxStepCountMinStepMaxStepMaxStep = 0.000000001;\n    float tMaxStepCountMinStepMaxStepMaxStepMax = 0.00000000001;\n    float tMaxStepCountMinStepMaxStepMaxStepMaxStep = 0.0000000000001;\n    float tMaxStepCountMinStepMaxStepMaxStepMaxStepMax = 0.000000000000001;\n    float tMaxStepCountMinStepMaxStepMaxStepMaxStepMaxStep = 0.00000000000000001;\n    float tMaxStepCountMinStepMaxStepMaxStepMaxStepMaxStepMax = 0.0000000000000000001;\n    float tMaxStepCountMinStepMaxStepMaxStepMaxStepMaxStepMaxStep = 0.00000// incomplete generation!\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    vec3 n = oN;\n    vec3 d = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = p + (rand3(p + float(i)) - 0.5) * 0.01;\n        vec3 nr = normal(r);\n        d += nr - n;\n        n = nr;\n    }\n    return d;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n\treturn pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-fs.x*d);\n    fogAmount = clamp(fogAmount,0.0,1.0);\n    vec3 fogColor = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor2 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor3 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor4 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor5 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor6 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor7 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor8 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor9 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor10 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor11 = mix(fc1,fc2,// incomplete generation!\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n\treturn cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 col = vec3(0.0);\n    vec2 p = vec2(fCoord.x,fCoord.y);\n    vec2 p2 = vec2(fCoord.x,fCoord.y);\n    vec2 p3 = vec2(fCoord.x,fCoord.y);\n    vec2 p4 = vec2(fCoord.x,fCoord.y);\n    vec2 p5 = vec2(fCoord.x,fCoord.y);\n    vec2 p6 = vec2(fCoord.x,fCoord.y);\n    vec2 p7 = vec2(fCoord.x,fCoord.y);\n    vec2 p8 = vec2(fCoord.x,fCoord.y);\n    vec2 p9 = vec2(fCoord.x,fCoord.y);\n    vec2 p10 = vec2(fCoord.x,fCoord.y);\n    vec2 p11 = vec2(fCoord.x,fCoord.y);\n    vec2 p12 = vec2(fCoord.x,fCoord.y);\n    vec2 p13 = vec2(fCoord.x,fCoord.y);\n    vec2 p14 = vec2(fCoord.x,fCoord.y);\n    vec2 p15 = vec2(fCoord.x,fCoord.y);\n    vec2 p16 = vec2(fCoord.x,fCoord.y);\n    vec2 p17 = vec2(fCoord.x,fCoord.y);\n    vec2 p18 = vec2(fCoord.x,fCoord.y);\n    vec2 p19 = vec2(fCoord.x,fCoord.y);\n    vec2 p20 = vec// incomplete generation!\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n"], ["/**\n * Adapted from my Mandelbrot-JS Project\n * http://sparkx120.github.io/mandelbrot.html\n * https://github.com/Sparkx120/mandelbrot-js\n * \n * By: James Wake (SparkX120)\n * Copyright (c) 2016 James Wake\n * \n * MIT\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 uv_offset = uv - 0.5;\n    uv_offset *= 2.0;\n\n    vec2 uv_offset_orig = uv_orig - 0.5;\n    uv_offset_orig *= 2.0;\n\n    vec2 uv_offset_orig_scaled = uv_offset_orig * i// incomplete generation!\n\n/* Old Shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float iterations = 512.0;                             // Iterations to compute over\n    const float maxZoom    = 20.0;                              // Max Zoom Time\n    float scale  = 0.5*pow(2.0, mod(iTime, maxZoom));     // Set Scale to 2^time and Loop at MaxZoomTime\n    \n\tfloat width  = iResolution[0];                              // Width Height\n\tfloat height = iResolution[1];                              //\n      \n    float widthScalar  = 3.5/scale;                             // Always fit width\n    float heightScalar = 3.5*height/width/scale;                // scale height\n        \n    float Px = fragCoord.x;                                     // Set Pixel Position\n    float Py = fragCoord.y;                                     //\n    \n    vec2 offset   = vec2(0.0, 0.0);                             // Hacky solution for multiple coordinates\n    float modTime = mod(iTime/maxZoom, 3.0);\n    if(modTime >= 0.0 && modTime < 1.0){\n      offset = vec2(21.30899, -5.33795);                        // Coordinate 1\n    }\n    if(modTime >= 1.0 && modTime < 2.0){\n      offset = vec2(5.39307,-41.7374);                          // Coordinate 2\n    }\n    if(modTime >= 2.0 && modTime < 3.0){\n      offset = vec2(48.895,0.0);                                // Coordinate 3\n    }\n    \n    float xDelta = iResolution.x/100.0*offset.x;                // Mandelbrot space offset\n    float yDelta = iResolution.y/100.0*offset.y;                //\n    \n    float Tx = Px-xDelta*scale;                                 // X-Y Translation\n    float Ty = Py-yDelta*scale;\n    float x0 = widthScalar/width*Tx - widthScalar/1.4;          // Scaling and Aspect Correction\n    float y0 = heightScalar/height*Ty - heightScalar/2.0;       //\n    float x  = 0.0;\n\tfloat y  = 0.0;\n    \n    float iteration = iterations;\n    int end = 0;\n    \n    for (float i=0.0; i < iterations; i++) {                    // Escape Time Computation\n        float xtemp = x*x-y*y+x0;\n        y = 2.0*x*y+y0;\n        x = xtemp;\n        if(x*x+y*y > 4.0){\n            iteration = i;\n            break;\n        }\n    }\n    \n    float intensity = iteration == iterations ? 0.0 : iteration/iterations;\n    \n    // Custom Color Shader based on log functions\n    float redGreen = intensity*((-1.0/4.0)*log((-1.0/11.112347)*intensity+0.09)-0.25);\n    float blue = (intensity*(1.0-2.4*log(intensity+0.0000000001)));\n    \n\tfragColor = vec4(redGreen,redGreen, blue, 1.0);\n}*/"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 11.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p)\n{\n    float time = localTime*2.0;\n    float cylRadBig = 1.0;\n    float cylRadSmall = 0.05;\n    float freq = 4.0;\n    float braidRad = 0.15;\n    float angle = atan(p.z, p.x);\n    float cylDist = length(p.xz) - cylRadBig;\n    vec3 cylWarp = vec3(cylDist, p.y, angle);\n    float amp = sin(angle + time) * 0.5 + 0.5;\n\n    float theta = angle*freq;\n    vec2 wave1 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave1 *= amp;\n    //float d = length(cylWarp.xy + wave1) - cylRadSmall;\n    float d = sdBox(vec3(cylWarp.xy + wave1, 0.0), vec3(cylRadSmall));\n    float final = d;\n\n    theta = angle*freq + TAU / 3.0;\n    vec2 wave2 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave2 *= amp;\n    //d = length(cylWarp.xy + wave2) - cylRadSmall;\n    d = sdBox(vec3(cylWarp.xy + wave2, 0.0), vec3(cylRadSmall));\n    final = smin(final, d, 0.1);\n\n    theta = angle*freq - TAU / 3.0;\n    vec2 wave3 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave3 *= amp;\n    //d = length(cylWarp.xy + wave3) - cylRadSmall;\n    d = sdBox(vec3(cylWarp.xy + wave3, 0.0), vec3(cylRadSmall));\n    final = smin(final, d, 0.1);\n\n    vec2 matd = vec2(final, fract((angle+time) / TAU+0.5));\n    float sliver = cyl(cylWarp.xy, 0.03);\n    glow += 1.0 / (sliver * sliver * sliver * sliver + 1.0);\n    //sliver = max(sliver, abs(fract(cylWarp.z*freq-2.0*localTime)-0.5)-0.3);\n    matd = matMin(matd, vec2(sliver, -1.0));\n    return matd;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.2;\n    uv /= zoom;\n\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n#ifndef MANUAL_CAMERA\n    camPos = vec3(0.0);\n    camPos.y = sin(localTime*0.125)*3.0;\n    camPos.z = cos(localTime*0.125)*3.0;\n    camUp.y = camPos.z;\n    camUp.z = -camPos.y;\n    camUp = normalize(camUp);\n#else\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distMat = vec2(1.0, 0.0);\n\tfloat t = 0.0 + Hash2d(uv)*1.6;\t// random dither glow by moving march count start position\n\tconst float maxDepth = 6.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n    float marchCount = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 80; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = camPos + rayVec * t;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distMat = DistanceToObject(pos);\n\n        // Move along the ray.\n        // Leave room for error by multiplying in case distance function isn't exact.\n        t += distMat.x * 0.8;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distMat.x) < smallVal)) break;\n\n        // Glow if we're close to the part of the ring with the braid.\n        float cyc = (-sin(distMat.y * TAU))*0.5+0.7;\n        // This function is similar to a gaussian fall-off of glow when you're close\n        // to an object.\n        // http://thetamath.com/app/y=(1)/((x*x+1))\n        marchCount += cyc / (distMat.x * distMat.x + 1.0);\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n    // Save off ray-march glows so they don't get messed up when we call the distance\n    // function again to get the normal\n\tfloat glowSave = glow;\n    float marchSave = marchCount;\n    marchCount = 0.0;\n    glow = 0.0;\n\n    // default to blueish background color.\n\tvec3 finalColor = vec3(0.09, 0.15, 0.35);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(distMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 texColor = vec3(0.0, 0.0, 0.1);\n        if (distMat.y < 0.0) texColor = vec3(0.6, 0.3, 0.1)*110.0;\n\n        finalColor = texColor;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    // add the ray marching glows\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*0.00625;\n    finalColor += vec3(1.0, 0.5, 0.3) * marchSave*0.05;\n\n    // vignette\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(saturate(finalColor));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 11.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p)\n{\n    // The distance to the nearest surface\n    float d = 10000.0;\n\n    // The material number\n    float m = 0.0;\n\n    // The distance to the sphere\n    float dSphere = length(p) - 1.0;\n\n    // If the distance to the sphere is less than the current distance\n    if (dSphere < d)\n    {\n        // Update the distance\n        d = dSphere;\n\n        // Update the material number\n        m = 1.0;\n    }\n\n    // The distance to the box\n    vec3 q = abs(p) - vec3(1.0, 1.0, 1.0);\n    float dBox = min(max(q.x, max(q.y, q.z)), 0.0) + length(max(q, 0.0));\n\n    // If the distance to the box is less than the current distance\n    if (dBox < d)\n    {\n        // Update the distance\n        d = dBox;\n\n        // Update the material number\n        m = 2.0;\n    }\n\n    // Return the distance and the material number\n    return vec2(d, m);\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.2;\n    uv /= zoom;\n\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n#ifndef MANUAL_CAMERA\n    camPos = vec3(0.0);\n    camPos.y = sin(localTime*0.125)*3.0;\n    camPos.z = cos(localTime*0.125)*3.0;\n    camUp.y = camPos.z;\n    camUp.z = -camPos.y;\n    camUp = normalize(camUp);\n#else\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distMat = vec2(1.0, 0.0);\n\tfloat t = 0.0 + Hash2d(uv)*1.6;\t// random dither glow by moving march count start position\n\tconst float maxDepth = 6.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n    float marchCount = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 80; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = camPos + rayVec * t;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distMat = DistanceToObject(pos);\n\n        // Move along the ray.\n        // Leave room for error by multiplying in case distance function isn't exact.\n        t += distMat.x * 0.8;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distMat.x) < smallVal)) break;\n\n        // Glow if we're close to the part of the ring with the braid.\n        float cyc = (-sin(distMat.y * TAU))*0.5+0.7;\n        // This function is similar to a gaussian fall-off of glow when you're close\n        // to an object.\n        // http://thetamath.com/app/y=(1)/((x*x+1))\n        marchCount += cyc / (distMat.x * distMat.x + 1.0);\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n    // Save off ray-march glows so they don't get messed up when we call the distance\n    // function again to get the normal\n\tfloat glowSave = glow;\n    float marchSave = marchCount;\n    marchCount = 0.0;\n    glow = 0.0;\n\n    // default to blueish background color.\n\tvec3 finalColor = vec3(0.09, 0.15, 0.35);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(distMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 texColor = vec3(0.0, 0.0, 0.1);\n        if (distMat.y < 0.0) texColor = vec3(0.6, 0.3, 0.1)*110.0;\n\n        finalColor = texColor;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    // add the ray marching glows\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*0.00625;\n    finalColor += vec3(1.0, 0.5, 0.3) * marchSave*0.05;\n\n    // vignette\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(saturate(finalColor));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n"], ["/*\n\nCopyright (c) 2016 Valters Mednis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#define ITERATIONS_MAX 100\n#define EXIT_NUMBER 10.0\n#define ANTIALIAS_AMOUNT 2\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r5 = pow(r, 5.0);\n    float theta5 = 5.0 * theta;\n    return vec2(r5 * cos(theta5), r5 * sin(theta5));\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant)\n{\n    //This part is very similar to crude mandlebrot implementations\n    vec2 z = coord;\n    for(int i = 0; i < ITERATIONS_MAX; i++)\n    {\n        if((z.x * z.x < EXIT_NUMBER * EXIT_NUMBER) && (z.y * z.y < EXIT_NUMBER * EXIT_NUMBER) && ((z.x * z.x) + (z.y * z.y) < EXIT_NUMBER * EXIT_NUMBER))\n        {\n        \t//z = z^5 + c\n        \tz = complexPower5(z) + morphConstant;\n        }\n    }\n    \n    //Unlike mandelbrot and likes this is not colored according to the number of iterations\n    //it took to reach the exit number, but rather the according to the number itself after\n    //these iterations\n    if((z.x * z.x < EXIT_NUMBER * EXIT_NUMBER) || (z.y * z.y < EXIT_NUMBER * EXIT_NUMBER))\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2 sampleStep = 1.0 / iResolution.xy / float(ANTIALIAS_AMOUNT + 1);\n    for(int i = 1; i < ANTIALIAS_AMOUNT + 1; i++)\n    {\n        for(int j = 1; j < ANTIALIAS_AMOUNT + 1; j++)\n        {\n            vec2 currentPos = uv;\n            currentPos.x += sampleStep.x * float(i);\n            currentPos.y += sampleStep.y * float(j);\n            result += colorBiomorph((currentPos) * 4.0, constant);\n        }\n    }\n    return result / float(ANTIALIAS_AMOUNT * ANTIALIAS_AMOUNT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    //Position the Biomorph\n    if(iResolution.x > iResolution.y)\n    {\n    \tuv.x -= 0.5 * (iResolution.x / iResolution.y) - 0.1777;\n   \t\tuv.y -= 0.5;\n    }\n    else\n    {\n        uv.y -= 0.5 * (iResolution.y / iResolution.x);\n   \t\tuv.x -= 0.3333;\n    }\n    //Render the Biomorph\n    if(iMouse.z < 0.5)\n    {\n\t\tfragColor = antiAliasedBiomorph(uv, vec2(0.01 * sin(iTime / 4.0) + 0.15, 0.8));\n    }\n    else\n    {\n        fragColor = antiAliasedBiomorph(uv, iMouse.xy / iResolution.xy);\n    }\n}\n\n"], ["/*\n\nCopyright (c) 2016 Valters Mednis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#define ITERATIONS_MAX 100\n#define EXIT_NUMBER 10.0\n#define ANTIALIAS_AMOUNT 2\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\n    vec2 cRes = c;\n    for(int i = 1; i < 5; i++)\n    {\n        //Multiply the result by the original complex number\n    \tvec2 cResCopy = cRes;\n    \tcRes.x = (c.x * cResCopy.x) - (c.y * cResCopy.y);\n    \tcRes.y = (c.x * cResCopy.y) + (c.y * cResCopy.x);\n    }\n    return cRes;\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant)\n{\n    vec2 morphCoord = coord;\n    vec2 morphCoord2 = coord;\n    vec2 morphCoord3 = coord;\n    vec2 morphCoord4 = coord;\n    vec2 morphCoord5 = coord;\n    vec2 morphCoord6 = coord;\n    vec2 morphCoord7 = coord;\n    vec2 morphCoord8 = coord;\n    vec2 morphCoord9 = coord;\n    vec2 morphCoord10 = coord;\n    vec2 morphCoord11 = coord;\n    vec2 morphCoord12 = coord;\n    vec2 morphCoord13 = coord;\n    vec2 morphCoord14 = coord;\n    vec2 morphCoord15 = coord;\n    vec2 morphCoord16 = coord;\n    vec2 morphCoord17 = coord;\n    vec2 morphCoord18 = coord;\n    vec2 morphCoord19 = coord;\n    vec2 morphCoord20 = coord;\n    vec2 morphCoord21 = coord;\n    vec2 morphCoord22 = coord;\n    vec2 morphCoord23 = coord;\n    vec2 morphCoord24 = coord;\n    vec2 morphCoord25 = coord;\n    vec2 morphCoord26 = coord;\n    vec2 morphCoord27 = coord;\n    vec2 morphCoord28 = coord;\n    vec2 morphCoord29 = coord;\n    vec2 morphCoord30 = coord;\n    vec2 morphCoord31 = coord;\n    vec2 morphCoord32 = coord;\n    vec2 morphCoord33 = coord;\n    vec2 morphCoord34 = coord;\n    vec2 morphCoord35 = coord;\n    vec2 morphCoord36 = coord;\n    vec2 morphCoord37 = coord;\n    vec2 morphCoord38 = coord;\n    vec2 morphCoord39 = coord;\n    vec2 morphCoord40 = coord;\n    vec2 morphCoord41 = coord;\n    vec2 morphCoord42 = coord;\n    vec2 morphCoord43 = coord;\n    vec2 morphCoord44 = coord;\n    vec2 morphCoord45 =// incomplete generation!\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2 sampleStep = 1.0 / iResolution.xy / float(ANTIALIAS_AMOUNT + 1);\n    for(int i = 1; i < ANTIALIAS_AMOUNT + 1; i++)\n    {\n        for(int j = 1; j < ANTIALIAS_AMOUNT + 1; j++)\n        {\n            vec2 currentPos = uv;\n            currentPos.x += sampleStep.x * float(i);\n            currentPos.y += sampleStep.y * float(j);\n            result += colorBiomorph((currentPos) * 4.0, constant);\n        }\n    }\n    return result / float(ANTIALIAS_AMOUNT * ANTIALIAS_AMOUNT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    //Position the Biomorph\n    if(iResolution.x > iResolution.y)\n    {\n    \tuv.x -= 0.5 * (iResolution.x / iResolution.y) - 0.1777;\n   \t\tuv.y -= 0.5;\n    }\n    else\n    {\n        uv.y -= 0.5 * (iResolution.y / iResolution.x);\n   \t\tuv.x -= 0.3333;\n    }\n    //Render the Biomorph\n    if(iMouse.z < 0.5)\n    {\n\t\tfragColor = antiAliasedBiomorph(uv, vec2(0.01 * sin(iTime / 4.0) + 0.15, 0.8));\n    }\n    else\n    {\n        fragColor = antiAliasedBiomorph(uv, iMouse.xy / iResolution.xy);\n    }\n}\n\n"], ["/*\n\nCopyright (c) 2016 Valters Mednis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#define ITERATIONS_MAX 100\n#define EXIT_NUMBER 10.0\n#define ANTIALIAS_AMOUNT 2\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\n    vec2 cRes = c;\n    for(int i = 1; i < 5; i++)\n    {\n        //Multiply the result by the original complex number\n    \tvec2 cResCopy = cRes;\n    \tcRes.x = (c.x * cResCopy.x) - (c.y * cResCopy.y);\n    \tcRes.y = (c.x * cResCopy.y) + (c.y * cResCopy.x);\n    }\n    return cRes;\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant)\n{\n    //This part is very similar to crude mandlebrot implementations\n    vec2 z = coord;\n    for(int i = 0; i < ITERATIONS_MAX; i++)\n    {\n        if((z.x * z.x < EXIT_NUMBER * EXIT_NUMBER) && (z.y * z.y < EXIT_NUMBER * EXIT_NUMBER) && ((z.x * z.x) + (z.y * z.y) < EXIT_NUMBER * EXIT_NUMBER))\n        {\n        \t//z = z^5 + c\n        \tz = complexPower5(z) + morphConstant;\n        }\n    }\n    \n    //Unlike mandelbrot and likes this is not colored according to the number of iterations\n    //it took to reach the exit number, but rather the according to the number itself after\n    //these iterations\n    if((z.x * z.x < EXIT_NUMBER * EXIT_NUMBER) || (z.y * z.y < EXIT_NUMBER * EXIT_NUMBER))\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec4 color = vec4(0.0);\n    for (float x = 0.0; x < 2.0; x++)\n    {\n        for (float y = 0.0; y < 2.0; y++)\n        {\n            vec2 offset = vec2(x, y) / 2.0;\n            color += biomorph(uv + offset, constant);\n        }\n    }\n    return color / 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    //Position the Biomorph\n    if(iResolution.x > iResolution.y)\n    {\n    \tuv.x -= 0.5 * (iResolution.x / iResolution.y) - 0.1777;\n   \t\tuv.y -= 0.5;\n    }\n    else\n    {\n        uv.y -= 0.5 * (iResolution.y / iResolution.x);\n   \t\tuv.x -= 0.3333;\n    }\n    //Render the Biomorph\n    if(iMouse.z < 0.5)\n    {\n\t\tfragColor = antiAliasedBiomorph(uv, vec2(0.01 * sin(iTime / 4.0) + 0.15, 0.8));\n    }\n    else\n    {\n        fragColor = antiAliasedBiomorph(uv, iMouse.xy / iResolution.xy);\n    }\n}\n\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) {\n    return abs(fract(x) - 0.5);\n}\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n  vec2 p = uv - pA;\n  vec2 d = pB - pA;\n  vec2 n = vec2(-d.y, d.x);\n  float l = length(d);\n  float t = dot(p, d) / l;\n  float d1 = dot(p, n) / l;\n  float d2 = abs(t - 0.5) * l - (thick.x * 0.5);\n  float d3 = max(d1, d2);\n  float d4 = min(max(d1, -t * l), max(d1, (l - t) * l));\n  float d5 = min(d3, d4);\n  float d6 = (rounded * thick.y) - length(p - pA - d * clamp(t, 0.0, 1.0));\n  float d7 = min(d5, d6);\n  return (dashOn > 0.5)? d7 : d7 * 1000.0;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - pA;\n    float d1 = dot(p, d);\n    float d2 = dot(p, n);\n    float d3 = dot(pB - pA, n);\n    float d4 = dot(pB - pA, d);\n    float d5 = dot(pA - pB, d);\n    float d6 = dot(pA - pB, n);\n    float d7 = dot(pB - pA, pB - pA);\n    float d8 = dot(pA - pB, pA - pB);\n    float d9 = dot(p, p);\n    float d10 = dot(pA - pB, pA - pB);\n    float d11 = dot(pB - pA, pB - pA);\n    float d12 = dot(pA - pB, pA - pB);\n    float d13 = dot(pB - pA, pB - pA);\n    float d14 = dot(pA - pB, pA - pB);\n    float d15 = dot(pB - pA, pB - pA);\n    float d16 = dot(pA - pB, pA - pB);\n    float d17 = dot(pB - pA, pB - pA);\n    float d18 = dot(pA - pB, pA - pB);\n    float d19 = dot(pB - pA, pB - pA);\n    float d20 = dot(pA - pB, pA - pB);\n    float d21 = dot(pB - pA, pB - pA);\n    float d22 = dot(pA - pB, pA - pB);\n    float// incomplete generation!\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - (pA + pB) / 2.0;\n    vec2 w = abs(p - thick * n);\n    float d1 = max(dot(p, n), 0.0);\n    float d2 = max(dot(p, -n), 0.0);\n    float d3 = max(w.x, w.y);\n    float d4 = max(d1, d2);\n    float d5 = max(d3, outlineThick);\n    return d5;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    vec2 p = uv - pA;\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    float t = dot(p, n);\n    float l = dot(p, d);\n    float w = dot(thick, d);\n    float r = rounded * w;\n    float s = smoothstep(0.0, r, abs(t)) * smoothstep(0.0, r, abs(l - w));\n    return s;\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    vec2 p = uv - pA;\n    vec2 d = pB - pA;\n    float l = length(d);\n    d /= l;\n    float t = dot(p, d);\n    float tt = t / l;\n    float tt2 = tt * l;\n    float tt3 = tt2 - floor(tt2);\n    float tt4 = tt3 * l;\n    float tt5 = tt4 - floor(tt4);\n    float tt6 = tt5 / l;\n    float tt7 = tt6 * l;\n    float tt8 = tt7 - floor(tt7);\n    float tt9 = tt8 / l;\n    float tt10 = tt9 * l;\n    float tt11 = tt10 - floor(tt10);\n    float tt12 = tt11 / l;\n    float tt13 = tt12 * l;\n    float tt14 = tt13 - floor(tt13);\n    float tt15 = tt14 / l;\n    float tt16 = tt15 * l;\n    float tt17 = tt16 - floor(tt16);\n    float tt18 = tt17 / l;\n    float tt19 = tt18 * l;\n    float tt20 = tt19 - floor(tt19);\n    float tt21 = tt20 / l;\n    float tt22 = tt21 * l;\n    float tt23 = tt22 - floor(tt22);\n    float tt24 = tt23 / l;\n    float tt25 = tt24 * l;\n    float tt26 = tt25 - floor(tt25);\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    vec2 p = uv - pA;\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    float t = dot(p, n);\n    float d1 = dot(p, d) / dot(d, d);\n    float d2 = dot(p - d, n) / dot(n, n);\n    float d3 = dot(p - d, d) / dot(d, d);\n    float d4 = dot(p + d, n) / dot(n, n);\n    float d5 = dot(p + d, d) / dot(d, d);\n    float d6 = dot(p - d, -n) / dot(-n, -n);\n    float d7 = dot(p - d, -d) / dot(-d, -d);\n    float d8 = dot(p + d, -n) / dot(-n, -n);\n    float d9 = dot(p + d, -d) / dot(-d, -d);\n    float d10 = dot(p - d, n) / dot(n, n);\n    float d11 = dot(p - d, d) / dot(d, d);\n    float d12 = dot(p + d, n) / dot(n, n);\n    float d13 = dot(p + d, d) / dot(d, d);\n    float d14 = dot(p - d, -n) / dot(-n, -n);\n    float d15 = dot(p - d, -d) / dot(-d, -d);\n    float d16 = dot(p + d, -n) / dot(-n, -n);\n    float d17 = dot(p + d, -d) / dot(-d, -d);\n    float d18 = dot(p - d, n) / dot// incomplete generation!\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    vec2 d = uv - p;\n    float dist = length(d);\n    if (dist < 0.001) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = r\u00b7sqrt(1-n\u00b2)\n//\n// Derivation and more info in the link above\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a disk (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 DiskAABB( in vec3 cen, in vec3 nor, float rad )  // disk: center, normal, radius\n{\n    vec3 e = rad*sqrt( 1.0 - nor*nor );\n    return bound3( cen-e, cen+e );\n}\n\n\n// ray-disk intersection\nfloat iDisk( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 cen, in vec3 nor, float rad ) // disk: center, normal, radius\n{\n    float t = -dot(nor,ro-cen)/dot(nor,rd);\n    vec3  x = ro + rd*t;\n    return (length(x-cen)-rad)/dot(rd,nor);\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // disk animation\n\tvec3  disk_center = 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n\tvec3  disk_axis = normalize( sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0)) );\n    float disk_radius = 0.4 + 0.2*sin(iTime*1.3+0.5);\n\n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace disk\n    float t = iDisk( ro, rd, disk_center, disk_axis, disk_radius );\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3)*(0.7+0.2*abs(disk_axis.y));\n\t}\n\n    // compute bounding box for disk\n    bound3 bbox = DiskAABB( disk_center, disk_axis, disk_radius );\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = r\u00b7sqrt(1-n\u00b2)\n//\n// Derivation and more info in the link above\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a disk (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 DiskAABB( in vec3 cen, in vec3 nor, float rad )  // disk: center, normal, radius\n{\n    vec3 e = rad*sqrt( 1.0 - nor*nor );\n    return bound3( cen-e, cen+e );\n}\n\n\n// ray-disk intersection\nfloat iDisk( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 cen, in vec3 nor, float rad ) // disk: center, normal, radius\n{\n\tvec3  q = ro - cen;\n    float t = -dot(nor,q)/dot(rd,nor);\n    if( t<0.0 ) return -1.0;\n    vec3 d = q + rd*t;\n    if( dot(d,d)>(rad*rad) ) return -1.0;\n    return t;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // disk animation\n\tvec3  disk_center = 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n\tvec3  disk_axis = normalize( sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0)) );\n    float disk_radius = 0.4 + 0.2*sin(iTime*1.3+0.5);\n\n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace disk\n    float t = iDisk( ro, rd, disk_center, disk_axis, disk_radius );\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3)*(0.7+0.2*abs(disk_axis.y));\n\t}\n\n    // compute bounding box for disk\n    bound3 bbox = DiskAABB( disk_center, disk_axis, disk_radius );\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = r\u00b7sqrt(1-n\u00b2)\n//\n// Derivation and more info in the link above\n\n\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n// Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n// Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n// Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n    \n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 ba = pb-pa;\n    vec3 oa = vec3(0.0);\n    vec3 oc = vec3(0.0);\n    vec3 oe = vec3(0.0);\n    vec3 oq = vec3(0.0);\n    vec3 oi = vec3(0.0);\n    vec3 oj = vec3(0.0);\n    vec3 ok = vec3(0.0);\n    vec3 oe = vec3(0.0);\n    vec3 oq = vec3(0.0);\n    vec3 oi = vec3(0.0);\n    vec3 oj = vec3(0.0);\n    vec3 ok = vec3(0.0);\n    vec3 oe = vec3(0.0);\n    vec3 oq = vec3(0.0);\n    vec3 oi = vec3(0.0);\n    vec3 oj = vec3(0.0);\n    vec3 ok = vec3(0.0);\n    vec3 oe = vec3(0.0);\n    vec3 oq = vec3(0.0);\n    vec3 oi = vec3(0.0);\n    vec3 oj = vec3(0.0);\n    vec3 ok = vec3(0.0);\n    vec3 oe = vec3(0.0);\n    vec3 oq = vec3(0.0);\n    vec3 oi = vec3(0.0);\n    vec3 oj = vec3(0.0);\n    vec3 ok = vec3(0.0);\n    vec3 oe = vec3(0.// incomplete generation!\n\n// ray-cylinder intersetion (returns t and normal)\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a;\n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch ) return vec4( t1, normalize( oc+t1*rd - ca*y ) );\n    \n    // caps\n    float sy = sign(y);\n    float tp = (sy*ch - caoc)/card;\n    if( abs(b+a*tp)<h )\n    {\n        return vec4( tp, ca*sy );\n    }\n\n    return vec4(-1.0);\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera position\n        vec3 ro = vec3( -0.5, 0.4, 1.5 );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // cylidner animation\n        vec3  c_a =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n        vec3  c_b = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n        float c_r =  0.3 + 0.2*sin(iTime*1.3+0.5);\n\n\n        // render\n        vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n        // raytrace\n        vec4 tnor = iCylinder( ro, rd, c_a, c_b, c_r );\n        float t = tnor.x;\n        float tmin = 1e10;\n        if( t>0.0 )\n        {\n            tmin = t;\n            // shading/lighting\t\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            float dif = clamp( dot(nor,vec3(0.5,0.7,0.2)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = sqrt( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );\n            col *= vec3(1.0,0.75,0.3);\n        }\n\n\n        // compute bounding box of cylinder\n        bound3 bbox = CylinderAABB( c_a, c_b, c_r );\n\n        // raytrace bounding box\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 tbox = iBox( ro, rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = ro + rd*tbox.y;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = ro + rd*tbox.x;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0 - 0.5)/256.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = r\u00b7sqrt(1-n\u00b2)\n//\n// Derivation and more info in the link above\n\n\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n// Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n// Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n// Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n    \n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 a = pb - pa;\n    vec3 e = ra*sqrt( 1.0 - a*a/dot(a,a) );\n    \n    return bound3( min( pa - e, pb - e ),\n                   max( pa + e, pb + e ) );\n}\n\n// ray-cylinder intersetion (returns t and normal)\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float bardoc = dot(ba,rd*oc);\n    float ococ = dot(oc,oc);\n    float rarara = ra*ra;\n    float h = max( -bardoc, 0.0 );\n    float f = baba*rarara - bardoc*bardoc;\n    float t = -baba*rarara + baba*h*h;\n    if( t<0.0 ) return vec4(0.0);\n    t = sqrt( t );\n    float t0 = h/bard + t/baba;\n    float t1 = h/bard - t/baba;\n    if( t0>t1 ) swap(t0,t1);\n    if( t0<0.0 ) t0=t1;\n    if( t0<0.0 ) return vec4(0.0);\n    vec3 n = (oc+ba*t0/baba)/ra;\n    return vec4( t0, n );\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera position\n        vec3 ro = vec3( -0.5, 0.4, 1.5 );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // cylidner animation\n        vec3  c_a =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n        vec3  c_b = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n        float c_r =  0.3 + 0.2*sin(iTime*1.3+0.5);\n\n\n        // render\n        vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n        // raytrace\n        vec4 tnor = iCylinder( ro, rd, c_a, c_b, c_r );\n        float t = tnor.x;\n        float tmin = 1e10;\n        if( t>0.0 )\n        {\n            tmin = t;\n            // shading/lighting\t\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            float dif = clamp( dot(nor,vec3(0.5,0.7,0.2)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = sqrt( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );\n            col *= vec3(1.0,0.75,0.3);\n        }\n\n\n        // compute bounding box of cylinder\n        bound3 bbox = CylinderAABB( c_a, c_b, c_r );\n\n        // raytrace bounding box\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 tbox = iBox( ro, rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = ro + rd*tbox.y;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = ro + rd*tbox.x;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0 - 0.5)/256.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = r\u00b7sqrt(1-n\u00b2)\n//\n// Derivation and more info in the link above\n\n\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n// Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n// Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n// Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n    \n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 a = pb - pa;\n    vec3 e = ra*sqrt( 1.0 - a*a/dot(a,a) );\n    \n    return bound3( min( pa - e, pb - e ),\n                   max( pa + e, pb + e ) );\n}\n\n// ray-cylinder intersetion (returns t and normal)\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a;\n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch ) return vec4( t1, normalize( oc+t1*rd - ca*y ) );\n    \n    // caps\n    float sy = sign(y);\n    float tp = (sy*ch - caoc)/card;\n    if( abs(b+a*tp)<h )\n    {\n        return vec4( tp, ca*sy );\n    }\n\n    return vec4(-1.0);\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera position\n        vec3 ro = vec3( -0.5, 0.4, 1.5 );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // cylidner animation\n        vec3  c_a =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n        vec3  c_b = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n        float c_r =  0.3 + 0.2*sin(iTime*1.3+0.5);\n\n\n        // render\n        vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n        // raytrace\n        vec4 tnor = iCylinder( ro, rd, c_a, c_b, c_r );\n        float t = tnor.x;\n        float tmin = 1e10;\n        if( t>0.0 )\n        {\n            tmin = t;\n            // shading/lighting\t\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            float dif = clamp( dot(nor,vec3(0.5,0.7,0.2)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = sqrt( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );\n            col *= vec3(1.0,0.75,0.3);\n        }\n\n\n        // compute bounding box of cylinder\n        bound3 bbox = CylinderAABB( c_a, c_b, c_r );\n\n        // raytrace bounding box\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 tbox = iBox( ro, rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = ro + rd*tbox.y;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = ro + rd*tbox.x;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0 - 0.5)/256.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction. There's\n// only one sphere involved, not two.\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb-pa, oa = ro-pa;\n    float baba = dot(ba,ba), oaba = dot(oa,ba), oaoa = dot(oa,oa);\n    float t = clamp( (oaba - oaoa*baba)/baba, 0.0, baba );\n    vec3  hc = pa + ba*t;\n    return length(hc-ro) - r;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a, pa = p - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    vec3  d = pa - h*ba;\n    float l = length(d);\n    float o = 1.0 - max(0.0,dot(-d,n))*r*r/(l*l*l);\n    return sqrt(o*o*o);\n}\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n        \n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        float t = capIntersect( ro, rd, capA, capB, capR );\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = capNormal(pos, capA, capB, capR );\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            float occ = 0.5 + 0.5*nor.y;\n\n            vec3 w = normalize(capB-capA);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-capA)*mat3(u,v,w);\n            col = pattern( vec2(12.0,64.0)*vec2(atan(q.y,q.x),q.z) );\n\n\n            col *= vec3(0.2,0.3,0.4)*amb*occ + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        col = sqrt( col );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction. There's\n// only one sphere involved, not two.\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a;\n    vec3 pa = pos-a;\n    vec3 pb = pos-b;\n    vec3 n = normalize( cross( ba, pa ) );\n    vec3 n2 = normalize( cross( ba, pb ) );\n    return mix( n, n2, step( dot(pb,ba), 0.0 ) );\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a, pa = p - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    vec3  d = pa - h*ba;\n    float l = length(d);\n    float o = 1.0 - max(0.0,dot(-d,n))*r*r/(l*l*l);\n    return sqrt(o*o*o);\n}\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n        \n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        float t = capIntersect( ro, rd, capA, capB, capR );\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = capNormal(pos, capA, capB, capR );\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            float occ = 0.5 + 0.5*nor.y;\n\n            vec3 w = normalize(capB-capA);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-capA)*mat3(u,v,w);\n            col = pattern( vec2(12.0,64.0)*vec2(atan(q.y,q.x),q.z) );\n\n\n            col *= vec3(0.2,0.3,0.4)*amb*occ + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        col = sqrt( col );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing normals analytically has the benefit of being faster if you need them often, \n// while numerical normals are easier to filter for antialiasing. See line 200.\n//\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// See this too: https://www.shadertoy.com/view/XsXfRH\n//\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = map( pos );\n        res = vec4(t,hnor.yzw);\n        \n\t\tif( hnor.x<0.001 ) break;\n\t\tt += hnor.x;\n        if( t>tmax ) break;\n\t}\n\n\tif( t>tmax ) res = vec4(-1.0);\n\treturn res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n#endif\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n        vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing normals analytically has the benefit of being faster if you need them often, \n// while numerical normals are easier to filter for antialiasing. See line 200.\n//\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// See this too: https://www.shadertoy.com/view/XsXfRH\n//\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(0.0);\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( abs(h)<0.001 ) break;\n        t += h;\n    }\n    res.x = t;\n    res.y = map( ro + rd*t );\n    res.z = 1.0;\n    return res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n#endif\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n        vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing normals analytically has the benefit of being faster if you need them often, \n// while numerical normals are easier to filter for antialiasing. See line 200.\n//\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// See this too: https://www.shadertoy.com/view/XsXfRH\n//\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = map( pos );\n        res = vec4(t,hnor.yzw);\n        \n\t\tif( hnor.x<0.001 ) break;\n\t\tt += hnor.x;\n        if( t>tmax ) break;\n\t}\n\n\tif( t>tmax ) res = vec4(-1.0);\n\treturn res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n#endif\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    float phi = acos(1.0 - 2.0 * i / n);\n    float theta = 2.0 * PI * i / n;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n        vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical second derivatibes of value noise and fbm made with it. Used second\n// derivatives to compute curvature.\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n//---------------------------------------------------------------\n// return.x = value noise\n// return.xyz = derivatives\n// out dd     = hessian (second derivatives)\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x, out mat3 dd )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    // cubic interpolation vs quintic interpolation\n#if 0\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    vec3 ddu = 6.0 - 12.0*w;\n#else\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 ddu = 60.0*w*(1.0+w*(-3.0+2.0*w));\n#endif\n    \n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    dd = mat3( ddu.x*(k1 + k4*u.y + k6*u.z + k7*u.y*u.z), \n               du.x*(k4+k7*u.z)*du.y,\n               du.x*(k6+k7*u.y)*du.z,\n              \n               du.y*(k4+k7*u.z)*du.x,\n               ddu.y*(k2 + k5*u.z + k4*u.x + k7*u.z*u.x),\n               du.y*(k5+k7*u.x)*du.z,\n              \n               du.z*(k6+k7*u.y)*du.x,\n               du.z*(k5+k7*u.x)*du.y,\n               ddu.z*(k3 + k6*u.x + k5*u.y + k7*u.x*u.y) );\n\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd( in vec3 x, out mat3 s )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    s = mat3(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        mat3 dd;\n        vec4 n = noised(f*x*scale,dd);\n        a += b*n.x;                // accumulate values\t\t\n        d += b*n.yzw*f*scale;      // accumulate derivatives\n        s += b*dd*f*f*scale*scale; // accumulate second derivative\n        b *= 0.5;\n        f *= 1.8;\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p, out mat3 s )\n{\n    \n    mat3 dd;\n\tvec4 d1 = fbmd( p, dd );\n    d1.x -= 0.33;\n\td1.x *= 0.7;\n    d1.yzw = 0.7*d1.yzw;\n    dd *= 0.7;\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    if(d1.x>d2.x)\n    {\n        s = dd;\n        return d1;\n    }\n    \n    \n    s = mat3(0.0);\n    return d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd, out mat3 resS )\n{\n    vec4 res = vec4(0.0);\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tdelta = 0.0;\n    float tstep = 0.0;\n    float tstep2 = 0.0;\n    float tstep3 = 0.0;\n    float tstep4 = 0.0;\n    float tstep5 = 0.0;\n    float tstep6 = 0.0;\n    float tstep7 = 0.0;\n    float tstep8 = 0.0;\n    float tstep9 = 0.0;\n    float tstep10 = 0.0;\n    float tstep11 = 0.0;\n    float tstep12 = 0.0;\n    float tstep13 = 0.0;\n    float tstep14 = 0.0;\n    float tstep15 = 0.0;\n    float tstep16 = 0.0;\n    float tstep17 = 0.0;\n    float tstep18 = 0.0;\n    float tstep19 = 0.0;\n    float tstep20 = 0.0;\n    float tstep21 = 0.0;\n    float tstep22 = 0.0;\n    float tstep23 = 0.0;\n    float tstep24 = 0.0;\n    float tstep25 = 0.0;\n    float tstep26 = 0.0;\n    float tstep27 = 0.0;\n    float tstep28 = 0.0;\n    float tstep29 = 0.0;\n    float tstep30 = 0.0;\n    float tstep31 = 0.0;\n    float tstep32 = 0.0;\n    float tstep33 = 0.0;\n    float t// incomplete generation!\n\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        mat3 kk;\n        ao += clamp( map( pos + nor*0.001 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    mat3 dd;\n    vec4 tnor = interesect( ro, rd, dd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3  pos = ro + t*rd;\n        vec3  nor = normalize(tnor.yzw);\n        float occ = calcAO( pos, nor );\n\n        \n        vec3 d = tnor.yzw;\n\n        // compute curvature\n\t\tmat4 mm = mat4( dd[0].x, dd[0].y, dd[0].z, d.x,\n                        dd[1].x, dd[1].y, dd[1].z, d.y,\n                        dd[2].x, dd[2].y, dd[2].z, d.z,\n                        d.x, d.y, d.z, 0.0 );\n\t\tfloat k = -determinant(mm)/(dot(d,d)*dot(d,d));\n\n        // shape it a bit\n        k = sign(k)*pow( abs(k), 1.0/3.0 );\n        \n        if( k<0.0) col = vec3(1.0,0.7,0.2); else col = vec3(0.2,0.8,1.0); col *= abs(k*0.2);\n        if( abs(k)<0.0001 ) col = vec3(0.1);\n\n        col *= occ;\n        col *= 0.7 + 0.3*nor.y;\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Computes the analytic derivatives of a 2D Gradient Noise\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return vec3(mix(a, b, u.x), mix(c, d, u.x), mix(mix(a, b, u.x), mix(c, d, u.x), u.y));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 n = noised( 8.0*p + iTime*4.0 );\n\n    vec3 col = 0.5 + 0.5*((p.x>0.0) ? n.yzx : n.xxx);\n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analiyically filtering a grid pattern (ie, not using supersampling or mipmapping.\n//\n// Info: http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n//  \n// More filtered patterns:  https://www.shadertoy.com/playlist/l3KXR1\n\n\n// --- analytically box-filtered grid ---\n\nconst float N = 10.0; // grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    vec2 h = step(f,vec2(0.5));\n    vec2 k = vec2(1.0)-h;\n    vec2 l = f-h;\n    vec2 m = f+k-1.0;\n    vec2 n = dFdx(g);\n    vec2 o = dFdy(g);\n    vec2 a = dFdx(l);\n    vec2 b = dFdy(l);\n    vec2 c = dFdx(m);\n    vec2 d = dFdy(m);\n    vec2 e = dFdx(h);\n    vec2 f2 = dFdy(h);\n    vec2 g2 = dFdx(k);\n    vec2 h2 = dFdy(k);\n    vec2 i = dFdx(f);\n    vec2 j = dFdy(f);\n    vec2 k2 = dFdx(vec2(0.5));\n    vec2 l2 = dFdy(vec2(0.5));\n    vec2 m2 = dFdx(vec2(0.0));\n    vec2 n2 = dFdy(vec2(0.0));\n    vec2 o2 = dFdx(vec2(1.0));\n    vec2 p2 = dFdy(vec2(1.0));\n    vec2 q = dFdx(n);\n    vec2 r = dFdy(n);\n    vec2 s = dFdx(o);\n    vec2 t = dFdy(o);\n    vec2 u = dFdx(a);\n    vec2 v = dFdy(a);\n    vec2 w = dFdx(b);\n    vec2 x = dFdy(b);\n    vec2 y = dFdx(c);\n    vec2 z = dFdy(c);\n    vec2 a2 = dFdx(d);\n    vec2 b2 = dFdy(d);\n    vec2 c2// incomplete generation!\n\n// --- unfiltered grid ---\n\nfloat gridTexture( in vec2 p )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    //return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  3.0, 0.5, 0.0, 0.5 );\nconst vec4 sc1 = vec4( -4.0, 2.0,-5.0, 2.0 );\nconst vec4 sc2 = vec4( -4.0, 2.0, 5.0, 2.0 );\nconst vec4 sc3 = vec4(-30.0, 8.0, 0.0, 8.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out int matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n    matid = -1;\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc1.xyz); \n\t\tmatid = 2;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc2.xyz); \n\t\tmatid = 3;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc3.xyz); \n\t\tmatid = 4;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec2 texCoords( in vec3 pos, int mid )\n{\n    vec2 matuv;\n    \n    if( mid==0 )\n    {\n        matuv = pos.xz;\n    }\n    else if( mid==1 )\n    {\n        vec3 q = normalize( pos - sc0.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n    }\n    else if( mid==2 )\n    {\n        vec3 q = normalize( pos - sc1.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc1.w;\n    }\n    else if( mid==3 )\n    {\n        vec3 q = normalize( pos - sc2.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc2.w;\n    }\n    else if( mid==4 )\n    {\n        vec3 q = normalize( pos - sc3.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc3.w;\n    }\n\n\treturn 8.0*matuv;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*sin(0.1*iTime);\n\tro = vec3( 5.0*cos(an), 0.5, 5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (2.0*pix-iResolution.xy) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 0.0;\n    \n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ;\n    int mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( mid!=-1 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = texCoords(     pos, mid );\n\t\tvec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;\n\t\tvec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytracer.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = texCoords( pos, mid );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\n        if( p.x<th ) mate = vec3(1.0)*gridTexture( uv );\n        else         mate = vec3(1.0)*gridTextureGradBox( uv, ddx_uv, ddy_uv );\n            \n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 1.0, 2.0, abs(p.x-th)/(2.0/iResolution.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define AA 4   // make this 1 is your machine is too slow\n\n\n//------------------------------------------------------------------\n\nconst vec2 torus = vec2(0.5,0.2);\n\nfloat map( in vec3 p )\n{\n    return length( vec2(length(p.xz)-torus.x,p.y) )-torus.y;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    vec3 n = vec3(0.0);\n    float d = map(p);\n    float e = 0.001;\n    n.x = map(p+vec3(e,0.0,0.0))-d;\n    n.y = map(p+vec3(0.0,e,0.0))-d;\n    n.z = map(p+vec3(0.0,0.0,e))-d;\n    return normalize(n);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    // plane\n    float tmax = (-torus.y-ro.y)/rd.y;\n   \n    // torus\n    float t = 1.0;\n    float m = 2.0;\n    for( int i=0; i<100; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) { t=tmax; m=1.0; }\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for( int i=0; i<12; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res,18.0*h/t );\n        t += clamp( h, 0.05, 0.10 );\n        if( res<0.005 || t>1.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 hexagon_pattern( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n\treturn vec3( pi + ca - cb*ma, dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3  col = vec3(0.0);\n    vec2  res = castRay(ro,rd);\n    vec3  pos = ro + rd*res.x;\n    vec3  nor = vec3(0.0,1.0,0.0);\n    float occ = 1.0;\n\n    // plane\n    if( res.y<1.5 )\n    {\n        // fake occlusion\n        occ = smoothstep(0.0,0.42, abs(length(pos.xz)-torus.x) );\n        // texture\n        #if 0\n        vec3  h = hexagon_pattern(pos.xz*4.);\n        float f = mod(h.x+2.0*h.y,3.0)/2.0 ;\n        #else\n        float f = float( (int(floor(2.0*pos.x))+int(floor(2.0*pos.z)))&1);\n        #endif\n        col = vec3(0.3 + f*0.1);\n    }\n    // torus\n    else\n    {\n        // analytic torus normal\n        nor = normalize( dmap(pos) );\n        // fake occlusion\n        occ = 0.5 + 0.5*nor.y;\n        // texture\n        vec2 uv = vec2(atan(pos.z,pos.x),atan(length(pos.xz)-torus.x,pos.y) )*\n                  vec2(12.0*sqrt(3.0), 8.0)/3.14159;\n        uv.y += iTime;\n        vec3 h = hexagon_pattern( uv );\n        col = vec3( mod(h.x+2.0*h.y,3.0)/2.0 );\n        //col = mix(col,vec3(0.0), 1.0-smoothstep(0.02,0.05,h.z)); // aliased\n        col = mix(col,vec3(0.0),clamp(1.3*(1.0-smoothstep(0.01*res.x,0.05*res.x,h.z))/res.x,0.0,1.0)); // somehow filtered\n    }\n    // lighting        \n    vec3  lig = normalize( vec3(0.4, 0.5, -0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.65+0.35*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 );\n\n    dif *= calcSoftshadow( pos, lig );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0) *\n                dif *\n                (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 1.63*dif*vec3(1.15,0.90,0.55);\n    lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n    lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n    col = col*lin;\n    col += 6.00*spe*vec3(1.15,0.90,0.55);\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    // camera\t\n    vec3 ro = vec3( 1.3*cos(0.05*iTime + 6.0*mo.x), 1.1, 1.3*sin(0.05*iTime + 6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.2, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(vec3(-cw.z,0.0,cw.x));\n    vec3 cv =          (cross(cu,cw) );\n    \n    vec4 tot = vec4(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m),float(n)) / float(AA-1) - 0.5)*1.7; // 1.7 pixels wide\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma (before reconstruction/filtering)\n        col = pow( col, vec3(0.4545) );\n\n \t\t#if AA>1\n        // triangular reconstruction filter, kernel 2.0 pixels wide\n        float w = clamp(1.0 - length(o)/1.0,0.0,1.0);\n        tot.xyz += w*col;\n        tot.w += w;\n        #else\n        tot.xyz = col;\n        #endif\n\t#if AA>1\n    }\n    tot /= tot.w;\n\t#endif\n\n    // grading\n    tot.xyz = pow(tot.xyz,vec3(0.8,0.9,1.0) );\n    \n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot.xyz *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    fragColor = vec4( tot.xyz, 1.0 );\n}"], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n\tv33 c=a;\n\ta=b;\n\tb=c;\n}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n\treturn v33(a.a-b,a.b-b);\n}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n\tfloat a=abs(dot(p,w));\n\treturn (a-floor(a))*2.-1.;\n}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tvec3 a=floor(q);\n\tvec3 b=fract(q);\n\tfloat s=dot(a,vec3(1.0,1.0,1.0));\n\tfloat t=dot(b,vec3(1.0,1.0,1.0));\n\tfloat u=dot(w,vec3(1.0,1.0,1.0));\n\tfloat v=dot(w,vec3(1.0,1.0,1.0));\n\tfloat f=mix(t,1.0-t,s);\n\tfloat g=mix(u,1.0-u,v);\n\treturn f*g;\n}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n  v33 d=r.xyz-s.xyz;\n  float l=length(d);\n  return 1.0-smoothstep(s.w-0.01,s.w+0.01,l);\n}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n\tvec3 d=s.xyz-u;\n\tfloat l=length(d);\n\treturn 1.-smoothstep(s.w-.01,s.w+.01,l);\n}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n "], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact bounding box to a quadratic Bezier curve. Since the bezier is quadratic,\n// the bbox can be compute with a linear equation:\n//\n//   Yellow: naive bbox of the 3 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 c = p1 - p0;\n    vec2 d = p2 - p1;\n    vec2 e = p0 - p2;\n    vec2 f = c + d + e;\n    vec2 g = 2.0 * (d + e);\n    vec2 h = e;\n    vec2 a = g * g - 4.0 * f * h;\n    vec2 b = 2.0 * g - 4.0 * f;\n    vec2 t0 = clamp( (-b + sqrt(a)) / (2.0 * f), 0.0, 1.0);\n    vec2 t1 = clamp( (-b - sqrt(a)) / (2.0 * f), 0.0, 1.0);\n    vec2 p = mix(p0, p2, t0);\n    vec2 q = mix(p0, p2, t1);\n    vec2 r = mix(p0, p2, 0.5);\n    vec2 s = mix(p0, p2, 0.25);\n    vec2 t = mix(p0, p2, 0.75);\n    vec2 u = mix(p0, p2, 0.125);\n    vec2 v = mix(p0, p2, 0.375);\n    vec2 w = mix(p0, p2, 0.625);\n    vec2 x = mix(p0, p2, 0.875);\n    vec2 y = mix(p0, p2, 0.0625);\n    vec2 z = mix(p0, p2, 0.1875);\n    vec2 aa = mix(p0, p2, 0.3125);\n    vec2 bb = mix(p0, p2, 0.4375);\n    vec2 cc = mix(p0, p2, 0.5625);\n    vec2// incomplete generation!\n\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 mi = min(p0,min(p1,p2));\n    vec2 ma = max(p0,max(p1,p2));\n    \n    return vec4( mi, ma );\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 udBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 pos)\n{    \n    // p(t)    = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0-2*p1+p2) + 2*(p1-p0)\n    // p'(0)   = 2(p1-p0)\n    // p'(1)   = 2(p2-p1)\n    // p'(1/2) = 2(p2-p0)\n    vec2 a = p1 - p0;\n    vec2 b = p0 - 2.0*p1 + p2;\n    vec2 c = p0 - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(c,b)) / 3.0;\n    float kz = kk * dot(c,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = c + (2.0*a + b*t)*t;\n        res = vec2( length(qos),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = c + (2.0*a + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = vec2(dis,t.x);\n\n        qos = c + (2.0*a + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.y );\n\n        qos = c + (2.0*a + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.z );\n\n        res.x = sqrt( res.x );\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 + 20.0;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    \n\t//-------------\n    // compute bbox\n\t//-------------\n    vec4 b1 = bboxBezierSimple(p0,p1,p2);\n    vec4 b2 = bboxBezier(p0,p1,p2);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p ).x;\n\tcol += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n    \n    // naive bbox\n    float d = sdBox( p-(b1.xy+b1.zw)*0.5, (b1.zw-b1.xy)*0.5 );\n    col = mix( col, vec3(1.0,0.6,0.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // exact bbox\n    d = sdBox( p-(b2.xy+b2.zw)*0.5, (b2.zw-b2.xy)*0.5 );\n    col = mix( col, vec3(0.2,0.5,1.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact bounding box to a quadratic Bezier curve. Since the bezier is quadratic,\n// the bbox can be compute with a linear equation:\n//\n//   Yellow: naive bbox of the 3 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    // extremes\n    vec2 mi = min(p0,p2);\n    vec2 ma = max(p0,p2);\n\n    // maxima/minima point, if p1 is outside the current bbox/hull\n    if( p1.x<mi.x || p1.x>ma.x || p1.y<mi.y || p1.y>ma.y )\n    {\n        // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n        // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)\n        // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);\n\n        vec2 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);\n        vec2 s = 1.0 - t;\n        vec2 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;\n        \n        mi = min(mi,q);\n        ma = max(ma,q);\n    }\n    \n    return vec4( mi, ma );\n}\n\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 c = p1 - p0;\n    vec2 d = p2 - p1;\n    vec2 e = c + d;\n    vec2 f = e * 0.5;\n    vec2 g = p0 + f;\n    vec2 h = p0 + c;\n    vec2 i = p2 - d;\n    vec2 j = p0 + p2;\n    vec2 k = j * 0.5;\n    vec2 l = p1 - k;\n    vec2 m = p1 + l;\n    vec2 n = p1 + p2;\n    vec2 o = n * 0.5;\n    vec2 p = p1 + o;\n    vec2 q = p1 + p;\n    vec2 r = p1 + q;\n    vec2 s = p1 + r;\n    vec2 t = p1 + s;\n    vec2 u = p1 + t;\n    vec2 v = p1 + u;\n    vec2 w = p1 + v;\n    vec2 x = p1 + w;\n    vec2 y = p1 + x;\n    vec2 z = p1 + y;\n    vec2 aa = p1 + z;\n    vec2 ab = p1 + aa;\n    vec2 ac = p1 + ab;\n    vec2 ad = p1 + ac;\n    vec2 ae = p1 + ad;\n    vec2 af = p1 + ae;\n    vec2 ag = p1 + af;\n    vec2 ah = p1 + ag;\n    vec2 ai = p1 + ah;\n    vec2 aj = p1 + ai;\n    vec2 ak = p1 + aj;\n    vec2 al = p1 + ak;\n    vec2 am = p1 + al;\n    vec2 an = p1 + am;\n    vec2 ao = p1 + an;\n    vec2 ap = p1 + ao;\n    vec2 aq = p1 + ap// incomplete generation!\n\n//---------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 udBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 pos)\n{    \n    // p(t)    = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0-2*p1+p2) + 2*(p1-p0)\n    // p'(0)   = 2(p1-p0)\n    // p'(1)   = 2(p2-p1)\n    // p'(1/2) = 2(p2-p0)\n    vec2 a = p1 - p0;\n    vec2 b = p0 - 2.0*p1 + p2;\n    vec2 c = p0 - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(c,b)) / 3.0;\n    float kz = kk * dot(c,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = c + (2.0*a + b*t)*t;\n        res = vec2( length(qos),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = c + (2.0*a + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = vec2(dis,t.x);\n\n        qos = c + (2.0*a + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.y );\n\n        qos = c + (2.0*a + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.z );\n\n        res.x = sqrt( res.x );\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 + 20.0;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    \n\t//-------------\n    // compute bbox\n\t//-------------\n    vec4 b1 = bboxBezierSimple(p0,p1,p2);\n    vec4 b2 = bboxBezier(p0,p1,p2);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p ).x;\n\tcol += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n    \n    // naive bbox\n    float d = sdBox( p-(b1.xy+b1.zw)*0.5, (b1.zw-b1.xy)*0.5 );\n    col = mix( col, vec3(1.0,0.6,0.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // exact bbox\n    d = sdBox( p-(b2.xy+b2.zw)*0.5, (b2.zw-b2.xy)*0.5 );\n    col = mix( col, vec3(0.2,0.5,1.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical computation of the exact bounding box for a cubic bezier segment\n//\n// See http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3 )\n{\n    vec3 b = p0*2.0 - p1*3.0 + p2*3.0 - p3;\n    vec3 c = p1*3.0 - p0*6.0 + p3*3.0 - p2*3.0;\n    vec3 d = p0 - p1*3.0 + p2*3.0 - p3;\n\n    vec3 bb = vec3(0.0);\n    bb.x = min( min( p0.x, p3.x ), min( min( p0.x, p1.x ), min( p2.x, p3.x ) ) );\n    bb.y = min( min( p0.y, p3.y ), min( min( p0.y, p1.y ), min( p2.y, p3.y ) ) );\n    bb.z = min( min( p0.z, p3.z ), min( min( p0.z, p1.z ), min( p2.z, p3.z ) ) );\n    bb.x = max( max( p0.x, p3.x ), max( max( p0.x, p1.x ), max( p2.x, p3.x ) ) );\n    bb.y = max( max( p0.y, p3.y ), max( max( p0.y, p1.y ), max( p2.y, p3.y ) ) );\n    bb.z = max( max( p0.z, p3.z ), max( max( p0.z,// incomplete generation!\n\n\n// ray-ellipse intersection\nfloat iEllipse( in vec3 ro, in vec3 rd,         // ray: origin, direction\n             in vec3 c, in vec3 u, in vec3 v )  // disk: center, 1st axis, 2nd axis\n{\n\tvec3 q = ro - c;\n\tvec3 r = vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), rd ),\n\t\tdot( cross(v,q), rd ) ) / \n        dot( cross(v,u), rd );\n    \n    return (dot(r.yz,r.yz)<1.0) ? r.x : -1.0;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n    \n}\n\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float width)\n{\n    const int kNum = 50;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec3 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n    \n    \n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // bezier animation\n    float time = iTime*0.5;\n    vec3 p0 = vec3(0.8,0.6,0.8)*sin( time*0.7 + vec3(3.0,1.0,2.0) );\n    vec3 p1 = vec3(0.8,0.6,0.8)*sin( time*1.1 + vec3(0.0,6.0,1.0) );\n    vec3 p2 = vec3(0.8,0.6,0.8)*sin( time*1.3 + vec3(4.0,2.0,3.0) );\n    vec3 p3 = vec3(0.8,0.6,0.8)*sin( time*1.5 + vec3(1.0,5.0,4.0) );\n\tfloat thickness = 0.01;\n        \n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace bezier\n    float t = iBezier( ro, rd, p0, p1, p2, p3, thickness);\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3);\n\t}\n\n    // compute bounding box for bezier\n    bound3 bbox = BezierAABB( p0, p1, p2, p3 );\n    bbox.mMin -= thickness;\n    bbox.mMax += thickness;\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact axis aligned bounding box to a cubic Bezier curve. Since\n// the bezier is cubic, the bbox can be compute with a quadratic equation:\n//\n//   Yellow: naive bbox of the 4 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n#if 1\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    vec2 k0 = -1.0*p0 + 1.0*p1;\n    vec2 k1 =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 k2 = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = k1*k1 - k0*k2;\n\n    if( h.x>0.0 )\n    {\n        h.x = sqrt(h.x);\n        //float t = (-k1.x - h.x)/k2.x;\n        float t = k0.x/(-k1.x-h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n        //t = (-k1.x + h.x)/k2.x;\n        t = k0.x/(-k1.x+h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n    }\n\n    if( h.y>0.0)\n    {\n        h.y = sqrt(h.y);\n        //float t = (-k1.y - h.y)/k2.y;\n        float t = k0.y/(-k1.y-h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n        //t = (-k1.y + h.y)/k2.y;\n        t = k0.y/(-k1.y+h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n    }\n   \n    return vec4( mi, ma );\n}\n#else\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    // note pascal triangle coefficnets\n    vec2 c = -1.0*p0 + 1.0*p1;\n    vec2 b =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 a = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = b*b - a*c;\n\n    // real solutions\n    if( any(greaterThan(h,vec2(0.0))))\n    {\n        vec2 g = sqrt(abs(h));\n        vec2 t1 = clamp((-b - g)/a,0.0,1.0); vec2 s1 = 1.0-t1;\n        vec2 t2 = clamp((-b + g)/a,0.0,1.0); vec2 s2 = 1.0-t2;\n        vec2 q1 = s1*s1*s1*p0 + 3.0*s1*s1*t1*p1 + 3.0*s1*t1*t1*p2 + t1*t1*t1*p3;\n        vec2 q2 = s2*s2*s2*p0 + 3.0*s2*s2*t2*p1 + 3.0*s2*t2*t2*p2 + t2*t2*t2*p3;\n\n        if( h.x > 0.0 )\n        {\n            mi.x = min(mi.x,min(q1.x,q2.x));\n            ma.x = max(ma.x,max(q1.x,q2.x));\n        }\n\n        if( h.y > 0.0  )\n        {\n            mi.y = min(mi.y,min(q1.y,q2.y));\n            ma.y = max(ma.y,max(q1.y,q2.y));\n        }\n    }\n    \n    return vec4( mi, ma );\n}\n#endif\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 min = min(min(p0, p1), min(p2, p3));\n    vec2 max = max(max(p0, p1), max(p2, p3));\n    return vec4(min, max);\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn sqrt(sdSegmentSq(p,a,b));\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{   \n    const int kNum = 50;\n    vec2 res = vec2(1e10,0.0);\n    vec2 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec2 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        float d = sdSegmentSq( pos, a, b );\n        if( d<res.x ) res = vec2(d,t);\n        a = b;\n    }\n    \n    return vec2(sqrt(res.x),res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 - 0.7;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n\t//-------------\n    // compute bbox\n\t//-------------\n    vec4 b1 = bboxBezierSimple(p0,p1,p2,p3);\n    vec4 b2 = bboxBezier(p0,p1,p2,p3);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p3, p ).x;\n\tcol += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n    \n    \n    // naive bbox\n    float d = sdBox( p-(b1.xy+b1.zw)*0.5, (b1.zw-b1.xy)*0.5 );\n    col = mix( col, vec3(1.0,0.6,0.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // exact bbox\n    d = sdBox( p-(b2.xy+b2.zw)*0.5, (b2.zw-b2.xy)*0.5 );\n    col = mix( col, vec3(0.2,0.5,1.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p2, p3 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p3-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact axis aligned bounding box to a cubic Bezier curve. Since\n// the bezier is cubic, the bbox can be compute with a quadratic equation:\n//\n//   Yellow: naive bbox of the 4 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n#if 1\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    vec2 k0 = -1.0*p0 + 1.0*p1;\n    vec2 k1 =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 k2 = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = k1*k1 - k0*k2;\n\n    if( h.x>0.0 )\n    {\n        h.x = sqrt(h.x);\n        //float t = (-k1.x - h.x)/k2.x;\n        float t = k0.x/(-k1.x-h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n        //t = (-k1.x + h.x)/k2.x;\n        t = k0.x/(-k1.x+h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n    }\n\n    if( h.y>0.0)\n    {\n        h.y = sqrt(h.y);\n        //float t = (-k1.y - h.y)/k2.y;\n        float t = k0.y/(-k1.y-h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n        //t = (-k1.y + h.y)/k2.y;\n        t = k0.y/(-k1.y+h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n    }\n   \n    return vec4( mi, ma );\n}\n#else\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    // note pascal triangle coefficnets\n    vec2 c = -1.0*p0 + 1.0*p1;\n    vec2 b =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 a = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = b*b - a*c;\n\n    // real solutions\n    if( any(greaterThan(h,vec2(0.0))))\n    {\n        vec2 g = sqrt(abs(h));\n        vec2 t1 = clamp((-b - g)/a,0.0,1.0); vec2 s1 = 1.0-t1;\n        vec2 t2 = clamp((-b + g)/a,0.0,1.0); vec2 s2 = 1.0-t2;\n        vec2 q1 = s1*s1*s1*p0 + 3.0*s1*s1*t1*p1 + 3.0*s1*t1*t1*p2 + t1*t1*t1*p3;\n        vec2 q2 = s2*s2*s2*p0 + 3.0*s2*s2*t2*p1 + 3.0*s2*t2*t2*p2 + t2*t2*t2*p3;\n\n        if( h.x > 0.0 )\n        {\n            mi.x = min(mi.x,min(q1.x,q2.x));\n            ma.x = max(ma.x,max(q1.x,q2.x));\n        }\n\n        if( h.y > 0.0  )\n        {\n            mi.y = min(mi.y,min(q1.y,q2.y));\n            ma.y = max(ma.y,max(q1.y,q2.y));\n        }\n    }\n    \n    return vec4( mi, ma );\n}\n#endif\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 mi = min(min(p0,p1),min(p2,p3));\n    vec2 ma = max(max(p0,p1),max(p2,p3));\n    \n    return vec4( mi, ma );\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn sqrt(sdSegmentSq(p,a,b));\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return udBezier(p0123, p123, p23, p3, pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 - 0.7;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n\t//-------------\n    // compute bbox\n\t//-------------\n    vec4 b1 = bboxBezierSimple(p0,p1,p2,p3);\n    vec4 b2 = bboxBezier(p0,p1,p2,p3);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p3, p ).x;\n\tcol += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n    \n    \n    // naive bbox\n    float d = sdBox( p-(b1.xy+b1.zw)*0.5, (b1.zw-b1.xy)*0.5 );\n    col = mix( col, vec3(1.0,0.6,0.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // exact bbox\n    d = sdBox( p-(b2.xy+b2.zw)*0.5, (b2.zw-b2.xy)*0.5 );\n    col = mix( col, vec3(0.2,0.5,1.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p2, p3 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p3-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// Other triangle functions:\n//\n// Occlusion:    https://www.shadertoy.com/view/XdjSDy\n// Distance:     https://www.shadertoy.com/view/4sXXRN\n// Intersection: https://www.shadertoy.com/view/MlGcDz\n// Closest:      https://www.shadertoy.com/view/ttfGWl\n\n\n//=====================================================\n\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1-v0;\n    vec3 e2 = v2-v0;\n    vec3 p = cross(rd,e2);\n    float det = dot(e1,p);\n    if( abs(det) < 0.0001 ) return vec3(1.0,0.0,0.0);\n    float invdet = 1.0/det;\n    vec3 t = ro - v0;\n    float u = dot(t,p)*invdet;\n    if( u<0.0 || u>1.0 ) return vec3(1.0,0.0,0.0);\n    vec3 q = cross(t,e1);\n    float v = dot(rd,q)*invdet;\n    if( v<0.0 || (u+v)>1.0 ) return vec3(1.0,0.0,0.0);\n    float tt = dot(e2,q)*invdet;\n    return vec3(tt,u,v);\n}\n\n\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = normalize(v0-pos);\n    vec3 b = normalize(v1-pos);\n    vec3 c = normalize(v2-pos);\n\n    float s = -sign(dot(v0-pos,cross(v0-v1,v2-v1))); // other side of the triangle\n    \n    // page 300 in http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.466.963&rep=rep1&type=pdf\n    float r = dot(nor,normalize(cross(a,b))) * acos(dot(a,b)) +\n              dot(nor,normalize(cross(b,c))) * acos(dot(b,c)) +\n              dot(nor,normalize(cross(c,a))) * acos(dot(c,a));\n    \n    return 1.0-max(0.0,s*r)/6.2831;\n}\n\n//=====================================================\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec3 ro = vec3(0.0, 0.0, 4.0 );\n        vec3 rd = normalize( vec3(p,-2.0) );\n\t\n        // triangle animation\n        vec3 v1 = cos( iTime*1.0 + vec3(2.0,1.0,1.0) + 1.0 )*vec3(1.5,1.0,1.0);\n\t    vec3 v2 = cos( iTime*1.0 + vec3(5.0,2.0,3.0) + 2.0 )*vec3(1.5,1.0,1.0);\n\t    vec3 v3 = cos( iTime*1.2 + vec3(1.0,3.0,5.0) + 4.0 )*vec3(1.5,1.0,1.0);\n\n        vec3 col = vec3(0.08) + 0.02*rd.y;\n\n        float tmin = 1e10;\n    \n        float t1 = iPlane( ro, rd );\n        if( t1>0.0 )\n        {\n            tmin = t1;\n            vec3 pos = ro + tmin*rd;\n            vec3 nor = vec3(0.0,1.0,0.0);\n            float occ = triOcclusion( pos, nor, v1, v2, v3 );\n            col = mix( col*3.0*occ*occ, col, 1.0-exp(-0.02*tmin) );\n        }\n        \n        col *= 1.0-0.3*length(p);\n\n        vec3 res = triIntersect( ro, rd, v1, v2, v3 );\n        float t2 = res.x;\n        if( t2>0.0 && t2<tmin )\n        {\n            tmin = t2;\n            float t = t2;\n            vec3 pos = ro + t*rd;\n            vec3 nor = normalize( cross( v2-v1, v3-v1 ) );\n            col = pattern(64.0*res.yz);\n            col *= 0.55 + 0.45*faceforward(-nor, -rd, nor).y;\n        }\n\n        \n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// Other triangle functions:\n//\n// Occlusion:    https://www.shadertoy.com/view/XdjSDy\n// Distance:     https://www.shadertoy.com/view/4sXXRN\n// Intersection: https://www.shadertoy.com/view/MlGcDz\n// Closest:      https://www.shadertoy.com/view/ttfGWl\n\n\n//=====================================================\n\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t\u00b7rd = p(u,v) = vo + u\u00b7(v1-v0) + v\u00b7(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 n = normalize( cross(e0,e1) );\n    float d = dot(v0,n);\n    float s = sign(dot(n,nor));\n    return s*max(0.0,dot(pos,n)+s*d);\n}\n\n//=====================================================\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec3 ro = vec3(0.0, 0.0, 4.0 );\n        vec3 rd = normalize( vec3(p,-2.0) );\n\t\n        // triangle animation\n        vec3 v1 = cos( iTime*1.0 + vec3(2.0,1.0,1.0) + 1.0 )*vec3(1.5,1.0,1.0);\n\t    vec3 v2 = cos( iTime*1.0 + vec3(5.0,2.0,3.0) + 2.0 )*vec3(1.5,1.0,1.0);\n\t    vec3 v3 = cos( iTime*1.2 + vec3(1.0,3.0,5.0) + 4.0 )*vec3(1.5,1.0,1.0);\n\n        vec3 col = vec3(0.08) + 0.02*rd.y;\n\n        float tmin = 1e10;\n    \n        float t1 = iPlane( ro, rd );\n        if( t1>0.0 )\n        {\n            tmin = t1;\n            vec3 pos = ro + tmin*rd;\n            vec3 nor = vec3(0.0,1.0,0.0);\n            float occ = triOcclusion( pos, nor, v1, v2, v3 );\n            col = mix( col*3.0*occ*occ, col, 1.0-exp(-0.02*tmin) );\n        }\n        \n        col *= 1.0-0.3*length(p);\n\n        vec3 res = triIntersect( ro, rd, v1, v2, v3 );\n        float t2 = res.x;\n        if( t2>0.0 && t2<tmin )\n        {\n            tmin = t2;\n            float t = t2;\n            vec3 pos = ro + t*rd;\n            vec3 nor = normalize( cross( v2-v1, v3-v1 ) );\n            col = pattern(64.0*res.yz);\n            col *= 0.55 + 0.45*faceforward(-nor, -rd, nor).y;\n        }\n\n        \n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a*2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float p = ky-kx*kx;\n    float q = kx*(2.0*kx-3.0*ky)+kz;\n    float det = q*q+4.0*p*p*p;\n\n    if( det<0.0 )\n    {\n        float r = sqrt(-p);\n        float phi = acos(q/(r*r*r));\n        float t = 2.0*r*cos(phi/3.0)-kx;\n        res = length(d + t*a + t*t*b);\n    }\n    else\n    {\n        float t0 = clamp( (-q - sqrt(det))/(2.0*p), 0.0, 1.0 );\n        res = length(d + t0*c);\n        float t1 = clamp( (-q + sqrt(det))/(2.0*p), 0.0, 1.0 );\n        res = min( res, length(d + t1*c) );\n    }\n\n    return res;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    \n    float d = sdBezier( p, v0,v1,v2 ); \n    \n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdBezier(m, v0,v1,v2 ); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n \n    if( cos(0.5*iTime)<-0.5 )\n    {\n        d = min( udSegment(p,v0,v1),\n                 udSegment(p,v1,v2) );\n        d = min( d, length(p-v0)-0.02 );\n        d = min( d, length(p-v1)-0.02 );\n        d = min( d, length(p-v2)-0.02 );\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\n    }\n\n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an isosceles trapezoid\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    vec2 ca = vec2(max(dot(k1,p),0.0),abs(p.y)-he);\n    vec2 cb = p-k2;\n    float s = (cb.x < 0.0)? -1.0 : 1.0;\n    cb.x = abs(cb.x);\n    return sign(s)*sqrt(min(dot(ca,ca),dot(cb,cb)));\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ra = 0.2+0.15*sin(iTime*1.3+0.0);\n    float rb = 0.2+0.15*sin(iTime*1.4+1.1);\n    vec2  pa = vec2(-0.6,0.0)+0.4*sin(iTime*1.1+vec2(0.0,2.0));\n    vec2  pb = vec2(-0.6,0.0)+0.4*sin(iTime*1.2+vec2(1.0,2.5));\n    vec2  pc = vec2(0.8,0.0);\n\n    // axis aligned trapezoid\n\tfloat d = sdTrapezoid( p-pc, ra, rb, 0.5+0.2*sin(1.3*iTime) );\n    // aribitrary trapezoid\n    d = min( d, sdTrapezoid( p, pa, pb , ra, rb ) );\n\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdTrapezoid( m, pa, pb , ra, rb );\n    d = min( d, sdTrapezoid( m-pc, ra, rb, 0.5+0.2*sin(1.3*iTime) ) );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an isosceles trapezoid\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb )\n{\n    vec2 d = abs(p)-a;\n    vec2 e = max(d,b);\n    vec2 f = vec2(max(d.x,b.x)-a.x,max(d.y,b.y)-a.y);\n    float g = max(f.x,f.y);\n    vec2 h = f-g*vec2(1.0,-1.0);\n    return min(max(e.x,e.y),min(ra,rb)) + min(g,min(ra,rb)) + min(h.x,h.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ra = 0.2+0.15*sin(iTime*1.3+0.0);\n    float rb = 0.2+0.15*sin(iTime*1.4+1.1);\n    vec2  pa = vec2(-0.6,0.0)+0.4*sin(iTime*1.1+vec2(0.0,2.0));\n    vec2  pb = vec2(-0.6,0.0)+0.4*sin(iTime*1.2+vec2(1.0,2.5));\n    vec2  pc = vec2(0.8,0.0);\n\n    // axis aligned trapezoid\n\tfloat d = sdTrapezoid( p-pc, ra, rb, 0.5+0.2*sin(1.3*iTime) );\n    // aribitrary trapezoid\n    d = min( d, sdTrapezoid( p, pa, pb , ra, rb ) );\n\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdTrapezoid( m, pa, pb , ra, rb );\n    d = min( d, sdTrapezoid( m-pc, ra, rb, 0.5+0.2*sin(1.3*iTime) ) );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime);\n\n    // opUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opUnion(d1,d2);\n    d = min( d, dt );\n  \t}\n    \n    // opSmoothUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothUnion(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n\n    // opSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSubtraction(d1,d2);\n    d = min( d, dt );\n    }\n\n    // opSmoothSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothSubtraction(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    // opIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opIntersection(d1,d2);\n    d = min( d, dt );\n    }\n    \n    // opSmoothIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q-vec3(0.0,0.5,0.0), vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothIntersection(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0)*0.5773;\n    return normalize( e.xyy*f( pos + e.xyy ) +\n                      e.yyx*f( pos + e.yyx ) +\n                      e.yxy*f( pos + e.yxy ) +\n                      e.xxx*f( pos + e.xxx ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime);\n\n    // opUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opUnion(d1,d2);\n    d = min( d, dt );\n  \t}\n    \n    // opSmoothUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothUnion(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n\n    // opSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSubtraction(d1,d2);\n    d = min( d, dt );\n    }\n\n    // opSmoothSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothSubtraction(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    // opIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opIntersection(d1,d2);\n    d = min( d, dt );\n    }\n    \n    // opSmoothIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q-vec3(0.0,0.5,0.0), vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothIntersection(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float ph = 1e10; // precision holder\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*tmin );\n        res = min( res, k*h/ph );\n        ph = h;\n        tmin += clamp( h, 0.01, 0.1 );\n        if( h<0.001 || tmin>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytic fake soft shadow for boxes. With a single ray, we can compute a soft shadow.\n// It is \"plausible\", but not accurate. It can probably be optimized further, right now\n// I am testing the 12 edges, but generaly you only need to test between 1 and 6.\n\n\n// Other Box functions:\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n\n// Other Soft Shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n\n\n#define SHADOW_TYPE 2\n\n// SHADOW_TYPE = 2 ---> great soft shadow\n// SHADOW_TYPE = 1 ---> super cheap soft shadow\n// SHADOW_TYPE = 0 ---> regular hard shadows\n\n\n#if SHADOW_TYPE==2\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz); // dm = 1.0 - rd.x*rd.x\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n#endif\n\n#if SHADOW_TYPE==1\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    // fake soft shadow\n    if( tF<0.0) return 1.0;\n    float sh = clamp(0.3*sk*(tN-tF)/tN,0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}    \n#endif\n\n#if SHADOW_TYPE==0\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 1.0;\n\treturn 0.0;\n}\n#endif\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad,\n                 out vec2 outT, out vec3 outNor, out vec2 outST, out int outFaceID ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return false;\n    vec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    outNor = (txx*vec4(nor,0.0)).xyz;\n    outT.x = tN;\n    outT.y = tF;\n    outST = (txx*vec4(ro+rd*outT.x,1.0)).xy;\n    outFaceID = int(3.0*nor.y+2.0*nor.z+nor.x);\n    return true;\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // 8 verts\n    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*rad - p);\n    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*rad - p);\n    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*rad - p);\n    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*rad - p);\n    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*rad - p);\n    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*rad - p);\n    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*rad - p);\n    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*rad - p);\n    \n    // 12 edges    \n    float k02 = dot( n, normalize( cross(v2,v0)) ) * acos( clamp(dot(v0,v2),-1.0,1.0) );\n    float k23 = dot( n, normalize( cross(v3,v2)) ) * acos( clamp(dot(v2,v3),-1.0,1.0) );\n    float k31 = dot( n, normalize( cross(v1,v3)) ) * acos( clamp(dot(v3,v1),-1.0,1.0) );\n    float k10 = dot( n, normalize( cross(v0,v1)) ) * acos( clamp(dot(v1,v0),-1.0,1.0) );\n    float k45 = dot( n, normalize( cross(v5,v4)) ) * acos( clamp(dot(v4,v5),-1.0,1.0) );\n    float k57 = dot( n, normalize( cross(v7,v5)) ) * acos( clamp(dot(v5,v7),-1.0,1.0) );\n    float k76 = dot( n, normalize( cross(v6,v7)) ) * acos( clamp(dot(v7,v6),-1.0,1.0) );\n    float k37 = dot( n, normalize( cross(v7,v3)) ) * acos( clamp(dot(v3,v7),-1.0,1.0) );\n    float k64 = dot( n, normalize( cross(v4,v6)) ) * acos( clamp(dot(v6,v4),-1.0,1.0) );\n    float k51 = dot( n, normalize( cross(v1,v5)) ) * acos( clamp(dot(v5,v1),-1.0,1.0) );\n    float k04 = dot( n, normalize( cross(v4,v0)) ) * acos( clamp(dot(v0,v4),-1.0,1.0) );\n    float k62 = dot( n, normalize( cross(v2,v6)) ) * acos( clamp(dot(v6,v2),-1.0,1.0) );\n    \n    // 6 faces    \n    float occ = 0.0;\n    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );\n    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );\n    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );\n    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );\n    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );\n    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );\n        \n    return occ / 6.2831;\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // animate box\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n    mat4 tra = translate( 0.0, 1.0, 0.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );\n    vec3 box = vec3(0.4,0.6,0.8);\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float tmin = 10000.0;\n        vec3  nor = vec3(0.0);\n        vec3  pos = vec3(0.0);\n        vec2  uv = vec2(0.0);\n\n        // raytrace-plane\n        float oid = 0.0;\n        float h = (0.0-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n            pos = ro + rd*h;\n            uv = pos.xz;\n        }\n\n        // raytrace box\n        vec3 bnor;  vec2 buv;\n        int outFaceID;\n        vec2 tnf;\n        if( boxIntersect( ro, rd, txx, txi, box, tnf, bnor, buv, outFaceID) )\n        {\n            if( tnf.x>0.0 && tnf.x<tmin )\n            {\n                tmin = tnf.x; \n                nor = bnor;\n                uv = buv;\n                oid = 2.0;\n        \t}\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.9);\n        if( tmin<100.0 )\n        {\n            vec3 lig = normalize(vec3(0.3,0.5,0.8));\n            pos = ro + tmin*rd;\n\n            // material\n            float occ = 1.0;\n            vec3  mate = vec3(1.0);\n            if( oid<1.5 ) // plane\n            {\n                mate = vec3(0.6)*(0.8+0.2*checkersGradBox( 2.0*uv ));\n                // analytic ambient occlusion\n                occ = 1.0-boxOcclusion( pos, nor, txx, txi, box );\n            }\t\t\t\n            else // box\n            {\n                mate = vec3(0.5)*(0.8+0.2*checkersGradBox( 5.0*uv ));\n                // fake ambient occlusion\n                occ  = 0.5 + 0.5*nor.y;\n                occ *= 0.5 + 0.5*clamp(pos.y,0.0,1.0);\n            }\t\t\n\n\n            // lighting\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            dif *= boxSoftShadow( pos+0.01*nor, lig, txx, box, 4.0 );\n            col = vec3(0.1,0.2,0.3)*occ + 2.0*dif*vec3(1.0,0.8,0.7);\n\n            // material * lighting\t\t\n            col *= mate;\n\n            // fog\n            col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytic fake soft shadow for boxes. With a single ray, we can compute a soft shadow.\n// It is \"plausible\", but not accurate. It can probably be optimized further, right now\n// I am testing the 12 edges, but generaly you only need to test between 1 and 6.\n\n\n// Other Box functions:\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n\n// Other Soft Shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n\n\n#define SHADOW_TYPE 2\n\n// SHADOW_TYPE = 2 ---> great soft shadow\n// SHADOW_TYPE = 1 ---> super cheap soft shadow\n// SHADOW_TYPE = 0 ---> regular hard shadows\n\n\n#if SHADOW_TYPE==2\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz); // dm = 1.0 - rd.x*rd.x\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n#endif\n\n#if SHADOW_TYPE==1\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    // fake soft shadow\n    if( tF<0.0) return 1.0;\n    float sh = clamp(0.3*sk*(tN-tF)/tN,0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}    \n#endif\n\n#if SHADOW_TYPE==0\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 1.0;\n\treturn 0.0;\n}\n#endif\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad,\n                 out vec2 outT, out vec3 outNor, out vec2 outST, out int outFaceID ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 s = vec3((rdd.x<0.0)?1.0:-1.0,\n                  (rdd.y<0.0)?1.0:-1.0,\n                  (rdd.z<0.0)?1.0:-1.0);\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 t1 = m*(-roo + s*rad);\n    vec3 t2 = m*(-roo - s*rad);\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return false;\n\n    // compute normal (in world space), face and UV\n         if( t1.x>t1.y && t1.x>t1.z ) { outNor = txi[0].xyz*s.x; outST = roo.yz+rdd.yz*t1.x; outFaceID=(1+int(s.x))/2; /* 0, 1 */ } \n    else if( t1.y>t1.z   )            { outNor = txi[1].xyz*s.y; outST = roo.zx+rdd.zx*t1.y; outFaceID=(5+int(s.y))/2; /* 2, 3 */ }\n    else                              { outNor = txi[2].xyz*s.z; outST = roo.xy+rdd.xy*t1.z; outFaceID=(9+int(s.z))/2; /* 4, 5 */ }\n\n\toutT = vec2(tN,tF);\n    \n    return true;\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    vec3 p = (txx*vec4(pos,1.0)).xyz;\n    vec3 n = (txx*vec4(nor,0.0)).xyz;\n    vec3 r = (txx*vec4(rad,0.0)).xyz;\n    vec3 q = p - n*r;\n    vec3 v = abs(q) - r;\n    vec3 s = max(v,0.0);\n    float d = length(max(v.yzx,v.zxy));\n    d = min(d,max(v.x,v.y));\n    d = min(d,max(v.y,v.z));\n    d = min(d,max(v.z,v.x));\n    d = max(d,dot(s,vec3(1.0)));\n    return clamp(1.0-d*d*d*d,0.0,1.0);\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // animate box\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n    mat4 tra = translate( 0.0, 1.0, 0.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );\n    vec3 box = vec3(0.4,0.6,0.8);\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float tmin = 10000.0;\n        vec3  nor = vec3(0.0);\n        vec3  pos = vec3(0.0);\n        vec2  uv = vec2(0.0);\n\n        // raytrace-plane\n        float oid = 0.0;\n        float h = (0.0-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n            pos = ro + rd*h;\n            uv = pos.xz;\n        }\n\n        // raytrace box\n        vec3 bnor;  vec2 buv;\n        int outFaceID;\n        vec2 tnf;\n        if( boxIntersect( ro, rd, txx, txi, box, tnf, bnor, buv, outFaceID) )\n        {\n            if( tnf.x>0.0 && tnf.x<tmin )\n            {\n                tmin = tnf.x; \n                nor = bnor;\n                uv = buv;\n                oid = 2.0;\n        \t}\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.9);\n        if( tmin<100.0 )\n        {\n            vec3 lig = normalize(vec3(0.3,0.5,0.8));\n            pos = ro + tmin*rd;\n\n            // material\n            float occ = 1.0;\n            vec3  mate = vec3(1.0);\n            if( oid<1.5 ) // plane\n            {\n                mate = vec3(0.6)*(0.8+0.2*checkersGradBox( 2.0*uv ));\n                // analytic ambient occlusion\n                occ = 1.0-boxOcclusion( pos, nor, txx, txi, box );\n            }\t\t\t\n            else // box\n            {\n                mate = vec3(0.5)*(0.8+0.2*checkersGradBox( 5.0*uv ));\n                // fake ambient occlusion\n                occ  = 0.5 + 0.5*nor.y;\n                occ *= 0.5 + 0.5*clamp(pos.y,0.0,1.0);\n            }\t\t\n\n\n            // lighting\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            dif *= boxSoftShadow( pos+0.01*nor, lig, txx, box, 4.0 );\n            col = vec3(0.1,0.2,0.3)*occ + 2.0*dif*vec3(1.0,0.8,0.7);\n\n            // material * lighting\t\t\n            col *= mate;\n\n            // fog\n            col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytic fake soft shadow for boxes. With a single ray, we can compute a soft shadow.\n// It is \"plausible\", but not accurate. It can probably be optimized further, right now\n// I am testing the 12 edges, but generaly you only need to test between 1 and 6.\n\n\n// Other Box functions:\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n\n// Other Soft Shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n\n\n#define SHADOW_TYPE 2\n\n// SHADOW_TYPE = 2 ---> great soft shadow\n// SHADOW_TYPE = 1 ---> super cheap soft shadow\n// SHADOW_TYPE = 0 ---> regular hard shadows\n\n\n#if SHADOW_TYPE==2\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz); // dm = 1.0 - rd.x*rd.x\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n#endif\n\n#if SHADOW_TYPE==1\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    // fake soft shadow\n    if( tF<0.0) return 1.0;\n    float sh = clamp(0.3*sk*(tN-tF)/tN,0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}    \n#endif\n\n#if SHADOW_TYPE==0\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 1.0;\n\treturn 0.0;\n}\n#endif\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad,\n                 out vec2 outT, out vec3 outNor, out vec2 outST, out int outFaceID ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 s = vec3((rdd.x<0.0)?1.0:-1.0,\n                  (rdd.y<0.0)?1.0:-1.0,\n                  (rdd.z<0.0)?1.0:-1.0);\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 t1 = m*(-roo + s*rad);\n    vec3 t2 = m*(-roo - s*rad);\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return false;\n\n    // compute normal (in world space), face and UV\n         if( t1.x>t1.y && t1.x>t1.z ) { outNor = txi[0].xyz*s.x; outST = roo.yz+rdd.yz*t1.x; outFaceID=(1+int(s.x))/2; /* 0, 1 */ } \n    else if( t1.y>t1.z   )            { outNor = txi[1].xyz*s.y; outST = roo.zx+rdd.zx*t1.y; outFaceID=(5+int(s.y))/2; /* 2, 3 */ }\n    else                              { outNor = txi[2].xyz*s.z; outST = roo.xy+rdd.xy*t1.z; outFaceID=(9+int(s.z))/2; /* 4, 5 */ }\n\n\toutT = vec2(tN,tF);\n    \n    return true;\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // 8 verts\n    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*rad - p);\n    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*rad - p);\n    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*rad - p);\n    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*rad - p);\n    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*rad - p);\n    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*rad - p);\n    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*rad - p);\n    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*rad - p);\n    \n    // 12 edges    \n    float k02 = dot( n, normalize( cross(v2,v0)) ) * acos( clamp(dot(v0,v2),-1.0,1.0) );\n    float k23 = dot( n, normalize( cross(v3,v2)) ) * acos( clamp(dot(v2,v3),-1.0,1.0) );\n    float k31 = dot( n, normalize( cross(v1,v3)) ) * acos( clamp(dot(v3,v1),-1.0,1.0) );\n    float k10 = dot( n, normalize( cross(v0,v1)) ) * acos( clamp(dot(v1,v0),-1.0,1.0) );\n    float k45 = dot( n, normalize( cross(v5,v4)) ) * acos( clamp(dot(v4,v5),-1.0,1.0) );\n    float k57 = dot( n, normalize( cross(v7,v5)) ) * acos( clamp(dot(v5,v7),-1.0,1.0) );\n    float k76 = dot( n, normalize( cross(v6,v7)) ) * acos( clamp(dot(v7,v6),-1.0,1.0) );\n    float k37 = dot( n, normalize( cross(v7,v3)) ) * acos( clamp(dot(v3,v7),-1.0,1.0) );\n    float k64 = dot( n, normalize( cross(v4,v6)) ) * acos( clamp(dot(v6,v4),-1.0,1.0) );\n    float k51 = dot( n, normalize( cross(v1,v5)) ) * acos( clamp(dot(v5,v1),-1.0,1.0) );\n    float k04 = dot( n, normalize( cross(v4,v0)) ) * acos( clamp(dot(v0,v4),-1.0,1.0) );\n    float k62 = dot( n, normalize( cross(v2,v6)) ) * acos( clamp(dot(v6,v2),-1.0,1.0) );\n    \n    // 6 faces    \n    float occ = 0.0;\n    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );\n    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );\n    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );\n    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );\n    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );\n    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );\n        \n    return occ / 6.2831;\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 q = floor(p);\n    vec2 r = fract(p);\n    float s = dot(q, vec2(1.0, -1.0));\n    float a = 1.0 - abs(s);\n    float b = 1.0 - abs(s+1.0);\n    float c = 1.0 - abs(s-1.0);\n    float k = smoothstep(0.0, 1.0, a*r.x + b*(1.0-r.x));\n    return mix(a, c, k);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // animate box\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n    mat4 tra = translate( 0.0, 1.0, 0.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );\n    vec3 box = vec3(0.4,0.6,0.8);\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float tmin = 10000.0;\n        vec3  nor = vec3(0.0);\n        vec3  pos = vec3(0.0);\n        vec2  uv = vec2(0.0);\n\n        // raytrace-plane\n        float oid = 0.0;\n        float h = (0.0-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n            pos = ro + rd*h;\n            uv = pos.xz;\n        }\n\n        // raytrace box\n        vec3 bnor;  vec2 buv;\n        int outFaceID;\n        vec2 tnf;\n        if( boxIntersect( ro, rd, txx, txi, box, tnf, bnor, buv, outFaceID) )\n        {\n            if( tnf.x>0.0 && tnf.x<tmin )\n            {\n                tmin = tnf.x; \n                nor = bnor;\n                uv = buv;\n                oid = 2.0;\n        \t}\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.9);\n        if( tmin<100.0 )\n        {\n            vec3 lig = normalize(vec3(0.3,0.5,0.8));\n            pos = ro + tmin*rd;\n\n            // material\n            float occ = 1.0;\n            vec3  mate = vec3(1.0);\n            if( oid<1.5 ) // plane\n            {\n                mate = vec3(0.6)*(0.8+0.2*checkersGradBox( 2.0*uv ));\n                // analytic ambient occlusion\n                occ = 1.0-boxOcclusion( pos, nor, txx, txi, box );\n            }\t\t\t\n            else // box\n            {\n                mate = vec3(0.5)*(0.8+0.2*checkersGradBox( 5.0*uv ));\n                // fake ambient occlusion\n                occ  = 0.5 + 0.5*nor.y;\n                occ *= 0.5 + 0.5*clamp(pos.y,0.0,1.0);\n            }\t\t\n\n\n            // lighting\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            dif *= boxSoftShadow( pos+0.01*nor, lig, txx, box, 4.0 );\n            col = vec3(0.1,0.2,0.3)*occ + 2.0*dif*vec3(1.0,0.8,0.7);\n\n            // material * lighting\t\t\n            col *= mate;\n\n            // fog\n            col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(127.1,311.7)))*43758.5453123);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    ivec2 i = ivec2(floor(x));\n     vec2 f =       fract(x);\n    \n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash((i+ivec2(0,0))&(p-1)), \n                    hash((i+ivec2(1,0))&(p-1)),f.x),\n               mix( hash((i+ivec2(0,1))&(p-1)), \n                    hash((i+ivec2(1,1))&(p-1)),f.x),f.y);\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        f += s*noise( x, p );\n        s *= 0.5;\n        x *= 2.0;\n        p *= 2;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    bool polar = fract(iTime/6.0)>0.5;\n\n    // coords\n    vec2 q = (polar) ? vec2( 4.0+4.0*atan(p.y,p.x)/3.1415927, length(p) ) :  p*8.0;\n    q += 0.5*iTime;\n\n    // fbm\n    const int pe = 8; // Period. Make it a power of 2\n    float f = fbm( q, pe );\n\tvec3 col = vec3(f);\n\n    // grid\n    if( !polar )\n    {\n        vec2 w = smoothstep(0.0,0.01,abs(mod(8.0*p+float(pe/2),float(pe))/float(pe)-0.5));\n        col = mix( col, vec3(1.0,0.7,0.0), (1.0-w.x*w.y)*smoothstep( 0.8,0.9,sin(iTime) ) );\n    }\n    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    // You SHOULD replace this by something better. Again, Do Not Use in production.\n    int n = q.x*131 + q.y*57;\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float((n>>8)&0x007fffff)/float(0x007fffff);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        f += s*noise( x, p );\n        s *= 0.5;\n        x *= 2.0;\n        p *= 2;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    bool polar = fract(iTime/6.0)>0.5;\n\n    // coords\n    vec2 q = (polar) ? vec2( 4.0+4.0*atan(p.y,p.x)/3.1415927, length(p) ) :  p*8.0;\n    q += 0.5*iTime;\n\n    // fbm\n    const int pe = 8; // Period. Make it a power of 2\n    float f = fbm( q, pe );\n\tvec3 col = vec3(f);\n\n    // grid\n    if( !polar )\n    {\n        vec2 w = smoothstep(0.0,0.01,abs(mod(8.0*p+float(pe/2),float(pe))/float(pe)-0.5));\n        col = mix( col, vec3(1.0,0.7,0.0), (1.0-w.x*w.y)*smoothstep( 0.8,0.9,sin(iTime) ) );\n    }\n    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    // You SHOULD replace this by something better. Again, Do Not Use in production.\n    int n = q.x*131 + q.y*57;\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float((n>>8)&0x007fffff)/float(0x007fffff);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    ivec2 i = ivec2(floor(x));\n     vec2 f =       fract(x);\n    \n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash((i+ivec2(0,0))&(p-1)), \n                    hash((i+ivec2(1,0))&(p-1)),f.x),\n               mix( hash((i+ivec2(0,1))&(p-1)), \n                    hash((i+ivec2(1,1))&(p-1)),f.x),f.y);\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float f = 0.0;\n    float w = 0.5;\n    for( int i=0; i<p; i++ )\n    {\n        f += w * noise(x);\n        x = x * 2.0;\n        w = w*0.5;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    bool polar = fract(iTime/6.0)>0.5;\n\n    // coords\n    vec2 q = (polar) ? vec2( 4.0+4.0*atan(p.y,p.x)/3.1415927, length(p) ) :  p*8.0;\n    q += 0.5*iTime;\n\n    // fbm\n    const int pe = 8; // Period. Make it a power of 2\n    float f = fbm( q, pe );\n\tvec3 col = vec3(f);\n\n    // grid\n    if( !polar )\n    {\n        vec2 w = smoothstep(0.0,0.01,abs(mod(8.0*p+float(pe/2),float(pe))/float(pe)-0.5));\n        col = mix( col, vec3(1.0,0.7,0.0), (1.0-w.x*w.y)*smoothstep( 0.8,0.9,sin(iTime) ) );\n    }\n    \n    \n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Code is based on: https://www.shadertoy.com/view/MlGcDz\n\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n\n// data from my modeling data.\nconst int numVertices = 60;\nconst int numFaces = 42;\n\nconst float vertices[60] = float[](\n    1.013484,-0.004748,-0.170576,1.363493,-0.372823,-1.554794,0.917013,-0.178702,-0.862685,1.288280,-0.178702,-0.862685,1.350874,-0.372823,1.669797,1.010963,-0.004748,0.212469,0.914492,-0.178702,0.904577,1.285759,-0.178702,0.904577,0.581273,-0.024900,0.352901,1.127463,-0.024900,0.352901,1.146371,0.728927,1.492630,0.581273,-0.023149,-0.350895,1.127463,-0.023149,-0.350895,1.146371,0.730678,-1.392582,1.000000,-0.010163,0.363769,1.000000,-0.002439,-0.369747,-1.000000,0.000000,0.006199,0.830098,0.325427,-0.003099,0.862253,-0.223150,0.009298,1.247514,-0.006511,0.004402\n);\n\nconst int faces[42] = int[](\n    3,4,2,1,4,3,7,8,6,5,8,7,9,10,11,12,13,14,17,15,18,18,20,16,15,17,19,16,17,18,19,17,16,16,20,19,19,20,15,20,18,15\n);\n\nconst int numVertices2 = 60;\nconst int numFaces2 = 69;\n\nconst float vertices2[60] = float[](\n-0.050644,-1.000000,-0.287185,-0.046908,-1.000000,0.282374,-0.022325,1.000000,-0.603118,0.252637,-0.756947,0.001045,0.086070,-0.554094,0.470331,0.080405,-0.581953,-0.393294,-0.310284,-0.550998,-0.745497,-0.299836,-0.538616,0.847426,0.301236,-0.464652,0.021582,-0.203997,0.661104,-0.847783,0.081116,0.650054,-0.284954,0.155316,0.606239,-0.650704,0.163361,0.764587,-0.622910,-0.191163,0.699229,0.950683,0.172071,0.792447,0.705030,0.085968,0.690296,0.454854,0.166343,0.645718,0.705368,-0.012304,0.995923,0.721267,0.357289,0.557239,0.010229,0.082718,1.115938,0.002954\n);\n\nconst int faces2[69] = int[](\n3,11,13,12,11,9,2,5,8,2,4,5,4,1,6,4,2,1,6,1,7,6,7,10,11,3,19,8,5,14,18,14,15,14,5,9,14,9,17,9,10,12,10,9,6,11,19,9,19,16,9,3,20,19,18,16,19,16,17,9,20,18,19,3,13,10,18,15,16\n);\n\n// Triangle intersection. Returns { t, u, v }\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1-v0, e2 = v2-v0;\n    vec3  p = cross(rd,e2), tvec;\n    float det = dot(e1,p);\n    if( abs(det) < 0.001 ) return vec3(0.0);\n    float invdet = 1.0 / det;\n    tvec = ro - v0;\n    float u = dot(tvec,p)*invdet;\n    if( u<0.0 || u>1.0 ) return vec3(0.0);\n    vec3 q = cross(tvec,e1);\n    float v = dot(rd,q)*invdet;\n    if( v<0.0 || (u+v)>1.0 ) return vec3(0.0);\n    float t = dot(e2,q)*invdet;\n    return vec3(t,u,v);\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\tvec2 prevP = p;\n    \n    // camera\n\tvec3 ro = vec3(5.0,1.0,0.0);\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n    \n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  pos = vec3(0.0);\n\tfloat oid = 0.0;\n\n    // player model\n    int index = 0;\n    float xpos = 3.0;\n    float ypos = 0.3+sin(iTime*0.5)*0.5;\n    float zpos = 0.0;\n    vec3 airCraftColor = vec3(0.7);\n    mat3 rotX = matRotateX(radians(sin(iTime*0.7)*30.0));\n    for(int i = 0; i<numFaces/3; i++){\n        int f1 = faces[index];\n        int f2 = faces[index+1];\n        int f3 = faces[index+2];\n        \n        vec3 v0 = vec3(vertices[(f1*3)-3],vertices[((f1*3)-3)+1],vertices[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices[(f2*3)-3],vertices[((f2*3)-3)+1],vertices[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices[(f3*3)-3],vertices[((f3*3)-3)+1],vertices[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \t\n        v0.x += 1.0;\n        v1.x += 1.0;\n        v2.x += 1.0;\n        \n        v0 *= rotX;\n        v1 *= rotX;\n        v2 *= rotX;\n        \n        float xspeed = 0.9;\n        v0.z += sin(iTime*xspeed)*1.5;\n        v1.z += sin(iTime*xspeed)*1.5;\n        v2.z += sin(iTime*xspeed)*1.5;\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 2.0;\n            airCraftColor = vec3(0.6-(float(i)*0.02));\n            if(f1 == 9 && f2 == 10 && f3 == 11 || f1 == 12 && f2 == 13 && f3 == 14){\n            \tairCraftColor = vec3(0.0,0.0,1.0);\n            } else if(f1 == 19 && f2 == 20 && f3 == 15){\n                airCraftColor = mod(iTime,0.2)<0.1?vec3(0.9,0.45,0.2):vec3(0.9,0.45,0.2)*1.5;\n            } else if(f1 == 16 && f2 == 20 && f3 == 19){\n                airCraftColor = mod(iTime,0.2)<0.1?vec3(0.9,0.4,0.2):vec3(0.9,0.4,0.2)*1.5;\n            }\n        }\n        index += 3;\n    }\n\n    // boss model\n    index = 0;\n    ypos = 1.5+sin(iTime*0.3)*-0.1;\n    xpos = 1.0+sin(iTime*0.5)*-1.5;\n    zpos = sin(iTime*1.2)*2.0;\n    vec3 bossColor = vec3(0.7);\n    float manimate = sin(iTime*5.0)*0.05;\n    for(int i = 0; i<numFaces2/3; i++){\n        int f1 = faces2[index];\n        int f2 = faces2[index+1];\n        int f3 = faces2[index+2];\n        \n        vec3 v0 = vec3(vertices2[(f1*3)-3],vertices2[((f1*3)-3)+1],vertices2[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices2[(f2*3)-3],vertices2[((f2*3)-3)+1],vertices2[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices2[(f3*3)-3],vertices2[((f3*3)-3)+1],vertices2[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \n\t\tv0.x -= xpos;\n        v1.x -= xpos;\n        v2.x -= xpos;\n        \n\t\tv0.z += zpos;\n        v1.z += zpos;\n        v2.z += zpos;\n        \n        // mouth animation\n        if(f1 == 9){\n            v0.y += manimate;\n        }\n        if(f2 == 9){\n            v1.y += manimate;\n        }\n        if(f3 == 9){\n            v2.y += manimate;\n        }\n        \n\t\tif(f1 == 4){\n            v0.y += manimate*-1.0;\n        }\n        if(f2 == 4){\n            v1.y += manimate*-1.0;\n        }\n        if(f3 == 4){\n            v2.y += manimate*-1.0;\n        }\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 3.0;\n            bossColor = vec3(0.7-(float(i)*0.02));\n        }\n        index += 3;\n    }\n    \n\t// enemy bullet\n\tvec3 box = vec3(0.2,0.03,0.2);\n    vec3 bcolor = vec3(0.8);\n    mat4 brotX = rotationAxisAngle(vec3(1.0,0.0,0.0),radians(iTime*30.0));\n    mat4 tra = translate( -xpos+mod(iTime*2.0,3.0)*3.0, 1.0, zpos );\n    mat4 txi = tra *brotX; \n    mat4 txx = inverse( txi );       \n\t\n    vec4 res = iBox( ro, rd, txx, txi, box);\n    if( res.x>0.0 && res.x<tmin )\n    {\n        tmin = res.x; \n        oid = 1.0;\n        bcolor = vec3(0.8-(tmin*0.1));\n    }\n    \n    // material/bg\n\tvec3 col = vec3(1.0);\n\tif( tmin<100.0 )\n\t{\n        // material\n\t\tvec3  mate = vec3(.0);\n\t\tif( oid<1.5 ) {\n\t\t    mate = bcolor;\n\t\t} else if( oid>=1.5 && oid<=2.0 ) {\n\t\t    mate = airCraftColor;\n\t\t} else if( oid>2.1 && oid<=3.0 ){\n            mate = bossColor;\n        }\n\t\tmate = mate*mate*1.1;\n        \t\n\t\tcol *= mate;\n\n\t\tcol = sqrt( col );\n    } else {\n        // bg\n    \tcol = vec3(0.0);\n        prevP.x+=sin(iTime+p.y)*0.7;\n        float rbg = (length(prevP+vec2(2.5,0.0))-0.5)+sin(iTime+p.y)*0.2;\n        col = mix( col, vec3(0.9,0.5,0.0), 1.0-smoothstep(0.15,2.5,abs(rbg)));\n        \n\t\tfloat lbg = (length(prevP+vec2(-2.5,0.0))-0.5)+sin(iTime+p.y)*0.2;\n        col = mix( col, vec3(1.0,0.2,0.2), 1.0-smoothstep(0.15,2.5,abs(lbg)));\n    }\n\t\n    // UI\n    p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float ganimate = sin(iTime*1.5)*0.1;\n    \n    float playerBarBg = dBox2d(p+vec2(1.20, 0.85), vec2(0.3,0.055));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.011,abs(playerBarBg)));\n    \n    float playerBar = dBox2d(p+vec2(1.3-ganimate, 0.85), vec2(0.15+ganimate,0.006));\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.029,0.03,abs(playerBar)));\n    \n\tfloat bossBarBg = dBox2d(p+vec2(-1.20, 0.85), vec2(0.3,0.055));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.011,abs(bossBarBg)));\n    \n    float bossBar = dBox2d(p+vec2(-1.2, 0.85), vec2(0.25,0.006));\n    col = mix( col, vec3(0.6,0.6,1.0), 1.0-smoothstep(0.029,0.03,abs(bossBar)));\n    \n    // result\n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Code is based on: https://www.shadertoy.com/view/MlGcDz\n\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n\n// data from my modeling data.\nconst int numVertices = 60;\nconst int numFaces = 42;\n\nconst float vertices[60] = float[](\n    1.013484,-0.004748,-0.170576,1.363493,-0.372823,-1.554794,0.917013,-0.178702,-0.862685,1.288280,-0.178702,-0.862685,1.350874,-0.372823,1.669797,1.010963,-0.004748,0.212469,0.914492,-0.178702,0.904577,1.285759,-0.178702,0.904577,0.581273,-0.024900,0.352901,1.127463,-0.024900,0.352901,1.146371,0.728927,1.492630,0.581273,-0.023149,-0.350895,1.127463,-0.023149,-0.350895,1.146371,0.730678,-1.392582,1.000000,-0.010163,0.363769,1.000000,-0.002439,-0.369747,-1.000000,0.000000,0.006199,0.830098,0.325427,-0.003099,0.862253,-0.223150,0.009298,1.247514,-0.006511,0.004402\n);\n\nconst int faces[42] = int[](\n    3,4,2,1,4,3,7,8,6,5,8,7,9,10,11,12,13,14,17,15,18,18,20,16,15,17,19,16,17,18,19,17,16,16,20,19,19,20,15,20,18,15\n);\n\nconst int numVertices2 = 60;\nconst int numFaces2 = 69;\n\nconst float vertices2[60] = float[](\n-0.050644,-1.000000,-0.287185,-0.046908,-1.000000,0.282374,-0.022325,1.000000,-0.603118,0.252637,-0.756947,0.001045,0.086070,-0.554094,0.470331,0.080405,-0.581953,-0.393294,-0.310284,-0.550998,-0.745497,-0.299836,-0.538616,0.847426,0.301236,-0.464652,0.021582,-0.203997,0.661104,-0.847783,0.081116,0.650054,-0.284954,0.155316,0.606239,-0.650704,0.163361,0.764587,-0.622910,-0.191163,0.699229,0.950683,0.172071,0.792447,0.705030,0.085968,0.690296,0.454854,0.166343,0.645718,0.705368,-0.012304,0.995923,0.721267,0.357289,0.557239,0.010229,0.082718,1.115938,0.002954\n);\n\nconst int faces2[69] = int[](\n3,11,13,12,11,9,2,5,8,2,4,5,4,1,6,4,2,1,6,1,7,6,7,10,11,3,19,8,5,14,18,14,15,14,5,9,14,9,17,9,10,12,10,9,6,11,19,9,19,16,9,3,20,19,18,16,19,16,17,9,20,18,19,3,13,10,18,15,16\n);\n\n// Triangle intersection. Returns { t, u, v }\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t\u00b7rd = p(u,v) = vo + u\u00b7(v1-v0) + v\u00b7(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec4( -1.0 );\n    vec3 ig = vec3(0.0);\n    if( t1.x>t1.y && t1.x>t1.z ) ig = vec3(-1.0,  0.0,  0.0);\n    if( t1.y>t1.x && t1.y>t1.z ) ig = vec3( 0.0, -1.0,  0.0);\n    if( t1.z>t1.x && t1.z>t1.y ) ig = vec3( 0.0,  0.0, -1.0);\n    return vec4( tN, dot(ig,txx[0].xyz) );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\tvec2 prevP = p;\n    \n    // camera\n\tvec3 ro = vec3(5.0,1.0,0.0);\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n    \n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  pos = vec3(0.0);\n\tfloat oid = 0.0;\n\n    // player model\n    int index = 0;\n    float xpos = 3.0;\n    float ypos = 0.3+sin(iTime*0.5)*0.5;\n    float zpos = 0.0;\n    vec3 airCraftColor = vec3(0.7);\n    mat3 rotX = matRotateX(radians(sin(iTime*0.7)*30.0));\n    for(int i = 0; i<numFaces/3; i++){\n        int f1 = faces[index];\n        int f2 = faces[index+1];\n        int f3 = faces[index+2];\n        \n        vec3 v0 = vec3(vertices[(f1*3)-3],vertices[((f1*3)-3)+1],vertices[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices[(f2*3)-3],vertices[((f2*3)-3)+1],vertices[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices[(f3*3)-3],vertices[((f3*3)-3)+1],vertices[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \t\n        v0.x += 1.0;\n        v1.x += 1.0;\n        v2.x += 1.0;\n        \n        v0 *= rotX;\n        v1 *= rotX;\n        v2 *= rotX;\n        \n        float xspeed = 0.9;\n        v0.z += sin(iTime*xspeed)*1.5;\n        v1.z += sin(iTime*xspeed)*1.5;\n        v2.z += sin(iTime*xspeed)*1.5;\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 2.0;\n            airCraftColor = vec3(0.6-(float(i)*0.02));\n            if(f1 == 9 && f2 == 10 && f3 == 11 || f1 == 12 && f2 == 13 && f3 == 14){\n            \tairCraftColor = vec3(0.0,0.0,1.0);\n            } else if(f1 == 19 && f2 == 20 && f3 == 15){\n                airCraftColor = mod(iTime,0.2)<0.1?vec3(0.9,0.45,0.2):vec3(0.9,0.45,0.2)*1.5;\n            } else if(f1 == 16 && f2 == 20 && f3 == 19){\n                airCraftColor = mod(iTime,0.2)<0.1?vec3(0.9,0.4,0.2):vec3(0.9,0.4,0.2)*1.5;\n            }\n        }\n        index += 3;\n    }\n\n    // boss model\n    index = 0;\n    ypos = 1.5+sin(iTime*0.3)*-0.1;\n    xpos = 1.0+sin(iTime*0.5)*-1.5;\n    zpos = sin(iTime*1.2)*2.0;\n    vec3 bossColor = vec3(0.7);\n    float manimate = sin(iTime*5.0)*0.05;\n    for(int i = 0; i<numFaces2/3; i++){\n        int f1 = faces2[index];\n        int f2 = faces2[index+1];\n        int f3 = faces2[index+2];\n        \n        vec3 v0 = vec3(vertices2[(f1*3)-3],vertices2[((f1*3)-3)+1],vertices2[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices2[(f2*3)-3],vertices2[((f2*3)-3)+1],vertices2[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices2[(f3*3)-3],vertices2[((f3*3)-3)+1],vertices2[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \n\t\tv0.x -= xpos;\n        v1.x -= xpos;\n        v2.x -= xpos;\n        \n\t\tv0.z += zpos;\n        v1.z += zpos;\n        v2.z += zpos;\n        \n        // mouth animation\n        if(f1 == 9){\n            v0.y += manimate;\n        }\n        if(f2 == 9){\n            v1.y += manimate;\n        }\n        if(f3 == 9){\n            v2.y += manimate;\n        }\n        \n\t\tif(f1 == 4){\n            v0.y += manimate*-1.0;\n        }\n        if(f2 == 4){\n            v1.y += manimate*-1.0;\n        }\n        if(f3 == 4){\n            v2.y += manimate*-1.0;\n        }\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 3.0;\n            bossColor = vec3(0.7-(float(i)*0.02));\n        }\n        index += 3;\n    }\n    \n\t// enemy bullet\n\tvec3 box = vec3(0.2,0.03,0.2);\n    vec3 bcolor = vec3(0.8);\n    mat4 brotX = rotationAxisAngle(vec3(1.0,0.0,0.0),radians(iTime*30.0));\n    mat4 tra = translate( -xpos+mod(iTime*2.0,3.0)*3.0, 1.0, zpos );\n    mat4 txi = tra *brotX; \n    mat4 txx = inverse( txi );       \n\t\n    vec4 res = iBox( ro, rd, txx, txi, box);\n    if( res.x>0.0 && res.x<tmin )\n    {\n        tmin = res.x; \n        oid = 1.0;\n        bcolor = vec3(0.8-(tmin*0.1));\n    }\n    \n    // material/bg\n\tvec3 col = vec3(1.0);\n\tif( tmin<100.0 )\n\t{\n        // material\n\t\tvec3  mate = vec3(.0);\n\t\tif( oid<1.5 ) {\n\t\t    mate = bcolor;\n\t\t} else if( oid>=1.5 && oid<=2.0 ) {\n\t\t    mate = airCraftColor;\n\t\t} else if( oid>2.1 && oid<=3.0 ){\n            mate = bossColor;\n        }\n\t\tmate = mate*mate*1.1;\n        \t\n\t\tcol *= mate;\n\n\t\tcol = sqrt( col );\n    } else {\n        // bg\n    \tcol = vec3(0.0);\n        prevP.x+=sin(iTime+p.y)*0.7;\n        float rbg = (length(prevP+vec2(2.5,0.0))-0.5)+sin(iTime+p.y)*0.2;\n        col = mix( col, vec3(0.9,0.5,0.0), 1.0-smoothstep(0.15,2.5,abs(rbg)));\n        \n\t\tfloat lbg = (length(prevP+vec2(-2.5,0.0))-0.5)+sin(iTime+p.y)*0.2;\n        col = mix( col, vec3(1.0,0.2,0.2), 1.0-smoothstep(0.15,2.5,abs(lbg)));\n    }\n\t\n    // UI\n    p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float ganimate = sin(iTime*1.5)*0.1;\n    \n    float playerBarBg = dBox2d(p+vec2(1.20, 0.85), vec2(0.3,0.055));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.011,abs(playerBarBg)));\n    \n    float playerBar = dBox2d(p+vec2(1.3-ganimate, 0.85), vec2(0.15+ganimate,0.006));\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.029,0.03,abs(playerBar)));\n    \n\tfloat bossBarBg = dBox2d(p+vec2(-1.20, 0.85), vec2(0.3,0.055));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.011,abs(bossBarBg)));\n    \n    float bossBar = dBox2d(p+vec2(-1.2, 0.85), vec2(0.25,0.006));\n    col = mix( col, vec3(0.6,0.6,1.0), 1.0-smoothstep(0.029,0.03,abs(bossBar)));\n    \n    // result\n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tfloat h = dot(p,vec2(127.1,311.7));\n\t\t\t\treturn fract(sin(h)*43758.5453123);\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tvec4 value = vec4(0.0);\n\t\t\t\tvec3 pos = vec3(0.0);\n\t\t\t\tvec3 vel = vec3(0.0);\n\t\t\t\tvec3 acc = vec3(0.0);\n\t\t\t\tvec3 force = vec3(0.0);\n\t\t\t\tvec3 force_dir = vec3(0.0);\n\t\t\t\tfloat force_mag = 0.0;\n\t\t\t\tfloat dist = 0.0;\n\t\t\t\tfloat dist_sq = 0.0;\n\t\t\t\tfloat dist_inv = 0.0;\n\t\t\t\tfloat dist_inv_sq = 0.0;\n\t\t\t\tfloat dist_inv_cub = 0.0;\n\t\t\t\tfloat dist_inv_quart = 0.0;\n\t\t\t\tfloat dist_inv_quint = 0.0;\n\t\t\t\tfloat dist_inv_six = 0.0;\n\t\t\t\tfloat dist_inv_sept = 0.0;\n\t\t\t\tfloat dist_inv_oct = 0.0;\n\t\t\t\tfloat dist_inv_nin = 0.0;\n\t\t\t\tfloat dist_inv_ten = 0.0;\n\t\t\t\tfloat dist_inv_ele = 0.0;\n\t\t\t\tfloat dist_inv_twel = 0.0;\n\t\t\t\tfloat dist_inv_thir = 0.0;\n\t\t\t\tfloat dist_inv_fourt = 0.0;\n\t\t\t\tfloat dist_inv_fift = 0.0;\n\t\t\t\tfloat dist_inv_sixt = 0.0;\n\t\t\t\tfloat dist_inv_sevent = 0.0;\n\t\t\t\tfloat dist_inv_eight = 0.0;\n\t\t\t\tfloat dist_inv_ninet = 0.0;\n\t\t\t\tfloat dist_inv_tenn = 0.0;\n\t\t\t\tfloat dist_inv_elev = 0.0;\n\t\t\t\tfloat dist_inv_twelv = 0.0;\n\t\t\t\tfloat dist_inv_thirt = 0.0;\n\t\t\t\tfloat dist_inv_fourte = 0.0;\n\t\t\t\tfloat dist_inv_fifte = 0.0;\n\t\t\t\tfloat dist_inv_sixtt = 0.0;\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\n\t\t\t\tvec3 b = balls[i];\n\t\t\t\tfloat d = length(b.xyz - p);\n\t\t\t\td = b.w / (d * d);\n\t\t\t\treturn d;\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d = 0.0;\n\t\t\t\tfor(int i = 0; i < 3; i++)\n\t\t\t\t{\n\t\t\t\t\tvec3 b = ball[i].xyz - p;\n\t\t\t\t\tfloat s = max(ball[i].w - dot(b, b), 0.0);\n\t\t\t\t\td += s;\n\t\t\t\t}\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d = 0.0;\n\t\t\t\tfloat t = 0.0;\n\t\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t\t{\n\t\t\t\t\td = min(d, length(p - vec3(0.0, 0.0, t)));\n\t\t\t\t\tt += 0.1;\n\t\t\t\t}\n\t\t\t\treturn d;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(1.0, -1.0)*0.5773*0.005;\n\t\t\t\treturn normalize( e.xyy*f( p + e.xyy ) +\n\t\t\t\t\t\t\t  e.yyx*f( p + e.yyx ) +\n\t\t\t\t\t\t\t  e.yxy*f( p + e.yxy ) +\n\t\t\t\t\t\t\t  e.xxx*f( p + e.xxx ) );\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd, float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.0;\n\t\t\t\tfloat h = 1.0;\n\t\t\t\tfor( int i=0; i<100; i++ )\n\t\t\t\t{\n\t\t\t\t\th = hn - height( ro + rd*t );\n\t\t\t\t\tif( h<0.001 ) break;\n\t\t\t\t\tt += h*0.5;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright \u00a9 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\n\t\t\t\tvec3 n=normalize(normal);\n\t\t\t\tvec3 l=normalize(lightPos-pos);\n\t\t\t\tvec3 v=normalize(ro-pos);\n\t\t\t\tvec3 r=reflect(-l,n);\n\t\t\t\tfloat lambert=max(dot(n,l),0.0);\n\t\t\t\tfloat specular=pow(max(dot(r,v),0.0),16.0);\n\t\t\t\treturn vec4(lambert*lightColor+specular*lightColor,1.0);\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The distance to a generic ellipsoid can be approximated, but produces\n// distorted distance fields that manifest, for example, in wrongly \n// rendered soft shadows.\n//\n// Symmetric ellipsoids (ellipses revolved in 3D) do allow however for an exact\n// distance estimation (although it requires solving a cubic, which is expensive)\n// and produce beautiful shadows.\n//\n// Left,  a symmetric ellipsoids rendered with the generic ellipsod method, \n//        producing a too big penumbra.\n// Right, same shape rendered with the symmetric solver, producing the\n//        correct penumbra.\n//\n// See also https://www.shadertoy.com/view/tdS3DG\n\n\n#define AA 2   // make this 4 is you have a fast computer\n\n//------------------------------------------------------------------\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = dot(p,p)/(r.x*r.x);\n    float k1 = dot(p,p)/(r.y*r.y);\n    float k2 = dot(p,p)/(r.z*r.z);\n    return sqrt(k0*k1*k2)/(r.x*r.x);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    return sdEllipse( vec2( length(p.xy), p.z ), r );\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    float d1 = (id==0) ? sdEllipsoid(    p, vec3(0.25,0.25,0.02) ) :\n                         sdEllipsoidXXZ( p, vec2(0.25,     0.02) );\n\n    // plane\n    float d2 = p.y+0.25;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<64 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t) );\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n  \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.1);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            occ = 1.0;\n            col *= 0.8+0.2*checkersGradBox( pos.xz*2.0 );\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.25,0.15,0.05);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.0, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        dif *= calcSoftshadow( pos, lig, id );\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.00*dif*vec3(3.30,2.50,2.00);\n        lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        col = col*lin;\n        col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The distance to a generic ellipsoid can be approximated, but produces\n// distorted distance fields that manifest, for example, in wrongly \n// rendered soft shadows.\n//\n// Symmetric ellipsoids (ellipses revolved in 3D) do allow however for an exact\n// distance estimation (although it requires solving a cubic, which is expensive)\n// and produce beautiful shadows.\n//\n// Left,  a symmetric ellipsoids rendered with the generic ellipsod method, \n//        producing a too big penumbra.\n// Right, same shape rendered with the symmetric solver, producing the\n//        correct penumbra.\n//\n// See also https://www.shadertoy.com/view/tdS3DG\n\n\n#define AA 2   // make this 4 is you have a fast computer\n\n//------------------------------------------------------------------\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec3 q = abs(p);\n    float l = length(q.xz);\n    float m = max(q.y, l);\n    if( l > m ) q.xz = q.xz*m/l;\n    return length(q) - r.x;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    float d1 = (id==0) ? sdEllipsoid(    p, vec3(0.25,0.25,0.02) ) :\n                         sdEllipsoidXXZ( p, vec2(0.25,     0.02) );\n\n    // plane\n    float d2 = p.y+0.25;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<64 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t) );\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n  \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.1);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            occ = 1.0;\n            col *= 0.8+0.2*checkersGradBox( pos.xz*2.0 );\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.25,0.15,0.05);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.0, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        dif *= calcSoftshadow( pos, lig, id );\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.00*dif*vec3(3.30,2.50,2.00);\n        lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        col = col*lin;\n        col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the exact distance to a generic (non symmetric) ellipsoid\n// requires solving a sixth degree equation, which can be difficult.\n// Approximating the distance is easier though. This shaders shows one\n// such approximation that produces better results than the naive\n// distance bound. More info here:\n//\n// http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\n//\n// Left, naive ellipsoid distance approximation (single square root)\n// Right, improved approximation (two square roots).\n//\n// Note how the improved approximation produces a more accurate intersection\n// for the same number of raymarching steps (specially noticeable in the first\n// frame of the animation). Note also how the penumbra shadow estimation works\n// best with since since it has a more eucliden distance as input.\n//\n// The technique is based on dividing the bad approximation's distance estimation\n// by the length of its gradient to get a first order approximation to the true\n// distance (see http://iquilezles.org/www/articles/distance/distance.htm)\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#define AA 2   // make this 3 is you have a fast computer\n\n//------------------------------------------------------------------\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p);\n    float d = max(q.x,max(q.y,q.z));\n    if( q.x>r.x ) q = q-2.0*r.x;\n    if( q.y>r.y ) q = q-2.0*r.y;\n    if( q.z>r.z ) q = q-2.0*r.z;\n    d = min(d,length(q));\n    return d;\n}\n\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    float d1 = (id==0) ? sdEllipsoid_Bad( p, vec3(0.18,0.3,0.02) ) :\n                         sdEllipsoid(     p, vec3(0.18,0.3,0.02) );\n\n    // plane\n    float d2 = p.y+0.3;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<100 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            col *= 0.7+0.3*checkersGradBox( pos.xz*2.0 );\n            occ = 1.0;\n\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.2);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.9, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        float sha = calcSoftshadow( pos, lig, id );\n        sha = sha*sha;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif * sha *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        //vec3 lin = vec3(0.0);\n        //lin += 2.00*dif*vec3(3.30,2.50,2.00)*sha;\n        //lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        //lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        //col = col*lin;\n        //col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        col *= 5.0;\n        col *= vec3(0.2,0.3,0.4)*amb*occ + 1.6*vec3(1.0,0.9,0.75)*dif*sha;\n        col += vec3(2.8,2.2,1.8)*spe*3.0;            \n\n\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    // scene selection\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    // render\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // separator    \n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the exact distance to a generic (non symmetric) ellipsoid\n// requires solving a sixth degree equation, which can be difficult.\n// Approximating the distance is easier though. This shaders shows one\n// such approximation that produces better results than the naive\n// distance bound. More info here:\n//\n// http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\n//\n// Left, naive ellipsoid distance approximation (single square root)\n// Right, improved approximation (two square roots).\n//\n// Note how the improved approximation produces a more accurate intersection\n// for the same number of raymarching steps (specially noticeable in the first\n// frame of the animation). Note also how the penumbra shadow estimation works\n// best with since since it has a more eucliden distance as input.\n//\n// The technique is based on dividing the bad approximation's distance estimation\n// by the length of its gradient to get a first order approximation to the true\n// distance (see http://iquilezles.org/www/articles/distance/distance.htm)\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#define AA 2   // make this 3 is you have a fast computer\n\n//------------------------------------------------------------------\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p);\n    float d = 0.0;\n    if( max(q.x,max(q.y,q.z)) > r.x )\n    {\n        d = max(q.x,max(q.y,q.z)) - r.x;\n    }\n    else\n    {\n        vec3 z = (q-r)*(q-r);\n        d = min(max(z.x,min(z.y,z.z)),max(z.y,z.z));\n        d = sqrt(d)/r.x;\n    }\n    return d;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    float d1 = (id==0) ? sdEllipsoid_Bad( p, vec3(0.18,0.3,0.02) ) :\n                         sdEllipsoid(     p, vec3(0.18,0.3,0.02) );\n\n    // plane\n    float d2 = p.y+0.3;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<100 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            col *= 0.7+0.3*checkersGradBox( pos.xz*2.0 );\n            occ = 1.0;\n\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.2);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.9, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        float sha = calcSoftshadow( pos, lig, id );\n        sha = sha*sha;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif * sha *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        //vec3 lin = vec3(0.0);\n        //lin += 2.00*dif*vec3(3.30,2.50,2.00)*sha;\n        //lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        //lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        //col = col*lin;\n        //col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        col *= 5.0;\n        col *= vec3(0.2,0.3,0.4)*amb*occ + 1.6*vec3(1.0,0.9,0.75)*dif*sha;\n        col += vec3(2.8,2.2,1.8)*spe*3.0;            \n\n\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    // scene selection\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    // render\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // separator    \n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the Lambert W function w = W(z) (https://en.wikipedia.org/wiki/Lambert_W_function)\n\n#define PI 3.14159265359\n#define EE 2.71828182846\n#define SCALE 5.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// from Fabrice Neyret, \n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A,B) cmul( A, cinv(B) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return a / (1.0 - a * (1.0 - x));\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// complex square root, from Numerical Recipes\n\nvec2 sqrtz( in vec2 z )\n{\n\tfloat ar = abs(z.x);\n    float ai = abs(z.y);\n\n    float w = (dot(z, z) == 0.0) ? 0.0 : ( (ar >= ai) ? (sqrt(ar) * sqrt(0.5 * (1.0 + sqrt(1.0 + (ai * ai)/(ar * ar))))) : (sqrt(ai) * sqrt(0.5 * (ar/ai + sqrt(1.0 + (ar * ar)/(ai * ai))))));\n    \n    return ((w == 0.0) ? vec2(0.0) : ((z.x >= 0.0 ? vec2(w, 0.5 * z.y/w) : vec2(0.5*ai/w, ((z.y >= 0.0) ? w : -w)))));\n}\n\n// complex logarithm\n\nvec2 logz( in vec2 z )\n{\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// Lambert W function, Winitzki's approximation (https://doi.org/10.1007/3-540-44839-X_82)\n\nvec2 LambertW( in vec2 z )\n{\n    vec2 v = sqrtz(2.0 * EE * z + 2.0);\n    vec2 w = 2.0 * logz(vec2(1.0, 0.0) + 0.8842 * v);\n\n    return cdiv(w - logz(vec2(1.0, 0.0) + 0.9294 * logz(vec2(1.0, 0.0) + 0.5106 * v)) - vec2(1.213, 0.0), vec2(1.0, 0.0) + cinv(w + vec2(4.69483568, 0.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = LambertW(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= mix(1.0, my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95), 0.5 + 0.5 * cos(iTime));\n    fragColor = vec4(c, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the Lambert W function w = W(z) (https://en.wikipedia.org/wiki/Lambert_W_function)\n\n#define PI 3.14159265359\n#define EE 2.71828182846\n#define SCALE 5.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// from Fabrice Neyret, \n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A,B) cmul( A, cinv(B) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * fract( x / p );\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// complex square root, from Numerical Recipes\n\nvec2 sqrtz( in vec2 z )\n{\n\tfloat ar = abs(z.x);\n    float ai = abs(z.y);\n\n    float w = (dot(z, z) == 0.0) ? 0.0 : ( (ar >= ai) ? (sqrt(ar) * sqrt(0.5 * (1.0 + sqrt(1.0 + (ai * ai)/(ar * ar))))) : (sqrt(ai) * sqrt(0.5 * (ar/ai + sqrt(1.0 + (ar * ar)/(ai * ai))))));\n    \n    return ((w == 0.0) ? vec2(0.0) : ((z.x >= 0.0 ? vec2(w, 0.5 * z.y/w) : vec2(0.5*ai/w, ((z.y >= 0.0) ? w : -w)))));\n}\n\n// complex logarithm\n\nvec2 logz( in vec2 z )\n{\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// Lambert W function, Winitzki's approximation (https://doi.org/10.1007/3-540-44839-X_82)\n\nvec2 LambertW( in vec2 z )\n{\n    vec2 v = sqrtz(2.0 * EE * z + 2.0);\n    vec2 w = 2.0 * logz(vec2(1.0, 0.0) + 0.8842 * v);\n\n    return cdiv(w - logz(vec2(1.0, 0.0) + 0.9294 * logz(vec2(1.0, 0.0) + 0.5106 * v)) - vec2(1.213, 0.0), vec2(1.0, 0.0) + cinv(w + vec2(4.69483568, 0.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = LambertW(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= mix(1.0, my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95), 0.5 + 0.5 * cos(iTime));\n    fragColor = vec4(c, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the Lambert W function w = W(z) (https://en.wikipedia.org/wiki/Lambert_W_function)\n\n#define PI 3.14159265359\n#define EE 2.71828182846\n#define SCALE 5.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// from Fabrice Neyret, \n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A,B) cmul( A, cinv(B) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 c = vec3(0.0);\n    c.r = smoothstep( 0.0, 0.1, h );\n    c.g = smoothstep( 0.1, 0.2, h );\n    c.b = smoothstep( 0.2, 0.3, h );\n    return c;\n}\n\n// complex square root, from Numerical Recipes\n\nvec2 sqrtz( in vec2 z )\n{\n\tfloat ar = abs(z.x);\n    float ai = abs(z.y);\n\n    float w = (dot(z, z) == 0.0) ? 0.0 : ( (ar >= ai) ? (sqrt(ar) * sqrt(0.5 * (1.0 + sqrt(1.0 + (ai * ai)/(ar * ar))))) : (sqrt(ai) * sqrt(0.5 * (ar/ai + sqrt(1.0 + (ar * ar)/(ai * ai))))));\n    \n    return ((w == 0.0) ? vec2(0.0) : ((z.x >= 0.0 ? vec2(w, 0.5 * z.y/w) : vec2(0.5*ai/w, ((z.y >= 0.0) ? w : -w)))));\n}\n\n// complex logarithm\n\nvec2 logz( in vec2 z )\n{\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// Lambert W function, Winitzki's approximation (https://doi.org/10.1007/3-540-44839-X_82)\n\nvec2 LambertW( in vec2 z )\n{\n    vec2 v = sqrtz(2.0 * EE * z + 2.0);\n    vec2 w = 2.0 * logz(vec2(1.0, 0.0) + 0.8842 * v);\n\n    return cdiv(w - logz(vec2(1.0, 0.0) + 0.9294 * logz(vec2(1.0, 0.0) + 0.5106 * v)) - vec2(1.213, 0.0), vec2(1.0, 0.0) + cinv(w + vec2(4.69483568, 0.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = LambertW(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= mix(1.0, my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95), 0.5 + 0.5 * cos(iTime));\n    fragColor = vec4(c, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Bounding box of a capsule\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone             - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Capsule          - 3D Bbox : https://www.shadertoy.com/view/3s2SRV\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n    \n//---------------------------------------------------------------------------------------\n// bounding box for a capsule\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 a = pb - pa;\n    \n    return bound3( min( pa - ra, pb - ra ),\n                   max( pa + ra, pb + ra ) );\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb-pa, pa1 = ro-pa, ba2 = rd-ba;\n    float a = dot(ba,ba), b = 2.0*dot(ba,ba2), c = dot(ba,ba2.yzx)-dot(ba,ba2.zxy)+dot(pa1,ba)-r*r, d = b*b-4.0*a*c;\n    if( d<0.0 ) return -1.0;\n    float t1 = (-b-sqrt(d))/(2.0*a), t2 = (-b+sqrt(d))/(2.0*a);\n    vec3  o1 = pa+ba*t1,  o2 = pa+ba*t2;\n    float h1 = length(o1-ro)-r,  h2 = length(o2-ro)-r;\n    if( h1<0.0 && h2<0.0 ) return -1.0;\n    if( h1<0.0 ) return t2;\n    if( h2<0.0 ) return t1;\n    return (t1*h1<t2*h2)? t1 : t2;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera position\n        vec3 ro = vec3( -0.5, 0.4, 1.5 );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // cylidner animation\n        vec3  c_a =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n        vec3  c_b = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n        float c_ra =  0.3 + 0.2*sin(iTime*1.3+0.5);\n\n        // render\n        vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n        // raytrace\n        float t = iCapsule( ro, rd, c_a, c_b, c_ra );\n        float tmin = 1e10;\n        if( t>0.0 )\n        {\n            tmin = t;\n            // shading/lighting\t\n            vec3 pos = ro + t*rd;\n            vec3 nor = capNormal( pos, c_a, c_b, c_ra );\n\n            float dif = clamp( dot(nor,vec3(0.5,0.7,0.2)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = sqrt( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );\n            col *= vec3(1.0,0.75,0.3);\n        }\n\n\n        // compute bounding box of cylinder\n        bound3 bbox = CapsuleAABB( c_a, c_b, c_ra );\n\n        // raytrace bounding box\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 tbox = iBox( ro, rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = ro + rd*tbox.y;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = ro + rd*tbox.x;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0 - 0.5)/256.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Euclidean distance to a capped cone. Uses only two square roots instead of\n// three like the naive implementation.\n//\n//\n// Other cone functions:\n//\n// Cone bbox:         https://www.shadertoy.com/view/WdjSRK\n// Cone distance:     https://www.shadertoy.com/view/tsSXzK\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n//\n//\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = dot(ba, pa) / dot(ba, ba);\n    return length(pa - ba * h) - mix(ra, rb, h);\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sdCone(pos, vec3(-0.15,-0.2,-0.1), vec3(0.2,0.2,0.1), 0.4, 0.1 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Fake/approximated soft shadow for a capsule.\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n// Other soft-shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n#define AA 3\n\n//================================================================\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k )\n{\n    vec3 ba = b-a;\n    vec3 oa = ro-a;\n    float t = dot(rd,ba)/dot(rd,rd);\n    float d = dot(rd,oa)/dot(rd,rd);\n    float h = dot(rd,cross(rd,ba))/dot(rd,rd);\n    float r2 = r*r;\n    float h2 = h*h;\n    float d2 = d*d;\n    float t2 = t*t;\n    float t2h2 = t2-h2;\n    float t2d2 = t2-d2;\n    float t2d2r2 = t2d2*r2;\n    float t2h2r2 = t2h2*r2;\n    float t2h2d2 = t2h2-d2;\n    float t2h2d2r2 = t2h2d2*r2;\n    float t2d2h2 = t2d2-h2;\n    float t2d2h2r2 = t2d2h2*r2;\n    float t2d2h2r2d2 = t2d2h2r2*d2;\n    float t2h2d2r2d2 = t2h2d2r2*d2;\n    float t2d2h2r2d2r2 = t2d2h2r2d2*r2;\n    float t2h2d2r2d2r2 = t2h2d2r2*r2;\n    float t2h2d2r2d2r2r2 = t2h2d2r2d2r2*r2;\n    float t2h2d2r2d2r2r2r2 = t2h2d2r2d2r2*r2;\n    float t2h2d2r2d2r2r2r2r2 = t2h2d2r// incomplete generation!\n\n\n//================================================================\n// intersect capsule\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a, pa = p - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    vec3  d = pa - h*ba;\n    float l = length(d);\n    float o = 1.0 - max(0.0,dot(-d,n))*r*r/(l*l*l);\n    return sqrt(o*o*o);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n\n        vec3 col = vec3(0.0);\n\n        const vec3 lig = normalize(vec3(-0.8,0.8,0.2));\n\n        float tmin = 1e20;\n        float sha = 1.0;\n        float occ = 1.0;\n        vec3 nor;\n\n        // plane (floor)\n        {\n            float t = (-0.3-ro.y)/rd.y;\n            if( t>0.0 && t<tmin )\n            {\n                tmin = t;\n                vec3 pos = ro + t*rd;\n                nor = vec3(0.0,1.0,0.0);\n                // fake soft shadow!\n                sha = capShadow( pos+0.001*nor, lig, capA, capB, capR, 4.0 ); \n                // fake occlusion \n                occ = capOcclusion( pos, nor, capA, capB, capR ); \n            }\n        }\n\n        // capsule\n        {\n            float t = capIntersect( ro, rd, capA, capB, capR );\n            if( t>0.0 && t<tmin )\n            {\n                tmin = t;\n                vec3 pos = ro + t*rd;\n                nor = capNormal(pos, capA, capB, capR );\n                occ = 0.5 + 0.5*nor.y;\n                sha = 1.0;\n            }\n        }\n\n        // lighting\n        if( tmin<1e19 )\n        {\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 )*sha;\n            float amb = 1.0*occ;\n            col =  vec3(0.2,0.3,0.4)*amb;\n            col += vec3(0.7,0.6,0.5)*dif*0.8;\n        }\n\n        tot += sqrt( col );\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n\tfragColor = vec4( tot, 1.0 );\n}"], ["// Released under the MIT licence\n// Copyright (c) 2019 - Alt144 (\u00c9lie Michel)\n// Study around the snake() function, to build uv-space shaped like a snake,\n// where each section is half a circle.\n\n#define PI 3.141593\n\nfloat pbeat(float t, float p)\n{\n    return pow(1. - fract(t), p);\n}\n\nmat2 rot(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d)\n{\n    return smoothstep(.01, .0, d);\n}\n\nfloat sat(float x) { return clamp(x, 0., 1.); }\n\nfloat triangle(vec2 uv, float radius)\n{\n    return min(\n        fill(abs(uv.y) + (uv.x - radius) * tan(PI/6.)),\n    \tfill(-uv.x - radius)\n    );\n}\n\nfloat pattern(vec2 uv)\n{\n    vec2 udx = floor(uv*5.);\n    uv.y += mod(udx.x, 2.)/5. * 0.5;\n    udx = floor(uv*5.);\n    vec2 guv = fract(uv*5.)-.5;\n    guv = rot(0.) * guv;\n    return triangle(guv, mix(0.25, 0.45, pbeat(iTime + udx.x*.01, 10.0)));\n}\n\nfloat lstep(float a, float b, float x)\n{\n    return (x - a) / (b - a);\n}\n\nvec2 ring(vec2 uv, float innerRadius, float outerRadius)\n{\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    uv = vec2(a / PI, sat(smoothstep(innerRadius, outerRadius, r)));\n    return uv;\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th)\n{\n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    float r1 = smoothstep(rad1, rad1 + th, r);\n    float r2 = smoothstep(rad2, rad2 + th, r);\n    return vec2(a, r1 + r2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.x;\n    vec2 uv0 = uv;\n    float rad = 0.3;\n    float th = 0.1;\n    \n    uv = snake(uv, rad - th, rad, th);\n    uv.x *= 4./5.;\n    \n    float ss = 0.05;\n    float t = mix(0., 1., fract(iTime * .5));\n    float test = step(t,uv.x) * step(uv.x, t+ss);\n    test *= step(.1, uv.y) * step(uv.y, 0.9);\n    \n    vec2 tuv = uv - vec2(iTime*0.1,0.);\n    vec3 col = vec3(0., pattern(tuv), test);\n    \n    col = vec3(1.,1.,.9);\n    col = mix(col, vec3(.95, 0.15, 0.1), fill((abs(fract(tuv.x*5.-.05)-0.5)-0.15)*2.0));\n    col = mix(col, vec3(.9, 0.7, 0.2), fill((abs(fract(tuv.x*5.+.05)-0.5)-0.15)*2.0));\n    col = mix(col, vec3(.05, 0.35, 0.9), fill((abs(fract(tuv.x*5.)-0.5)-0.15)*2.0));\n    \n    col = mix(col, vec3(.1), pattern(tuv * vec2(15.,1.)) * step(.001, tuv.y) * step(tuv.y, .999));\n    \n    float o = 0.07;\n    uv = snake(uv0, rad-th - o, rad + o, th);\n    col = mix(col, vec3(.1), fill(max(.45 - uv.y, uv.y - .55) * 0.35));\n    \n    o = -o;\n    uv = snake(uv0, rad-th - o, rad + o, th);\n    col = mix(col, vec3(.1), fill(max(.45 - uv.y, uv.y - .55) * 0.35));\n    \n    o -= 0.01;\n    uv = snake(uv0, rad-th - o, rad + o, th);\n    //col = mix(col, vec3(.1), fill((.55 - uv.y) * 0.35));\n    \n    fragColor = vec4(col, 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    float a = atan(p.y,p.x);\n    float r2 = dot(p,p);\n    float a2 = a*a;\n    float r22 = r*r*r*r;\n    float a22 = a*a*a*a;\n    return sqrt( r22*a22 + r22*a2 - r22*a22*a2 + r22*a22*a22 - r22*a22*a22*a2 - r22*a22*a22*a22 + r22*a22*a22*a22*a2 + r22*a22*a22*a22*a22 - r22*a22*a22*a22*a22*a2 - r22*a22*a22*a22*a22*a22 + r22*a22*a22*a22*a22*a22*a2 + r22*a22*a22*a22*a22*a22*a22 - r22*a22*a22*a22*a22*a22*a22*a2 - r22*a22*a22*a22*a22*a22*a22*a22 + r22*a22*a22*a22*a22*a22*a22*a22*a2 - r22*a22*a22*a22*a22*a22*a22*a22*a22 + r22*a22*a22*a22*a22*a22*a22*a22*a22*a2 - r22*a22*a22*a22*a2// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float t =            3.14*(0.5+0.5*cos(iTime*0.52));\n    vec2  w = vec2(0.50,0.25)*(0.5+0.5*cos(iTime*vec2(1.1,1.3)+vec2(0.0,2.0)));\n    \n    // distance\n    float d = sdPie(p,vec2(sin(t),cos(t)), 0.5);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdPie(m,vec2(sin(t),cos(t)), 0.5);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic intersection of a sphere f(x,y,z)=x^4+y^4+z^4-r^4=0. I Specialized\n// the generic quartic equation solver for the only geometrically valid cases,\n// reduced all canceling complex operations, and optimized coefficients.\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat iSphere4( in vec3 ro, in vec3 rd, in float ra )\n{\n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    \n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    \n    float h = q*q - p*p*p;\n\n    // -----------------------------\n    // skip the case of three real solutions for the cubic, which involves four\n    // complex solutions for the quartic, since we know this objcet is convex\n    // -----------------------------\n    if( h<0.0 ) return -1.0;\n    \n    // one real solution, two complex (conjugated)\n    float sh = sqrt(h);\n\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n\n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n\n#if 1\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n#else\n    float r = sqrt( c2*c2 + w.x*w.x + 2.0*w.x*c2 - c0 );\n    return -sqrt( 3.0*w.y*w.y/(4.0*r+w.x*2.0+c2*8.0)) - c1/r - k3;\n#endif    \n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n#define AA 2\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 3.1*cos(an), 1.4, 3.1*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n\t    float t = iSphere4( ro, rd, 1.0 );\n\n        // shading/lighting\t\n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\t    if( t>0.0 && t<100.0 )\n\t    {\n            vec3 pos = ro + t*rd;\n\t\t    vec3 nor = nSphere4( pos );\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n#if 0\n            col = vec3(0.8);\n#else\n            const float fr = 3.14159*7.5;\n            vec3 uvw = pow(abs(nor),vec3(1.0/3.0));\n            //vec3 uvw = pos;\n            col = vec3(0.5);\n            float w = pow(1.0+dot(nor,rd),3.0);\n            col += 0.4*smoothstep(-0.01,0.01,cos(uvw.x*fr*0.5)*cos(uvw.y*fr*0.5)*cos(uvw.z*fr*0.5)); \n            col *= 1.0*smoothstep(-1.0,-0.98+0.2*w,cos(uvw.x*fr))\n                      *smoothstep(-1.0,-0.98+0.2*w,cos(uvw.y*fr))\n                      *smoothstep(-1.0,-0.98+0.2*w,cos(uvw.z*fr));\n#endif      \n\t\t    col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            \n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n\t    }\n\t\n        // gamma\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a sector of a circle\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float d = abs(r-ra);\n    d = max(d, abs(a*sca.x-scb.x));\n    d = max(d, abs(a*sca.y-scb.y));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float time = iTime;\n    float ta = 3.14*(0.5+0.5*cos(time*0.52+2.0));\n    float tb = 3.14*(0.5+0.5*cos(time*0.31+2.0));\n    float rb = 0.15*(0.5+0.5*cos(time*0.41+3.0));\n    \n    // distance\n    float d = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.7, rb);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdArc(m,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.7, rb);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Euclidean distance to chain link. After elongating a torus with the technique\n// in this article https://www.shadertoy.com/view/Ml3fWj, you can simplify a few\n// things, producing a branch free and compact sdLink() with a minimal number of\n// square roots and operations.\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat map( in vec3 pos )\n{\n    // animate\n    pos.y += 0.5*iTime;\n\n    // paramteres\n    const float le = 0.13, r1 = 0.2, r2 = 0.09;\n    \n    // make a chain out of sdLink's\n    vec3 a = pos; a.y = fract(a.y    )-0.5;\n    vec3 b = pos; b.y = fract(b.y+0.5)-0.5;\n    \n    // evaluate two links\n    return min(sdLink(a.xyz,le,r1,r2),\n               sdLink(b.zyx,le,r1,r2));\n}\n\n/*\n// build the chain directly, it saves one of four square roots\n// over using sdLinks()\nfloat sdChain( in vec3 pos, in float le, in float r1, in float r2 )\n{\n    float ya = max(abs(fract(pos.y    )-0.5)-le,0.0);\n    float yb = max(abs(fract(pos.y+0.5)-0.5)-le,0.0);\n\n    float la = ya*ya - 2.0*r1*sqrt(pos.x*pos.x+ya*ya);\n    float lb = yb*yb - 2.0*r1*sqrt(pos.z*pos.z+yb*yb);\n    \n    return sqrt(dot(pos.xz,pos.xz) + r1*r1 + min(la,lb)) - r2;\n}\n*/\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float ph = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( ro + rd*tmax ).x;\n        res = min( res, 8.0*h/ph );\n        ph = h;\n        tmax += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.2, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.6,0.2,0.4));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float occ = calcOcclusion( pos, nor );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n            float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col =  vec3(0.5,1.0,1.2)*amb*occ;\n            col += vec3(2.8,2.2,1.8)*dif;\n            \n            col *= 0.2;\n            \n            col += vec3(2.8,2.2,1.8)*spe*3.0;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I raymarched a 3D slice of a 4D rounded box. The 3D slice (plane) that\n// cuts the 4D box is animated over time, and the cube itself is rotating\n// in 4D space. Note this is NOT 4D raymarching, it is 3D raymarching (of\n// a 3D slice of a 4D world).\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));\n}\n\nmat4x4 q2m( in vec4 q )\n{\n    return mat4x4( q.x, -q.y, -q.z, -q.w,\n                   q.y,  q.x, -q.w,  q.z,\n                   q.z,  q.w,  q.x, -q.y,\n                   q.w, -q.z,  q.y, q.x );\n}\n\nfloat map( in vec3 pos, float time )\n{\n    // take a 3D slice\n    vec4 p = vec4(pos,0.5*sin(time*0.513));\n    \n    // rotate 3D point into 4D\n\tvec4 q1 = normalize( cos( 0.2*time*vec4(1.0,1.7,1.1,1.5) + vec4(0.0,1.0,5.0,4.0) ) );\n\tvec4 q2 = normalize( cos( 0.2*time*vec4(1.9,1.7,1.4,1.3) + vec4(3.0,2.0,6.0,5.0) ) );\n    p = q2m(q2)*p*q2m(q1);\n    \n    // 4D box\n    return sdBox( p, vec4(0.8,0.5,0.7,0.2) )- 0.03;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    const float eps = 0.0001;\n    const vec2  off = vec2( eps,0.0 );\n    return normalize( vec3(\n        map( pos + off.xyy, time ).x - map( pos - off.xyy, time ).x,\n        map( pos + off.yxy, time ).x - map( pos - off.yxy, time ).x,\n        map( pos + off.yyx, time ).x - map( pos - off.yyx, time ).x ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time );\n        res = min( res, 16.0*h/t );\n        t += clamp( h, 0.01, 0.25 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (-1.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    {\n    // box\n    float tmax = min(6.0,res.x);\n    float t = 0.4;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos, time);\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    if( t<tmax && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float di = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+di)/float(AA*AA-1);\n        \n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // create view ray\n        vec3 ro = vec3(-0.5,0.0,2.5);\n        vec3 rd = normalize( vec3(p,-1.8) );\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = normalize( vec3(px,-1.8) );\n        vec3 rdy = normalize( vec3(py,-1.8) );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd, time );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor = (tm.y<1.5)?vec3(0.0,1.0,0.0):calcNormal(pos,time);\n            vec3 lig = normalize(vec3(0.8,0.4,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = calcSoftshadow( pos+0.001*nor, lig, 0.001, 4.0, time );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(-nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 3.5*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 4.0*vec3(0.12,0.18,0.24)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n            \n            if( pos.y<-.99 )\n            {\n                // project pixel footprint into the plane\n                vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n                vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n                float f = checkersGradBox( 2.0*pos.xz, 2.0*dpdx.xz, 2.0*dpdy.xz );\n                col *= 0.2 + f*vec3(0.05);\n            }\n            else\n            {\n                col *= 0.25;\n            }\n            \n            col += 0.2*pow(spe,8.0)*dif*sha;\n            \n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n\n        // gamma        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I raymarched a 3D slice of a 4D rounded box. The 3D slice (plane) that\n// cuts the 4D box is animated over time, and the cube itself is rotating\n// in 4D space. Note this is NOT 4D raymarching, it is 3D raymarching (of\n// a 3D slice of a 4D world).\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));\n}\n\nmat4x4 q2m( in vec4 q )\n{\n    return mat4x4( q.x, -q.y, -q.z, -q.w,\n                   q.y,  q.x, -q.w,  q.z,\n                   q.z,  q.w,  q.x, -q.y,\n                   q.w, -q.z,  q.y, q.x );\n}\n\nfloat map( in vec3 pos, float time )\n{\n    // take a 3D slice\n    vec4 p = vec4(pos,0.5*sin(time*0.513));\n    \n    // rotate 3D point into 4D\n\tvec4 q1 = normalize( cos( 0.2*time*vec4(1.0,1.7,1.1,1.5) + vec4(0.0,1.0,5.0,4.0) ) );\n\tvec4 q2 = normalize( cos( 0.2*time*vec4(1.9,1.7,1.4,1.3) + vec4(3.0,2.0,6.0,5.0) ) );\n    p = q2m(q2)*p*q2m(q1);\n    \n    // 4D box\n    return sdBox( p, vec4(0.8,0.5,0.7,0.2) )- 0.03;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float ph = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( ro + rd*tmax ).x;\n        if( h<0.001 ) return 0.0;\n        float dh = h*ph;\n        res = min( res, 8.0*dh/tmax );\n        tmax += h;\n        ph = dh;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (-1.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    {\n    // box\n    float tmax = min(6.0,res.x);\n    float t = 0.4;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos, time);\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    if( t<tmax && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float di = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+di)/float(AA*AA-1);\n        \n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // create view ray\n        vec3 ro = vec3(-0.5,0.0,2.5);\n        vec3 rd = normalize( vec3(p,-1.8) );\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = normalize( vec3(px,-1.8) );\n        vec3 rdy = normalize( vec3(py,-1.8) );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd, time );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor = (tm.y<1.5)?vec3(0.0,1.0,0.0):calcNormal(pos,time);\n            vec3 lig = normalize(vec3(0.8,0.4,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = calcSoftshadow( pos+0.001*nor, lig, 0.001, 4.0, time );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(-nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 3.5*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 4.0*vec3(0.12,0.18,0.24)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n            \n            if( pos.y<-.99 )\n            {\n                // project pixel footprint into the plane\n                vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n                vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n                float f = checkersGradBox( 2.0*pos.xz, 2.0*dpdx.xz, 2.0*dpdy.xz );\n                col *= 0.2 + f*vec3(0.05);\n            }\n            else\n            {\n                col *= 0.25;\n            }\n            \n            col += 0.2*pow(spe,8.0)*dif*sha;\n            \n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n\n        // gamma        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I raymarched a 3D slice of a 4D rounded box. The 3D slice (plane) that\n// cuts the 4D box is animated over time, and the cube itself is rotating\n// in 4D space. Note this is NOT 4D raymarching, it is 3D raymarching (of\n// a 3D slice of a 4D world).\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));\n}\n\nmat4x4 q2m( in vec4 q )\n{\n    return mat4x4( q.x, -q.y, -q.z, -q.w,\n                   q.y,  q.x, -q.w,  q.z,\n                   q.z,  q.w,  q.x, -q.y,\n                   q.w, -q.z,  q.y, q.x );\n}\n\nfloat map( in vec3 pos, float time )\n{\n    // take a 3D slice\n    vec4 p = vec4(pos,0.5*sin(time*0.513));\n    \n    // rotate 3D point into 4D\n\tvec4 q1 = normalize( cos( 0.2*time*vec4(1.0,1.7,1.1,1.5) + vec4(0.0,1.0,5.0,4.0) ) );\n\tvec4 q2 = normalize( cos( 0.2*time*vec4(1.9,1.7,1.4,1.3) + vec4(3.0,2.0,6.0,5.0) ) );\n    p = q2m(q2)*p*q2m(q1);\n    \n    // 4D box\n    return sdBox( p, vec4(0.8,0.5,0.7,0.2) )- 0.03;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time );\n        res = min( res, 16.0*h/t );\n        t += clamp( h, 0.01, 0.25 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (-1.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    {\n    // box\n    float tmax = min(6.0,res.x);\n    float t = 0.4;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos, time);\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    if( t<tmax && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 q = floor(p);\n    vec2 r = p-q;\n    vec2 s = abs(r)-0.5;\n    vec2 t = abs(s);\n    vec2 u = max(t,-t);\n    vec2 v = 0.5*length(u-t)+t;\n    vec2 w = 0.5*length(u+t)+t;\n    vec2 x = min(v,w);\n    vec2 y = min(x,1.0-x);\n    vec2 z = min(y,min(abs(r.x),abs(r.y)));\n    vec2 a = min(z,min(abs(r.x-1.0),abs(r.y-1.0)));\n    vec2 b = min(a,min(abs(r.x-0.5),abs(r.y-0.5)));\n    vec2 c = min(b,min(abs(r.x-1.5),abs(r.y-1.5)));\n    vec2 d = min(c,min(abs(r.x-0.5),abs(r.y-1.5)));\n    vec2 e = min(d,min(abs(r.x-1.5),abs(r.y-0.5)));\n    vec2 f = min(e,min(abs(r.x-1.5),abs(r.y-1.5)));\n    vec2 g = min(f,min(abs(r.x-0.5),abs(r.y-0.5)));\n    vec2 h = min(g,min(abs(r.x-1.0),abs(r.y-1.0)));\n    vec2 i = min(h,min(abs(r.x-0.0),abs(r.y-1.0)));\n    vec2 j =// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float di = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+di)/float(AA*AA-1);\n        \n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // create view ray\n        vec3 ro = vec3(-0.5,0.0,2.5);\n        vec3 rd = normalize( vec3(p,-1.8) );\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = normalize( vec3(px,-1.8) );\n        vec3 rdy = normalize( vec3(py,-1.8) );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd, time );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor = (tm.y<1.5)?vec3(0.0,1.0,0.0):calcNormal(pos,time);\n            vec3 lig = normalize(vec3(0.8,0.4,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = calcSoftshadow( pos+0.001*nor, lig, 0.001, 4.0, time );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(-nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 3.5*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 4.0*vec3(0.12,0.18,0.24)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n            \n            if( pos.y<-.99 )\n            {\n                // project pixel footprint into the plane\n                vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n                vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n                float f = checkersGradBox( 2.0*pos.xz, 2.0*dpdx.xz, 2.0*dpdy.xz );\n                col *= 0.2 + f*vec3(0.05);\n            }\n            else\n            {\n                col *= 0.25;\n            }\n            \n            col += 0.2*pow(spe,8.0)*dif*sha;\n            \n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n\n        // gamma        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    return k*x/(1.0+k*abs(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // coordinates    \n    float dx = 3.0/iResolution.y;\n    vec2  p = fragCoord.xy*dx;\n    \n    // animate staircase curve\n    float k = pow( 2.0, 4.0*sin(3.1415927*iTime));\n    \n    // background\n    vec3 col = vec3( 0.2 + 0.02*mod(floor(p.x)+floor(p.y),2.0) );\n\n    // draw curve y=f(x)\n    float y = staircase( p.x, k );\n    col = mix( col, vec3(1.0,0.8,0.3), 1.0-smoothstep(0.0, 2.0*dx, abs(p.y-y) ) );\n    \n    // draw curve x=f^-1(x)\n    float x = staircase( p.y, 1.0/k );\n    col = mix( col, vec3(1.0,0.8,0.3), 1.0-smoothstep(0.0, 2.0*dx, abs(p.x-x) ) );\n    \n    fragColor = vec4( col, 1.0 );\n}"], ["/*\nMIT License\n\nCopyright (c) 2019 - 2021 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nUpdate 1 (25-9-2019): added 2 lines to prevent mie from shining through objects inside the atmosphere\nUpdate 2 (2-10-2019): made use of HW_PERFORMANCE to improve performance on mobile (reduces number of samples), also added a sun\nUpdate 3 (5-10-2019): added a license\nUpdate 4 (28-11-2019): atmosphere now correctly blocks light from the scene passing through, and added an ambient scattering term\nUpdate 5 (28-11-2019): mouse drag now changes the time of day\nUpdate 6 (28-11-2019): atmosphere now doesn't use the ray sphere intersect function, meaning it's only one function\nUpdate 7 (22-12-2019): Compacted the mie and rayleigh parts into a single vec2 + added a basic skylight\nUpdate 8 (15-5-2020): Added ozone absorption (Can also be used as absorption in general)\nUpdate 9 (6-5-2021): Changed the ozone distribution from 1 / cosh(x) to 1 / (x^2 + 1), and removed the clamp, better integration is planned\nUpdate 10 (6-5-2021): Changed the integrator to be a bit better, but it might have broken it a bit as well (and it's not 100% done yet) \nUpdate 11 (18-5-2021): Changed the integrator again, to fix it, because apparently it got worse since last update\nUpdate 12 (19-5-2021): Found a slight issue at certain view angles backwards, fixed with a simple max\nUpdate 13 (Planned): Change the integration again, according to seb hillaire: transmittance + total instead of optical depth and total\n                     See Enscape clouds, this hopefully improves the quality\n\nScattering works by calculating how much light is scattered to the camera on a certain path/\nThis implementation does that by taking a number of samples across that path to check the amount of light that reaches the path\nand it calculates the color of this light from the effects of scattering.\n\nThere are two types of scattering, rayleigh and mie\nrayleigh is caused by small particles (molecules) and scatters certain colors better than others (causing a blue sky on earth)\nmie is caused by bigger particles (like water droplets), and scatters all colors equally, but only in a certain direction. \nMie scattering causes the red sky during the sunset, because it scatters the remaining red light\n\nTo know where the ray starts and ends, we need to calculate where the ray enters and exits the atmosphere\nWe do this using a ray-sphere intersect\n\nThe scattering code is based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\nwith some modifications to allow moving the planet, as well as objects inside the atmosphere, correct light absorbsion\nfrom objects in the scene and an ambient scattering term tp light up the dark side a bit if needed\n            \nthe camera also moves up and down, and the sun rotates around the planet as well\n\nNote: \tBecause rayleigh is a long word to type, I use ray instead on most variable names\n\t\tthe same goes for position (which becomes pos), direction (which becomes dir) and optical (becomes opt)\n*/\n\n// first, lets define some constants to use (planet radius, position, and scattering coefficients)\n#define PLANET_POS vec3(0.0) /* the position of the planet */\n#define PLANET_RADIUS 6371e3 /* radius of the planet */\n#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */\n// scattering coeffs\n#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */\n#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */\n#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */\n#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */\n#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */\n// and the heights (how far to go up before the scattering has no effect)\n#define HEIGHT_RAY 8e3 /* rayleigh height */\n#define HEIGHT_MIE 1.2e3 /* and mie */\n#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */\n#define ABSORPTION_FALLOFF 4e3 /* how much the absorption decreases the further away it gets from the maximum height */\n// and the steps (more looks better, but is slower)\n// the primary step has the most effect on looks\n#if HW_PERFORMANCE==0\n// edit these if you are on mobile\n#define PRIMARY_STEPS 12 \n#define LIGHT_STEPS 4\n# else\n// and these on desktop\n#define PRIMARY_STEPS 32 /* primary steps, affects quality the most */\n#define LIGHT_STEPS 8 /* light steps, how much steps in the light direction are taken */\n#endif\n\n// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space\n#define CAMERA_MODE 2\n\n/*\nNext we'll define the main scattering function.\nThis traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.\nFor every sample, we'll also trace a ray in the direction of the light, \nbecause the color that reaches the sample also changes due to scattering\n*/\nvec3 calculate_scattering(\n\tvec3 start, \t\t\t\t// the start of the ray (the camera position)\n    vec3 dir, \t\t\t\t\t// the direction of the ray (the camera vector)\n    float max_dist, \t\t\t// the maximum distance the ray can travel (because something is in the way, like an object)\n    vec3 scene_color,\t\t\t// the color of the scene\n    vec3 light_dir, \t\t\t// the direction of the light\n    vec3 light_intensity,\t\t// how bright the light is, affects the brightness of the atmosphere\n    vec3 planet_position, \t\t// the position of the planet\n    float planet_radius, \t\t// the radius of the planet\n    float atmo_radius, \t\t\t// the radius of the atmosphere\n    vec3 beta_ray, \t\t\t\t// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\n    vec3 beta_mie, \t\t\t\t// the amount mie scattering scatters colors\n    vec3 beta_absorption,   \t// how much air is absorbed\n    vec3 beta_ambient,\t\t\t// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter\n    float g, \t\t\t\t\t// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\n    float height_ray, \t\t\t// how high do you have to go before there is no rayleigh scattering?\n    float height_mie, \t\t\t// the same, but for mie\n    float height_absorption,\t// the height at which the most absorption happens\n    float absorption_falloff,\t// how fast the absorption falls off from the absorption height\n    int steps_i, \t\t\t\t// the amount of steps along the 'primary' ray, more looks better but slower\n    int steps_l \t\t\t\t// the amount of steps along the light ray, more looks better but slower\n) {\n    // add an offset to the camera position, so that the atmosphere is in the correct position\n    start -= planet_position;\n    // calculate the start and end position of the ray, as a distance along the ray\n    // we do this with a ray sphere intersect\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (atmo_radius * atmo_radius);\n    float d = (b * b) - 4.0 * a * c;\n    \n    // stop early if there is no intersect\n    if (d < 0.0) return scene_color;\n    \n    // calculate the ray length\n    vec2 ray_length = vec2(\n        max((-b - sqrt(d)) / (2.0 * a), 0.0),\n        min((-b + sqrt(d)) / (2.0 * a), max_dist)\n    );\n    \n    // if the ray did not hit the atmosphere, return a black color\n    if (ray_length.x > ray_length.y) return scene_color;\n    // prevent the mie glow from appearing if there's an object in front of the camera\n    bool allow_mie = max_dist > ray_length.y;\n    // make sure the ray is no longer than allowed\n    ray_length.y = min(ray_length.y, max_dist);\n    ray_length.x = max(ray_length.x, 0.0);\n    // get the step size of the ray\n    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);\n    \n    // next, set how far we are along the ray, so we can calculate the position of the sample\n    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere\n    // if it's inside, it should start at the position of the camera\n    // the min statement makes sure of that\n    float ray_pos_i = ray_length.x + step_size_i * 0.5;\n    \n    // these are the values we use to gather all the scattered light\n    vec3 total_ray = vec3(0.0); // for rayleigh\n    vec3 total_mie = vec3(0.0); // for mie\n    \n    // initialize the optical depth. This is used to calculate how much air was in the ray\n    vec3 opt_i = vec3(0.0);\n    \n    // we define the density early, as this helps doing integration\n    // usually we would do riemans summing, which is just the squares under the integral area\n    // this is a bit innefficient, and we can make it better by also taking the extra triangle at the top of the square into account\n    // the starting value is a bit inaccurate, but it should make it better overall\n    vec3 prev_density = vec3(0.0);\n    \n    // also init the scale height, avoids some vec2's later on\n    vec2 scale_height = vec2(height_ray, height_mie);\n    \n    // Calculate the Rayleigh and Mie phases.\n    // This is the color that will be scattered for this ray\n    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them\n    float mu = dot(dir, light_dir);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n    \n    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it\n    for (int i = 0; i < steps_i; ++i) {\n        \n        // calculate where we are along this ray\n        vec3 pos_i = start + dir * ray_pos_i;\n        \n        // and how high we are above the surface\n        float height_i = length(pos_i) - planet_radius;\n        \n        // now calculate the density of the particles (both for rayleigh and mie)\n        vec3 density = vec3(exp(-height_i / scale_height), 0.0);\n        \n        // and the absorption density. this is for ozone, which scales together with the rayleigh, \n        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height\n        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side\n        float denom = (height_absorption - height_i) / absorption_falloff;\n        density.z = (1.0 / (denom * denom + 1.0)) * density.x;\n        \n        // multiply it by the step size here\n        // we are going to use the density later on as well\n        density *= step_size_i;\n        \n        // Add these densities to the optical depth, so that we know how many particles are on this ray.\n        // max here is needed to prevent opt_i from potentially becoming negative\n        opt_i += max(density + (prev_density - density) * 0.5, 0.0);\n        \n        // and update the previous density\n        prev_density = density;\n\n        // Calculate the step size of the light ray.\n        // again with a ray sphere intersect\n        // a, b, c and d are already defined\n        a = dot(light_dir, light_dir);\n        b = 2.0 * dot(light_dir, pos_i);\n        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);\n        d = (b * b) - 4.0 * a * c;\n\n        // no early stopping, this one should always be inside the atmosphere\n        // calculate the ray length\n        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));\n\n        // and the position along this ray\n        // this time we are sure the ray is in the atmosphere, so set it to 0\n        float ray_pos_l = step_size_l * 0.5;\n\n        // and the optical depth of this ray\n        vec3 opt_l = vec3(0.0);\n        \n        // again, use the prev density for better integration\n        vec3 prev_density_l = vec3(0.0);\n        \n        // now sample the light ray\n        // this is similar to what we did before\n        for (int l = 0; l < steps_l; ++l) {\n\n            // calculate where we are along this ray\n            vec3 pos_l = pos_i + light_dir * ray_pos_l;\n\n            // the heigth of the position\n            float height_l = length(pos_l) - planet_radius;\n\n            // calculate the particle density, and add it\n            // this is a bit verbose\n            // first, set the density for ray and mie\n            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);\n            \n            // then, the absorption\n            float denom = (height_absorption - height_l) / absorption_falloff;\n            density_l.z = (1.0 / (denom * denom + 1.0)) * density_l.x;\n            \n            // multiply the density by the step size\n            density_l *= step_size_l;\n            \n            // and add it to the total optical depth\n            opt_l += max(density_l + (prev_density_l - density_l) * 0.5, 0.0);\n            \n            // and update the previous density\n            prev_density_l = density_l;\n\n            // and increment where we are along the light ray.\n            ray_pos_l += step_size_l;\n            \n        }\n        \n        // Now we need to calculate the attenuation\n        // this is essentially how much light reaches the current sample point due to scattering\n        vec3 attn = exp(-beta_ray * (opt_i.x + opt_l.x) - beta_mie * (opt_i.y + opt_l.y) - beta_absorption * (opt_i.z + opt_l.z));\n\n        // accumulate the scattered light (how much will be scattered towards the camera)\n        total_ray += density.x * attn;\n        total_mie += density.y * attn;\n\n        // and increment the position on this ray\n        ray_pos_i += step_size_i;\n    \t\n    }\n    \n    // calculate how much light can pass through the atmosphere\n    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));\n    \n\t// calculate and return the final color\n    return (\n        \tphase_ray * beta_ray * total_ray // rayleigh color\n       \t\t+ phase_mie * beta_mie * total_mie // mie\n            + opt_i.x * beta_ambient // and ambient\n    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly\n}\n\n/*\nA ray-sphere intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray sphere intersect built in\n*/\n\nvec2 ray_sphere_intersect(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {\n    vec3 sample_dir = normalize(sample_pos - camera_pos);\n    float sample_dist = length(sample_pos - camera_pos);\n    float sample_dist_sq = sample_dist * sample_dist;\n    float sample_dist_inv_sq = 1.0 / sample_dist_sq;\n    float sample_dist_inv = 1.0 / sample_dist;\n\n    vec3 sample_col = background_col;\n    float sample_atten = 1.0;\n    float sample_atten_inv = 1.0;\n    float sample_atten_inv_sq = 1.0;\n    float sample_atten_inv_cub = 1.0;\n    float sample_atten_inv_four = 1.0;\n    float sample_atten_inv_five = 1.0;\n    float sample_atten_inv_six = 1.0;\n    float sample_atten_inv_seven = 1.0;\n    float sample_atten_inv_eight = 1.0;\n    float sample_atten_inv_nine = 1.0;\n    float sample_atten_inv_ten = 1.0;\n    float sample_atten_inv_eleven = 1.0;\n    float sample_atten_inv_twelve = 1.0;\n    float sample_atten_inv_thirteen = 1.0;\n    float sample_atten_inv_fourteen = 1.0;\n    float sample_atten_inv_fifteen = 1.0;\n    float sample_atten_inv_sixteen = 1.0;\n    float sample_atten_inv_seventeen = 1.0;\n    float sample_atten_inv_eighteen = 1.0;\n    float sample_atten_inv_nineteen = 1.0;\n    float sample_atten_// incomplete generation!\n\n/*\nThe following function returns the scene color and depth \n(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)\n\nin this case, the function renders a green sphere on the place where the planet should be\ncolor is in .xyz, distance in .w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {\n    \n    // the color to use, w is the scene depth\n    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);\n    \n    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white\n    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);\n    \n    // get where the ray intersects the planet\n    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); \n    \n    // if the ray hit the planet, set the max distance to that ray\n    if (0.0 < planet_intersect.y) {\n    \tcolor.w = max(planet_intersect.x, 0.0);\n        \n        // sample position, where the pixel is\n        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;\n        \n        // and the surface normal\n        vec3 surface_normal = normalize(sample_pos);\n        \n        // get the color of the sphere\n        color.xyz = vec3(0.0, 0.25, 0.05); \n        \n        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law\n        vec3 N = surface_normal;\n        vec3 V = -dir;\n        vec3 L = light_dir;\n        float dotNV = max(1e-6, dot(N, V));\n        float dotNL = max(1e-6, dot(N, L));\n        float shadow = dotNL / (dotNL + dotNV);\n        \n        // apply the shadow\n        color.xyz *= shadow;\n        \n        // apply skylight\n        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);\n    }\n    \n\treturn color;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 uv    = coord.xy / resolution.xy - vec2(0.5);\n         uv.x *= resolution.x / resolution.y;\n\n    return normalize(vec3(uv.x, uv.y, -1.0));\n}\n\n/*\nFinally, draw the atmosphere to screen\n\nwe first get the camera vector and position, as well as the light dir\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the camera vector\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord);\n    \n    // get the camera position, switch based on the defines\n#if CAMERA_MODE==0\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);\n#endif\n#if CAMERA_MODE==1\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS , ATMOS_RADIUS);\n#endif\n#if CAMERA_MODE==2\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS + (-cos(iTime / 2.0) * (ATMOS_RADIUS - PLANET_RADIUS - 1.0)), 0.0);\n#endif\n#if CAMERA_MODE==3\n    float offset = (1.0 - cos(iTime / 2.0)) * ATMOS_RADIUS;\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 1.0, offset);\n#endif\n    // get the light direction\n    // also base this on the mouse position, that way the time of day can be changed with the mouse\n    vec3 light_dir = iMouse.y == 0.0 ? \n        normalize(vec3(0.0, cos(-iTime/8.0), sin(-iTime/8.0))) : \n    \tnormalize(vec3(0.0, cos(iMouse.y * -5.0 / iResolution.y), sin(iMouse.y * -5.0 / iResolution.y)));\n    \n    // get the scene color and depth, color is in xyz, depth in w\n    // replace this with something better if you are using this shader for something else\n    vec4 scene = render_scene(camera_position, camera_vector, light_dir);\n    \n    // the color of this pixel\n    vec3 col = vec3(0.0);//scene.xyz;\n    \n    // get the atmosphere color\n    col += calculate_scattering(\n    \tcamera_position,\t\t\t\t// the position of the camera\n        camera_vector, \t\t\t\t\t// the camera vector (ray direction of this pixel)\n        scene.w, \t\t\t\t\t\t// max dist, essentially the scene depth\n        scene.xyz,\t\t\t\t\t\t// scene color, the color of the current pixel being rendered\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height \n        PRIMARY_STEPS, \t\t\t\t\t// steps in the ray direction \n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n        \n    // apply exposure, removing this makes the brighter colors look ugly\n    // you can play around with removing this\n    col = 1.0 - exp(-col);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}"], ["/*\nMIT License\n\nCopyright (c) 2019 - 2021 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nUpdate 1 (25-9-2019): added 2 lines to prevent mie from shining through objects inside the atmosphere\nUpdate 2 (2-10-2019): made use of HW_PERFORMANCE to improve performance on mobile (reduces number of samples), also added a sun\nUpdate 3 (5-10-2019): added a license\nUpdate 4 (28-11-2019): atmosphere now correctly blocks light from the scene passing through, and added an ambient scattering term\nUpdate 5 (28-11-2019): mouse drag now changes the time of day\nUpdate 6 (28-11-2019): atmosphere now doesn't use the ray sphere intersect function, meaning it's only one function\nUpdate 7 (22-12-2019): Compacted the mie and rayleigh parts into a single vec2 + added a basic skylight\nUpdate 8 (15-5-2020): Added ozone absorption (Can also be used as absorption in general)\nUpdate 9 (6-5-2021): Changed the ozone distribution from 1 / cosh(x) to 1 / (x^2 + 1), and removed the clamp, better integration is planned\nUpdate 10 (6-5-2021): Changed the integrator to be a bit better, but it might have broken it a bit as well (and it's not 100% done yet) \nUpdate 11 (18-5-2021): Changed the integrator again, to fix it, because apparently it got worse since last update\nUpdate 12 (19-5-2021): Found a slight issue at certain view angles backwards, fixed with a simple max\nUpdate 13 (Planned): Change the integration again, according to seb hillaire: transmittance + total instead of optical depth and total\n                     See Enscape clouds, this hopefully improves the quality\n\nScattering works by calculating how much light is scattered to the camera on a certain path/\nThis implementation does that by taking a number of samples across that path to check the amount of light that reaches the path\nand it calculates the color of this light from the effects of scattering.\n\nThere are two types of scattering, rayleigh and mie\nrayleigh is caused by small particles (molecules) and scatters certain colors better than others (causing a blue sky on earth)\nmie is caused by bigger particles (like water droplets), and scatters all colors equally, but only in a certain direction. \nMie scattering causes the red sky during the sunset, because it scatters the remaining red light\n\nTo know where the ray starts and ends, we need to calculate where the ray enters and exits the atmosphere\nWe do this using a ray-sphere intersect\n\nThe scattering code is based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\nwith some modifications to allow moving the planet, as well as objects inside the atmosphere, correct light absorbsion\nfrom objects in the scene and an ambient scattering term tp light up the dark side a bit if needed\n            \nthe camera also moves up and down, and the sun rotates around the planet as well\n\nNote: \tBecause rayleigh is a long word to type, I use ray instead on most variable names\n\t\tthe same goes for position (which becomes pos), direction (which becomes dir) and optical (becomes opt)\n*/\n\n// first, lets define some constants to use (planet radius, position, and scattering coefficients)\n#define PLANET_POS vec3(0.0) /* the position of the planet */\n#define PLANET_RADIUS 6371e3 /* radius of the planet */\n#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */\n// scattering coeffs\n#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */\n#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */\n#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */\n#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */\n#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */\n// and the heights (how far to go up before the scattering has no effect)\n#define HEIGHT_RAY 8e3 /* rayleigh height */\n#define HEIGHT_MIE 1.2e3 /* and mie */\n#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */\n#define ABSORPTION_FALLOFF 4e3 /* how much the absorption decreases the further away it gets from the maximum height */\n// and the steps (more looks better, but is slower)\n// the primary step has the most effect on looks\n#if HW_PERFORMANCE==0\n// edit these if you are on mobile\n#define PRIMARY_STEPS 12 \n#define LIGHT_STEPS 4\n# else\n// and these on desktop\n#define PRIMARY_STEPS 32 /* primary steps, affects quality the most */\n#define LIGHT_STEPS 8 /* light steps, how much steps in the light direction are taken */\n#endif\n\n// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space\n#define CAMERA_MODE 2\n\n/*\nNext we'll define the main scattering function.\nThis traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.\nFor every sample, we'll also trace a ray in the direction of the light, \nbecause the color that reaches the sample also changes due to scattering\n*/\nvec3 calculate_scattering(\n\tvec3 start, \t\t\t\t// the start of the ray (the camera position)\n    vec3 dir, \t\t\t\t\t// the direction of the ray (the camera vector)\n    float max_dist, \t\t\t// the maximum distance the ray can travel (because something is in the way, like an object)\n    vec3 scene_color,\t\t\t// the color of the scene\n    vec3 light_dir, \t\t\t// the direction of the light\n    vec3 light_intensity,\t\t// how bright the light is, affects the brightness of the atmosphere\n    vec3 planet_position, \t\t// the position of the planet\n    float planet_radius, \t\t// the radius of the planet\n    float atmo_radius, \t\t\t// the radius of the atmosphere\n    vec3 beta_ray, \t\t\t\t// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\n    vec3 beta_mie, \t\t\t\t// the amount mie scattering scatters colors\n    vec3 beta_absorption,   \t// how much air is absorbed\n    vec3 beta_ambient,\t\t\t// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter\n    float g, \t\t\t\t\t// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\n    float height_ray, \t\t\t// how high do you have to go before there is no rayleigh scattering?\n    float height_mie, \t\t\t// the same, but for mie\n    float height_absorption,\t// the height at which the most absorption happens\n    float absorption_falloff,\t// how fast the absorption falls off from the absorption height\n    int steps_i, \t\t\t\t// the amount of steps along the 'primary' ray, more looks better but slower\n    int steps_l \t\t\t\t// the amount of steps along the light ray, more looks better but slower\n) {\n    // add an offset to the camera position, so that the atmosphere is in the correct position\n    start -= planet_position;\n    // calculate the start and end position of the ray, as a distance along the ray\n    // we do this with a ray sphere intersect\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (atmo_radius * atmo_radius);\n    float d = (b * b) - 4.0 * a * c;\n    \n    // stop early if there is no intersect\n    if (d < 0.0) return scene_color;\n    \n    // calculate the ray length\n    vec2 ray_length = vec2(\n        max((-b - sqrt(d)) / (2.0 * a), 0.0),\n        min((-b + sqrt(d)) / (2.0 * a), max_dist)\n    );\n    \n    // if the ray did not hit the atmosphere, return a black color\n    if (ray_length.x > ray_length.y) return scene_color;\n    // prevent the mie glow from appearing if there's an object in front of the camera\n    bool allow_mie = max_dist > ray_length.y;\n    // make sure the ray is no longer than allowed\n    ray_length.y = min(ray_length.y, max_dist);\n    ray_length.x = max(ray_length.x, 0.0);\n    // get the step size of the ray\n    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);\n    \n    // next, set how far we are along the ray, so we can calculate the position of the sample\n    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere\n    // if it's inside, it should start at the position of the camera\n    // the min statement makes sure of that\n    float ray_pos_i = ray_length.x + step_size_i * 0.5;\n    \n    // these are the values we use to gather all the scattered light\n    vec3 total_ray = vec3(0.0); // for rayleigh\n    vec3 total_mie = vec3(0.0); // for mie\n    \n    // initialize the optical depth. This is used to calculate how much air was in the ray\n    vec3 opt_i = vec3(0.0);\n    \n    // we define the density early, as this helps doing integration\n    // usually we would do riemans summing, which is just the squares under the integral area\n    // this is a bit innefficient, and we can make it better by also taking the extra triangle at the top of the square into account\n    // the starting value is a bit inaccurate, but it should make it better overall\n    vec3 prev_density = vec3(0.0);\n    \n    // also init the scale height, avoids some vec2's later on\n    vec2 scale_height = vec2(height_ray, height_mie);\n    \n    // Calculate the Rayleigh and Mie phases.\n    // This is the color that will be scattered for this ray\n    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them\n    float mu = dot(dir, light_dir);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n    \n    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it\n    for (int i = 0; i < steps_i; ++i) {\n        \n        // calculate where we are along this ray\n        vec3 pos_i = start + dir * ray_pos_i;\n        \n        // and how high we are above the surface\n        float height_i = length(pos_i) - planet_radius;\n        \n        // now calculate the density of the particles (both for rayleigh and mie)\n        vec3 density = vec3(exp(-height_i / scale_height), 0.0);\n        \n        // and the absorption density. this is for ozone, which scales together with the rayleigh, \n        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height\n        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side\n        float denom = (height_absorption - height_i) / absorption_falloff;\n        density.z = (1.0 / (denom * denom + 1.0)) * density.x;\n        \n        // multiply it by the step size here\n        // we are going to use the density later on as well\n        density *= step_size_i;\n        \n        // Add these densities to the optical depth, so that we know how many particles are on this ray.\n        // max here is needed to prevent opt_i from potentially becoming negative\n        opt_i += max(density + (prev_density - density) * 0.5, 0.0);\n        \n        // and update the previous density\n        prev_density = density;\n\n        // Calculate the step size of the light ray.\n        // again with a ray sphere intersect\n        // a, b, c and d are already defined\n        a = dot(light_dir, light_dir);\n        b = 2.0 * dot(light_dir, pos_i);\n        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);\n        d = (b * b) - 4.0 * a * c;\n\n        // no early stopping, this one should always be inside the atmosphere\n        // calculate the ray length\n        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));\n\n        // and the position along this ray\n        // this time we are sure the ray is in the atmosphere, so set it to 0\n        float ray_pos_l = step_size_l * 0.5;\n\n        // and the optical depth of this ray\n        vec3 opt_l = vec3(0.0);\n        \n        // again, use the prev density for better integration\n        vec3 prev_density_l = vec3(0.0);\n        \n        // now sample the light ray\n        // this is similar to what we did before\n        for (int l = 0; l < steps_l; ++l) {\n\n            // calculate where we are along this ray\n            vec3 pos_l = pos_i + light_dir * ray_pos_l;\n\n            // the heigth of the position\n            float height_l = length(pos_l) - planet_radius;\n\n            // calculate the particle density, and add it\n            // this is a bit verbose\n            // first, set the density for ray and mie\n            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);\n            \n            // then, the absorption\n            float denom = (height_absorption - height_l) / absorption_falloff;\n            density_l.z = (1.0 / (denom * denom + 1.0)) * density_l.x;\n            \n            // multiply the density by the step size\n            density_l *= step_size_l;\n            \n            // and add it to the total optical depth\n            opt_l += max(density_l + (prev_density_l - density_l) * 0.5, 0.0);\n            \n            // and update the previous density\n            prev_density_l = density_l;\n\n            // and increment where we are along the light ray.\n            ray_pos_l += step_size_l;\n            \n        }\n        \n        // Now we need to calculate the attenuation\n        // this is essentially how much light reaches the current sample point due to scattering\n        vec3 attn = exp(-beta_ray * (opt_i.x + opt_l.x) - beta_mie * (opt_i.y + opt_l.y) - beta_absorption * (opt_i.z + opt_l.z));\n\n        // accumulate the scattered light (how much will be scattered towards the camera)\n        total_ray += density.x * attn;\n        total_mie += density.y * attn;\n\n        // and increment the position on this ray\n        ray_pos_i += step_size_i;\n    \t\n    }\n    \n    // calculate how much light can pass through the atmosphere\n    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));\n    \n\t// calculate and return the final color\n    return (\n        \tphase_ray * beta_ray * total_ray // rayleigh color\n       \t\t+ phase_mie * beta_mie * total_mie // mie\n            + opt_i.x * beta_ambient // and ambient\n    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly\n}\n\n/*\nA ray-sphere intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray sphere intersect built in\n*/\n\nvec2 ray_sphere_intersect(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {\n\n    // slightly bend the surface normal towards the light direction\n    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));\n    \n    // and sample the atmosphere\n    return calculate_scattering(\n    \tsample_pos,\t\t\t\t\t\t// the position of the camera\n        surface_normal, \t\t\t\t// the camera vector (ray direction of this pixel)\n        3.0 * ATMOS_RADIUS, \t\t\t// max dist, since nothing will stop the ray here, just use some arbitrary value\n        background_col,\t\t\t\t\t// scene color, just the background color here\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height\n        LIGHT_STEPS, \t\t\t\t\t// steps in the ray direction\n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n}\n\n/*\nThe following function returns the scene color and depth \n(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)\n\nin this case, the function renders a green sphere on the place where the planet should be\ncolor is in.xyz, distance in.w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {\n\tvec3 light_color = vec3(0.0, 1.0, 0.0);\n\tvec3 light_pos = vec3(0.0, 0.0, 0.0);\n\tvec3 light_dir = normalize(light_pos - pos);\n\tfloat light_dist = length(light_pos - pos);\n\tfloat light_attenuation = 1.0 / (1.0 + 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_attenuation * light_color;\n\tvec3 light_color = light_color * (max(0.0, dot(light_dir, dir)) + 0.5 * max(0.0, dot(light_dir, dir)) * max(0.0, dot(light_dir, dir)));\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 *// incomplete generation!\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 uv    = coord.xy / resolution.xy - vec2(0.5);\n         uv.x *= resolution.x / resolution.y;\n\n    return normalize(vec3(uv.x, uv.y, -1.0));\n}\n\n/*\nFinally, draw the atmosphere to screen\n\nwe first get the camera vector and position, as well as the light dir\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the camera vector\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord);\n    \n    // get the camera position, switch based on the defines\n#if CAMERA_MODE==0\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);\n#endif\n#if CAMERA_MODE==1\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS , ATMOS_RADIUS);\n#endif\n#if CAMERA_MODE==2\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS + (-cos(iTime / 2.0) * (ATMOS_RADIUS - PLANET_RADIUS - 1.0)), 0.0);\n#endif\n#if CAMERA_MODE==3\n    float offset = (1.0 - cos(iTime / 2.0)) * ATMOS_RADIUS;\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 1.0, offset);\n#endif\n    // get the light direction\n    // also base this on the mouse position, that way the time of day can be changed with the mouse\n    vec3 light_dir = iMouse.y == 0.0 ? \n        normalize(vec3(0.0, cos(-iTime/8.0), sin(-iTime/8.0))) : \n    \tnormalize(vec3(0.0, cos(iMouse.y * -5.0 / iResolution.y), sin(iMouse.y * -5.0 / iResolution.y)));\n    \n    // get the scene color and depth, color is in xyz, depth in w\n    // replace this with something better if you are using this shader for something else\n    vec4 scene = render_scene(camera_position, camera_vector, light_dir);\n    \n    // the color of this pixel\n    vec3 col = vec3(0.0);//scene.xyz;\n    \n    // get the atmosphere color\n    col += calculate_scattering(\n    \tcamera_position,\t\t\t\t// the position of the camera\n        camera_vector, \t\t\t\t\t// the camera vector (ray direction of this pixel)\n        scene.w, \t\t\t\t\t\t// max dist, essentially the scene depth\n        scene.xyz,\t\t\t\t\t\t// scene color, the color of the current pixel being rendered\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height \n        PRIMARY_STEPS, \t\t\t\t\t// steps in the ray direction \n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n        \n    // apply exposure, removing this makes the brighter colors look ugly\n    // you can play around with removing this\n    col = 1.0 - exp(-col);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}"], ["/*\nMIT License\n\nCopyright (c) 2019 - 2021 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nUpdate 1 (25-9-2019): added 2 lines to prevent mie from shining through objects inside the atmosphere\nUpdate 2 (2-10-2019): made use of HW_PERFORMANCE to improve performance on mobile (reduces number of samples), also added a sun\nUpdate 3 (5-10-2019): added a license\nUpdate 4 (28-11-2019): atmosphere now correctly blocks light from the scene passing through, and added an ambient scattering term\nUpdate 5 (28-11-2019): mouse drag now changes the time of day\nUpdate 6 (28-11-2019): atmosphere now doesn't use the ray sphere intersect function, meaning it's only one function\nUpdate 7 (22-12-2019): Compacted the mie and rayleigh parts into a single vec2 + added a basic skylight\nUpdate 8 (15-5-2020): Added ozone absorption (Can also be used as absorption in general)\nUpdate 9 (6-5-2021): Changed the ozone distribution from 1 / cosh(x) to 1 / (x^2 + 1), and removed the clamp, better integration is planned\nUpdate 10 (6-5-2021): Changed the integrator to be a bit better, but it might have broken it a bit as well (and it's not 100% done yet) \nUpdate 11 (18-5-2021): Changed the integrator again, to fix it, because apparently it got worse since last update\nUpdate 12 (19-5-2021): Found a slight issue at certain view angles backwards, fixed with a simple max\nUpdate 13 (Planned): Change the integration again, according to seb hillaire: transmittance + total instead of optical depth and total\n                     See Enscape clouds, this hopefully improves the quality\n\nScattering works by calculating how much light is scattered to the camera on a certain path/\nThis implementation does that by taking a number of samples across that path to check the amount of light that reaches the path\nand it calculates the color of this light from the effects of scattering.\n\nThere are two types of scattering, rayleigh and mie\nrayleigh is caused by small particles (molecules) and scatters certain colors better than others (causing a blue sky on earth)\nmie is caused by bigger particles (like water droplets), and scatters all colors equally, but only in a certain direction. \nMie scattering causes the red sky during the sunset, because it scatters the remaining red light\n\nTo know where the ray starts and ends, we need to calculate where the ray enters and exits the atmosphere\nWe do this using a ray-sphere intersect\n\nThe scattering code is based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\nwith some modifications to allow moving the planet, as well as objects inside the atmosphere, correct light absorbsion\nfrom objects in the scene and an ambient scattering term tp light up the dark side a bit if needed\n            \nthe camera also moves up and down, and the sun rotates around the planet as well\n\nNote: \tBecause rayleigh is a long word to type, I use ray instead on most variable names\n\t\tthe same goes for position (which becomes pos), direction (which becomes dir) and optical (becomes opt)\n*/\n\n// first, lets define some constants to use (planet radius, position, and scattering coefficients)\n#define PLANET_POS vec3(0.0) /* the position of the planet */\n#define PLANET_RADIUS 6371e3 /* radius of the planet */\n#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */\n// scattering coeffs\n#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */\n#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */\n#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */\n#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */\n#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */\n// and the heights (how far to go up before the scattering has no effect)\n#define HEIGHT_RAY 8e3 /* rayleigh height */\n#define HEIGHT_MIE 1.2e3 /* and mie */\n#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */\n#define ABSORPTION_FALLOFF 4e3 /* how much the absorption decreases the further away it gets from the maximum height */\n// and the steps (more looks better, but is slower)\n// the primary step has the most effect on looks\n#if HW_PERFORMANCE==0\n// edit these if you are on mobile\n#define PRIMARY_STEPS 12 \n#define LIGHT_STEPS 4\n# else\n// and these on desktop\n#define PRIMARY_STEPS 32 /* primary steps, affects quality the most */\n#define LIGHT_STEPS 8 /* light steps, how much steps in the light direction are taken */\n#endif\n\n// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space\n#define CAMERA_MODE 2\n\n/*\nNext we'll define the main scattering function.\nThis traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.\nFor every sample, we'll also trace a ray in the direction of the light, \nbecause the color that reaches the sample also changes due to scattering\n*/\nvec3 calculate_scattering(\n\tvec3 start, \t\t\t\t// the start of the ray (the camera position)\n    vec3 dir, \t\t\t\t\t// the direction of the ray (the camera vector)\n    float max_dist, \t\t\t// the maximum distance the ray can travel (because something is in the way, like an object)\n    vec3 scene_color,\t\t\t// the color of the scene\n    vec3 light_dir, \t\t\t// the direction of the light\n    vec3 light_intensity,\t\t// how bright the light is, affects the brightness of the atmosphere\n    vec3 planet_position, \t\t// the position of the planet\n    float planet_radius, \t\t// the radius of the planet\n    float atmo_radius, \t\t\t// the radius of the atmosphere\n    vec3 beta_ray, \t\t\t\t// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\n    vec3 beta_mie, \t\t\t\t// the amount mie scattering scatters colors\n    vec3 beta_absorption,   \t// how much air is absorbed\n    vec3 beta_ambient,\t\t\t// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter\n    float g, \t\t\t\t\t// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\n    float height_ray, \t\t\t// how high do you have to go before there is no rayleigh scattering?\n    float height_mie, \t\t\t// the same, but for mie\n    float height_absorption,\t// the height at which the most absorption happens\n    float absorption_falloff,\t// how fast the absorption falls off from the absorption height\n    int steps_i, \t\t\t\t// the amount of steps along the 'primary' ray, more looks better but slower\n    int steps_l \t\t\t\t// the amount of steps along the light ray, more looks better but slower\n) {\n    // add an offset to the camera position, so that the atmosphere is in the correct position\n    start -= planet_position;\n    // calculate the start and end position of the ray, as a distance along the ray\n    // we do this with a ray sphere intersect\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (atmo_radius * atmo_radius);\n    float d = (b * b) - 4.0 * a * c;\n    \n    // stop early if there is no intersect\n    if (d < 0.0) return scene_color;\n    \n    // calculate the ray length\n    vec2 ray_length = vec2(\n        max((-b - sqrt(d)) / (2.0 * a), 0.0),\n        min((-b + sqrt(d)) / (2.0 * a), max_dist)\n    );\n    \n    // if the ray did not hit the atmosphere, return a black color\n    if (ray_length.x > ray_length.y) return scene_color;\n    // prevent the mie glow from appearing if there's an object in front of the camera\n    bool allow_mie = max_dist > ray_length.y;\n    // make sure the ray is no longer than allowed\n    ray_length.y = min(ray_length.y, max_dist);\n    ray_length.x = max(ray_length.x, 0.0);\n    // get the step size of the ray\n    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);\n    \n    // next, set how far we are along the ray, so we can calculate the position of the sample\n    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere\n    // if it's inside, it should start at the position of the camera\n    // the min statement makes sure of that\n    float ray_pos_i = ray_length.x + step_size_i * 0.5;\n    \n    // these are the values we use to gather all the scattered light\n    vec3 total_ray = vec3(0.0); // for rayleigh\n    vec3 total_mie = vec3(0.0); // for mie\n    \n    // initialize the optical depth. This is used to calculate how much air was in the ray\n    vec3 opt_i = vec3(0.0);\n    \n    // we define the density early, as this helps doing integration\n    // usually we would do riemans summing, which is just the squares under the integral area\n    // this is a bit innefficient, and we can make it better by also taking the extra triangle at the top of the square into account\n    // the starting value is a bit inaccurate, but it should make it better overall\n    vec3 prev_density = vec3(0.0);\n    \n    // also init the scale height, avoids some vec2's later on\n    vec2 scale_height = vec2(height_ray, height_mie);\n    \n    // Calculate the Rayleigh and Mie phases.\n    // This is the color that will be scattered for this ray\n    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them\n    float mu = dot(dir, light_dir);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n    \n    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it\n    for (int i = 0; i < steps_i; ++i) {\n        \n        // calculate where we are along this ray\n        vec3 pos_i = start + dir * ray_pos_i;\n        \n        // and how high we are above the surface\n        float height_i = length(pos_i) - planet_radius;\n        \n        // now calculate the density of the particles (both for rayleigh and mie)\n        vec3 density = vec3(exp(-height_i / scale_height), 0.0);\n        \n        // and the absorption density. this is for ozone, which scales together with the rayleigh, \n        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height\n        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side\n        float denom = (height_absorption - height_i) / absorption_falloff;\n        density.z = (1.0 / (denom * denom + 1.0)) * density.x;\n        \n        // multiply it by the step size here\n        // we are going to use the density later on as well\n        density *= step_size_i;\n        \n        // Add these densities to the optical depth, so that we know how many particles are on this ray.\n        // max here is needed to prevent opt_i from potentially becoming negative\n        opt_i += max(density + (prev_density - density) * 0.5, 0.0);\n        \n        // and update the previous density\n        prev_density = density;\n\n        // Calculate the step size of the light ray.\n        // again with a ray sphere intersect\n        // a, b, c and d are already defined\n        a = dot(light_dir, light_dir);\n        b = 2.0 * dot(light_dir, pos_i);\n        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);\n        d = (b * b) - 4.0 * a * c;\n\n        // no early stopping, this one should always be inside the atmosphere\n        // calculate the ray length\n        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));\n\n        // and the position along this ray\n        // this time we are sure the ray is in the atmosphere, so set it to 0\n        float ray_pos_l = step_size_l * 0.5;\n\n        // and the optical depth of this ray\n        vec3 opt_l = vec3(0.0);\n        \n        // again, use the prev density for better integration\n        vec3 prev_density_l = vec3(0.0);\n        \n        // now sample the light ray\n        // this is similar to what we did before\n        for (int l = 0; l < steps_l; ++l) {\n\n            // calculate where we are along this ray\n            vec3 pos_l = pos_i + light_dir * ray_pos_l;\n\n            // the heigth of the position\n            float height_l = length(pos_l) - planet_radius;\n\n            // calculate the particle density, and add it\n            // this is a bit verbose\n            // first, set the density for ray and mie\n            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);\n            \n            // then, the absorption\n            float denom = (height_absorption - height_l) / absorption_falloff;\n            density_l.z = (1.0 / (denom * denom + 1.0)) * density_l.x;\n            \n            // multiply the density by the step size\n            density_l *= step_size_l;\n            \n            // and add it to the total optical depth\n            opt_l += max(density_l + (prev_density_l - density_l) * 0.5, 0.0);\n            \n            // and update the previous density\n            prev_density_l = density_l;\n\n            // and increment where we are along the light ray.\n            ray_pos_l += step_size_l;\n            \n        }\n        \n        // Now we need to calculate the attenuation\n        // this is essentially how much light reaches the current sample point due to scattering\n        vec3 attn = exp(-beta_ray * (opt_i.x + opt_l.x) - beta_mie * (opt_i.y + opt_l.y) - beta_absorption * (opt_i.z + opt_l.z));\n\n        // accumulate the scattered light (how much will be scattered towards the camera)\n        total_ray += density.x * attn;\n        total_mie += density.y * attn;\n\n        // and increment the position on this ray\n        ray_pos_i += step_size_i;\n    \t\n    }\n    \n    // calculate how much light can pass through the atmosphere\n    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));\n    \n\t// calculate and return the final color\n    return (\n        \tphase_ray * beta_ray * total_ray // rayleigh color\n       \t\t+ phase_mie * beta_mie * total_mie // mie\n            + opt_i.x * beta_ambient // and ambient\n    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly\n}\n\n/*\nA ray-sphere intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray sphere intersect built in\n*/\n\nvec2 ray_sphere_intersect(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {\n\n    // slightly bend the surface normal towards the light direction\n    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));\n    \n    // and sample the atmosphere\n    return calculate_scattering(\n    \tsample_pos,\t\t\t\t\t\t// the position of the camera\n        surface_normal, \t\t\t\t// the camera vector (ray direction of this pixel)\n        3.0 * ATMOS_RADIUS, \t\t\t// max dist, since nothing will stop the ray here, just use some arbitrary value\n        background_col,\t\t\t\t\t// scene color, just the background color here\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height\n        LIGHT_STEPS, \t\t\t\t\t// steps in the ray direction\n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n}\n\n/*\nThe following function returns the scene color and depth \n(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)\n\nin this case, the function renders a green sphere on the place where the planet should be\ncolor is in .xyz, distance in .w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {\n    \n    // the color to use, w is the scene depth\n    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);\n    \n    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white\n    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);\n    \n    // get where the ray intersects the planet\n    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); \n    \n    // if the ray hit the planet, set the max distance to that ray\n    if (0.0 < planet_intersect.y) {\n    \tcolor.w = max(planet_intersect.x, 0.0);\n        \n        // sample position, where the pixel is\n        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;\n        \n        // and the surface normal\n        vec3 surface_normal = normalize(sample_pos);\n        \n        // get the color of the sphere\n        color.xyz = vec3(0.0, 0.25, 0.05); \n        \n        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law\n        vec3 N = surface_normal;\n        vec3 V = -dir;\n        vec3 L = light_dir;\n        float dotNV = max(1e-6, dot(N, V));\n        float dotNL = max(1e-6, dot(N, L));\n        float shadow = dotNL / (dotNL + dotNV);\n        \n        // apply the shadow\n        color.xyz *= shadow;\n        \n        // apply skylight\n        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);\n    }\n    \n\treturn color;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 xy = coord.xy;\n\tvec2 xy_norm = xy / resolution.xy;\n\tvec2 xy_norm_offset = xy_norm * 2.0 - 1.0;\n\tvec2 xy_norm_offset_scaled = xy_norm_offset * vec2(aspect, 1.0);\n\tvec3 camera_vector = vec3(xy_norm_offset_scaled, -1.0);\n\treturn camera_vector;\n}\n\n/*\nFinally, draw the atmosphere to screen\n\nwe first get the camera vector and position, as well as the light dir\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the camera vector\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord);\n    \n    // get the camera position, switch based on the defines\n#if CAMERA_MODE==0\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);\n#endif\n#if CAMERA_MODE==1\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS , ATMOS_RADIUS);\n#endif\n#if CAMERA_MODE==2\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS + (-cos(iTime / 2.0) * (ATMOS_RADIUS - PLANET_RADIUS - 1.0)), 0.0);\n#endif\n#if CAMERA_MODE==3\n    float offset = (1.0 - cos(iTime / 2.0)) * ATMOS_RADIUS;\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 1.0, offset);\n#endif\n    // get the light direction\n    // also base this on the mouse position, that way the time of day can be changed with the mouse\n    vec3 light_dir = iMouse.y == 0.0 ? \n        normalize(vec3(0.0, cos(-iTime/8.0), sin(-iTime/8.0))) : \n    \tnormalize(vec3(0.0, cos(iMouse.y * -5.0 / iResolution.y), sin(iMouse.y * -5.0 / iResolution.y)));\n    \n    // get the scene color and depth, color is in xyz, depth in w\n    // replace this with something better if you are using this shader for something else\n    vec4 scene = render_scene(camera_position, camera_vector, light_dir);\n    \n    // the color of this pixel\n    vec3 col = vec3(0.0);//scene.xyz;\n    \n    // get the atmosphere color\n    col += calculate_scattering(\n    \tcamera_position,\t\t\t\t// the position of the camera\n        camera_vector, \t\t\t\t\t// the camera vector (ray direction of this pixel)\n        scene.w, \t\t\t\t\t\t// max dist, essentially the scene depth\n        scene.xyz,\t\t\t\t\t\t// scene color, the color of the current pixel being rendered\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height \n        PRIMARY_STEPS, \t\t\t\t\t// steps in the ray direction \n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n        \n    // apply exposure, removing this makes the brighter colors look ugly\n    // you can play around with removing this\n    col = 1.0 - exp(-col);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a cone that intersects a sphere, or a\n// \"solid angle\". Beware doing the max() of a cone and a \n// sphere won't produce an exact euclidean distance.\n// Based on sdPie(): https://www.shadertoy.com/view/3l23RK\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n    float d = dot(p, c.xy);\n    float h = length(p) - d;\n    return max(h, -d) - ra;\n}\n\nfloat map( in vec3 pos )\n{\n    pos.y += 0.4;\n    pos.xy = (mat2(4,3,-3,4)/5.0)*pos.xy;\n    \n    return sdSolidAngle(pos, vec2(3,4)/5.0, 0.7 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n  vec3 color = vec3(0.0);\n  if (material == 0) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 1) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 2) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 3) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 4) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 5) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 6) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 7) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 8) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 9) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 10) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 11) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 12) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 13) {\n    color = vec3(0.0, 0.0, 0.0);// incomplete generation!\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 0.9f;\n        case MATERIAL_METAL:\n            return 0.8f;\n        case MATERIAL_WOOD:\n            return 0.3f;\n        case MATERIAL_PLASTIC:\n            return 0.5f;\n        case MATERIAL_CONCRETE:\n            return 0.2f;\n        case MATERIAL_WATER:\n            return 0.9f;\n        case MATERIAL_ICE:\n            return 0.9f;\n        case MATERIAL_SNOW:\n            return 0.9f;\n        case MATERIAL_CLOTH:\n            return 0.5f;\n        case MATERIAL_CARPET:\n            return 0.5f;\n        case MATERIAL_GRASS:\n            return 0.5f;\n        case MATERIAL_DIRT:\n            return 0.5f;\n        case MATERIAL_SAND:\n            return 0.5f;\n        case MATERIAL_WOOD_PLANKS:\n            return 0.5f;\n        case MATERIAL_STONE:\n            return 0.5f;\n        case MATERIAL_BRICK:\n            return 0.5f;\n        case MATERIAL_BEDROCK:\n            return 0.5f;\n        case MATERIAL_LEAVES:\n            return 0.5f;\n        case MATERIAL_WOOD_PLANKS_2:\n            return 0.5f;\n        case MATERIAL_WOOD_PLANKS_3:\n            return 0.5f;\n        case MATERIAL_WOOD_PLANKS_4:\n            return 0.5f;\n        case MATERIAL_WOOD_PLANKS_5:\n            return 0.5f;\n        case MATERIAL_WO// incomplete generation!\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 1.5;\n        case MATERIAL_PLASTIC:\n            return 1.3;\n        case MATERIAL_METAL:\n            return 1.0;\n        default:\n            return 1.0;\n    }\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return material_opacity[material];\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 s1 = line_b - line_a;\n    vec3 s2 = line_a - tri_a;\n    float f = 1.0 / dot(cross(s1, e2), e1);\n    float u = f * dot(cross(s2, e1), s1);\n    float v = f * dot(cross(s2, e2), s1);\n    return vec3(u + v < 1.0 && u >= 0.0 && v >= 0.0, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    return normalize(cross(tri_ab, tri_ac));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n\n    return mat3(\n        x_axis,\n        y_axis,\n        z_axis\n    );\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    cast_ray_result result;\n    result.intersected = false;\n    result.distance = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000// incomplete generation!\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n  vec3 ray_direction = normalize(ray_target - ray_origin);\n  float ray_length = distance(ray_origin, ray_target);\n  float ray_distance = 0.0;\n  float ray_opacity = 1.0;\n  float ray_shadow = 1.0;\n  vec3 ray_position = ray_origin;\n  for (int i = 0; i < 100; i++) {\n    ray_position = ray_origin + ray_direction * ray_distance;\n    ray_opacity = ray_opacity * get_opacity(ray_position);\n    if (ray_opacity < 0.001) {\n      break;\n    }\n    ray_shadow = ray_shadow * get_shadow(ray_position);\n    ray_distance = ray_distance + 0.01;\n    if (ray_distance > ray_length) {\n      break;\n    }\n  }\n  return ray_shadow;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader shows how to control the velocity of an\n// object that is being animated with a sin() function.\n//\n// When animating something like angle=sin(v*t), with t being\n// the time (iTime for example), w is only the (angular) \n// velocity of the object if v is a constant.  Hence, doing \n// v(t) = smoothstep(0,1,t) for exampe will  result in an\n// acceleration and a deceleration, which is probably not\n// intenteded.\n//\n// To get the desired behaviour you need to define your v(t),\n// integrate it to get w(t), then plug it into the sin:\n//\n// v(t) = smoothste(0,1,t)      if t<1\n// v(t) = 1                     if t>=1\n//\n// Then you integrate that to get\n//\n// w(t) = t*t*t*(1.0 - t/2.0)   if t<1\n// w(t) = t-0.5                 if t>=1\n// \n// Try using the incorrect method below and restarting the\n// shader in order to see the difference:\n\n\n// 0: incorrect method: sin(v(t)*t)\n// 1:   correct method: sin(w(t))\n#define METHOD 1\n\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 tx, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*tx[3].xyz;\n    vec3 k = m*tx[0].xyz;\n    vec3 l = m*tx[1].xyz;\n    vec3 h = m*tx[2].xyz;\n    vec3 t1 = -n - k*tx[0].w - l*tx[1].w - h*tx[2].w;\n    vec3 t2 =  n - k*tx[0].w - l*tx[1].w - h*tx[2].w;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec4( -1.0 );\n    vec3 ins = (tx[3].xyz + rad) - (tx[0].xyz*tx[0].w + tx[1].xyz*tx[1].w + tx[2].xyz*tx[2].w);\n    vec3 ird = 1.0/rd;\n    vec3 t3 = -ird * ins;\n    vec3 t4 = ird * (ins - 2.0*rad);\n    float tN2 = max( max( t3.x, t3.y ), t3.z );\n    float tF2 = min( min( t4.x, t4.y ), t4.z );\n    if( tN2 > tF2 || tF2 < 0.0) return vec4( -1.0 );\n    if( tN < 0.0 ) tN = tN2;\n    if( tF > tF2 ) tF = tF2;\n    return vec4( tN// incomplete generation!\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3( 0.0, 0.0, 2.2 );\n    vec3 rd = normalize( vec3(p.xy,-1.8) );\n    \n    \n    #if METHOD==0\n        // WRONG\n    \tfloat animation = smoothstep(0.0,1.0,iTime)*iTime;\n    #else\n        // CORRECT\n        float animation = (iTime<1.0) ?\n    \t    iTime*iTime*iTime*(1.0 - iTime/2.0)\n            :\n            iTime-0.5;\n    #endif\n    \n\tmat4 txi = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), 0.5*animation-1.0 );\n\n\tvec3 col = vec3(0.1);\n\t\t\n\tconst vec3 box = vec3(0.4,0.6,0.8) ;\n\tvec4 res = iBox( ro, rd, txi, box);\n\tif( res.x>0.0 )\n\t{\n\t\tvec3 onor = res.yzw;\n\t\tvec3 wpos = ro + res.x*rd;\n\t\t\n\t    mat4 txx = inverse( txi );\n        vec3 opos = (txi*vec4(wpos,1.0)).xyz;\n        vec3 wnor = (txx*vec4(onor,0.0)).xyz;\n\n        col = vec3(1.0,0.5,0.1)*(0.5 + 0.5*wnor.y);\n        col *= 1.0 - (1.0-abs(onor.x))*smoothstep( box.x-0.04, box.x-0.02, abs(opos.x) );\n        col *= 1.0 - (1.0-abs(onor.y))*smoothstep( box.y-0.04, box.y-0.02, abs(opos.y) );\n        col *= 1.0 - (1.0-abs(onor.z))*smoothstep( box.z-0.04, box.z-0.02, abs(opos.z) );\n\t}\n\t\n\tcol = sqrt( col );\n\n\tfragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is a 1D noise that uses a single random number/hash\n// per invocation, instead of two like regular value and gradient\n// noises do. This means no neighboring information is needed\n// in order to preserve continuity, and therefore it's much faster\n// than both Value and Gradient Noise.\n//\n// In fact, this is a hybrid between the two - it has zeros at\n// integer locations like Gradient noise, but the gradients/\n// derivatives are constant, +-1. That way each cycle's boundaries\n// are fixed and continuity is preserved always. Then, the single\n// per cycle random number K controls the value of the signal's\n// peak, a bit like in a Value Noise. A quartic function is used\n// to interpolate the whole curve inside the cycle.\n//\n// p(0)=0, p'(0)=1, p(1)=0, p'(1)=-1, p(1/2)=k, p'(1/2)=0\n//\n// results in\n//\n// p(x)=x\u00b7(x-1)\u00b7((16k-4)\u00b7x\u00b7(x-1)-1)\n//\n// The yellow curve shows this new Basic Noise, superimposed on\n// top of a regular Gradient Noise in dark grey.\n\nfloat hash( uint n );\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    return fract(sin(x)*43758.5453);\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    uint  i = uint(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    float g0 = hash(i+0u)*2.0-1.0;\n    float g1 = hash(i+1u)*2.0-1.0;\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\n////////////////////////////////////\n\nfloat fbm( in float x )\n{    \n    float n = 0.0;\n    float s = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        n += s*bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px = 1.0/iResolution.y;\n    vec2 p = fragCoord*px;\n\t\n    vec3 col = vec3( 0.0 );\n    col = mix( col, vec3(0.7), 1.0 - smoothstep( 0.0, 2.0*px, abs( p.y - 0.75 ) ) );\n    col = mix( col, vec3(0.7), 1.0 - smoothstep( 0.0, 2.0*px, abs( p.y - 0.25 ) ) );\n    p.x += iTime*0.1;\n    \n    {\n    float y = 0.75+0.25*gnoise( 6.0*p.x );\n    col = mix( col, vec3(0.3,0.3,0.3), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    {\n    float y = 0.75+0.25*bnoise( 6.0*p.x );\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    {\n    float y = 0.25+0.15*fbm( 2.0*p.x );\n    col = mix( col, vec3(1.0,0.6,0.2), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}\n\nfloat hash( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n; \n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is a 1D noise that uses a single random number/hash\n// per invocation, instead of two like regular value and gradient\n// noises do. This means no neighboring information is needed\n// in order to preserve continuity, and therefore it's much faster\n// than both Value and Gradient Noise.\n//\n// In fact, this is a hybrid between the two - it has zeros at\n// integer locations like Gradient noise, but the gradients/\n// derivatives are constant, +-1. That way each cycle's boundaries\n// are fixed and continuity is preserved always. Then, the single\n// per cycle random number K controls the value of the signal's\n// peak, a bit like in a Value Noise. A quartic function is used\n// to interpolate the whole curve inside the cycle.\n//\n// p(0)=0, p'(0)=1, p(1)=0, p'(1)=-1, p(1/2)=k, p'(1/2)=0\n//\n// results in\n//\n// p(x)=x\u00b7(x-1)\u00b7((16k-4)\u00b7x\u00b7(x-1)-1)\n//\n// The yellow curve shows this new Basic Noise, superimposed on\n// top of a regular Gradient Noise in dark grey.\n\nfloat hash( uint n );\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n  //float k = hash(uint(i));\n  //float k = 0.5+0.5*sin(i);\n    float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    float fl = floor(p);\n    float fc = fract(p);\n    float fc2 = fc*fc;\n    float fc3 = fc2*fc;\n    float fc4 = fc3*fc;\n    float fc5 = fc4*fc;\n    float fc6 = fc5*fc;\n    float fc7 = fc6*fc;\n    float fc8 = fc7*fc;\n    float fc9 = fc8*fc;\n    float fc10 = fc9*fc;\n    float fc11 = fc10*fc;\n    float fc12 = fc11*fc;\n    float fc13 = fc12*fc;\n    float fc14 = fc13*fc;\n    float fc15 = fc14*fc;\n    float fc16 = fc15*fc;\n    float fc17 = fc16*fc;\n    float fc18 = fc17*fc;\n    float fc19 = fc18*fc;\n    float fc20 = fc19*fc;\n    float fc21 = fc20*fc;\n    float fc22 = fc21*fc;\n    float fc23 = fc22*fc;\n    float fc24 = fc23*fc;\n    float fc25 = fc24*fc;\n    float fc26 = fc25*fc;\n    float fc27 = fc26*fc;\n    float fc28 = fc27*fc;\n    float fc29 = fc28*fc;\n    float fc30 = fc29*fc;\n    float fc31 = fc30*fc;\n    float fc32 = fc31*fc;\n    float fc33 = fc32*fc;\n    float fc34 = fc33*fc;\n\n////////////////////////////////////\n\nfloat fbm( in float x )\n{    \n    float n = 0.0;\n    float s = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        n += s*bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px = 1.0/iResolution.y;\n    vec2 p = fragCoord*px;\n\t\n    vec3 col = vec3( 0.0 );\n    col = mix( col, vec3(0.7), 1.0 - smoothstep( 0.0, 2.0*px, abs( p.y - 0.75 ) ) );\n    col = mix( col, vec3(0.7), 1.0 - smoothstep( 0.0, 2.0*px, abs( p.y - 0.25 ) ) );\n    p.x += iTime*0.1;\n    \n    {\n    float y = 0.75+0.25*gnoise( 6.0*p.x );\n    col = mix( col, vec3(0.3,0.3,0.3), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    {\n    float y = 0.75+0.25*bnoise( 6.0*p.x );\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    {\n    float y = 0.25+0.15*fbm( 2.0*p.x );\n    col = mix( col, vec3(1.0,0.6,0.2), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}\n\nfloat hash( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n; \n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n    return fract(sin(float(n)*1e-3)*456789.456);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime + 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    float n = floor(p);\n    float f = fract(p);\n    float s = f*f*(3.0-2.0*f);\n    return mix( rand(n), rand(n+1.0), s );\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime + 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{\n    float f = 0.0;\n    float A = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += A * noise(x);\n        x = x * 2.0 + G;\n        A = A * 0.5;\n    }\n    return f;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime + 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Something I toyed with a decade ago was mapping all possible\n// quadratic polynomials to the surface of a sphere:\n//\n// http://www.iquilezles.org/blog/?p=1089\n//\n// See also this video: https://www.youtube.com/watch?v=JJYVqviE2Uk\n//\n// Basically, all possible quadratic equations (parabolas) can be\n// mapped to the surface of a sphere. p(x)=ax\u00b2+bx+c becomes a point\n// (a,b,c) in 3D space, and since all quadratics of the form\n// (k\u00b7a, k\u00b7b, k\u00b7c) has the same solutions, all space can be\n// collapsed into a unit sphere through vector normalization.\n//\n// In blue are complex solutions.\n// In yellow are real solutions with different signs\n// In white are real solutions with same signs\n//\n// Similar idea, but for cubic equations:\n// https://www.shadertoy.com/view/tsVSRR\n\n//-------------------------------------------------------\n\n// For a point in the sphere's surface p, return a color based on\n// the solutions of the associate quadratic polynomial\nvec3 getColor( in vec3 p )\n{\n    // Quadratic polynomial coefficients\n    float a = 1.0;\n    float b = 2.0*dot(p,p);\n    float c = dot(p,p) - 1.0;\n\n    // Quadratic polynomial solutions\n    float t0 = (-b - sqrt(b*b - 4.0*a*c)) / (2.0*a);\n    float t1 = (-b + sqrt(b*b - 4.0*a*c)) / (2.0*a);\n\n    // Return a color based on the solutions\n    return vec3(t0, t1, 0.0);\n}\n\n//-------------------------------------------------------\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    return dot(nor,r)*(sph.w*sph.w)/(l*l*l);\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 plot2D( in vec2 px )\n{\n    vec2 p = px/iResolution.xy;\n    \n#if 1\n    p.x -= 0.5;\n    vec2 a = p.yx*vec2(3.141593, 6.283185);\n        \n    vec3 q = vec3( cos(a.x),\n                   sin(a.x)*cos(a.y),\n                   sin(a.x)*sin(a.y) );\n#else\n    p.y = -0.5 + p.y;\n    vec2 a = p*vec2(6.283185,3.141593);\n        \n    vec3 q = vec3( cos(a.y)*cos(a.x),\n        \t\t   sin(a.y),\n                   cos(a.y)*sin(a.x) );\n#endif    \n    \n    //if( length(q-vec3(0,1,0))<0.1 ) return vec3(1,0,0);\n    \n    return getColor(q);    \n}\n\n//=====================================================\n\nvec3 plot3D( in vec2 px )\n{\n    vec2 p = (-iResolution.xy + 2.0*px)/iResolution.y;\n\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 3.0 );\n    vec3 rd = normalize( vec3(p,-2.0) );\n\n    // sphere\n    vec4 sph = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n    vec3 col = vec3(0.0);\n\n    // intersect geometry\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    vec3 mate = vec3(1.0);\n\n    // plane/floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0-sphOcclusion( pos, nor, sph );\n        mate = vec3(0.2);\n    }\n\n    // sphere\n    float t2 = sphIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph );\n        occ = 0.5 + 0.5*nor.y;\n        mate = getColor(nor);\n    }\n\n    // apply color and lighting\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n\n        vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n        float sha = sphSoftShadow( pos, lig, sph, 2.0 );\n\n        vec3 lin = vec3(1.5)*clamp(dot(nor,lig),0.0,1.0)*sha;\n        lin += 0.5*occ;\n        lin += 0.5*occ*pow(clamp(1.0+dot(nor,rd),0.0,1.0),3.0);\n\n        col = mate*lin;\n        // fog\n        col *= exp( -0.05*tmin );\n    }\n    return col;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p = fragCoord + vec2(float(m),float(n))/float(AA)-0.5;\n        #else    \n        vec2 p = fragCoord;\n        #endif\n \n        // draw stuff\n        vec3 col = (sin(0.7*iTime)<-0.5) ? plot2D(p) : plot3D(p);\n\n        // gamma correction\n        col = pow(col,vec3(0.4545));\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    // output color\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//-------------------------------------------------------\n\n// For a point p in the unit box, return a color\n// based on the solutions of the associated cubic\n// polynomial. The point p is interprested as the \n// 3 polar angles of a 4D point in a unit sphere,\n// and that 4D point maps to a unique cubic\n// polynomials a,b,c,d coefficients.\nvec3 getColor( in vec3 pb ) // p is in -1..1\n{\n    float a, b, c, d;\n    float x, y, z, w;\n    float t;\n    float r;\n    float r2;\n    float r3;\n    float r4;\n    float r5;\n    float r6;\n    float r7;\n    float r8;\n    float r9;\n    float r10;\n    float r11;\n    float r12;\n    float r13;\n    float r14;\n    float r15;\n    float r16;\n    float r17;\n    float r18;\n    float r19;\n    float r20;\n    float r21;\n    float r22;\n    float r23;\n    float r24;\n    float r25;\n    float r26;\n    float r27;\n    float r28;\n    float r29;\n    float r30;\n    float r31;\n    float r32;\n    float r33;\n    float r34;\n    float r35;\n    float r36;\n    float r37;\n    float r38;\n    float r39;\n    float r40;\n    float r41;\n    float r42;\n    float r43;\n    float r44;\n    float r45;\n    float r46;\n    float r47;\n    float r48;\n    float r49;\n    float r50;\n    float r51;\n    float r52;\n    float r53;\n    float r54;\n    float r55;\n    float r56;\n\n//-------------------------------------------------------\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ro -= cen;\n    \n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n\n\treturn vec4( tN, nor );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ro -= cen;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (0.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 plot3D( in vec2 px )\n{\n    vec2 p = (-iResolution.xy + 2.0*px)/iResolution.y;\n\n    // camera\n     // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 4.0*cos(an), 4.0, 4.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n    \n    // sphere\n    //vec3 box = vec3( 1.0 );\n    \n    float h = 0.5+0.49995*sin(1.0*iTime);\n    //h = 1.0;\n    vec3 box_cen = vec3(0.0,h,0.0);\n    vec3 box_rad = vec3(1.0,h,2.0);\n       \n\n    vec3 col = vec3(0.0);\n\n    // intersect geometry\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    vec3 mate = vec3(1.0);\n\n    // plane/floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0;//-sphOcclusion( pos, nor, sph );\n        float d = sdBox( pos.xz, box_rad.xz );\n        occ = 0.2 + 0.8*clamp(1.0 - 1.0/(1.0+d*d),0.0,1.0);\n            \n        mate = vec3(0.2);\n    }\n\n    // box\n    vec4 t2 = boxIntersect( ro, rd, box_cen, box_rad );\n    if( t2.x>0.0 && t2.x<tmin )\n    {\n        tmin = t2.x;\n        vec3 pos = ro + t2.x*rd;\n        nor = t2.yzw;\n        occ = 0.2+0.8*clamp(pos.y/2.0,0.0,1.0);\n        mate = getColor(pos);\n\n        // wireframe\n        mate *= 1.0 - (1.0-abs(nor.x))*smoothstep( box_rad.x-0.04, box_rad.x-0.02, abs(pos.x-box_cen.x) );\n        mate *= 1.0 - (1.0-abs(nor.y))*smoothstep( box_rad.y-0.04, box_rad.y-0.02, abs(pos.y-box_cen.y) );\n        mate *= 1.0 - (1.0-abs(nor.z))*smoothstep( box_rad.z-0.04, box_rad.z-0.02, abs(pos.z-box_cen.z) );\n    }\n\n    // apply color and lighting\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n\n        vec3 lig = normalize( vec3(0.6,0.2,0.4) );\n\n        float sha = step( boxShadow( pos+0.01*nor, lig, box_cen, box_rad ), 0.0 );\n\n        vec3 lin = vec3(0.0);\n        lin += vec3(1.5)*clamp(dot(nor,lig),0.0,1.0)*sha;\n        lin += 0.5*occ;\n        //lin += 0.5*occ*pow(clamp(1.0+dot(nor,rd),0.0,1.0),3.0);\n\n        col = mate*lin;\n        //col = vec3(occ);\n        //col = mate;\n        // fog\n        col *= exp( -0.05*tmin );\n    }\n    return col;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p = fragCoord + vec2(float(m),float(n))/float(AA)-0.5;\n        #else    \n        vec2 p = fragCoord;\n        #endif\n \n        vec3 col = plot3D(p);\n\n        // gamma correction\n        col = pow(col,vec3(0.4545));\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//-------------------------------------------------------\n\n// For a point p in the unit box, return a color\n// based on the solutions of the associated cubic\n// polynomial. The point p is interprested as the \n// 3 polar angles of a 4D point in a unit sphere,\n// and that 4D point maps to a unique cubic\n// polynomials a,b,c,d coefficients.\nvec3 getColor( in vec3 pb ) // p is in -1..1\n{\n    vec3 col = vec3(0.0);\n    float m = 0.0;\n\n    \n    //-------------------------------------------------------\n    \n    // convert from box space to cannoincal 0..1\n    pb = 0.5 + 0.498*pb/vec3(1.0,1.0,2.0); \n    \n    pb += vec3(0.5,0.5,0.5);\n    \n    // convert to 4D polar coordinates with radius=1\n    pb *= vec3(3.141593,3.141593,6.283185);\n    \n    // convert to cartesian 4D\n    vec4 ps = vec4( cos(pb.x),\n                    sin(pb.x)*cos(pb.y),\n                    sin(pb.x)*sin(pb.y)*cos(pb.z),\n                    sin(pb.x)*sin(pb.y)*sin(pb.z) );\n    \n    //-----------------------------\n    // make lead coefficient=1\n    ps /= ps.x;\n    \n#if 1\n    //-----------------------------\n    // compute depressed cubic t^3 + pt + q = 0\n    float p = (3.0*ps.z - ps.y*ps.y)/3.0;\n    float q = (2.0*ps.y*ps.y*ps.y - 9.0*ps.y*ps.z + 27.0*ps.w)/27.0;\n    \n    // discriminant\n    float h = -4.0*p*p*p - 27.0*q*q;\n#else    \n    // discriminant\n    float h = 18.0*ps.y*ps.z*ps.w - 4.0*ps.y*ps.y*ps.y*ps.w + ps.y*ps.y*ps.z*ps.z - 4.0*ps.z*ps.z*ps.z - 27.0*ps.w*ps.w;\n#endif    \n    \n    if( h<0.0 )\n    {\n        // 1 real, 2 complex roots. Make it blue, and shade it\n        // based on modulo of the roots\n        m = -h;//length(vec2(-p.y,sqrt(-h)))*0.5/abs(p.x);\n        col = vec3(0.0,0.5,1.0);\n    }\n    else\n    {\n        // 3 real roots. Make it yellow if possitive and\n        // purple is negative, and shader it based on size\n        // of the first root\n        m = h;//1.0;//(-p.y-sqrt(h))*0.5/p.x;\n        col = vec3(1.0,0.5,0.0);// : vec3(1.0,0.0,0.5);\n\t}\n    \n    // discriminant --> geometric mean of root differences\n    h = pow(abs(h),1.0/6.0);\n    col *= 0.7 + 0.3*smoothstep(-0.1,0.1,sin(abs(12.0*h))); // discriminant isolines\n    //col *= h;\n    return col;\n}\n\n//-------------------------------------------------------\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec4( -1.0 );\n    return vec4( tN, tF );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ro -= cen;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (0.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 plot3D( in vec2 px )\n{\n    vec2 p = (-iResolution.xy + 2.0*px)/iResolution.y;\n\n    // camera\n     // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 4.0*cos(an), 4.0, 4.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n    \n    // sphere\n    //vec3 box = vec3( 1.0 );\n    \n    float h = 0.5+0.49995*sin(1.0*iTime);\n    //h = 1.0;\n    vec3 box_cen = vec3(0.0,h,0.0);\n    vec3 box_rad = vec3(1.0,h,2.0);\n       \n\n    vec3 col = vec3(0.0);\n\n    // intersect geometry\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    vec3 mate = vec3(1.0);\n\n    // plane/floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0;//-sphOcclusion( pos, nor, sph );\n        float d = sdBox( pos.xz, box_rad.xz );\n        occ = 0.2 + 0.8*clamp(1.0 - 1.0/(1.0+d*d),0.0,1.0);\n            \n        mate = vec3(0.2);\n    }\n\n    // box\n    vec4 t2 = boxIntersect( ro, rd, box_cen, box_rad );\n    if( t2.x>0.0 && t2.x<tmin )\n    {\n        tmin = t2.x;\n        vec3 pos = ro + t2.x*rd;\n        nor = t2.yzw;\n        occ = 0.2+0.8*clamp(pos.y/2.0,0.0,1.0);\n        mate = getColor(pos);\n\n        // wireframe\n        mate *= 1.0 - (1.0-abs(nor.x))*smoothstep( box_rad.x-0.04, box_rad.x-0.02, abs(pos.x-box_cen.x) );\n        mate *= 1.0 - (1.0-abs(nor.y))*smoothstep( box_rad.y-0.04, box_rad.y-0.02, abs(pos.y-box_cen.y) );\n        mate *= 1.0 - (1.0-abs(nor.z))*smoothstep( box_rad.z-0.04, box_rad.z-0.02, abs(pos.z-box_cen.z) );\n    }\n\n    // apply color and lighting\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n\n        vec3 lig = normalize( vec3(0.6,0.2,0.4) );\n\n        float sha = step( boxShadow( pos+0.01*nor, lig, box_cen, box_rad ), 0.0 );\n\n        vec3 lin = vec3(0.0);\n        lin += vec3(1.5)*clamp(dot(nor,lig),0.0,1.0)*sha;\n        lin += 0.5*occ;\n        //lin += 0.5*occ*pow(clamp(1.0+dot(nor,rd),0.0,1.0),3.0);\n\n        col = mate*lin;\n        //col = vec3(occ);\n        //col = mate;\n        // fog\n        col *= exp( -0.05*tmin );\n    }\n    return col;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p = fragCoord + vec2(float(m),float(n))/float(AA)-0.5;\n        #else    \n        vec2 p = fragCoord;\n        #endif\n \n        vec3 col = plot3D(p);\n\n        // gamma correction\n        col = pow(col,vec3(0.4545));\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//-------------------------------------------------------\n\n// For a point p in the unit box, return a color\n// based on the solutions of the associated cubic\n// polynomial. The point p is interprested as the \n// 3 polar angles of a 4D point in a unit sphere,\n// and that 4D point maps to a unique cubic\n// polynomials a,b,c,d coefficients.\nvec3 getColor( in vec3 pb ) // p is in -1..1\n{\n    vec3 col = vec3(0.0);\n    float m = 0.0;\n\n    \n    //-------------------------------------------------------\n    \n    // convert from box space to cannoincal 0..1\n    pb = 0.5 + 0.498*pb/vec3(1.0,1.0,2.0); \n    \n    pb += vec3(0.5,0.5,0.5);\n    \n    // convert to 4D polar coordinates with radius=1\n    pb *= vec3(3.141593,3.141593,6.283185);\n    \n    // convert to cartesian 4D\n    vec4 ps = vec4( cos(pb.x),\n                    sin(pb.x)*cos(pb.y),\n                    sin(pb.x)*sin(pb.y)*cos(pb.z),\n                    sin(pb.x)*sin(pb.y)*sin(pb.z) );\n    \n    //-----------------------------\n    // make lead coefficient=1\n    ps /= ps.x;\n    \n#if 1\n    //-----------------------------\n    // compute depressed cubic t^3 + pt + q = 0\n    float p = (3.0*ps.z - ps.y*ps.y)/3.0;\n    float q = (2.0*ps.y*ps.y*ps.y - 9.0*ps.y*ps.z + 27.0*ps.w)/27.0;\n    \n    // discriminant\n    float h = -4.0*p*p*p - 27.0*q*q;\n#else    \n    // discriminant\n    float h = 18.0*ps.y*ps.z*ps.w - 4.0*ps.y*ps.y*ps.y*ps.w + ps.y*ps.y*ps.z*ps.z - 4.0*ps.z*ps.z*ps.z - 27.0*ps.w*ps.w;\n#endif    \n    \n    if( h<0.0 )\n    {\n        // 1 real, 2 complex roots. Make it blue, and shade it\n        // based on modulo of the roots\n        m = -h;//length(vec2(-p.y,sqrt(-h)))*0.5/abs(p.x);\n        col = vec3(0.0,0.5,1.0);\n    }\n    else\n    {\n        // 3 real roots. Make it yellow if possitive and\n        // purple is negative, and shader it based on size\n        // of the first root\n        m = h;//1.0;//(-p.y-sqrt(h))*0.5/p.x;\n        col = vec3(1.0,0.5,0.0);// : vec3(1.0,0.0,0.5);\n\t}\n    \n    // discriminant --> geometric mean of root differences\n    h = pow(abs(h),1.0/6.0);\n    col *= 0.7 + 0.3*smoothstep(-0.1,0.1,sin(abs(12.0*h))); // discriminant isolines\n    //col *= h;\n    return col;\n}\n\n//-------------------------------------------------------\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ro -= cen;\n    \n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n\n\treturn vec4( tN, nor );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return -1.0;\n    return tN;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (0.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 plot3D( in vec2 px )\n{\n    vec2 p = (-iResolution.xy + 2.0*px)/iResolution.y;\n\n    // camera\n     // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 4.0*cos(an), 4.0, 4.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n    \n    // sphere\n    //vec3 box = vec3( 1.0 );\n    \n    float h = 0.5+0.49995*sin(1.0*iTime);\n    //h = 1.0;\n    vec3 box_cen = vec3(0.0,h,0.0);\n    vec3 box_rad = vec3(1.0,h,2.0);\n       \n\n    vec3 col = vec3(0.0);\n\n    // intersect geometry\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    vec3 mate = vec3(1.0);\n\n    // plane/floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0;//-sphOcclusion( pos, nor, sph );\n        float d = sdBox( pos.xz, box_rad.xz );\n        occ = 0.2 + 0.8*clamp(1.0 - 1.0/(1.0+d*d),0.0,1.0);\n            \n        mate = vec3(0.2);\n    }\n\n    // box\n    vec4 t2 = boxIntersect( ro, rd, box_cen, box_rad );\n    if( t2.x>0.0 && t2.x<tmin )\n    {\n        tmin = t2.x;\n        vec3 pos = ro + t2.x*rd;\n        nor = t2.yzw;\n        occ = 0.2+0.8*clamp(pos.y/2.0,0.0,1.0);\n        mate = getColor(pos);\n\n        // wireframe\n        mate *= 1.0 - (1.0-abs(nor.x))*smoothstep( box_rad.x-0.04, box_rad.x-0.02, abs(pos.x-box_cen.x) );\n        mate *= 1.0 - (1.0-abs(nor.y))*smoothstep( box_rad.y-0.04, box_rad.y-0.02, abs(pos.y-box_cen.y) );\n        mate *= 1.0 - (1.0-abs(nor.z))*smoothstep( box_rad.z-0.04, box_rad.z-0.02, abs(pos.z-box_cen.z) );\n    }\n\n    // apply color and lighting\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n\n        vec3 lig = normalize( vec3(0.6,0.2,0.4) );\n\n        float sha = step( boxShadow( pos+0.01*nor, lig, box_cen, box_rad ), 0.0 );\n\n        vec3 lin = vec3(0.0);\n        lin += vec3(1.5)*clamp(dot(nor,lig),0.0,1.0)*sha;\n        lin += 0.5*occ;\n        //lin += 0.5*occ*pow(clamp(1.0+dot(nor,rd),0.0,1.0),3.0);\n\n        col = mate*lin;\n        //col = vec3(occ);\n        //col = mate;\n        // fog\n        col *= exp( -0.05*tmin );\n    }\n    return col;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p = fragCoord + vec2(float(m),float(n))/float(AA)-0.5;\n        #else    \n        vec2 p = fragCoord;\n        #endif\n \n        vec3 col = plot3D(p);\n\n        // gamma correction\n        col = pow(col,vec3(0.4545));\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash1(float k) {\n    int x = FK(k);int y = FK(cos(k));\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float k) {\n    float r1 = hash1(k);\n    float r2 = hash1(r1);\n    float r3 = hash1(r2);\n    return vec3(r1, r2, r3);\n}\n\n//rotate P around axis AX by angle RO\nvec3 rotate(vec3 p, vec3 ax, float ro) {\n  float s = sin(ro);\n  float c = cos(ro);\n  vec3 q = vec3(\n    (ax.x * ax.x * (1.0 - c)) + c,\n    (ax.x * ax.y * (1.0 - c)) - (ax.z * s),\n    (ax.x * ax.z * (1.0 - c)) + (ax.y * s)\n  );\n  vec3 r = vec3(\n    (ax.y * ax.x * (1.0 - c)) + (ax.z * s),\n    (ax.y * ax.y * (1.0 - c)) + c,\n    (ax.y * ax.z * (1.0 - c)) - (ax.x * s)\n  );\n  vec3 t = vec3(\n    (ax.z * ax.x * (1.0 - c)) - (ax.y * s),\n    (ax.z * ax.y * (1.0 - c)) + (ax.x * s),\n    (ax.z * ax.z * (1.0 - c)) + c\n  );\n  return vec3(\n    dot(p, q),\n    dot(p, r),\n    dot(p, t)\n  );\n}\n\nvec3 sphericalCoordinates(vec2 p) {\n    float phi = acos(p.x);\n    float theta = p.y*3.1415;\n    return vec3(cos(phi), sin(phi)*sin(theta), sin(phi)*cos(theta));\n}\n\nvec3 domainRepetition(vec3 p, vec3 scale) {\n    return (fract(p/scale)-0.5)*scale;\n}\n\nvec4 component(vec3 p, vec3 offset, vec3 rotation) {\n    vec3 axis = sphericalCoordinates(rotation.xy);\n    float angle = rotation.z * 3.1415;\n    p = rotate(p, axis, angle);\n    p = domainRepetition(p + offset, vec3(1));\n\n    vec3 normal = rotate(normalize(p), axis, -angle);\n    return vec4(length(p)-0.48, normal);\n}\n\nvec4 scene(vec3 p) {\n    vec4 accum = vec4(0.);\n    float iters = 5.;\n    for (float i = 0.; i < iters; i++) {\n    \tvec3 off = hash3(i);\n    \tvec3 rot = hash3(hash1(i));\n    \taccum += component(p, off, rot);\n    }\n    return accum/sqrt(iters*1.5)-0.1;\n}\n\nfloat phong(vec3 norm, vec3 light) {\n    return abs(dot(norm, light));\n}\n\nvec3 shade(vec3 p, vec3 norm, vec3 cam) {\n    float d1 = length(sin(p)*0.5+0.5)/sqrt(3.);\n    float d2 = length(sin(norm)*0.5+0.5)/sqrt(3.);\n    return sqrt(phong(norm, cam)*( d1*vec3(0.8,0.2,0.1) + (1.-d2)*vec3(0.3,0.6,0.9)  ));\n}\n\nvoid castRay(vec3 cam, inout vec3 p, inout vec4 dist) {\n    float sgn = 1.;\n    for (int i = 0; i < 100; i++) {\n        dist = scene(p);\n        if (i == 0) sgn = sign(dist.x);\n        if (abs(dist.x) < 0.001) return;\n        p += cam*dist.x*sgn;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    fragColor = vec4(0.0);\n    \n    vec3 cam = normalize(vec3(0.5, uv));\n    vec3 init = vec3(iTime,0.,0.);\n    vec3 p = init;\n    vec4 dist; vec3 norm;\n    castRay(cam, p, dist);\n    norm = normalize(dist.yzw);\n    vec3 col1 = shade(p, norm, cam);\n    \n    float pdist = distance(p, init);\n    float transparency = pow(1./(pdist+1.),8.);\n    float fog1 = pow(exp(-pdist*0.5)/exp(0.),0.5);\n    \n    vec3 col2 = col1;\n    if (transparency > 0.02) {\n    \tp+=cam*0.1;\n        init = p;\n    \tcastRay(cam, p, dist);\n    \tnorm = normalize(dist.yzw);\n    \tcol2 = shade(p, norm, cam);\n    }\n\n    float pdist2 = distance(p, init);\n    float fog2 = pow(exp(-pdist2*0.5)/exp(0.),0.5);\n    \n    fragColor.xyz = mix(col1*fog1, col2*fog2, transparency);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader is what I believe the most accurate fake soft shadow implementation\n// to date, in that it reproduces correct inner and outer penumbra sizes casting\n// a single ray. It matches the ground truth pretty well for different light\n// source sizes.\n// \n// Code is in line 119\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 q = vec2( length(p.xz)-r, abs(p.y-h*0.5)-h*0.5 );\n    return min( max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nbool shadowBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return false;\n\treturn tN>0.0 && tN<tmax;\n}\n\nbool shadowSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float tmax )\n{\n\tvec3 oc = ro - cen;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return false;\n\tfloat t = -b - sqrt( h );\n    return t>0.0 && t<tmax;\n}\n\nbool shadowCylinder( in vec3 ro, in vec3 rd, in float he, float ra, in float tmax )\n{\n    float he2 = he*he;\n    \n    float k2 = 1.0        - rd.y*rd.y;\n    float k1 = dot(ro,rd) - ro.y*rd.y;\n    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return false;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = ro.y + t*rd.y;\n    if( y>0.0 && y<he )\n    {\n        return t>0.0 && t<tmax;\n    }\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : he) - ro.y)/rd.y;\n    if( abs(k1+k2*t)<h )\n    {\n        return t>0.0 && t<tmax;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 p2 = vec3( mod(pos.x+1.0,3.0)-1.0, pos.yz );\n    vec3 p3 = vec3( mod(pos.x+2.0,3.0)-1.0, pos.yz );\n    vec3 p4 = vec3( mod(pos.x+3.0,3.0)-1.0, pos.yz );\n\n    float d1 = sdPlane(    pos-vec3(0.0,0.00,0.0) );\n    float d2 = sdSphere(   p2-vec3(0.0,0.30,0.0), 0.4 );\n    float d3 = sdBox(      p3-vec3(0.0,0.25,0.0), vec3(0.2,0.5,0.2) );\n    float d4 = sdCylinder( p4-vec3(0.0,0.0,0.0), 0.8,0.3 );\n      \n    return min(min(d1,d2),min(d3,d4));\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float ph = 1.0;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*tmax).x;\n        if(h<0.001) return 0.0;\n        float d = h*h/(ph+h);\n        float l = sqrt(d*d+tmax*tmax);\n        float dt = l-tmax;\n        tmax += dt;\n        ph = h;\n        res = min(res, w*l/tmax);\n    }\n    return res;\n}\n\n\n// montecarlo based shadow, for ground truth comparison\nfloat seed; float rand(void) { return fract(sin(seed++)*768.475278); }\n\nfloat realSoftShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, float w )\n{\n    vec3 uu = normalize(cross(rd,vec3(0,1,0)));\n    vec3 vv = normalize(cross(rd,uu));\n    \n    float tot = 0.0;\n    const int num = 32; // cast 32 rays\n\tfor( int j=0; j<num; j++ )\n    {\n        // uniform distribution on an disk\n        float ra = sqrt(rand());\n        float an = 6.283185*rand();\n        vec3 jrd = rd + w*ra*(uu*cos(an)+vv*sin(an));\n        \n        // raycast\n        float res = 1.0;\n        \n        for( int i=0; i<7; i++ ) // 7 objects\n        {\n            int k = i % 3;\n            bool sha = false;\n                 if(k==0) sha = shadowBox( ro, jrd, vec3(-4.0 + float(i),0.25,0.0), vec3(0.2,0.5,0.2), tmax);\n            else if(k==1) sha = shadowSphere(ro, jrd, vec3(-4.0 + float(i),0.3,0.0), 0.4, tmax);\n            else          sha = shadowCylinder( ro - vec3(-4.0 + float(i),0.0,0.0), jrd, 0.8, 0.3, tmax);\n            \n            if( sha ) { res=0.0; break; }\n        }\n        \n        \n        tot += res;\n    }\n    return tot/float(num);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<128; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in int technique, in float lightSize)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate = vec3(0.3);\n\n        // key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        \n        float sha = (technique==0) ? realSoftShadow(pos, lig, 0.01, 3.0, lightSize ) \n                                   : apprSoftShadow(pos, lig, 0.01, 3.0, lightSize );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n        \n\t\tfloat spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*\n                    dif *\n                    (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=       9.0*spe*vec3(0.90,0.80,1.0);\n        \n        // ambient light\n        float occ = (pos.y>0.01) ? 1.0 : calcAO( pos, nor );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n        col += mate*amb*occ*vec3(0.05,0.1,0.15);\n        \n        // fog\n        col *= exp( -0.0008*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    float an = 12.0 - sin(0.1*iTime);\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    seed = sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)*sin(iTime);\n    \n    // animation\n    int technique = (fract(iTime/3.0)>0.5) ? 1 : 0;\n    float lightSize = 0.05 + 0.04*sin(0.7*iTime);\n\n    // render\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, technique, lightSize);\n\n        // gain\n        col = 1.8*col/(1.0+dot(col,vec3(0.333)));\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader is what I believe the most accurate fake soft shadow implementation\n// to date, in that it reproduces correct inner and outer penumbra sizes casting\n// a single ray. It matches the ground truth pretty well for different light\n// source sizes.\n// \n// Code is in line 119\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 q = vec2( length(p.xz)-r, abs(p.y-h*0.5)-h*0.5 );\n    return min( max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nbool shadowBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return false;\n\treturn tN>0.0 && tN<tmax;\n}\n\nbool shadowSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float tmax )\n{\n\tvec3 oc = ro - cen;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return false;\n\tfloat t = -b - sqrt( h );\n    return t>0.0 && t<tmax;\n}\n\nbool shadowCylinder( in vec3 ro, in vec3 rd, in float he, float ra, in float tmax )\n{\n    float he2 = he*he;\n    \n    float k2 = 1.0        - rd.y*rd.y;\n    float k1 = dot(ro,rd) - ro.y*rd.y;\n    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return false;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = ro.y + t*rd.y;\n    if( y>0.0 && y<he )\n    {\n        return t>0.0 && t<tmax;\n    }\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : he) - ro.y)/rd.y;\n    if( abs(k1+k2*t)<h )\n    {\n        return t>0.0 && t<tmax;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 p2 = vec3( mod(pos.x+1.0,3.0)-1.0, pos.yz );\n    vec3 p3 = vec3( mod(pos.x+2.0,3.0)-1.0, pos.yz );\n    vec3 p4 = vec3( mod(pos.x+3.0,3.0)-1.0, pos.yz );\n\n    float d1 = sdPlane(    pos-vec3(0.0,0.00,0.0) );\n    float d2 = sdSphere(   p2-vec3(0.0,0.30,0.0), 0.4 );\n    float d3 = sdBox(      p3-vec3(0.0,0.25,0.0), vec3(0.2,0.5,0.2) );\n    float d4 = sdCylinder( p4-vec3(0.0,0.0,0.0), 0.8,0.3 );\n      \n    return min(min(d1,d2),min(d3,d4));\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n \tfloat t = mint;\n    float res = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n     \tfloat h = map(ro + t*rd);\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n\n// montecarlo based shadow, for ground truth comparison\nfloat seed; float rand(void) { seed = fract(10000.0*seed); return seed; }\n\nfloat realSoftShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, float w )\n{\n    vec3 uu = normalize(cross(rd,vec3(0,1,0)));\n    vec3 vv = normalize(cross(rd,uu));\n    \n    float tot = 0.0;\n    const int num = 32; // cast 32 rays\n\tfor( int j=0; j<num; j++ )\n    {\n        // uniform distribution on an disk\n        float ra = sqrt(rand());\n        float an = 6.283185*rand();\n        vec3 jrd = rd + w*ra*(uu*cos(an)+vv*sin(an));\n        \n        // raycast\n        float res = 1.0;\n        \n        for( int i=0; i<7; i++ ) // 7 objects\n        {\n            int k = i % 3;\n            bool sha = false;\n                 if(k==0) sha = shadowBox( ro, jrd, vec3(-4.0 + float(i),0.25,0.0), vec3(0.2,0.5,0.2), tmax);\n            else if(k==1) sha = shadowSphere(ro, jrd, vec3(-4.0 + float(i),0.3,0.0), 0.4, tmax);\n            else          sha = shadowCylinder( ro - vec3(-4.0 + float(i),0.0,0.0), jrd, 0.8, 0.3, tmax);\n            \n            if( sha ) { res=0.0; break; }\n        }\n        \n        \n        tot += res;\n    }\n    return tot/float(num);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<128; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in int technique, in float lightSize)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate = vec3(0.3);\n\n        // key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        \n        float sha = (technique==0) ? realSoftShadow(pos, lig, 0.01, 3.0, lightSize ) \n                                   : apprSoftShadow(pos, lig, 0.01, 3.0, lightSize );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n        \n\t\tfloat spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*\n                    dif *\n                    (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=       9.0*spe*vec3(0.90,0.80,1.0);\n        \n        // ambient light\n        float occ = (pos.y>0.01) ? 1.0 : calcAO( pos, nor );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n        col += mate*amb*occ*vec3(0.05,0.1,0.15);\n        \n        // fog\n        col *= exp( -0.0008*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    float an = 12.0 - sin(0.1*iTime);\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    seed = sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)*sin(iTime);\n    \n    // animation\n    int technique = (fract(iTime/3.0)>0.5) ? 1 : 0;\n    float lightSize = 0.05 + 0.04*sin(0.7*iTime);\n\n    // render\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, technique, lightSize);\n\n        // gain\n        col = 1.8*col/(1.0+dot(col,vec3(0.333)));\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    float h = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        h = sin(h);\n        h = sin(h + p.x) + sin(h + p.y) + sin(h + p.z);\n    }\n    return h;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\nvec2 map( in vec3 p )\n{\n    // box\n    float d = sdBox( p, vec3(1.0) );\n\n    // fbm\n    vec2 dt = sdFbm( p+0.5, d );\n\n    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;\n    \n    return dt;\n}\n\nconst float precis = 0.0005;\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec2 h = map( pos );\n        res.x = t;\n        res.y = h.y;\n        \n\t\tif( h.x<precis || t>dis.y ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>dis.y ) res = vec2(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)\n{\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return 1.0;\n    \n    tmin = max(tmin,dis.x);\n\ttmax = min(tmax,dis.y);\n    \n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n     \tfloat h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n   \n        // camera anim\n        float an = -0.1*iTime;\n        vec3 ro = 4.0*vec3( cos(an), 0.4, sin(an) );\n        vec3 ta = vec3( 0.0, -0.35, 0.0 );\n\n        // camera matrix\t\n        vec3  cw = normalize( ta-ro );\n        vec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n        vec3  cv = normalize( cross(cu,cw) );\n        vec3  rd = normalize( p.x*cu + p.y*cv + 2.7*cw );\n\n        // render\n        vec3 col = vec3(0.01);\n        vec2 tm = raycast( ro, rd );\n        float t = tm.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float occ = tm.y*tm.y;\n\n            // material\n            vec3 mate = mix( vec3(0.6,0.3,0.1), vec3(1), tm.y )*0.7;\n\n            // key light\n            {\n            const vec3 lig = normalize(vec3(1.0,0.5,0.6));\n            float dif = dot(lig,nor);\n            if( dif>0.0 ) dif *= calcSoftShadow(pos+nor*0.001,lig,0.001,10.0,0.003);\n            dif = clamp(dif,0.0,1.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = clamp(dot(hal,nor),0.0,1.0);\n            spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n            col = vec3(0.0);\n            col += mate*1.5*vec3(1.30,0.85,0.75)*dif;\n            col +=      9.0*spe;\n            }\n            // ambient light\n            {\n            col += mate*0.2*vec3(0.40,0.45,0.60)*occ*(0.6+0.4*nor.y);\n            }\n        }\n\n        // tonemap\n        col = col*1.7/(1.0+col);\n        \n        // gamma\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.7 + 0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor=vec4(tot,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\nvec2 map( in vec3 p )\n{\n    // box\n    float d = sdBox( p, vec3(1.0) );\n\n    // fbm\n    vec2 dt = sdFbm( p+0.5, d );\n\n    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;\n    \n    return dt;\n}\n\nconst float precis = 0.0005;\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec2 h = map( pos );\n        res.x = t;\n        res.y = h.y;\n        \n\t\tif( h.x<precis || t>dis.y ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>dis.y ) res = vec2(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)\n{\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return 1.0;\n    \n    tmin = max(tmin,dis.x);\n\ttmax = min(tmax,dis.y);\n    \n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n     \tfloat h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n   \n        // camera anim\n        float an = -0.1*iTime;\n        vec3 ro = 4.0*vec3( cos(an), 0.4, sin(an) );\n        vec3 ta = vec3( 0.0, -0.35, 0.0 );\n\n        // camera matrix\t\n        vec3  cw = normalize( ta-ro );\n        vec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n        vec3  cv = normalize( cross(cu,cw) );\n        vec3  rd = normalize( p.x*cu + p.y*cv + 2.7*cw );\n\n        // render\n        vec3 col = vec3(0.01);\n        vec2 tm = raycast( ro, rd );\n        float t = tm.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float occ = tm.y*tm.y;\n\n            // material\n            vec3 mate = mix( vec3(0.6,0.3,0.1), vec3(1), tm.y )*0.7;\n\n            // key light\n            {\n            const vec3 lig = normalize(vec3(1.0,0.5,0.6));\n            float dif = dot(lig,nor);\n            if( dif>0.0 ) dif *= calcSoftShadow(pos+nor*0.001,lig,0.001,10.0,0.003);\n            dif = clamp(dif,0.0,1.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = clamp(dot(hal,nor),0.0,1.0);\n            spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n            col = vec3(0.0);\n            col += mate*1.5*vec3(1.30,0.85,0.75)*dif;\n            col +=      9.0*spe;\n            }\n            // ambient light\n            {\n            col += mate*0.2*vec3(0.40,0.45,0.60)*occ*(0.6+0.4*nor.y);\n            }\n        }\n\n        // tonemap\n        col = col*1.7/(1.0+col);\n        \n        // gamma\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.7 + 0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor=vec4(tot,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\nvec2 map( in vec3 p )\n{\n    // box\n    float d = sdBox( p, vec3(1.0) );\n\n    // fbm\n    vec2 dt = sdFbm( p+0.5, d );\n\n    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;\n    \n    return dt;\n}\n\nconst float precis = 0.0005;\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec2 h = map( pos );\n        res.x = t;\n        res.y = h.y;\n        \n\t\tif( h.x<precis || t>dis.y ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>dis.y ) res = vec2(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)\n{\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return 1.0;\n    \n    tmin = max(tmin,dis.x);\n\ttmax = min(tmax,dis.y);\n    \n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n     \tfloat h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n   \n        // camera anim\n        float an = -0.1*iTime;\n        vec3 ro = 4.0*vec3( cos(an), 0.4, sin(an) );\n        vec3 ta = vec3( 0.0, -0.35, 0.0 );\n\n        // camera matrix\t\n        vec3  cw = normalize( ta-ro );\n        vec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n        vec3  cv = normalize( cross(cu,cw) );\n        vec3  rd = normalize( p.x*cu + p.y*cv + 2.7*cw );\n\n        // render\n        vec3 col = vec3(0.01);\n        vec2 tm = raycast( ro, rd );\n        float t = tm.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float occ = tm.y*tm.y;\n\n            // material\n            vec3 mate = mix( vec3(0.6,0.3,0.1), vec3(1), tm.y )*0.7;\n\n            // key light\n            {\n            const vec3 lig = normalize(vec3(1.0,0.5,0.6));\n            float dif = dot(lig,nor);\n            if( dif>0.0 ) dif *= calcSoftShadow(pos+nor*0.001,lig,0.001,10.0,0.003);\n            dif = clamp(dif,0.0,1.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = clamp(dot(hal,nor),0.0,1.0);\n            spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n            col = vec3(0.0);\n            col += mate*1.5*vec3(1.30,0.85,0.75)*dif;\n            col +=      9.0*spe;\n            }\n            // ambient light\n            {\n            col += mate*0.2*vec3(0.40,0.45,0.60)*occ*(0.6+0.4*nor.y);\n            }\n        }\n\n        // tonemap\n        col = col*1.7/(1.0+col);\n        \n        // gamma\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.7 + 0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor=vec4(tot,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\nvec2 map( in vec3 p )\n{\n    // box\n    float d = sdBox( p, vec3(1.0) );\n\n    // fbm\n    vec2 dt = sdFbm( p+0.5, d );\n\n    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;\n    \n    return dt;\n}\n\nconst float precis = 0.0005;\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec2 h = map( pos );\n        res.x = t;\n        res.y = h.y;\n        \n\t\tif( h.x<precis || t>dis.y ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>dis.y ) res = vec2(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)\n{\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return 1.0;\n    \n    tmin = max(tmin,dis.x);\n\ttmax = min(tmax,dis.y);\n    \n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n     \tfloat h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n   \n        // camera anim\n        float an = -0.1*iTime;\n        vec3 ro = 4.0*vec3( cos(an), 0.4, sin(an) );\n        vec3 ta = vec3( 0.0, -0.35, 0.0 );\n\n        // camera matrix\t\n        vec3  cw = normalize( ta-ro );\n        vec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n        vec3  cv = normalize( cross(cu,cw) );\n        vec3  rd = normalize( p.x*cu + p.y*cv + 2.7*cw );\n\n        // render\n        vec3 col = vec3(0.01);\n        vec2 tm = raycast( ro, rd );\n        float t = tm.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float occ = tm.y*tm.y;\n\n            // material\n            vec3 mate = mix( vec3(0.6,0.3,0.1), vec3(1), tm.y )*0.7;\n\n            // key light\n            {\n            const vec3 lig = normalize(vec3(1.0,0.5,0.6));\n            float dif = dot(lig,nor);\n            if( dif>0.0 ) dif *= calcSoftShadow(pos+nor*0.001,lig,0.001,10.0,0.003);\n            dif = clamp(dif,0.0,1.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = clamp(dot(hal,nor),0.0,1.0);\n            spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n            col = vec3(0.0);\n            col += mate*1.5*vec3(1.30,0.85,0.75)*dif;\n            col +=      9.0*spe;\n            }\n            // ambient light\n            {\n            col += mate*0.2*vec3(0.40,0.45,0.60)*occ*(0.6+0.4*nor.y);\n            }\n        }\n\n        // tonemap\n        col = col*1.7/(1.0+col);\n        \n        // gamma\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.7 + 0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor=vec4(tot,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\nvec2 map( in vec3 p )\n{\n    // box\n    float d = sdBox( p, vec3(1.0) );\n\n    // fbm\n    vec2 dt = sdFbm( p+0.5, d );\n\n    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;\n    \n    return dt;\n}\n\nconst float precis = 0.0005;\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec2 h = map( pos );\n        res.x = t;\n        res.y = h.y;\n        \n\t\tif( h.x<precis || t>dis.y ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>dis.y ) res = vec2(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)\n{\n    float res = 1.0;\n    float t = tmin;\n    for(int i=0; i<10; i++)\n    {\n        float h = map(ro + rd*t).x;\n        res = min(res, w*h/t);\n        t += clamp(h, 0.01, 0.1);\n        if(res<0.001 || t>tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n   \n        // camera anim\n        float an = -0.1*iTime;\n        vec3 ro = 4.0*vec3( cos(an), 0.4, sin(an) );\n        vec3 ta = vec3( 0.0, -0.35, 0.0 );\n\n        // camera matrix\t\n        vec3  cw = normalize( ta-ro );\n        vec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n        vec3  cv = normalize( cross(cu,cw) );\n        vec3  rd = normalize( p.x*cu + p.y*cv + 2.7*cw );\n\n        // render\n        vec3 col = vec3(0.01);\n        vec2 tm = raycast( ro, rd );\n        float t = tm.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float occ = tm.y*tm.y;\n\n            // material\n            vec3 mate = mix( vec3(0.6,0.3,0.1), vec3(1), tm.y )*0.7;\n\n            // key light\n            {\n            const vec3 lig = normalize(vec3(1.0,0.5,0.6));\n            float dif = dot(lig,nor);\n            if( dif>0.0 ) dif *= calcSoftShadow(pos+nor*0.001,lig,0.001,10.0,0.003);\n            dif = clamp(dif,0.0,1.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = clamp(dot(hal,nor),0.0,1.0);\n            spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n            col = vec3(0.0);\n            col += mate*1.5*vec3(1.30,0.85,0.75)*dif;\n            col +=      9.0*spe;\n            }\n            // ambient light\n            {\n            col += mate*0.2*vec3(0.40,0.45,0.60)*occ*(0.6+0.4*nor.y);\n            }\n        }\n\n        // tonemap\n        col = col*1.7/(1.0+col);\n        \n        // gamma\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.7 + 0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor=vec4(tot,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2019 Miguel \"Codax\" Nieves\n// Twitter: @GameDevMig\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define PI 3.14159265359\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //How many stripes to show (even works best)\n    float stripes = 16.0;\n    //Wave Scroll Speed\n    float speed = 0.35;\n    \n    //Animated height of each wave from -1 to 1\n    float amplitude = sin(iTime * 2.0);\n    //float amplitude = (2.0 * abs( (2.0 * fract(iTime * 0.5))-1.0 ) - 1.0); //Triangle Wave\n    amplitude *= 0.68;//0.78;\n    \n    uv.y = uv.y * stripes;\n    uv.x = uv.x * 4.0;\n    \n    float waveID = round(uv.y);\n    \n    //Current Wave but cap the parts would overlap\n    vec2 waveUV = uv;\n    waveUV.x += iTime  * speed * (2.0 * step(1.0,mod(waveID,2.0)) - 1.);\n    waveUV.y += max(-0.5, min(0.5, sin(waveUV.x * PI * 2.0) * amplitude));\n\n\t//Use next line only if amplitude is between -0.5 and 0.5\n    //waveUV.y += sin(waveUV.x * PI * 2.0) * amplitude; \n    \n    //Hold on to the current Stripe value\n    float midWave = waveUV.y;\n    \n    //Calculate the Value from the Stripe Above\n    float upperWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID + 1.0,2.0)) - 1.));\n    upperWave = sin(upperWave * PI * 2.0) * amplitude;\n    \n    upperWave *= 1.0- step(0.5, fract(uv.y));\n    /*if (fract(uv.y) >= 0.5) //Optimized Out\n    {\n        upperWave = 0.0;\n    }*/\n                      \n\tupperWave += fract(uv.y);\n    upperWave = step(1.0, upperWave);\n    \n    //Calculate the Value from the Strip Below\n    float lowerWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID - 1.0,2.0)) - 1.));\n    lowerWave = sin(lowerWave * PI * 2.0) * amplitude;\n    \n    lowerWave *= step(0.5, fract(uv.y));\n    /*if (fract(uv.y) < 0.5) //Optimized Out\n    {\n        lowerWave = 0.0;\n    }\n\t*/\n    lowerWave += fract(uv.y);\n    lowerWave = step(0.00, lowerWave);\n\n\n    //Mix and Overlap\n\tmidWave *= upperWave;\t//Use the Upperwave to first mask the mid wave\n    upperWave *= step(0.000,midWave - waveID); //Then overlap the upperwave by the midwave\n    \n    waveUV.y *= (1.0 - upperWave); //Mask out the upper Wave\n    waveUV.y += upperWave * (uv.y + 1.0); //Add in the upper \n    \n\twaveUV.y *= lowerWave;  //Mask out the lower wave from the \n    waveUV.y += (1.0 - lowerWave) * (uv.y - 1.0); //Put in the overlap from the lower wave\n\n   \n    //Create a color ID from 0.0 - 1.0\n    float colorID = floor( waveUV.y ) / stripes;\n    \n    float ct = iTime * 0.1;\n    //vec3 col = pal( colorID, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,1.0),vec3(0.4 * sin(ct*1.23),0.40 * cos(ct*2.14),0.80 * sin(-ct)) );\n    vec3 col = pal( colorID, vec3(0.5,0.5,1.0),vec3(0.5,0.5,1.0),vec3(2.0, 1.0, 0.0),vec3(0.2+sin(ct*1.23), 0.2+cos(ct*2.14), 0.1 + sin(-ct)));\n    \n    //Darken the bottom few waves\n    col *= smoothstep(1.0, 0.6, 1.0 - colorID);\n\n    // Wave Debug\n    //col = vec3(colorID);// * fract(uv.y));\n\n    // Output to screen \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Euclidean distance to rhombus with thickness and rounding.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p.xz = abs(p.xz);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz);\n    p.xz = max(p.xz,0.0);\n    p.xz = length(p.xz)-ra;\n    p.y = abs(p.y)-h;\n    return max(p.xz,p.y);\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sdRhombus(pos, 0.6, 0.2, 0.02, 0.02 ) - 0.01;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a segment, or can maybe also call it\n// \"capsule\" coordinates.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  x = a + ba*h;\n    float d = length( p - x );\n    float s = sign( cross( ba, pa ) );\n    float g = smoothstep( -band, band, d*s );\n    float w = length( pa.x*ba.y - pa.y*ba.x );\n    return vec4( x, w, g );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n\n    // animate segment\n    float id = floor((iTime+0.1)/5.0);\n    vec2  pa = 0.7*cos( vec2(3,2) + id*1.0);\n    vec2  pb = 0.7*cos( vec2(6,1) + id*1.7);\n    float ra = 0.15 + 0.05*sin(id*0.2);\n\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paSegment(uv,pa,pb,ra,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A wave based noise, similar to gabor and all its variants but much\n// simplified, originially explored in shadertoy by user robobo1221\n// in this shader: https://www.shadertoy.com/view/wttSRj\n//\n// It is comparable in speed to traditional gradient noise (if the\n// architecture supports fast sin/cos, like GPUs do anyways), but\n// slower than value noise of course. The advantage is that it's\n// infinitely derivable. It can also be easily animated by moving\n// the waves over time or rotating the gradients, which is fun.\n//\n// But the main advantage is that it can generate a wromy look, as\n// in robobo1221's original shader, by changing the kF constant in \n// line 45 to be closer to 6\n\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\n\n\n\n// You should replace this hash by one that you like and meets\n// your needs. This one is here just as example and should not\n// be used in production.\nvec2 g( vec2 n ) {\n    return fract(sin(n)*43758.5453);\n}\n//vec2 g( vec2 n ) { return sin(n.x*n.y+vec2(0,1.571)); } // if you want the gradients to lay on a circle\n\nfloat noise(vec2 p)\n{\n    const float kF = 2.0;  // make 6 to see worms\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\n    float f = 0.0;\n\t\n    // left: noise\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 24.0*uv + iTime*4.0 );\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 8.0;\n        uv += iTime*4.0/3.0;\n        const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a rounded box. Or could also be called\n// \"rounded box\" coordinates.\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat msign( in float x ) { return (x<0.0)?-1.0:1.0; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 q = abs(p)-b;\n    vec2 w = max(q,0.0);\n    float d = length(max(vec2(0.0),q));\n    float sd = min(s,d);\n    float sdf = min(max(q.x,q.y),0.0) - r;\n    return vec4(w,sd,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n\n    // animate segment\n    float id = floor((iTime+0.1)/3.0);\n    vec2  si = vec2(0.35,0.15) + 0.1*cos( vec2(1,2) + id*vec2(3,1) );\n    float ra = 0.15 + 0.05*sin(id*0.2);\n    \n    // distance and parametrization    \n    const float band = 0.1;\n    vec4 b = paBox( p, si, ra, band );\n\n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/band)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/band+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    // circles\n    if( d>-band*0.5 )\n    {\n\tvec2 q = b.xy;\n    q.y *= floor(b.z/band)*(band/b.z);  // optional - ensure periodicity, but break physicallity\n    q.y -= iTime*0.1;                   // animate circles\n    \n    vec2 uv = fract(q/band+0.5)-0.5;    // draw circles\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a box. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\n\n// Other Box functions\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  v = max(w,0.0);\n    float a = length(v);\n    float b = min(max(w.x,w.y),0.0);\n    return vec3(a,b,s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // corner radious\n    float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgBox(p,vec2(0.8,0.3));\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a circle.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band ) \n{\n    float d = length(p);\n    float d2 = abs(d - r);\n    float d3 = abs(d - r - band);\n    float d4 = abs(d - r + band);\n    float d5 = min(d2, min(d3, d4));\n    return vec4(d, d5, 2.0*band, d5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    const float ra = 0.5 ;\n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paCircle(uv,ra,bandSize);\n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a polygon. It only works for convex\n// polygons, has some problems, and I still need to optimize it.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    float d = 1e10;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 a = verts[i];\n        vec2 b = verts[(i+1)%5];\n        d = min( d, sdSegment( p, a, b, r ) );\n    }\n    return d;\n}\n\nfloat angle( in vec2 a, in vec2 b )\n{\n    float n = atan(dot(a,b),cro(a,b));\n    if( n<0.0 )n+=6.283185;\n    return n;\n}\n    \n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band ) \n{\n    const int num = verts.length();\n\n    float od = sdPoly( p, verts, r );\n    \n    float ra = band*round(od/band);\n    \n    float d = length(p-verts[0])-ra;\n    float l = 0.0;\n    float t = 0.0;\n    for( int i=0; i<num; i++ )\n    {\n        vec2 a = verts[ i       ];\n        vec2 b = verts[(i+1)%num];\n        vec2 c = verts[(i+2)%num];\n            \n        vec2  pa1 = p-a; vec2 ba1 = b-a;\n        vec2  pa2 = p-b; vec2 ba2 = c-b;\n        float h1 = dot(pa1,ba1)/dot(ba1,ba1);\n        float h2 = dot(pa2,ba2)/dot(ba2,ba2);\n        float tmp = length( pa1 - ba1*clamp(h1,0.0,1.0) ) - (r+ra);\n        \n        float lba = length(ba1);\n        \n        if( tmp<d || ((i==num-1) && cro(ba1,pa1)>0.0) )\n        {\n            d = min(d,tmp);\n            if( h1>=0.0 && h1<=1.0 )\n            {\n                l = t + h1*lba;\n            }\n            else if( h1>1.0 && h2<0.0)\n            {\n                l = t+lba;\n                l += (r+ra)*angle(ba1,pa2);\n            }\n        }\n        t += lba+(r+ra)*angle(ba1,vec2(-ba2.y,ba2.x));\n    }\n    \n    return vec4(d,l,t,od);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    // animate polygon\n    float id = floor((iTime+0.1)/3.0);\n    vec2 kVerts[5];\n    for( int i=0; i<5; i++ )\n    {\n        kVerts[i] = 0.75*cos( float(i)*vec2(1.1,1.3) + vec2(0,2) + id*11.0 );\n    }\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paPoly(uv,kVerts,0.15,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += 1.0-smoothstep(0.0, 0.005, abs(d)-0.003);\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n        \n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,abs(l-0.35)-0.03);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,l-0.10);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a polygon. It only works for convex\n// polygons, has some problems, and I still need to optimize it.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    const int num = verts.length();\n\tfloat s = 1.0;\n    float d = length(p-verts[0]);\n    for( int i=0; i<num; i++ )\n    {\n        vec2 a = verts[i];\n        vec2 b = verts[(i+1)%num];\n       \n        vec2  pa = p-a;\n        vec2  ba = b-a;\n        float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = min(d,length( pa - ba*h ));\n        \n        bvec3 cond = bvec3( p.y>=a.y, p.y<b.y, ba.x*pa.y>ba.y*pa.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*d-r;\n}\n\nfloat angle( in vec2 a, in vec2 b )\n{\n    float n = atan(dot(a,b),cro(a,b));\n    if( n<0.0 )n+=6.283185;\n    return n;\n}\n    \n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band ) \n{\n    vec2  v0 = verts[0], v1 = verts[1], v2 = verts[2], v3 = verts[3], v4 = verts[4];\n    float d = 0.0;\n    float l = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float z0 = 0.0;\n    float z1 = 0.0;\n    float z2 = 0.0;\n    float z3 = 0.0;\n    float z4 = 0.0;\n    float z5 = 0.0;\n    float z6 = 0.0;\n    float z7 = 0.0;\n    float z8 = 0.0;\n    float z9 = 0.0;\n    float z10 = 0.0;\n    float z11 = 0.0;\n    float z12 = 0.0;\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    // animate polygon\n    float id = floor((iTime+0.1)/3.0);\n    vec2 kVerts[5];\n    for( int i=0; i<5; i++ )\n    {\n        kVerts[i] = 0.75*cos( float(i)*vec2(1.1,1.3) + vec2(0,2) + id*11.0 );\n    }\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paPoly(uv,kVerts,0.15,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += 1.0-smoothstep(0.0, 0.005, abs(d)-0.003);\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n        \n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,abs(l-0.35)-0.03);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,l-0.10);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a segment. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h), h, ba );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec2 v1 = 0.8*cos( 0.5*iTime*vec2(1.3,1.0) + vec2(2,4) );\n        vec2 v2 = 0.8*cos( 0.5*iTime*vec2(0.9,1.2) + vec2(1,5) );\n        float th = 0.15*(0.5+0.5*sin(iTime*1.2+2.0));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgSegment(p,v1,v2);\n        float d = dg.x - th;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a hexagon. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    vec2 pa = p;\n    pa.x -= clamp(pa.x,0.0,r*1.5);\n    float s = (pa.x>0.0)?1.0:-1.0;\n    pa.y -= s*r*0.5;\n    pa.y = abs(pa.y);\n    pa.x -= r*0.5;\n    pa.x = abs(pa.x);\n    pa.x -= r*0.5;\n    pa.y -= r*0.5;\n    pa.y = abs(pa.y);\n    pa.y -= r*0.5;\n    float d = length(pa);\n    return vec3( d, 0.0, 0.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // size\n\tfloat si = 0.3 + 0.2*cos( iTime );\n    // corner radious\n    float ra = 0.3*(0.5+0.5*sin(iTime*2.0));\n\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgHexagon(p,si);\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n     vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\n//smooth triangle wave for smooth domain repetition https://www.desmos.com/calculator/ototv6tja8\nvec4 stri(vec4 p, float k) {\n    float s = smoothstep(-0.5, 0.5, sin(p.x * k));\n    float c = smoothstep(-0.5, 0.5, cos(p.y * k));\n    float t = smoothstep(-0.5, 0.5, tan(p.z * k));\n    float b = smoothstep(-0.5, 0.5, sin(p.w * k));\n    return vec4(s, c, t, b);\n}\n\nfloat scene(vec4 p) {\n  vec4 q = abs(p) - 1.;\n  float cube = length(max(q,0.0)) + min(max(max(q.x,q.w),max(q.y,q.z)),0.0) - 0.1;\n  float scale = 1.;\n  vec4 p2 = p+iTime*0.2;\n  p2 = (stri(p2/scale, .9)-0.5)*scale;\n  float spheres = length(p2)-0.2;\n  spheres = -smin(-(length(p) - 2.), -spheres, 0.1);\n  return smin(cube, spheres, 0.5);\n}\n\nvec4 norm(vec4 p) {\n  mat4 k = mat4(p,p,p,p) - mat4(0.001);\n  return normalize(scene(p) - vec4( scene(k[0]),scene(k[1]),scene(k[2]),scene(k[3]) ) );\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n  return pow(vec3(r,g,b),vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  vec4 cam = normalize(vec4(1,uv,0));\n  vec4 init = vec4(-5,0,0,sin(iTime*0.1));\n\n  float wrot = cos(iTime*0.5);\n  float zrot = cos(iTime*0.25);\n  float yrot = sin(iTime*0.5);\n  float zrot2 = iTime;\n  if (iMouse.z > 0.) {\n    zrot = mouse.x*2.;\n    wrot = radians(45.0);\n    yrot = mouse.y*2.;\n    zrot2 = 0.;\n  }\n  cam.xyw = erot(cam.xyw, vec3(0,1,0), zrot);\n  init.xyw = erot(init.xyw, vec3(0,1,0), zrot);\n  cam.xyz = erot(cam.xyz, vec3(0,1,0), yrot);\n  init.xyz = erot(init.xyz, vec3(0,1,0), yrot);\n  cam.yzw = erot(cam.yzw, vec3(0,1,0), wrot);\n  init.yzw = erot(init.yzw, vec3(0,1,0), wrot);\n  cam.xyz = erot(cam.xyz, vec3(0,0,1), zrot2);\n  init.xyz = erot(init.xyz, vec3(0,0,1), zrot2);\n  \n  vec4 p = init;\n  bool hit = false;\n  for (int i = 0; i<200 && !hit;i++) {\n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n  }\n  vec4 n = norm(p);\n  vec4 r = reflect(cam,n);\n  vec4 aon = reflect(cam, norm(p+r*0.3));\n  float factor = length(sin(aon*3.)*0.5+0.5)/2.;\n  vec3 color = mix(srgb(0.1,0.1,0.2), srgb(0.2,0.6,0.9), factor) + pow(factor, 10.);\n  fragColor.xyz = hit ? color : srgb(0.1,0.1,0.1);\n  fragColor.xyz = sqrt(fragColor.xyz);\n}"], ["////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Conic Envelope\n//\n// Copyright (c) Matthew Arcus, 2020\n// MIT License: https://opensource.org/licenses/MIT\n//\n// More projective magic - generate an ellipse as an envelope of lines.\n// In fact, we start with the ellipse and find a network of lines\n// enveloping it: at each point p, find tangents to the ellipse,\n// intersect these with a fixed axis at x = -3 - this will be the\n// source of the rays. From axis intersection point, map to a radial\n// parameter, then find closest displayed ray, map that back to the\n// axis and find the tangents from there & these are the lines that\n// actually get displayed.\n//\n// Mouse changes size and orientation of ellipse.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2) {\n  vec3 n = normalize(X * p);\n  vec3 d = normalize(X * vec3(0, 0, 1));\n  vec3 t = normalize(cross(n, d));\n  vec3 t1 = normalize(cross(n, t));\n  vec3 t2 = normalize(cross(t, n));\n  tan1 = t1;\n  tan2 = t2;\n  return dot(t1, t2) < 0.0;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 3.0;\n  float t = 0.2*iTime+PI/6.0;\n  float A = 0.25, B = 1.0;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    t += PI*(m.y);\n    B = exp(-m.x);\n  }\n  float cost = cos(t), sint = sin(t);\n  // Conic matrix - conic is points p with pXp = 0\n  mat3 X = mat3(A,0,0,0,B,0,0,0,-1);\n  // Apply tranformation to conic matrix.\n  mat3 P = mat3(cost,sint,0, -sint,cost,0, 0,0,1);\n  X = transpose(P)*X*P;\n\n  vec3 p = vec3(scale*(2.0*fragCoord - iResolution.xy)/iResolution.y,1);\n\n  vec3 col = vec3(0);\n  \n  float lwidth0 = 0.0;\n  float lwidth1 = max(0.02,fwidth(p.x));\n\n  vec3 tan1,tan2,tan11,tan12,tan21,tan22;\n  if (tangents(p,X,tan1,tan2)) {\n    float N = 64.0;\n    vec3 axis = vec3(1,0,3);\n    float index1,index2;\n\n    vec3 p1 = join(tan1,axis);\n    float t1 = atan(p1.y/p1.z);\n    t1 += 0.1*iTime;\n    t1 *= N/PI; t1 = round(t1); index1 = t1; t1 *= PI/N;\n    t1 -= 0.1*iTime;\n    p1 = vec3(-3,tan(t1),1);\n    p1.y = sign(p1.y)*min(abs(p1.y),1e4); // Fix up silly values\n    if (tangents(p1,X,tan11,tan12)) {\n      vec3 c1 = hsv2rgb(vec3(index1/N,1,1));\n      float d = line(p,tan11);\n      col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan2.xy),normalize(tan12.xy));\n      // Try not to get the wrong tangent here. There must be a better\n      // way of doing this.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan12);\n        col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n\n    vec3 p2 = join(tan2,axis);\n    float t2 = atan(p2.y/p2.z);\n    t2 += 0.1*iTime;\n    t2 *= N/PI; t2 = round(t2); index2 = t2; t2 *= PI/N;\n    t2 -= 0.1*iTime;\n    p2 = vec3(-3,tan(t2),1);\n    p2.y = sign(p2.y)*min(abs(p2.y),1e4); // Fix up silly values\n    if (tangents(p2,X,tan21,tan22)) {\n      vec3 c2 = hsv2rgb(vec3(index2/N,1,1));\n      float d = line(p,tan22);\n      col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan1.xy),normalize(tan21.xy));\n      // Try not to get the wrong tangent here.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan21);\n        col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}"], ["// Author: https://www.shadertoy.com/user/andretugan\n// Creative Commons Attribution-NonCommercial 3.0 Unported License\n// https://creativecommons.org/licenses/by-nc/3.0\n\n#define NUM_CHORDS 128\n\n#define M_PI 3.14159265358\n#define M_2_PI (2. * 3.14159265358)\n\n#define FADE_INNER_RADIUS 0.8\n#define FADE_OUTER_RADIUS 1.1\n#define LINE_WIDTH 4.\n\n// Function from Inigo Quilez\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;                   \n    float uv2 = dot(uv, uv);        \n    if (uv2 > FADE_OUTER_RADIUS * FADE_OUTER_RADIUS) { \n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n               \n    float multiplier = 1.99 + 5. * (.5 - .5 * cos(iTime * 0.03));\n    float start = multiplier * M_PI * 0.25;\n    float val = 0.;\n\n    for (int i = 0; i < NUM_CHORDS; ++i) {\n        float angle1 = start + M_2_PI / float(NUM_CHORDS) * float(i);\n        float angle2 = multiplier * angle1;\n        vec2 point1 = vec2(cos(angle1), sin(angle1));\t                       \n        vec2 point2 = vec2(cos(angle2), sin(angle2));\n\n        vec2 diff = point2 - point1;\n        vec2 perp = point1 + (dot(uv - point1, diff) / dot(diff, diff)) * diff - uv;\n        float dist2 = dot(perp, perp);\n        \n        float line_width = LINE_WIDTH / iResolution.y;                                        \n    \tfloat add_val = smoothstep(line_width * line_width, line_width * line_width * 0.5, dist2);                                                 \n        add_val *= smoothstep(FADE_OUTER_RADIUS * FADE_OUTER_RADIUS, FADE_INNER_RADIUS * FADE_INNER_RADIUS, uv2);        \n        val += add_val;\n    }\n    \n    val *= 20. / float(NUM_CHORDS);\n    val = pow(val, 0.5);\n    \n    float hue = sin(iTime * 0.05 + uv2 * 0.3);                                  \n    fragColor = vec4(hsv2rgb(vec3(hue, 1., val)),1.0);\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this shader is an experiment with mapping a 4 dimensional SDF onto a 3 dimensional one, by\n//using the components of 3d space plus the distance to a given SDF. this can be used to\n//map domain-repeated spheres onto the surface of an SDF, and use those spheres to cut holes\n//into it, much like pitted metal. Becase these spheres are restrained to the surface of the\n//SDF, we can control exactly what part of the SDF gets pitted. This shader cycles through 3\n//possibilities. pitting everything, only pitting inside existing pits, or only pitting\n//outside existing pits. There is no visible domain repetition pattern because I am also using\n//a modified version of domain repetition where some of the domains are \"disabled\" such that\n//they report the distance as if the neighbour domains are filled, but it is empty. this means\n//you can make an arbitrary percentage of domains empty, and therefore no holes will appear\n\n//see https://www.shadertoy.com/view/WsBBRw for the 2d case\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_domain(vec4 p, float scale, bool gated) {\n    float d = sphere(p, scale);\n    if (gated) {\n        d = max(d, sphere(p, scale * 0.5));\n        d = max(d, sphere(p, scale * 0.25));\n    }\n    return d;\n}\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nint pittingtype;\nfloat scene(vec3 p) {\n    float sphere = length(p)-1.;\n    float cut = p.z;\n    \n    float top = sphere;\n    float last = sphere;\n    for (int i = 0; i < 5; i++) { //5 octaves of noise\n        //random rotations\n        p = erot(p, normalize(vec3(1,2,3)), .2);\n        p = erot(p, normalize(vec3(1,3,2)), .51);\n\n    \tfloat scale = .5/pow(float(i+1),1.5);\n\n        //create 4d coordinates where the first coordinate is the distance to the SDF\n    \tvec4 p4d = vec4(last,p);\n\n        //domain repetition *only* along the yzw axes\n    \tvec3 id = floor(p4d.yzw/scale);\n    \tp4d.yzw = (fract(p4d.yzw/scale)-0.5)*scale;\n\n        //disable 50% of spheres. see https://www.shadertoy.com/view/WsSBRD for another example of this technique\n    \tbool gated = hash(id.x, hash(id.y, id.z)) > 0.;\n        float holes = gated_domain(p4d, scale, gated);\n        top = -smin(-top, holes, 0.04*sqrt(scale));\n\n        if (pittingtype == 0) last = holes; //add pitting to existing pits\n        if (pittingtype == 1) last = top; //add pitting everywhere\n        if (pittingtype == 2) last = sphere; //add pitting only to original surface\n    }\n    \n    return max(top,-cut);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    pittingtype = int(iTime)%3;\n\n    vec3 cam = normalize(vec3(2,uv));\n    vec3 init = vec3(-5,0,0);\n\n   \tfloat yrot = 0.5;\n    float zrot = 4.5;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    } else {\n        yrot += cos(iTime)*.2;\n        zrot += sin(iTime)*.2;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init; \n    bool hit = false;\n    //raymarch\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist*.9;\n        if (distance(p,init) > 10.) break;\n    }\n    //shading\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    ao *= smoothstep(-.2,.2,scene(p+n*.2));\n    ao*=ao;\n    float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n    float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    float fresnel = 1.-abs(dot(cam,n))*.98;\n    vec3 col = abs(erot(vec3(0.1,0.04,0.03),r,0.05))*diff*diff*ao + pow(spec, 10.)*fresnel*ao;\n    fragColor.xyz = sqrt((hit ? col : vec3(0.))*2.) + abs(hash(iTime, hash(uv.x,uv.y)))*.04;\n}"], ["// The MIT License\n// Copyright \u00a9 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical computation of the exact bounding box for a cubic bezier segment\n//\n// See http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 b = p0 + (p2-p0)*0.5;\n    vec3 c = p1 - b;\n    vec3 q = p2 - p0;\n    vec3 w = vec3( dot(q,q), 4.0*dot(c,q), 2.0*dot(c,c) );\n    vec3 e = sqrt(vec3(w.y*w.y-4.0*w.x*w.z, w.z, 0.0));\n    vec3 s = vec3(2.0*w.x, 2.0*w.y, 1.0);\n    vec3 r = vec3( clamp((-w.y-e)/s,0.0,1.0), clamp((-w.y+e)/s,0.0,1.0), 0.5 );\n    vec3 t = clamp(r,0.0,1.0);\n    vec3 a = p0 + t.x*q + t.y*c;\n    vec3 b = p0 + t.z*q + t.y*c;\n    return bound3( min(a,b), max(a,b) );\n}\n\n\n// ray-ellipse intersection\nfloat iEllipse( in vec3 ro, in vec3 rd,         // ray: origin, direction\n             in vec3 c, in vec3 u, in vec3 v )  // disk: center, 1st axis, 2nd axis\n{\n\tvec3 q = ro - c;\n\tvec3 r = vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), rd ),\n\t\tdot( cross(v,q), rd ) ) / \n        dot( cross(v,u), rd );\n    \n    return (dot(r.yz,r.yz)<1.0) ? r.x : -1.0;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n    \n}\n\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in float width)\n{\n    const int kNum = 50;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        vec3 b = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n    \n    \n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // bezier animation\n    float time = iTime*0.5;\n    vec3 p0 = vec3(0.8,0.6,0.8)*sin( time*0.7 + vec3(3.0,1.0,2.0) );\n    vec3 p1 = vec3(0.8,0.6,0.8)*sin( time*1.1 + vec3(0.0,6.0,1.0) );\n    vec3 p2 = vec3(0.8,0.6,0.8)*sin( time*1.3 + vec3(4.0,2.0,3.0) );\n\tfloat thickness = 0.01;\n        \n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace bezier\n    float t = iBezier( ro, rd, p0, p1, p2, thickness);\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3);\n\t}\n\n    // compute bounding box for bezier\n    bound3 bbox = BezierAABB( p0, p1, p2 );\n    bbox.mMin -= thickness;\n    bbox.mMax += thickness;\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//antialising\n#define AA_SAMPLES 1\n//percentage of domains filled\n#define DENSITY 0.35\n\n//returns a vector pointing in the direction of the closest neighbouring cell\nvec3 quadrant(vec3 p) {\n    vec3 q = floor(p);\n    vec3 f = fract(p);\n    vec3 d = f - 0.5;\n    vec3 g = sign(d);\n    vec3 h = abs(d);\n    vec3 i = step(h.yzx, h.xyz);\n    vec3 j = step(h.zxy, h.xyz);\n    vec3 k = i * j;\n    vec3 l = (1.0 - i) * j;\n    vec3 m = k * g + l * (1.0 - g);\n    vec3 n = (1.0 - k) * g + l * (1.0 - g);\n    return vec3(q.x + m.x, q.y + m.y, q.z + m.z);\n}\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\nbool domain_enabled(vec3 id) {\n    //repeat random number along z axis so every active cell has at least one active neighbour\n    id.z = floor(id.z/2.); \n    return hash(id.x, hash(id.y, id.z)) < DENSITY;\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat ball;\nfloat scene(vec3 p) {\n    float scale = 5.;\n    vec3 id = floor(p/scale);\n    p = (fract(p/scale)-.5)*scale;\n    if (!domain_enabled(id)) {\n        //return distance to sphere in adjacent domain\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= scale;\n        return length(p)-1.;\n    }\n    float dist = length(p)-1.;\n    ball = dist;\n    vec3 quad = quadrant(p);\n    if (domain_enabled(id+quad)) {\n        //add pipe\n        dist = min(dist, linedist(p, vec3(0), quad*scale)-.2);\n    }\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat smoothstairs(float p, float scale) {\n    p *= scale;\n    p = smoothstep(0.9, 1., fract(p)) + floor(p);\n    return p/scale;\n}\n\nconst float PI = acos(-1.);\nvec3 pixel_color(vec2 uv) {\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tvec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(iTime,0,0);\n\n    float yrot = 0.;\n    float zrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += smoothstep(-PI/2., PI/2., -4.*mouse.y)*PI-PI/2.;\n        zrot += 4.*mouse.x;\n    } else {\n        yrot += cos(iTime*.2)*.6;\n        zrot += sin(iTime*.2)*.6;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    bool triggered = false;\n    bool outline = false;\n    bool type = false;\n    float dist;\n    //ray marching\n    for (int i = 0; i < 150 && !hit; i++) {\n        dist = scene(p);\n        float outline_radius = 0.1*sqrt(distance(p,init))/3.;\n        if (dist < outline_radius*.9 && !triggered) {\n            triggered = true;\n            type = dist == ball;\n        }\n        if (triggered) {\n            float line = (outline_radius-dist);\n            outline = line < dist || type != (dist == ball);\n\t\t\tdist = min(line, dist);\n        }\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>90.) break;\n    }\n    if (!hit) return vec3(0.4);\n    bool is_ball = dist == ball;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n \t\n    //add outline to sharp edges\n    outline = outline || scene(p+n*.1) < 0.09;\n    float fog = smoothstep(80.,60., distance(p,init));\n\n    //shading\n    float ao = smoothstep(.0, .5, scene(p+n*.5));\n    float fact = ao*length(sin(r*vec3(3.,-2.,2.))*.5+.5)/sqrt(3.);\n    float lod = smoothstep(90.,50.,distance(p,init))*5.; //make the shading simpler in the distance\n    fact = smoothstairs(fact, lod)+.1;\n    vec3 ballcol = abs(erot(srgb(0.6,0.7,0.8), normalize(cos(p*.5)), .3));\n    vec3 matcol = is_ball ? ballcol : srgb(0.6,0.65,0.7);\n    vec3 col = matcol*fact + mix(vec3(1), matcol, .4)*pow(fact, 10.)*1.5;\n    col *= smoothstep(0.,.25,abs(dot(cam, n)));\n    col = mix(vec3(.6), outline ? vec3(0.) : col, fog);\n    if (isnan(length(col))) return vec3(.6); //i have no idea where this nan is coming from\n    return col;\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    for (int i = 0; i < AA_SAMPLES; i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n        fragColor += vec4(pixel_color(uv2), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is the technique in https://www.shadertoy.com/view/td2fRD\n//but a 3d SDF mapping to a 2d sdf, instead of a 4d to a 3d.\n//should be easier to understand.\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_domain(vec3 p, float scale, bool gated) {\n    float d = sphere(p, scale);\n    if (gated) {\n        d = max(d, sphere(p, scale * 0.5));\n        d = max(d, sphere(p, scale * 0.25));\n    }\n    return d;\n}\n\nfloat scene3d(vec3 p) {\n    float scale = 2.;\n    vec2 id = floor(p.xy*scale);\n    p.xy = (fract(p.xy*scale)-0.5)/scale;\n    bool gated = hash(id.x, id.y) > 0.;\n    return gated_domain(p, scale, gated);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nint pittingtype;\nfloat scene2d(vec2 p) {\n    float circle = length(p)-1.;\n\n    float top = circle;\n    float last = circle;\n    for (int i = 0; i < 5; i++) {\n        float scale = 1./float(i+1);\n        //map 3d coordinates to 4d using the distance to the SDF\n    \tvec3 p3d = vec3(p, last)/scale;\n\t\t//cut out mapped spheres from SDF\n        float holes = scene3d(p3d)*scale;\n    \ttop = max(top, -holes);\n\n        if (pittingtype == 0) last = holes; //add pitting to existing pits\n        if (pittingtype == 1) last = top; //add pitting everywhere\n        if (pittingtype == 2) last = circle; //add pitting only to original surface\n    }\n    return top;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene3d(p)-vec3(scene3d(k[0]),scene3d(k[1]),scene3d(k[2])));\n}\n\nvec3 render3d(vec2 uv) {\n    \n    vec3 cam = normalize(vec3(2,uv));\n    vec3 init = vec3(-5,0,2);\n    \n    cam = erot(cam,vec3(0,1,0), .3);\n    cam = erot(cam,vec3(0,0,1), iTime*.1);\n    \n    vec3 p = init; \n    bool hit = false;\n    //raymarch\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene3d(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist*.9;\n        if (distance(p,init) > 100.) break;\n    }\n    //shading\n    vec3 n = norm(p);\n    return hit ? sin(n)*.5+.5 : vec3(0.1);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvec3 render2d(vec2 uv, vec2 mouse) {\n    uv *= 3.; mouse *= 3.;\n    vec3 col = shadeDistance(scene2d(uv));\n    \n    float mousedist = scene2d(mouse);\n    if (iMouse.z > 0.) {\n        col *= antialias(distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    pittingtype = int(iTime)%3;\n    \n    if (uv.x > .0) {\n        fragColor.xyz = render3d(uv-vec2(0.45,0.));\n    } else {\n        fragColor.xyz = render2d(uv+vec2(0.45,0.), mouse+vec2(0.45,0.));\n    }\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec3 b) {\n    return vec3(a.x / max(b.x, 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000// incomplete generation!\n\nfloat antiderivative(float x, vec3 origin, vec3 dir) {\n    //antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3(1,1,0,-1,0,1,0,-1,-1);\n    mat3 B = mat3(1,1,0,1,0,1,0,1,1);\n    vec3 Q = origin + dir*x;\n    vec3 integral = div(sin(A*Q),(A*dir)) - div(sin(B*Q),(B*dir)) + div((2.*Q-sin(2.*Q)),(4.*dir));\n    return dot(integral, vec3(1));\n}\n\nfloat lineintegral(vec3 a, vec3 b) {\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    return antiderivative(len,a,dir) - antiderivative(0.,a,dir);\n}\n\nfloat scene(vec3 p) {\n    p = asin(sin(p+1.));\n    return length(p)-1.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) {\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n\tvec3 init = vec3(-4,0,0);\n    cam = erot(cam, vec3(0,1,0), .2);\n    init = erot(init, vec3(0,1,0), .2);\n    cam = erot(cam, vec3(0,0,1), iTime/5.);\n    init = erot(init, vec3(0,0,1), iTime/5.);\n    init.x += iTime;\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist * cam;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 a = p; vec3 b = init; float scale = 1.;\n    float fog = lineintegral(a,b)/20.;\n    \n    if (uv.x > 0.) {\n    \t//sum up multiple different versions of the fog\n    \tfor (int i = 0; i < 50; i++) {\n            //random rotation\n        \tvec3 ax = normalize(tan(hash3(float(i),14353.)));\n        \tfloat ro = hash(float(i),66123.)*10.;\n        \ta = erot(a,ax,ro);\n        \tb = erot(b,ax,ro);\n        \tfog += lineintegral(a*scale,b*scale)/sqrt(scale);\n       \t\tscale *= 1.06;\n    \t}\n\t\tfog /= 2500.;\n\t}\n\n    fragColor = sqrt(vec4(fog));\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)\u222bcos(t)dt with t \u2208 (x-\u00bdw, x+\u00bdw)\n// = [sin(x+\u00bdw) - sin(x-\u00bdw)]/w\n// = cos(x)\u00b7sin(\u00bdw)/(\u00bdw)\n//\n// Can approximate smoothstep(2\u03c0,0,w) \u2248 sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    return cos(x)*(1.0-step(abs(x),1.0));\n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/www/articles/palettes/palettes.htm)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.6,0.5,0.4);\n    col += 0.14*mcos(6.2832*t*  1.0+vec3(0.0,0.5,0.6));\n    col += 0.13*mcos(6.2832*t*  3.1+vec3(0.5,0.6,1.0));\n    col += 0.12*mcos(6.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.11*mcos(6.2832*t*  9.1+vec3(0.1,0.5,1.2));\n    col += 0.10*mcos(6.2832*t* 17.1+vec3(0.0,0.3,0.9));\n    col += 0.09*mcos(6.2832*t* 31.1+vec3(0.1,0.5,1.3));\n    col += 0.08*mcos(6.2832*t* 65.1+vec3(0.1,0.5,1.3));\n    col += 0.07*mcos(6.2832*t*131.1+vec3(0.3,0.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = 2.0*q/dot(q,q);\n\n    // animation\n    p.xy += 0.05*iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-th));\n    \n    // palette\n    if( q.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)\u222bcos(t)dt with t \u2208 (x-\u00bdw, x+\u00bdw)\n// = [sin(x+\u00bdw) - sin(x-\u00bdw)]/w\n// = cos(x)\u00b7sin(\u00bdw)/(\u00bdw)\n//\n// Can approximate smoothstep(2\u03c0,0,w) \u2248 sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/www/articles/palettes/palettes.htm)\nvec3 getColor( in float t )\n{\n    vec3 c = vec3(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        float f = float(i)/2.0;\n        c[i] = cos( 6.28318*(t*0.25+f) )*0.5+0.5;\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = 2.0*q/dot(q,q);\n\n    // animation\n    p.xy += 0.05*iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-th));\n    \n    // palette\n    if( q.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 1.0 );\n}"], ["// License CC0: Double Ended Truchet Experiment\n// Been looking at some double ended truchets by BigWings and Shane. \n// After some experiments I got something I felt was interesting enough to share.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nconst vec2 coords[8] = vec2[8](\n  0.5*vec2(-1.0, -0.5),\n  0.5*vec2(-1.0, +0.5),\n  0.5*vec2(-0.5, +1.0),\n  0.5*vec2(+0.5, +1.0),\n  0.5*vec2(+1.0, +0.5),\n  0.5*vec2(+1.0, -0.5),\n  0.5*vec2(+0.5, -1.0),\n  0.5*vec2(-0.5, -1.0)\n  );\n\nconst vec2 dcoords[8] = vec2[8](\n  vec2(+1.0, +0.0),\n  vec2(+1.0, +0.0),\n  vec2(+0.0, -1.0),\n  vec2(+0.0, -1.0),\n  vec2(-1.0, +0.0),\n  vec2(-1.0, +0.0),\n  vec2(+0.0, +1.0),\n  vec2(+0.0, +1.0)\n  );\n\nconst int noCorners = 105;\n// Using symmetries and reflections should be possible to reduce this \n//  array alot, but that is hard ;)\nconst int corners[105*8] = int[105*8](\n  0, 1, 2, 3, 4, 5, 6, 7, \n  0, 1, 2, 3, 4, 6, 5, 7, \n  0, 1, 2, 3, 4, 7, 5, 6, \n  0, 1, 2, 4, 3, 5, 6, 7, \n  0, 1, 2, 4, 3, 6, 5, 7, \n  0, 1, 2, 4, 3, 7, 5, 6, \n  0, 1, 2, 5, 3, 4, 6, 7, \n  0, 1, 2, 5, 3, 6, 4, 7, \n  0, 1, 2, 5, 3, 7, 4, 6, \n  0, 1, 2, 6, 3, 4, 5, 7, \n  0, 1, 2, 6, 3, 5, 4, 7, \n  0, 1, 2, 6, 3, 7, 4, 5, \n  0, 1, 2, 7, 3, 4, 5, 6, \n  0, 1, 2, 7, 3, 5, 4, 6, \n  0, 1, 2, 7, 3, 6, 4, 5, \n  0, 2, 1, 3, 4, 5, 6, 7, \n  0, 2, 1, 3, 4, 6, 5, 7, \n  0, 2, 1, 3, 4, 7, 5, 6, \n  0, 2, 1, 4, 3, 5, 6, 7, \n  0, 2, 1, 4, 3, 6, 5, 7, \n  0, 2, 1, 4, 3, 7, 5, 6, \n  0, 2, 1, 5, 3, 4, 6, 7, \n  0, 2, 1, 5, 3, 6, 4, 7, \n  0, 2, 1, 5, 3, 7, 4, 6, \n  0, 2, 1, 6, 3, 4, 5, 7, \n  0, 2, 1, 6, 3, 5, 4, 7, \n  0, 2, 1, 6, 3, 7, 4, 5, \n  0, 2, 1, 7, 3, 4, 5, 6, \n  0, 2, 1, 7, 3, 5, 4, 6, \n  0, 2, 1, 7, 3, 6, 4, 5, \n  0, 3, 1, 2, 4, 5, 6, 7, \n  0, 3, 1, 2, 4, 6, 5, 7, \n  0, 3, 1, 2, 4, 7, 5, 6, \n  0, 3, 1, 4, 2, 5, 6, 7, \n  0, 3, 1, 4, 2, 6, 5, 7, \n  0, 3, 1, 4, 2, 7, 5, 6, \n  0, 3, 1, 5, 2, 4, 6, 7, \n  0, 3, 1, 5, 2, 6, 4, 7, \n  0, 3, 1, 5, 2, 7, 4, 6, \n  0, 3, 1, 6, 2, 4, 5, 7, \n  0, 3, 1, 6, 2, 5, 4, 7, \n  0, 3, 1, 6, 2, 7, 4, 5, \n  0, 3, 1, 7, 2, 4, 5, 6, \n  0, 3, 1, 7, 2, 5, 4, 6, \n  0, 3, 1, 7, 2, 6, 4, 5, \n  0, 4, 1, 2, 3, 5, 6, 7, \n  0, 4, 1, 2, 3, 6, 5, 7, \n  0, 4, 1, 2, 3, 7, 5, 6, \n  0, 4, 1, 3, 2, 5, 6, 7, \n  0, 4, 1, 3, 2, 6, 5, 7, \n  0, 4, 1, 3, 2, 7, 5, 6, \n  0, 4, 1, 5, 2, 3, 6, 7, \n  0, 4, 1, 5, 2, 6, 3, 7, \n  0, 4, 1, 5, 2, 7, 3, 6, \n  0, 4, 1, 6, 2, 3, 5, 7, \n  0, 4, 1, 6, 2, 5, 3, 7, \n  0, 4, 1, 6, 2, 7, 3, 5, \n  0, 4, 1, 7, 2, 3, 5, 6, \n  0, 4, 1, 7, 2, 5, 3, 6, \n  0, 4, 1, 7, 2, 6, 3, 5, \n  0, 5, 1, 2, 3, 4, 6, 7, \n  0, 5, 1, 2, 3, 6, 4, 7, \n  0, 5, 1, 2, 3, 7, 4, 6, \n  0, 5, 1, 3, 2, 4, 6, 7, \n  0, 5, 1, 3, 2, 6, 4, 7, \n  0, 5, 1, 3, 2, 7, 4, 6, \n  0, 5, 1, 4, 2, 3, 6, 7, \n  0, 5, 1, 4, 2, 6, 3, 7, \n  0, 5, 1, 4, 2, 7, 3, 6, \n  0, 5, 1, 6, 2, 3, 4, 7, \n  0, 5, 1, 6, 2, 4, 3, 7, \n  0, 5, 1, 6, 2, 7, 3, 4, \n  0, 5, 1, 7, 2, 3, 4, 6, \n  0, 5, 1, 7, 2, 4, 3, 6, \n  0, 5, 1, 7, 2, 6, 3, 4, \n  0, 6, 1, 2, 3, 4, 5, 7, \n  0, 6, 1, 2, 3, 5, 4, 7, \n  0, 6, 1, 2, 3, 7, 4, 5, \n  0, 6, 1, 3, 2, 4, 5, 7, \n  0, 6, 1, 3, 2, 5, 4, 7, \n  0, 6, 1, 3, 2, 7, 4, 5, \n  0, 6, 1, 4, 2, 3, 5, 7, \n  0, 6, 1, 4, 2, 5, 3, 7, \n  0, 6, 1, 4, 2, 7, 3, 5, \n  0, 6, 1, 5, 2, 3, 4, 7, \n  0, 6, 1, 5, 2, 4, 3, 7, \n  0, 6, 1, 5, 2, 7, 3, 4, \n  0, 6, 1, 7, 2, 3, 4, 5, \n  0, 6, 1, 7, 2, 4, 3, 5, \n  0, 6, 1, 7, 2, 5, 3, 4, \n  0, 7, 1, 2, 3, 4, 5, 6, \n  0, 7, 1, 2, 3, 5, 4, 6, \n  0, 7, 1, 2, 3, 6, 4, 5, \n  0, 7, 1, 3, 2, 4, 5, 6, \n  0, 7, 1, 3, 2, 5, 4, 6, \n  0, 7, 1, 3, 2, 6, 4, 5, \n  0, 7, 1, 4, 2, 3, 5, 6, \n  0, 7, 1, 4, 2, 5, 3, 6, \n  0, 7, 1, 4, 2, 6, 3, 5, \n  0, 7, 1, 5, 2, 3, 4, 6, \n  0, 7, 1, 5, 2, 4, 3, 6, \n  0, 7, 1, 5, 2, 6, 3, 4, \n  0, 7, 1, 6, 2, 3, 4, 5, \n  0, 7, 1, 6, 2, 4, 3, 5, \n  0, 7, 1, 6, 2, 5, 3, 4\n  );\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    vec2 BC = C - B;\n    vec2 BA = A - B;\n    vec2 CA = A - C;\n    vec2 CB = B - C;\n    vec2 P = pos - A;\n    vec2 Q = pos - B;\n    vec2 R = pos - C;\n    float a = dot(BC, BC);\n    float b = dot(BA, BC);\n    float c = dot(BA, BA);\n    float d = dot(P, BC);\n    float e = dot(P, BA);\n    float f = dot(Q, BA);\n    float det = a * c - b * b;\n    float s = (c * d - b * f) / det;\n    float t = (a * f - b * e) / det;\n    return s * s * dot(AC, P) + 2.0 * s * t * dot(AC, Q) + t * t * dot(AC, R);\n}\n\nfloat bezier2(vec2 p, float f, vec2 off, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5+off;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 color(vec2 p, float s, float aa, vec3 col) {\n  p /= s;\n  vec2 cp = p;\n  vec2 cn = mod2_1(cp);\n  float rr = hash(cn);\n  int sel = int(float(noCorners)*rr);\n  int off = sel*8;\n  \n  const vec3 scol = vec3(0.25);\n  const vec3 bcol = vec3(1.0);\n  const float sw = 0.05;\n  \n  for (int i = 0; i < 4; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];    \n    int odd = min(c0, c1) & 1;\n    \n    float r = fract(rr*13.0*float(i+1));\n    \n    int l = abs(c0 - c1) + odd*8;\n    float f = 0.71;\n    vec2 off = vec2(0.0, 0.0);\n\n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n    \n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n\n    vec2 dp = mix(dp0, dp1, r);\n\n    switch(l) {\n    // Mid shape\n    case 1:\n    case 15:\n      f = mix(0.75, 2.5, r);\n      break;\n    // L - shape\n    case 2:\n    case 6:\n    case 10:\n    case 14:\n      f = r > 0.5 ? 0.35 : 1.25;\n      break;\n    // Big corner shape\n    case 3:\n    case 13:\n      f = mix(0.5, 1.0, r);\n      break;\n    // Cross line\n    case 4:\n    case 12:\n      f = r>0.5 ? 0.5 : 1.5;\n      break;\n    // Straight line\n    case 5:\n    case 11:\n      f = 1.5;\n      off = (r > 0.5 ? 1.0 : -1.0)*0.15*vec2(dp0.y, -dp0.x);\n      break;\n    // Small corner shape\n    case 7:\n    case 9:\n      f = r>0.5 ? 0.75 : 2.75;\n      break;\n    default:\n      f = 0.5;\n      break;\n    }\n    \n    float dd = (bezier2(cp, f, off, p0, dp0, p1, dp1)-0.025)*s;\n    \n    vec4 sc = vec4(scol, smoothstep(-sw, sw, -dd));\n    vec4 bc = vec4(bcol, smoothstep(-aa, aa, -dd));\n\n    col = alphaBlend(col, sc);\n    col = alphaBlend(col, bc);\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  p += vec2(0.5, sqrt(0.5))*TIME*0.1;\n \n  float aa = 2.0/RESOLUTION.y;\n  float s = 0.25;\n\n  vec3 col = vec3(0.1);\n  col = color(p, s, aa, col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0 / (1.0 + e * R * R);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    float k = 0.0;\n    if (e > 0.0)\n    {\n        k = (a - b) / (e * R);\n    }\n    return k;\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * exp(-d * d / (2.0 * R * R));\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 bc = c - b;\n    float ab2 = dot(ab, ab);\n    float ac2 = dot(ac, ac);\n    float bc2 = dot(bc, bc);\n    float abbc = dot(ab, bc);\n    float abac = dot(ab, ac);\n    float bcac = dot(bc, ac);\n    float ab2bc2 = ab2 * bc2;\n    float ab2ac2 = ab2 * ac2;\n    float bc2ac2 = bc2 * ac2;\n    float abbc2 = abbc * abbc;\n    float abac2 = abac * abac;\n    float bcac2 = bcac * bcac;\n    float ab2bc2ac2 = ab2bc2 + ab2ac2 + bc2ac2;\n    float abbc2ac2 = abbc2 + abac2 + bcac2;\n    float abbc2ac2_ab2bc2ac2 = abbc2ac2 / ab2bc2ac2;\n    float abbc2ac2_ab2bc2ac2_2 = abbc2ac2_ab2bc2ac2 * 2.0;\n    float abbc2ac2_ab2bc2ac2_2_ab2 = abbc2ac2_ab2bc2ac2_2 * ab2;\n    float abbc2ac2_ab2bc2ac2_2_ab2_bc2 = abbc2ac2_ab2bc2ac2_2_ab2 * bc2;\n    float abbc2ac2_ab2bc2ac2_2_ab2_bc2_ab2 = abbc2ac2_ab2bc2ac2_2_ab2_bc2 * ab2;\n    float abbc// incomplete generation!\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = 1000.0;\n    float t = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        float r = float(i) * 0.1 + 0.1;\n        float s = 0.0;\n        for (int j = 0; j < 10; j++)\n        {\n            float a = float(j) * 0.1 + 0.1;\n            float b = float(j) * 0.1 + 0.1;\n            float c = float(j) * 0.1 + 0.1;\n            float e = float(j) * 0.1 + 0.1;\n            float f = float(j) * 0.1 + 0.1;\n            float g = float(j) * 0.1 + 0.1;\n            float h = float(j) * 0.1 + 0.1;\n            float k = float(j) * 0.1 + 0.1;\n            float l = float(j) * 0.1 + 0.1;\n            float m = float(j) * 0.1 + 0.1;\n            float n = float(j) * 0.1 + 0.1;\n            float o = float(j) * 0.1 + 0.1;\n            float p = float(j) * 0.1 + 0.1;\n            float q = float(j) * 0.1 + 0.1;\n            float w = float(j) * 0.1 + 0.1;\n            float x = float(j) * 0.1 + 0.1;\n            float y = float(j) * 0.1 + 0.1;\n            float z = float(j) * 0.1 + 0.1;\n            float v = float(j) * 0.1 + 0.1;\n            float u = float(j) * 0.1 + 0.1;\n            float t// incomplete generation!\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    vec3 ab = b - a;\n    return length(ab) * (1.0 + 0.5 * dot(ab, ab));\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        Object(p + e.xyy) - Object(p - e.xyy),\n        Object(p + e.yxy) - Object(p - e.yxy),\n        Object(p + e.yyx) - Object(p - e.yyx)\n    ));\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = 0.0;\n    float r = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float m = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float c = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    vec3 p = vec3(0.0);\n    vec3 q = vec3(0.0);\n    vec3 n = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 m1 = vec3(0.0);\n    vec3 m2 = vec3(0.0);\n    vec3 m3 = vec3(0.0);\n    vec3 m4 = vec3(0.0);\n    vec3 m5 = vec3(0.0);\n    vec3 m6 = vec3(0.0);\n    vec3 m7 = vec3(0.0);\n    vec3 m8 = vec3(0.0);\n    vec3 m9 = vec3(0.0);\n    vec3 m10 = vec3(0.0);\n    vec3 m11 = vec3(0.0);\n    vec3 m12 = vec3(0.0);\n    vec3 m13 = vec3(0.0);\n    vec3 m14 = vec3(0.0);\n    vec3 m15 = vec3(0.0);\n    vec3 m16 = vec3(0.0);\n    vec3 m17 = vec3(0.0);\n    vec3 m18 = vec// incomplete generation!\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + t * u;\n        float d = Distance(p);\n        if (d < EPSILON)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Gu\u00e9rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    return vec3(0.0);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n//------------------------------------------------------------------\n#define March_Quality 32\n#define Shadow_Quality 4\n#define AO_Quality 8\n#define Lighting 1\n#define Epsilon 0.00001\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opB( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec3 opRepLim(  vec3 p,  float c, vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return ( q );\n}\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    pos = opRepLim(pos,3.,vec3(1,1,1));\n    pos.y +=0.2;\n    pos.y *=0.9;\n    vec2 belly = vec2( sdSphere(    pos-vec3(.0,0., 0.2), 0.5 ), 11  );\n\n    vec2 brownBelly = vec2(sdSphere(    pos-vec3(.0,0., 0.0), 0.6), 12  );\n    vec2 brownHead = vec2(sdSphere(    pos-vec3(.0,0.6, 0.0), 0.4), 12  );\n    vec3 eyePos = pos;\n    eyePos.x *=1.3;\n    vec2 whiteEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.65, 0.25),0.15), 11  );\n    vec2 whiteEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.65, 0.25), 0.15), 11  );\n    vec2 brownEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.73, 0.22),0.15), 12  );\n    vec2 brownEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.73, 0.22), 0.15), 12  );\n\tvec2 pupilEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.65, 0.37),0.05), 13  );\n    vec2 pupilEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.65, 0.37), 0.05), 13  );\n\t\n    vec3 furPos = pos;\n    furPos.x *=0.5;\n    \n    vec2 mouthFur = vec2(sdSphere( furPos-vec3(0.,0.44,0.35),0.11),11);\n    vec2 mouthFur2 = vec2(sdSphere( furPos-vec3(0.,0.5,0.35),0.09),11);\n    vec2 mouthFur3 = vec2(sdSphere( furPos-vec3(0.,0.56,0.42),0.04),11);\n    vec3 earPos = pos;\n    earPos.z *=1.6;\n    earPos.x *=1.7;\n    earPos.y *=0.5;\n    vec2 brownEarL = vec2(sdSphere(earPos-vec3(0.27,0.5,0.),0.25),12);\n\tvec2 brownEarR = vec2(sdSphere(earPos-vec3(-0.27,0.5,0.),0.25),12);\n    vec2 redEarL = vec2(sdSphere(earPos-vec3(0.27,0.5,0.1),0.18),14);\n\tvec2 redEarR = vec2(sdSphere(earPos-vec3(-0.27,0.5,0.1),0.18),14);\n    vec3 mouthPos = pos;\n\tmouthPos.y -= 0.5;\n    mouthPos.z +=0.14;\n    vec2 mouthSub = vec2(sdBox(mouthPos-vec3(0,-0.05,.5),vec3(0.1,0.1,0.1)),15);\n    vec2 redMouth = vec2(sdSphere(mouthPos-vec3(0.,0.,.5),0.1),15);\n\tredMouth = opB(redMouth,mouthSub);\n    \n    vec2 teeth = opU(vec2(sdBox(mouthPos-vec3(0.035,0.031,0.59),vec3(0.025,0.03,0.005)),11),vec2(sdBox(mouthPos-vec3(-0.035,0.031,0.59),vec3(0.025,0.03,0.005)),11));\n    \n    vec3 feetPos =pos;\n    feetPos.y += 0.4;\n    feetPos.x *=0.7;\n    \n    vec2 leftFoot = vec2(sdSphere(feetPos-vec3(-0.30,0,0),0.25),12);\n    vec2 rightFoot = vec2(sdSphere(feetPos-vec3(0.30,0,0),0.25),12);\n    \n    feetPos.y *=1.1;\n    vec2 leftFootWhite = vec2(sdSphere(feetPos-vec3(-0.40,-0.05,0),0.25),11);\n    vec2 rightFootWhite = vec2(sdSphere(feetPos-vec3(0.40,-0.05,0),0.25),11);\n    vec2 feetWhite = opU(leftFootWhite,rightFootWhite);\n    vec2 feet = opU(leftFoot,rightFoot);\n    feet = opU(feetWhite,feet);\n    \n    \n    vec2 rightArm = vec2(sdCylinder(pos-vec3(0.5,0.25,0.),vec3(0,0,0),vec3(0.5,0,0),0.1),12);      \n    vec2 leftArm = vec2(sdCylinder(pos-vec3(-0.5,0.25,0.),vec3(0,0,0),vec3(-0.5,0,0),0.1),12);\n\tvec2 leftHand = vec2(sdSphere(pos-vec3(-1.0,0.25,0),0.15),11);\n    vec2 rightHand = vec2(sdSphere(pos-vec3(1.0,0.25,0),0.15),11);\n    \n    vec2 res =opU(brownBelly,belly);\n    res = opU(res,brownHead);\n    res = opU(res,whiteEyeL);\n    res = opU(res,whiteEyeR);\n    res = opU(res,brownEyeR);\n\tres = opU(res,brownEyeL);\n    res = opU(res,pupilEyeR);\n\tres = opU(res,pupilEyeL);\n    res = opU(res,mouthFur);\n    res = opU(res,mouthFur2);\n    res = opU(res,mouthFur3);\n    res = opU(res,brownEarL);\n    res = opU(res,brownEarR);\n    res = opU(res,redEarL);\n    res = opU(res,redEarR);\n    res = opU(res,redMouth);\n    res = opU(res,teeth);\n\tres = opU(res,feet);\n    res = opU(res,rightArm);\n    res = opU(res,leftArm);\n    res = opU(res,leftHand);\n    res = opU(res,rightHand);\n\n    return res;\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n   \n    //else return res;\n    \n    // raymarch primitives   \n\n        float t = tmin;\n        for( int i=0; i<March_Quality && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(Epsilon*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    \n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<Shadow_Quality; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<AO_Quality; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if(m>=10.){\n        if(m<=11.){\n         col = vec3(1,1,1);   \n        }else if(m<=12.){\n         col = vec3(0.45,0.4,0.4);   \n        }else if(m<=13.){\n            col = vec3(0.,0.,0.);\n        }else if(m<=14.){\n            col = vec3(0.85,0.54,0.50);\n        \n        }else if(m<=15.){\n            col = vec3(0.75,0.47,0.63);\n        }\n    \n  \n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n        \n        \n            ks = 0.4;\n        }\n        if(Lighting ==1){\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(1.5, 0.8, 0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n        }\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0., -0., -0. );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.1);\n\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.45) );\n\n        tot += col;\n\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// Copyright \u00a9 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.141592653;\nconst float PI2 = 2.0 * PI;\n\n// square\nconst int N = 4;\n\n// the circumradius of polygon\nconst float R_POLY = 0.4;\n\nconst float SCREW_THICKNESS = 0.02;\n\n// the half of thickness of polygon edges\nconst float THICKNESS = 0.025;\n\n// Good Colors!!\nconst vec3 COLOR[N] = vec3[](\n    vec3(226.0, 133.0, 27.0) / 255.0,\n    vec3(126.0, 107.0, 152.0) / 255.0,\n    vec3(238.0, 200.0, 80.0) / 255.0,\n    vec3(136.0, 175.0, 34.0) / 255.0\n);\n\n// the radius of the vertex of square\nconst float R_DOT = 0.04;\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / resolution;\n}\n\n// Creates vertices of polygon\nvec2[N] createVertex() {\n    vec2 vertex[N];\n    for (int i = 0; i < N; i++) {\n        float theta = float(i) / float(N) * PI2;\n        vertex[i] = vec2(cos(theta), sin(theta)) * R_POLY;\n    }\n    return vertex;\n}\n\nfloat get_angle(in vec2 uv) {\n    float theta = acos(uv.x / length(uv));\n    if (uv.y < 0.0) theta = 2.0 * PI - theta;\n    return theta;\n}\n\nfloat torus_distance(in float x, in float y) {\n    float a = abs(x - y);\n    float b = abs(PI2 + x - y);\n    float c = abs(x - y - PI2);\n    return min(a, min(b, c));\n}\n\nvec4 renderScrew(in vec2 uv) {\n    float len = length(uv);\n    float theta = get_angle(uv);\n    float c = 0.0;\n    int idx = 0;\n    for (int i = 0; i < N; i++) {\n        if (len < R_POLY) continue;\n        float delta = float(i) / float(N);\n        float phase = fract((iTime - PI2 * len + PI2 * delta) / PI2) * PI2;\n        float dist = smoothstep(0.0, 1.0, (torus_distance(phase, theta) / PI2) / SCREW_THICKNESS);\n        if (c < 1.0 - dist * dist * dist) {\n            c = 1.0 - dist * dist * dist;\n            idx = i % N;\n        }\n    }\n    return vec4(c * COLOR[idx], 1.0);    \n}\n\nvec4 renderSquare(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    float plus = abs(uv.x + uv.y);\n    float minus = abs(uv.x - uv.y);\n    if (plus < R_POLY - THICKNESS && minus < R_POLY - THICKNESS)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else if (plus < R_POLY + THICKNESS && minus < R_POLY + THICKNESS) {\n        float k = 1.0 - abs(plus - R_POLY) / THICKNESS;\n        k = max(k, 1.0 - abs(minus - R_POLY) / THICKNESS);\n        k = 1.0 - pow(1.0 - k, 5.0);\n        vec3 col = vec3(0.0);\n        for (int i = 0; i < N; i++) {\n            float c = distance(vertex[i], uv) / R_POLY;\n            c = smoothstep(0.0, 1.0, c);\n            c = 1.0 - pow(c, 3.0);\n            col += c * COLOR[i] * k;\n        }\n        fragColor = vec4(col, 1.0);\n    }\n    return fragColor;\n}\n\nvec4 renderVertices(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    for (int i = 0; i < N; i++) {\n        if (distance(uv, vertex[i]) < R_DOT) {\n            float c = distance(uv, vertex[i]) / R_DOT;\n            c = 1.0 - pow(c, 5.0);\n            fragColor = vec4(COLOR[i] * c, 1.0);\n        }\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uv_coord(fragCoord);\n    vec2 vertex[N] = createVertex();\n    fragColor = renderScrew(uv);\n    fragColor = renderSquare(fragColor, uv, vertex);\n    fragColor = renderVertices(fragColor, uv, vertex);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and analytic gradient to an isosceles\n// triangle. More accurate than central differences and\n// faster to compute than automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    vec2  a = vec2(q.x,q.y-q.x);\n    vec2  b = vec2(q.x,q.y+q.x);\n    vec2  c = vec2(0.0,0.0);\n    vec2  d = vec2(p.x,p.y);\n    vec2  e = vec2(p.x,p.y);\n    vec2  f = vec2(p.x,p.y);\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p1 = 0.0;\n    float q1 = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a1 = 0.0;\n    float b1 = 0.0;\n    float c1 = 0.0;\n    float d1 = 0.0;\n    float e1 = 0.0;\n    float f1 = 0.0;\n    float g1 = 0.0;\n    float h1 = 0.0;\n    float i1 =// incomplete generation!\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        p.y -= 0.3;\n        // size\n        vec2 si = vec2(0.5,-0.5) + vec2(0.3,-0.3)*cos( iTime + vec2(0.0,1.57) + 0.0 );\n\n        // sdf(p) and gradient(sdf(p))\n        vec3 dg = sdgTriangleIsosceles(p,si);\n        float d = dg.x;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n         vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a Vesica. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d)\n{\n    float a = r*r - d*d;\n    float b = 2.0*r*d;\n    float c = r*r + d*d;\n    float x = sqrt(a*a + b*b);\n    float y = sqrt(a*a - b*b);\n    float z = sqrt(c*c - b*b);\n    float xy = sqrt(x*x + y*y);\n    float xz = sqrt(x*x - z*z);\n    float xyz = sqrt(xy*xy + xz*xz);\n    float xyz2 = sqrt(xy*xy - xz*xz);\n    float xyz3 = sqrt(xy*xy + xz*xz + 1.0);\n    float xyz4 = sqrt(xy*xy - xz*xz + 1.0);\n    float xyz5 = sqrt(xy*xy + xz*xz - 1.0);\n    float xyz6 = sqrt(xy*xy - xz*xz - 1.0);\n    float xyz7 = sqrt(xy*xy + xz*xz + 2.0);\n    float xyz8 = sqrt(xy*xy - xz*xz + 2.0);\n    float xyz9 = sqrt(xy*xy + xz*xz - 2.0);\n    float xyz10 = sqrt(xy*xy - xz*xz - 2.0);\n    float xyz11 = sqrt(xy*xy + xz*xz + 3.0);\n    float xyz12 = sqrt(xy*xy - xz*xz + 3.0);\n    float xyz13 = sqrt(xy*xy + xz*xz - 3.0);\n    float xyz// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // animate\n    float time = iTime;\n    float r1 = 0.5*cos(time+12.0);\n    float r2 = 0.2*sin(time*1.4);\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgVesica( p, 0.7, r1 );\n    float d = dg.x + r2;\n    vec2  g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.7*exp(-8.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a pie. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p-c;\n    float a = atan(q.y,q.x);\n    float k = a/6.28318530718;\n    k = abs(abs(k)-.5);\n    k = clamp( k, 0.0, 1.0 );\n    float s = sign(q.x*c.y-q.y*c.x);\n    float d = length(q);\n    float d2 = length(vec2(d,k-0.5)*vec2(1.0,2.0));\n    return vec3( d2-r, a, s );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        float t =            3.14*(0.5+0.5*cos(iTime*0.52));\n        vec2  w = vec2(0.50,0.25)*(0.5+0.5*cos(iTime*vec2(1.1,1.3)+vec2(0.0,2.0)));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgPie(p,vec2(sin(t),cos(t)), 0.65);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a triangle. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 v[3] )\n{\n    vec2  e[3] = vec2[3](v[0]-v[1], v[1]-v[2], v[2]-v[0]);\n    vec2  n[3] = vec2[3](normalize(vec2(-e[0].y,e[0].x)),\n                         normalize(vec2(-e[1].y,e[1].x)),\n                         normalize(vec2(-e[2].y,e[2].x)));\n    vec2  d[3] = vec2[3](dot(n[0],v[0]), dot(n[1],v[1]), dot(n[2],v[2]));\n    vec2  w[3] = vec2[3](dot(n[0],p) - d[0],\n                         dot(n[1],p) - d[1],\n                         dot(n[2],p) - d[2]);\n    vec2  q[3] = vec2[3](dot(e[0],w[1]),\n                         dot(e[1],w[2]),\n                         dot(e[2],w[0]));\n    vec2  a[3] = vec2[3](dot(w[0],w[0]),\n                         dot(w[1],w[1]),\n                         dot(w[2],w[2]));\n    vec2  b[3] = vec2[3](dot(w[0],q[0]),\n                         dot(w[1],q[1]),\n                         dot(w[2],q[2// incomplete generation!\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n        vec2 v[3] = vec2[3](\n            vec2(-0.8,-0.3) + 0.5*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n            vec2( 0.8,-0.3) + 0.5*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n            vec2( 0.0, 0.3) + 0.5*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ) );\n\n        // corner radious\n        float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgTriangle(p,v);\n        float d = dg.x-ra;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n//////////////////////////////////////////////////////////////////////////////////////////////\n// Some useful functions\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 2\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nfloat PI = 3.1415926535;\nvec3 MoonDirection = normalize(vec3(-0.5,0.4,-0.3));\nvec3 MoonColor = vec3(0.6,0.7,1.2);\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rot(float r){\n    return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nvec4 dist(vec3 p){\n    //p.z *= 0.7;\n    p.y -= 0.3;\n\tfloat d = 0.009;\n    float no = ridgedMF(p.xz+0.3*snoise(p.xz+0.1*iTime));\n    vec3 col = vec3(1,1,1)*0.02*exp(-no*3.);\n    float thredy = 0.5;\n    float thx = p.y-thredy;\n    vec3 highems = vec3(1.3,1.0,1.0)*max(thx*8.0*exp(-3.5*vec3(2.,1.2,1.5)*thx),0.);\n    col *= highems;\n    return vec4(col,d);\n}\n\nvec4 ground(vec3 p){\n    p.y -= 0.3;\n    p.x -= -0.;\n    float d = p.y - smoothstep(0.0,1.0,length(p.xz-vec2(-0.4,0.))*1.)*0.23*ridgedMF(vec2(0.9,1.)*(p.xz-vec2(-0.1,0.02*iTime)));\n    //d = max(d,-(length(p-vec3(-0.4,0.65,-0.6))-0.8));\n    vec3 col = vec3(0);\n    return vec4(col,d);\n}\n\nvec3 getnormal(vec3 p)\n{\n\tconst vec2 e = vec2(0.5773,-0.5773)*0.0001;\n\tvec3 nor = normalize( e.xyy*ground(p+e.xyy).w +\n \t\te.yyx*ground(p+e.yyx).w + e.yxy*ground(p+e.yxy).w + e.xxx*ground(p+e.xxx).w);\n\tnor = normalize(vec3(nor));\n\treturn nor ;\n}\n\n\nvec3 star(vec2 s){\n    vec3 c = vec3(snoise(s));\n    c = pow(c,vec3(5.));\n    c = clamp(7.*clamp(c-0.7,0.0,1.0),0.0,1000.0);\n  \n    return c;\n}\n\nvec3 background(vec3 rd){\n    vec2 rs = vec2(atan(length(rd.xy),rd.z),atan(rd.x,rd.y));\n    vec3 moon = 0.5*clamp(MoonColor*0.07/length(MoonDirection-rd),0.0,1.0);\n    return moon+star(rs*50.)*vec3(0.5)+vec3(0.7,0.5,0.5)*star(rs*50.+20.)+vec3(0.5,0.5,0.7)*star(rs*50.+70.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    p = 2.0*(p-0.5);\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 offset = vec3(0,-0.4 ,0);\n    vec3 ro = vec3(0,0,0)-offset;\n    vec3 ta = vec3(0,1.6,-2)-offset;\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    float fov = 0.4;\n   \n    vec3 rd = normalize(side*p.x+up*p.y+cdir*fov);\n     //rd.xz *= rot(iTime);\n    float d,t=0.;\n    float gd = 0.;\n    vec3 ac = vec3(0.);\n    vec4 disres;\n    float kset = 0.3;\n    float sen = (1.0+1.5*pow(abs(sin(iTime*kset))*(1.0-fract(iTime*kset/(0.5*PI))),1.));\n    \n    for(int i = 0;i<139;i++){\n    \tdisres = 2.0*dist(ro+rd*t)*sen;\n        d = disres.w;\n        gd = 0.5*ground(ro+rd*t).w;\n        d = min(gd,d);\n        t += d;\n\t\tac += disres.xyz;\n        if((ro+rd*t).z<-1.5)break;\n    }\n\n    vec3 col = vec3(0.);\n\n   \tcol += ac;\n    \n    col += background(rd);\n    \n    if(gd<0.01){\n        vec3 sp = ro+rd*t;\n        vec3 normal = getnormal(sp);\n        float snk = 1.;\n        vec3 cnormal = normal + 0.1*(vec3(random(snk*sp.yz),random(snk*sp.zx),random(snk*sp.xy))-0.5);\n        cnormal = normalize(cnormal);\n        col = 1.5*vec3(193,157,121)/255.*MoonColor*vec3(max(dot(cnormal,MoonDirection),0.));\n        col += MoonColor*0.02;\n        ac = vec3(0.0);\n        \n        vec3 snormal;\n        vec3 rrd;\n        for(int i =0; i<8; i++){\n            snormal =normal + 1.0*(vec3(random(snk*sp.yz+float(i)*100.),random(snk*sp.zx+float(i)*100.),random(snk*sp.xy+float(i)*100.))-0.5);\n            snormal = normalize(snormal);\n            t = 0.4;\n            ro = sp;\n            rrd =snormal;// reflect(rd,snormal);\n            for(int i = 0;i<10;i++){\n                disres = 6.0*dist(ro+rrd*t)*sen;\n                d = disres.w;\n                t += d;\n                ac += disres.xyz;\n            }\n        }\n        col += 0.1*ac;\n    \n    }\n    \n    // Output to screen\n\tcol = pow(col,vec3(0.8));\n    fragColor = vec4(col,1.0);\n}"], ["\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n//////////////////////////////////////////////////////////////////////////////////////////////\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 2\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset) {\n  h = abs(h);\n  h = offset - h;\n  h = h * h;\n  return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nfloat PI = 3.1415926535;\nvec3 MoonDirection = normalize(vec3(-0.5,0.4,-0.3));\nvec3 MoonColor = vec3(0.6,0.7,1.2);\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rot(float r){\n    return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nvec4 dist(vec3 p){\n    //p.z *= 0.7;\n    p.y -= 0.3;\n\tfloat d = 0.009;\n    float no = ridgedMF(p.xz+0.3*snoise(p.xz+0.1*iTime));\n    vec3 col = vec3(1,1,1)*0.02*exp(-no*3.);\n    float thredy = 0.5;\n    float thx = p.y-thredy;\n    vec3 highems = vec3(1.3,1.0,1.0)*max(thx*8.0*exp(-3.5*vec3(2.,1.2,1.5)*thx),0.);\n    col *= highems;\n    return vec4(col,d);\n}\n\nvec4 ground(vec3 p){\n    p.y -= 0.3;\n    p.x -= -0.;\n    float d = p.y - smoothstep(0.0,1.0,length(p.xz-vec2(-0.4,0.))*1.)*0.23*ridgedMF(vec2(0.9,1.)*(p.xz-vec2(-0.1,0.02*iTime)));\n    //d = max(d,-(length(p-vec3(-0.4,0.65,-0.6))-0.8));\n    vec3 col = vec3(0);\n    return vec4(col,d);\n}\n\nvec3 getnormal(vec3 p)\n{\n\tconst vec2 e = vec2(0.5773,-0.5773)*0.0001;\n\tvec3 nor = normalize( e.xyy*ground(p+e.xyy).w +\n \t\te.yyx*ground(p+e.yyx).w + e.yxy*ground(p+e.yxy).w + e.xxx*ground(p+e.xxx).w);\n\tnor = normalize(vec3(nor));\n\treturn nor ;\n}\n\n\nvec3 star(vec2 s){\n    vec3 c = vec3(snoise(s));\n    c = pow(c,vec3(5.));\n    c = clamp(7.*clamp(c-0.7,0.0,1.0),0.0,1000.0);\n  \n    return c;\n}\n\nvec3 background(vec3 rd){\n    vec2 rs = vec2(atan(length(rd.xy),rd.z),atan(rd.x,rd.y));\n    vec3 moon = 0.5*clamp(MoonColor*0.07/length(MoonDirection-rd),0.0,1.0);\n    return moon+star(rs*50.)*vec3(0.5)+vec3(0.7,0.5,0.5)*star(rs*50.+20.)+vec3(0.5,0.5,0.7)*star(rs*50.+70.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    p = 2.0*(p-0.5);\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 offset = vec3(0,-0.4 ,0);\n    vec3 ro = vec3(0,0,0)-offset;\n    vec3 ta = vec3(0,1.6,-2)-offset;\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    float fov = 0.4;\n   \n    vec3 rd = normalize(side*p.x+up*p.y+cdir*fov);\n     //rd.xz *= rot(iTime);\n    float d,t=0.;\n    float gd = 0.;\n    vec3 ac = vec3(0.);\n    vec4 disres;\n    float kset = 0.3;\n    float sen = (1.0+1.5*pow(abs(sin(iTime*kset))*(1.0-fract(iTime*kset/(0.5*PI))),1.));\n    \n    for(int i = 0;i<139;i++){\n    \tdisres = 2.0*dist(ro+rd*t)*sen;\n        d = disres.w;\n        gd = 0.5*ground(ro+rd*t).w;\n        d = min(gd,d);\n        t += d;\n\t\tac += disres.xyz;\n        if((ro+rd*t).z<-1.5)break;\n    }\n\n    vec3 col = vec3(0.);\n\n   \tcol += ac;\n    \n    col += background(rd);\n    \n    if(gd<0.01){\n        vec3 sp = ro+rd*t;\n        vec3 normal = getnormal(sp);\n        float snk = 1.;\n        vec3 cnormal = normal + 0.1*(vec3(random(snk*sp.yz),random(snk*sp.zx),random(snk*sp.xy))-0.5);\n        cnormal = normalize(cnormal);\n        col = 1.5*vec3(193,157,121)/255.*MoonColor*vec3(max(dot(cnormal,MoonDirection),0.));\n        col += MoonColor*0.02;\n        ac = vec3(0.0);\n        \n        vec3 snormal;\n        vec3 rrd;\n        for(int i =0; i<8; i++){\n            snormal =normal + 1.0*(vec3(random(snk*sp.yz+float(i)*100.),random(snk*sp.zx+float(i)*100.),random(snk*sp.xy+float(i)*100.))-0.5);\n            snormal = normalize(snormal);\n            t = 0.4;\n            ro = sp;\n            rrd =snormal;// reflect(rd,snormal);\n            for(int i = 0;i<10;i++){\n                disres = 6.0*dist(ro+rrd*t)*sen;\n                d = disres.w;\n                t += d;\n                ac += disres.xyz;\n            }\n        }\n        col += 0.1*ac;\n    \n    }\n    \n    // Output to screen\n\tcol = pow(col,vec3(0.8));\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a circle art.\n// Probably faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float aa = a*a;\n    float raa = ra*ra;\n    float rba = rb*ra;\n    float rbb = rb*rb;\n    float rbaa = rba*rba;\n    float rbbaa = rbb*rbb;\n    float rbaa2 = rbaa*2.0;\n    float rbbaa2 = rbbaa*2.0;\n    float rbaa4 = rbaa*4.0;\n    float rbbaa4 = rbbaa*4.0;\n    float rbaa6 = rbaa*6.0;\n    float rbbaa6 = rbbaa*6.0;\n    float rbaa8 = rbaa*8.0;\n    float rbbaa8 = rbbaa*8.0;\n    float rbaa10 = rbaa*10.0;\n    float rbbaa10 = rbbaa*10.0;\n    float rbaa12 = rbaa*12.0;\n    float rbbaa12 = rbbaa*12.0;\n    float rbaa14 = rbaa*14.0;\n    float rbbaa14 = rbbaa*14.0;\n    float rbaa16 = rbaa*16.0;\n    float rbbaa16 = rbbaa*16.0;\n    float rbaa18 = rba// incomplete generation!\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        float ta = 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n        float tb = 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n        float rb = 0.15*(0.5+0.5*cos(iTime*0.41+1.0));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a quad. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 sdgQuad( in vec2 p, in vec2 v[4] )\n{\n    float gs = cro(v[0]-v[3],v[1]-v[0]);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v[1]-v[0];\n    vec2  w = p-v[0];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v[2]-v[1];\n    vec2  w = p-v[1];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v[3]-v[2];\n    vec2  w = p-v[2];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n\n    // edge 3\n    {\n    vec2  e = v[0]-v[3];\n    vec2  w = p-v[3];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }    \n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n        vec2 v[4] = vec2[4](\n            vec2(-0.9,-0.5) + 0.3*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n            vec2( 0.9,-0.5) + 0.3*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n            vec2( 0.9, 0.5) + 0.3*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ),\n            vec2(-0.9, 0.5) + 0.3*cos( 1.1*time + vec2(0.0,1.5) + 0.0 ) );\n\n        // corner radious\n        float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgQuad(p,v);\n        float d = dg.x-ra;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to an ellipse. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n//\n// It uses 4 iterations of Newton's root solver, but could need more for\n// very eccentric ellipses (see line 46). For an analytic solver see\n// https://www.shadertoy.com/view/4sS3zz\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Ellipse:            https://www.shadertoy.com/view/3lcfR8\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab )\n{\n    p = p*ab;\n    vec2 q = p;\n    p = abs(p);\n    float l = length(p);\n    float l2 = dot(p,p);\n    float l4 = l2*l2;\n    float l8 = l4*l4;\n    float l10 = l8*l2;\n    float l12 = l8*l4;\n    float l14 = l8*l4*l2;\n    float l16 = l8*l8;\n    float l18 = l16*l2;\n    float l20 = l16*l4;\n    float l22 = l16*l4*l2;\n    float l24 = l16*l8;\n    float l26 = l24*l2;\n    float l28 = l24*l4;\n    float l30 = l24*l4*l2;\n    float l32 = l16*l16;\n    float l34 = l32*l2;\n    float l36 = l32*l4;\n    float l38 = l32*l4*l2;\n    float l40 = l32*l8;\n    float l42 = l40*l2;\n    float l44 = l40*l4;\n    float l46 = l40*l4*l2;\n    float l48 = l32*l16;\n    float l50 = l48*l2;\n    float l52 = l48*l4;\n    float l54 = l48*l4*l2;\n    float l56 = l// incomplete generation!\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        vec2 ab = 0.7 + vec2(0.4,0.2)*cos(iTime*0.52+vec2(1,2));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgEllipse(p,ab);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n        \n        // draw gradient discontinuty\n        if( sin(3.1415927*iTime)>0.0 )\n        {\n            float f2 = ab.x*ab.x - ab.y*ab.y;\n            if( ab.x>ab.y )\n            {\n                float foc = f2/ab.x;\n                p.x -= clamp(p.x,-foc,foc);\n            }\n            else\n            {\n                float foc = -f2/ab.y;\n                p.y -= clamp(p.y,-foc,foc);\n            }\n            d = length(p);\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.005,0.010,abs(d)) );\n        }\n    \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// Smooth Repetition\n// by @paulofalcao\n//\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//\n// Twitter: @paulofalcao\n// https://twitter.com/paulofalcao/status/1365726720695934979\n//\n// YouTube playing with this and Material Maker\n// https://www.youtube.com/watch?v=HoAQ7DFRzQE\n//\n// I was using smooth abs p=sqrt(p*p+a) introduced by omeometo\n// at https://shadertoy.com/view/wljXzh\n// and iteratively doing smooth abs and translations\n// the number of objects is exponencial\n//\n// But it's possible to use asin(sin(x)*S) with S between 0 and 1 \n// like blackle said in the comments!\n// Creates infinite repetitions and it's even faster! :)\n// Change asin_sin_mode to true to use this mode (this is now the default mode)\n//\n// Using IQ \"Raymarching - Primitives\" as sandbox\n// https://www.shadertoy.com/view/Xds3zN\n//\n\n#define asin_sin_mode true\n\n//Change asin_sin_mode to true to use this mode (default)\n//blackle mode asin(sin(x)*S) with S between 0 and 1 (higher values less smooth)\nvec2 smoothrepeat_asin_sin(vec2 p,float smooth_size,float size){\n\tvec2 p_mod = mod(p,size);\n\tvec2 p_mod_mod = mod(p_mod,smooth_size);\n\tvec2 p_mod_mod_mod = mod(p_mod_mod,smooth_size/2.);\n\tvec2 p_mod_mod_mod_mod = mod(p_mod_mod_mod,smooth_size/4.);\n\tvec2 p_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod,smooth_size/8.);\n\tvec2 p_mod_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod_mod,smooth_size/16.);\n\tvec2 p_mod_mod_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod_mod_mod,smooth_size/32.);\n\tvec2 p_mod_mod_mod_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod_mod_mod_mod,smooth_size/64.);\n\tvec2 p_mod_mod_mod_mod_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod_mod_mod_mod_mod,smooth_size/128.);\n\tvec2 p_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod_mod_mod_mod_mod_mod,smooth_size/256.);\n\tvec2 p_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = mod(p_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod,smooth_size/512.);\n\tvec2 p_mod_mod_mod_mod_// incomplete generation!\n\n//Change asin_sin_mode to false to use this mode\n//6 iterations create 2^6 objects for each axis\n#define smoothrepeat_iterations 6\nvec2 smoothrepeat(vec2 p,float smooth_size,float size){\n    size/=2.0;\n    float w=pow(2.0,float(smoothrepeat_iterations));\n\tfor(int i=0;i<smoothrepeat_iterations;i++){\n        p=sqrt(p*p+smooth_size);//smooth abs\n\t\tp-=size*w;//translate\n\t\tw=w/2.0;\n\t}\n\treturn p;\n}\n\n\n//\n// The code from now on is the same as IQ \"Raymarching - Primitives\"\n// with minor modifications and different map function\n// https://www.shadertoy.com/view/Xds3zN\n//\n\n#if HW_PERFORMANCE==1\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n// PRIMITIVES\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rot(vec2 p, float r) {\n\tfloat s=sin(r);float c=cos(r);\n\treturn p*mat2(c,-s,s,c);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n\n      float sm=(smoothstep(0.0,1.0,sin(iTime)+0.5)-0.5)*0.01+0.005;\n      float dist=sin(iTime*0.35)*0.2+0.3;\n      \n      if (asin_sin_mode){\n          pos.xz=smoothrepeat_asin_sin(pos.xz,sm*10.0,dist);\n      } else {\n          pos.xz=smoothrepeat(pos.xz,sm,dist);\n      }\n\n      \n      pos.xz=rot(pos.xz,sin(iTime*0.5));\n      pos.xy=rot(pos.xy,sin(iTime*0.7)*0.4);\n      pos.yz=rot(pos.yz,sin(iTime)*0.3);\n\n      pos-=vec3(0.0,0.2, 0.0);\n      float b=sdRoundBox( pos, vec3(0.4,0.02,0.1),0.02);\n      \n      res = opU( res, vec2(b ,1.5) );\n    }\n\n    \n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.1;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n\n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     10.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0, 0, 0 );\n    \n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.0 + 4.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgTorus() returns the torus SDF and its gradient, by \n// computing it analytically. This means the normal to\n// the torus surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n  vec2 q = vec2(length(p.xz)-ra,p.y);\n  return vec4( length(q)-rb, q.x, q.y, 1.0 );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5;\n    float rb = 0.2+0.1*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgTorus(pos,ra,rb).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgTorus(pos,ra,rb).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgTorus( pos + e.xyy*eps, ra, rb ).x + \n                             e.yyx*sdgTorus( pos + e.yyx*eps, ra, rb ).x + \n                             e.yxy*sdgTorus( pos + e.yxy*eps, ra, rb ).x + \n                             e.xxx*sdgTorus( pos + e.xxx*eps, ra, rb ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgSegment() returns the segments/capsule SDF and its\n// analytical gradient. This means the normal to the \n// capsule's surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSegment( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec4( pa - ba*h, length(pa-ba*h) - r );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    vec3  pa = vec3(-0.5,-0.4,-0.3);\n    vec3  pb = vec3( 0.2, 0.4, 0.1);\n    float ra = 0.25+0.2*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgSegment(pos,pa,pb,ra).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgSegment(pos,pa,pb,ra).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgSegment( pos + e.xyy*eps, pa, pb, ra ).x + \n                             e.yyx*sdgSegment( pos + e.yyx*eps, pa, pb, ra ).x + \n                             e.yxy*sdgSegment( pos + e.yxy*eps, pa, pb, ra ).x + \n                             e.xxx*sdgSegment( pos + e.xxx*eps, pa, pb, ra ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Distance to a parallelogram, I implemented three methods:\n// Method 1: computed by two edges, by symmetry, single square root\n// Method 2: computed by interior/exterior, optimization of Pentan's idea\n// Method 3: computed by zones\n\n#define METHOD 1\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_1( in vec2 p, float wi, float he, float sk )\n{\n    vec2 k1 = vec2(  wi,  sk );\n    vec2 k2 = vec2( -sk,  wi );\n    vec2 k3 = vec2(  wi, -sk );\n    vec2 k4 = vec2(  sk, -wi );\n\n    vec2 a = vec2( dot(p,k1), dot(p,k2) );\n    vec2 b = vec2( dot(p,k3), dot(p,k4) );\n\n    vec2 d = min( a, b );\n    d = min( d, -p );\n    d = max( d, vec2(0.0) );\n\n    return length(d);\n}\n\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    float da = abs(p.x*e.y-p.y*e.x)-wi*he;\n    float db = abs(p.y)-e.y;\n    if( max(da,db)<0.0 ) // interior\n    {\n        return max( da*inversesqrt(e2), db );\n    }\n    else                 // exterior\n    {\n       float f = clamp(p.y/e.y,-1.0,1.0);\n       float g = clamp(p.x-e.x*f, -wi, wi);\n       float h = clamp(((p.x-g)*e.x+p.y*e.y)/e2,-1.0,1.0);\n       return length(p-vec2(g+e.x*h,e.y*h));\n    }\n}\n\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    // above\n    float db = abs(p.y)-he;\n    if( db>0.0 && abs(p.x-sk*sign(p.y))<wi )\n        return db;\n        \n    // inside\n    float e2 = sk*sk + he*he;\n    float h  = p.x*he - p.y*sk;\n    float da = (abs(h)-wi*he)*inversesqrt(e2);\n    if( da<0.0 && db<0.0 )\n        return max( da, db );\n\n    // sides\n    vec2 q = (h<0.0)?-p:p; q.x -= wi;\n    float v = abs(q.x*sk+q.y*he);\n    if( v<e2 )\n        return da;\n    \n    // exterior\n    return sqrt( dot(q,q)+e2-2.0*v );\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    #if METHOD==1\n    return sdParallelogram_1(p,wi,he,sk);\n    #endif\n    #if METHOD==2\n    return sdParallelogram_2(p,wi,he,sk);\n    #endif\n    #if METHOD==3\n    return sdParallelogram_3(p,wi,he,sk);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate\n    float sk = 0.5*sin(iTime);\n        \n    //p.x -= sk; // enable to lock base in place\n\n    // distance\n\tfloat d = sdParallelogram(p,0.4,0.6,sk);\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdParallelogram(m,0.4,0.6,sk);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parallelogram. Probably\n// faster than central differences or automatic differentiation/dual\n// numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2  q = abs(p);\n    vec2  e = vec2(wi,he);\n    float d = length(max(q,e-q)) + min(max(q.x,q.y),0.0);\n    vec2  g = vec2(sk,0.0);\n    float k = clamp(0.5+0.5*(p.y-p.x)/wi,0.0,1.0);\n    vec2  a = max(q-e+g*k,0.0);\n    float s = sign(p.y-p.x)*sign(p.y);\n    return vec3( d, s*a.x+a.y, s );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n\n        // sdf(p) and gradient(sdf(p))\n        float s = sin(iTime);\n        vec3  dg = sdgParallelogram(p,0.4, 0.6,s);\n        float d = dg.x;\n        vec2 g = dg.yz;\n        \n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["//Modificado por jorge2017a1 ----jorgeFloresP\n\n\n//Referencia de IQ https://www.shadertoy.com/view/wdBXRW\n// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n//\n//\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tr += c;\n\treturn r;\n\t}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n////-------------------\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N1 =12;\n\n\n\n\nfloat sdPolygon( in vec2 p, in vec2[N1] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n//vec2[] polygon = vec2[](v0,v1,v2,v3,v4);\n\nvec2 pt1[12]=vec2[](\nvec2(.32,.56),\nvec2(.24,.32),\nvec2(.34,.39),\nvec2(.4,.32),\nvec2(.43,.39),\nvec2(.47,.33),\nvec2(.49,.41),\nvec2(.55,.3),\nvec2(.56,.41),\nvec2(.61,.28),\nvec2(.59,.56),\nvec2(.32,.56)\n );\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nvec3 CabezaConPelo(vec2 p, vec3 col )\n{\n    vec2 p2= rotatev2( p, radians(180.0));\n    //vec2 p3= rotatev2( p-vec2(0.03,0.10), radians(iTime*10.0));\n    vec2 p3= rotatev2( p-vec2(0.03,0.10), radians(185.0));\n    \n    float d1 = sdPolygon(p2-vec2(-0.4,-0.5), pt1);\n    float d2 = sdPolygon(p3-vec2(-0.4,-0.5), pt1);\n    \n    float s1= sdCircle( p-vec2(-0.05,-0.1), 0.15 );\n    \n    float boca1= sdBox( p-vec2(-0.01,-0.2), vec2(0.05,0.01) );\n    \n    float ojo1= sdBox( p-vec2(-0.05,-0.1), vec2(0.02,0.02) );\n    float ojo2= sdBox( p-vec2(0.05,-0.1), vec2(0.02,0.02) );\n    \n    col = mix(col,vec3(1.0, 0.8,0.1)*1.2,S(s1,0.0));\n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(d2,0.0));\n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(boca1,0.0));\n    \n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo1,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo2,0.0));\n    \n    \n    d1 = SS(d1);\n    col=mix(col,vec3(0.0),d1);\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float tt=iTime;\n    uv=uv*2.0*abs(sin(tt));\n    vec2 p=uv*0.5+tt;\n    vec2 p2=uv*2.0;\n    //-------------------------------\n    vec3 col=vec3(1.0);\n    \n    p.x= opRep1D( p.x, 0.8 );\n    p.y= opRep1D( p.y, 0.8 );\n    \n    p2.x= opRep1D( p2.x, 1.6 );\n    p2.y= opRep1D( p2.y, 1.6 );\n    \n    col= CabezaConPelo(p, col);\n    col= CabezaConPelo(p2-vec2(0.5,-0.5), col);\n    \n    fragColor=vec4(col,1.0);\n    \n\n}"], ["// License CC0: 2D Amoebas\n//  While messing around I stumbled on a simple \"amoeba\" lika effect.\n//  Nothing complicated but nice IMHO so I shared\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n\treturn (a + b) / 2 - (a - b) * k;\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat df(vec2 p) {\n  // Generates a grid of dots\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(p-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n \n  const float z = 1.4;\n  float d = df(p/z)*z; \n  \n  vec3 col = vec3(0.33);\n  col = mix(col, vec3(.0), smoothstep(-aa, aa, -d));\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: 2D Amoebas\n//  While messing around I stumbled on a simple \"amoeba\" lika effect.\n//  Nothing complicated but nice IMHO so I shared\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p = fract(p / size) * size;\n    return q;\n}\n\n\nfloat df(vec2 p) {\n  // Generates a grid of dots\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(p-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n \n  const float z = 1.4;\n  float d = df(p/z)*z; \n  \n  vec3 col = vec3(0.33);\n  col = mix(col, vec3(.0), smoothstep(-aa, aa, -d));\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: Starry background with nebula\n//  Created for another shader but thought the background could be useful to others so extracted it\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n// QUINTIC or HERMITE interpolation?\n#define QUINTIC\n\n// How often to change the nebula\n#define PERIOD            15.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define TTIME             (TAU*TIME)\n\nconst mat2 rotSome          = ROT(1.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec2 co) {\n  co += 123.4;\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n// From one of IQ's value noise shaders\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n  // For each of the four corners we compute a dot product between\n  // the corner coordinates and the position.\n  float a = dot(i, vec2(1.0, 1.0));\n  float b = dot(i, vec2(1.0, 0.0));\n  float c = dot(i, vec2(0.0, 1.0));\n  float d = dot(i, vec2(0.0, 0.0));\n\n  // We then perform linear interpolation on each of the values\n  // computed above to get the final noise value.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat globalCloudDensity(vec2 p, float off) {\n  vec2 pp = p;\n\n  p *= 3.33;\n\n  float gcd = vnoise(p+off);\n  gcd *= smoothstep(PI/2.0, PI/4.0, abs(pp.x));\n  gcd *= smoothstep(PI/6.0, PI/18.0, abs(pp.y));\n\n  return gcd;\n}\n\nfloat localCloudDensity(vec2 p, float off) {\n  p *= 10.0;\n  const float aa = -0.45;\n  const mat2 pp = 2.03*rotSome;\n  float a = 0.5;\n  float s = 0.0;\n  p += off;\n\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n    \n  return s*2.75;\n}\n\nvec3 clouds(vec3 ro, vec3 rd, out float cloudDensity) {\n  vec3 srd = toSpherical(rd.zxy);\n  float y = sin(srd.y);\n\n  vec2 pp = srd.zy;\n  pp.x *= y;\n  pp.y -= PI/2.0;\n  pp *= ROT(0.5);\n\n  float h = hash(floor(2.0+TIME/PERIOD));\n  float off = 10.0*fract(123.0*h)+100.0;\n\n  float gcd = globalCloudDensity(pp, off);\n\n  float cd = gcd*localCloudDensity(pp, off);\n  float cdo = gcd*localCloudDensity(pp+00.075*vec2(0.125, -0.25), off);\n  cloudDensity = cd;\n\n  // Basis for some very fake shading\n  float cli = mix(-0.5, 1.0, 0.5 + 0.5*tanh_approx(12.0*(cd-cdo)));\n  \n  float tc = clamp(cd, 0.0, 1.0);\n  float huec = (mix(-0.2, 0.05, tc)+0.05)-0.15*(h-0.5)-0.0;\n  float satc = mix(0.9, 0.5, tc);\n  float bric = 1.0;\n  vec3 colc = hsv2rgb(vec3(huec, satc, bric))+cli*vec3(0.9, 0.7, 0.9);\n  tc *= tc;\n\n  vec4 cc = vec4(colc*0.66, tc);\n  cc = clamp(cc, 0.0, 1.0);\n\n  return cc.xyz*cc.w;\n}\n\nvec3 stars(vec3 ro, vec3 rd, float cloudDensity) {\n  vec3 col = vec3(0.0);\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = LAYERS;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = srd.yz+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.025, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(srd.y);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*109.0);\n    float h2 = fract(h.x*113.0);\n    float h3 = fract(h.x*127.0);\n\n    vec3 hsv = vec3(fract(0.025-0.4*h1*h1), mix(0.5, 0.125, s), 1.0);\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*hsv2rgb(hsv);\n\n    vec3 ccol = col+ exp(-(2000.0/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    float p = i < 3.0 ? mix(0.125, 2.0, cloudDensity)*y : y;\n    p = clamp(p, 0.0, 1.0);\n    col = h3 < p ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = srd.yz;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(srd.y);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(2.0, 0, 0.);\n  ro.xy *= ROT(-0.33*sin(TTIME/12.0));\n  ro.xz *= ROT(1.5+0.33*sin(TTIME/12.0));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = vec3(0.0);\n\n  float cloudDensity;  \n  col += clouds(ro, rd, cloudDensity);\n  col += stars(ro, rd, cloudDensity);\n  col += grid(ro, rd);\n  \n  col = clamp(col, 0.0, 1.0);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n\n"], ["// License CC0: The monolith, 1x4x9\n\n#define TOLERANCE         0.0001\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define SKYCOLOR(ro, rd)  skyColor(ro, rd)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(miss); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, plane);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    // Extremely fake soft shadows\n    float sha = rb.x == miss ? 1.0 : (1.0-1.0*tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75+0.23;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3, 0.3, 0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 enor) {\n  const float spr = 0.25;\n\n  vec3 spc = vec3(-enor*spr);\n  vec4 sp  = vec4(spc, spr);\n  vec2 rs = raySphere(ro,rd, sp);\n  vec3 bhsv = vec3(fract(0.05*TIME+dot(enor, rd)*2.0), 0.5, 1.0);\n  vec3 bcol = hsv2rgb(bhsv);\n\n  vec3 col = vec3(0.0);\n  \n  if (rs.x < miss) {\n    float t = rs.x;\n    vec3 pos = ro + rd*t;\n    vec3 nor = normalize(pos - sp.xyz);\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 2.0);\n    float l   = dif;\n    float lin = mix(0.005, 1.0, l);\n    float itd = rs.y - rs.x;\n    col += lin*bcol;\n    col = mix(col, vec3(0.0), tanh_approx(1E-3/(itd*itd)));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nor);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n//    col += vec3(0.5, 0.5, 1.0)*bddd*10;\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float mul = 0.05;\n  float mm = mix(0.25, 0.5, PCOS(TIME*mul*sqrt(3.0)));\n  vec3 ro = mm*vec3(2.0, 0, 0.2);\n  ro.xz *= ROT((TIME*mul));\n  ro.yz *= ROT(sin(TIME*mul*sqrt(0.5))*0.5);\n  ro += vec3(0.0, mm, 0.0);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.00;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n"], ["// License CC0: The monolith, 1x4x9\n\n#define TOLERANCE         0.0001\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define SKYCOLOR(ro, rd)  skyColor(ro, rd)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(miss); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, plane);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    // Extremely fake soft shadows\n    float sha = rb.x == miss ? 1.0 : (1.0-1.0*tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75+0.23;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3, 0.3, 0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 enor) {\n  const float spr = 0.25;\n\n  vec3 spc = vec3(-enor*spr);\n  vec4 sp  = vec4(spc, spr);\n  vec2 rs = raySphere(ro,rd, sp);\n  vec3 bhsv = vec3(fract(0.05*TIME+dot(enor, rd)*2.0), 0.5, 1.0);\n  vec3 bcol = hsv2rgb(bhsv);\n\n  vec3 col = vec3(0.0);\n  \n  if (rs.x < miss) {\n    float t = rs.x;\n    vec3 pos = ro + rd*t;\n    vec3 nor = normalize(pos - sp.xyz);\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 2.0);\n    float l   = dif;\n    float lin = mix(0.005, 1.0, l);\n    float itd = rs.y - rs.x;\n    col += lin*bcol;\n    col = mix(col, vec3(0.0), tanh_approx(1E-3/(itd*itd)));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nor);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n//    col += vec3(0.5, 0.5, 1.0)*bddd*10;\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float mul = 0.05;\n  float mm = mix(0.25, 0.5, PCOS(TIME*mul*sqrt(3.0)));\n  vec3 ro = mm*vec3(2.0, 0, 0.2);\n  ro.xz *= ROT((TIME*mul));\n  ro.yz *= ROT(sin(TIME*mul*sqrt(0.5))*0.5);\n  ro += vec3(0.0, mm, 0.0);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.00;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n"], ["// License CC0: The monolith, 1x4x9\n\n#define TOLERANCE         0.0001\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define SKYCOLOR(ro, rd)  skyColor(ro, rd)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    vec3 p = ro + rd*tN;\n    outNormal = vec3(p.x > boxSize.x? -1 : (p.x < -boxSize.x? 1 : 0),\n                     p.y > boxSize.y? -1 : (p.y < -boxSize.y? 1 : 0),\n                     p.z > boxSize.z? -1 : (p.z < -boxSize.z? 1 : 0) );\n    return vec2(tN, tF);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, plane);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    // Extremely fake soft shadows\n    float sha = rb.x == miss ? 1.0 : (1.0-1.0*tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75+0.23;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3, 0.3, 0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 enor) {\n  const float spr = 0.25;\n\n  vec3 spc = vec3(-enor*spr);\n  vec4 sp  = vec4(spc, spr);\n  vec2 rs = raySphere(ro,rd, sp);\n  vec3 bhsv = vec3(fract(0.05*TIME+dot(enor, rd)*2.0), 0.5, 1.0);\n  vec3 bcol = hsv2rgb(bhsv);\n\n  vec3 col = vec3(0.0);\n  \n  if (rs.x < miss) {\n    float t = rs.x;\n    vec3 pos = ro + rd*t;\n    vec3 nor = normalize(pos - sp.xyz);\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 2.0);\n    float l   = dif;\n    float lin = mix(0.005, 1.0, l);\n    float itd = rs.y - rs.x;\n    col += lin*bcol;\n    col = mix(col, vec3(0.0), tanh_approx(1E-3/(itd*itd)));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nor);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n//    col += vec3(0.5, 0.5, 1.0)*bddd*10;\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float mul = 0.05;\n  float mm = mix(0.25, 0.5, PCOS(TIME*mul*sqrt(3.0)));\n  vec3 ro = mm*vec3(2.0, 0, 0.2);\n  ro.xz *= ROT((TIME*mul));\n  ro.yz *= ROT(sin(TIME*mul*sqrt(0.5))*0.5);\n  ro += vec3(0.0, mm, 0.0);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.00;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n// sdgOval returns the oval SDF and its gradient, by \n// computing it analytically. \n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//A Z up oval, similiar to a capsule with a customizable mid radius\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgOvalZ(vec3 pIn, float  a, float b, float h) {\n  vec3 p = pIn;\n  p.z += h;\n  float r = length(p.xy);\n  float r2 = r*r;\n  float a2 = a*a;\n  float b2 = b*b;\n  float h2 = h*h;\n  float d = r2 - a2*b2;\n  float d2 = d*d;\n  float d3 = d*d2;\n  float d4 = d2*d2;\n  float d5 = d*d4;\n  float d6 = d2*d4;\n  float d7 = d*d6;\n  float d8 = d2*d6;\n  float d9 = d*d8;\n  float d10 = d2*d8;\n  float d11 = d*d10;\n  float d12 = d2*d10;\n  float d13 = d*d12;\n  float d14 = d2*d12;\n  float d15 = d*d14;\n  float d16 = d2*d14;\n  float d17 = d*d16;\n  float d18 = d2*d16;\n  float d19 = d*d18;\n  float d20 = d2*d18;\n  float d21 = d*d20;\n  float d22 = d2*d20;\n  float d23 = d*d22;\n  float d24 = d2*d22;\n\n//This shader assumes Y is up, so wrapping it to call the Z up oval\nvec4 sdgOvalY(vec3 p, float  a, float b, float h) {\n    p.xyz = p.xzy;\n    vec4 r= sdgOvalZ(p, a,b,h);\n    r.yzw = r.ywz;\n    return r;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an),1.30, 1.0*sin(an));\n    vec3 ta = vec3( 0.0, .5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5 + 0.4*cos(iTime);\n    float rb = min(0.1+0.1*(sin(iTime)), ra*.9);\n    float height = abs(cos(iTime*.5))*.5 +0.6;\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgOvalY(pos,ra,rb, height).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgOvalY(pos,ra,rb, height).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgOvalY( pos + e.xyy*eps, ra, rb,height ).x + \n                             e.yyx*sdgOvalY( pos + e.yyx*eps, ra, rb,height ).x + \n                             e.yxy*sdgOvalY( pos + e.yxy*eps, ra, rb,height ).x + \n                             e.xxx*sdgOvalY( pos + e.xxx*eps, ra, rb,height ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n// sdgOval returns the oval SDF and its gradient, by \n// computing it analytically. \n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//A Z up oval, similiar to a capsule with a customizable mid radius\n// .x = f(p)\n// .y = \u2202f(p)/\u2202x\n// .z = \u2202f(p)/\u2202y\n// .w = \u2202f(p)/\u2202z\n// .yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgOvalZ(vec3 pIn, float  a, float b, float h) {\n    \n    //These first 4 lines can be precalculated once\n    float r = a - b; //a must be greater than b!\n\tfloat l = (h * h - r * r) / (r+r);\n\tfloat sub2 = (a + l);\n\tfloat sub1 = sub2 - length(vec2(h, l));\n       \n\n    vec2 p = vec2(length(pIn.xy), abs(pIn.z) );\n    \n\tbool isTop =((p.y-h)*l) > p.x * h;\n    \n\tfloat y = isTop? h: 0.0;\n\tfloat x = isTop ? 0.0: l;\n\n\tvec2 p2 = vec2( p.x + x, p.y - y );\n   \n\tfloat d = length(p2)- (isTop ? sub1 : sub2);  \n\tvec3 grad = vec3(pIn.xy, pIn.z-y)*vec3(p2.x, p2.x, p.x );\n  \n\treturn vec4(d, normalize(grad));\n}\n\n//This shader assumes Y is up, so wrapping it to call the Z up oval\nvec4 sdgOvalY(vec3 p, float  a, float b, float h) {\n  return sdgOvalZ(vec3(p.x, p.z, p.y), a, b, h);\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an),1.30, 1.0*sin(an));\n    vec3 ta = vec3( 0.0, .5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5 + 0.4*cos(iTime);\n    float rb = min(0.1+0.1*(sin(iTime)), ra*.9);\n    float height = abs(cos(iTime*.5))*.5 +0.6;\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgOvalY(pos,ra,rb, height).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgOvalY(pos,ra,rb, height).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgOvalY( pos + e.xyy*eps, ra, rb,height ).x + \n                             e.yyx*sdgOvalY( pos + e.yyx*eps, ra, rb,height ).x + \n                             e.yxy*sdgOvalY( pos + e.yxy*eps, ra, rb,height ).x + \n                             e.xxx*sdgOvalY( pos + e.xxx*eps, ra, rb,height ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// License CC0: Crystal skull\n// Perhaps it's just me that sees a glowing skull captured in a crystal?\n// Result after continued experimenting with marble fractals and different kinds of trap functions\n\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5+0.5*cos(x))\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst vec3  skyCol1        = pow(vec3(0.2, 0.4, 0.6), vec3(0.25))*1.0;\nconst vec3  skyCol2        = pow(vec3(0.4, 0.7, 1.0), vec3(2.0))*1.0;\nconst vec3  sunCol         = vec3(8.0,7.0,6.0)/8.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Various ray object intersection from IQ:\n//  https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra*ra;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.505));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.5+.5*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n// Marble fractal from https://www.shadertoy.com/view/MtX3Ws\nvec2 csqr(vec2 a) { \n  return vec2(a.x*a.x - a.y*a.y, 2.*a.x*a.y); \n}\n\nfloat l0(vec3 v) {\n  return abs(v.x) + abs(v.y) + abs(v.z);\n}\n\nfloat marble_df(vec3 p) {  \n  float res = 0.;\n\n  vec3 c = p;\n  const float scale = 0.72;\n  const int max_iter = 8;\n  for (int i = 0; i < max_iter; ++i) {\n    p    = scale*abs(p)/L2(p) - scale;\n    p.yz = csqr(p.yz);\n    p    = p.zxy;\n    res  += exp(-2. * L2(p-c));\n  }\n\n  return res;\n}\n\nvec3 marble_march(vec3 ro, vec3 rd, float d, float dist, vec2 tminmax) {\n  float t   = tminmax.x;\n  float dt  = mix(1.0, 0.02, d);\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 64;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-2.0*c);\n      if(t>tminmax.y) { \n        break; \n      }\n      vec3 pos = ro+t*rd;\n        \n      c = marble_df(pos); \n      c *= 0.5;\n        \n      vec3 dcol = vec3(c*c*c-c*dist, c*c-c, c);\n      col = col + dcol;\n  }    \n  const float scale = 0.005;\n  float td = (t - tminmax.x)/(tminmax.y - tminmax.x);\n  col *= exp(-10.0*td);\n  col *= scale;\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd, float d) {\n  vec3 ipos = ro;\n  vec3 ird  = rd;\n  \n  float its4  = IRAYSHAPE(ipos, ird);\n  \n  float fi    = smoothstep(8.75, 10.0, TIME);\n\n  vec3 dpos = ipos;\n  dpos.x = abs(dpos.x);\n  float dm = mix(0.75, 1.1, (PCOS(-TIME*0.5+8.0*dpos.y))*fi);\n  float dist = 0.0;\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.1, 0.055))-0.05)*30.0, dm);\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.0, -0.025))-0.05)*20.0, dm);\n  \n  ipos.z -= mix(0.3, 0.0, fi);\n  ipos.z -= 0.0125*sin(ipos.y*5.0-TIME*sqrt(1.25));\n  ipos -= vec3(0.0, 0.2, mix(0.25, 0.0, d*d*d*d));\n  return marble_march(ipos, ird, d, dist, vec2(0.0, its4));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = skyColor(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n    \n    float d   = dot(rd, refr);\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr, d);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 start  = 1.5*vec3(0.5, 0.5, -2.0);\n  vec3 end    = mix(0.4, 0.6, PCOS(TIME*0.1))*vec3(0.0, 0.2, -2.0);\n  float fi    = smoothstep(1.0, 10.0, TIME);\n  vec3 ro     = mix(start, end, fi);\n  ro.zy      *= ROT(0.1*sin(TIME*sqrt(0.05))*fi);\n  ro.xz      *= ROT(0.1*sin(TIME*sqrt(0.02))*fi);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0+0.5*tanh_approx(length(p));\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  col = mix(vec3(0.0), col, smoothstep(0.0, 3.0, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Crystal skull\n// Perhaps it's just me that sees a glowing skull captured in a crystal?\n// Result after continued experimenting with marble fractals and different kinds of trap functions\n\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5+0.5*cos(x))\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst vec3  skyCol1        = pow(vec3(0.2, 0.4, 0.6), vec3(0.25))*1.0;\nconst vec3  skyCol2        = pow(vec3(0.4, 0.7, 1.0), vec3(2.0))*1.0;\nconst vec3  sunCol         = vec3(8.0,7.0,6.0)/8.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Various ray object intersection from IQ:\n//  https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.505));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.5+.5*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n// Marble fractal from https://www.shadertoy.com/view/MtX3Ws\nvec2 csqr(vec2 a) {\n    return vec2(a.x*a.x - a.y*a.y, a.x*a.y*2.0);\n}\n\nfloat l0(vec3 v) {\n  return abs(v.x) + abs(v.y) + abs(v.z);\n}\n\nfloat marble_df(vec3 p) {  \n  float res = 0.;\n\n  vec3 c = p;\n  const float scale = 0.72;\n  const int max_iter = 8;\n  for (int i = 0; i < max_iter; ++i) {\n    p    = scale*abs(p)/L2(p) - scale;\n    p.yz = csqr(p.yz);\n    p    = p.zxy;\n    res  += exp(-2. * L2(p-c));\n  }\n\n  return res;\n}\n\nvec3 marble_march(vec3 ro, vec3 rd, float d, float dist, vec2 tminmax) {\n  float t   = tminmax.x;\n  float dt  = mix(1.0, 0.02, d);\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 64;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-2.0*c);\n      if(t>tminmax.y) { \n        break; \n      }\n      vec3 pos = ro+t*rd;\n        \n      c = marble_df(pos); \n      c *= 0.5;\n        \n      vec3 dcol = vec3(c*c*c-c*dist, c*c-c, c);\n      col = col + dcol;\n  }    \n  const float scale = 0.005;\n  float td = (t - tminmax.x)/(tminmax.y - tminmax.x);\n  col *= exp(-10.0*td);\n  col *= scale;\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd, float d) {\n  vec3 ipos = ro;\n  vec3 ird  = rd;\n  \n  float its4  = IRAYSHAPE(ipos, ird);\n  \n  float fi    = smoothstep(8.75, 10.0, TIME);\n\n  vec3 dpos = ipos;\n  dpos.x = abs(dpos.x);\n  float dm = mix(0.75, 1.1, (PCOS(-TIME*0.5+8.0*dpos.y))*fi);\n  float dist = 0.0;\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.1, 0.055))-0.05)*30.0, dm);\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.0, -0.025))-0.05)*20.0, dm);\n  \n  ipos.z -= mix(0.3, 0.0, fi);\n  ipos.z -= 0.0125*sin(ipos.y*5.0-TIME*sqrt(1.25));\n  ipos -= vec3(0.0, 0.2, mix(0.25, 0.0, d*d*d*d));\n  return marble_march(ipos, ird, d, dist, vec2(0.0, its4));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = skyColor(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n    \n    float d   = dot(rd, refr);\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr, d);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 start  = 1.5*vec3(0.5, 0.5, -2.0);\n  vec3 end    = mix(0.4, 0.6, PCOS(TIME*0.1))*vec3(0.0, 0.2, -2.0);\n  float fi    = smoothstep(1.0, 10.0, TIME);\n  vec3 ro     = mix(start, end, fi);\n  ro.zy      *= ROT(0.1*sin(TIME*sqrt(0.05))*fi);\n  ro.xz      *= ROT(0.1*sin(TIME*sqrt(0.02))*fi);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0+0.5*tanh_approx(length(p));\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  col = mix(vec3(0.0), col, smoothstep(0.0, 3.0, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is further explorations in how domain repetition works\n//and under what scenarios a naively domain repeated object might fail to be an SDF\n\n//this is a visualization of how the closest neighbour SDF inside a domain changes as those SDFs change\n//if we imagine a point within a domain, we can ask \"what is the closest neighbouring SDF?\"\n//in this case, we have 6 boxes in the immediate neighbouring domains.\n//as we move a point within the central domain around, the closest box to that point will change\n//we can visualze the boundaries at which a point stops being closest to one box, and starts being closest to a different box\n//inside the middle box of this shader is such a visualization\n//as the dimensions of the neighbouring boxes change, the shape of the boundaries change.\n\n//when the boxes are perfect cubes, we can model the boundaries with\n//the \"face\" function in this shader: https://www.shadertoy.com/view/Wl3fD2\n//see also the youtube video: https://youtu.be/I8fmkLK1OKg\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat obj(vec3 p) {\n    return box(p, vec3(.25,.25,.25+sin(iTime)*.24)) - .01;\n}\n\nbool sort(inout float a, inout float b) {\n    if (b < a) {\n        float tmp = a;\n        a = b; b = tmp;\n        return true;\n    }\n    return false;\n}\n\nint gid;\nfloat scene(vec3 p) {\n    float u = obj(p - vec3(0,0,1));\n    float d = obj(p - vec3(0,0,-1));\n    float e = obj(p - vec3(0,1,0));\n    float w = obj(p - vec3(0,-1,0));\n    float n = obj(p - vec3(1,0,0));\n    float s = obj(p - vec3(-1,0,0));\n    \n    gid = 0;\n    if (sort(u,d)) gid = 1;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    sort(n,s);\n    \n    if (sort(u,d)) gid = 2;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    \n    if (sort(u,d)) gid = 3;\n    sort(d,e);\n    sort(e,w);\n    \n    if (sort(u,d)) gid = 4;\n    sort(d,e);\n    \n    if (sort(u,d)) gid = 5;\n    \n    float closest = u;\n    float secondclosest = d;\n    float boundary = (abs(closest-secondclosest)-.01)/2.;\n    boundary = max(boundary, box(p, vec3(.5)));\n    \n    return min(closest,boundary);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.0001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n    float fid = float(gid);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float fact = length(sin(r*3.5)*.5+.5)/sqrt(3.0);\n    return palette(fid)*(fact*.5 + pow(fact,5.)*4.*fres);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 cam = normalize(vec3(.8,uv));\n    vec3 init = vec3(-2.5,0,0);\n    float yrot = .2;\n    float zrot = iTime/2.;\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    \n    \n    vec3 col = vec3(0);\n    float atten = .7;\n    float k = 1.;\n    for (int i = 0; i < 200; i++ ) {\n        float dist = scene(p);\n        p += cam*dist*k;\n        if (dist*dist < 1e-7) {\n            col += shade(p, cam)*atten;\n            atten *= .7;\n            p += cam*.005;\n            k = sign(scene(p));\n        }\n        if(distance(p,init)>100.)break;\n    }\n    vec3 spec = shade(p, cam);\n    fragColor = vec4(sqrt(smoothstep(0.,1.,col)),1.0);\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat nozerosgn(float x) { return step(0.,x)*2.-1.; }\nvec2  nozerosgn(vec2  x) { return step(0.,x)*2.-1.; }\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n  vec2 e = abs(d);\n  vec2 s = sign(d);\n  vec2 q = abs(p);\n  vec2 r = e-q;\n  vec2 t = q-e;\n  vec2 a = vec2(e.x, t.y);\n  vec2 b = vec2(t.x, e.y);\n  vec2 c = vec2(r.x, t.y);\n  vec2 d = vec2(t.x, r.y);\n  vec2 e = vec2(r.x, r.y);\n  vec2 f = vec2(t.x, t.y);\n  vec2 g = vec2(r.x, q.y);\n  vec2 h = vec2(q.x, r.y);\n  vec2 i = vec2(r.x, e.y);\n  vec2 j = vec2(e.x, r.y);\n  vec2 k = vec2(t.x, e.y);\n  vec2 l = vec2(e.x, t.y);\n  vec2 m = vec2(q.x, e.y);\n  vec2 n = vec2(e.x, q.y);\n  vec2 o = vec2(q.x, q.y);\n  vec2 p = vec2(e.x, e.y);\n  vec2 q = vec2(t.x, t.y);\n  vec2 r = vec2(r.x, r.y);\n  vec2 s = vec2(t.x, t.y);\n  vec2 t = vec2(r.x, r.y);\n  vec2 u = vec2(t.x, t.y);\n  vec2 v = vec2(r.x, r.y);\n  vec2 w = vec2(t.x, t.// incomplete generation!\n\n//rest of this is visualization code\n//colours in box cycle between the boundaries for the 1st, 2nd, 3rd, and 4th closest edge.\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return length(p-mix(a,b,clamp(k,0.,1.)));\n}\nvec2 closestonline(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nfloat aa(float x) {\n    return smoothstep(0., 1.5/iResolution.y, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec2 d = vec2(sin(iTime/3.)*.5+1., -sin(iTime/3.)*.5+1.)*.3;\n    vec2 p = vec2(sin(iTime), cos(iTime*3./2.))*min(d.x,d.y);\n    if (iMouse.z > 0.) p = mouse;\n\n    vec2 e1, e2, e3, e4;\n    edge4(p, d, e1, e2, e3, e4);\n\n    float d1 = linedist(uv, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    float d2 = linedist(uv, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    float d3 = linedist(uv, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    float d4 = linedist(uv, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    \n    vec2 c1 = closestonline(p, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    vec2 c2 = closestonline(p, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    vec2 c3 = closestonline(p, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    vec2 c4 = closestonline(p, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    float dd1 = linedist(uv, p, c1);\n    float dd2 = linedist(uv, p, c2);\n    float dd3 = linedist(uv, p, c3);\n    float dd4 = linedist(uv, p, c4);\n\n    edge4(uv, d, e1, e2, e3, e4);\n    bool vb1 = sin(iTime/4.) < 0.;\n    bool vb2 = sin(iTime/2.) < 0.;\n    vec2 vis = vb1 ? (vb2 ? e1 : e3) : (vb2 ? e2 : e4);\n    \n    vec3 col = length(max(abs(uv)-d,0.)) > 0. ? vec3(1) : vec3(vis*.3+.7,1.);\n    float dmin = min(min(min(d1,dd1),min(d2,dd2)),min(min(d3,dd3),min(d4,dd4)));\n    col = mix(vec3(.00), col, aa(dmin-.007));\n    col = mix(vec3(.75), col, aa(min(d4,dd4)-.005));\n    col = mix(vec3(.50), col, aa(min(d3,dd3)-.005));\n    col = mix(vec3(.25), col, aa(min(d2,dd2)-.005));\n    col = mix(vec3(.00), col, aa(min(d1,dd1)-.005));\n    col = mix(vec3(.85,.05,.05), col, aa(distance(p,uv)-.020));\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat nozerosgn(float x) { return step(0.,x)*2.-1.; }\nvec2  nozerosgn(vec2  x) { return step(0.,x)*2.-1.; }\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n//this probably has some really elegant underlying structure, but I'm too tired to figure it out\n    vec3 p3 = vec3(nozerosgn(p), 0); //this lets us construct the edge vectors\n    p = abs(p);\n    float c2 = nozerosgn(p.x+p.y-d.x-d.y+min(d.x,d.y)*2.);\n    e1 = (p.x-d.x < p.y-d.y) ? p3.zy : p3.xz;\n    e2 =  c2*((c2 < 0. == p.x-d.x < p.y-d.y) ? p3.zy : p3.xz);\n    e3 = -c2*((c2 < 0. == p.x+d.x < p.y+d.y) ? p3.zy : p3.xz);\n    e4 = (p.x+d.x < p.y+d.y) ? -p3.zy : -p3.xz;\n}\n\n//rest of this is visualization code\n//colours in box cycle between the boundaries for the 1st, 2nd, 3rd, and 4th closest edge.\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nvec2 closestonline(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nfloat aa(float x) {\n    return smoothstep(0., 1.5/iResolution.y, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec2 d = vec2(sin(iTime/3.)*.5+1., -sin(iTime/3.)*.5+1.)*.3;\n    vec2 p = vec2(sin(iTime), cos(iTime*3./2.))*min(d.x,d.y);\n    if (iMouse.z > 0.) p = mouse;\n\n    vec2 e1, e2, e3, e4;\n    edge4(p, d, e1, e2, e3, e4);\n\n    float d1 = linedist(uv, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    float d2 = linedist(uv, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    float d3 = linedist(uv, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    float d4 = linedist(uv, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    \n    vec2 c1 = closestonline(p, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    vec2 c2 = closestonline(p, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    vec2 c3 = closestonline(p, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    vec2 c4 = closestonline(p, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    float dd1 = linedist(uv, p, c1);\n    float dd2 = linedist(uv, p, c2);\n    float dd3 = linedist(uv, p, c3);\n    float dd4 = linedist(uv, p, c4);\n\n    edge4(uv, d, e1, e2, e3, e4);\n    bool vb1 = sin(iTime/4.) < 0.;\n    bool vb2 = sin(iTime/2.) < 0.;\n    vec2 vis = vb1 ? (vb2 ? e1 : e3) : (vb2 ? e2 : e4);\n    \n    vec3 col = length(max(abs(uv)-d,0.)) > 0. ? vec3(1) : vec3(vis*.3+.7,1.);\n    float dmin = min(min(min(d1,dd1),min(d2,dd2)),min(min(d3,dd3),min(d4,dd4)));\n    col = mix(vec3(.00), col, aa(dmin-.007));\n    col = mix(vec3(.75), col, aa(min(d4,dd4)-.005));\n    col = mix(vec3(.50), col, aa(min(d3,dd3)-.005));\n    col = mix(vec3(.25), col, aa(min(d2,dd2)-.005));\n    col = mix(vec3(.00), col, aa(min(d1,dd1)-.005));\n    col = mix(vec3(.85,.05,.05), col, aa(distance(p,uv)-.020));\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * dfac(n - 2);\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n  float f = 1.0;\n  for (int i = l-m+1; i <= l+m; i++)\n    f *= i;\n  return f;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return vec2(cos(c.x), sin(c.x)) * c.y;\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l == 0) {\n        return 1;\n    }\n    if (m == 0) {\n        return legendre_poly(x, l - 1, m) * (2 * l - 1) * x / l;\n    }\n    return (legendre_poly(x, l - 1, m - 1) - legendre_poly(x, l - 1, m) * (2 * l - 1) * x / l) / (l - m);\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float theta_m = theta - phi * float(m);\n    float theta_p = theta + phi * float(m);\n    float theta_0 = theta;\n    float theta_1 = theta_m;\n    float theta_2 = theta_p;\n    float theta_3 = theta_0;\n    float theta_4 = theta_m;\n    float theta_5 = theta_p;\n    float theta_6 = theta_0;\n    float theta_7 = theta_m;\n    float theta_8 = theta_p;\n    float theta_9 = theta_0;\n    float theta_10 = theta_m;\n    float theta_11 = theta_p;\n    float theta_12 = theta_0;\n    float theta_13 = theta_m;\n    float theta_14 = theta_p;\n    float theta_15 = theta_0;\n    float theta_16 = theta_m;\n    float theta_17 = theta_p;\n    float theta_18 = theta_0;\n    float theta_19 = theta_m;\n    float theta_20 = theta_p;\n    float theta_21 = theta_0;\n    float theta_22 = theta_m;\n    float theta_23 = theta_p;\n    float theta_24 = theta_0;\n    float theta_25 = theta_m;\n    float theta_26 = theta_p;\n    float theta_27 = theta_0;\n    float theta_28 = theta_m;\n    float theta_29 = theta_p;\n    float theta_30 = theta_0;\n    float theta_31 = theta_m;\n    float theta_32 = theta_p// incomplete generation!\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    return pow(r, l) * exp(-r / (2 * n));\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}"], ["// License CC0: Random friday fractal\n// Result after a bit of random coding on friday afternoon\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\n\nfloat df(vec3 p) {\n  float d = 1E6;\n\n  const float zf = 2.;\n  const vec3 nz = normalize(vec3(1.0, .0, -1.0));\n  const vec3 ny = normalize(vec3(1.0, -1., 0.0));\n  float z = 1.0;\n  const float rsm = 0.125*0.25;\n  const float a = 128.25; \n  const mat2 rxy = ROT(a);\n  const mat2 ryz = ROT(a*sqrt(0.5));\n  \n  for (int i = 0; i < 7; ++i) {\n    vec3 pp0 = p;\n    vec3 pp1 = p;\n    float dd0 = box(pp0, vec3(0.25))-0.01;\n    float dd1 = length(pp1)-0.3;\n    float dd  = dd0;\n    dd =  pmax(dd, -dd1, 0.05);\n    dd = min(dd, length(pp0)- 0.25);\n    dd  /= z;\n    \n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(0.85/zf, 0.0, 0.0);\n    d = pmax(d, -(dd-0.1/z), 0.05/z);\n    \n    if(i > 2)\n    d = min(d, dd);\n  \n  }\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  if (t >= MAX_RAY_LENGTH) {\n    return vec3(0.0);\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n\n  float ifade= 1.0-tanh_approx(1.25*ii);\n  vec3 hsv   = vec3(1.25-t*0.5, mix(0.25, 1.0, ii), 1.0);\n  vec3 color = hsv2rgb(hsv);\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 5.0/ll2;\n  float dif = max(dot(nor,ld),0.0)*(dm+0.05);  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*ao*sha;\n\n  return col*ifade;\n//  return vec3(ao);\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/20.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// The left butterfly implements a naive and wrong way to\n// transition a stationary object into constant motion. The\n// butterfly to the right implements the integral of the\n// smoothstep() function in order to smoohtly transition\n// between the two states.\n//\n// More information here:\n//\n// https://iquilezles.org/www/articles/smoothstepintegral/smoothstepintegral.htm\n\n\n\n// Incorrect EaseInOut/Smoothstep velocity\nfloat position_bad( float t, in float T )\n{\n\treturn t * t * ( 3.0 - 2.0 * t );\n}\n\n// Correct integral of EaseInOut/Smoothstep\nfloat position_good( float t, in float T )\n{\n    if( t>=T ) return t - 0.5*T;\n    float f = t/T;\n    return f*f*f*(T-t*0.5);\n}\n\n\n// =======================================\n\nvec3 trackMin( in vec3 v, in float d )\n{\n         if( d<v.x ) v=vec3(d,v.x,v.y); \n    else if( d<v.y ) v=vec3(v.x,d,v.y);\n    else if( d<v.z ) v=vec3(v.x,v.y,d);\n    return v;\n}\n\nvec4 butterfly( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    p.y *= 0.9;\n    vec4 col = vec4(0.0);\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    \n    if( p.y<0.0 )\n    {\n        float f = 0.6 + 0.01*sin( 24.0*a );\n        float w = 1.1*a-0.8;\n        f *= sin(w)*sin(w);\n\n        float th = f + 0.001;\n        float th2 = th;\n        \n        vec3 wcol = mix( vec3(210,119,40)/255.0, \n                         vec3(232,79,12)/255.0, smoothstep( 0.0, 0.7, r ) );\n        wcol *= 1.5;\n\n        wcol *= 1.0+0.1*sin(17.0*p.x+vec3(0,0,4))*sin(23.0*p.y+vec3(0,0,4));\n\n        vec2 q = p;\n        q.xy += 0.02*sin(q.yx*12.0);\n        q.y = min(q.y,0.0);\n        vec3 v = vec3(10);\n        v = trackMin(v,length(q-vec2(0.29,-0.20)));\n        v = trackMin(v,length(q-vec2(0.10,-0.30)));\n        v = trackMin(v,length(q-vec2(0.20,-0.26)));\n        v = trackMin(v,length(q-vec2(0.28,-0.29)));\n        v = trackMin(v,length(q-vec2(0.34,-0.27)));\n        v = trackMin(v,length(q-vec2(0.38,-0.24)));\n        v = trackMin(v,length(q-vec2(0.39,-0.20)));\n        v = trackMin(v,length(q-vec2(0.38,-0.15)));\n        v = trackMin(v,length(q-vec2(0.35,-0.08)));\n\n        v.yz -= v.x;\n        float g = 1.25*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.01,g);\n        th -= 0.05*(1.0-smoothstep(0.0,0.05,g))-0.02;\n\n        wcol *= smoothstep(0.02,0.03,(th-r)*th);\n\n        q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        wcol = mix( wcol, vec3(1,1,1), 1.0-smoothstep( 0.0, 0.005,d) );\n        \n        wcol *= smoothstep(0.01,0.03,length(p-vec2(0.235,-0.2)));\n        \n        d = r-(th+th2)*0.5;\n        col = vec4(wcol,smoothstep( 0.0,2.0*fwidth(d),-d) );\n    }\n    \n    if( a<2.2 )\n    {\n        float f = 0.65 + 0.015*sin( 24.0*a );\n        float w = a*(3.1416/2.356);\n        float th = f*sin(w)*sin(w) + 0.001;\n        float th2 = th;\n        th += 0.25*exp2( -50.0*(w-1.4)*(w-1.4) );\n            \n        vec3 wcol = mix( vec3(0.7,0.5,0.2), \n                         vec3(0.8,0.2,0.0), smoothstep( 0.0, 1.0, r ) );\n        wcol *= 1.4;\n        wcol *= 1.0+0.1*sin(13.0*p.x+vec3(0,0,4))*sin(19.0*p.y+vec3(0,0,4));\n\n        vec3 v = vec3(10);\n        v = trackMin(v,length(p-vec2(0.25,0.2)));\n        v = trackMin(v,length(p-vec2(0.35,0.0)));\n        v = trackMin(v,length(p-vec2(0.4,0.1)));\n        v = trackMin(v,length(p-vec2(0.45,0.2)));\n        v = trackMin(v,length(p-vec2(0.45,0.3)));\n\n        v.yz -= v.x;\n        float g = 2.0*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.02,g);\n        th2 -= 0.05*(1.0-smoothstep(0.0,0.05,g));\n\n        float isblack = smoothstep(0.02,0.03,(th2-r)*th2);\n\n        vec2 q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        float ww = 1.0-smoothstep( 0.0, 0.01,d);\n        \n        if( r>th2 )\n        {\n        vec2 q = fract(p*18.0)-0.5;\n        vec2 iq = floor(p*18.0);\n        float id= iq.x*111.0+iq.y*13.0;\n        q += 0.25*sin(id*vec2(15,17)+vec2(0,2));\n        float r = 1.0+0.75*sin(id*431.0);\n        ww = max( ww, 1.0-smoothstep(0.0,0.01,length(q)-0.2*r));\n        }\n        \n        wcol = mix( wcol, vec3(ww), 1.0-isblack );\n        \n        d = r-th;\n        \n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = mix( col.xyz, wcol, al );\n        col.w = 1.0 - (1.0-col.w)*(1.0-al);\n    }\n    \n    return col;\n}\n\nint hash( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589)>>16;\n}\n\n#if HW_PERFORMANCE==0\nconst int AA = 2;\n#else\nconst int AA = 4;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stime = mod( iTime, 6.0 );\n    \n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        \n        p *= 1.6;\n        //p.y += 0.5;\n\n        float di = float( hash(ivec2(fragCoord)*AA+ivec2(i,j))&255 )/255.0;\n        float time = stime + ((float(j*AA+i)+di)/float(AA*AA))*(0.5/30.0) - 0.5*0.5/30.0;\n        \n        time += 0.07*sin( p.y );\n        \n        float wing = (p.x<0.0)?position_bad(time, 2.0):\n                               position_good(time, 2.0);\n        \n        if( p.x>0.0 ) p.x=p.x-1.4;\n        else          p.x=p.x+1.4;\n\n       \n        float an = 1.55*(0.5-0.5*cos(2.0*6.283185*wing));\n        vec2  pl = vec2(sign(p.x)*sin(an),-cos(an));\n\n        vec3 ro = vec3(0.0,0.085,2.1);\n        vec3 rd = vec3(p,-3.0);\n        vec3 pos = ro - rd*dot(ro.xz,pl)/dot(rd.xz,pl);\n        vec2 q = vec2( length(pos.xz), pos.y );\n\n        vec4 tmp = butterfly( q );\n        tmp = clamp(tmp,0.0,1.0);\n        tmp.xyz *= 0.1+0.9*mix(1.0,abs(q.y)*0.5+min(q.x*2.0,1.0),pl.x*pl.x);\n        tmp.xyz *= clamp(0.25+0.75*(pl.x-pl.y+1.0),0.0,1.0);\n        \n        \n        col += mix( vec3(0.5), tmp.xyz, tmp.w );\n    }\n    col /= float(AA*AA);\n\n    vec2 q = fragCoord/iResolution.xy;\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// The left butterfly implements a naive and wrong way to\n// transition a stationary object into constant motion. The\n// butterfly to the right implements the integral of the\n// smoothstep() function in order to smoohtly transition\n// between the two states.\n//\n// More information here:\n//\n// https://iquilezles.org/www/articles/smoothstepintegral/smoothstepintegral.htm\n\n\n\n// Incorrect EaseInOut/Smoothstep velocity\nfloat position_bad( float t, in float T )\n{\n    return smoothstep(0.0,T,t)*t;\n    //return (t<T) ? (t*t*t)/(T*T*T)*(3.0*T-2.0*t) : t;\n}\n\n// Correct integral of EaseInOut/Smoothstep\nfloat position_good( float t, in float T )\n{\n    return t * t * ( 3.0 - 2.0 * t );\n}\n\n\n// =======================================\n\nvec3 trackMin( in vec3 v, in float d )\n{\n         if( d<v.x ) v=vec3(d,v.x,v.y); \n    else if( d<v.y ) v=vec3(v.x,d,v.y);\n    else if( d<v.z ) v=vec3(v.x,v.y,d);\n    return v;\n}\n\nvec4 butterfly( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    p.y *= 0.9;\n    vec4 col = vec4(0.0);\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    \n    if( p.y<0.0 )\n    {\n        float f = 0.6 + 0.01*sin( 24.0*a );\n        float w = 1.1*a-0.8;\n        f *= sin(w)*sin(w);\n\n        float th = f + 0.001;\n        float th2 = th;\n        \n        vec3 wcol = mix( vec3(210,119,40)/255.0, \n                         vec3(232,79,12)/255.0, smoothstep( 0.0, 0.7, r ) );\n        wcol *= 1.5;\n\n        wcol *= 1.0+0.1*sin(17.0*p.x+vec3(0,0,4))*sin(23.0*p.y+vec3(0,0,4));\n\n        vec2 q = p;\n        q.xy += 0.02*sin(q.yx*12.0);\n        q.y = min(q.y,0.0);\n        vec3 v = vec3(10);\n        v = trackMin(v,length(q-vec2(0.29,-0.20)));\n        v = trackMin(v,length(q-vec2(0.10,-0.30)));\n        v = trackMin(v,length(q-vec2(0.20,-0.26)));\n        v = trackMin(v,length(q-vec2(0.28,-0.29)));\n        v = trackMin(v,length(q-vec2(0.34,-0.27)));\n        v = trackMin(v,length(q-vec2(0.38,-0.24)));\n        v = trackMin(v,length(q-vec2(0.39,-0.20)));\n        v = trackMin(v,length(q-vec2(0.38,-0.15)));\n        v = trackMin(v,length(q-vec2(0.35,-0.08)));\n\n        v.yz -= v.x;\n        float g = 1.25*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.01,g);\n        th -= 0.05*(1.0-smoothstep(0.0,0.05,g))-0.02;\n\n        wcol *= smoothstep(0.02,0.03,(th-r)*th);\n\n        q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        wcol = mix( wcol, vec3(1,1,1), 1.0-smoothstep( 0.0, 0.005,d) );\n        \n        wcol *= smoothstep(0.01,0.03,length(p-vec2(0.235,-0.2)));\n        \n        d = r-(th+th2)*0.5;\n        col = vec4(wcol,smoothstep( 0.0,2.0*fwidth(d),-d) );\n    }\n    \n    if( a<2.2 )\n    {\n        float f = 0.65 + 0.015*sin( 24.0*a );\n        float w = a*(3.1416/2.356);\n        float th = f*sin(w)*sin(w) + 0.001;\n        float th2 = th;\n        th += 0.25*exp2( -50.0*(w-1.4)*(w-1.4) );\n            \n        vec3 wcol = mix( vec3(0.7,0.5,0.2), \n                         vec3(0.8,0.2,0.0), smoothstep( 0.0, 1.0, r ) );\n        wcol *= 1.4;\n        wcol *= 1.0+0.1*sin(13.0*p.x+vec3(0,0,4))*sin(19.0*p.y+vec3(0,0,4));\n\n        vec3 v = vec3(10);\n        v = trackMin(v,length(p-vec2(0.25,0.2)));\n        v = trackMin(v,length(p-vec2(0.35,0.0)));\n        v = trackMin(v,length(p-vec2(0.4,0.1)));\n        v = trackMin(v,length(p-vec2(0.45,0.2)));\n        v = trackMin(v,length(p-vec2(0.45,0.3)));\n\n        v.yz -= v.x;\n        float g = 2.0*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.02,g);\n        th2 -= 0.05*(1.0-smoothstep(0.0,0.05,g));\n\n        float isblack = smoothstep(0.02,0.03,(th2-r)*th2);\n\n        vec2 q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        float ww = 1.0-smoothstep( 0.0, 0.01,d);\n        \n        if( r>th2 )\n        {\n        vec2 q = fract(p*18.0)-0.5;\n        vec2 iq = floor(p*18.0);\n        float id= iq.x*111.0+iq.y*13.0;\n        q += 0.25*sin(id*vec2(15,17)+vec2(0,2));\n        float r = 1.0+0.75*sin(id*431.0);\n        ww = max( ww, 1.0-smoothstep(0.0,0.01,length(q)-0.2*r));\n        }\n        \n        wcol = mix( wcol, vec3(ww), 1.0-isblack );\n        \n        d = r-th;\n        \n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = mix( col.xyz, wcol, al );\n        col.w = 1.0 - (1.0-col.w)*(1.0-al);\n    }\n    \n    return col;\n}\n\nint hash( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589)>>16;\n}\n\n#if HW_PERFORMANCE==0\nconst int AA = 2;\n#else\nconst int AA = 4;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stime = mod( iTime, 6.0 );\n    \n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        \n        p *= 1.6;\n        //p.y += 0.5;\n\n        float di = float( hash(ivec2(fragCoord)*AA+ivec2(i,j))&255 )/255.0;\n        float time = stime + ((float(j*AA+i)+di)/float(AA*AA))*(0.5/30.0) - 0.5*0.5/30.0;\n        \n        time += 0.07*sin( p.y );\n        \n        float wing = (p.x<0.0)?position_bad(time, 2.0):\n                               position_good(time, 2.0);\n        \n        if( p.x>0.0 ) p.x=p.x-1.4;\n        else          p.x=p.x+1.4;\n\n       \n        float an = 1.55*(0.5-0.5*cos(2.0*6.283185*wing));\n        vec2  pl = vec2(sign(p.x)*sin(an),-cos(an));\n\n        vec3 ro = vec3(0.0,0.085,2.1);\n        vec3 rd = vec3(p,-3.0);\n        vec3 pos = ro - rd*dot(ro.xz,pl)/dot(rd.xz,pl);\n        vec2 q = vec2( length(pos.xz), pos.y );\n\n        vec4 tmp = butterfly( q );\n        tmp = clamp(tmp,0.0,1.0);\n        tmp.xyz *= 0.1+0.9*mix(1.0,abs(q.y)*0.5+min(q.x*2.0,1.0),pl.x*pl.x);\n        tmp.xyz *= clamp(0.25+0.75*(pl.x-pl.y+1.0),0.0,1.0);\n        \n        \n        col += mix( vec3(0.5), tmp.xyz, tmp.w );\n    }\n    col /= float(AA*AA);\n\n    vec2 q = fragCoord/iResolution.xy;\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an arrow\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*h - w2*(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float time = iTime*0.25;\n    vec2 a = vec2(-1.0,0.0)+vec2(0.4,0.6)*cos(time*vec2(1.1,1.3)+vec2(0.0,1.0));\n    vec2 b = vec2( 1.0,0.0)+vec2(0.4,0.6)*cos(time*vec2(1.2,1.5)+vec2(0.3,2.0));\n    float w1 = 0.2;//0.05*(0.8+0.2*cos(time*0.31+2.0));\n    float w2 = w1 + 0.15;\n    \n    // distance\n    float d = sdArrow(p, a, b, w1, w2);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-5.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdArrow(m, a, b, w1, w2);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray-disk intersection. For general planar shapes, please see the\n// \"coord system intersector\" at https://www.shadertoy.com/view/lsfGDB\n//\n//\n// List of other ray-surface intersectors:\n//    https://www.shadertoy.com/playlist/l3dXRf\n// and \n//    http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// disk: center c, normal n, radius r\nfloat diskIntersect( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n    vec3 oc = ro-c;\n    float b = dot( oc, n );\n    float c = dot( oc, oc ) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\n// disk: center c, normal n, radius r\nfloat diskIntersectWithBackFaceCulling( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n    float d = dot(rd,n);\n    if( d>0.0 ) return -1.0;\n\tvec3  o = ro - c;\n    float t = -dot(n,o)/d;\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n        // camera\n        vec3 ro = 1.5*vec3(cos(0.15*iTime),0.0,sin(0.15*iTime));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n        // render background\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // render disks (raycast them)\n        const int num = 64;  // number of disks\n\n        float tmin = 1e20;\n        vec3  onor = vec3(0.0);\n        for( int i=0; i<num; i++ )\n        {\n            // fibonacci points on a sphere\n            const float kInvPhi = (sqrt(5.0)-1.0)/2.0; // one over golden ratio\n            float cb = 1.0-2.0*(float(i)+0.5)/float(num);\n            float sb = sqrt(1.0-cb*cb);\n            float aa = 6.283185*kInvPhi*float(i);\n            vec3  cen = vec3( sb*sin(aa), sb*cos(aa), cb );\n\n            // orient disk tangent to sphere surface\n            vec3  nor = normalize(cen);\n\n            // for full coverage, each disk's area should be 4PI/num,\n            // ie, their radius should be 2/sqrt(num)\n            float rad = (2.0/sqrt(float(num))); \n            // but we only want partial coverage, for aesthetic reasons\n            rad *= 0.5;\n\n            // test for intersection with disk\n            float t = diskIntersect( ro, rd, cen, nor, rad );\n\n            // trak intersections\n            if( t>0.0 && t<tmin ) \n            {\n                tmin = t;\n                onor = nor;\n            }\n        }\n\n        // shade disk, if one found\n        if( tmin<1000.0 )\n        {\n            float dif = clamp( dot(onor,vec3(0.8,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*onor.y;\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.75,0.6)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// License CC0: Cable nest\n//  Result after a few hours programming sunday afternoon\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\nconst float cam_amp = 1.0;\n\nvec4 g_state = vec4(0.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float res = -b - h;\n    if( res < dbuffer ) return -1.0;\n    return res;\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\nfloat df(vec3 p3, out vec4 state) {\n  float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= ROT(-0.2*TIME);\n  float s = 1.0;\n  \n  float d = 1E6;\n  float tt = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    tt += sqrt(2.0)*float(1+i);\n    p *= pp;\n    vec2 sp = sign(p);\n    p = abs(p);\n    tt += dot(sp, vec2(0.25, 0.5))*s;\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    \n    float dd = (length(p-vec2(0.0))-cylr)*s;\n    if (dd < d) {\n      d = dd;\n      state = vec4(p, t, hash(tt+123.4));\n    }\n    \n  }\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  vec4 state;\n  float d = df(p, state);\n  \n  g_state = state;\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  vec4 state = g_state;\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*120.0/60.0));\n  vec3 bcol   = mix(1.5*vec3(2.25, 0.75, 0.5), 3.5*vec3(2.0, 1.0, 0.75), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n  \n  vec3 nor    = normal(pos);\n\n  float sa    = atan(state.y, state.x)+4.0*state.z*(0.5+0.5*state.w);\n  float v     = 0.9*smoothstep(-0.1, 0.1, sin(4.0*sa));\n  vec3 color  = hsv2rgb(vec3(0.0+123.4*state.w, 0.66, 0.75*v));\n  \n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n  col += dif0*sha0*color;\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect3d(vec2 p) {\n  float tm = TIME;\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*-2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = (2.0+0.5*tanh_approx(length(p)));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p);\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return sign(p)*b + clamp(d, vec3(0.0), vec3(1.0))*sign(d);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  vec3 q = abs(p) - b;\n  return min(max(q.x,max(q.y,q.z)),0.0) +\n         length(max(q,0.0)) - e;\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        sdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n        sdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n        sdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );\n    return normalize( nor );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    float t = 0.0;\n    float h = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        t += h;\n        h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        if( h<0.001 ) break;\n    }\n    return res;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// License CC0: Saturday Torus\n//  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 q = vec2(length(cross(rd, ro)), dot(tor, ro));\n    float r = tor.x + tor.y;\n    float a = q.x*q.x + q.y*q.y - r*r;\n    float b = dot(q, rd);\n    float h = b*b - a;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    float s = -b - h;\n    if( s < 0.001 ) s = -b + h;\n    if( s < 0.001 ) return -1.0;\n    return s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  const float rdd = 2.0;\n  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n  vec3 la  = vec3(0.0, 0.0, 0.2);\n  vec3 up  = vec3(0.3, 0.0, 1.0);\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = ldif1/ldl1;\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n  vec3  bcol0 = vec3(0.3);  \n  vec3  bcol1 = vec3(0.025);  \n  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n  vec3 col = vec3(0.0);\n\n  if (td > -1.0) {\n    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n    col *= sqrt(abs(dot(rd, tnor)));\n  }\n  \n  if (sd < ldl1) {\n    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n  }\n\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p, q);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Saturday Torus\n//  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n  float po = 1.0;\n\n  float Ra2 = tor.x*tor.x;\n  float ra2 = tor.y*tor.y;\n\n  float m = dot(ro,ro);\n  float n = dot(ro,rd);\n\n  // bounding sphere\n  {\n    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n    if(h<0.0) return -1.0;\n    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n  }\n\n  // find quartic equation\n  float k = (m - ra2 - Ra2)/2.0;\n  float k3 = n;\n  float k2 = n*n + Ra2*rd.z*rd.z + k;\n  float k1 = k*n + Ra2*ro.z*rd.z;\n  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n  #ifndef TORUS_REDUCE_PRECISION\n  // prevent |c1| from being too close to zero\n  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n  {\n    po = -1.0;\n    float tmp=k1; k1=k3; k3=tmp;\n    k0 = 1.0/k0;\n    k1 = k1*k0;\n    k2 = k2*k0;\n    k3 = k3*k0;\n  }\n  #endif\n\n  float c2 = 2.0*k2 - 3.0*k3*k3;\n  float c1 = k3*(k3*k3 - k2) + k1;\n  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n  c2 /= 3.0;\n  c1 *= 2.0;\n  c0 /= 3.0;\n\n  float Q = c2*c2 + c0;\n  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n  float h = R*R - Q*Q*Q;\n  float z = 0.0;\n  if(h < 0.0) {\n    // 4 intersections\n    float sQ = sqrt(Q);\n    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n  } else {\n    // 2 intersections\n    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n    z = sign(R)*abs(sQ + Q/sQ);\n  }\n  z = c2 - z;\n\n  float d1 = z   - 3.0*c2;\n  float d2 = z*z - 3.0*c0;\n  if(abs(d1) < 1.0e-4) {\n    if(d2 < 0.0) return -1.0;\n    d2 = sqrt(d2);\n  } else {\n    if(d1 < 0.0) return -1.0;\n    d1 = sqrt(d1/2.0);\n    d2 = c1/d1;\n  }\n\n  //----------------------------------\n\n  float result = 1e20;\n\n  h = d1*d1 - z + d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=t1;\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  h = d1*d1 - z - d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=min(result,t1);\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n  vec2 n = vec2(q.x/tor.x, 1.0);\n  float l = length(n);\n  n /= l;\n  return normalize(pos - n*tor.x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  const float rdd = 2.0;\n  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n  vec3 la  = vec3(0.0, 0.0, 0.2);\n  vec3 up  = vec3(0.3, 0.0, 1.0);\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = ldif1/ldl1;\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n  vec3  bcol0 = vec3(0.3);  \n  vec3  bcol1 = vec3(0.025);  \n  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n  vec3 col = vec3(0.0);\n\n  if (td > -1.0) {\n    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n    col *= sqrt(abs(dot(rd, tnor)));\n  }\n  \n  if (sd < ldl1) {\n    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n  }\n\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p, q);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Saturday Torus\n//  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n  float po = 1.0;\n\n  float Ra2 = tor.x*tor.x;\n  float ra2 = tor.y*tor.y;\n\n  float m = dot(ro,ro);\n  float n = dot(ro,rd);\n\n  // bounding sphere\n  {\n    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n    if(h<0.0) return -1.0;\n    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n  }\n\n  // find quartic equation\n  float k = (m - ra2 - Ra2)/2.0;\n  float k3 = n;\n  float k2 = n*n + Ra2*rd.z*rd.z + k;\n  float k1 = k*n + Ra2*ro.z*rd.z;\n  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n  #ifndef TORUS_REDUCE_PRECISION\n  // prevent |c1| from being too close to zero\n  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n  {\n    po = -1.0;\n    float tmp=k1; k1=k3; k3=tmp;\n    k0 = 1.0/k0;\n    k1 = k1*k0;\n    k2 = k2*k0;\n    k3 = k3*k0;\n  }\n  #endif\n\n  float c2 = 2.0*k2 - 3.0*k3*k3;\n  float c1 = k3*(k3*k3 - k2) + k1;\n  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n  c2 /= 3.0;\n  c1 *= 2.0;\n  c0 /= 3.0;\n\n  float Q = c2*c2 + c0;\n  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n  float h = R*R - Q*Q*Q;\n  float z = 0.0;\n  if(h < 0.0) {\n    // 4 intersections\n    float sQ = sqrt(Q);\n    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n  } else {\n    // 2 intersections\n    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n    z = sign(R)*abs(sQ + Q/sQ);\n  }\n  z = c2 - z;\n\n  float d1 = z   - 3.0*c2;\n  float d2 = z*z - 3.0*c0;\n  if(abs(d1) < 1.0e-4) {\n    if(d2 < 0.0) return -1.0;\n    d2 = sqrt(d2);\n  } else {\n    if(d1 < 0.0) return -1.0;\n    d1 = sqrt(d1/2.0);\n    d2 = c1/d1;\n  }\n\n  //----------------------------------\n\n  float result = 1e20;\n\n  h = d1*d1 - z + d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=t1;\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  h = d1*d1 - z - d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=min(result,t1);\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n    float x2 = x * x;\n    return x * (8.0f / (1.0f + x2 + x2 * x2 + x2 * x2 * x2));\n}\n\nvec3 color(vec2 p, vec2 q) {\n  const float rdd = 2.0;\n  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n  vec3 la  = vec3(0.0, 0.0, 0.2);\n  vec3 up  = vec3(0.3, 0.0, 1.0);\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = ldif1/ldl1;\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n  vec3  bcol0 = vec3(0.3);  \n  vec3  bcol1 = vec3(0.025);  \n  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n  vec3 col = vec3(0.0);\n\n  if (td > -1.0) {\n    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n    col *= sqrt(abs(dot(rd, tnor)));\n  }\n  \n  if (sd < ldl1) {\n    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n  }\n\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p, q);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Saturday Torus\n//  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n  float po = 1.0;\n\n  float Ra2 = tor.x*tor.x;\n  float ra2 = tor.y*tor.y;\n\n  float m = dot(ro,ro);\n  float n = dot(ro,rd);\n\n  // bounding sphere\n  {\n    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n    if(h<0.0) return -1.0;\n    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n  }\n\n  // find quartic equation\n  float k = (m - ra2 - Ra2)/2.0;\n  float k3 = n;\n  float k2 = n*n + Ra2*rd.z*rd.z + k;\n  float k1 = k*n + Ra2*ro.z*rd.z;\n  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n  #ifndef TORUS_REDUCE_PRECISION\n  // prevent |c1| from being too close to zero\n  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n  {\n    po = -1.0;\n    float tmp=k1; k1=k3; k3=tmp;\n    k0 = 1.0/k0;\n    k1 = k1*k0;\n    k2 = k2*k0;\n    k3 = k3*k0;\n  }\n  #endif\n\n  float c2 = 2.0*k2 - 3.0*k3*k3;\n  float c1 = k3*(k3*k3 - k2) + k1;\n  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n  c2 /= 3.0;\n  c1 *= 2.0;\n  c0 /= 3.0;\n\n  float Q = c2*c2 + c0;\n  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n  float h = R*R - Q*Q*Q;\n  float z = 0.0;\n  if(h < 0.0) {\n    // 4 intersections\n    float sQ = sqrt(Q);\n    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n  } else {\n    // 2 intersections\n    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n    z = sign(R)*abs(sQ + Q/sQ);\n  }\n  z = c2 - z;\n\n  float d1 = z   - 3.0*c2;\n  float d2 = z*z - 3.0*c0;\n  if(abs(d1) < 1.0e-4) {\n    if(d2 < 0.0) return -1.0;\n    d2 = sqrt(d2);\n  } else {\n    if(d1 < 0.0) return -1.0;\n    d1 = sqrt(d1/2.0);\n    d2 = c1/d1;\n  }\n\n  //----------------------------------\n\n  float result = 1e20;\n\n  h = d1*d1 - z + d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=t1;\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  h = d1*d1 - z - d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=min(result,t1);\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  const float rdd = 2.0;\n  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n  vec3 la  = vec3(0.0, 0.0, 0.2);\n  vec3 up  = vec3(0.3, 0.0, 1.0);\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = ldif1/ldl1;\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n  vec3  bcol0 = vec3(0.3);  \n  vec3  bcol1 = vec3(0.025);  \n  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n  vec3 col = vec3(0.0);\n\n  if (td > -1.0) {\n    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n    col *= sqrt(abs(dot(rd, tnor)));\n  }\n  \n  if (sd < ldl1) {\n    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n  }\n\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = pow(col, vec3(0.85));\n  col *= 1.05;\n  col = 1.0 - col;\n  col = 1.0 - col * col;\n  col *= 1.1;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p, q);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n"], ["/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n    float sx=sin(theta.x);\n    float cx=cos(theta.x);\n    float sy=sin(theta.y);\n    float cy=cos(theta.y);\n    float sz=sin(theta.z);\n    float cz=cos(theta.z);\n    return mat3(\n        vec3(cy*cz, -cy*sz, sy),\n        vec3(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy),\n        vec3(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy)\n        );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 sun_pos = eye;\n\tvec3 L = sun_pos - p;\n    float d = max(length(L), EPSILON);\n    float atten = 1.0 / (1.0 + d*0.2 + d*d*0.1); \n    vec3 c = (K_a + K_d + K_s)*atten;\n\treturn c;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n"], ["/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n    float sx=sin(theta.x);\n    float cx=cos(theta.x);\n    float sy=sin(theta.y);\n    float cy=cos(theta.y);\n    float sz=sin(theta.z);\n    float cz=cos(theta.z);\n    return mat3(\n        vec3(cy*cz, -cy*sz, sy),\n        vec3(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy),\n        vec3(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy)\n        );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 sun_pos = eye;\n\tvec3 L = sun_pos - p;\n    float d = max(length(L), EPSILON);\n    float atten = 1.0 / (1.0 + d*0.2 + d*d*0.1); \n    vec3 c = (K_a + K_d + K_s)*atten;\n\treturn c;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n"], ["/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    c.x + c.y * c.z, s.y * s.z - c.y * s.x, s.y * c.z + c.y * s.x,\n    s.x * c.z - c.x * s.y, c.x + c.y * c.z, s.x * s.y + c.x * c.y,\n    c.z * s.x + c.x * s.y, -s.z * s.x + c.x * c.z, c.x + c.y * c.z\n  );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 sun_pos = eye;\n\tvec3 L = sun_pos - p;\n    float d = max(length(L), EPSILON);\n    float atten = 1.0 / (1.0 + d*0.2 + d*d*0.1); \n    vec3 c = (K_a + K_d + K_s)*atten;\n\treturn c;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n"], ["/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n    float sx=sin(theta.x);\n    float cx=cos(theta.x);\n    float sy=sin(theta.y);\n    float cy=cos(theta.y);\n    float sz=sin(theta.z);\n    float cz=cos(theta.z);\n    return mat3(\n        vec3(cy*cz, -cy*sz, sy),\n        vec3(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy),\n        vec3(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy)\n        );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 l = normalize(lp - p);\n    vec3 v = normalize(eye - p);\n    vec3 h = normalize(l + v);\n    float lDotV = max(dot(l, v), 0.0);\n    float lDotH = max(dot(l, h), 0.0);\n    float vDotH = max(dot(v, h), 0.0);\n    float specular = pow(lDotH, 16.0);\n    float diffuse = lDotV;\n    float attenuation = 1.0 / (1.0 + 0.001 * length(lp - p));\n    vec3 ambient = vec3(0.0, 0.0, 0.0);\n    vec3 sunLight = (ambient + diffuse + specular) * attenuation;\n    return sunLight;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n"], ["// License CC0: Simple circle tiling\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p = fract(p / size) * size;\n    return q;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash(vec2 uv) {\n  return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df(vec2 p, out float n, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 0.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d = circle(pp, 1.25*sz);\n  \n  n = fract(r);\n  sc = sz;\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  p += r*vec2(cos(a), sin(a));\n  p *= ROT(-a+0.25);\n  float n = 0.0;\n  float sc = 0.0;\n  float d = df(p, n, sc)*z;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3(n-0.25*d/sc, 0.5+0.5*d/sc, 1.0);\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: Simple circle tiling\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df(vec2 p, out float n, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 0.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d = circle(pp, 1.25*sz);\n  \n  n = fract(r);\n  sc = sz;\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  p += r*vec2(cos(a), sin(a));\n  p *= ROT(-a+0.25);\n  float n = 0.0;\n  float sc = 0.0;\n  float d = df(p, n, sc)*z;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3(n-0.25*d/sc, 0.5+0.5*d/sc, 1.0);\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: Adaptive tile sizes\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define DOT2(x)     dot(x, x)\n\nconst int max_iter = 6;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n    float a = p.x*p.x + p.y*p.y - 1.0;\n    return -a*a*a + 0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat shape(vec2 p) {\n  const float z = 1.6;\n  p /= z;\n  p *= ROT(TIME*0.25);\n  p.y += 0.58;\n  float d = heart(p)*z;\n  return d;\n}\n\nfloat df(vec2 p, out int ii, out bool inside) {\n  float aa = 3.0/RESOLUTION.y;\n\n  float sz = 0.9;\n  float ds = shape(p);\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  return box(pp, vec2(r-aa));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  int i;\n  bool inside;\n  float d = df(p, i, inside)*z;\n  float ds = shape(p)*z;\n  float ii = float(i)/float(max_iter);\n\n  if (!inside) d = abs(d)-aa;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3((inside ? 0.1 : 0.6) +1.1*ii, 0.7, sqrt(max(1.0-ii, 0.0)));\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: Adaptive tile sizes\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define DOT2(x)     dot(x, x)\n\nconst int max_iter = 6;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(DOT2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(DOT2(p-vec2(0.00,1.00)),\n                    DOT2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat shape(vec2 p) {\n  const float z = 1.6;\n  p /= z;\n  p *= ROT(TIME*0.25);\n  p.y += 0.58;\n  float d = heart(p)*z;\n  return d;\n}\n\nfloat df(vec2 p, out int ii, out bool inside) {\n  float aa = 3.0/RESOLUTION.y;\n\n  float sz = 0.9;\n  float ds = shape(p);\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  return box(pp, vec2(r-aa));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  int i;\n  bool inside;\n  float d = df(p, i, inside)*z;\n  float ds = shape(p)*z;\n  float ii = float(i)/float(max_iter);\n\n  if (!inside) d = abs(d)-aa;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3((inside ? 0.1 : 0.6) +1.1*ii, 0.7, sqrt(max(1.0-ii, 0.0)));\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The three bisectors of a triangle meet at a single point\n// which is also the point that is equidistant to the three\n// sides. And so, it's also the center of the incircle of\n// the triangle.\n\n\nvec2 triangleIncenter( in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float l0 = length(v2-v1);\n    float l1 = length(v0-v2);\n    float l2 = length(v1-v0);\n\n    return (v0*l0+v1*l1+v2*l2)/(l0+l1+l2);\n}\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n  return length(p-c)-r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat dot2( in vec2 a ) { return dot(a,a); }\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1-p0; vec2 v0 = p-p0;\n\tvec2 e1 = p2-p1; vec2 v1 = p-p1;\n\tvec2 e2 = p0-p2; vec2 v2 = p-p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot2(e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot2(e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot2(e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot2( pq0 ), cro(v0,e0) ),\n                       vec2( dot2( pq1 ), cro(v1,e1) )),\n                       vec2( dot2( pq2 ), cro(v2,e2) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tvec2 v0 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(0.0,2.0) );\n\tvec2 v1 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(1.5,3.0) );\n\tvec2 v2 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(4.0,1.0) );\n\n    // compute traingle SDF\n\tfloat dis = sdTriangle( v0, v1, v2, p );\n    \n    // compute triangle equicenter (yellow dot)\n    vec2 ce = triangleIncenter( v0, v1, v2 );\n\n    // draw triangle SDF\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(150.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n\n    // draw helped bisectors\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v0, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v1, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v2, ce )));\n    \n    // draw equicenter in yellow\n    col = mix(col,vec3(1.0,1.0,0.0),smoothstep(0.005,0.001,sdDisk(p,ce,0.02)));\n\n    // output\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The three bisectors of a triangle meet at a single point\n// which is also the point that is equidistant to the three\n// sides. And so, it's also the center of the incircle of\n// the triangle.\n\n\nvec2 triangleIncenter( in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float l0 = length(v2-v1);\n    float l1 = length(v0-v2);\n    float l2 = length(v1-v0);\n\n    return (v0*l0+v1*l1+v2*l2)/(l0+l1+l2);\n}\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat dot2( in vec2 a ) { return dot(a,a); }\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1-p0; vec2 v0 = p-p0;\n\tvec2 e1 = p2-p1; vec2 v1 = p-p1;\n\tvec2 e2 = p0-p2; vec2 v2 = p-p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot2(e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot2(e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot2(e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot2( pq0 ), cro(v0,e0) ),\n                       vec2( dot2( pq1 ), cro(v1,e1) )),\n                       vec2( dot2( pq2 ), cro(v2,e2) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tvec2 v0 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(0.0,2.0) );\n\tvec2 v1 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(1.5,3.0) );\n\tvec2 v2 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(4.0,1.0) );\n\n    // compute traingle SDF\n\tfloat dis = sdTriangle( v0, v1, v2, p );\n    \n    // compute triangle equicenter (yellow dot)\n    vec2 ce = triangleIncenter( v0, v1, v2 );\n\n    // draw triangle SDF\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(150.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n\n    // draw helped bisectors\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v0, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v1, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v2, ce )));\n    \n    // draw equicenter in yellow\n    col = mix(col,vec3(1.0,1.0,0.0),smoothstep(0.005,0.001,sdDisk(p,ce,0.02)));\n\n    // output\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The three bisectors of a triangle meet at a single point\n// which is also the point that is equidistant to the three\n// sides. And so, it's also the center of the incircle of\n// the triangle.\n\n\nvec2 triangleIncenter( in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float l0 = length(v2-v1);\n    float l1 = length(v0-v2);\n    float l2 = length(v1-v0);\n\n    return (v0*l0+v1*l1+v2*l2)/(l0+l1+l2);\n}\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b ) {\n    return a.x*b.y-a.y*b.x;\n}\nfloat dot2( in vec2 a ) { return dot(a,a); }\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1-p0; vec2 v0 = p-p0;\n\tvec2 e1 = p2-p1; vec2 v1 = p-p1;\n\tvec2 e2 = p0-p2; vec2 v2 = p-p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot2(e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot2(e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot2(e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot2( pq0 ), cro(v0,e0) ),\n                       vec2( dot2( pq1 ), cro(v1,e1) )),\n                       vec2( dot2( pq2 ), cro(v2,e2) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tvec2 v0 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(0.0,2.0) );\n\tvec2 v1 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(1.5,3.0) );\n\tvec2 v2 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(4.0,1.0) );\n\n    // compute traingle SDF\n\tfloat dis = sdTriangle( v0, v1, v2, p );\n    \n    // compute triangle equicenter (yellow dot)\n    vec2 ce = triangleIncenter( v0, v1, v2 );\n\n    // draw triangle SDF\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(150.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n\n    // draw helped bisectors\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v0, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v1, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v2, ce )));\n    \n    // draw equicenter in yellow\n    col = mix(col,vec3(1.0,1.0,0.0),smoothstep(0.005,0.001,sdDisk(p,ce,0.02)));\n\n    // output\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Signed distance to a 2D rounded square.\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel and moust coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate the square\n\tfloat si = 0.7 + 0.2*cos(1.2*iTime+0.0);\n    float ra = 0.3 - 0.2*cos(3.1*iTime+4.0);\n    ra = min(ra,si);\n\n    // draw the square \n\tfloat d = sdRoundSquare( p, si, ra );\n\n    // apply colors to it\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundSquare( m, si, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n  return vec2(\n    rvec.x * p.x - rvec.y * p.y,\n    rvec.x * p.y + rvec.y * p.x\n  );\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n  float c = cos(rvec.x), s = sin(rvec.x);\n  return vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    return (b - a).cross(p - a) >= 0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return (cross(p, a, b) >= 0) && (cross(p, b, c) >= 0) && (cross(p, c, a) >= 0);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n    return vec2( 0.25, 0.75 ) * fract( sin( float(z.x) * 12.9898 + float(z.y) * 78.233 ) * 43758.5453 );\n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(\n            texture2D(iChannel0, (ip+vec2(0.0,0.0))/256.0).x,\n            texture2D(iChannel0, (ip+vec2(1.0,0.0))/256.0).x,\n            u.x),\n        mix(\n            texture2D(iChannel0, (ip+vec2(0.0,1.0))/256.0).x,\n            texture2D(iChannel0, (ip+vec2(1.0,1.0))/256.0).x,\n            u.x),\n        u.y);\n    return res*res;\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n    return vec2(\n        texture2D(heightmap_texture, p).r,\n        texture2D(heightmap_texture, p + vec2(0.001, 0.001)).r - texture2D(heightmap_texture, p).r\n    );\n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( in vec2 p, in float r ) \n{\n  return length(p)-r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p )\n{ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0; p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n\tfloat r = pow(length(m) / 0.75, 3.5) * 0.75;\n\tfloat a = atan(m.x, m.y);\n    float v = sin(48.*(sqrt(r)-0.0625*a-.05*t));\n\treturn clamp(v,0.,1.);\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r =      abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.);    //green\n    float b = 2. - abs(hue * 6. - 4.);  //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //saturate\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p )\n{\n    p.x = abs(p.x);\n    p.y = p.y+p.x-1.0;\n    float m = -2.0*p.y;\n    p.x += m;\n    p.x = abs(p.x);\n    p.x -= 1.0;\n    return length(max(vec2(m,p.y),0.0)) + min(max(m,p.y),0.0);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n\tfloat r = pow(length(m) / 0.75, 3.5) * 0.75;\n\tfloat a = atan(m.x, m.y);\n    float v = sin(48.*(sqrt(r)-0.0625*a-.05*t));\n\treturn clamp(v,0.,1.);\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r =      abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.);    //green\n    float b = 2. - abs(hue * 6. - 4.);  //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //saturate\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p )\n{ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0; p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n\tfloat r = pow(length(m) / 0.75, 3.5) * 0.75;\n\tfloat a = atan(m.x, m.y);\n    float v = sin(48.*(sqrt(r)-0.0625*a-.05*t));\n\treturn clamp(v,0.,1.);\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r =      abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.);    //green\n    float b = 2. - abs(hue * 6. - 4.);  //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //saturate\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p )\n{ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0; p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n    float a = atan(m.y, m.x);\n    float r = length(m);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float x = r * s;\n    float y = r * c;\n    return length(vec2(x, y));\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r =      abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.);    //green\n    float b = 2. - abs(hue * 6. - 4.);  //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //saturate\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21"], ["// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p )\n{ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0; p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n\tfloat r = pow(length(m) / 0.75, 3.5) * 0.75;\n\tfloat a = atan(m.x, m.y);\n    float v = sin(48.*(sqrt(r)-0.0625*a-.05*t));\n\treturn clamp(v,0.,1.);\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersecting two line segments.\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    float d = cro(b2-a2,b1-a1);\n    float s = cro(a1-a2,b1-a1) / d;\n    float t = cro(a1-a2,b2-a2) / d;\n    point = a1 + (b1-a1)*t; // or point = a2 + (b2-a2)*s;\n    return s>=0.0 && t>=0.0 && t<=1.0 && s<=1.0;\n}\n\n/*\n// same math as above, alternative writing by mla (see comments)\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    vec2 st = inverse(mat2(b1-a1,a2-b2))*(a2-a1);\n    point = a1 + (b1-a1)*st.x;\n    return s>=0.0 && t>=0.0 && t<=1.0 && s<=1.0;\n    // alternative range test with single comparison\n    // st = abs(st-0.5); return max(st.x,st.y)<0.5;\n}\n*/\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // animate\n    vec2 a1 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.1+vec2(0.0,0.5)));\n    vec2 b1 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.2+vec2(5.0,2.0)));\n    vec2 a2 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.3+vec2(3.0,1.0)));\n    vec2 b2 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.4+vec2(1.5,4.5)));\n\n    // NDC coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3(0.15) - 0.04*length(p);\n\n    p *= 3.5;\n        \n    // segment 1\n    {\n    float    d = sdLine(p,a1,b1)-0.02;\n    d = min( d,  sdDisk(p,a1,0.06) );\n    d = min( d,  sdDisk(p,b1,0.06) );\n    col = mix(col, vec3(0.0,0.7,0.7), smoothstep(0.01,0.0,d) );\n    }\n    \n    // segment 2\n    {\n    float    d = sdLine(p,a2,b2)-0.02;\n    d = min( d,  sdDisk(p,a2,0.06) );\n    d = min( d,  sdDisk(p,b2,0.06) );\n    col = mix(col, vec3(0.2,0.5,1.0), smoothstep(0.01,0.0,d) );\n    }\n\n    // intersection\n    vec2 pos;\n    if( intersect(a1, b1, a2, b2, pos) )\n    {\n        float d = sdDisk(p,pos,0.03);\n        d = min( d, abs(d-0.2) ) - 0.01; // onion, see https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n        col = mix(col, vec3(1.0,0.7,0.0), smoothstep(0.01,0.0,d));\n    }    \n\n    // cheap dither (color banding removal)\n    col += (1.0/512.0)*sin(fragCoord.x*2.0+13.0*fragCoord.y);\n    \n    fragColor = vec4(col,1.0);\n}\n"],["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersecting two line segments.\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    float d = cro(b2-a2,b1-a1);\n    float s = cro(a1-a2,b1-a1) / d;\n    float t = cro(a1-a2,b2-a2) / d;\n    point = a1 + (b1-a1)*t; // or point = a2 + (b2-a2)*s;\n    return s>=0.0 && t>=0.0 && t<=1.0 && s<=1.0;\n}\n\n/*\n// same math as above, alternative writing by mla (see comments)\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    vec2 st = inverse(mat2(b1-a1,a2-b2))*(a2-a1);\n    point = a1 + (b1-a1)*st.x;\n    return s>=0.0 && t>=0.0 && t<=1.0 && s<=1.0;\n    // alternative range test with single comparison\n    // st = abs(st-0.5); return max(st.x,st.y)<0.5;\n}\n*/\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/(dot(ba,ba)),0.0, 1.0);\n    return length(pa-ba*h);\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // animate\n    vec2 a1 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.1+vec2(0.0,0.5)));\n    vec2 b1 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.2+vec2(5.0,2.0)));\n    vec2 a2 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.3+vec2(3.0,1.0)));\n    vec2 b2 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.4+vec2(1.5,4.5)));\n\n    // NDC coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3(0.15) - 0.04*length(p);\n\n    p *= 3.5;\n        \n    // segment 1\n    {\n    float    d = sdLine(p,a1,b1)-0.02;\n    d = min( d,  sdDisk(p,a1,0.06) );\n    d = min( d,  sdDisk(p,b1,0.06) );\n    col = mix(col, vec3(0.0,0.7,0.7), smoothstep(0.01,0.0,d) );\n    }\n    \n    // segment 2\n    {\n    float    d = sdLine(p,a2,b2)-0.02;\n    d = min( d,  sdDisk(p,a2,0.06) );\n    d = min( d,  sdDisk(p,b2,0.06) );\n    col = mix(col, vec3(0.2,0.5,1.0), smoothstep(0.01,0.0,d) );\n    }\n\n    // intersection\n    vec2 pos;\n    if( intersect(a1, b1, a2, b2, pos) )\n    {\n        float d = sdDisk(p,pos,0.03);\n        d = min( d, abs(d-0.2) ) - 0.01; // onion, see https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n        col = mix(col, vec3(1.0,0.7,0.0), smoothstep(0.01,0.0,d));\n    }    \n\n    // cheap dither (color banding removal)\n    col += (1.0/512.0)*sin(fragCoord.x*2.0+13.0*fragCoord.y);\n    \n    fragColor = vec4(col,1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a logarithmic spiral. It's inexact, mostly\n// noticeable when the number of rotations is small.\n\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float d = abs(mod(a,2.*k)-k)-.5;\n    return sqrt(d*d+r*r)/w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    // recenter\n    p -= vec2(0.2,-0.09);\n    m -= vec2(0.2,-0.09);\n    \n    // animation\n    float sw = 1.0;\n    float sk = 1.0 + 10.0*(0.5-0.5*cos(iTime+1.5));\n    \n    // distance\n    float d = sdSpiral(p, sw, sk);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(160.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdSpiral(m, sw, sk);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(-px, px, abs(length(p-m)-abs(d))-0.005));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(-px, px, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["// Copyright (c) 2021 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// -------------------------------------\n// Defines\n#define EPS                 1e-6\n#define PI                  3.14159265359\n#define INFINITY            1.0 / 0.0\n#define PLANET_RADIUS       6371000.0\n#define PLANET_CENTER       vec3(0, -PLANET_RADIUS, 0)\n#define ATMOSPHERE_HEIGHT   100000.0\n#define RAYLEIGH_HEIGHT     (ATMOSPHERE_HEIGHT * 0.08)\n#define MIE_HEIGHT          (ATMOSPHERE_HEIGHT * 0.012)\n\n// -------------------------------------\n// Coefficients\n#define C_RAYLEIGH          (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE               (vec3(3.996,  3.996,  3.996) * 1e-6)\n#define C_OZONE             (vec3(0.650,  1.881,  0.085) * 1e-6)\n\n#define ATMOSPHERE_DENSITY  1.0\n#define EXPOSURE            20.0\n\n// -------------------------------------\n// Math\nvec2 SphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\trayStart -= sphereCenter;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = 2.0 * dot(rayStart, rayDir);\n\tfloat c = dot(rayStart, rayStart) - (sphereRadius * sphereRadius);\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0)\n\t{\n\t\treturn vec2(-1);\n\t}\n\telse\n\t{\n\t\td = sqrt(d);\n\t\treturn vec2(-b - d, -b + d) / (2.0 * a);\n\t}\n}\nvec2 PlanetIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\nvec2 AtmosphereIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\n// -------------------------------------\n// Phase functions\nfloat PhaseRayleigh(float costh)\n{\n\treturn 3.0 * (1.0 + costh*costh) / (16.0 * PI);\n}\n\nfloat PhaseMie(float costh, float g)\n{\n\tg = min(g, 0.9381);\n\tfloat k = 1.55*g - 0.55*g*g*g;\n\tfloat kcosth = k*costh;\n\treturn (1.0 - k*k) / ((4.0 * PI) * (1.0-kcosth) * (1.0-kcosth));\n}\n\n// -------------------------------------\n// Atmosphere\nfloat AtmosphereHeight(vec3 positionWS)\n{\n\treturn distance(positionWS, PLANET_CENTER) - PLANET_RADIUS;\n}\nfloat DensityRayleigh(float h)\n{\n\treturn exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\nfloat DensityMie(float h)\n{\n\treturn exp(-max(0.0, h / MIE_HEIGHT));\n}\nfloat DensityOzone(float h)\n{\n\t// The ozone layer is represented as a tent function with a width of 30km, centered around an altitude of 25km.\n\treturn max(0.0, 1.0 - abs(h - 25000.0) / 15000.0);\n}\nvec3 AtmosphereDensity(float h)\n{\n\treturn vec3(DensityRayleigh(h), DensityMie(h), DensityOzone(h));\n}\n\n// Optical depth is a unitless measurement of the amount of absorption of a participating medium (such as the atmosphere).\n// This function calculates just that for our three atmospheric elements:\n// R: Rayleigh\n// G: Mie\n// B: Ozone\n// If you find the term \"optical depth\" confusing, you can think of it as \"how much density was found along the ray in total\".\nvec3 IntegrateOpticalDepth(vec3 rayStart, vec3 rayDir)\n{\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\tfloat  rayLength    = intersection.y;\n\n\tint    sampleCount  = 8;\n\tfloat  stepSize     = rayLength / float(sampleCount);\n\t\n\tvec3 opticalDepth = vec3(0);\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tvec3 localPosition = rayStart + rayDir * (float(i) + 0.5) * stepSize;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\t}\n\n\treturn opticalDepth;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{\n    return exp(-opticalDepth);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n\t// We can reduce the number of atmospheric samples required to converge by spacing them exponentially closer to the camera.\n\t// This breaks space view however, so let's compensate for that with an exponent that \"fades\" to 1 as we leave the atmosphere.\n\tfloat  rayHeight = AtmosphereHeight(rayStart);\n\tfloat  sampleDistributionExponent = 1.0 + clamp(1.0 - rayHeight / ATMOSPHERE_HEIGHT, 0.0, 1.0) * 8.0; // Slightly arbitrary max exponent of 9\n\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\trayLength = min(rayLength, intersection.y);\n\tif (intersection.x > 0.0)\n\t{\n\t\t// Advance ray to the atmosphere entry point\n\t\trayStart += rayDir * intersection.x;\n\t\trayLength -= intersection.x;\n\t}\n\n\tfloat  costh    = dot(rayDir, lightDir);\n\tfloat  phaseR   = PhaseRayleigh(costh);\n\tfloat  phaseM   = PhaseMie(costh, 0.85 /* Default */);\n\n\tint    sampleCount  = 64;\n\n\tvec3 opticalDepth = vec3(0);\n\tvec3 rayleigh     = vec3(0);\n\tvec3 mie          = vec3(0);\n\n\tfloat  prevRayTime  = 0.0;\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tfloat  rayTime = pow(float(i) / float(sampleCount), sampleDistributionExponent) * rayLength;\n\t\t// Because we are distributing the samples exponentially, we have to calculate the step size per sample.\n\t\tfloat  stepSize = (rayTime - prevRayTime);\n\n\t\tvec3 localPosition = rayStart + rayDir * rayTime;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\n\t\t// The atmospheric transmittance from rayStart to localPosition\n\t\tvec3 viewTransmittance = Absorb(opticalDepth);\n\n\t\tvec3 opticalDepthlight  = IntegrateOpticalDepth(localPosition, lightDir);\n\t\t// The atmospheric transmittance of light reaching localPosition\n\t\tvec3 lightTransmittance = Absorb(opticalDepthlight);\n\n\t\trayleigh += viewTransmittance * lightTransmittance * phaseR * localDensity.x * stepSize;\n\t\tmie      += viewTransmittance * lightTransmittance * phaseM * localDensity.y * stepSize;\n\n\t\tprevRayTime = rayTime;\n\t}\n\n\ttransmittance = Absorb(opticalDepth);\n\n\treturn (rayleigh * C_RAYLEIGH + mie * C_MIE) * lightColor * EXPOSURE;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //camera position\n    vec3 ray_start = vec3(0,0,0);\n    \n    vec2 mouse_vec = iMouse.xy/iResolution.xy;\n    \n    vec3 cam_dir = normalize(vec3(mouse_vec, 1.0));\n    vec3 u = normalize(cross(cam_dir, vec3(0., 1., 0.)));\n    vec3 v = cross(u, cam_dir);\n    float fdist = 0.3;\n    vec3 ray_dir = normalize(cam_dir*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n    \n    const float ray_length = 1000000000.0f;\n    vec3 light_dir = vec3(0.25,1,0);\n    vec3 light_color = vec3(1,1,1);\n    vec3 transmittance;\n    vec3 sky_color = IntegrateScattering(ray_start, ray_dir, ray_length, light_dir, light_color, transmittance);\n    \n    fragColor = vec4(sky_color,1);\n}"], ["// Copyright (c) 2021 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// -------------------------------------\n// Defines\n#define EPS                 1e-6\n#define PI                  3.14159265359\n#define INFINITY            1.0 / 0.0\n#define PLANET_RADIUS       6371000.0\n#define PLANET_CENTER       vec3(0, -PLANET_RADIUS, 0)\n#define ATMOSPHERE_HEIGHT   100000.0\n#define RAYLEIGH_HEIGHT     (ATMOSPHERE_HEIGHT * 0.08)\n#define MIE_HEIGHT          (ATMOSPHERE_HEIGHT * 0.012)\n\n// -------------------------------------\n// Coefficients\n#define C_RAYLEIGH          (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE               (vec3(3.996,  3.996,  3.996) * 1e-6)\n#define C_OZONE             (vec3(0.650,  1.881,  0.085) * 1e-6)\n\n#define ATMOSPHERE_DENSITY  1.0\n#define EXPOSURE            20.0\n\n// -------------------------------------\n// Math\nvec2 SphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\trayStart -= sphereCenter;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = 2.0 * dot(rayStart, rayDir);\n\tfloat c = dot(rayStart, rayStart) - (sphereRadius * sphereRadius);\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0)\n\t{\n\t\treturn vec2(-1);\n\t}\n\telse\n\t{\n\t\td = sqrt(d);\n\t\treturn vec2(-b - d, -b + d) / (2.0 * a);\n\t}\n}\nvec2 PlanetIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\nvec2 AtmosphereIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\n// -------------------------------------\n// Phase functions\nfloat PhaseRayleigh(float costh)\n{\n\treturn 3.0 * (1.0 + costh*costh) / (16.0 * PI);\n}\n\nfloat PhaseMie(float costh, float g)\n{\n\tg = min(g, 0.9381);\n\tfloat k = 1.55*g - 0.55*g*g*g;\n\tfloat kcosth = k*costh;\n\treturn (1.0 - k*k) / ((4.0 * PI) * (1.0-kcosth) * (1.0-kcosth));\n}\n\n// -------------------------------------\n// Atmosphere\nfloat AtmosphereHeight(vec3 positionWS)\n{\n\treturn distance(positionWS, PLANET_CENTER) - PLANET_RADIUS;\n}\nfloat DensityRayleigh(float h)\n{\n\treturn exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\nfloat DensityMie(float h)\n{\n\treturn exp(-max(0.0, h / MIE_HEIGHT));\n}\nfloat DensityOzone(float h)\n{\n\t// The ozone layer is represented as a tent function with a width of 30km, centered around an altitude of 25km.\n\treturn max(0.0, 1.0 - abs(h - 25000.0) / 15000.0);\n}\nvec3 AtmosphereDensity(float h)\n{\n\treturn vec3(DensityRayleigh(h), DensityMie(h), DensityOzone(h));\n}\n\n// Optical depth is a unitless measurement of the amount of absorption of a participating medium (such as the atmosphere).\n// This function calculates just that for our three atmospheric elements:\n// R: Rayleigh\n// G: Mie\n// B: Ozone\n// If you find the term \"optical depth\" confusing, you can think of it as \"how much density was found along the ray in total\".\nvec3 IntegrateOpticalDepth(vec3 rayStart, vec3 rayDir)\n{\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\tfloat  rayLength    = intersection.y;\n\n\tint    sampleCount  = 8;\n\tfloat  stepSize     = rayLength / float(sampleCount);\n\t\n\tvec3 opticalDepth = vec3(0);\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tvec3 localPosition = rayStart + rayDir * (float(i) + 0.5) * stepSize;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\t}\n\n\treturn opticalDepth;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{\n\t// Note that Mie results in slightly more light absorption than scattering, about 10%\n\treturn exp(-(opticalDepth.x * C_RAYLEIGH + opticalDepth.y * C_MIE * 1.1 + opticalDepth.z * C_OZONE) * ATMOSPHERE_DENSITY);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n    // Calculate the optical depth for the ray.\n    float opticalDepth = RayleighScatteringOpticalDepth(rayStart, rayDir, rayLength);\n\n    // Calculate the transmittance for the ray.\n    transmittance = exp(-opticalDepth * RayleighScatteringExtinctionCoefficient);\n\n    // Calculate the scattering for the ray.\n    return lightColor * opticalDepth * RayleighScatteringExtinctionCoefficient;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //camera position\n    vec3 ray_start = vec3(0,0,0);\n    \n    vec2 mouse_vec = iMouse.xy/iResolution.xy;\n    \n    vec3 cam_dir = normalize(vec3(mouse_vec, 1.0));\n    vec3 u = normalize(cross(cam_dir, vec3(0., 1., 0.)));\n    vec3 v = cross(u, cam_dir);\n    float fdist = 0.3;\n    vec3 ray_dir = normalize(cam_dir*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n    \n    const float ray_length = 1000000000.0f;\n    vec3 light_dir = vec3(0.25,1,0);\n    vec3 light_color = vec3(1,1,1);\n    vec3 transmittance;\n    vec3 sky_color = IntegrateScattering(ray_start, ray_dir, ray_length, light_dir, light_color, transmittance);\n    \n    fragColor = vec4(sky_color,1);\n}"], ["// Copyright(c) 2022 Bj\u00f6rn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst float softness_scale = 0.2; // controls softness of RGB clipping\nconst float offset = 0.75; // controls how colors desaturate as they brighten. 0 results in that colors never fluoresce, 1 in very saturated colors \nconst float chroma_scale = 1.2; // overall scale of chroma\n\nconst mat3 rec2020toSrgb = mat3(\n    1.6603034854, -0.5875701425, -0.0728900602,\n    -0.1243755953,  1.1328344814, -0.0083597372,\n    -0.0181122800, -0.1005836085,  1.1187703262);\n\nconst mat3 displayP3toSrgb = mat3(\n    1.2248021163, -0.2249112615, -0.0000475721,\n    -0.0419281049,  1.0420298967, -0.0000026429,\n    -0.0196088092, -0.0786321233,  1.0983153702);\n\nconst mat3 SrgbToSrgb = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    \nconst mat3 sourceColorSpaceToSrgb = SrgbToSrgb; // change for different input color space\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve(vec3 x)\n{\n    const float a = 0.2;\n    const float b = 0.4;\n    const float c = 0.8;\n    const float d = 1.2;\n    return clamp((x * (a * x + c * b) + d * c) / (x * (a * x + b) + d * a), 0.0, 1.0);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    \n    x = max(x, 0.0);\n    vec3 r = (x*(c*x + d) + e);\n    return (a*x*(d*x + 2.0*e) + b*(e - c*x*x))/(r*r);\n}\n\nvec3 tonemap_per_channel(vec3 c)\n{\n    return s_curve(c);\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c_smooth,x-c_smooth)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n\n    return sqrt(a*a + b*b);\n}\n\nvec2 calculateMC(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float M = findCenterAndPurity(lms).x; \n    \n    return vec2(M, calculateC(lms));\n}\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec2 MC = calculateMC(rgb);\n    vec2 STnew = vec2((MC.x)/MC.y, (1.0-MC.x)/MC.y);\n    STnew = (STnew + 3.0*STnew*STnew*MC.y);\n    \n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec2 MC = calculateMC(rgb);\n    float Cnew = (1.0/((ST.x/(MC.x)) + (ST.y/(1.0-MC.x))));\n\n    return max(MC.y/Cnew, scale);\n}\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\nvec3 tonemap_hue_preserving(vec3 c)\n{\n    mat3 toLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n        \n    mat3 fromLms = mat3(\n        +4.0767416621f , -3.3077115913, +0.2309699292,\n        -1.2684380046f , +2.6097574011, -0.3413193965,\n        -0.0041960863f , -0.7034186147, +1.7076147010);\n        \n    vec3 lms_ = c*toLms;\n    vec3 lms = sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n    \n    vec2 MP = findCenterAndPurity(lms);\n    \n    // apply tone curve\n    \n    // Approach 1: scale chroma based on derivative of chrome curve\n    if (true)\n    { \n        float I = (MP.x+(1.0-offset)*MP.y);\n        // Remove comment to see what the results are with Oklab L\n        //I = dot(lms, vec3(0.2104542553f, 0.7936177850f, - 0.0040720468f));\n        \n        lms = lms*I*I;\n        I = I*I*I;\n        vec3 dLms = lms - I;\n\n        float Icurve = s_curve(vec3(I)).x;\n        lms = 1.0f + chroma_scale*dLms*d_s_curve(vec3(I))/Icurve;     \n        I = pow(Icurve, 1.0/3.0);\n\n        lms = lms*I;\n    }\n    \n    // Approach 2: Separate color into a whiteness/blackness part, apply scale to them independendtly\n    if (false)\n    {\n        lms = chroma_scale*(lms - MP.x) + MP.x;\n    \n        float invBlackness = (MP.x+MP.y);\n        float whiteness = (MP.x-MP.y);\n        \n        float invBlacknessC = pow(s_curve(vec3(invBlackness*invBlackness*invBlackness)).x, 1.0/3.0);\n        float whitenessC = pow(s_curve(vec3(whiteness*whiteness*whiteness)).x, 1.0/3.0);\n        \n        lms = (invBlacknessC+whitenessC)/2.0 + (lms-(invBlackness+whiteness)/2.0)*(invBlacknessC-whitenessC)/(invBlackness-whiteness);\n    }\n    \n    \n    // compress to a smooth approximation of the target gamut\n    { \n        float M = findCenterAndPurity(lms).x;\n        vec2 ST = approximateShape(); // this can be precomputed, only depends on RGB gamut\n        float C_smooth_gamut = (1.0)/((ST.x/(M)) + (ST.y/(1.0-M)));\n        float C = calculateC(lms);\n\n        lms = (lms-M)/sqrt(C*C/C_smooth_gamut/C_smooth_gamut+1.0) + M;\n    }\n    \n    vec3 rgb = lms*lms*lms*fromLms;\n\n    return rgb;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    // not quite sure this mapping is easy to invert, but should be possible to construct similar ones that do\n    \n    float grey = 0.2;\n        \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n    \n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color;\n    \n    const int N = 8;\n    \n    float time = 0.125*iTime;\n    \n    for (int i = 0; i <= N; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            float fi = float(i)/float(N);\n            float fj = float(j)/float(N);\n        \n            float x = 1.5*(fi-0.5*fj-0.5);\n            float y = 1.5*sqrt(3.0)/2.0*(fj-0.5);            \n            vec2 xyd = vec2(x,y)-uv;\n            \n            float d = min(0.0006/dot(xyd,xyd),1.0);\n            \n            vec3 c = vec3(fi-fj, fj, 1.0-fi);\n                   \n            c = c*sourceColorSpaceToSrgb;\n\n            color += pow(2.0,-3.0*cos(2.0*3.14159*time))*d*c;\n        }\n    }\n    \n    color = tonemap_hue_preserving(color);\n    color = softClipColor(color);\n    \n    //color = tonemap_per_channel(color);\n  \n    \n    // highlight colors that clip if any\n    float diff = length(color - clamp(color, 0., 1.));\n    if(diff != 0.)\n        color = vec3(0.5,0.5,0.5);    \n    \n    \n    // Output to screen\n    fragColor = vec4(pow(color,vec3(1.0/2.2)),1.0);\n}"], ["// Copyright(c) 2022 Bj\u00f6rn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst float softness_scale = 0.2; // controls softness of RGB clipping\nconst float offset = 0.75; // controls how colors desaturate as they brighten. 0 results in that colors never fluoresce, 1 in very saturated colors \nconst float chroma_scale = 1.2; // overall scale of chroma\n\nconst mat3 rec2020toSrgb = mat3(\n    1.6603034854, -0.5875701425, -0.0728900602,\n    -0.1243755953,  1.1328344814, -0.0083597372,\n    -0.0181122800, -0.1005836085,  1.1187703262);\n\nconst mat3 displayP3toSrgb = mat3(\n    1.2248021163, -0.2249112615, -0.0000475721,\n    -0.0419281049,  1.0420298967, -0.0000026429,\n    -0.0196088092, -0.0786321233,  1.0983153702);\n\nconst mat3 SrgbToSrgb = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    \nconst mat3 sourceColorSpaceToSrgb = SrgbToSrgb; // change for different input color space\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = max(x, 0.0);\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 3.0 * x * (1.0 - x);\n}\n\nvec3 tonemap_per_channel(vec3 c)\n{\n    return s_curve(c);\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c_smooth,x-c_smooth)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n\n    return sqrt(a*a + b*b);\n}\n\nvec2 calculateMC(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float M = findCenterAndPurity(lms).x; \n    \n    return vec2(M, calculateC(lms));\n}\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec2 MC = calculateMC(rgb);\n    vec2 STnew = vec2((MC.x)/MC.y, (1.0-MC.x)/MC.y);\n    STnew = (STnew + 3.0*STnew*STnew*MC.y);\n    \n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec2 MC = calculateMC(rgb);\n    float Cnew = (1.0/((ST.x/(MC.x)) + (ST.y/(1.0-MC.x))));\n\n    return max(MC.y/Cnew, scale);\n}\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\nvec3 tonemap_hue_preserving(vec3 c)\n{\n    mat3 toLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n        \n    mat3 fromLms = mat3(\n        +4.0767416621f , -3.3077115913, +0.2309699292,\n        -1.2684380046f , +2.6097574011, -0.3413193965,\n        -0.0041960863f , -0.7034186147, +1.7076147010);\n        \n    vec3 lms_ = c*toLms;\n    vec3 lms = sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n    \n    vec2 MP = findCenterAndPurity(lms);\n    \n    // apply tone curve\n    \n    // Approach 1: scale chroma based on derivative of chrome curve\n    if (true)\n    { \n        float I = (MP.x+(1.0-offset)*MP.y);\n        // Remove comment to see what the results are with Oklab L\n        //I = dot(lms, vec3(0.2104542553f, 0.7936177850f, - 0.0040720468f));\n        \n        lms = lms*I*I;\n        I = I*I*I;\n        vec3 dLms = lms - I;\n\n        float Icurve = s_curve(vec3(I)).x;\n        lms = 1.0f + chroma_scale*dLms*d_s_curve(vec3(I))/Icurve;     \n        I = pow(Icurve, 1.0/3.0);\n\n        lms = lms*I;\n    }\n    \n    // Approach 2: Separate color into a whiteness/blackness part, apply scale to them independendtly\n    if (false)\n    {\n        lms = chroma_scale*(lms - MP.x) + MP.x;\n    \n        float invBlackness = (MP.x+MP.y);\n        float whiteness = (MP.x-MP.y);\n        \n        float invBlacknessC = pow(s_curve(vec3(invBlackness*invBlackness*invBlackness)).x, 1.0/3.0);\n        float whitenessC = pow(s_curve(vec3(whiteness*whiteness*whiteness)).x, 1.0/3.0);\n        \n        lms = (invBlacknessC+whitenessC)/2.0 + (lms-(invBlackness+whiteness)/2.0)*(invBlacknessC-whitenessC)/(invBlackness-whiteness);\n    }\n    \n    \n    // compress to a smooth approximation of the target gamut\n    { \n        float M = findCenterAndPurity(lms).x;\n        vec2 ST = approximateShape(); // this can be precomputed, only depends on RGB gamut\n        float C_smooth_gamut = (1.0)/((ST.x/(M)) + (ST.y/(1.0-M)));\n        float C = calculateC(lms);\n\n        lms = (lms-M)/sqrt(C*C/C_smooth_gamut/C_smooth_gamut+1.0) + M;\n    }\n    \n    vec3 rgb = lms*lms*lms*fromLms;\n\n    return rgb;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    // not quite sure this mapping is easy to invert, but should be possible to construct similar ones that do\n    \n    float grey = 0.2;\n        \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n    \n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color;\n    \n    const int N = 8;\n    \n    float time = 0.125*iTime;\n    \n    for (int i = 0; i <= N; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            float fi = float(i)/float(N);\n            float fj = float(j)/float(N);\n        \n            float x = 1.5*(fi-0.5*fj-0.5);\n            float y = 1.5*sqrt(3.0)/2.0*(fj-0.5);            \n            vec2 xyd = vec2(x,y)-uv;\n            \n            float d = min(0.0006/dot(xyd,xyd),1.0);\n            \n            vec3 c = vec3(fi-fj, fj, 1.0-fi);\n                   \n            c = c*sourceColorSpaceToSrgb;\n\n            color += pow(2.0,-3.0*cos(2.0*3.14159*time))*d*c;\n        }\n    }\n    \n    color = tonemap_hue_preserving(color);\n    color = softClipColor(color);\n    \n    //color = tonemap_per_channel(color);\n  \n    \n    // highlight colors that clip if any\n    float diff = length(color - clamp(color, 0., 1.));\n    if(diff != 0.)\n        color = vec3(0.5,0.5,0.5);    \n    \n    \n    // Output to screen\n    fragColor = vec4(pow(color,vec3(1.0/2.2)),1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a sphere cut by another sphere. Note\n// that doing the boolean subtration of a sphere from another\n// sphere using max() won't produce a correct Euclidean distance\n// than cab be used for rounding. This shape is basically a\n// revolution operator (https://www.shadertoy.com/view/4lyfzw)\n// applied to a moon (https://www.shadertoy.com/view/WtdBRS)\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec3 p = p2;\n    p.xz = abs(p.xz);\n    p.xz = p.xz - 2.0*min(0.0, min(p.x, p.z));\n    float d2 = length(p);\n    float d3 = max(0.0, d2 - rb);\n    float d4 = max(0.0, length(p.xz - vec2(d,0.0)) - rb);\n    float d5 = max(0.0, length(p.xz - vec2(0.0,d)) - rb);\n    float d6 = max(0.0, length(p.xz - vec2(d,d)) - rb);\n    float d7 = max(0.0, length(p.xz - vec2(0.0,-d)) - rb);\n    float d8 = max(0.0, length(p.xz - vec2(-d,0.0)) - rb);\n    float d9 = max(0.0, length(p.xz - vec2(-d,-d)) - rb);\n    float d10 = max(0.0, length(p.xz - vec2(0.0,d)) - rb);\n    float d11 = max(0.0, length(p.xz - vec2(d,0.0)) - rb);\n    float d12 = max(0.0, length(p.xz - vec2(d,d)) - rb);\n    float d13 = max(0.0, length(p.xz - vec2(0.0,-d)) - rb);\n    float d14 = max(0.0, length(p.xz - vec2(-d,0.0)) - rb);\n    float d15 = max(0.0, length(p.xz - vec2(-d,-d)) - rb);\n    float// incomplete generation!\n\nfloat map( in vec3 pos )\n{\n    float ra = 0.5;\n    float rb = 0.35+0.20*cos(iTime*1.1+4.0);\n    float di = 0.50+0.15*cos(iTime*1.7);\n    return sdDeathStar(pos, ra, rb, di );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.003, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 1.0*sin(0.38*iTime+3.0);\n\tvec3 ro = vec3( 1.0*cos(an), -0.1, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.57703);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a hollow sphere cut by a plane. Basically a\n// revolution operator (https://www.shadertoy.com/view/4lyfzw)\n// applied to a 2D arc (https://www.shadertoy.com/view/wl23RK)\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    float d = length(p) - r;\n    float d2 = length(p.xz) - r;\n    float d3 = length(p.xy) - r;\n    float d4 = length(p.yz) - r;\n    float d5 = length(p.yz - vec2(0.0, h)) - r;\n    float d6 = length(p.xz - vec2(0.0, h)) - r;\n    float d7 = length(p.xy - vec2(0.0, h)) - r;\n    float d8 = length(p.yz - vec2(h, 0.0)) - r;\n    float d9 = length(p.xz - vec2(h, 0.0)) - r;\n    float d10 = length(p.xy - vec2(h, 0.0)) - r;\n    float d11 = length(p.xz - vec2(0.0, h)) - r;\n    float d12 = length(p.xy - vec2(0.0, h)) - r;\n    float d13 = length(p.yz - vec2(0.0, h)) - r;\n    float d14 = length(p.xz - vec2(0.0, h)) - r;\n    float d15 = length(p.xy - vec2(0.0, h)) - r;\n    float d16 = length(p.yz - vec2(0.0, h)) - r;\n    float d17 = length(p.xz - vec2(0.0, h)) - r;\n    float d18 = length(p.xy - vec2(0.0, h)) - r;\n    float d19 = length(p.yz - vec2(0.0, h)) - r;\n    float d20 = length(p.xz - vec2(0.0, h)) - r;\n    float d21 = length(// incomplete generation!\n\nfloat map( in vec3 pos )\n{\n    pos.xy = (mat2(3,4,-4,3)/5.0)*pos.xy;\n    float r = 0.5;\n    float h = 0.2 + 0.2*cos(iTime*1.0);\n    float t = 0.01;\n    return sdCutHollowSphere(pos, r, h, t );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = sin(0.2*iTime);\n\tvec3 ro = vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.57703);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a hollow sphere cut by a plane. Basically a\n// revolution operator (https://www.shadertoy.com/view/4lyfzw)\n// applied to a 2D arc (https://www.shadertoy.com/view/wl23RK)\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat map( in vec3 pos )\n{\n    pos.xy = (mat2(3,4,-4,3)/5.0)*pos.xy;\n    float r = 0.5;\n    float h = 0.2 + 0.2*cos(iTime*1.0);\n    float t = 0.01;\n    return sdCutHollowSphere(pos, r, h, t );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float ph = 1e10; // precision holder\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*tmin );\n        if( h<0.001 ) return 0.0;\n        float d = h/ph;\n        res = min( res, k*d/ph );\n        ph = h;\n        tmin += h;\n        if( h<0.01 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = sin(0.2*iTime);\n\tvec3 ro = vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.57703);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a sphere cut by a plane. Beware doing the max() of\n// a sphere and a plane won't produce an exact Euclidean distance.\n// Based on sdCutDisk(): https://www.shadertoy.com/view/ftVXRc\n//\n// It is a useful primitive when combined with rounding/inflating, which\n// cannot be done with the non-Euclidean max() approach, since you can do\n// things like mushroom heads.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    float d = length(p) - r;\n    float s = p.y - h;\n    float k = d*d - s*s;\n    return k < 0.0? s : sqrt(k);\n}\n\nfloat map( in vec3 pos )\n{\n    if( sin(iTime*0.8)>-0.1 )\n    {\n    pos.yz = (mat2(-4,3,-3,-4)/5.0)*pos.yz;\n    return sdCutSphere(pos, 0.5, -0.2 );\n    }\n    else\n    {\n    pos.y += 0.1;\n    float d = sdCutSphere(pos, 0.5, 0.2 ) - 0.1;\n    return min( d, max(length(pos.xz)-0.15,pos.y-0.2) );\n    }\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.8*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a sphere cut by a plane. Beware doing the max() of\n// a sphere and a plane won't produce an exact Euclidean distance.\n// Based on sdCutDisk(): https://www.shadertoy.com/view/ftVXRc\n//\n// It is a useful primitive when combined with rounding/inflating, which\n// cannot be done with the non-Euclidean max() approach, since you can do\n// things like mushroom heads.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\nfloat map( in vec3 pos )\n{\n    if( sin(iTime*0.8)>-0.1 )\n    {\n    pos.yz = (mat2(-4,3,-3,-4)/5.0)*pos.yz;\n    return sdCutSphere(pos, 0.5, -0.2 );\n    }\n    else\n    {\n    pos.y += 0.1;\n    float d = sdCutSphere(pos, 0.5, 0.2 ) - 0.1;\n    return min( d, max(length(pos.xz)-0.15,pos.y-0.2) );\n    }\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0)*0.5773;\n    return normalize( e.xyy*f( pos + e.xyy ) +\n                      e.yyx*f( pos + e.yyx ) +\n                      e.yxy*f( pos + e.yxy ) +\n                      e.xxx*f( pos + e.xxx ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.8*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk that's been clipped by a line\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n// r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    vec2 q = vec2(length(p),p.y);\n    q.x = abs(q.x-r);\n    float d = length(max(q,0.0));\n    d = min(d,abs(q.y-h));\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n   \n    // animation\n    float ra = 0.75;\n    float he = ra*clamp(cos(iTime*0.8),-0.999999,0.999999);\n   \n    // distance\n    float d = sdCutDisk(p,ra,he);\n   \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(128.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // interactivity\n    if( iMouse.z>0.001 )\n    {\n    d = sdCutDisk(m,ra,he);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//returns a vector pointing in the direction of the closest neighbouring cell\n\n#define saturate(a) (clamp((a),0.,1.))\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\n\n\nfloat tick (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return i + r;\n}\n\nfloat tock (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n  \n    \n    return i + r;\n}\n\nfloat ball;\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nvec3 randomdir (float n) {\n    return fract(vec3(5.1283,9.3242,13.8381) * hash(n) * 8421.4242);\n}\nfloat glow = 0.;\nfloat sph(vec3 p,float r) {\n    return length(p) -r ;\n}\nfloat map(vec3 p) {\n\n    //geo\n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    // wierd skylights\n    q.xy *= rot(q.z/10.);\n    q.x += tt * 10.;\n    q = mod( q, 16.) - 8.;\n  \n    float uu = sph(q,.00001);\n    glow += .1/(.1+pow(uu,2.));\n    \n    float domain = 1.5;\n  ;\n   \n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.1);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n   \n    //vec3 flit = randomdir(hash31(id)) * .2;\n    \n    \n    vec3 jitter = flit * sin((tt*9.1+rando*12.1));\n  \n    \n   \n    \n    //(.5)hash(float(id)) * vec3(.5) * sin(iTime*6.+3.*hash(float(id)));\n    \n    if (  rando *.6< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p + jitter, vec3(.4));\n      \n        return min(uu,u*.5);\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p + jitter, vec3(.4));\n       \n        return min(uu,u*.5);\n    }\n \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\n\nconst float PI = acos(-1.);\n\nvec3 pixel_color(vec2 uv) {\n   \n  // nav\n\n    float tt = iTime ;\n    vec3 jump = vec3(1) * tick(tt*.05)*77.2;\n    jump.xz *= rot(tt*.00001);\n  \n    \n    vec3 s = vec3(10.,3.2,7.1)*tt*.18 + jump;\n    vec3 arm = vec3(1,0,0);\n    arm.xz *= rot(sin(tt* .19));\n    arm.yz *= rot(sin(tt*.23));\n    //arm.yx *= rot(sin(tt*.28));\n    \n    vec3 t = s + arm;\n    \n \n \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  cz -= dot(uv,uv)/15.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n    \n    vec3 p = s;\n    bool hit = false;\n  \n    float d;\n    float i;\n    float dd = 0.;\n    //ray marching\n    for ( i = 0.; i < 800.; i++) {\n        \n        d = map(p);\n        d = abs(d);\n        if ( d < .001) {\n           hit = true;\n           break;\n        }\n        if (dd>1000.) { break;}\n        \n        dd += d;\n        p+=d*r;\n    }\n\n \n \n  \n  vec3 col = vec3(.8, .5, .2);\n  col = vec3(.1,.1,.2)*1.;\n\n  \n  float ao = pow(1. - i/500.,1.);\n  col *= ao;\n  col += glow*.6;\n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n // if ( dot(light,n) < 0.) { light = -light;}\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n   float diff = max(0., dot(n,light)*.5 +.5);\n   col *= diff;\n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 1.03E-2) );\n\n\n  float edge = saturate(length(n1-n2)/0.1);\n  \n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n\n  return col; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    fragColor += vec4(pixel_color(uv), 1.);\n  \tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}\n\n/*\n  \n  //float uniformity = (sin(iTime*.01)*.5 + .5) * 10. + 5.;\n  float uniformity = 15.;\n  vec3 hue = 1.-sin(p/uniformity);\n\n  vec3 light =normalize(vec3(60,10,10));\n  if ( dot(light,n) < 0.) { light = -light;}\n\n  float diff = max(0., dot(n,light)*.5 +.5);\n \n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  vec3 fog = vec3(0);\n \n // vec3 col = mix(spec * 0.2 + hue * ( diff ),fog, min(fren,.8));\n  vec3 col = mix(spec * 0.2 + hue * ( diff ),fog,.5);\n  \n  col = mix(col,fog,1. - exp(-.000003*dd*dd*dd));\n*/"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//returns a vector pointing in the direction of the closest neighbouring cell\n\n#define saturate(a) (clamp((a),0.,1.))\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float s = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += s*noise( p );\n        p = p*2.0 + vec3( 0.0, 0.0, 0.0 );\n        s *= 0.5;\n    }\n    return f;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\n\n\nfloat tick (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return i + r;\n}\n\nfloat tock (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n  \n    \n    return i + r;\n}\n\nfloat ball;\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nvec3 randomdir (float n) {\n    return fract(vec3(5.1283,9.3242,13.8381) * hash(n) * 8421.4242);\n}\nfloat glow = 0.;\nfloat sph(vec3 p,float r) {\n    return length(p) -r ;\n}\nfloat map(vec3 p) {\n\n    //geo\n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    // wierd skylights\n    q.xy *= rot(q.z/10.);\n    q.x += tt * 10.;\n    q = mod( q, 16.) - 8.;\n  \n    float uu = sph(q,.00001);\n    glow += .1/(.1+pow(uu,2.));\n    \n    float domain = 1.5;\n  ;\n   \n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.1);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n   \n    //vec3 flit = randomdir(hash31(id)) * .2;\n    \n    \n    vec3 jitter = flit * sin((tt*9.1+rando*12.1));\n  \n    \n   \n    \n    //(.5)hash(float(id)) * vec3(.5) * sin(iTime*6.+3.*hash(float(id)));\n    \n    if (  rando *.6< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p + jitter, vec3(.4));\n      \n        return min(uu,u*.5);\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p + jitter, vec3(.4));\n       \n        return min(uu,u*.5);\n    }\n \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\n\nconst float PI = acos(-1.);\n\nvec3 pixel_color(vec2 uv) {\n   \n  // nav\n\n    float tt = iTime ;\n    vec3 jump = vec3(1) * tick(tt*.05)*77.2;\n    jump.xz *= rot(tt*.00001);\n  \n    \n    vec3 s = vec3(10.,3.2,7.1)*tt*.18 + jump;\n    vec3 arm = vec3(1,0,0);\n    arm.xz *= rot(sin(tt* .19));\n    arm.yz *= rot(sin(tt*.23));\n    //arm.yx *= rot(sin(tt*.28));\n    \n    vec3 t = s + arm;\n    \n \n \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  cz -= dot(uv,uv)/15.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n    \n    vec3 p = s;\n    bool hit = false;\n  \n    float d;\n    float i;\n    float dd = 0.;\n    //ray marching\n    for ( i = 0.; i < 800.; i++) {\n        \n        d = map(p);\n        d = abs(d);\n        if ( d < .001) {\n           hit = true;\n           break;\n        }\n        if (dd>1000.) { break;}\n        \n        dd += d;\n        p+=d*r;\n    }\n\n \n \n  \n  vec3 col = vec3(.8, .5, .2);\n  col = vec3(.1,.1,.2)*1.;\n\n  \n  float ao = pow(1. - i/500.,1.);\n  col *= ao;\n  col += glow*.6;\n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n // if ( dot(light,n) < 0.) { light = -light;}\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n   float diff = max(0., dot(n,light)*.5 +.5);\n   col *= diff;\n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 1.03E-2) );\n\n\n  float edge = saturate(length(n1-n2)/0.1);\n  \n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n\n  return col; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    fragColor += vec4(pixel_color(uv), 1.);\n  \tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}\n\n/*\n  \n  //float uniformity = (sin(iTime*.01)*.5 + .5) * 10. + 5.;\n  float uniformity = 15.;\n  vec3 hue = 1.-sin(p/uniformity);\n\n  vec3 light =normalize(vec3(60,10,10));\n  if ( dot(light,n) < 0.) { light = -light;}\n\n  float diff = max(0., dot(n,light)*.5 +.5);\n \n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  vec3 fog = vec3(0);\n \n // vec3 col = mix(spec * 0.2 + hue * ( diff ),fog, min(fren,.8));\n  vec3 col = mix(spec * 0.2 + hue * ( diff ),fog,.5);\n  \n  col = mix(col,fog,1. - exp(-.000003*dd*dd*dd));\n*/"], ["//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//returns a vector pointing in the direction of the closest neighbouring cell\n\n#define saturate(a) (clamp((a),0.,1.))\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\n\n\nfloat tick (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return i + r;\n}\n\nfloat tock (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n  \n    \n    return i + r;\n}\n\nfloat ball;\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n    float h = dot(p3, vec3(127.1, 311.7, 741.2));\n    return fract(sin(h) * 43758.5453123);\n}\nvec3 randomdir (float n) {\n    return fract(vec3(5.1283,9.3242,13.8381) * hash(n) * 8421.4242);\n}\nfloat glow = 0.;\nfloat sph(vec3 p,float r) {\n    return length(p) -r ;\n}\nfloat map(vec3 p) {\n\n    //geo\n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    // wierd skylights\n    q.xy *= rot(q.z/10.);\n    q.x += tt * 10.;\n    q = mod( q, 16.) - 8.;\n  \n    float uu = sph(q,.00001);\n    glow += .1/(.1+pow(uu,2.));\n    \n    float domain = 1.5;\n  ;\n   \n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.1);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n   \n    //vec3 flit = randomdir(hash31(id)) * .2;\n    \n    \n    vec3 jitter = flit * sin((tt*9.1+rando*12.1));\n  \n    \n   \n    \n    //(.5)hash(float(id)) * vec3(.5) * sin(iTime*6.+3.*hash(float(id)));\n    \n    if (  rando *.6< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p + jitter, vec3(.4));\n      \n        return min(uu,u*.5);\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p + jitter, vec3(.4));\n       \n        return min(uu,u*.5);\n    }\n \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\n\nconst float PI = acos(-1.);\n\nvec3 pixel_color(vec2 uv) {\n   \n  // nav\n\n    float tt = iTime ;\n    vec3 jump = vec3(1) * tick(tt*.05)*77.2;\n    jump.xz *= rot(tt*.00001);\n  \n    \n    vec3 s = vec3(10.,3.2,7.1)*tt*.18 + jump;\n    vec3 arm = vec3(1,0,0);\n    arm.xz *= rot(sin(tt* .19));\n    arm.yz *= rot(sin(tt*.23));\n    //arm.yx *= rot(sin(tt*.28));\n    \n    vec3 t = s + arm;\n    \n \n \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  cz -= dot(uv,uv)/15.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n    \n    vec3 p = s;\n    bool hit = false;\n  \n    float d;\n    float i;\n    float dd = 0.;\n    //ray marching\n    for ( i = 0.; i < 800.; i++) {\n        \n        d = map(p);\n        d = abs(d);\n        if ( d < .001) {\n           hit = true;\n           break;\n        }\n        if (dd>1000.) { break;}\n        \n        dd += d;\n        p+=d*r;\n    }\n\n \n \n  \n  vec3 col = vec3(.8, .5, .2);\n  col = vec3(.1,.1,.2)*1.;\n\n  \n  float ao = pow(1. - i/500.,1.);\n  col *= ao;\n  col += glow*.6;\n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n // if ( dot(light,n) < 0.) { light = -light;}\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n   float diff = max(0., dot(n,light)*.5 +.5);\n   col *= diff;\n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 1.03E-2) );\n\n\n  float edge = saturate(length(n1-n2)/0.1);\n  \n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n\n  return col; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    fragColor += vec4(pixel_color(uv), 1.);\n  \tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}\n\n/*\n  \n  //float uniformity = (sin(iTime*.01)*.5 + .5) * 10. + 5.;\n  float uniformity = 15.;\n  vec3 hue = 1.-sin(p/uniformity);\n\n  vec3 light =normalize(vec3(60,10,10));\n  if ( dot(light,n) < 0.) { light = -light;}\n\n  float diff = max(0., dot(n,light)*.5 +.5);\n \n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  vec3 fog = vec3(0);\n \n // vec3 col = mix(spec * 0.2 + hue * ( diff ),fog, min(fren,.8));\n  vec3 col = mix(spec * 0.2 + hue * ( diff ),fog,.5);\n  \n  col = mix(col,fog,1. - exp(-.000003*dd*dd*dd));\n*/"], ["// Created by Jack Akers on February 22, 2022.\n// Made available under the CC0 license - https://creativecommons.org/publicdomain/zero/1.0/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n    vec2 uv4 = fragCoord.xy / iResolution.xy;\n    vec2 uv5 = fragCoord.xy / iResolution.xy;\n    vec2 uv6 = fragCoord.xy / iResolution.xy;\n    vec2 uv7 = fragCoord.xy / iResolution.xy;\n    vec2 uv8 = fragCoord.xy / iResolution.xy;\n    vec2 uv9 = fragCoord.xy / iResolution.xy;\n    vec2 uv10 = fragCoord.xy / iResolution.xy;\n    vec2 uv11 = fragCoord.xy / iResolution.xy;\n    vec2 uv12 = fragCoord.xy / iResolution.xy;\n    vec2 uv13 = fragCoord.xy / iResolution.xy;\n    vec2 uv14 = fragCoord.xy / iResolution.xy;\n    vec2 uv15 = fragCoord.xy / iResolution.xy;\n    vec2 uv16 = fragCoord.xy / iResolution.xy;\n    vec2 uv17 = fragCoord.xy / iResolution.xy;\n    vec2 uv18 = fragCoord.xy / iResolution.xy;\n    vec2 uv19 = fragCoord.xy / iResolution.xy;\n    vec2 uv20 = fragCoord.xy / iResolution.xy;\n    vec2 uv21 = fragCoord.xy / iResolution.xy;\n    vec2 uv22 = fragCoord.xy / iResolution.xy;\n    vec2 uv23 = fragCoord.xy / iResolution.xy// incomplete generation!"], ["// License CC0: Into the techno dome\n// A simple extension of \"Follow the Light\" I made earlier.\n// The tunnel forks and the fork is picked randomly.\n// Thought it turned out nice.\n// Based on: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 70\n#define NORM_OFF        0.0001\n#define PCOS(x)         (0.5 + 0.5*cos(x))\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n    return fract(sin(co*12.9898)*43758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat fractal(vec3 pos) {\n  vec3 tpos =pos;\n  const float sz = 6.0;\n  tpos.z    = abs(0.5*sz-mod(tpos.z, sz));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif\n\n  // Splits the tunnel\n  const float splitDist = 50.0;\n  float mz = mod(p.z, splitDist);\n  float n  = floor(p.z/splitDist);\n  float h  = hash(n);\n  float off = 1.75*smoothstep(15.0, 35.0, mz);\n\n  p.x -= h>0.5 ? off : -off;\n  p.x = abs(p.x);\n  p.x -= 1.0+off;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  return fractal(p); \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = cam(ro.z+10.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float dm  = 4.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0), 1.0);  \n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.75, 2.25, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.2, 1.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.75, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*06.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) {\n    return t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n"], ["// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) {\n    return pow(c, vec3(1.0/2.2));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n"], ["// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n"], ["// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 > dbuffer) return -1.0;\n    if (t2 < dbuffer) return -1.0;\n    return min(t1, t2);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n"], ["// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  float t = iTime * 0.1;\n  float r = 0.0;\n  float s = 1.0;\n  for (int i = 0; i < 10; i++) {\n    r += s * abs(p.x) * 0.5;\n    p = abs(p) * 2.0 - vec4(1.0, 1.0, 1.0, 0.0);\n    s *= 0.5;\n  }\n  return vec4(r);\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgEllipsoid() returns the approximated ellipsoid SDF and\n// the exact normalized gradient/normal of the ellipsoid, by \n// computing it analytically. This means the normal to\n// the ellipsoid surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:     https://www.shadertoy.com/view/wtcfzM\n// Capsule:   https://www.shadertoy.com/view/WttfR7\n// Ellipsoid: https://www.shadertoy.com/view/flXyRS\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r )\n{\n  p = abs(p);\n  float d = length(p - r);\n  float a = dot(p,r);\n  float b = dot(p,p);\n  float c = dot(r,r);\n  float k = sqrt(a*a + b*c - a*b);\n  float e = (a - k) / (b - c);\n  float f = sqrt(1.0 - e*e);\n  float g = (a - e*b) / (c - e*e);\n  float h = sqrt(1.0 - g*g);\n  float s = (a - e*b) * (c - e*e);\n  float t = (a - k) * (b - c);\n  float u = (a - e*b) * (c - e*e) + (a - k) * (b - c);\n  float v = (a - e*b) * (c - e*e) - (a - k) * (b - c);\n  float w = (a - e*b) * (c - e*e) - (a - k) * (b - c);\n  float x = (a - e*b) * (c - e*e) + (a - k) * (b - c);\n  float y = (a - e*b) * (c - e*e) - (a - k) * (b - c);\n  float z = (a - e*b) * (c - e*e) - (a - k) * (b - c);\n  return vec4(d, f*h, g*h, f*h) * sign(vec4(s, t, u// incomplete generation!\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    vec3 ra = vec3(0.8,0.1,0.5);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgEllipsoid(pos,ra).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgEllipsoid(pos,ra).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgEllipsoid( pos + e.xyy*eps, ra ).x + \n                             e.yyx*sdgEllipsoid( pos + e.yyx*eps, ra ).x + \n                             e.yxy*sdgEllipsoid( pos + e.yxy*eps, ra ).x + \n                             e.xxx*sdgEllipsoid( pos + e.xxx*eps, ra ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// License CC0: Voronoi Glass Panes\n//  Tinkering with the voronoi pattern from a Shane shader on saturday evening\n//  Kind of hackish overall but that never stopped me from sharing a shader before\n//  Shane shader, it's worth a look: https://www.shadertoy.com/view/Mld3Rn\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PI_2        (0.5*3.141592654)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\nconst float planeDist = 1.0-0.25;\n\nfloat g_hmul = 1.0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float zoomOuter = 1.0;\nconst float zoomInner = 0.2;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n    vec4 res = front + back * (1.0 - front.a);\n    res.a = front.a + back.a * (1.0 - front.a);\n    return res;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r ) {\n  const vec3 k  = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 scol = HSV2RGB(vec3(0.1, 0.25, 0.9));\n  return scol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nfloat voronoi2(vec2 p){\n  vec2 g = floor(p), o; p -= g;\n  \n  vec3 d = vec3(1);\n    \n  for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n      d.z = dot(o, o); \n      d.y = max(d.x, min(d.y, d.z));\n      d.x = min(d.x, d.z); \n    }\n  }\n  \n  return max(d.y/1.2 - d.x, 0.0)/1.2;\n}\n\nfloat hf2(vec2 p) {\n  const float zo = zoomOuter;\n  const float zi = zoomInner;\n  \n  p /= zo;\n  p /= zi;\n  \n  float d = -voronoi2(p);\n  d *= zi*zo;\n  \n  float h = 0.2*tanh_approx(3.0*smoothstep(0.0, 1.0*zo*zi, -d));\n  \n  return h*zo*zi;\n}\n\nfloat height(vec2 p) {\n  return -hf2(p)*g_hmul;\n}\n\nvec3 normal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = height(p + e.yx) - height(p - e.yx);\n  n.z = -2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec4 plane(vec3 pro, vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n_, out vec3 pnor) {\n  float h0 = hash(n_);\n  float h1 = fract(7793.0*h0);\n  float h2 = fract(6337.0*h0);\n  \n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  const float s = 1.0;\n  vec3 lp1 = vec3(5.0,  1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  vec3 lp2 = vec3(-5.0, 1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  const float hsz = 0.2;\n  float hd = hex(p.yx, hsz);\n\n  g_hmul = smoothstep(0.0, 0.125, (hd-hsz/2.0));\n\n  p += vec2(h0,h1)*20.0;\n  p *= mix(0.5, 1.0, h2);\n  float he  = height(p);\n  vec3  nor = normal(p,2.0*aa);\n  vec3 po   = pp;\n\n  pnor = nor;\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(nor, ld1), 0.0);\n  float diff2 = max(dot(nor, ld2), 0.0);\n  diff1 = ld1.z*nor.z;;\n\n  vec3  ref   = reflect(rd, nor);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 mat   = HSV2RGB(vec3(0.55, 0.45, 0.05));\n  const vec3 lcol1 = HSV2RGB(vec3(0.6, 0.5, 0.9));\n  const vec3 lcol2 = HSV2RGB(vec3(0.1, 0.65, 0.9));\n  \n  float hf = smoothstep(0.0, 0.0002, -he);\n  vec3 lpow1 = 1.0*lcol1/DOT2(ld1);\n  vec3 lpow2 = 1.0*lcol2/DOT2(ld2);\n  vec3 col = vec3(0.0);\n  col += hf*mat*diff1*diff1*lpow1;\n  col += hf*mat*diff2*diff2*lpow2;\n  float spes = 20.0;\n  col += pow(ref1, spes)*lcol1;\n  col += pow(ref2, spes)*lcol2;\n\n  float t = 1.0;\n  t *= smoothstep(aa, -aa, -(hd-hsz/4.0));\n  t *= mix(1.0, 0.75, hf);\n  \n  return vec4(col, t);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 pro, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = 2.0+tanh_approx(length(0.25*p));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 5;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.98;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec3 pnor = vec3(0.0);\n      vec4 pcol = plane(pro, ro, rd, pp, off, aa, nz+float(i), pnor);\n      \n      vec3 refr = refract(rd, pnor, 1.0-0.075);\n      if (pcol.w > (1.0-cutOff)&&refr != vec3(0.0)) {\n        rd = refr;\n      }\n\n      float dz = pp.z-ro.z;\n      const float fi = -0.; \n      float fadeIn = smoothstep(planeDist*(float(furthest)+fi), planeDist*(float(fadeFrom)-fi), dz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, dz);\n      pcol.w *= fadeOut*fadeIn;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float z   = 0.33*planeDist*TIME;\n  vec3 pro  = offset(z-1.0);\n  vec3 ro   = offset(z);\n  vec3 dro  = doffset(z);\n  vec3 ddro = ddoffset(z);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, pro, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Voronoi Glass Panes\n//  Tinkering with the voronoi pattern from a Shane shader on saturday evening\n//  Kind of hackish overall but that never stopped me from sharing a shader before\n//  Shane shader, it's worth a look: https://www.shadertoy.com/view/Mld3Rn\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PI_2        (0.5*3.141592654)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\nconst float planeDist = 1.0-0.25;\n\nfloat g_hmul = 1.0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float zoomOuter = 1.0;\nconst float zoomInner = 0.2;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return front.a * front.rgb + (1.0 - front.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r ) {\n  const vec3 k  = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 scol = HSV2RGB(vec3(0.1, 0.25, 0.9));\n  return scol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nfloat voronoi2(vec2 p){\n  vec2 g = floor(p), o; p -= g;\n  \n  vec3 d = vec3(1);\n    \n  for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n      d.z = dot(o, o); \n      d.y = max(d.x, min(d.y, d.z));\n      d.x = min(d.x, d.z); \n    }\n  }\n  \n  return max(d.y/1.2 - d.x, 0.0)/1.2;\n}\n\nfloat hf2(vec2 p) {\n  const float zo = zoomOuter;\n  const float zi = zoomInner;\n  \n  p /= zo;\n  p /= zi;\n  \n  float d = -voronoi2(p);\n  d *= zi*zo;\n  \n  float h = 0.2*tanh_approx(3.0*smoothstep(0.0, 1.0*zo*zi, -d));\n  \n  return h*zo*zi;\n}\n\nfloat height(vec2 p) {\n  return -hf2(p)*g_hmul;\n}\n\nvec3 normal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = height(p + e.yx) - height(p - e.yx);\n  n.z = -2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec4 plane(vec3 pro, vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n_, out vec3 pnor) {\n  float h0 = hash(n_);\n  float h1 = fract(7793.0*h0);\n  float h2 = fract(6337.0*h0);\n  \n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  const float s = 1.0;\n  vec3 lp1 = vec3(5.0,  1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  vec3 lp2 = vec3(-5.0, 1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  const float hsz = 0.2;\n  float hd = hex(p.yx, hsz);\n\n  g_hmul = smoothstep(0.0, 0.125, (hd-hsz/2.0));\n\n  p += vec2(h0,h1)*20.0;\n  p *= mix(0.5, 1.0, h2);\n  float he  = height(p);\n  vec3  nor = normal(p,2.0*aa);\n  vec3 po   = pp;\n\n  pnor = nor;\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(nor, ld1), 0.0);\n  float diff2 = max(dot(nor, ld2), 0.0);\n  diff1 = ld1.z*nor.z;;\n\n  vec3  ref   = reflect(rd, nor);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 mat   = HSV2RGB(vec3(0.55, 0.45, 0.05));\n  const vec3 lcol1 = HSV2RGB(vec3(0.6, 0.5, 0.9));\n  const vec3 lcol2 = HSV2RGB(vec3(0.1, 0.65, 0.9));\n  \n  float hf = smoothstep(0.0, 0.0002, -he);\n  vec3 lpow1 = 1.0*lcol1/DOT2(ld1);\n  vec3 lpow2 = 1.0*lcol2/DOT2(ld2);\n  vec3 col = vec3(0.0);\n  col += hf*mat*diff1*diff1*lpow1;\n  col += hf*mat*diff2*diff2*lpow2;\n  float spes = 20.0;\n  col += pow(ref1, spes)*lcol1;\n  col += pow(ref2, spes)*lcol2;\n\n  float t = 1.0;\n  t *= smoothstep(aa, -aa, -(hd-hsz/4.0));\n  t *= mix(1.0, 0.75, hf);\n  \n  return vec4(col, t);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 pro, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = 2.0+tanh_approx(length(0.25*p));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 5;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.98;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec3 pnor = vec3(0.0);\n      vec4 pcol = plane(pro, ro, rd, pp, off, aa, nz+float(i), pnor);\n      \n      vec3 refr = refract(rd, pnor, 1.0-0.075);\n      if (pcol.w > (1.0-cutOff)&&refr != vec3(0.0)) {\n        rd = refr;\n      }\n\n      float dz = pp.z-ro.z;\n      const float fi = -0.; \n      float fadeIn = smoothstep(planeDist*(float(furthest)+fi), planeDist*(float(fadeFrom)-fi), dz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, dz);\n      pcol.w *= fadeOut*fadeIn;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float z   = 0.33*planeDist*TIME;\n  vec3 pro  = offset(z-1.0);\n  vec3 ro   = offset(z);\n  vec3 dro  = doffset(z);\n  vec3 ddro = ddoffset(z);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, pro, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Voronoi Glass Panes\n//  Tinkering with the voronoi pattern from a Shane shader on saturday evening\n//  Kind of hackish overall but that never stopped me from sharing a shader before\n//  Shane shader, it's worth a look: https://www.shadertoy.com/view/Mld3Rn\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PI_2        (0.5*3.141592654)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\nconst float planeDist = 1.0-0.25;\n\nfloat g_hmul = 1.0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float zoomOuter = 1.0;\nconst float zoomInner = 0.2;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 scol = HSV2RGB(vec3(0.1, 0.25, 0.9));\n  return scol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nfloat voronoi2(vec2 p){\n  vec2 g = floor(p), o; p -= g;\n  \n  vec3 d = vec3(1);\n    \n  for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n      d.z = dot(o, o); \n      d.y = max(d.x, min(d.y, d.z));\n      d.x = min(d.x, d.z); \n    }\n  }\n  \n  return max(d.y/1.2 - d.x, 0.0)/1.2;\n}\n\nfloat hf2(vec2 p) {\n  const float zo = zoomOuter;\n  const float zi = zoomInner;\n  \n  p /= zo;\n  p /= zi;\n  \n  float d = -voronoi2(p);\n  d *= zi*zo;\n  \n  float h = 0.2*tanh_approx(3.0*smoothstep(0.0, 1.0*zo*zi, -d));\n  \n  return h*zo*zi;\n}\n\nfloat height(vec2 p) {\n  return -hf2(p)*g_hmul;\n}\n\nvec3 normal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = height(p + e.yx) - height(p - e.yx);\n  n.z = -2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec4 plane(vec3 pro, vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n_, out vec3 pnor) {\n  float h0 = hash(n_);\n  float h1 = fract(7793.0*h0);\n  float h2 = fract(6337.0*h0);\n  \n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  const float s = 1.0;\n  vec3 lp1 = vec3(5.0,  1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  vec3 lp2 = vec3(-5.0, 1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  const float hsz = 0.2;\n  float hd = hex(p.yx, hsz);\n\n  g_hmul = smoothstep(0.0, 0.125, (hd-hsz/2.0));\n\n  p += vec2(h0,h1)*20.0;\n  p *= mix(0.5, 1.0, h2);\n  float he  = height(p);\n  vec3  nor = normal(p,2.0*aa);\n  vec3 po   = pp;\n\n  pnor = nor;\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(nor, ld1), 0.0);\n  float diff2 = max(dot(nor, ld2), 0.0);\n  diff1 = ld1.z*nor.z;;\n\n  vec3  ref   = reflect(rd, nor);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 mat   = HSV2RGB(vec3(0.55, 0.45, 0.05));\n  const vec3 lcol1 = HSV2RGB(vec3(0.6, 0.5, 0.9));\n  const vec3 lcol2 = HSV2RGB(vec3(0.1, 0.65, 0.9));\n  \n  float hf = smoothstep(0.0, 0.0002, -he);\n  vec3 lpow1 = 1.0*lcol1/DOT2(ld1);\n  vec3 lpow2 = 1.0*lcol2/DOT2(ld2);\n  vec3 col = vec3(0.0);\n  col += hf*mat*diff1*diff1*lpow1;\n  col += hf*mat*diff2*diff2*lpow2;\n  float spes = 20.0;\n  col += pow(ref1, spes)*lcol1;\n  col += pow(ref2, spes)*lcol2;\n\n  float t = 1.0;\n  t *= smoothstep(aa, -aa, -(hd-hsz/4.0));\n  t *= mix(1.0, 0.75, hf);\n  \n  return vec4(col, t);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 pro, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = 2.0+tanh_approx(length(0.25*p));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 5;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.98;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec3 pnor = vec3(0.0);\n      vec4 pcol = plane(pro, ro, rd, pp, off, aa, nz+float(i), pnor);\n      \n      vec3 refr = refract(rd, pnor, 1.0-0.075);\n      if (pcol.w > (1.0-cutOff)&&refr != vec3(0.0)) {\n        rd = refr;\n      }\n\n      float dz = pp.z-ro.z;\n      const float fi = -0.; \n      float fadeIn = smoothstep(planeDist*(float(furthest)+fi), planeDist*(float(fadeFrom)-fi), dz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, dz);\n      pcol.w *= fadeOut*fadeIn;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float z   = 0.33*planeDist*TIME;\n  vec3 pro  = offset(z-1.0);\n  vec3 ro   = offset(z);\n  vec3 dro  = doffset(z);\n  vec3 ddro = ddoffset(z);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, pro, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["//excluding the function cubicRoot:\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this works by exploiting the fact that there exist polynomials T_n\n//such that T_n(cos(x)) = cos(n*x). these are chebyshev polynomials\n//of the first kind. T_2 is a parabola, and we can estimate the\n//distance to the cosine curve by using the analytic distance to this\n//parabola.\n//\n//to get the distance from p to the sine curve, we first do\n//p.x = sin(p.x*frequency)/frequency\n//then we produce the closest point on the parabola\n//T_2(x) = 2x^2 - 1\n//call this point \"q\". we undo the mapping we made to p with\n//q.x = asin(q.x*frequency)/frequency\n//we do need to clamp it between -1 and 1 before passing into asin\n//but that is the gist of the method.\n//\n//this estimate only works for one half of the principal half cycle,\n//so we need to use two estimates for either side, and take the closest\n//point to p. finally we do a single newton's method update to finalize\n//the estimate. I'm not sure how accurate this is, but it looks extremely\n//close to the ground truth.\n//\n// article: https://suricrasia.online/demoscene/sine-distance/\n//\n//other solutions:\n//  iq:        https://www.shadertoy.com/view/3t23WG\n//  fabrice:   https://www.shadertoy.com/view/tsXXRM\n//  blackle 2: https://www.shadertoy.com/view/3lSyDG\n\n#define PI 3.141592653\n\n//perform one step of netwon's method to finalize the estimate\n#define ONE_NEWTON_STEP\n\n// of equation x^3+c1*x+c2=0\n/* Stolen from http://perso.ens-lyon.fr/christophe.winisdoerffer/INTRO_NUM/NumericalRecipesinF77.pdf,\n   page 179 */\n// subsequently stolen from https://www.shadertoy.com/view/MdfSDn\nfloat cubicRoot(float c1, float c2) {\n    float a = c1 / 3.0;\n    float b = c2;\n    float p = -a * a * a / 27.0 + b / 3.0;\n    float q = a * (2.0 * a * a - 9.0 * b) / 27.0 + 8.0 / 27.0;\n    float d = q * q / 4.0 + p * p * p / 27.0;\n    float r = sqrt(abs(d));\n    float phi = acos(q / (2.0 * r));\n    float x = 2.0 * r * cos(phi / 3.0) - a / 3.0;\n    return x;\n}\n\nvec2 cls_one(vec2 p, float f) {\n    //sorry this is unreadable\n    float f2 = f*f; //sq\n    float cmn = 8.*f2*f2;\n    float x = sin(p.x*f)/f;\n    float pp = ((-4.*p.y-4.)*f2 + 1.)/cmn;\n    float qq = -x/cmn;\n    float sol = cubicRoot(pp, qq);\n    \n    x = asin(clamp(sol*f,-1.,1.))/f;\n    return vec2(x,-cos(f*2.*x));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n    float wavelen = PI/freq;\n\n    //map p to be within the principal half cycle\n    float cell = round(p.x/wavelen)*wavelen;\n    float sgn = sign(cos(p.x*freq));\n    p.x = (p.x-cell)*sgn;\n    \n    vec2 off = vec2(-PI/freq/2.,0);\n    //approximate either side of the principal half cycle with\n    //the distance to the 2nd chebyshev polynomial of the 1st kind\n    vec2 a = -off+cls_one(off+p, freq/2.);\n    vec2 b =  off-cls_one(off-p, freq/2.);\n\n    //pick closest, comment out to see how the one-sided approximation looks\n    if (length(p-b) < length(p-a)) a = b;\n\n#ifdef ONE_NEWTON_STEP\n    //newton's method update via lagrange multipliers\n    //visually very close after one step, but more increases accuracy quadratically\n    vec3 K = vec3(a,p.x-p.y);\n    \n    //it might be possible to simplify this a lot...\n    vec3 lagrange = vec3(2.*(K.x-p.x)+K.z*-cos(K.x*freq)*freq,\n        2.*(K.y-p.y)-K.z,\n        K.y+sin(K.x*freq));\n    K -= (inverse(mat3(2.-K.z*-sin(K.x*freq)*freq*freq,0,cos(K.x*freq)*freq,0,2,1,-cos(K.x*freq)*freq,-1,0))*lagrange);\n    a = K.xy;\n    a.y = -sin(a.x*freq);\n#endif\n\n    float dist = length(p-a)*sign(p.y+sin(p.x*freq));\n    //map the closest point back to global coordinates\n    a.x *= sgn; a.x += cell;\n    return vec3(dist,a);\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tfloat scale = 5.;\n    uv*=scale; mouse*=scale;\n    float pixel_size = scale/iResolution.y;\n    \n    float t = sin(iTime)*.5+.5;\n    float freq = mix(20.,.1,sqrt(t));\n\n    vec3 mousedist = sine_SDF(mouse, freq);\n    vec3 col = shadeDistance(sine_SDF(uv, freq).x);\n    if (iMouse.z > 0.) {\n        col *= smoothstep(-pixel_size,pixel_size, distance(mouse, uv) - abs(mousedist.x)) *.5 +.5;\n        col = mix(vec3(.8,.9,.4), col, smoothstep(-pixel_size,pixel_size, distance(mousedist.yz, uv) - .05));\n    }\n    float sn = abs(uv.y+cos(uv.x*freq))-.01;\n    float snl = 0.*smoothstep(fwidth(sn),0.,sn);\n\n    fragColor = vec4(col,1.0) + snl;\n}"], ["// License CC0: Stars and galaxy\n// Bit of sunday tinkering lead to stars and a galaxy\n// Didn't turn out as I envisioned but it turned out to something\n// that I liked so sharing it.\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n  // Found at https://www.shadertoy.com/view/sdlXWX\n  // Which then redirected to IQ shader\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f*f*(3.-2.*f);\n  \n  float n =\n         mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)), \n                   dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),\n              mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)), \n                   dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);\n\n  return 2.0*n;              \n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h /= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME/60.0-PI/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n"], ["// License CC0: Stars and galaxy\n// Bit of sunday tinkering lead to stars and a galaxy\n// Didn't turn out as I envisioned but it turned out to something\n// that I liked so sharing it.\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n  // Found at https://www.shadertoy.com/view/sdlXWX\n  // Which then redirected to IQ shader\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f*f*(3.-2.*f);\n  \n  float n =\n         mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)), \n                   dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),\n              mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)), \n                   dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);\n\n  return 2.0*n;              \n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h /= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME/60.0-PI/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n"], ["// License CC0: Stars and galaxy\n// Bit of sunday tinkering lead to stars and a galaxy\n// Didn't turn out as I envisioned but it turned out to something\n// that I liked so sharing it.\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n    vec3 col = vec3(pow(Temp, 4.0)) * vec3(155.0, 46.0, 1.0);\n    return col / (col + vec3(1.0));\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n  // Found at https://www.shadertoy.com/view/sdlXWX\n  // Which then redirected to IQ shader\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f*f*(3.-2.*f);\n  \n  float n =\n         mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)), \n                   dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),\n              mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)), \n                   dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);\n\n  return 2.0*n;              \n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h /= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME/60.0-PI/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n"], ["// License CC0: Stars and galaxy\n// Bit of sunday tinkering lead to stars and a galaxy\n// Didn't turn out as I envisioned but it turned out to something\n// that I liked so sharing it.\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(random2(i + vec2(0.0,0.0)), f - vec2(0.0,0.0)),\n                   dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n               mix(dot(random2(i + vec2(0.0,1.0)), f - vec2(0.0,1.0)),\n                   dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h /= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME/60.0-PI/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n"], ["// License CC0: Stars and galaxy\n// Bit of sunday tinkering lead to stars and a galaxy\n// Didn't turn out as I envisioned but it turned out to something\n// that I liked so sharing it.\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n  // Found at https://www.shadertoy.com/view/sdlXWX\n  // Which then redirected to IQ shader\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f*f*(3.-2.*f);\n  \n  float n =\n         mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)), \n                   dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),\n              mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)), \n                   dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);\n\n  return 2.0*n;              \n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h /= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME/60.0-PI/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Correct SDF and gradient to a Squircle. NOTE - this is a brite force\n// way to do this, it has tesselation artifacts and is slow. But it is exact\n// (in the limit). Not also this is NOT a great way go blend between a circle\n// and a square btw; for that you can use https://www.shadertoy.com/view/7sdXz2\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n)\n{\n    vec2 q = abs(p);\n    float d = length(q) - 1.0;\n    float a = max(q.x, q.y);\n    float b = min(q.x, q.y);\n    float c = sqrt(a*a - b*b);\n    float d1 = a - c;\n    float d2 = a + c;\n    float d3 = a - b;\n    float d4 = a + b;\n    float d5 = d1 - d2;\n    float d6 = d3 - d4;\n    float d7 = d5 - d6;\n    float d8 = d7 - d;\n    float d9 = d8 - d;\n    float d10 = d9 - d;\n    float d11 = d10 - d;\n    float d12 = d11 - d;\n    float d13 = d12 - d;\n    float d14 = d13 - d;\n    float d15 = d14 - d;\n    float d16 = d15 - d;\n    float d17 = d16 - d;\n    float d18 = d17 - d;\n    float d19 = d18 - d;\n    float d20 = d19 - d;\n    float d21 = d20 - d;\n    float d22 = d21 - d;\n    float d23 = d22 - d;\n    float d24 = d23 - d;\n    float d25 = d24 - d;\n    float d26 = d25 - d;\n    float d27 = d26 - d;\n    float d28 = d27 - d;\n\nfloat incorrect_sdSquircle(vec2 p, float n)\n{\n    return pow(pow(abs(p.x),n) + pow(abs(p.y),n),1.0/n) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n     // animation\n    float n = 3.0 + 2.5*sin(6.283185*iTime/3.0);\n\n    // distance\n    vec3 dg =  sdSquircle(p, n);\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    //g = vec2( dFdx(d), dFdy(d) )/(2.0*1.4/iResolution.y);\n\n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-8.0*abs(d));\n    col *= 0.9 + 0.1*cos(90.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdSquircle(m,n).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.010, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.010, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The Devil's Stairs (https://en.m.wikipedia.org/wiki/Cantor_function) climbs around f(x)=x\n// but can be generalize to any monotonic function for which we can compute the inverse.\n\nfloat fun_smt( float x, float k ) { return pow(x,k)/(pow(x,k)+pow(1.0-x,k)); }\nfloat inv_smt( float x, float k ) { return fun_smt(x,1.0/k); }\nfloat fun_pow( float x, float k ) { return pow(x,k); }\nfloat inv_pow( float x, float k ) { return fun_pow(x,1.0/k); }\n\nfloat function( float x, float t )\n{\n    float k = exp2(3.0*(0.5-0.5*cos(t*6.283185/3.0)));\n    return (t<3.0) ? fun_smt(x,k) : fun_pow(x,k);\n}\nfloat inverse_function( float x, float t )\n{\n    float k = exp2(3.0*(0.5-0.5*cos(t*6.283185/3.0)));\n    return (t<3.0) ? inv_smt(x,k) : inv_pow(x,k);\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n\tfloat y = 0.0;\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat A = 1.0;\n\tfloat B = 1.0;\n\tfloat C = 1.0;\n\tfloat D = 1.0;\n\tfloat E = 1.0;\n\tfloat F = 1.0;\n\tfloat G = 1.0;\n\tfloat H = 1.0;\n\tfloat I = 1.0;\n\tfloat J = 1.0;\n\tfloat K = 1.0;\n\tfloat L = 1.0;\n\tfloat M = 1.0;\n\tfloat N = 1.0;\n\tfloat O = 1.0;\n\tfloat P = 1.0;\n\tfloat Q = 1.0;\n\tfloat R = 1.0;\n\tfloat S = 1.0;\n\tfloat T = 1.0;\n\tfloat U = 1.0;\n\tfloat V = 1.0;\n\tfloat W = 1.0;\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\treturn length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // pixel coords\n    float px = 1.0/iResolution.y;\n    vec2  p = (vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)*px;\n    \n    // animation loop\n    float t = mod(iTime,6.0);\n\n    // render\n    vec3 col = vec3(0.0);\n    if( p.x>0.0 && p.x<1.0 )\n    {\n        // background\n        col = vec3( 0.04 + 0.008*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n\n        // plot\n        vec2 d = vec2(1e20);\n        for( int i=-2; i<2; i++ )\n        {\n            float x0 = p.x + px*float(i+0);\n            float x1 = p.x + px*float(i+1);\n            d.x = min( d.x, sdLine(p, vec2(x0, function(x0,t)), \n                                      vec2(x1, function(x1,t))));\n            d.y = min( d.y, sdLine(p, vec2(x0, cantor(  x0,t)), \n                                      vec2(x1, cantor(  x1,t))));\n        }\n        col = mix( col, vec3(0.25,0.25,0.25), 1.0-smoothstep(0.0007,0.0007+px,d.x) );\n        col = mix( col, vec3(1.00,0.36,0.04), 1.0-smoothstep(0.0007,0.0007+px,d.y) );\n    }\n    \n    // gamma\n    col = sqrt(col);\n \n    fragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The Devil's Stairs (https://en.m.wikipedia.org/wiki/Cantor_function) climbs around f(x)=x\n// but can be generalize to any monotonic function for which we can compute the inverse.\n\nfloat fun_smt( float x, float k ) { return pow(x,k)/(pow(x,k)+pow(1.0-x,k)); }\nfloat inv_smt( float x, float k ) { return fun_smt(x,1.0/k); }\nfloat fun_pow( float x, float k ) { return pow(x,k); }\nfloat inv_pow( float x, float k ) { return fun_pow(x,1.0/k); }\n\nfloat function( float x, float t )\n{\n    float k = exp2(3.0*(0.5-0.5*cos(t*6.283185/3.0)));\n    return (t<3.0) ? fun_smt(x,k) : fun_pow(x,k);\n}\nfloat inverse_function( float x, float t )\n{\n    float k = exp2(3.0*(0.5-0.5*cos(t*6.283185/3.0)));\n    return (t<3.0) ? inv_smt(x,k) : inv_pow(x,k);\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    float y = 0.0;\n    float sc = 0.5;\n    float bi = 0.0;\n    float xa = 0.0;\n    float xb = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        // choose subdivision intervals\n        float ya = function(xa,t);\n        float yb = function(xb,t);\n        float wa = inverse_function(ya+(yb-ya)/3.0,t);\n        float wb = inverse_function(yb-(yb-ya)/3.0,t);\n        // recurse\n             if( x<wa ) { bi+=0.0*sc; y=bi+sc*(x-xa)/(wa-xa); xb=wa; }\n        else if( x>wb ) { bi+=1.0*sc; y=bi+sc*(x-wb)/(xb-wb); xa=wb; }\n        else            { bi+=0.0*sc; y=bi+sc;                break; }\n        sc *= 0.5;\n    }\n    return y;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // pixel coords\n    float px = 1.0/iResolution.y;\n    vec2  p = (vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)*px;\n    \n    // animation loop\n    float t = mod(iTime,6.0);\n\n    // render\n    vec3 col = vec3(0.0);\n    if( p.x>0.0 && p.x<1.0 )\n    {\n        // background\n        col = vec3( 0.04 + 0.008*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n\n        // plot\n        vec2 d = vec2(1e20);\n        for( int i=-2; i<2; i++ )\n        {\n            float x0 = p.x + px*float(i+0);\n            float x1 = p.x + px*float(i+1);\n            d.x = min( d.x, sdLine(p, vec2(x0, function(x0,t)), \n                                      vec2(x1, function(x1,t))));\n            d.y = min( d.y, sdLine(p, vec2(x0, cantor(  x0,t)), \n                                      vec2(x1, cantor(  x1,t))));\n        }\n        col = mix( col, vec3(0.25,0.25,0.25), 1.0-smoothstep(0.0007,0.0007+px,d.x) );\n        col = mix( col, vec3(1.00,0.36,0.04), 1.0-smoothstep(0.0007,0.0007+px,d.y) );\n    }\n    \n    // gamma\n    col = sqrt(col);\n \n    fragColor = vec4( col, 1.0 );\n}"], ["\n// Created by Danil (2022+) https://github.com/danilw\n// License - CC0 or use as you wish\n\n\n// main point of this shader is - fractal that generate different image depends of parameters\n// look map function\n\n\n\n// to play with parameters and use Mouse control, 5 is index in arrays below that size of psz\n//#define use_func 5\n\n\n// to test animation loop with mouse\n//#define mouse_loop\n\n\n#define cam_orbit 2.05\n\n// params\n#define psz 8\n\n// scale\nfloat p0[psz] = float[]( 0.7, 0.7, 0.7, 0.7, 0.57, 0.697, .09, 2.57);\n\n\n// biggest visual impact \nfloat p1[psz] = float[]( 0.07,  0.07, -0.107, -0.07, -0.69,  -0.69,   -0.1069,  -0.69);\n\nfloat p2[psz] = float[](-0.15, -0.15,  1.84,  -0.15, -0.015,  0.015,  -0.02015, -0.015);\n\nfloat p3[psz] = float[]( 0.465, 0.184, 0.465,  0.465, 0.2465, 0.1465,  1.465,    0.2465);\n\n\n// number of loops, keep low (clamped to 1 to 30 to not kill your GPU)\nint p5[psz] = int[](5,5,10,5,5,5,10,5);\n\n\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n    float d = 0.;\n    float t = 0.;\n    float s = 0.;\n    float r = 0.;\n    float a = 0.;\n    float b = 0.;\n    float c = 0.;\n    float e = 0.;\n    float f = 0.;\n    float g = 0.;\n    float h = 0.;\n    float i = 0.;\n    float j = 0.;\n    float k = 0.;\n    float l = 0.;\n    float m = 0.;\n    float n = 0.;\n    float o = 0.;\n    float p1 = 0.;\n    float q = 0.;\n    float r1 = 0.;\n    float s1 = 0.;\n    float t1 = 0.;\n    float u = 0.;\n    float v = 0.;\n    float w = 0.;\n    float x = 0.;\n    float y = 0.;\n    float z = 0.;\n    float a1 = 0.;\n    float b1 = 0.;\n    float c1 = 0.;\n    float d1 = 0.;\n    float e1 = 0.;\n    float f1 = 0.;\n    float g1 = 0.;\n    float h1 = 0.;\n    float i1 = 0.;\n    float j1 = 0.;\n    float k1 = 0.;\n    float l1 = 0.;\n    float m1 = 0.;\n    float n1 = 0.;\n    float o1 = 0.;\n    float p2 = 0.;\n    float q1 = 0.;\n    float r2 = 0.;\n    float s2 = 0.;\n    float t2 = 0.;\n    float u1 = 0.;\n    float v1 = 0.;\n    float w1 = 0.;\n\n\nvec3 postProcess(vec3 col, float ct);\nvec3 march(vec3 ro, vec3 rd, int idx, float c_timer, float ct2) {\n  float t   = 0.;\n  float dt  = 0.152;\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 48;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-1.50*c);\n      vec3 pos = ro+t*rd;\n      c = map(pos,idx); \n      \n      //c *= 0.025+2.*iMouse.y/iResolution.y; //test color with mouse\n      c *= 0.025+2.*c_timer;\n      float center = -0.35; // center of color shift\n      float dist = (abs(pos.x + pos.y + center))*2.5;\n      vec3 dcol = vec3(c*c+0.5*c*c-c*dist, c*c-c, c); // color func\n      col = col + dcol*1./float(max_iter);\n  }\n  col *= 0.18;\n  col=clamp(col,0.,1.);\n  return postProcess(col, ct2);\n}\n\nvec3 postProcess(vec3 col, float ct) {\n  col = col*0.85+0.85*col*col.brb;\n  col = col*0.6+0.64*col*col*(3.0-2.0*col)+0.5*col*col;\n  col = col+0.4*(col.rrb-vec3(dot(col, vec3(0.33))));\n  vec3 c1=col-0.344*(col.brb-vec3(dot(col, vec3(0.33))));\n  vec3 c2=col+0.64*(col.ggr-vec3(dot(col, vec3(0.33))));\n  col=mix(col,c1,min(ct*2.,1.));\n  col=mix(col,c2,-clamp(ct*2.-1.,0.,1.));\n  //col*=1.5;\n  col=col*01.5+0.5*col*col;\n  return col;\n}\n\n\n\n// fractal color function\n\n#define PI 3.14159265\nvec4 get_color(vec2 p , int idx, float timer, float c_timer)\n{\n    idx = idx%psz;\n    vec4 fragColor;\n\tfloat time = iTime;\n    vec3 ret_col = vec3(0.0);\n    float mouseY = 0.15 * PI;\n    mouseY = (1.0 - 0.5*1.15 * (1.83-timer)) * 0.5 * PI;\n#ifdef use_func\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI; //test MOUSE\n#endif\n#ifndef mouse_loop\n    if(iMouse.z>0.&&iMouse.w<iResolution.y)mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n#endif\n    float mouseX = -1.25*PI;\n    mouseX+=-(timer*1.5+0.25) * .5 * PI;\n#ifdef use_func\n    mouseX=-1.25*PI-(iMouse.x / iResolution.x) * 3. * PI; //test MOUSE\n#endif\n#ifndef mouse_loop\n    if(iMouse.z>0.&&iMouse.z<iResolution.x)mouseX=-1.25*PI-(iMouse.x / iResolution.x) * 3. * PI;\n#endif\n    vec3 eye = cam_orbit*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    eye = eye+0.0001*(1.-abs(sign(eye)));\n    vec3 ro = eye;\n\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec3 rd = normalize(w + p.x * u + p.y * v);\n    \n    vec3 col =  march(ro, rd, idx, timer*0.30+0.15*timer*timer+0.25, c_timer);\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n    return fragColor;\n}\n\n\n\n// everything else is just Shadertoy presentation, not related to fractal\n// mainImage has godrays + image slider logic\n\nvec2 plane(vec2 uv, float timer);\nfloat GetBayerFromCoordLevel(vec2 pixelpos);\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d );\nfloat hash(vec2 p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.);\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n\n#ifdef use_func\n    fragColor = get_color((uv-res*0.5)*2., use_func, 0.65, 0.);\n    return;\n#endif\n\n    const float grn = 7.; // number of tiles for slider\n\n    float sx = 0.5*(1./grn)+0.5*0.25*(floor(res.x/(1./grn))-0.5*res.x/(1./grn));\n    uv.x += sx;\n    vec2 gid = floor(uv*grn);\n    uv = fract(uv*grn)-0.5;\n    \n    // timers\n    float gtime = iTime*.645;\n    // gtime=float(psz)*6. sec loop\n    \n#ifdef mouse_loop\n    gtime=float(psz)*6.*iMouse.x/iResolution.x; //test MOUSE\n#endif\n\n    // timer logic\n    float tt = mod(gtime,12.);\n    float tt2 = mod(gtime+6.,12.);\n    float i1 = smoothstep(3.,6.,tt);float i2 = smoothstep(9.,12.,tt);\n    float ltime = (i1+i2)*3.+floor(gtime/12.)*6.;\n    float s_timer = (smoothstep(3.,12.,tt2));\n    float s_timer2 = (smoothstep(3.,12.,tt));\n    int itdx = int(ltime+3.)/6;\n    int itdx2 = int(ltime)/6;\n    \n    float gmix1 = 0.5-0.5*cos(gtime/6.*0.35);\n    float gmix2 = 0.5-0.5*cos(gtime/6.*0.25);\n\n    // godrays \n    vec3 occ_col=vec3(0.);\n    {\n        #define DECAY .974\n        #define EXPOSURE .116907\n        #define SAMPLES\t32\n        #define DENSITY\t.595\n        #define WEIGHT .25\n        vec2 coord = fragCoord.xy/iResolution.xy;\n        float cd = 1.75*length(coord-0.5);\n        float occ=0.;\n        vec2 lightpos = vec2(0.51,0.503);\n        float dither = GetBayerFromCoordLevel(fragCoord);    \n        vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);\n        float illumdecay = 1.;\n        for(int i=0; i<SAMPLES; i++)\n        {\n            coord -= dtc;\n            vec2 otuv = coord+(dtc*dither);\n            vec2 tuv = otuv*res;\n            tuv.x += sx; vec2 lgid = floor(tuv*grn); tuv = fract(tuv*grn)-0.5;\n            float lctimer = 0.0;\n            float lctime = ltime - (lgid.y/grn - lgid.x/(grn*res.x))*1.-grn/16.+2.;\n            lctime = mod(lctime, 6.);\n            lctimer += smoothstep(0.0, 1.0, lctime);\n            lctimer += 1. - smoothstep(3.0, 4.0, lctime);\n            lctimer = abs(lctimer-1.0);\n            vec2 tuv_pl = plane(tuv,lctimer);\n            float noplx = float(abs(tuv_pl.x)>0.5||abs(tuv_pl.y)>0.5);\n            float s = (noplx)*(1.-smoothstep(-0.03,0.75,.5*length(otuv-0.5)));\n            s *= illumdecay * WEIGHT;\n            occ += s;\n            illumdecay *= DECAY;\n        }\n        occ=1.5*occ*EXPOSURE;\n        occ_col = occ*(1./max(cd,0.0001))*\n            pal( mix(cd*occ*0.35,cd+occ*0.35,gmix1), \n            vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) ).gbr;\n        occ_col=clamp(occ_col,0.,1.);\n    }\n    //----\n\n    float timer = 0.0;\n    float time = ltime - (gid.y/grn - gid.x/(grn*res.x))*1.-grn/16.+2.;\n    time = mod(time, 6.);\n    timer += smoothstep(0.0, 1.0, time);\n    timer += 1. - smoothstep(3.0, 4.0, time);\n    timer = abs(timer-1.0);\n    float side = step(0.5, timer);\n    vec2 uv_pl = plane(uv,timer);\n    \n    vec2 tp = (fragCoord.xy/iResolution.xy-0.5)*2.;\n    tp = pow(abs(tp), vec2(2.0)); \n    float tcd = 0.5+0.5*clamp(1.0 - dot(tp, tp),0.,1.);\n    float cineshader_alpha = smoothstep(0.,1.,(timer))*0.5*tcd;\n    //float cineshader_alpha = smoothstep(0.,1.,2.*abs(timer-.5))*0.5*tcd;\n    \n    bool nopl = abs(uv_pl.x)>0.5||abs(uv_pl.y)>0.5;\n    uv_pl += 0.5;\n    if(side<0.5)uv_pl.x=1.-uv_pl.x;\n    \n    if (nopl)\n    {\n        fragColor = vec4(occ_col,cineshader_alpha);\n        return;\n    }\n    vec2 tuv = ((uv_pl*1./res)*1./grn+((gid*1./grn)+vec2(-sx,0.))*1./res);\n    if(side>0.5)fragColor = get_color((tuv-0.5)*res*2.,0+itdx*2,s_timer, gmix2);\n    else fragColor = get_color((tuv-0.5)*res*2.,1+itdx2*2,s_timer2, gmix2);\n    \n    //fragColor.rgb*=smoothstep(0.,1.,2.*abs(timer-.5));\n    \n    fragColor = vec4(fragColor.rgb+occ_col,cineshader_alpha);\n    fragColor.rgb = clamp(fragColor.rgb,0.,1.);\n}\n\n\nvec2 plane(vec2 uv, float timer)\n{\n    timer = radians(timer*180.0);\n    vec4 n = vec4(cos(timer),0,sin(timer),-sin(timer));\n    vec3 d = vec3(1.0,uv.y,uv.x);\n    vec3 p = vec3(-1.0+n.w/4.0,0.,0.);\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = cross(up, n.xyz);\n    float dn = dot(d, n.xyz);dn+=0.00001*(1.-abs(sign(dn)));\n    float pn = dot(p, n.xyz);\n    vec3 hit = p - d / dn * pn;\n    return vec2(dot(hit, right), dot(hit, up));\n}\n\n\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{\n    ivec2 ppos = ivec2(pixelpos);\n    int sum = 0; const int MAX_LEVEL = 3;\n    for(int i=0; i<MAX_LEVEL; i++)\n    {\n        ivec2 tv = ppos>>(MAX_LEVEL-1-i)&1;\n        sum += ((4-(tv).x-((tv).y<<1))%4)<<(2*i);\n    }\n    return float(sum) / float(2<<(MAX_LEVEL*2-1));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n"], ["// License CC0 - Complex atanh - darkmode edition\n// More work tinkering based on mlas shader Complex atanh - https://www.shadertoy.com/view/tsBXRW\n#define DARKMODE\n#define FASTATAN\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#if defined(FASTATAN)\n#define ATAN atan_approx\n#else\n#define ATAN atan\n#endif\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n    float z = x + y;\n    return 0.15 * z * z * (y / z - x);\n}\n\n// Complex trig functions found at: Complex Atanh - https://www.shadertoy.com/view/tsBXRW\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),ATAN(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at an ctanh\nvec2 cexp(vec2 z) {\n  float r = exp(z.x);\n  return r*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\nvec2 transform(vec2 z, out float aa, out vec2 hscale) {\n  float A = 9.0;\n  float B = 2.0;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n\n  vec2 rot = vec2(A, B);\n  float a = TIME;\n  z *= 2.0;\n  z = catanh(-0.5*z+0.5*vec2(sin(a*0.234*sqrt(0.5)), sin(a*0.234)))+catanh(z*ROT(0.1234*a));\n  z /= PI;\n\n  aa = fwidth(z.x);\n  aa *= length(rot);\n  z = cmul(rot,z);\n  z.x += 0.5*a;\n\n  hscale = 1.0/rot.yx;\n  return z;\n}\n\nvec3 effect(vec3 col, vec2 op) {\n  op *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  float aa;\n  vec2 hscale;\n  vec2 p = transform(op, aa, hscale);\n\n  vec2 n = round(p);\n  p -= n; // Neat!\n\n  float d = circle8(p, 0.45);\n\n  vec2 pf = p;\n  float sf = sign(pf.x*pf.y);\n  pf = abs(pf);\n  float df = sf*min(pf.x, pf.y);\n  float flip = smoothstep(aa, -aa, df);\n\n#if defined(DARKMODE)\n  col = vec3(0.0);\n  float fo = tanh_approx(0.333*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.65+0.2*sin(0.5*TIME+0.25*flip+PI*dot(n, hscale))), mix(0.0, 0.75, fo), mix(1.0, 0.05, fo*fo)));\n#else\n  col = vec3(1.0);\n  float fo = tanh_approx(0.125*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.05*TIME+0.125*flip+0.5*dot(hscale, n)), mix(0.0, 0.75, fo), mix(1.0, 0.85, fo*fo)));\n#endif\n\n  rgb = mix(rgb, smoothstep(0.5, 1.0, rgb), flip);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 3.0, TIME);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0 - Complex atanh - darkmode edition\n// More work tinkering based on mlas shader Complex atanh - https://www.shadertoy.com/view/tsBXRW\n#define DARKMODE\n#define FASTATAN\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#if defined(FASTATAN)\n#define ATAN atan_approx\n#else\n#define ATAN atan\n#endif\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// Complex trig functions found at: Complex Atanh - https://www.shadertoy.com/view/tsBXRW\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),ATAN(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at an ctanh\nvec2 cexp(vec2 z) {\n  float r = exp(z.x);\n  return r*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\nvec2 transform(vec2 z, out float aa, out vec2 hscale) {\n  float A = 9.0;\n  float B = 2.0;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n\n  vec2 rot = vec2(A, B);\n  float a = TIME;\n  z *= 2.0;\n  z = catanh(-0.5*z+0.5*vec2(sin(a*0.234*sqrt(0.5)), sin(a*0.234)))+catanh(z*ROT(0.1234*a));\n  z /= PI;\n\n  aa = fwidth(z.x);\n  aa *= length(rot);\n  z = cmul(rot,z);\n  z.x += 0.5*a;\n\n  hscale = 1.0/rot.yx;\n  return z;\n}\n\nvec3 effect(vec3 col, vec2 op) {\n  op *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  float aa;\n  vec2 hscale;\n  vec2 p = transform(op, aa, hscale);\n\n  vec2 n = round(p);\n  p -= n; // Neat!\n\n  float d = circle8(p, 0.45);\n\n  vec2 pf = p;\n  float sf = sign(pf.x*pf.y);\n  pf = abs(pf);\n  float df = sf*min(pf.x, pf.y);\n  float flip = smoothstep(aa, -aa, df);\n\n#if defined(DARKMODE)\n  col = vec3(0.0);\n  float fo = tanh_approx(0.333*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.65+0.2*sin(0.5*TIME+0.25*flip+PI*dot(n, hscale))), mix(0.0, 0.75, fo), mix(1.0, 0.05, fo*fo)));\n#else\n  col = vec3(1.0);\n  float fo = tanh_approx(0.125*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.05*TIME+0.125*flip+0.5*dot(hscale, n)), mix(0.0, 0.75, fo), mix(1.0, 0.85, fo*fo)));\n#endif\n\n  rgb = mix(rgb, smoothstep(0.5, 1.0, rgb), flip);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 3.0, TIME);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0 - Complex atanh - darkmode edition\n// More work tinkering based on mlas shader Complex atanh - https://www.shadertoy.com/view/tsBXRW\n#define DARKMODE\n#define FASTATAN\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#if defined(FASTATAN)\n#define ATAN atan_approx\n#else\n#define ATAN atan\n#endif\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// Complex trig functions found at: Complex Atanh - https://www.shadertoy.com/view/tsBXRW\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),ATAN(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// My own attempt at an ctanh\nvec2 cexp(vec2 z) {\n  float r = exp(z.x);\n  return r*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\nvec2 transform(vec2 z, out float aa, out vec2 hscale) {\n  float A = 9.0;\n  float B = 2.0;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n\n  vec2 rot = vec2(A, B);\n  float a = TIME;\n  z *= 2.0;\n  z = catanh(-0.5*z+0.5*vec2(sin(a*0.234*sqrt(0.5)), sin(a*0.234)))+catanh(z*ROT(0.1234*a));\n  z /= PI;\n\n  aa = fwidth(z.x);\n  aa *= length(rot);\n  z = cmul(rot,z);\n  z.x += 0.5*a;\n\n  hscale = 1.0/rot.yx;\n  return z;\n}\n\nvec3 effect(vec3 col, vec2 op) {\n  op *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  float aa;\n  vec2 hscale;\n  vec2 p = transform(op, aa, hscale);\n\n  vec2 n = round(p);\n  p -= n; // Neat!\n\n  float d = circle8(p, 0.45);\n\n  vec2 pf = p;\n  float sf = sign(pf.x*pf.y);\n  pf = abs(pf);\n  float df = sf*min(pf.x, pf.y);\n  float flip = smoothstep(aa, -aa, df);\n\n#if defined(DARKMODE)\n  col = vec3(0.0);\n  float fo = tanh_approx(0.333*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.65+0.2*sin(0.5*TIME+0.25*flip+PI*dot(n, hscale))), mix(0.0, 0.75, fo), mix(1.0, 0.05, fo*fo)));\n#else\n  col = vec3(1.0);\n  float fo = tanh_approx(0.125*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.05*TIME+0.125*flip+0.5*dot(hscale, n)), mix(0.0, 0.75, fo), mix(1.0, 0.85, fo*fo)));\n#endif\n\n  rgb = mix(rgb, smoothstep(0.5, 1.0, rgb), flip);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 3.0, TIME);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0 - Complex atanh - darkmode edition\n// More work tinkering based on mlas shader Complex atanh - https://www.shadertoy.com/view/tsBXRW\n#define DARKMODE\n#define FASTATAN\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#if defined(FASTATAN)\n#define ATAN atan_approx\n#else\n#define ATAN atan\n#endif\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// Complex trig functions found at: Complex Atanh - https://www.shadertoy.com/view/tsBXRW\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),ATAN(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at an ctanh\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\nvec2 transform(vec2 z, out float aa, out vec2 hscale) {\n  float A = 9.0;\n  float B = 2.0;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n\n  vec2 rot = vec2(A, B);\n  float a = TIME;\n  z *= 2.0;\n  z = catanh(-0.5*z+0.5*vec2(sin(a*0.234*sqrt(0.5)), sin(a*0.234)))+catanh(z*ROT(0.1234*a));\n  z /= PI;\n\n  aa = fwidth(z.x);\n  aa *= length(rot);\n  z = cmul(rot,z);\n  z.x += 0.5*a;\n\n  hscale = 1.0/rot.yx;\n  return z;\n}\n\nvec3 effect(vec3 col, vec2 op) {\n  op *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  float aa;\n  vec2 hscale;\n  vec2 p = transform(op, aa, hscale);\n\n  vec2 n = round(p);\n  p -= n; // Neat!\n\n  float d = circle8(p, 0.45);\n\n  vec2 pf = p;\n  float sf = sign(pf.x*pf.y);\n  pf = abs(pf);\n  float df = sf*min(pf.x, pf.y);\n  float flip = smoothstep(aa, -aa, df);\n\n#if defined(DARKMODE)\n  col = vec3(0.0);\n  float fo = tanh_approx(0.333*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.65+0.2*sin(0.5*TIME+0.25*flip+PI*dot(n, hscale))), mix(0.0, 0.75, fo), mix(1.0, 0.05, fo*fo)));\n#else\n  col = vec3(1.0);\n  float fo = tanh_approx(0.125*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.05*TIME+0.125*flip+0.5*dot(hscale, n)), mix(0.0, 0.75, fo), mix(1.0, 0.85, fo*fo)));\n#endif\n\n  rgb = mix(rgb, smoothstep(0.5, 1.0, rgb), flip);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 3.0, TIME);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: More Complex Atanh\n//  Inspired by: Complex Atanh  - https://www.shadertoy.com/view/tsBXRW\n//  I always thought Complex Atanh by mla was very cool\n//  I tinkered a bit with it on saturday morning and got something \n//  I think is different enough to share\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// Complex trig functions found at: Complex Atanh  - https://www.shadertoy.com/view/sl3XW7\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) { return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at a ctanh\nvec2 cexp(vec2 z) {\n  float r = exp(z.x);\n  return r*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nvec2 transform(vec2 p) {\n  float a = 0.5*TIME;\n  p *= mix(2.0, 0.5, smoothstep(-0.85, 0.85, cos(0.5*a)));\n  p = ctanh(p);\n  p *= ROT(0.2*a);\n  p += 1.5*vec2(cos(0.3*a), sin(0.4*a));\n  p = catanh(p);\n  p.x -= 0.2*a;\n  return p;\n}\n\nvec3 effect(vec3 col, vec2 p_) {\n  const float scale = 1.0/PI;\n  const float cellw = 0.05;\n  p_ *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  vec2 np_ = p_+aaa;\n  vec2 p   = transform(p_);\n  vec2 np  = transform(np_);\n  float aa = distance(p, np)*sqrt(0.5);\n\n  p *= scale;\n  aa *= scale;\n\n  vec2 n = floor(p/cellw);\n  p = mod(p, cellw);\n  p -= 0.5*cellw;\n  float fo = tanh_approx(aaa/(aa));\n  float d = circle8(p, 0.45*cellw);\n  col = mix(col, hsv2rgb(vec3(fract(0.1*n.y+0.05*n.x+0.05*TIME), mix(0., 0.95, fo), mix(0.9, 0.85, fo*fo))), smoothstep(aa, -aa, d)*step(aa, 0.7));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = mix(col, vec3(1.0), smoothstep(4.0, 0.0, TIME)),\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: More Complex Atanh\n//  Inspired by: Complex Atanh  - https://www.shadertoy.com/view/tsBXRW\n//  I always thought Complex Atanh by mla was very cool\n//  I tinkered a bit with it on saturday morning and got something \n//  I think is different enough to share\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// Complex trig functions found at: Complex Atanh  - https://www.shadertoy.com/view/sl3XW7\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at a ctanh\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nvec2 transform(vec2 p) {\n  float a = 0.5*TIME;\n  p *= mix(2.0, 0.5, smoothstep(-0.85, 0.85, cos(0.5*a)));\n  p = ctanh(p);\n  p *= ROT(0.2*a);\n  p += 1.5*vec2(cos(0.3*a), sin(0.4*a));\n  p = catanh(p);\n  p.x -= 0.2*a;\n  return p;\n}\n\nvec3 effect(vec3 col, vec2 p_) {\n  const float scale = 1.0/PI;\n  const float cellw = 0.05;\n  p_ *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  vec2 np_ = p_+aaa;\n  vec2 p   = transform(p_);\n  vec2 np  = transform(np_);\n  float aa = distance(p, np)*sqrt(0.5);\n\n  p *= scale;\n  aa *= scale;\n\n  vec2 n = floor(p/cellw);\n  p = mod(p, cellw);\n  p -= 0.5*cellw;\n  float fo = tanh_approx(aaa/(aa));\n  float d = circle8(p, 0.45*cellw);\n  col = mix(col, hsv2rgb(vec3(fract(0.1*n.y+0.05*n.x+0.05*TIME), mix(0., 0.95, fo), mix(0.9, 0.85, fo*fo))), smoothstep(aa, -aa, d)*step(aa, 0.7));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = mix(col, vec3(1.0), smoothstep(4.0, 0.0, TIME)),\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  float a = alpha.r;\n  float b = alpha.g;\n  float c = alpha.b;\n  float d = alpha.a;\n  float sum = a + b + c + d;\n  float a_ = a / sum;\n  float b_ = b / sum;\n  float c_ = c / sum;\n  float d_ = d / sum;\n  float a__ = pow(a_, contrast);\n  float b__ = pow(b_, contrast);\n  float c__ = pow(c_, contrast);\n  float d__ = pow(d_, contrast);\n  float sum__ = a__ + b__ + c__ + d__;\n  return vec4(\n    a__ / sum__,\n    b__ / sum__,\n    c__ / sum__,\n    d__ / sum__\n  );\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    tilingVal3D a = rohmCell(uvw, vec3( .0, .0, .0), gridRes);\n    tilingVal3D b = rohmCell(uvw, vec3( .5, .0, qurt_sqrt2), gridRes);\n    tilingVal3D c = rohmCell(uvw, vec3( .0, .5, qurt_sqrt2), gridRes);\n    tilingVal3D d = rohmCell(uvw, vec3( .0, .0, half_sqrt2), gridRes);\n   \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.alpha, b.alpha, \n                                c.alpha, d.alpha), contrast);\n                                \n#ifdef ZEROTOONE\n    // rescale UVWs to 0-1\n    a.grid = a.grid *0.5+0.5;\n    b.grid = b.grid *0.5+0.5;\n    c.grid = c.grid *0.5+0.5;\n    d.grid = d.grid *0.5+0.5;   \n#endif\n    \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = a.grid * alpha.x +\n               b.grid * alpha.y +\n               c.grid * alpha.z +\n               d.grid * alpha.w;\n#ifndef ZEROTOONE\n    col *= 2.0;\n#endif\n\n#ifdef ALPHA\n    col = alpha.xyz;\n#endif\n    \n    return col;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 q = abs(p);\n    float d1 = max(q.x, max(q.y, q.z));\n    float d2 = min(q.x, min(q.y, q.z));\n    float d3 = q.x + q.y + q.z - d1 - d2;\n    return max(d1 - 1.0, max(d2 - 1.0, d3 - 1.0));\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    tilingVal3D a = rohmCell(uvw, vec3( .0, .0, .0), gridRes);\n    tilingVal3D b = rohmCell(uvw, vec3( .5, .0, qurt_sqrt2), gridRes);\n    tilingVal3D c = rohmCell(uvw, vec3( .0, .5, qurt_sqrt2), gridRes);\n    tilingVal3D d = rohmCell(uvw, vec3( .0, .0, half_sqrt2), gridRes);\n   \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.alpha, b.alpha, \n                                c.alpha, d.alpha), contrast);\n                                \n#ifdef ZEROTOONE\n    // rescale UVWs to 0-1\n    a.grid = a.grid *0.5+0.5;\n    b.grid = b.grid *0.5+0.5;\n    c.grid = c.grid *0.5+0.5;\n    d.grid = d.grid *0.5+0.5;   \n#endif\n    \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = a.grid * alpha.x +\n               b.grid * alpha.y +\n               c.grid * alpha.z +\n               d.grid * alpha.w;\n#ifndef ZEROTOONE\n    col *= 2.0;\n#endif\n\n#ifdef ALPHA\n    col = alpha.xyz;\n#endif\n    \n    return col;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n  vec3 uv = uvw.xy;\n  vec3 w = uvw.z;\n  vec3 u = uv + w;\n  vec3 v = uv - w;\n  vec3 u2 = u + u;\n  vec3 v2 = v + v;\n  vec3 u3 = u + v;\n  vec3 v3 = v + u;\n  vec3 u4 = u - v;\n  vec3 v4 = v - u;\n  vec3 u5 = u2 + v;\n  vec3 v5 = v2 + u;\n  vec3 u6 = u2 - v;\n  vec3 v6 = v2 - u;\n  vec3 u7 = u + v2;\n  vec3 v7 = v + u2;\n  vec3 u8 = u - v2;\n  vec3 v8 = v - u2;\n  vec3 u9 = u3 + w;\n  vec3 v9 = v3 + w;\n  vec3 u10 = u3 - w;\n  vec3 v10 = v3 - w;\n  vec3 u11 = u4 + w;\n  vec3 v11 = v4 + w;\n  vec3 u12 = u4 - w;\n  vec3 v12 = v4 - w;\n  vec3 u13 = u5 + w;\n  vec3 v13 = v5 + w;\n  vec3 u14 = u5 - w;\n  vec3 v14 = v5 - w;\n  vec3 u15 = u6 + w;\n  vec3 v15 = v6 + w;\n  vec3 u16 = u6 - w;\n  vec3 v16 = v6 - w;\n  vec3 u17 = u7 + w;\n  vec3 v17 = v7 + w;\n  vec3 u18 = u7 - w;\n  vec3 v18 = v7 - w;\n  vec3 u19 = u8 + w;\n  vec3 v19 =// incomplete generation!\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    tilingVal3D a = rohmCell(uvw, vec3( .0, .0, .0), gridRes);\n    tilingVal3D b = rohmCell(uvw, vec3( .5, .0, qurt_sqrt2), gridRes);\n    tilingVal3D c = rohmCell(uvw, vec3( .0, .5, qurt_sqrt2), gridRes);\n    tilingVal3D d = rohmCell(uvw, vec3( .0, .0, half_sqrt2), gridRes);\n   \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.alpha, b.alpha, \n                                c.alpha, d.alpha), contrast);\n                                \n#ifdef ZEROTOONE\n    // rescale UVWs to 0-1\n    a.grid = a.grid *0.5+0.5;\n    b.grid = b.grid *0.5+0.5;\n    c.grid = c.grid *0.5+0.5;\n    d.grid = d.grid *0.5+0.5;   \n#endif\n    \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = a.grid * alpha.x +\n               b.grid * alpha.y +\n               c.grid * alpha.z +\n               d.grid * alpha.w;\n#ifndef ZEROTOONE\n    col *= 2.0;\n#endif\n\n#ifdef ALPHA\n    col = alpha.xyz;\n#endif\n    \n    return col;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n  vec3 uv = uvw.xy;\n  vec3 vw = uvw.yz;\n  vec3 wu = uvw.zw;\n  vec3 u = uvw.xyz;\n  vec3 v = uvw.yzx;\n  vec3 w = uvw.zxy;\n  vec3 r = uvw.xyz;\n  vec3 s = uvw.yzx;\n  vec3 t = uvw.zxy;\n  vec3 uv2 = uvw.xy * 2.0;\n  vec3 vw2 = uvw.yz * 2.0;\n  vec3 wu2 = uvw.zw * 2.0;\n  vec3 u2 = uvw.xyz * 2.0;\n  vec3 v2 = uvw.yzx * 2.0;\n  vec3 w2 = uvw.zxy * 2.0;\n  vec3 r2 = uvw.xyz * 2.0;\n  vec3 s2 = uvw.yzx * 2.0;\n  vec3 t2 = uvw.zxy * 2.0;\n  vec3 uv3 = uvw.xy * 3.0;\n  vec3 vw3 = uvw.yz * 3.0;\n  vec3 wu3 = uvw.zw * 3.0;\n  vec3 u3 = uvw.xyz * 3.0;\n  vec3 v3 = uvw.yzx * 3.0;\n  vec3 w3 = uvw.zxy * 3.0;\n  vec3 r3 = uvw.xyz * 3.0;\n  vec3 s3 = uvw.yzx * 3.0;\n  vec3 t3 = uvw.zxy * 3.0;\n  vec3 uv4 = uvw.xy * 4.0;\n  vec3 vw4 = uvw.yz * 4.0;\n  vec3 wu4 = uvw.zw * // incomplete generation!\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    tilingVal3D a = rohmCell(uvw, vec3( .0, .0, .0), gridRes);\n    tilingVal3D b = rohmCell(uvw, vec3( .5, .0, qurt_sqrt2), gridRes);\n    tilingVal3D c = rohmCell(uvw, vec3( .0, .5, qurt_sqrt2), gridRes);\n    tilingVal3D d = rohmCell(uvw, vec3( .0, .0, half_sqrt2), gridRes);\n   \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.alpha, b.alpha, \n                                c.alpha, d.alpha), contrast);\n                                \n#ifdef ZEROTOONE\n    // rescale UVWs to 0-1\n    a.grid = a.grid *0.5+0.5;\n    b.grid = b.grid *0.5+0.5;\n    c.grid = c.grid *0.5+0.5;\n    d.grid = d.grid *0.5+0.5;   \n#endif\n    \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = a.grid * alpha.x +\n               b.grid * alpha.y +\n               c.grid * alpha.z +\n               d.grid * alpha.w;\n#ifndef ZEROTOONE\n    col *= 2.0;\n#endif\n\n#ifdef ALPHA\n    col = alpha.xyz;\n#endif\n    \n    return col;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    vec3 uv = uvw.xy;\n    vec3 w = uvw.z;\n    vec3 uv2 = uv * 2.0;\n    vec3 uv3 = uv * 3.0;\n    vec3 uv4 = uv * 4.0;\n    vec3 uv5 = uv * 5.0;\n    vec3 uv6 = uv * 6.0;\n    vec3 uv7 = uv * 7.0;\n    vec3 uv8 = uv * 8.0;\n    vec3 uv9 = uv * 9.0;\n    vec3 uv10 = uv * 10.0;\n    vec3 uv11 = uv * 11.0;\n    vec3 uv12 = uv * 12.0;\n    vec3 uv13 = uv * 13.0;\n    vec3 uv14 = uv * 14.0;\n    vec3 uv15 = uv * 15.0;\n    vec3 uv16 = uv * 16.0;\n    vec3 uv17 = uv * 17.0;\n    vec3 uv18 = uv * 18.0;\n    vec3 uv19 = uv * 19.0;\n    vec3 uv20 = uv * 20.0;\n    vec3 uv21 = uv * 21.0;\n    vec3 uv22 = uv * 22.0;\n    vec3 uv23 = uv * 23.0;\n    vec3 uv24 = uv * 24.0;\n    vec3 uv25 = uv * 25.0;\n    vec3 uv26 = uv * 26.0;\n    vec3 uv27 = uv * 27.0// incomplete generation!\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI created an algorithm, that gives you the distance to the nearest edge of an\nIcosahedron.\n\nIt has mouse controls to rotated around the center.\n\nI made this because I wanted to make a 3D tiling pattern, but I only skim\nread the Wikipedia article and chose the wrong shape. This shape cannot be \nseamlessly tiled. Lol\n*/\n\n#define pi              3.1415926536\n#define inv_sqrt3\t0.5773502693 // 1/sqrt(3)\n#define nGRa \t\t0.3568220898 // normalized Golden Ration\n#define nGRc \t\t0.9341723590 // normalized 2 Golden Ration + 1\n\nconst vec3 hrA = vec3(inv_sqrt3); //vector to Icosahedron Edge A\nconst vec3 hrB = vec3(0., nGRc, nGRa); //vector to Icosahedron Edge B\nconst vec3 hrC = vec3(nGRa, 0., nGRc); //vector to Icosahedron Edge C\nconst vec3 hrD = vec3(nGRc, nGRa, 0.); //vector to Icosahedron Edge D\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p);\n    float a = 1.0 / cos(radians(36.0));\n    float r = a * sqrt(3.0);\n    float s = r / 2.0;\n    float t = s / tan(radians(36.0));\n    float u = t / 2.0;\n    float v = sqrt(u * u + t * t);\n    float w = v - u;\n    float x = w / sqrt(2.0);\n    float y = x / cos(radians(36.0));\n    float z = y / tan(radians(36.0));\n    float e = z / 2.0;\n    float f = e / cos(radians(36.0));\n    float g = f / 2.0;\n    float h = g / cos(radians(36.0));\n    float i = h / 2.0;\n    float j = i / cos(radians(36.0));\n    float k = j / 2.0;\n    float l = k / cos(radians(36.0));\n    float m = l / 2.0;\n    float n = m / cos(radians(36.0));\n    float o = n / 2.0;\n    float p1 = o / cos(radians(36.0));\n    float q = p1 / 2.0;\n    float r1 = q / cos(radians(36.0));\n    float s1 = r1 / 2.0;\n    float t1 = s1 / cos(radians(36.0));\n    float u1 = t1 / 2.0;\n    float v1 = u1 / cos(radians(36.0));\n    float w1 = v1 / 2.0;\n    float x1 = w1 / cos(radians(36.0));\n    float y1 = x1 / 2.0;\n    float z1 = y1 / cos(radians(36.0));\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    const vec3 c0 = vec3(-0.000941,1.000941,1.000000);\n    const vec3 c1 = vec3(1.001170,-1.001170,-0.000000);\n    const vec3 c2 = vec3(0.004744,-0.004748,0.000001);\n    const vec3 c3 = vec3(-0.011841,0.011841,-0.000005);\n    const vec3 c4 = vec3(0.012964,-0.012943,0.000009);\n    const vec3 c5 = vec3(-0.005110,0.005073,-0.000008);\n    const vec3 c6 = vec3(-0.000046,0.000064,0.000003);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = IcoDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = Cool(ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI created an algorithm, that gives you the distance to the nearest edge of an\nIcosahedron.\n\nIt has mouse controls to rotated around the center.\n\nI made this because I wanted to make a 3D tiling pattern, but I only skim\nread the Wikipedia article and chose the wrong shape. This shape cannot be \nseamlessly tiled. Lol\n*/\n\n#define pi              3.1415926536\n#define inv_sqrt3\t0.5773502693 // 1/sqrt(3)\n#define nGRa \t\t0.3568220898 // normalized Golden Ration\n#define nGRc \t\t0.9341723590 // normalized 2 Golden Ration + 1\n\nconst vec3 hrA = vec3(inv_sqrt3); //vector to Icosahedron Edge A\nconst vec3 hrB = vec3(0., nGRc, nGRa); //vector to Icosahedron Edge B\nconst vec3 hrC = vec3(nGRa, 0., nGRc); //vector to Icosahedron Edge C\nconst vec3 hrD = vec3(nGRc, nGRa, 0.); //vector to Icosahedron Edge D\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    p = abs(p);\n    float pAB = max(dot(p, hrA),dot(p, hrB));\n    float pCD = max(dot(p, hrC),dot(p, hrD));\n    float dist = max(pAB,pCD);\n    \n    // optional makes it 0-1 inside, and negative outside\n    return (.5-dist)*2.; \n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = IcoDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = Cool(ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI created an algorithm, that gives you the distance to the nearest edge of an\nIcosahedron.\n\nIt has mouse controls to rotated around the center.\n\nI made this because I wanted to make a 3D tiling pattern, but I only skim\nread the Wikipedia article and chose the wrong shape. This shape cannot be \nseamlessly tiled. Lol\n*/\n\n#define pi              3.1415926536\n#define inv_sqrt3\t0.5773502693 // 1/sqrt(3)\n#define nGRa \t\t0.3568220898 // normalized Golden Ration\n#define nGRc \t\t0.9341723590 // normalized 2 Golden Ration + 1\n\nconst vec3 hrA = vec3(inv_sqrt3); //vector to Icosahedron Edge A\nconst vec3 hrB = vec3(0., nGRc, nGRa); //vector to Icosahedron Edge B\nconst vec3 hrC = vec3(nGRa, 0., nGRc); //vector to Icosahedron Edge C\nconst vec3 hrD = vec3(nGRc, nGRa, 0.); //vector to Icosahedron Edge D\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    p = abs(p);\n    float pAB = max(dot(p, hrA),dot(p, hrB));\n    float pCD = max(dot(p, hrC),dot(p, hrD));\n    float dist = max(pAB,pCD);\n    \n    // optional makes it 0-1 inside, and negative outside\n    return (.5-dist)*2.; \n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    const vec3 c0 = vec3(-0.000941,1.000941,1.000000);\n    const vec3 c1 = vec3(1.001170,-1.001170,-0.000000);\n    const vec3 c2 = vec3(0.004744,-0.004748,0.000001);\n    const vec3 c3 = vec3(-0.011841,0.011841,-0.000005);\n    const vec3 c4 = vec3(0.012964,-0.012943,0.000009);\n    const vec3 c5 = vec3(-0.005110,0.005073,-0.000008);\n    const vec3 c6 = vec3(-0.000046,0.000064,0.000003);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    v = m * v;\n    s = sin(a.y);\n    c = cos(a.y);\n    m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    v = m * v;\n    s = sin(a.z);\n    c = cos(a.z);\n    m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    v = m * v;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = IcoDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = Cool(ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}"], ["// License CC0: Mandelbrot variation\n//  Tinkered with julia mapping. Not amazing but different enough to share.\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat cell_df(vec2 np, vec2 mp, vec2 off) {\n  const vec2 n0 = normalize(vec2(1.0, 1.0));\n  const vec2 n1 = normalize(vec2(-1.0, 1.0));\n\n  np += off;\n  mp -= off;\n  \n  float hh = hash(np);\n  vec2 n = hh > 0.5 ? n0 : n1;\n  vec2 t = vec2(n.y, -n.x);\n\n\n  vec2  p0 = mp;  \n  p0 = abs(p0);\n  p0 -= 0.5;\n  float d0 = length(p0)-0.0;\n\n  vec2  p1 = mp;\n  float d1 = dot(n, p1);\n  float px = dot(t, p1);\n  d1 = abs(px) > sqrt(0.5) ? d0 : abs(d1); \n\n  float d = d0;\n  d = min(d, d1);\n  \n  return d;\n}\n\nfloat truchet_df(vec2 p) {\n  vec2 np = floor(p+0.5);\n  vec2 mp = fract(p+0.5) - 0.5;\n  float d = 1E6;\n  const float off = 1.0;\n  for (float x=-off;x<=off;++x) {\n    for (float y=-off;y<=off;++y) {\n      vec2 o = vec2(x,y);\n      d = min(d,cell_df(np, mp, o));\n    }\n  }\n  return d;\n}\n\nvoid julia_map(inout vec2 p, vec2 c) {\n  for (int i = 0; i < 89; ++i) {\n    vec2 p2 = p*p;\n    p = vec2(p2.x-p2.y, 2.0*p.x*p.y);\n    p += c;\n  }\n}\n\nvec2 transform(vec2 p) {\n  p *= 0.0125;\n  p.x -= 0.5;\n  p += vec2(0.59, 0.62);\n  julia_map(p, p);\n  p *= 30.0;\n  p += 0.2*TIME;\n  return p;\n}\n\nvec3 effect(vec3 col, vec2 p_, vec2 np_) {\n  vec2 p  = transform(p_);\n  vec2 np = transform(np_);\n  float aa = distance(p, np)*sqrt(0.5);\n\n  float d = truchet_df(p)-aa;\n  \n  col = mix(col, vec3(0.1), smoothstep(aa, -aa, d));\n\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p+2.0/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p, np);\n  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n  vec2 k = abs(p);\n  return max(k.x, (k.y + (k.x * 0.5)));\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {\n    vec2 q = vec2(uv.x, uv.y + uv.x / 2.0);\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    vec2 g = mod(i, 2.0);\n    vec2 r = mod(i, 2.0) - 0.5;\n    vec2 s = step(g, vec2(1.0));\n    vec2 t = s - 1.0 + 2.0 * r;\n    vec2 u = f - s;\n    vec2 v = f - 1.0 + s;\n    vec2 w = v + t;\n    vec2 x = min(u, v);\n    vec2 y = max(u, v);\n    vec2 z = min(x, w);\n    vec2 a = max(x, w);\n    vec2 b = min(y, z);\n    vec2 c = max(y, z);\n    vec2 d = min(a, b);\n    vec2 e = max(a, b);\n    vec2 f0 = vec2(0.0);\n    vec2 f1 = vec2(1.0);\n    vec2 f2 = vec2(2.0);\n    vec2 f3 = vec2(3.0);\n    vec2 f4 = vec2(4.0);\n    vec2 f5 = vec2(5.0);\n    vec2 f6 = vec2(6.0);\n    vec2 f7 = vec2(7.0);\n    vec2 f8 = vec2(8.0);\n    vec2 f9 = vec2(9.0);\n    vec2 fa = vec2(10.0);\n    vec2 fb = vec2(11.0);\n    vec2 fc = vec2(12.0);\n    vec2 fd = vec2(13.0);\n    vec2 fe = vec2(14.0);\n    vec2 ff =// incomplete generation!\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = vec3(0.0);\n    c.r = pow(t, 6.0);\n    c.g = 1.5 * t - 0.5 * pow(t, 2.0) - 0.5 * pow(t, 3.0);\n    c.b = 3.0 * pow(t, 2.0) - 2.0 * pow(t, 3.0);\n    return c;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    vec2 p = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    float d = 1.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash2(p + g + offset);\n            vec2 r = g + o - f;\n            float l = length(r);\n            float s = smoothstep(0.0, 1.0, sin(time * 0.1 + l * 10.0));\n            d = min(d, s);\n        }\n    }\n    return d;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float x = uv.x;\n    float y = uv.y;\n    float t = time;\n    float res = gridRes;\n    float len = len;\n    float x1 = x + sin(t + y * res) * len;\n    float x2 = x + sin(t + y * res + 1.0) * len;\n    float x3 = x + sin(t + y * res + 2.0) * len;\n    float y1 = y + sin(t + x * res) * len;\n    float y2 = y + sin(t + x * res + 1.0) * len;\n    float y3 = y + sin(t + x * res + 2.0) * len;\n    float x1_ = x1 + sin(t + y1 * res) * len;\n    float x2_ = x2 + sin(t + y2 * res) * len;\n    float x3_ = x3 + sin(t + y3 * res) * len;\n    float y1_ = y1 + sin(t + x1 * res) * len;\n    float y2_ = y2 + sin(t + x2 * res) * len;\n    float y3_ = y3 + sin(t + x3 * res) * len;\n    float x1__ = x1_ + sin(t + y1_ * res) * len;\n    float x2__ = x2_ + sin(t + y2_ * res) * len;\n    float x3__ = x3_ + sin(t + y3_ * res) * len;\n    float y1__ = y1_ + sin(t + x1_ * res) * len;\n    float y2__ = y2_ + sin(t + x2_ * res) * len;\n    float y3__ = y3_ + sin(t + x3_ * res) * len;\n    float x1___ = x1__ + sin(t + y1__ * res)// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is an approximation of a tropical cyclone flowmap at sea level. \nThe reference cyclone had a diamter of 300km. The maximum velocity was 53m/s. \nIt was generated using the CM1 weather model in a super computer. \n\nThe flowmap is just a vector field that can be used for other stuff like this \n(https://www.shadertoy.com/view/7dycDV)\n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define twoPi           6.2831853072\n#define pi              3.1415926536\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n  vec2 center = vec2(0.0, 0.0);\n  vec2 dir = normalize(point - center);\n  float dist = length(point - center);\n  float speed = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.3; // of the first spiral\n    float time = iTime * 1.0; // rotation speed  \n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    \n    vec2 flowMap = cycloneFlow(uv, radius, time);    \n        \n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n\n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a donut shaped flowmap I did for testing. \n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{    \n    float cenderDistance = length(point); // distance to center    \n    // simple inverted x^2 https://www.desmos.com/calculator/ibidozowyh\n    float donut =  1.0-pow(2.0*(cenderDistance-offset)/spread, 2.0);     \n    donut = clamp(donut, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(-point.y, point.x)); // flow vectors\n    flow *= donut;  // masked by donut\n    //flow = (flow+1.0)/2.0; // generates a flowmap texture\n    //flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    uv += vec2(cos(iTime),sin(iTime))*0.1; //rotating center\n    float spread = mix(0.4, 0.3, sin(0.9*iTime)*0.5+0.5); //changing donut size\n    \n    // making flowmap\n    vec2 flowMap = donutFlow(uv, spread, 0.33);\n     \n    //adding arrows\n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n    \n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a donut shaped flowmap I did for testing. \n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n  vec2 pa = p - p1;\n  vec2 ba = p2 - p1;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{    \n    float cenderDistance = length(point); // distance to center    \n    // simple inverted x^2 https://www.desmos.com/calculator/ibidozowyh\n    float donut =  1.0-pow(2.0*(cenderDistance-offset)/spread, 2.0);     \n    donut = clamp(donut, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(-point.y, point.x)); // flow vectors\n    flow *= donut;  // masked by donut\n    //flow = (flow+1.0)/2.0; // generates a flowmap texture\n    //flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    uv += vec2(cos(iTime),sin(iTime))*0.1; //rotating center\n    float spread = mix(0.4, 0.3, sin(0.9*iTime)*0.5+0.5); //changing donut size\n    \n    // making flowmap\n    vec2 flowMap = donutFlow(uv, spread, 0.33);\n     \n    //adding arrows\n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n    \n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a donut shaped flowmap I did for testing. \n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n  vec2 p1 = arrowTileCenterCoord(p);\n  vec2 p2 = p1 + v;\n  vec2 p3 = p1 + v * 0.5;\n  vec2 p4 = p1 + v * 0.5 + v.yx * 0.5;\n  vec2 p5 = p1 + v * 0.5 - v.yx * 0.5;\n  vec2 p6 = p1 + v * 0.5 + v.yx * 0.5 * 0.5;\n  vec2 p7 = p1 + v * 0.5 - v.yx * 0.5 * 0.5;\n  vec2 p8 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5;\n  vec2 p9 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5;\n  vec2 p10 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p11 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p12 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p13 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p14 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p1// incomplete generation!\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{    \n    float cenderDistance = length(point); // distance to center    \n    // simple inverted x^2 https://www.desmos.com/calculator/ibidozowyh\n    float donut =  1.0-pow(2.0*(cenderDistance-offset)/spread, 2.0);     \n    donut = clamp(donut, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(-point.y, point.x)); // flow vectors\n    flow *= donut;  // masked by donut\n    //flow = (flow+1.0)/2.0; // generates a flowmap texture\n    //flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    uv += vec2(cos(iTime),sin(iTime))*0.1; //rotating center\n    float spread = mix(0.4, 0.3, sin(0.9*iTime)*0.5+0.5); //changing donut size\n    \n    // making flowmap\n    vec2 flowMap = donutFlow(uv, spread, 0.33);\n     \n    //adding arrows\n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n    \n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a donut shaped flowmap I did for testing. \n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n  return (x + 1.0) / 2.0;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{    \n    float cenderDistance = length(point); // distance to center    \n    // simple inverted x^2 https://www.desmos.com/calculator/ibidozowyh\n    float donut =  1.0-pow(2.0*(cenderDistance-offset)/spread, 2.0);     \n    donut = clamp(donut, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(-point.y, point.x)); // flow vectors\n    flow *= donut;  // masked by donut\n    //flow = (flow+1.0)/2.0; // generates a flowmap texture\n    //flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    uv += vec2(cos(iTime),sin(iTime))*0.1; //rotating center\n    float spread = mix(0.4, 0.3, sin(0.9*iTime)*0.5+0.5); //changing donut size\n    \n    // making flowmap\n    vec2 flowMap = donutFlow(uv, spread, 0.33);\n     \n    //adding arrows\n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n    \n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a donut shaped flowmap I did for testing. \n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{\n    vec2 center = vec2(0.5, 0.5);\n    float radius = 0.25;\n    float innerRadius = 0.1;\n    float outerRadius = 0.3;\n    float innerSpread = 0.05;\n    float outerSpread = 0.05;\n    float innerOffset = 0.0;\n    float outerOffset = 0.0;\n    float innerAngle = atan(point.y - center.y, point.x - center.x);\n    float outerAngle = atan(point.y - center.y, point.x - center.x);\n    float innerDistance = distance(point, center);\n    float outerDistance = distance(point, center);\n    float innerAngleOffset = innerAngle + innerOffset;\n    float outerAngleOffset = outerAngle + outerOffset;\n    float innerAngleSpread = innerAngle + innerSpread;\n    float outerAngleSpread = outerAngle + outerSpread;\n    float innerAngleSpreadOffset = innerAngle + innerSpread + innerOffset;\n    float outerAngleSpreadOffset = outerAngle + outerSpread + outerOffset;\n    float innerAngleSpreadOffsetDistance = distance(point, center);\n    float outerAngleSpreadOffsetDistance = distance(point, center);\n    float innerAngleSpreadOffsetDistanceSpread = innerAngleSpreadOffsetDistance + innerSpread;\n    float outerAngleSpreadOffsetDistanceSpread = outerAngleSpreadOffsetDistance + outerSpread;\n    float innerAngleSpreadOffsetDistanceSpreadOffset = innerAngleSpreadOffsetDistance + innerSpread + innerOffset;\n    float outerAngleSpreadOffsetDistanceSpreadOffset = outerAngleSpreadOffsetDistance + outerSpread + outerOffset;\n    float innerAngleSpreadOffsetDistanceSpreadOffsetDistance = distance(point, center);\n    float outerAngleSpreadOffsetDistanceSpreadOffsetDistance = distance(point, center);\n    float innerAngleSpreadOffsetDistanceSpreadOffsetDistanceSpread = innerAngleSpreadOffsetDistanceSpreadOffsetDistance + innerSpread;\n    float outerAngleSp// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    uv += vec2(cos(iTime),sin(iTime))*0.1; //rotating center\n    float spread = mix(0.4, 0.3, sin(0.9*iTime)*0.5+0.5); //changing donut size\n    \n    // making flowmap\n    vec2 flowMap = donutFlow(uv, spread, 0.33);\n     \n    //adding arrows\n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n    \n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the SDF of a limited number of copies of a base\n// SDF object constrained to a circle.\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: https://iquilezles.org/articles/distfunctions\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp, in float time )\n{\n    float d;\n    if( sin(time/2.0)>0.0 )\n    {\n        d = sdBox( p, vec2(0.1,0.1)*sp ) - 0.2*sp;\n    }\n    else\n    {\n        if( mod(id.x+id.y,2.0)>0.5 )\n          d = sdBox( p, vec2(0.2*sp) );\n        else\n          d = sdBox( p, vec2(0.2,0.02)*sp ) - 0.3*sp;\n    }\n    return d;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    // make grid\n    vec2 id0 = round(p/sp);\n    \n    // snap to circle\n    if( dot(id0,id0)>ra*ra ) id0 = round(normalize(id0)*ra);\n    \n    // scan neighbors\n    float d = 1e20;\n    for( int j=-2; j<=2; j++ ) // increase this search window\n    for( int i=-2; i<=2; i++ ) // for large values of ra\n    {\n        vec2 id = id0 + vec2(i,j);\n        if( dot(id,id)<=ra*ra )\n        {\n            vec2 q = p-sp*id;\n            d = min( d, sdBase(q,id,sp,time) );\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n    float time = iTime + 0.001;\n    \n    // circle radius and cell size, to be tuned for your needs\n    float ra = floor(3.0 + 8.0*(0.5-0.5*cos(time)));\n    float sp = 0.8/ra;\n\n    // sdf\n    float d = sdCircularRepetition( p, ra, sp, time );\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos( 120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.009,abs(d)) );\n   \n    if( iMouse.z>0.001 )\n    {\n    d = sdCircularRepetition( m, ra, sp, time );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the SDF of a limited number of copies of a base\n// SDF object constrained to a circle.\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: https://iquilezles.org/articles/distfunctions\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp, in float time )\n{\n    float t = time;\n    float t2 = t * 0.5;\n    float t3 = t * 0.25;\n    float t4 = t * 0.125;\n    float t5 = t * 0.0625;\n    float t6 = t * 0.03125;\n    float t7 = t * 0.015625;\n    float t8 = t * 0.0078125;\n    float t9 = t * 0.00390625;\n    float t10 = t * 0.001953125;\n    float t11 = t * 0.0009765625;\n    float t12 = t * 0.00048828125;\n    float t13 = t * 0.000244140625;\n    float t14 = t * 0.0001220703125;\n    float t15 = t * 0.00006103515625;\n    float t16 = t * 0.000030517578125;\n    float t17 = t * 0.0000152587890625;\n    float t18 = t * 0.00000762939453125;\n    float t19 = t * 0.000003814697265625;\n    float t20 = t * 0.0000019073486328125;\n    float t21 = t * 0.00000095367431640625;\n    float t22 = t * 0// incomplete generation!\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    // make grid\n    vec2 id0 = round(p/sp);\n    \n    // snap to circle\n    if( dot(id0,id0)>ra*ra ) id0 = round(normalize(id0)*ra);\n    \n    // scan neighbors\n    float d = 1e20;\n    for( int j=-2; j<=2; j++ ) // increase this search window\n    for( int i=-2; i<=2; i++ ) // for large values of ra\n    {\n        vec2 id = id0 + vec2(i,j);\n        if( dot(id,id)<=ra*ra )\n        {\n            vec2 q = p-sp*id;\n            d = min( d, sdBase(q,id,sp,time) );\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n    float time = iTime + 0.001;\n    \n    // circle radius and cell size, to be tuned for your needs\n    float ra = floor(3.0 + 8.0*(0.5-0.5*cos(time)));\n    float sp = 0.8/ra;\n\n    // sdf\n    float d = sdCircularRepetition( p, ra, sp, time );\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos( 120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.009,abs(d)) );\n   \n    if( iMouse.z>0.001 )\n    {\n    d = sdCircularRepetition( m, ra, sp, time );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the SDF of a limited number of copies of a base\n// SDF object constrained to a circle.\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: https://iquilezles.org/articles/distfunctions\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp, in float time )\n{\n    float d;\n    if( sin(time/2.0)>0.0 )\n    {\n        d = sdBox( p, vec2(0.1,0.1)*sp ) - 0.2*sp;\n    }\n    else\n    {\n        if( mod(id.x+id.y,2.0)>0.5 )\n          d = sdBox( p, vec2(0.2*sp) );\n        else\n          d = sdBox( p, vec2(0.2,0.02)*sp ) - 0.3*sp;\n    }\n    return d;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float t = time;\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float aa = mod(a+t,sp)-sp/2.0;\n    float rr = r + sin(aa)*ra;\n    return rr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n    float time = iTime + 0.001;\n    \n    // circle radius and cell size, to be tuned for your needs\n    float ra = floor(3.0 + 8.0*(0.5-0.5*cos(time)));\n    float sp = 0.8/ra;\n\n    // sdf\n    float d = sdCircularRepetition( p, ra, sp, time );\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos( 120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.009,abs(d)) );\n   \n    if( iMouse.z>0.001 )\n    {\n    d = sdCircularRepetition( m, ra, sp, time );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nSimple 3D Cubic Tiling. It looks like triangles and hexagons, because I rotated \nit a bit. What you see is the Edge Distance.\n\nThis project contains algorithms for the edge distance, center distance, ID and \nUVW coordinates of a cubeic honeycomb grid.\n\nThe caluclation for the cube gird is very fast. I wonder, if this is faster to \ncalculate 3D cubes and rotate them compated to making a 2D triangle grid the \nnormal way. Maybe I'll test that later.\n*/\n\n#define sqrt25 \t\t\t0.6324555320 //sqrt(2./5.)\n#define sqrt35 \t\t\t0.7745966692 //sqrt(3./5.)\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n  return min(min(uvw.x, uvw.y), uvw.z);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) {\n    vec3 grid = fract(uvw)-.5; // centered UVW coords\n    float edist = 1.-cubeDist(grid); // edge distance\n    //float cdist = dot(grid,grid); //squared center distance\n    //vec3 id = uvw-grid; // Cells IDs\n\n    return vec4(grid, edist);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec4 cubeTiling = cubeTile(uvw*gridRes + offset);\n    vec3 tiledUV = (cubeTiling.xyz - offset)/gridRes; //cube pixaltion\n    \n    return vec4(tiledUV,cubeTiling.w);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    const vec3 c0 = vec3(0.207621,0.196195,0.618832);\n    const vec3 c1 = vec3(-0.088125,3.196170,-0.353302);\n    const vec3 c2 = vec3(8.261232,-8.366855,14.368787);\n    const vec3 c3 = vec3(-2.922476,33.244294,-43.419173);\n    const vec3 c4 = vec3(-34.085327,-74.476041,37.159352);\n    const vec3 c5 = vec3(50.429790,67.145621,-1.750169);\n    const vec3 c6 = vec3(-21.188828,-20.935464,-6.501427);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.05*iTime); // used as z dimension  \n    float gridRes = 2.5; //size of cubes\n    \n    vec3 point = vec3(uv, time); //uvw cords\n    \n    //cosmetic rotate for fun triangles otherwise it looks so square\n    point = rotate(point, (vec3(sqrt25,sqrt35,0.))); //vec3 must be normalized\n    \n    vec4 a = cubeCell(point, vec3(0.), gridRes);  \n    \n    vec3 col = RdYlBu_r(a.w); // cosmetic Colormap\n    \n    fragColor = vec4(col, 1.);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nSimple 3D Cubic Tiling. It looks like triangles and hexagons, because I rotated \nit a bit. What you see is the Edge Distance.\n\nThis project contains algorithms for the edge distance, center distance, ID and \nUVW coordinates of a cubeic honeycomb grid.\n\nThe caluclation for the cube gird is very fast. I wonder, if this is faster to \ncalculate 3D cubes and rotate them compated to making a 2D triangle grid the \nnormal way. Maybe I'll test that later.\n*/\n\n#define sqrt25 \t\t\t0.6324555320 //sqrt(2./5.)\n#define sqrt35 \t\t\t0.7745966692 //sqrt(3./5.)\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    vec3 d = abs(uvw); //mirroring along axis\n    return max(d.x, max(d.y, d.z))*2.; //*2. for 0-1 range\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) {\n  vec3 absUvw = abs(uvw);\n  vec3 maxUvw = max(absUvw, 1.0 - absUvw);\n  vec3 maxUvw2 = maxUvw * maxUvw;\n  vec3 maxUvw3 = maxUvw2 * maxUvw;\n  vec3 maxUvw4 = maxUvw3 * maxUvw;\n  vec3 maxUvw5 = maxUvw4 * maxUvw;\n  vec3 maxUvw6 = maxUvw5 * maxUvw;\n  vec3 maxUvw7 = maxUvw6 * maxUvw;\n  vec3 maxUvw8 = maxUvw7 * maxUvw;\n  vec3 maxUvw9 = maxUvw8 * maxUvw;\n  vec3 maxUvw10 = maxUvw9 * maxUvw;\n  vec3 maxUvw11 = maxUvw10 * maxUvw;\n  vec3 maxUvw12 = maxUvw11 * maxUvw;\n  vec3 maxUvw13 = maxUvw12 * maxUvw;\n  vec3 maxUvw14 = maxUvw13 * maxUvw;\n  vec3 maxUvw15 = maxUvw14 * maxUvw;\n  vec3 maxUvw16 = maxUvw15 * maxUvw;\n  vec3 maxUvw17 = maxUvw16 * maxUvw;\n  vec3 maxUvw18 = maxUvw17 * maxUvw;\n  vec3 maxUvw19 = maxUvw18 * maxUvw;\n  vec3 maxUvw20 = maxUvw19 * maxUvw;\n  vec3 maxUvw21 = maxUvw20 * maxUvw;\n  vec3 maxUvw22 = maxUvw21 * maxUvw;\n  vec3 maxUvw23 = maxUvw22 * maxUvw;\n  vec3 maxUvw24 = maxUvw23 * maxUvw;\n  vec3 maxUvw25 = maxUvw24 * maxU// incomplete generation!\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec4 cubeTiling = cubeTile(uvw*gridRes + offset);\n    vec3 tiledUV = (cubeTiling.xyz - offset)/gridRes; //cube pixaltion\n    \n    return vec4(tiledUV,cubeTiling.w);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    const vec3 c0 = vec3(0.207621,0.196195,0.618832);\n    const vec3 c1 = vec3(-0.088125,3.196170,-0.353302);\n    const vec3 c2 = vec3(8.261232,-8.366855,14.368787);\n    const vec3 c3 = vec3(-2.922476,33.244294,-43.419173);\n    const vec3 c4 = vec3(-34.085327,-74.476041,37.159352);\n    const vec3 c5 = vec3(50.429790,67.145621,-1.750169);\n    const vec3 c6 = vec3(-21.188828,-20.935464,-6.501427);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.05*iTime); // used as z dimension  \n    float gridRes = 2.5; //size of cubes\n    \n    vec3 point = vec3(uv, time); //uvw cords\n    \n    //cosmetic rotate for fun triangles otherwise it looks so square\n    point = rotate(point, (vec3(sqrt25,sqrt35,0.))); //vec3 must be normalized\n    \n    vec4 a = cubeCell(point, vec3(0.), gridRes);  \n    \n    vec3 col = RdYlBu_r(a.w); // cosmetic Colormap\n    \n    fragColor = vec4(col, 1.);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nSimple 3D Cubic Tiling. It looks like triangles and hexagons, because I rotated \nit a bit. What you see is the Edge Distance.\n\nThis project contains algorithms for the edge distance, center distance, ID and \nUVW coordinates of a cubeic honeycomb grid.\n\nThe caluclation for the cube gird is very fast. I wonder, if this is faster to \ncalculate 3D cubes and rotate them compated to making a 2D triangle grid the \nnormal way. Maybe I'll test that later.\n*/\n\n#define sqrt25 \t\t\t0.6324555320 //sqrt(2./5.)\n#define sqrt35 \t\t\t0.7745966692 //sqrt(3./5.)\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    vec3 d = abs(uvw); //mirroring along axis\n    return max(d.x, max(d.y, d.z))*2.; //*2. for 0-1 range\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) {\n    vec3 grid = fract(uvw)-.5; // centered UVW coords\n    float edist = 1.-cubeDist(grid); // edge distance\n    //float cdist = dot(grid,grid); //squared center distance\n    //vec3 id = uvw-grid; // Cells IDs\n\n    return vec4(grid, edist);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes) {\n  vec3 cell = floor(uvw * gridRes);\n  vec3 f = fract(uvw * gridRes);\n  vec3 g = step(f, vec3(0.5));\n  vec3 h = 1.0 - g;\n  vec3 i = mod(cell, 2.0);\n  vec3 j = mod(cell + g, 2.0);\n  vec3 k = mod(cell + h, 2.0);\n  vec3 l = mod(cell + g + h, 2.0);\n  vec3 m = mod(cell + i, 2.0);\n  vec3 n = mod(cell + i + g, 2.0);\n  vec3 o = mod(cell + i + h, 2.0);\n  vec3 p = mod(cell + i + g + h, 2.0);\n  vec3 q = mod(cell + j, 2.0);\n  vec3 r = mod(cell + j + h, 2.0);\n  vec3 s = mod(cell + j + i, 2.0);\n  vec3 t = mod(cell + j + i + h, 2.0);\n  vec3 u = mod(cell + k, 2.0);\n  vec3 v = mod(cell + k + g, 2.0);\n  vec3 w = mod(cell + k + i, 2.0);\n  vec3 x = mod(cell + k + g + i, 2.0);\n  vec3 y = mod(cell + l, 2.0);\n  vec3 z = mod(cell + l + g, 2.0);\n  vec3 aa = mod(cell + l + i, 2.0);\n  vec3 ab = mod(cell + l + g + i, 2.0);\n  vec3 ac = mod(cell + m, 2.0);\n  vec3 ad = mod(cell + m + h, 2.0);\n  vec3 ae = mod(cell + m + j, 2.// incomplete generation!\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    const vec3 c0 = vec3(0.207621,0.196195,0.618832);\n    const vec3 c1 = vec3(-0.088125,3.196170,-0.353302);\n    const vec3 c2 = vec3(8.261232,-8.366855,14.368787);\n    const vec3 c3 = vec3(-2.922476,33.244294,-43.419173);\n    const vec3 c4 = vec3(-34.085327,-74.476041,37.159352);\n    const vec3 c5 = vec3(50.429790,67.145621,-1.750169);\n    const vec3 c6 = vec3(-21.188828,-20.935464,-6.501427);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.05*iTime); // used as z dimension  \n    float gridRes = 2.5; //size of cubes\n    \n    vec3 point = vec3(uv, time); //uvw cords\n    \n    //cosmetic rotate for fun triangles otherwise it looks so square\n    point = rotate(point, (vec3(sqrt25,sqrt35,0.))); //vec3 must be normalized\n    \n    vec4 a = cubeCell(point, vec3(0.), gridRes);  \n    \n    vec3 col = RdYlBu_r(a.w); // cosmetic Colormap\n    \n    fragColor = vec4(col, 1.);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nSimple 3D Cubic Tiling. It looks like triangles and hexagons, because I rotated \nit a bit. What you see is the Edge Distance.\n\nThis project contains algorithms for the edge distance, center distance, ID and \nUVW coordinates of a cubeic honeycomb grid.\n\nThe caluclation for the cube gird is very fast. I wonder, if this is faster to \ncalculate 3D cubes and rotate them compated to making a 2D triangle grid the \nnormal way. Maybe I'll test that later.\n*/\n\n#define sqrt25 \t\t\t0.6324555320 //sqrt(2./5.)\n#define sqrt35 \t\t\t0.7745966692 //sqrt(3./5.)\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    vec3 d = abs(uvw); //mirroring along axis\n    return max(d.x, max(d.y, d.z))*2.; //*2. for 0-1 range\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) {\n    vec3 grid = fract(uvw)-.5; // centered UVW coords\n    float edist = 1.-cubeDist(grid); // edge distance\n    //float cdist = dot(grid,grid); //squared center distance\n    //vec3 id = uvw-grid; // Cells IDs\n\n    return vec4(grid, edist);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec4 cubeTiling = cubeTile(uvw*gridRes + offset);\n    vec3 tiledUV = (cubeTiling.xyz - offset)/gridRes; //cube pixaltion\n    \n    return vec4(tiledUV,cubeTiling.w);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = vec3(0.0);\n    c.r = pow(t, 1.0/6.0);\n    c.g = pow(t, 1.0/3.0);\n    c.b = t;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.05*iTime); // used as z dimension  \n    float gridRes = 2.5; //size of cubes\n    \n    vec3 point = vec3(uv, time); //uvw cords\n    \n    //cosmetic rotate for fun triangles otherwise it looks so square\n    point = rotate(point, (vec3(sqrt25,sqrt35,0.))); //vec3 must be normalized\n    \n    vec4 a = cubeCell(point, vec3(0.), gridRes);  \n    \n    vec3 col = RdYlBu_r(a.w); // cosmetic Colormap\n    \n    fragColor = vec4(col, 1.);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI made this simple edge distance function for the Cuboctahedron. \nIt's basically a cube with cut of corners.\n\nIt has mouse controls to rotated around the center.\n\nThis shape is one of the two shapes best for close packing of spheres (FCC). \nThis shape is not part of the Honeycomb group, so it doesn't tile seamlessly. \n*/\n\n#define pi              3.1415926536\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p) {\n    vec3 q = abs(p);\n    float s = max(q.x, max(q.y, q.z));\n    float t = min(q.x, min(q.y, q.z));\n    float u = (q.x + q.y + q.z - s - t) / 2.0;\n    return length(vec3(s - t, s - u, u)) - 1.0;\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    const vec3 c0 = vec3(-0.000000,-0.000941,1.000471);\n    const vec3 c1 = vec3(0.000000,1.001170,-0.500585);\n    const vec3 c2 = vec3(-0.000000,0.004744,-0.002369);\n    const vec3 c3 = vec3(0.000000,-0.011841,0.005901);\n    const vec3 c4 = vec3(-0.000000,0.012964,-0.006433);\n    const vec3 c5 = vec3(0.000000,-0.005110,0.002500);\n    const vec3 c6 = vec3(-0.000000,-0.000046,0.000045);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = cubocDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = winter(1.-ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI made this simple edge distance function for the Cuboctahedron. \nIt's basically a cube with cut of corners.\n\nIt has mouse controls to rotated around the center.\n\nThis shape is one of the two shapes best for close packing of spheres (FCC). \nThis shape is not part of the Honeycomb group, so it doesn't tile seamlessly. \n*/\n\n#define pi              3.1415926536\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p) {\n    vec3 hra = vec3(0.5); //vector to Diagonal Edge\n    \n    p = abs(p);\n    float pAB = max(p.x,p.y); //rigt and left edge  \n    float pCD = max(dot(p, hra),p.z); //diagonal and top edge\n    \n    float pABCD = max(pAB, pCD);\n    \n    //optional 0-1 range\n    return (.5-pABCD)*2.;\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = cubocDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = winter(1.-ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n  vec2 tile = floor(uv);\n  vec2 tileF = fract(uv);\n  vec2 tileC = tileF - 0.5;\n  vec2 tileN = vec2(tileC.y, tileC.x);\n  vec2 tileN2 = vec2(tileC.y, -tileC.x);\n  vec2 tileN3 = vec2(-tileC.y, tileC.x);\n  vec2 tileN4 = vec2(-tileC.y, -tileC.x);\n  vec2 tileN5 = vec2(tileC.y, tileC.x);\n  vec2 tileN6 = vec2(tileC.y, -tileC.x);\n  vec2 tileN7 = vec2(-tileC.y, tileC.x);\n  vec2 tileN8 = vec2(-tileC.y, -tileC.x);\n  vec2 tileN9 = vec2(tileC.y, tileC.x);\n  vec2 tileN10 = vec2(tileC.y, -tileC.x);\n  vec2 tileN11 = vec2(-tileC.y, tileC.x);\n  vec2 tileN12 = vec2(-tileC.y, -tileC.x);\n  vec2 tileN13 = vec2(tileC.y, tileC.x);\n  vec2 tileN14 = vec2(tileC.y, -tileC.x);\n  vec2 tileN15 = vec2(-tileC.y, tileC.x);\n  vec2 tileN16 = vec2(-tileC.y, -tileC.x);\n  vec2 tileN17 = vec2(tileC.y, tileC.x);\n  vec2 tileN18 = vec2(tileC.y, -tileC.x);\n  vec2 tileN19 = vec2(-tileC.y, tileC.x);\n  vec2 tileN20 = vec2(-tileC.y, -tileC.x);\n  vec2 tileN21 = vec2(tileC.y, tileC// incomplete generation!\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n  vec2 p = fract(uv);\n  vec2 q = abs(p - 0.5);\n  vec2 r = 0.5 - q;\n  vec2 s = step(p, 0.5);\n  vec2 t = s - (1.0 - s);\n  vec2 u = t * r + (1.0 - t) * q;\n  return vec3(u, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n  vec2 grid = floor(uv * gridRes);\n  vec2 gridCenter = (grid + 0.5) / gridRes;\n  vec2 gridOffset = gridCenter + offset;\n  return vec3(gridOffset, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n  vec2 grid = floor(uv * gridRes);\n  vec2 gridCenter = (grid + 0.5) / gridRes;\n  vec2 gridOffset = gridCenter - uv;\n  vec2 gridOffset2 = gridOffset * gridRes;\n  vec2 gridOffset3 = gridOffset2 * gridRes;\n  vec2 gridOffset4 = gridOffset3 * gridRes;\n  vec2 gridOffset5 = gridOffset4 * gridRes;\n  vec2 gridOffset6 = gridOffset5 * gridRes;\n  vec2 gridOffset7 = gridOffset6 * gridRes;\n  vec2 gridOffset8 = gridOffset7 * gridRes;\n  vec2 gridOffset9 = gridOffset8 * gridRes;\n  vec2 gridOffset10 = gridOffset9 * gridRes;\n  vec2 gridOffset11 = gridOffset10 * gridRes;\n  vec2 gridOffset12 = gridOffset11 * gridRes;\n  vec2 gridOffset13 = gridOffset12 * gridRes;\n  vec2 gridOffset14 = gridOffset13 * gridRes;\n  vec2 gridOffset15 = gridOffset14 * gridRes;\n  vec2 gridOffset16 = gridOffset15 * gridRes;\n  vec2 gridOffset17 = gridOffset16 * gridRes;\n  vec2 gridOffset18 = gridOffset17 * gridRes;\n  vec2 gridOffset19 = gridOffset18 * gridRes;\n  vec2 gridOffset20 = gridOffset19 * gridRes;\n  vec2 gridOffset21 = gridOffset20 * gridRes;\n  vec2 gridOffset22 = gridOffset21 * gridRes;\n  vec2 gridOffset23 = gridOffset22 * gridRes;\n  vec2 gridOffset24 = gridOffset23 * gridRes;\n  vec2 gridOffset25 = gridOffset24 * gridRes;\n  vec2 gridOffset26 = gridOffset25 * gridRes;\n  vec2 gridOffset27 = gridOffset26 * gridRes;\n  vec2 gridOffset28 = gridOffset27 *// incomplete generation!\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    vec2 p = floor(uv * gridRes);\n    vec2 t = fract(uv * gridRes);\n    float tt = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt2 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt3 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt4 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt5 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt6 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt7 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt8 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt9 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt10 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt11 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt12 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt13 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt14 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt15 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt16 = 1.0 -// incomplete generation!\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {\n    float t = time * 0.0001;\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float x1 = mod(x + t, len);\n    float y1 = mod(y + t, len);\n    float x2 = mod(x - t, len);\n    float y2 = mod(y - t, len);\n    float x3 = mod(x + t, len * 2.0);\n    float y3 = mod(y + t, len * 2.0);\n    float x4 = mod(x - t, len * 2.0);\n    float y4 = mod(y - t, len * 2.0);\n    float x5 = mod(x + t, len * 3.0);\n    float y5 = mod(y + t, len * 3.0);\n    float x6 = mod(x - t, len * 3.0);\n    float y6 = mod(y - t, len * 3.0);\n    float x7 = mod(x + t, len * 4.0);\n    float y7 = mod(y + t, len * 4.0);\n    float x8 = mod(x - t, len * 4.0);\n    float y8 = mod(y - t, len * 4.0);\n    float x9 = mod(x + t, len * 5.0);\n    float y9 = mod(y + t, len * 5.0);\n    float x10 = mod(x - t, len * 5.0);\n    float y10 = mod(y - t, len * 5.0);\n    float x11 = mod(x + t, len * 6.0);\n    float y11 = mod(y + t, len * 6.0);\n    float x12 = mod(x - t, len * 6.0);\n    float y12 = mod(y - t, len * 6.0);\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray intersection for quadrics of this particular shape:\n//\n//  f(x,y,z) = \u00b1 a\u00b2x\u00b2 \u00b1 b\u00b2y\u00b2 \u00b1 c\u00b2z\u00b2 - {-1,0,1} = 0\n//\n// Note this is NOT a general quadric, it does not handle\n// paraboloids. It does however handle hyperboloids, cones and\n// ellipsods optimally (as opposed to a general quadric solver),\n// and also spheres, cylinders, slabs and so on, in a non-optimal\n// way as a bonus (you should use specialized code paths for\n// those shapes, do NOT use this). See this shader for paraboloids:\n//\n// https://www.shadertoy.com/view/sdyfDR\n//\n// a,b,c,d are the parameters of the shape. a,b,c are inverse\n// radii and d is either -1, 0 or 1. See lines 91 to 100.\n//\n// Sphere                  : a>0, b=a, c=a, d= 1\n// Ellipsoid               : a>0, b>0, c>0, d= 1\n// Cone                    : a>0, b<0, c>0, d= 0\n// Hyperboloid of 1 sheets : a>0, b<0, c>0, d= 1\n// Hyperboloid of 2 sheets : a>0, b<0, c>0, d=-1\n// Cylinder                : a>0, b=0, c>0, d= 1\n// Slab                    : a>0, b=0, c=0, d= 1\n// Hyperbolic Cylinder     : a>0, b=0, c<0, d=-1\n//\n// Note I'm showing symmetric cones and hyperboloids, but\n// you can just specify different radii for each axis.\n//\n//\n// List of ray-surface intersectors at \n//     https://www.shadertoy.com/playlist/l3dXRf\n// and\n//     https://iquilezles.org/articles/intersectors\n\nbool clipped( in vec3 pos, float clipY, float clipZ );\n\nfloat iQuadricTypeA(         // intersection distance. -1 if no intersection\n    in vec3  ro, in vec3 rd, // ray origin and direction\n    in vec4  abcd,           // the quadric (see above)\n    in float clipY,          // height of clipping volume\n    in float clipZ,          // depth  of clipping volume\n    out vec3 oNor,           // normal at intersection\n    out bool oInside )       // inside/outside identifier\n{\n    vec3 r2 = abcd.xyz*abs(abcd.xyz); // squared WITH sign\n    \n    float k2 = dot(rd,rd*r2);\n    float k1 = dot(rd,ro*r2);\n    float k0 = dot(ro,ro*r2) - abcd.w;\n             \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h) * sign(k2);\n\n    // entry point\n    float t = (-k1-h)/k2;\n    vec3 pos = ro + t*rd;\n    if( t>0.0 && clipped(pos,clipY,clipZ) ) \n    {\n        oInside = k2<0.0;\n        oNor = normalize(pos*r2);\n        return t;\n    }\n\n    // exit point\n    t = (-k1+h)/k2;\n    pos = ro + t*rd;\n    if( t>0.0 && clipped(pos,clipY,clipZ) )\n    {\n        oInside = k2>0.0;\n        oNor = normalize(pos*r2);\n        return t;\n    }\n\n    return -1.0;\n}\n\nbool clipped( in vec3 pos, float y, float z )\n{\n    return abs(pos.y)<y && abs(pos.z)<z;\n}\n\n//--------------------------------------------------------\n\n// shapes\nconst vec4 kShape[10] = vec4[10]( \n  vec4(1.0/1.6, 1.0/1.6,1.0/1.6, 1.0),  // sphere\n  vec4(1.0/1.7, 1.0/3.0,1.0/0.9, 1.0),  // ellipsoid\n  vec4(1.0/1.0, 0.0,    0.0,     1.0),  // slab\n  vec4(1.0/0.8, 0.0,   -1.0/0.8, 0.0),  // cross\n  vec4(1.0/0.8, 0.0,   -1.0/0.8,-1.0),  // hyperbolic cylinder\n  vec4(1.0/1.6, 0.0,    1.0/1.6, 1.0),  // cylinder\n  vec4(1.0/1.6, 0.0,    1.0/0.9, 1.0),  // cylinder\n  vec4(1.0/0.6,-1.0/1.2,1.0/0.6, 0.0),  // cone\n  vec4(1.0/0.3,-1.0/0.7,1.0/0.3, 1.0),  // hyperboloid of one sheet\n  vec4(1.0/0.3,-1.0/0.6,1.0/0.3,-1.0)); // hyperboloid of two sheets\n    \n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    vec2 h = vec2(0.0);\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 o = vec2(i,j);\n        vec2 r = vec2(0.5)-abs(f-0.5);\n        vec2 q = g + o + r;\n        float n = hash2( q );\n        float w = smoothstep( 0.0, 1.0, 1.0-abs(fract(n)-0.5) );\n        float v = textureGrad( iChannel0, q, ddx, ddy ).x;\n        res += v*w;\n        h += vec2(v,w);\n    }\n    return res/h.y;\n}\n\nvec2 getUV( in vec3 pos, ivec2 id )\n{\n    if( id.y==0 && id.x>=2 ) return 11.0*pos.zy;\n    \n    return vec2(12.0,11.0)*vec2(atan(pos.x,pos.z),pos.y);\n}\n\nvec3 getRay( in vec2 p, in vec3 uu, in vec3 vv, in vec3 ww )\n{\n    return normalize( p.x*uu + p.y*vv + 3.0*ww );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // clip height\n    float clipY = 1.0 + 2.0*smoothstep(-1.0,-0.8,-cos(iTime*6.283185/12.0));\n\n    // camera movement\t\n    float an1 = 0.4 + 0.9*smoothstep(0.7,0.9,-cos(iTime*6.283185/12.0));\n\tfloat an2 = 6.283185*iTime/6.0;\n\tvec3 ro = 12.0*vec3( cos(an1)*sin(an2), sin(an1), cos(an1)*cos(an2) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // global normalize coordinates\n    vec2 gp = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // viewport\n    ivec2 id  = ivec2(vec2(5.0,2.0)*fragCoord/iResolution.xy );\n    vec2  res = iResolution.xy/vec2(5.0,2.0);\n    vec2  q   = mod(fragCoord,res);\n        \n    float clipZ = (id.x>=2 && id.y==0) ? 1.4 : 2.0;\n    \n    // render\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(q+o)-res)/res.y;\n        #else    \n        vec2 p = (2.0*q-res)/res.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = getRay( p, uu, vv, ww );\n\n        // background\n\t    vec3 col = vec3(0.08) * (1.0-0.3*length(gp));\n        //col += 0.1*cos( float(5*id.y+id.x)+vec3(0,2,4));\n \n        // raytrace\n        bool isInside = false;\n        vec3 nor = vec3(0.0);\n        float t = iQuadricTypeA( ro, rd, kShape[5*id.y+id.x], clipY, clipZ, nor, isInside );\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n\n\n            // material\n\n            vec2 uv = getUV( pos, id );\n\n            // checkerboard pattern\n            {\n                col = vec3(0.6);\n                col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n                if( isInside ) col = vec3(1.5,0.6,0.0);\n            }\n            // grid lines\n            {\n                #if 0\n                // no filtering\n                col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n                #endif\n                #if 0\n                // hardware filtering\n                uv = 0.5 + uv/6.283185;\n                col *= gridTextureGradBox( uv, dFdx(uv), dFdy(uv) );\n                #endif\n                #if 1\n                // software filtering\n                // https://iquilezles.org/articles/filteringrm\n                vec2 px = vec2(p.x+2.0/res.y,p.y);\n                vec2 py = vec2(p.x,p.y+2.0/res.y);\n                vec3 rdx = getRay( px, uu, vv, ww );\n                vec3 rdy = getRay( py, uu, vv, ww );\n                vec3 posx = ro + t*rdx*dot(rd,nor)/dot(rdx,nor);\n                vec3 posy = ro + t*rdy*dot(rd,nor)/dot(rdy,nor);\n                vec2 uvx = getUV(posx, id);\n                vec2 uvy = getUV(posy, id);\n                uv  = 0.5 + uv /6.283185;\n                uvx = 0.5 + uvx/6.283185;\n                uvy = 0.5 + uvy/6.283185;\n                col *= gridTextureGradBox( uv, uvx-uv, uvy-uv );\n                #endif\n            }\n\n            // lighting\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            col *= vec3(0.2,0.3,0.4)*amb*2.0 + 0.7*vec3(1.0,0.9,0.7)*dif;\n            col += 0.3*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n       }\n \t\n        // gamma\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n     \n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}"], ["// License CC0: Rainbow boxes\n//  Wednesday hack to reproduce a commonly seen effect\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n    p = abs(p);\n    return max(p.x, p.y) - r;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nfloat cellf(vec2 p, vec2 n) {\n  const float lw = 0.01;\n  return -hexagon(p.yx, 0.5-lw);\n}\n\nvec2 df(vec2 p, out vec2 hn0, out vec2 hn1) {\n  const float sz = 0.25;\n  p /= sz;\n  vec2 hp0 = p;\n  vec2 hp1 = p+vec2(1.0, sqrt(1.0/3.0));\n\n  hn0 = hextile(hp0);\n  hn1 = hextile(hp1);\n\n  float d0 = cellf(hp0, hn0);\n  float d1 = cellf(hp1, hn1);\n  float d2 = length(hp0);\n\n  float d = d0;\n  d = min(d0, d1);\n\n  return vec2(d, d2)*sz;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 hn0;\n  vec2 hn1;\n  p .x+= 0.05*TIME;\n  vec2 d2 = df(p, hn0, hn1);\n\n  \n  vec3 col = vec3(0.01);\n\n  float h0 = hash(hn1);\n  float h = fract(-0.025*hn1.x+0.1*hn1.y-0.2*TIME);\n  float l = mix(0.25, 0.75, h0);\n\n  if (hn0.x <= hn1.x+0.5) {\n    l *= 0.5;\n  }\n\n  if (hn0.y <= hn1.y) {\n    l *= 0.75;\n  }\n  \n  col += hsv2rgb(vec3(h, 0.5, l));\n  \n  col = mix(col, vec3(0.), smoothstep(aa, -aa, d2.x));\n  col *= mix(0.75, 1.0, smoothstep(0.01, 0.2, d2.y));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME-0.5*length(p));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Rainbow boxes\n//  Wednesday hack to reproduce a commonly seen effect\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n//  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  const vec3 k = 0.5*vec3(-sqrt(3.0),1.0,sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n    float s = 1.0;\n    float t = 0.866025404;\n    float x = p.x;\n    float y = p.y;\n    float cx = floor(x / s);\n    float cy = floor(y / t);\n    float mx = x - cx * s;\n    float my = y - cy * t;\n    float b = mod(cy, 2.0);\n    float tx = cx * s;\n    float ty = cy * t;\n    if (b < 0.5) {\n        if (my <= t * mx) {\n            p = vec2(tx, ty);\n        } else {\n            p = vec2(tx + s, ty + t);\n        }\n    } else {\n        if (my <= -t * mx + t) {\n            p = vec2(tx + s, ty);\n        } else {\n            p = vec2(tx, ty + t);\n        }\n    }\n    return p;\n}\n\nfloat cellf(vec2 p, vec2 n) {\n  const float lw = 0.01;\n  return -hexagon(p.yx, 0.5-lw);\n}\n\nvec2 df(vec2 p, out vec2 hn0, out vec2 hn1) {\n  const float sz = 0.25;\n  p /= sz;\n  vec2 hp0 = p;\n  vec2 hp1 = p+vec2(1.0, sqrt(1.0/3.0));\n\n  hn0 = hextile(hp0);\n  hn1 = hextile(hp1);\n\n  float d0 = cellf(hp0, hn0);\n  float d1 = cellf(hp1, hn1);\n  float d2 = length(hp0);\n\n  float d = d0;\n  d = min(d0, d1);\n\n  return vec2(d, d2)*sz;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 hn0;\n  vec2 hn1;\n  p .x+= 0.05*TIME;\n  vec2 d2 = df(p, hn0, hn1);\n\n  \n  vec3 col = vec3(0.01);\n\n  float h0 = hash(hn1);\n  float h = fract(-0.025*hn1.x+0.1*hn1.y-0.2*TIME);\n  float l = mix(0.25, 0.75, h0);\n\n  if (hn0.x <= hn1.x+0.5) {\n    l *= 0.5;\n  }\n\n  if (hn0.y <= hn1.y) {\n    l *= 0.75;\n  }\n  \n  col += hsv2rgb(vec3(h, 0.5, l));\n  \n  col = mix(col, vec3(0.), smoothstep(aa, -aa, d2.x));\n  col *= mix(0.75, 1.0, smoothstep(0.01, 0.2, d2.y));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME-0.5*length(p));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Compressing images with noise.\n//\n// I was thinking, why not use Perlin Noise as activation function\n// for a classic multi-layer perceptron network? If ReLUs and sine\n// waves work, any non linear thing must just work. Including some\n// noise (ie, a differentiable, stochastic oscillating signal, not\n// the \"noise\" of signal processing). Unlike sin waves, the search\n// space is way larger since noise isn't periodic. Also, feel free\n// to call this NOREN (Noise Representation Network).\n//\n// This is the quick experiment referred here a year ago\n// https://twitter.com/iquilezles/status/1432429955527237632\n// which I never got the time to write about.\n//\n// I trained the network with a little C program I wrote, so I am\n// confident you can beat it by a lot with a proper ML framework.\n// \n// As said, the network is a regular multi-layer perceptron, with\n// { 2, 64, 32, 16, 8, 1 } layers and a total of 2945 parameters.\n// The activation noise function is this one I developed here:\n// https://www.shadertoy.com/view/3sd3Rs\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat fun( in float x )\n{\n    float f = floor(x);\n    float s = fract(x);\n    float a = 1.0-s;\n    float b = s;\n    float c = 1.0-abs(s-0.5)*2.0;\n    float d = 1.0-abs(s-0.25)*4.0;\n    float e = 1.0-abs(s-0.75)*4.0;\n    return a*a*(3.0-2.0*a) + b*b*(3.0-2.0*b) + c*c*(3.0-2.0*c) + d*d*(3.0-2.0*d) + e*e*(3.0-2.0*e);\n}\n\n// network\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // --- layer 0 : input ---------------\n    float v_0_0 = fragCoord.x/iResolution.x;\n    float v_0_1 = fragCoord.y/iResolution.y;\n\n    // --- layer 1 -----------------------\n    float v_1_00 = fun( 12.651764*v_0_0 +1.339055*v_0_1-23.754999);\n    float v_1_01 = fun( -0.532269*v_0_0 -8.396215*v_0_1+23.099752);\n    float v_1_02 = fun(-12.253928*v_0_0+22.502775*v_0_1-24.686695);\n    float v_1_03 = fun( 17.924093*v_0_0-18.237402*v_0_1-14.419626);\n    float v_1_04 = fun(-22.862108*v_0_0-15.147194*v_0_1-15.151608);\n    float v_1_05 = fun( -9.650509*v_0_0-14.831182*v_0_1+20.137722);\n    float v_1_06 = fun( -8.004325*v_0_0 -0.475607*v_0_1+20.921373);\n    float v_1_07 = fun(  7.464520*v_0_0 +1.960937*v_0_1+4.899765);\n    float v_1_08 = fun(-10.973597*v_0_0+18.677485*v_0_1-6.463108);\n    float v_1_09 = fun(-23.755060*v_0_0+19.067633*v_0_1-13.359839);\n    float v_1_10 = fun(  9.192753*v_0_0+20.252661*v_0_1+16.834564);\n    float v_1_11 = fun(  7.906412*v_0_0+14.221536*v_0_1+7.045158);\n    float v_1_12 = fun(-10.764951*v_0_0 +1.050687*v_0_1-12.406633);\n    float v_1_13 = fun( 14.603448*v_0_0+24.272823*v_0_1+4.524347);\n    float v_1_14 = fun(  5.894300*v_0_0 -2.107377*v_0_1-1.927901);\n    float v_1_15 = fun(  3.901146*v_0_0 +1.269753*v_0_1+23.912832);\n    float v_1_16 = fun( -7.028045*v_0_0+19.630928*v_0_1+5.540376);\n    float v_1_17 = fun( -0.534545*v_0_0+14.446243*v_0_1-17.512001);\n    float v_1_18 = fun( -2.202332*v_0_0+10.817842*v_0_1-19.685925);\n    float v_1_19 = fun( -5.548895*v_0_0 -0.556134*v_0_1+12.383915);\n    float v_1_20 = fun(  4.818054*v_0_0 +3.885520*v_0_1-18.928185);\n    float v_1_21 = fun(-19.688728*v_0_0 -6.919561*v_0_1+19.978441);\n    float v_1_22 = fun( -9.321958*v_0_0-20.376427*v_0_1+8.881976);\n    float v_1_23 = fun(-20.164150*v_0_0-13.801070*v_0_1+1.050954);\n    float v_1_24 = fun(-11.437829*v_0_0 +6.469597*v_0_1+13.477356);\n    float v_1_25 = fun( 11.655347*v_0_0 +8.145976*v_0_1+8.415142);\n    float v_1_26 = fun(-10.880453*v_0_0 +0.682798*v_0_1+17.531200);\n    float v_1_27 = fun(-13.601298*v_0_0-21.871817*v_0_1-0.502928);\n    float v_1_28 = fun(-14.981379*v_0_0+21.467344*v_0_1-3.321391);\n    float v_1_29 = fun(-20.798067*v_0_0+17.810989*v_0_1-6.143041);\n    float v_1_30 = fun( -8.127576*v_0_0-20.133320*v_0_1+3.440520);\n    float v_1_31 = fun(  0.758812*v_0_0+10.336716*v_0_1-18.378170);\n    float v_1_32 = fun( 13.717178*v_0_0 +4.189069*v_0_1-10.929428);\n    float v_1_33 = fun( 20.781424*v_0_0+13.521489*v_0_1-20.092876);\n    float v_1_34 = fun( 12.257710*v_0_0 -3.714963*v_0_1-17.730146);\n    float v_1_35 = fun(-15.930890*v_0_0-11.382194*v_0_1+18.150429);\n    float v_1_36 = fun(  7.444907*v_0_0+10.940384*v_0_1+1.030603);\n    float v_1_37 = fun( 17.040625*v_0_0+15.649309*v_0_1+5.114138);\n    float v_1_38 = fun(  9.930554*v_0_0-16.405514*v_0_1+20.695515);\n    float v_1_39 = fun(  6.665332*v_0_0+18.455132*v_0_1+12.971514);\n    float v_1_40 = fun( 23.615326*v_0_0+10.625115*v_0_1-10.179976);\n    float v_1_41 = fun(-20.110067*v_0_0 +2.001038*v_0_1+8.840239);\n    float v_1_42 = fun(-18.800917*v_0_0+23.278751*v_0_1+23.994085);\n    float v_1_43 = fun( 22.557316*v_0_0-20.167139*v_0_1-6.057110);\n    float v_1_44 = fun(-20.584620*v_0_0 -8.592924*v_0_1+9.116179);\n    float v_1_45 = fun( 23.096958*v_0_0+20.168434*v_0_1-21.596998);\n    float v_1_46 = fun( -7.976181*v_0_0+20.527336*v_0_1-18.099480);\n    float v_1_47 = fun( -5.720318*v_0_0-12.690313*v_0_1-8.031078);\n    float v_1_48 = fun( 17.160139*v_0_0 +2.665666*v_0_1-18.810461);\n    float v_1_49 = fun(-11.865465*v_0_0-16.981085*v_0_1-19.168430);\n    float v_1_50 = fun( -2.159684*v_0_0 +4.667675*v_0_1+3.735635);\n    float v_1_51 = fun( -8.529593*v_0_0 -8.495744*v_0_1+19.751242);\n    float v_1_52 = fun( 18.633884*v_0_0 +9.868877*v_0_1-1.110809);\n    float v_1_53 = fun( -7.546693*v_0_0 -0.406618*v_0_1-7.886292);\n    float v_1_54 = fun( 13.809946*v_0_0 +7.604858*v_0_1-23.396351);\n    float v_1_55 = fun(-16.146168*v_0_0 +6.536390*v_0_1-7.000743);\n    float v_1_56 = fun(-14.457527*v_0_0 -0.539393*v_0_1-3.365755);\n    float v_1_57 = fun(-19.274729*v_0_0 +2.786475*v_0_1-10.144519);\n    float v_1_58 = fun(-15.128548*v_0_0-21.821358*v_0_1+17.020514);\n    float v_1_59 = fun( 20.561825*v_0_0 -8.012662*v_0_1+3.237656);\n    float v_1_60 = fun(-22.853487*v_0_0 +0.398873*v_0_1+15.676755);\n    float v_1_61 = fun( 18.068533*v_0_0-17.750360*v_0_1-3.100729);\n    float v_1_62 = fun( 23.743105*v_0_0 -7.714730*v_0_1-15.557582);\n    float v_1_63 = fun(  6.675613*v_0_0+11.700735*v_0_1-2.029474);\n\n    // --- layer 2 -----------------------\n    float v_2_00 = fun(-0.044525*v_1_00+0.115868*v_1_01-0.035576*v_1_02+0.027339*v_1_03+0.015867*v_1_04+0.022896*v_1_05+0.039554*v_1_06-0.169480*v_1_07+0.031006*v_1_08+0.044222*v_1_09-0.004297*v_1_10+0.025188*v_1_11-0.437089*v_1_12-0.038434*v_1_13-0.082501*v_1_14-0.169753*v_1_15+0.020257*v_1_16+0.111858*v_1_17-0.051250*v_1_18+0.119436*v_1_19+0.203302*v_1_20+0.170197*v_1_21+0.068203*v_1_22-0.015849*v_1_23-0.195028*v_1_24+0.038735*v_1_25-0.087068*v_1_26+0.030674*v_1_27+0.027934*v_1_28+0.036769*v_1_29-0.029686*v_1_30-0.099598*v_1_31+0.185609*v_1_32+0.077544*v_1_33-0.001495*v_1_34-0.096777*v_1_35-0.077638*v_1_36+0.006687*v_1_37+0.025782*v_1_38+0.045049*v_1_39+0.011980*v_1_40-0.067470*v_1_41+0.005923*v_1_42-0.031544*v_1_43+0.002367*v_1_44-0.017811*v_1_45-0.044148*v_1_46-0.001016*v_1_47+0.333579*v_1_48+0.035056*v_1_49-0.033190*v_1_50-0.078993*v_1_51+0.069724*v_1_52+0.014914*v_1_53+0.067980*v_1_54+0.003039*v_1_55-0.208939*v_1_56+0.097293*v_1_57-0.000224*v_1_58+0.144430*v_1_59+0.032889*v_1_60-0.085943*v_1_61+0.029325*v_1_62-0.019159*v_1_63+0.064850);\n    float v_2_01 = fun( 0.085992*v_1_00+0.205653*v_1_01-0.053559*v_1_02-0.075332*v_1_03+0.037484*v_1_04-0.082075*v_1_05-0.000862*v_1_06+0.081010*v_1_07-0.015090*v_1_08+0.010667*v_1_09-0.025403*v_1_10-0.133320*v_1_11-0.053244*v_1_12+0.041927*v_1_13+0.498567*v_1_14+0.243247*v_1_15+0.020366*v_1_16+0.035310*v_1_17+0.003063*v_1_18-0.169640*v_1_19+0.108635*v_1_20+0.021393*v_1_21+0.104203*v_1_22+0.016613*v_1_23-0.106106*v_1_24+0.076009*v_1_25+0.084641*v_1_26-0.092887*v_1_27-0.032172*v_1_28+0.001252*v_1_29+0.004446*v_1_30+0.041510*v_1_31-0.068689*v_1_32-0.075427*v_1_33-0.053876*v_1_34-0.117501*v_1_35+0.034715*v_1_36+0.038847*v_1_37-0.086056*v_1_38-0.075281*v_1_39-0.004249*v_1_40-0.096576*v_1_41-0.023905*v_1_42+0.079087*v_1_43+0.034240*v_1_44+0.034465*v_1_45-0.031142*v_1_46+0.044658*v_1_47-0.147024*v_1_48-0.053687*v_1_49-0.135732*v_1_50-0.049481*v_1_51-0.034369*v_1_52-0.027767*v_1_53+0.066915*v_1_54-0.193987*v_1_55+0.022023*v_1_56+0.100757*v_1_57+0.022187*v_1_58-0.139774*v_1_59+0.058295*v_1_60+0.036765*v_1_61-0.082648*v_1_62-0.136839*v_1_63+0.092278);\n    float v_2_02 = fun(-0.127209*v_1_00+0.065225*v_1_01-0.056975*v_1_02+0.052557*v_1_03-0.074556*v_1_04-0.052306*v_1_05-0.324635*v_1_06-0.090682*v_1_07-0.103687*v_1_08-0.022151*v_1_09-0.041096*v_1_10-0.075392*v_1_11-0.270524*v_1_12+0.014113*v_1_13-0.070891*v_1_14-0.172151*v_1_15+0.025130*v_1_16-0.049420*v_1_17+0.053585*v_1_18-0.202775*v_1_19-0.056114*v_1_20-0.238883*v_1_21+0.129495*v_1_22+0.001273*v_1_23-0.126285*v_1_24-0.012618*v_1_25+0.173209*v_1_26-0.011349*v_1_27+0.050094*v_1_28-0.011544*v_1_29+0.083887*v_1_30+0.017274*v_1_31-0.113601*v_1_32-0.040849*v_1_33+0.097738*v_1_34-0.148567*v_1_35+0.098479*v_1_36-0.068012*v_1_37-0.026094*v_1_38-0.040769*v_1_39-0.037829*v_1_40-0.193376*v_1_41+0.044405*v_1_42-0.068566*v_1_43+0.029461*v_1_44-0.001436*v_1_45+0.000594*v_1_46+0.141620*v_1_47-0.087259*v_1_48-0.028868*v_1_49-0.016243*v_1_50+0.457991*v_1_51+0.150156*v_1_52-0.194628*v_1_53-0.022515*v_1_54+0.029254*v_1_55-0.059812*v_1_56-0.101218*v_1_57-0.030081*v_1_58-0.082407*v_1_59+0.003820*v_1_60+0.024786*v_1_61+0.075422*v_1_62+0.085187*v_1_63-0.007961);\n    float v_2_03 = fun( 0.043561*v_1_00+0.103728*v_1_01-0.014765*v_1_02-0.007922*v_1_03-0.021944*v_1_04+0.004805*v_1_05+0.203720*v_1_06-0.198465*v_1_07-0.011335*v_1_08+0.024568*v_1_09+0.014230*v_1_10+0.016075*v_1_11-0.128696*v_1_12-0.044283*v_1_13-0.039055*v_1_14+0.133844*v_1_15-0.054472*v_1_16+0.104392*v_1_17-0.105933*v_1_18-0.276674*v_1_19-0.001262*v_1_20+0.012153*v_1_21-0.000153*v_1_22+0.115850*v_1_23-0.058406*v_1_24-0.009838*v_1_25-0.271043*v_1_26-0.047843*v_1_27-0.006785*v_1_28+0.020373*v_1_29-0.002165*v_1_30+0.177880*v_1_31+0.096860*v_1_32-0.030319*v_1_33-0.048030*v_1_34+0.053012*v_1_35+0.093970*v_1_36+0.006791*v_1_37-0.127931*v_1_38-0.025170*v_1_39-0.056277*v_1_40-0.090330*v_1_41-0.063819*v_1_42-0.042224*v_1_43-0.111293*v_1_44+0.002892*v_1_45-0.057016*v_1_46+0.098001*v_1_47-0.024162*v_1_48+0.028837*v_1_49+0.065524*v_1_50+0.011087*v_1_51+0.065933*v_1_52-0.024707*v_1_53-0.229571*v_1_54-0.006999*v_1_55+0.117027*v_1_56+0.024293*v_1_57-0.026667*v_1_58-0.040759*v_1_59-0.011486*v_1_60+0.009570*v_1_61-0.044660*v_1_62-0.021106*v_1_63-0.131698);\n    float v_2_04 = fun( 0.068916*v_1_00-0.056187*v_1_01-0.083925*v_1_02-0.030404*v_1_03+0.074165*v_1_04-0.013949*v_1_05-0.114450*v_1_06+0.038914*v_1_07+0.000601*v_1_08-0.028590*v_1_09-0.036830*v_1_10+0.009743*v_1_11+0.270937*v_1_12-0.016449*v_1_13-0.066408*v_1_14+0.151630*v_1_15-0.061993*v_1_16-0.033557*v_1_17-0.014451*v_1_18-0.199938*v_1_19-0.107729*v_1_20-0.168311*v_1_21-0.072904*v_1_22-0.029236*v_1_23+0.062262*v_1_24+0.018318*v_1_25-0.056614*v_1_26-0.035537*v_1_27-0.005170*v_1_28-0.024719*v_1_29-0.071641*v_1_30+0.196137*v_1_31-0.145898*v_1_32+0.024779*v_1_33+0.181902*v_1_34+0.029270*v_1_35-0.048335*v_1_36-0.050959*v_1_37-0.007753*v_1_38-0.029827*v_1_39-0.037985*v_1_40+0.028145*v_1_41+0.066963*v_1_42+0.011681*v_1_43+0.053097*v_1_44-0.098342*v_1_45+0.081099*v_1_46-0.099549*v_1_47+0.152579*v_1_48-0.106578*v_1_49+0.011003*v_1_50+0.113793*v_1_51-0.122793*v_1_52+0.085224*v_1_53-0.079507*v_1_54-0.054002*v_1_55+0.149172*v_1_56-0.012336*v_1_57+0.012771*v_1_58-0.117302*v_1_59+0.095892*v_1_60-0.038606*v_1_61-0.021617*v_1_62+0.076835*v_1_63-0.040366);\n    float v_2_05 = fun( 0.116964*v_1_00-0.041162*v_1_01+0.014651*v_1_02-0.056107*v_1_03-0.059145*v_1_04-0.077622*v_1_05-0.268724*v_1_06-0.134324*v_1_07-0.055725*v_1_08-0.025782*v_1_09-0.010396*v_1_10-0.049224*v_1_11-0.217466*v_1_12+0.008592*v_1_13-0.058990*v_1_14+0.029188*v_1_15+0.072704*v_1_16-0.037670*v_1_17+0.005817*v_1_18+0.109588*v_1_19-0.115937*v_1_20+0.149483*v_1_21+0.048569*v_1_22-0.038552*v_1_23+0.073754*v_1_24-0.050677*v_1_25+0.035677*v_1_26-0.011170*v_1_27+0.033516*v_1_28-0.014033*v_1_29-0.000624*v_1_30-0.090845*v_1_31+0.020498*v_1_32+0.000211*v_1_33+0.070077*v_1_34-0.025147*v_1_35-0.186809*v_1_36+0.067344*v_1_37-0.035309*v_1_38-0.022144*v_1_39-0.019433*v_1_40+0.003882*v_1_41-0.029886*v_1_42-0.008913*v_1_43-0.016018*v_1_44+0.007118*v_1_45+0.026850*v_1_46-0.015412*v_1_47-0.145883*v_1_48-0.008495*v_1_49-0.215282*v_1_50-0.108235*v_1_51+0.039193*v_1_52-0.471203*v_1_53-0.030101*v_1_54-0.085238*v_1_55-0.114731*v_1_56-0.060247*v_1_57+0.056936*v_1_58-0.060115*v_1_59-0.128227*v_1_60+0.016342*v_1_61+0.036467*v_1_62-0.106037*v_1_63+0.279289);\n    float v_2_06 = fun( 0.109230*v_1_00+0.078372*v_1_01-0.018636*v_1_02-0.029131*v_1_03+0.027303*v_1_04-0.044817*v_1_05+0.129715*v_1_06+0.343596*v_1_07-0.007394*v_1_08+0.036945*v_1_09-0.028737*v_1_10+0.006490*v_1_11+0.160583*v_1_12-0.022513*v_1_13-0.220929*v_1_14+0.129579*v_1_15+0.013360*v_1_16+0.020161*v_1_17-0.058713*v_1_18-0.237086*v_1_19+0.242633*v_1_20+0.022790*v_1_21-0.057628*v_1_22-0.045872*v_1_23-0.066223*v_1_24+0.006318*v_1_25-0.147093*v_1_26-0.024223*v_1_27-0.040515*v_1_28-0.025714*v_1_29-0.011629*v_1_30+0.042925*v_1_31+0.077983*v_1_32+0.022331*v_1_33+0.103722*v_1_34-0.054089*v_1_35-0.019024*v_1_36+0.057139*v_1_37-0.111831*v_1_38+0.067253*v_1_39+0.099102*v_1_40+0.135182*v_1_41+0.010571*v_1_42-0.017970*v_1_43+0.032068*v_1_44-0.033492*v_1_45-0.028049*v_1_46-0.037449*v_1_47+0.172682*v_1_48+0.016097*v_1_49+0.049245*v_1_50-0.096760*v_1_51-0.088336*v_1_52+0.231941*v_1_53+0.066014*v_1_54-0.042505*v_1_55+0.108459*v_1_56-0.137289*v_1_57-0.020837*v_1_58+0.000274*v_1_59-0.012707*v_1_60+0.023851*v_1_61-0.001153*v_1_62-0.083715*v_1_63-0.045738);\n    float v_2_07 = fun(-0.049054*v_1_00-0.064092*v_1_01-0.009303*v_1_02+0.091048*v_1_03+0.041963*v_1_04+0.071571*v_1_05-0.116161*v_1_06-0.009199*v_1_07-0.028050*v_1_08+0.109007*v_1_09+0.035222*v_1_10+0.052942*v_1_11-0.256152*v_1_12-0.015888*v_1_13+0.032352*v_1_14+0.215416*v_1_15-0.113211*v_1_16-0.038637*v_1_17+0.160005*v_1_18+0.204943*v_1_19-0.084699*v_1_20+0.169729*v_1_21-0.070630*v_1_22-0.155203*v_1_23+0.099114*v_1_24-0.082160*v_1_25+0.348775*v_1_26+0.075367*v_1_27+0.065602*v_1_28-0.059847*v_1_29-0.070868*v_1_30+0.102799*v_1_31+0.103740*v_1_32-0.008684*v_1_33-0.038303*v_1_34+0.028744*v_1_35+0.046329*v_1_36+0.035560*v_1_37-0.026201*v_1_38-0.031817*v_1_39-0.008845*v_1_40+0.045956*v_1_41-0.004966*v_1_42-0.040434*v_1_43-0.025753*v_1_44+0.012081*v_1_45+0.141337*v_1_46+0.077079*v_1_47+0.219484*v_1_48+0.087629*v_1_49-0.016214*v_1_50+0.045452*v_1_51-0.088374*v_1_52-0.003001*v_1_53+0.021538*v_1_54+0.116217*v_1_55+0.194081*v_1_56+0.064589*v_1_57+0.008192*v_1_58+0.026659*v_1_59+0.087408*v_1_60+0.034451*v_1_61+0.088239*v_1_62+0.063672*v_1_63-0.011650);\n    float v_2_08 = fun(-0.000891*v_1_00+0.037174*v_1_01+0.035635*v_1_02+0.013455*v_1_03-0.069656*v_1_04-0.026386*v_1_05+0.154870*v_1_06-0.124133*v_1_07-0.060302*v_1_08+0.075157*v_1_09+0.064238*v_1_10+0.033930*v_1_11+0.142169*v_1_12-0.034823*v_1_13-0.141791*v_1_14+0.308062*v_1_15+0.071166*v_1_16-0.101051*v_1_17+0.148833*v_1_18-0.237508*v_1_19-0.007577*v_1_20+0.058586*v_1_21-0.008530*v_1_22+0.119090*v_1_23+0.109259*v_1_24-0.074080*v_1_25-0.173627*v_1_26-0.001551*v_1_27+0.045630*v_1_28-0.154267*v_1_29-0.071145*v_1_30+0.028686*v_1_31+0.138934*v_1_32-0.046134*v_1_33-0.205212*v_1_34-0.005224*v_1_35-0.066314*v_1_36-0.004673*v_1_37-0.046198*v_1_38+0.033970*v_1_39-0.076263*v_1_40-0.067474*v_1_41-0.053773*v_1_42-0.030688*v_1_43+0.000307*v_1_44+0.053086*v_1_45-0.038117*v_1_46+0.279037*v_1_47-0.013427*v_1_48+0.112147*v_1_49-0.138102*v_1_50+0.070978*v_1_51-0.069293*v_1_52+0.065393*v_1_53+0.126960*v_1_54+0.005318*v_1_55-0.069379*v_1_56-0.077873*v_1_57-0.064549*v_1_58-0.034743*v_1_59-0.075528*v_1_60+0.069086*v_1_61-0.125627*v_1_62+0.086342*v_1_63-0.046347);\n    float v_2_09 = fun(-0.032540*v_1_00-0.137541*v_1_01+0.101021*v_1_02+0.040863*v_1_03+0.121088*v_1_04+0.031102*v_1_05-0.040727*v_1_06+0.130902*v_1_07+0.081037*v_1_08+0.073079*v_1_09-0.065653*v_1_10-0.083753*v_1_11-0.137497*v_1_12-0.076455*v_1_13+0.177779*v_1_14-0.196471*v_1_15+0.014860*v_1_16+0.021566*v_1_17+0.151096*v_1_18-0.113111*v_1_19-0.032137*v_1_20+0.078012*v_1_21-0.091503*v_1_22-0.098476*v_1_23+0.130862*v_1_24+0.095748*v_1_25+0.018123*v_1_26+0.030106*v_1_27-0.048689*v_1_28+0.015594*v_1_29+0.072637*v_1_30-0.135748*v_1_31+0.245782*v_1_32+0.051858*v_1_33-0.113820*v_1_34+0.048778*v_1_35-0.077600*v_1_36-0.043569*v_1_37-0.009787*v_1_38-0.058587*v_1_39+0.003101*v_1_40+0.138477*v_1_41-0.030714*v_1_42+0.007233*v_1_43+0.021504*v_1_44+0.017412*v_1_45-0.043149*v_1_46+0.064261*v_1_47-0.030618*v_1_48+0.018059*v_1_49-0.092716*v_1_50-0.037081*v_1_51-0.039639*v_1_52-0.244125*v_1_53-0.137004*v_1_54-0.023565*v_1_55-0.113035*v_1_56-0.157926*v_1_57+0.042674*v_1_58-0.053496*v_1_59-0.069275*v_1_60-0.002082*v_1_61+0.141601*v_1_62+0.124829*v_1_63-0.061572);\n    float v_2_10 = fun( 0.290386*v_1_00-0.055151*v_1_01-0.012646*v_1_02-0.039341*v_1_03-0.025366*v_1_04-0.034720*v_1_05-0.057582*v_1_06-0.224825*v_1_07-0.061306*v_1_08+0.003922*v_1_09+0.033667*v_1_10-0.050187*v_1_11-0.055425*v_1_12+0.010525*v_1_13-0.107164*v_1_14+0.020638*v_1_15+0.031683*v_1_16+0.047446*v_1_17+0.103024*v_1_18-0.122056*v_1_19-0.058516*v_1_20+0.048436*v_1_21-0.000058*v_1_22+0.045718*v_1_23-0.009659*v_1_24-0.037452*v_1_25-0.117138*v_1_26-0.042320*v_1_27+0.021043*v_1_28-0.020780*v_1_29+0.010015*v_1_30-0.043874*v_1_31-0.062205*v_1_32-0.086181*v_1_33+0.120951*v_1_34-0.018674*v_1_35-0.051633*v_1_36+0.016197*v_1_37-0.064681*v_1_38-0.005301*v_1_39-0.024871*v_1_40-0.049132*v_1_41+0.020755*v_1_42-0.005837*v_1_43+0.074336*v_1_44-0.057820*v_1_45-0.060769*v_1_46+0.072127*v_1_47-0.255633*v_1_48-0.073757*v_1_49+0.159994*v_1_50+0.031299*v_1_51-0.076716*v_1_52+0.231272*v_1_53-0.039419*v_1_54+0.006703*v_1_55+0.051666*v_1_56+0.022057*v_1_57-0.074899*v_1_58-0.063821*v_1_59+0.002305*v_1_60-0.036243*v_1_61-0.016563*v_1_62+0.002557*v_1_63-0.031302);\n    float v_2_11 = fun( 0.026524*v_1_00-0.045045*v_1_01+0.002808*v_1_02-0.037124*v_1_03+0.013424*v_1_04-0.019687*v_1_05+0.103888*v_1_06-0.035798*v_1_07+0.003701*v_1_08-0.011704*v_1_09+0.004628*v_1_10-0.071057*v_1_11-0.008859*v_1_12+0.000584*v_1_13+0.190465*v_1_14+0.209680*v_1_15-0.036645*v_1_16-0.095986*v_1_17+0.071253*v_1_18+0.039880*v_1_19-0.082014*v_1_20+0.046031*v_1_21-0.017396*v_1_22-0.037866*v_1_23-0.020641*v_1_24+0.021218*v_1_25+0.121622*v_1_26+0.030982*v_1_27-0.003318*v_1_28+0.018139*v_1_29+0.053375*v_1_30+0.101832*v_1_31-0.146065*v_1_32-0.061475*v_1_33-0.038460*v_1_34+0.010538*v_1_35-0.001573*v_1_36-0.077988*v_1_37+0.151403*v_1_38+0.024668*v_1_39+0.014445*v_1_40+0.037147*v_1_41+0.048779*v_1_42+0.034143*v_1_43+0.059742*v_1_44-0.011403*v_1_45+0.084758*v_1_46+0.012009*v_1_47+0.007174*v_1_48-0.004666*v_1_49+0.059770*v_1_50+0.115192*v_1_51+0.030357*v_1_52-0.207609*v_1_53-0.027997*v_1_54+0.021363*v_1_55+0.099245*v_1_56+0.080460*v_1_57+0.065775*v_1_58+0.033129*v_1_59+0.044693*v_1_60-0.048957*v_1_61-0.077817*v_1_62+0.036288*v_1_63-0.066653);\n    float v_2_12 = fun(-0.070386*v_1_00+0.052948*v_1_01-0.042500*v_1_02+0.047282*v_1_03+0.025260*v_1_04+0.131321*v_1_05-0.257915*v_1_06+0.099309*v_1_07-0.089104*v_1_08-0.028367*v_1_09+0.079093*v_1_10-0.078358*v_1_11-0.036319*v_1_12+0.130834*v_1_13-0.359926*v_1_14+0.039374*v_1_15-0.004614*v_1_16+0.082259*v_1_17-0.123608*v_1_18-0.110275*v_1_19+0.001329*v_1_20+0.002514*v_1_21+0.023275*v_1_22+0.073062*v_1_23-0.213277*v_1_24+0.014087*v_1_25-0.067947*v_1_26+0.031123*v_1_27-0.008709*v_1_28-0.101559*v_1_29+0.054124*v_1_30-0.024036*v_1_31+0.005426*v_1_32-0.176637*v_1_33-0.239188*v_1_34-0.027527*v_1_35+0.106400*v_1_36+0.205420*v_1_37-0.013339*v_1_38+0.043838*v_1_39-0.055377*v_1_40+0.113929*v_1_41+0.052142*v_1_42-0.032742*v_1_43+0.096733*v_1_44-0.067038*v_1_45+0.024640*v_1_46+0.029677*v_1_47-0.057010*v_1_48-0.077632*v_1_49+0.255702*v_1_50-0.213174*v_1_51-0.141738*v_1_52-0.031315*v_1_53+0.150495*v_1_54+0.122954*v_1_55-0.062877*v_1_56-0.202118*v_1_57-0.026556*v_1_58+0.135034*v_1_59-0.154258*v_1_60+0.004900*v_1_61-0.093458*v_1_62+0.145635*v_1_63+0.188409);\n    float v_2_13 = fun( 0.102896*v_1_00+0.132588*v_1_01-0.026726*v_1_02+0.026576*v_1_03+0.008145*v_1_04+0.092777*v_1_05+0.001342*v_1_06-0.227200*v_1_07-0.006547*v_1_08+0.028998*v_1_09-0.009280*v_1_10-0.027162*v_1_11-0.105840*v_1_12-0.014192*v_1_13+0.097730*v_1_14-0.265727*v_1_15-0.046303*v_1_16-0.083002*v_1_17+0.094294*v_1_18+0.172596*v_1_19+0.036173*v_1_20+0.058732*v_1_21-0.035230*v_1_22-0.021967*v_1_23-0.046883*v_1_24-0.079157*v_1_25-0.070754*v_1_26-0.013511*v_1_27+0.005162*v_1_28+0.003202*v_1_29-0.054908*v_1_30-0.048946*v_1_31-0.080689*v_1_32-0.002217*v_1_33-0.053794*v_1_34-0.057295*v_1_35+0.043063*v_1_36-0.015499*v_1_37+0.041203*v_1_38-0.024652*v_1_39+0.015546*v_1_40+0.068395*v_1_41-0.072654*v_1_42-0.015718*v_1_43+0.099289*v_1_44-0.030368*v_1_45-0.017012*v_1_46-0.068940*v_1_47+0.103993*v_1_48+0.033860*v_1_49+0.018307*v_1_50-0.067980*v_1_51-0.038447*v_1_52+0.007678*v_1_53-0.049110*v_1_54+0.075390*v_1_55-0.128384*v_1_56-0.031055*v_1_57+0.093045*v_1_58+0.039915*v_1_59+0.010956*v_1_60-0.047911*v_1_61-0.071262*v_1_62-0.054446*v_1_63-0.194175);\n    float v_2_14 = fun( 0.097249*v_1_00-0.107658*v_1_01+0.047073*v_1_02-0.028581*v_1_03-0.036623*v_1_04-0.129108*v_1_05-0.070894*v_1_06-0.123021*v_1_07-0.037279*v_1_08-0.012234*v_1_09-0.078434*v_1_10-0.007059*v_1_11-0.257766*v_1_12-0.014171*v_1_13-0.133103*v_1_14-0.208169*v_1_15+0.048927*v_1_16-0.087562*v_1_17-0.089354*v_1_18-0.050608*v_1_19+0.112024*v_1_20+0.001560*v_1_21+0.019680*v_1_22-0.200185*v_1_23+0.000350*v_1_24+0.130224*v_1_25-0.044145*v_1_26+0.030221*v_1_27+0.079815*v_1_28+0.022414*v_1_29+0.062566*v_1_30-0.071945*v_1_31-0.051269*v_1_32+0.102051*v_1_33+0.024576*v_1_34-0.015681*v_1_35-0.023085*v_1_36-0.055362*v_1_37-0.056835*v_1_38+0.054811*v_1_39-0.033753*v_1_40-0.040839*v_1_41+0.061439*v_1_42+0.009153*v_1_43-0.114843*v_1_44+0.072661*v_1_45+0.009317*v_1_46+0.040278*v_1_47+0.068560*v_1_48-0.101806*v_1_49+0.003109*v_1_50-0.034983*v_1_51-0.028217*v_1_52-0.074423*v_1_53-0.147630*v_1_54-0.107716*v_1_55+0.164659*v_1_56+0.035496*v_1_57-0.003968*v_1_58+0.068453*v_1_59+0.019834*v_1_60-0.028257*v_1_61+0.030428*v_1_62+0.021704*v_1_63-0.153423);\n    float v_2_15 = fun( 0.318060*v_1_00-0.097002*v_1_01-0.017498*v_1_02-0.016142*v_1_03+0.018641*v_1_04-0.007036*v_1_05-0.134782*v_1_06+0.035184*v_1_07-0.063777*v_1_08-0.119002*v_1_09+0.143757*v_1_10-0.020829*v_1_11-0.070806*v_1_12+0.021214*v_1_13+0.067304*v_1_14-0.136263*v_1_15+0.048198*v_1_16+0.130174*v_1_17-0.162235*v_1_18-0.310550*v_1_19+0.047101*v_1_20+0.000390*v_1_21+0.036958*v_1_22+0.044357*v_1_23+0.150679*v_1_24-0.086537*v_1_25+0.061050*v_1_26+0.026752*v_1_27+0.033871*v_1_28+0.096044*v_1_29-0.062106*v_1_30-0.001273*v_1_31+0.141453*v_1_32-0.174016*v_1_33+0.089377*v_1_34+0.116798*v_1_35-0.089918*v_1_36+0.123172*v_1_37+0.128447*v_1_38-0.007015*v_1_39+0.018107*v_1_40+0.180308*v_1_41-0.085415*v_1_42-0.030752*v_1_43-0.131683*v_1_44-0.003770*v_1_45+0.015266*v_1_46+0.056423*v_1_47+0.029254*v_1_48+0.041463*v_1_49+0.106484*v_1_50+0.244691*v_1_51+0.097298*v_1_52-0.061043*v_1_53+0.070898*v_1_54-0.079493*v_1_55+0.202869*v_1_56+0.073435*v_1_57+0.037280*v_1_58-0.094291*v_1_59+0.049520*v_1_60-0.048514*v_1_61-0.161530*v_1_62+0.159415*v_1_63+0.024619);\n    float v_2_16 = fun( 0.147201*v_1_00+0.034769*v_1_01-0.031108*v_1_02-0.030289*v_1_03+0.032987*v_1_04+0.035047*v_1_05+0.156383*v_1_06+0.053084*v_1_07-0.007473*v_1_08-0.004496*v_1_09+0.123424*v_1_10-0.005311*v_1_11+0.075165*v_1_12-0.025234*v_1_13+0.048587*v_1_14-0.070836*v_1_15-0.053717*v_1_16-0.060380*v_1_17-0.077900*v_1_18+0.533767*v_1_19-0.009047*v_1_20-0.021228*v_1_21-0.032255*v_1_22-0.016347*v_1_23-0.097184*v_1_24+0.016580*v_1_25-0.030301*v_1_26-0.009585*v_1_27-0.011768*v_1_28-0.043063*v_1_29-0.058895*v_1_30-0.001107*v_1_31-0.058639*v_1_32-0.031642*v_1_33+0.264479*v_1_34+0.113643*v_1_35-0.037472*v_1_36+0.006160*v_1_37+0.027431*v_1_38+0.044727*v_1_39-0.042013*v_1_40-0.086714*v_1_41+0.011766*v_1_42-0.011616*v_1_43+0.064697*v_1_44+0.031223*v_1_45-0.003964*v_1_46+0.020819*v_1_47+0.001451*v_1_48-0.059511*v_1_49-0.064650*v_1_50-0.141412*v_1_51-0.077150*v_1_52-0.135488*v_1_53+0.054462*v_1_54-0.037431*v_1_55-0.010287*v_1_56+0.026739*v_1_57+0.019533*v_1_58-0.115860*v_1_59+0.001498*v_1_60+0.019573*v_1_61-0.128926*v_1_62-0.021824*v_1_63-0.118782);\n    float v_2_17 = fun( 0.095144*v_1_00-0.034258*v_1_01+0.015414*v_1_02+0.093834*v_1_03+0.009984*v_1_04-0.196997*v_1_05+0.078619*v_1_06-0.057782*v_1_07-0.076626*v_1_08-0.029486*v_1_09-0.055051*v_1_10-0.056482*v_1_11-0.116257*v_1_12-0.042562*v_1_13+0.095955*v_1_14+0.254019*v_1_15+0.125456*v_1_16+0.024856*v_1_17+0.072307*v_1_18+0.434768*v_1_19+0.286832*v_1_20+0.119274*v_1_21-0.059628*v_1_22-0.115188*v_1_23-0.102288*v_1_24-0.115091*v_1_25-0.024814*v_1_26-0.002879*v_1_27-0.108488*v_1_28+0.072857*v_1_29+0.023908*v_1_30-0.014248*v_1_31-0.095894*v_1_32-0.032524*v_1_33-0.130427*v_1_34+0.043149*v_1_35-0.038313*v_1_36-0.076181*v_1_37+0.150665*v_1_38+0.096981*v_1_39-0.091956*v_1_40+0.012699*v_1_41+0.046980*v_1_42+0.073128*v_1_43+0.084351*v_1_44-0.024285*v_1_45+0.057245*v_1_46+0.077333*v_1_47+0.050003*v_1_48-0.026704*v_1_49-0.053772*v_1_50+0.231248*v_1_51-0.046740*v_1_52-0.195443*v_1_53-0.178476*v_1_54-0.096862*v_1_55-0.084065*v_1_56-0.026103*v_1_57+0.131859*v_1_58-0.043820*v_1_59+0.059325*v_1_60-0.135251*v_1_61+0.075508*v_1_62+0.213230*v_1_63+0.112285);\n    float v_2_18 = fun(-0.074823*v_1_00-0.008639*v_1_01-0.037473*v_1_02+0.020968*v_1_03+0.016166*v_1_04+0.051208*v_1_05+0.030274*v_1_06+0.151686*v_1_07+0.006597*v_1_08+0.040258*v_1_09+0.039151*v_1_10+0.089726*v_1_11+0.043513*v_1_12-0.000917*v_1_13-0.247656*v_1_14+0.659646*v_1_15-0.005295*v_1_16+0.072994*v_1_17-0.044763*v_1_18+0.062800*v_1_19-0.178046*v_1_20+0.095272*v_1_21+0.044849*v_1_22+0.020821*v_1_23-0.024507*v_1_24+0.115631*v_1_25-0.040357*v_1_26+0.030084*v_1_27-0.000434*v_1_28-0.000875*v_1_29+0.041111*v_1_30+0.004606*v_1_31-0.034878*v_1_32-0.016758*v_1_33+0.043220*v_1_34-0.072036*v_1_35+0.031581*v_1_36-0.029288*v_1_37-0.023722*v_1_38+0.080657*v_1_39-0.046068*v_1_40-0.005445*v_1_41+0.032326*v_1_42-0.037803*v_1_43+0.014747*v_1_44+0.017115*v_1_45-0.014810*v_1_46-0.023985*v_1_47-0.021938*v_1_48+0.007481*v_1_49+0.020594*v_1_50+0.142448*v_1_51+0.037638*v_1_52-0.048612*v_1_53-0.057975*v_1_54+0.053047*v_1_55+0.065897*v_1_56+0.036405*v_1_57-0.065867*v_1_58+0.027132*v_1_59-0.004833*v_1_60+0.047071*v_1_61-0.031596*v_1_62+0.076818*v_1_63-0.022958);\n    float v_2_19 = fun( 0.095679*v_1_00-0.036472*v_1_01+0.052574*v_1_02+0.028556*v_1_03+0.026815*v_1_04-0.127829*v_1_05+0.060295*v_1_06+0.106021*v_1_07+0.048702*v_1_08-0.003575*v_1_09-0.029194*v_1_10+0.038937*v_1_11-0.053299*v_1_12-0.007953*v_1_13+0.170006*v_1_14+0.049977*v_1_15+0.012446*v_1_16+0.064353*v_1_17+0.131522*v_1_18-0.053832*v_1_19-0.145525*v_1_20-0.067829*v_1_21-0.078829*v_1_22+0.044281*v_1_23-0.016499*v_1_24+0.017302*v_1_25+0.125538*v_1_26+0.093448*v_1_27+0.024834*v_1_28+0.040568*v_1_29+0.153339*v_1_30+0.027570*v_1_31+0.120489*v_1_32-0.003057*v_1_33+0.020171*v_1_34-0.032555*v_1_35+0.039928*v_1_36+0.050188*v_1_37-0.114904*v_1_38+0.011750*v_1_39+0.036389*v_1_40+0.184682*v_1_41+0.022356*v_1_42+0.022414*v_1_43-0.087043*v_1_44-0.043563*v_1_45+0.039863*v_1_46-0.171541*v_1_47+0.082198*v_1_48+0.044386*v_1_49+0.113120*v_1_50+0.069231*v_1_51+0.090735*v_1_52+0.093352*v_1_53-0.083231*v_1_54-0.162849*v_1_55+0.092392*v_1_56-0.109702*v_1_57-0.013519*v_1_58+0.169150*v_1_59+0.035072*v_1_60+0.032225*v_1_61+0.013814*v_1_62-0.090252*v_1_63-0.129754);\n    float v_2_20 = fun( 0.035495*v_1_00-0.034746*v_1_01-0.057071*v_1_02+0.077991*v_1_03+0.013007*v_1_04-0.130168*v_1_05+0.199667*v_1_06-0.048282*v_1_07-0.069962*v_1_08+0.004368*v_1_09+0.005981*v_1_10+0.077606*v_1_11+0.056434*v_1_12+0.027429*v_1_13-0.280157*v_1_14-0.200260*v_1_15-0.007444*v_1_16-0.168778*v_1_17-0.161652*v_1_18-0.172109*v_1_19+0.118138*v_1_20+0.080745*v_1_21+0.125826*v_1_22+0.056150*v_1_23-0.260738*v_1_24-0.083704*v_1_25+0.077948*v_1_26-0.029848*v_1_27-0.012768*v_1_28+0.093701*v_1_29+0.019933*v_1_30+0.066294*v_1_31+0.125842*v_1_32-0.079273*v_1_33+0.283108*v_1_34+0.033387*v_1_35+0.071962*v_1_36+0.006211*v_1_37-0.005184*v_1_38-0.139697*v_1_39-0.115251*v_1_40-0.084687*v_1_41-0.003867*v_1_42-0.024396*v_1_43-0.109638*v_1_44+0.131472*v_1_45-0.040307*v_1_46-0.049689*v_1_47-0.047194*v_1_48-0.037479*v_1_49+0.018213*v_1_50+0.127044*v_1_51-0.035110*v_1_52+0.046599*v_1_53+0.099048*v_1_54+0.036148*v_1_55-0.333003*v_1_56+0.115531*v_1_57-0.027569*v_1_58-0.141175*v_1_59-0.107419*v_1_60-0.046728*v_1_61-0.084667*v_1_62-0.039256*v_1_63-0.077893);\n    float v_2_21 = fun(-0.145870*v_1_00-0.179397*v_1_01-0.001598*v_1_02+0.078662*v_1_03-0.017292*v_1_04-0.106816*v_1_05-0.082902*v_1_06+0.026821*v_1_07+0.109633*v_1_08+0.051771*v_1_09-0.066174*v_1_10-0.042033*v_1_11+0.017372*v_1_12-0.057279*v_1_13-0.487842*v_1_14+0.215429*v_1_15+0.046850*v_1_16+0.132580*v_1_17-0.032096*v_1_18+0.067209*v_1_19+0.051961*v_1_20-0.232110*v_1_21-0.026262*v_1_22-0.033424*v_1_23+0.086529*v_1_24+0.001596*v_1_25-0.041739*v_1_26+0.032346*v_1_27+0.010403*v_1_28+0.124268*v_1_29+0.038135*v_1_30-0.095907*v_1_31+0.077675*v_1_32+0.053996*v_1_33+0.106597*v_1_34+0.048009*v_1_35-0.003231*v_1_36+0.079841*v_1_37+0.020884*v_1_38+0.052181*v_1_39+0.033267*v_1_40+0.107384*v_1_41-0.064603*v_1_42+0.013943*v_1_43+0.012131*v_1_44-0.016179*v_1_45-0.070350*v_1_46-0.032281*v_1_47-0.166642*v_1_48+0.008364*v_1_49+0.177071*v_1_50-0.158398*v_1_51+0.173566*v_1_52-0.038086*v_1_53+0.028295*v_1_54-0.106559*v_1_55+0.131552*v_1_56-0.167748*v_1_57-0.044889*v_1_58+0.089807*v_1_59+0.013079*v_1_60-0.033965*v_1_61+0.058036*v_1_62+0.024121*v_1_63-0.129454);\n    float v_2_22 = fun( 0.163506*v_1_00+0.116730*v_1_01+0.017614*v_1_02+0.079399*v_1_03-0.036294*v_1_04-0.017938*v_1_05+0.055932*v_1_06+0.219972*v_1_07+0.005499*v_1_08+0.034809*v_1_09+0.021454*v_1_10-0.007493*v_1_11-0.181407*v_1_12-0.044627*v_1_13+0.174083*v_1_14+0.105369*v_1_15-0.037037*v_1_16+0.058805*v_1_17+0.131395*v_1_18+0.000066*v_1_19-0.258702*v_1_20-0.052686*v_1_21-0.002926*v_1_22-0.000698*v_1_23+0.063669*v_1_24-0.041365*v_1_25+0.031462*v_1_26+0.003424*v_1_27+0.024556*v_1_28-0.005972*v_1_29+0.058226*v_1_30-0.008921*v_1_31-0.051907*v_1_32-0.011668*v_1_33-0.048709*v_1_34-0.012438*v_1_35-0.157490*v_1_36+0.065145*v_1_37+0.024894*v_1_38+0.074607*v_1_39+0.030731*v_1_40+0.056638*v_1_41-0.024184*v_1_42-0.045461*v_1_43+0.024914*v_1_44-0.096972*v_1_45+0.013692*v_1_46+0.053290*v_1_47-0.168386*v_1_48-0.004690*v_1_49-0.117601*v_1_50-0.067415*v_1_51+0.043451*v_1_52+0.183752*v_1_53-0.118766*v_1_54+0.024181*v_1_55+0.221312*v_1_56-0.031017*v_1_57+0.031752*v_1_58+0.012803*v_1_59+0.018574*v_1_60-0.107304*v_1_61-0.036710*v_1_62-0.076097*v_1_63+0.017912);\n    float v_2_23 = fun( 0.021726*v_1_00+0.024698*v_1_01+0.051796*v_1_02-0.045750*v_1_03-0.039828*v_1_04+0.069389*v_1_05+0.038318*v_1_06-0.086662*v_1_07+0.053999*v_1_08+0.050428*v_1_09+0.016212*v_1_10+0.017871*v_1_11+0.060622*v_1_12-0.103163*v_1_13+0.156376*v_1_14-0.382265*v_1_15-0.064779*v_1_16-0.129881*v_1_17+0.179816*v_1_18-0.054466*v_1_19+0.167942*v_1_20+0.036257*v_1_21-0.052102*v_1_22+0.160203*v_1_23-0.030206*v_1_24+0.037662*v_1_25-0.227760*v_1_26+0.046208*v_1_27-0.013000*v_1_28-0.027015*v_1_29+0.021135*v_1_30+0.088139*v_1_31+0.057885*v_1_32-0.023003*v_1_33+0.063294*v_1_34-0.014417*v_1_35+0.033509*v_1_36-0.124639*v_1_37+0.030170*v_1_38-0.014527*v_1_39-0.087254*v_1_40-0.093705*v_1_41-0.059968*v_1_42-0.072205*v_1_43-0.226725*v_1_44+0.011781*v_1_45+0.033925*v_1_46+0.205980*v_1_47+0.074133*v_1_48-0.046433*v_1_49-0.147946*v_1_50+0.213612*v_1_51-0.012681*v_1_52-0.059909*v_1_53-0.091516*v_1_54+0.063973*v_1_55+0.243457*v_1_56+0.121418*v_1_57+0.050073*v_1_58+0.050494*v_1_59+0.068534*v_1_60-0.059785*v_1_61+0.033478*v_1_62-0.112038*v_1_63-0.128393);\n    float v_2_24 = fun(-0.050544*v_1_00-0.180363*v_1_01+0.061462*v_1_02-0.071600*v_1_03+0.006621*v_1_04+0.179442*v_1_05+0.021326*v_1_06+0.050782*v_1_07-0.012582*v_1_08+0.042399*v_1_09+0.030369*v_1_10-0.043486*v_1_11-0.044804*v_1_12-0.071367*v_1_13-0.045773*v_1_14-0.001165*v_1_15-0.120713*v_1_16-0.024949*v_1_17+0.195363*v_1_18-0.193877*v_1_19+0.121901*v_1_20-0.147307*v_1_21+0.146943*v_1_22-0.128370*v_1_23+0.124716*v_1_24+0.176166*v_1_25+0.193454*v_1_26-0.057714*v_1_27-0.053509*v_1_28+0.022527*v_1_29+0.064206*v_1_30-0.131882*v_1_31-0.155334*v_1_32-0.097740*v_1_33+0.007541*v_1_34+0.033374*v_1_35-0.140058*v_1_36-0.065524*v_1_37+0.060766*v_1_38+0.018226*v_1_39-0.071659*v_1_40+0.006323*v_1_41+0.058930*v_1_42-0.083008*v_1_43+0.035524*v_1_44+0.036348*v_1_45-0.005736*v_1_46+0.058605*v_1_47-0.152259*v_1_48-0.096653*v_1_49-0.070626*v_1_50-0.018521*v_1_51-0.024582*v_1_52+0.027870*v_1_53+0.105787*v_1_54-0.052791*v_1_55-0.155543*v_1_56+0.042659*v_1_57-0.056554*v_1_58+0.103733*v_1_59-0.104800*v_1_60+0.065039*v_1_61+0.096187*v_1_62+0.044322*v_1_63+0.043559);\n    float v_2_25 = fun(-0.143788*v_1_00-0.124667*v_1_01-0.126120*v_1_02+0.056341*v_1_03+0.071410*v_1_04-0.093629*v_1_05+0.162966*v_1_06-0.172463*v_1_07+0.100926*v_1_08+0.020944*v_1_09-0.004375*v_1_10+0.085489*v_1_11+0.202547*v_1_12+0.038963*v_1_13-0.014876*v_1_14+0.243997*v_1_15+0.012334*v_1_16-0.032969*v_1_17+0.031341*v_1_18+0.160123*v_1_19+0.122372*v_1_20-0.142253*v_1_21+0.044832*v_1_22-0.116035*v_1_23+0.001555*v_1_24+0.051855*v_1_25-0.068999*v_1_26-0.044933*v_1_27+0.029653*v_1_28+0.002120*v_1_29-0.003572*v_1_30-0.029879*v_1_31+0.180541*v_1_32-0.114006*v_1_33+0.064833*v_1_34-0.007295*v_1_35+0.011442*v_1_36-0.139765*v_1_37+0.024904*v_1_38-0.088994*v_1_39+0.077624*v_1_40-0.013598*v_1_41+0.013260*v_1_42+0.025051*v_1_43-0.096173*v_1_44+0.010820*v_1_45-0.032819*v_1_46-0.109230*v_1_47-0.208038*v_1_48+0.055067*v_1_49+0.130348*v_1_50-0.062290*v_1_51+0.149416*v_1_52-0.181755*v_1_53-0.042960*v_1_54-0.109323*v_1_55+0.010075*v_1_56-0.012195*v_1_57-0.027754*v_1_58+0.022066*v_1_59-0.018877*v_1_60+0.020224*v_1_61-0.060787*v_1_62-0.084639*v_1_63+0.167064);\n    float v_2_26 = fun(-0.250008*v_1_00-0.133694*v_1_01+0.049802*v_1_02+0.020565*v_1_03-0.061965*v_1_04+0.004078*v_1_05-0.247580*v_1_06-0.172765*v_1_07+0.031031*v_1_08+0.029313*v_1_09+0.075740*v_1_10+0.015441*v_1_11+0.050413*v_1_12-0.017299*v_1_13+0.469505*v_1_14-0.488017*v_1_15-0.008758*v_1_16+0.019012*v_1_17-0.028467*v_1_18+0.002662*v_1_19+0.196276*v_1_20+0.026125*v_1_21-0.071135*v_1_22+0.103115*v_1_23-0.123745*v_1_24+0.135102*v_1_25-0.000806*v_1_26+0.021510*v_1_27+0.001487*v_1_28+0.035961*v_1_29-0.065339*v_1_30-0.029646*v_1_31+0.167113*v_1_32-0.028877*v_1_33-0.091073*v_1_34-0.039901*v_1_35-0.059825*v_1_36+0.061069*v_1_37+0.038106*v_1_38+0.103084*v_1_39+0.096507*v_1_40+0.078328*v_1_41-0.016708*v_1_42-0.007555*v_1_43-0.016339*v_1_44+0.000596*v_1_45+0.021349*v_1_46-0.101175*v_1_47-0.101273*v_1_48-0.057021*v_1_49-0.015717*v_1_50+0.199943*v_1_51-0.033852*v_1_52-0.245972*v_1_53-0.030291*v_1_54+0.190247*v_1_55+0.133671*v_1_56+0.077213*v_1_57+0.056085*v_1_58+0.064699*v_1_59-0.043193*v_1_60-0.023179*v_1_61-0.171582*v_1_62+0.043448*v_1_63-0.139438);\n    float v_2_27 = fun( 0.042914*v_1_00-0.056391*v_1_01+0.042633*v_1_02+0.058883*v_1_03+0.049711*v_1_04+0.046266*v_1_05+0.397336*v_1_06-0.056700*v_1_07-0.016119*v_1_08+0.024251*v_1_09+0.059287*v_1_10-0.025932*v_1_11+0.128445*v_1_12-0.015435*v_1_13-0.061154*v_1_14+0.446170*v_1_15-0.040126*v_1_16-0.107514*v_1_17-0.075646*v_1_18+0.216301*v_1_19+0.120494*v_1_20-0.082604*v_1_21-0.018787*v_1_22+0.005329*v_1_23+0.044530*v_1_24+0.079088*v_1_25-0.025080*v_1_26-0.065861*v_1_27-0.018091*v_1_28-0.008258*v_1_29-0.088934*v_1_30-0.065546*v_1_31+0.016943*v_1_32-0.053246*v_1_33-0.093756*v_1_34+0.088500*v_1_35+0.030016*v_1_36+0.017786*v_1_37-0.040298*v_1_38-0.123512*v_1_39+0.001288*v_1_40+0.064996*v_1_41+0.004272*v_1_42-0.036213*v_1_43-0.171982*v_1_44+0.047645*v_1_45-0.053825*v_1_46-0.060183*v_1_47+0.183344*v_1_48+0.007293*v_1_49+0.087602*v_1_50-0.043304*v_1_51+0.022211*v_1_52+0.129382*v_1_53+0.006573*v_1_54+0.119095*v_1_55-0.040031*v_1_56+0.001212*v_1_57-0.011027*v_1_58+0.031518*v_1_59-0.018907*v_1_60+0.042672*v_1_61+0.042982*v_1_62+0.047723*v_1_63+0.015713);\n    float v_2_28 = fun(-0.247434*v_1_00+0.087006*v_1_01-0.001838*v_1_02+0.103970*v_1_03+0.044078*v_1_04-0.035469*v_1_05+0.096247*v_1_06-0.221772*v_1_07+0.027120*v_1_08-0.013663*v_1_09+0.041071*v_1_10-0.096205*v_1_11+0.378040*v_1_12-0.040731*v_1_13-0.146890*v_1_14+0.057755*v_1_15+0.072481*v_1_16-0.025617*v_1_17+0.116804*v_1_18-0.012006*v_1_19+0.118558*v_1_20+0.099509*v_1_21-0.054052*v_1_22-0.029560*v_1_23+0.015257*v_1_24-0.018572*v_1_25+0.006983*v_1_26-0.023485*v_1_27-0.014802*v_1_28+0.033256*v_1_29+0.026986*v_1_30-0.046895*v_1_31+0.099273*v_1_32+0.132610*v_1_33+0.089164*v_1_34-0.012252*v_1_35-0.001675*v_1_36-0.022203*v_1_37+0.022235*v_1_38-0.090554*v_1_39-0.014280*v_1_40-0.233611*v_1_41-0.031846*v_1_42-0.034070*v_1_43-0.009919*v_1_44+0.010189*v_1_45-0.050531*v_1_46+0.049227*v_1_47-0.012636*v_1_48-0.024750*v_1_49-0.019146*v_1_50+0.097287*v_1_51+0.037336*v_1_52+0.164855*v_1_53+0.035434*v_1_54+0.145338*v_1_55-0.168737*v_1_56-0.028701*v_1_57-0.042239*v_1_58+0.038589*v_1_59+0.000372*v_1_60-0.013494*v_1_61-0.128969*v_1_62+0.048280*v_1_63-0.030141);\n    float v_2_29 = fun( 0.015752*v_1_00-0.095414*v_1_01-0.025556*v_1_02-0.046414*v_1_03-0.020304*v_1_04+0.022741*v_1_05-0.044633*v_1_06-0.072512*v_1_07-0.082407*v_1_08+0.001178*v_1_09-0.056977*v_1_10+0.128317*v_1_11-0.142663*v_1_12+0.026767*v_1_13+0.118596*v_1_14+0.047216*v_1_15-0.000868*v_1_16+0.127119*v_1_17-0.008348*v_1_18-0.079873*v_1_19-0.053913*v_1_20-0.012249*v_1_21-0.018671*v_1_22-0.093717*v_1_23+0.057636*v_1_24+0.020238*v_1_25-0.045780*v_1_26-0.020037*v_1_27+0.011733*v_1_28-0.024091*v_1_29+0.059316*v_1_30+0.025354*v_1_31+0.019169*v_1_32-0.015251*v_1_33-0.029542*v_1_34-0.017117*v_1_35+0.032121*v_1_36+0.015890*v_1_37-0.149591*v_1_38+0.029245*v_1_39+0.036584*v_1_40+0.020786*v_1_41-0.008920*v_1_42+0.034699*v_1_43-0.075346*v_1_44-0.007095*v_1_45+0.047784*v_1_46-0.001412*v_1_47-0.033727*v_1_48+0.062673*v_1_49-0.020166*v_1_50-0.063980*v_1_51-0.077553*v_1_52-0.202349*v_1_53-0.144119*v_1_54-0.041573*v_1_55+0.122908*v_1_56+0.050519*v_1_57-0.128274*v_1_58-0.029806*v_1_59+0.044142*v_1_60+0.020201*v_1_61+0.099513*v_1_62-0.054130*v_1_63+0.006593);\n    float v_2_30 = fun( 0.048807*v_1_00+0.026975*v_1_01-0.019485*v_1_02+0.004008*v_1_03+0.016719*v_1_04+0.047581*v_1_05+0.502410*v_1_06+0.160158*v_1_07+0.027909*v_1_08+0.046359*v_1_09-0.079433*v_1_10-0.053918*v_1_11-0.103968*v_1_12-0.003395*v_1_13+0.014385*v_1_14-0.173457*v_1_15-0.001820*v_1_16+0.012140*v_1_17+0.003838*v_1_18-0.226680*v_1_19+0.069451*v_1_20-0.034824*v_1_21+0.000264*v_1_22-0.086546*v_1_23-0.097731*v_1_24-0.065381*v_1_25+0.054259*v_1_26+0.025402*v_1_27-0.020453*v_1_28+0.002425*v_1_29-0.001751*v_1_30-0.092841*v_1_31+0.211274*v_1_32+0.005983*v_1_33+0.042153*v_1_34-0.097111*v_1_35+0.047695*v_1_36+0.077482*v_1_37-0.024398*v_1_38+0.054729*v_1_39-0.019457*v_1_40+0.088513*v_1_41-0.018716*v_1_42+0.055683*v_1_43+0.029142*v_1_44+0.024234*v_1_45-0.006112*v_1_46-0.028955*v_1_47+0.206247*v_1_48+0.074527*v_1_49-0.240541*v_1_50-0.090128*v_1_51-0.086299*v_1_52+0.026007*v_1_53+0.041443*v_1_54-0.044002*v_1_55+0.012283*v_1_56-0.002342*v_1_57+0.074317*v_1_58+0.014854*v_1_59-0.031060*v_1_60-0.031747*v_1_61+0.078449*v_1_62-0.009373*v_1_63-0.035445);\n    float v_2_31 = fun(-0.222115*v_1_00+0.040301*v_1_01-0.016525*v_1_02+0.046240*v_1_03+0.100368*v_1_04+0.137614*v_1_05+0.160493*v_1_06-0.150416*v_1_07+0.005644*v_1_08-0.026327*v_1_09+0.079841*v_1_10+0.125470*v_1_11-0.021651*v_1_12-0.003291*v_1_13-0.111326*v_1_14-0.016486*v_1_15+0.029922*v_1_16-0.052471*v_1_17+0.058107*v_1_18+0.060459*v_1_19+0.089466*v_1_20+0.168591*v_1_21-0.091046*v_1_22+0.048474*v_1_23-0.005327*v_1_24-0.168475*v_1_25-0.629512*v_1_26+0.012670*v_1_27-0.122494*v_1_28-0.131098*v_1_29+0.002919*v_1_30-0.073231*v_1_31-0.085928*v_1_32-0.124500*v_1_33+0.056340*v_1_34-0.068095*v_1_35+0.176562*v_1_36-0.100797*v_1_37+0.044769*v_1_38-0.001113*v_1_39-0.106552*v_1_40-0.091171*v_1_41+0.042360*v_1_42+0.004133*v_1_43+0.100468*v_1_44-0.033907*v_1_45-0.091305*v_1_46-0.014356*v_1_47-0.027684*v_1_48+0.041259*v_1_49+0.025353*v_1_50-0.070525*v_1_51+0.035754*v_1_52+0.128852*v_1_53-0.080721*v_1_54+0.013834*v_1_55-0.213721*v_1_56+0.020273*v_1_57+0.054897*v_1_58+0.019326*v_1_59+0.085586*v_1_60+0.039246*v_1_61-0.043885*v_1_62-0.065694*v_1_63+0.200177);\n\n    // --- layer 3 -----------------------\n    float v_3_00 = fun(-0.072429*v_2_00-0.052117*v_2_01-0.023910*v_2_02+0.203479*v_2_03-0.132919*v_2_04-0.349307*v_2_05+0.089661*v_2_06-0.078603*v_2_07+0.196552*v_2_08-0.067238*v_2_09+0.169480*v_2_10+0.155241*v_2_11-0.198106*v_2_12-0.085792*v_2_13-0.238174*v_2_14-0.163969*v_2_15-0.071988*v_2_16+0.027705*v_2_17-0.020056*v_2_18+0.246110*v_2_19+0.084463*v_2_20-0.094323*v_2_21-0.105242*v_2_22+0.044057*v_2_23+0.207527*v_2_24+0.282902*v_2_25+0.114393*v_2_26+0.173069*v_2_27+0.069312*v_2_28-0.001658*v_2_29+0.183876*v_2_30+0.038688*v_2_31-0.067231);\n    float v_3_01 = fun( 0.279215*v_2_00+0.280494*v_2_01+0.321873*v_2_02-0.145595*v_2_03-0.034021*v_2_04+0.195307*v_2_05-0.234471*v_2_06+0.135093*v_2_07+0.035883*v_2_08+0.081551*v_2_09-0.219987*v_2_10+0.054182*v_2_11-0.238160*v_2_12+0.011234*v_2_13-0.085822*v_2_14-0.259100*v_2_15+0.366847*v_2_16+0.132563*v_2_17-0.228914*v_2_18+0.130180*v_2_19+0.149006*v_2_20+0.023534*v_2_21-0.103975*v_2_22-0.081088*v_2_23-0.025780*v_2_24-0.200678*v_2_25+0.378662*v_2_26-0.204158*v_2_27-0.024252*v_2_28+0.413405*v_2_29-0.157246*v_2_30-0.044508*v_2_31+0.158127);\n    float v_3_02 = fun( 0.160732*v_2_00+0.256011*v_2_01-0.110751*v_2_02-0.125313*v_2_03-0.065373*v_2_04-0.110848*v_2_05-0.114430*v_2_06-0.082431*v_2_07-0.068293*v_2_08+0.050474*v_2_09-0.211380*v_2_10+0.008279*v_2_11+0.208713*v_2_12-0.032765*v_2_13+0.189141*v_2_14-0.086992*v_2_15+0.124879*v_2_16+0.033473*v_2_17-0.208384*v_2_18+0.037765*v_2_19+0.119528*v_2_20+0.101169*v_2_21+0.222705*v_2_22+0.245765*v_2_23-0.176616*v_2_24+0.017667*v_2_25+0.078378*v_2_26+0.284788*v_2_27-0.028020*v_2_28+0.033615*v_2_29+0.062638*v_2_30+0.094317*v_2_31+0.102371);\n    float v_3_03 = fun( 0.141703*v_2_00+0.018339*v_2_01-0.049143*v_2_02+0.017668*v_2_03-0.153063*v_2_04+0.058508*v_2_05+0.111957*v_2_06+0.082174*v_2_07-0.212974*v_2_08+0.009967*v_2_09+0.041689*v_2_10-0.231775*v_2_11-0.145673*v_2_12-0.269081*v_2_13-0.201231*v_2_14-0.146360*v_2_15+0.069768*v_2_16+0.174144*v_2_17+0.102493*v_2_18-0.158220*v_2_19-0.023848*v_2_20-0.044683*v_2_21+0.194084*v_2_22+0.012289*v_2_23-0.108902*v_2_24+0.157053*v_2_25-0.101255*v_2_26-0.138732*v_2_27-0.064813*v_2_28-0.168581*v_2_29-0.179403*v_2_30-0.098669*v_2_31+0.060956);\n    float v_3_04 = fun( 0.055462*v_2_00+0.012236*v_2_01+0.137857*v_2_02-0.007873*v_2_03-0.255538*v_2_04-0.004729*v_2_05-0.009306*v_2_06+0.177762*v_2_07+0.167626*v_2_08+0.179370*v_2_09+0.156887*v_2_10-0.026025*v_2_11+0.195465*v_2_12-0.169990*v_2_13-0.110219*v_2_14+0.171137*v_2_15+0.041942*v_2_16+0.056661*v_2_17-0.047715*v_2_18-0.097023*v_2_19-0.076487*v_2_20+0.102538*v_2_21+0.070541*v_2_22+0.289628*v_2_23-0.054302*v_2_24+0.262871*v_2_25-0.115504*v_2_26-0.038528*v_2_27-0.005957*v_2_28+0.024039*v_2_29+0.116935*v_2_30-0.136978*v_2_31+0.290137);\n    float v_3_05 = fun( 0.094135*v_2_00+0.151499*v_2_01+0.142469*v_2_02+0.473716*v_2_03-0.003120*v_2_04-0.096686*v_2_05-0.211224*v_2_06+0.289545*v_2_07-0.017378*v_2_08-0.219641*v_2_09-0.105904*v_2_10+0.159131*v_2_11-0.232989*v_2_12+0.093633*v_2_13+0.203833*v_2_14-0.182458*v_2_15-0.181173*v_2_16-0.151925*v_2_17-0.137024*v_2_18-0.030933*v_2_19-0.269800*v_2_20-0.005893*v_2_21+0.204376*v_2_22-0.451209*v_2_23+0.172122*v_2_24-0.080869*v_2_25+0.097873*v_2_26-0.113800*v_2_27+0.222237*v_2_28-0.011652*v_2_29-0.006933*v_2_30+0.135856*v_2_31+0.229496);\n    float v_3_06 = fun( 0.114590*v_2_00-0.050509*v_2_01-0.177848*v_2_02-0.075297*v_2_03+0.166118*v_2_04-0.151201*v_2_05+0.083566*v_2_06+0.325173*v_2_07-0.109660*v_2_08-0.026054*v_2_09+0.067388*v_2_10-0.113322*v_2_11-0.028444*v_2_12-0.227439*v_2_13+0.138387*v_2_14-0.042116*v_2_15-0.142887*v_2_16-0.253878*v_2_17-0.019159*v_2_18+0.154164*v_2_19+0.186702*v_2_20-0.031668*v_2_21+0.023003*v_2_22+0.012250*v_2_23+0.089520*v_2_24+0.060231*v_2_25+0.000937*v_2_26-0.298728*v_2_27+0.267446*v_2_28-0.292538*v_2_29+0.064285*v_2_30-0.072182*v_2_31+0.172897);\n    float v_3_07 = fun(-0.110691*v_2_00-0.261372*v_2_01+0.078001*v_2_02+0.213953*v_2_03+0.090914*v_2_04-0.291401*v_2_05+0.085209*v_2_06+0.217021*v_2_07-0.114512*v_2_08+0.133875*v_2_09+0.270512*v_2_10-0.064528*v_2_11+0.065763*v_2_12+0.108031*v_2_13+0.130548*v_2_14-0.132751*v_2_15-0.248279*v_2_16-0.075339*v_2_17+0.176982*v_2_18-0.039952*v_2_19+0.095405*v_2_20+0.213864*v_2_21+0.074618*v_2_22+0.016896*v_2_23+0.095186*v_2_24-0.004186*v_2_25+0.011728*v_2_26+0.149403*v_2_27-0.101422*v_2_28-0.006989*v_2_29+0.119510*v_2_30+0.138768*v_2_31+0.083989);\n    float v_3_08 = fun( 0.114491*v_2_00+0.168758*v_2_01+0.264733*v_2_02+0.025732*v_2_03-0.138357*v_2_04-0.636609*v_2_05-0.179637*v_2_06+0.069689*v_2_07-0.169867*v_2_08+0.055848*v_2_09-0.149956*v_2_10-0.215913*v_2_11-0.005772*v_2_12-0.077164*v_2_13+0.061990*v_2_14+0.018299*v_2_15+0.284049*v_2_16+0.163867*v_2_17-0.339084*v_2_18-0.009155*v_2_19-0.205331*v_2_20-0.233561*v_2_21-0.065324*v_2_22-0.098747*v_2_23+0.010475*v_2_24+0.031747*v_2_25+0.313526*v_2_26-0.017686*v_2_27+0.036675*v_2_28+0.168762*v_2_29-0.062879*v_2_30+0.074452*v_2_31+0.253199);\n    float v_3_09 = fun(-0.056692*v_2_00-0.238749*v_2_01+0.076381*v_2_02+0.114606*v_2_03+0.089212*v_2_04-0.080897*v_2_05+0.270516*v_2_06+0.059891*v_2_07-0.002170*v_2_08+0.231490*v_2_09-0.242035*v_2_10+0.191429*v_2_11+0.006937*v_2_12-0.056038*v_2_13-0.204798*v_2_14-0.008964*v_2_15+0.037935*v_2_16-0.290974*v_2_17-0.159624*v_2_18+0.059585*v_2_19+0.199148*v_2_20+0.186739*v_2_21-0.170407*v_2_22+0.027352*v_2_23+0.150852*v_2_24+0.148215*v_2_25+0.054201*v_2_26-0.518585*v_2_27+0.289968*v_2_28+0.037875*v_2_29-0.052819*v_2_30+0.033675*v_2_31+0.029864);\n    float v_3_10 = fun( 0.326542*v_2_00+0.040399*v_2_01+0.201698*v_2_02+0.290997*v_2_03+0.199064*v_2_04+0.006128*v_2_05-0.124135*v_2_06+0.057628*v_2_07+0.124545*v_2_08+0.109343*v_2_09+0.048072*v_2_10+0.330426*v_2_11-0.036181*v_2_12-0.260121*v_2_13+0.071318*v_2_14-0.135288*v_2_15-0.117472*v_2_16-0.148146*v_2_17-0.688773*v_2_18+0.072893*v_2_19+0.024796*v_2_20-0.076462*v_2_21+0.109759*v_2_22-0.280305*v_2_23-0.023174*v_2_24-0.242890*v_2_25+0.171241*v_2_26+0.099887*v_2_27+0.202405*v_2_28-0.218115*v_2_29+0.035058*v_2_30+0.411294*v_2_31-0.131805);\n    float v_3_11 = fun( 0.205495*v_2_00+0.131622*v_2_01-0.200618*v_2_02-0.126344*v_2_03+0.137103*v_2_04-0.203709*v_2_05-0.179754*v_2_06+0.008463*v_2_07+0.047206*v_2_08-0.174325*v_2_09-0.310894*v_2_10-0.374026*v_2_11-0.065052*v_2_12-0.041360*v_2_13-0.227356*v_2_14-0.049431*v_2_15+0.047929*v_2_16+0.244925*v_2_17+0.321526*v_2_18+0.089854*v_2_19+0.043593*v_2_20-0.040902*v_2_21+0.375603*v_2_22-0.023301*v_2_23+0.229255*v_2_24+0.077241*v_2_25-0.023149*v_2_26-0.170729*v_2_27-0.068468*v_2_28+0.249025*v_2_29-0.085374*v_2_30+0.125159*v_2_31-0.172228);\n    float v_3_12 = fun( 0.039226*v_2_00+0.034918*v_2_01-0.048377*v_2_02+0.090690*v_2_03+0.176874*v_2_04-0.118805*v_2_05-0.010681*v_2_06+0.153826*v_2_07+0.055955*v_2_08+0.009882*v_2_09-0.223976*v_2_10+0.085491*v_2_11+0.059156*v_2_12-0.046569*v_2_13-0.222009*v_2_14-0.012478*v_2_15-0.205995*v_2_16+0.202204*v_2_17+0.137789*v_2_18-0.111004*v_2_19+0.149519*v_2_20+0.034712*v_2_21+0.272577*v_2_22+0.014841*v_2_23+0.075070*v_2_24-0.403323*v_2_25+0.075140*v_2_26+0.270352*v_2_27-0.155054*v_2_28+0.096580*v_2_29+0.104740*v_2_30-0.007412*v_2_31+0.047696);\n    float v_3_13 = fun(-0.048225*v_2_00+0.058702*v_2_01-0.105006*v_2_02+0.131665*v_2_03+0.088907*v_2_04-0.147617*v_2_05+0.070276*v_2_06+0.078152*v_2_07-0.106617*v_2_08-0.140748*v_2_09-0.127722*v_2_10-0.011950*v_2_11+0.134040*v_2_12-0.071629*v_2_13-0.051022*v_2_14-0.250510*v_2_15-0.142103*v_2_16-0.135902*v_2_17-0.063278*v_2_18-0.172445*v_2_19+0.307059*v_2_20+0.034731*v_2_21-0.102078*v_2_22-0.148489*v_2_23-0.024020*v_2_24-0.366180*v_2_25+0.174037*v_2_26+0.118328*v_2_27+0.186542*v_2_28+0.103307*v_2_29+0.023335*v_2_30-0.088635*v_2_31+0.359868);\n    float v_3_14 = fun(-0.159407*v_2_00+0.048035*v_2_01-0.235352*v_2_02+0.196105*v_2_03+0.049172*v_2_04-0.048163*v_2_05-0.132879*v_2_06+0.151793*v_2_07-0.208038*v_2_08-0.155564*v_2_09+0.130196*v_2_10+0.216088*v_2_11-0.024750*v_2_12-0.364631*v_2_13-0.075135*v_2_14-0.087908*v_2_15-0.212368*v_2_16-0.005580*v_2_17+0.004953*v_2_18-0.284964*v_2_19-0.136990*v_2_20+0.082654*v_2_21+0.089684*v_2_22+0.014834*v_2_23-0.064100*v_2_24-0.106852*v_2_25-0.023190*v_2_26+0.021252*v_2_27+0.373946*v_2_28-0.054027*v_2_29+0.656903*v_2_30+0.147754*v_2_31+0.308907);\n    float v_3_15 = fun( 0.225937*v_2_00-0.224250*v_2_01-0.242018*v_2_02+0.105097*v_2_03-0.082519*v_2_04-0.138594*v_2_05-0.153288*v_2_06-0.109048*v_2_07-0.059405*v_2_08-0.047025*v_2_09+0.048504*v_2_10+0.030623*v_2_11-0.001060*v_2_12+0.071544*v_2_13-0.135603*v_2_14-0.178962*v_2_15-0.104012*v_2_16-0.041296*v_2_17+0.105765*v_2_18+0.040479*v_2_19-0.013607*v_2_20-0.092112*v_2_21-0.032040*v_2_22+0.042604*v_2_23-0.173923*v_2_24-0.014723*v_2_25-0.206968*v_2_26-0.095554*v_2_27-0.015923*v_2_28-0.145868*v_2_29-0.284663*v_2_30-0.215003*v_2_31+0.205751);\n\n    // --- layer 4 -----------------------\n    float v_4_0 = fun(-0.074770*v_3_00+0.153457*v_3_01-0.081600*v_3_02+0.806365*v_3_03+0.319611*v_3_04-0.421145*v_3_05+0.262921*v_3_06+0.414504*v_3_07+0.182466*v_3_08-0.204948*v_3_09-0.278227*v_3_10-0.267526*v_3_11-0.482732*v_3_12+0.016222*v_3_13-0.163100*v_3_14-0.230546*v_3_15+0.239487);\n    float v_4_1 = fun(-0.177743*v_3_00+0.225562*v_3_01-0.453886*v_3_02+0.049631*v_3_03-0.075604*v_3_04+0.043647*v_3_05-0.399492*v_3_06+0.247270*v_3_07+0.142535*v_3_08+0.207551*v_3_09-0.285785*v_3_10+0.103653*v_3_11+0.173852*v_3_12-0.448810*v_3_13+0.348173*v_3_14-0.034657*v_3_15+0.146180);\n    float v_4_2 = fun( 0.007303*v_3_00-0.020625*v_3_01+0.083740*v_3_02+0.352550*v_3_03+0.240649*v_3_04-0.228324*v_3_05+0.194696*v_3_06-0.296093*v_3_07-0.187802*v_3_08-0.277522*v_3_09+0.138169*v_3_10+0.089463*v_3_11-0.271476*v_3_12+0.172629*v_3_13-0.294718*v_3_14-0.250925*v_3_15+0.358876);\n    float v_4_3 = fun(-0.265278*v_3_00-0.038249*v_3_01+0.333545*v_3_02-0.297062*v_3_03-0.615192*v_3_04-0.249223*v_3_05+0.212743*v_3_06-0.604752*v_3_07-0.367048*v_3_08-0.042192*v_3_09+0.173391*v_3_10+0.114303*v_3_11+0.426310*v_3_12-0.139203*v_3_13-0.123320*v_3_14+0.058854*v_3_15+0.155411);\n    float v_4_4 = fun( 0.240330*v_3_00-0.381828*v_3_01+0.046630*v_3_02-0.166178*v_3_03-0.399996*v_3_04-0.082567*v_3_05+0.133546*v_3_06-0.302975*v_3_07+0.572987*v_3_08+0.104452*v_3_09-0.106836*v_3_10-0.224661*v_3_11+0.276150*v_3_12+0.192883*v_3_13-0.242290*v_3_14+0.385779*v_3_15+0.468982);\n    float v_4_5 = fun( 0.110387*v_3_00+0.526222*v_3_01+0.281856*v_3_02-0.270505*v_3_03-0.084157*v_3_04-0.022643*v_3_05+0.262157*v_3_06+0.263482*v_3_07+0.012487*v_3_08-0.286433*v_3_09+0.246836*v_3_10+0.379451*v_3_11-0.071842*v_3_12-0.334393*v_3_13+0.305813*v_3_14-0.101473*v_3_15-0.389199);\n    float v_4_6 = fun(-0.254180*v_3_00+0.230147*v_3_01+0.149039*v_3_02+0.492671*v_3_03+0.093311*v_3_04-0.255843*v_3_05-0.106917*v_3_06-0.123294*v_3_07+0.267801*v_3_08+0.014941*v_3_09-0.434856*v_3_10-0.066969*v_3_11-0.263687*v_3_12-0.005927*v_3_13+0.241499*v_3_14+0.033405*v_3_15+0.188735);\n    float v_4_7 = fun(-0.151883*v_3_00-0.453696*v_3_01-0.408301*v_3_02+0.007573*v_3_03-0.007660*v_3_04-0.544588*v_3_05-0.594500*v_3_06-0.579255*v_3_07-0.301253*v_3_08+0.662012*v_3_09-0.429279*v_3_10-0.396704*v_3_11-0.088744*v_3_12-0.262998*v_3_13-0.595673*v_3_14-0.016370*v_3_15+0.526708);\n\n    // --- layer 5 : output --------------\n    float v_5_0 = 0.5 + ( 0.274124*v_4_0+0.153013*v_4_1 -1.233798*v_4_2+0.299297*v_4_3+0.879313*v_4_4-0.199257*v_4_5-0.248584*v_4_6+0.411614*v_4_7-0.153534);\n    fragColor = vec4(v_5_0, v_5_0, v_5_0, 1.0);\n}"], ["// License CC0: 2nd attempt multiscale truchet\n// Everyone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\n// Been tinkering a bit more with multiscale truchet inspired by Shane's.\n// Made a height field and applied lighting to it. Kind of neat\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n    return pow(t, vec3(1.0/2.2));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat df0(vec2 p) {\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+100.0);\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - 0.125;\n  return d;\n}\n\nfloat df1(vec2 p) {\n  vec2 op = p;\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+200.0);\n  float h1 = fract(8667.0*h0);\n\n  if (h1 < 0.5) {\n    return -(df0(2.0*op))*0.5;\n  }\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  p = abs(p);\n  float d2 = circle(p-0.5, 0.125*1.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125*1.5;\n  d = min(d, d2);\n  return d;\n}\n\nfloat df2(vec2 p) {\n  vec2 op = p;\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+300.0);\n  float h1 = fract(8667.0*h0);\n\n  if (h1 < 0.5) {\n    return -(df1(2.0*op))*0.5;\n  }\n\n  if (h0 > 0.666) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  p = abs(p);\n  float d2 = circle(p-0.5, 0.125);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125;\n  d = min(d, d2);\n  d = abs(d)-0.0125*2.5;\n  return d;\n}\n\nfloat df(vec2 p) {\n  return df2(p);\n}\n\nfloat hf(vec2 p) {\n  float aa = 0.0275;\n  float d = df(p);\n  return -0.033*smoothstep(aa, -aa, -d);\n}\n\nfloat g_h3 = 0.0;\n\nfloat height(vec2 p) {\n  p *= 0.3333;\n  float h = hf(p);\n  p *= 3.0;\n  h += 0.5*hf(p);\n  p *= 3.0;\n  float h3 = hf(p);\n  h += 0.25*h3;\n  g_h3 = h3;\n  return h;\n}\n\nvec3 normal(vec2 p) {\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 effect(vec2 p) {\n  const float s = 1.0;\n  \n  const float amp = 10.0;\n  vec2 off = amp*sin(vec2(1.0, sqrt(0.5))*TIME*TAU/(30.0*amp));\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  vec2 p0 = p;\n  p0 += off;\n  float h = height(p0);\n  float h3= g_h3;\n  vec3  n = normal(p0);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n  float fre   = 1.0+dot(n,rd);\n  float mh3  = smoothstep(-0.033, -0.015, h3);\n  vec3 mat   = HSV2RGB(vec3(0.66, 0.55, mix(0.75, 0.05, mh3)));\n  const vec3 lcol1 = HSV2RGB(vec3(0.60, 0.66, 6.0));\n  const vec3 lcol2 = HSV2RGB(vec3(0.05, 0.66, 2.0));\n  vec3 col = vec3(0.);\n  float dm = tanh_approx(-h*10.0+0.05);\n  float dist1 = DOT2(lp1 - po);\n  float dist2 = DOT2(lp2 - po);\n  col += (lcol1*mat)*(diff1*diff1/dist1);\n  col += (lcol2*mat)*(diff2*diff2/dist2);\n  col *= dm;\n  float rm = mix(0.125, 0.5, fre);\n  float spread = mix(80.0, 40.0, mh3);\n  col += (rm/dist1)*(pow(ref1, spread)*lcol1);\n  col += (rm/dist2)*(pow(ref2, spread)*lcol2);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: 1st attempt multiscale truchet\n// Everyone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\n// I was trying to understand what was going and my brain hurt.\n// Anyway after some tinkering I think I got the gist of it. The idea is brilliant!\n// Compared to Shane's this looks awful but I have a low barrier to what I chose to share :)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Classic truchet pattern\nfloat df0(vec2 p) {\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i++) {\n        s += k * texture(iChannel0, p * k).x;\n        k *= 2.0;\n    }\n    return s;\n}\n\n// Multiscale truchet\nfloat df1(vec2 p) {\n  vec2 op = p;\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+100.0);\n  float h1 = fract(8667.0*h0);\n\n  // Recurse to df0 for 50% of the tiles\n  if (h1 < 0.5) {\n    // Invert the distance to make inside into outside\n    return -(df0(2.0*op))*0.5;\n  }\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  // Classic truchet with an added circle\n  // so that the outside areas matches up with the nested truchet \n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  p = abs(p);\n  float d2 = circle(p-0.5, 0.125*1.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125*1.5;\n  d = min(d, d2);\n  return d;\n}\n\nfloat df(vec2 p) {\n  return df1(p);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  const float amp = 10.0;\n  p += amp*sin(vec2(1.0, sqrt(0.5))*TIME*TAU/(10.0*amp));\n  const float sz = 0.25;\n  float d = df(p/sz)*sz;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);  \n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: 1st attempt multiscale truchet\n// Everyone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\n// I was trying to understand what was going and my brain hurt.\n// Anyway after some tinkering I think I got the gist of it. The idea is brilliant!\n// Compared to Shane's this looks awful but I have a low barrier to what I chose to share :)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Classic truchet pattern\nfloat df0(vec2 p) {\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+100.0);\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - 0.125;\n  return d;\n}\n\n// Multiscale truchet\nfloat df1(vec2 p) {\n    float s = 0.0;\n    for (int i = 0; i < 3; i++) {\n        float a = float(i) * 0.25;\n        float r = 0.5 * pow(2.0, float(i));\n        vec2 q = r * p;\n        q = 0.5 * (q + vec2(cos(a), sin(a)));\n        s = max(s, length(q) - 0.25);\n    }\n    return s;\n}\n\nfloat df(vec2 p) {\n  return df1(p);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  const float amp = 10.0;\n  p += amp*sin(vec2(1.0, sqrt(0.5))*TIME*TAU/(10.0*amp));\n  const float sz = 0.25;\n  float d = df(p/sz)*sz;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);  \n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a triangle. Negative in the inside, positive in the outside.\n// Note there's only one square root involved. The clamp(x,a,b) is really just\n// max(a,min(b,x)). The sign(x) function is |x|/x. \n\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// Other triangle functions:\n//\n// Distance:   https://www.shadertoy.com/view/XsXSz4\n// Gradient:   https://www.shadertoy.com/view/tlVyWh\n// Boundaries: https://www.shadertoy.com/view/tlKcDz\n\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign(e0.x*e2.y - e0.y*e2.x);\n    float d0 = dot( pq0, pq0 );\n    float d1 = dot( pq1, pq1 );\n    float d2 = dot( pq2, pq2 );\n    float d01 = dot( pq0, pq1 );\n    float d02 = dot( pq0, pq2 );\n    float d12 = dot( pq1, pq2 );\n    float h = sqrt(max(0.0,1.0-d01*d01/(d0*d1)));\n    float a = d01 + h*sqrt(max(0.0,d0-d01*d01/(d0*d1)));\n    float b = d12 + h*sqrt(max(0.0,d1-d12*d12/(d1*d2)));\n    float c = d02 + h*sqrt(max(0.0,d2-d02*d02/(d2*d0)));\n    float k4 = 4.0*// incomplete generation!\n\nfloat drawQuad(in vec2 p, vec2 v1, float w1, vec2 v2, float w2){\n    float t1 = sdTriangle(p, v1+vec2(-w1/2.,0.0),v1+vec2(w1/2.,0.0),v2+vec2(w2/2.,0));\n    return min(t1, sdTriangle( p,v1+vec2(-w1/2.,0.0),v2-vec2(w2/2.,0),v2+vec2(w2/2.,0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    m *= 1.5;\n    \n    // animate\n\tvec2 v1 = vec2(1.4,1.0)*cos( iTime*vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = vec2(1.4,1.0)*cos( iTime*vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = vec2(1.4,1.0)*cos( iTime*vec2(0.0,3.00) + 4.0 );\nv3 = abs(v3);\n    // distance\n\tfloat d = sdTriangle( p, v1, v2, v3 );\n    d = drawQuad(p, v1, v3.x, v2, v3.y);\n    // color\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}"], ["// License CC0: Cable nest v2\n//  Revisited the old Cable nest shader and recoloured + tweaked distance field\n//  Thought it turned out nice enough to share again\n\n\n// ---\n\n// Some parameters to play with.\n\n#define BPM 120.0\n\n// Controls camera \"fisheye\" \n//#define RDD0\n//#define RDD1\n\n// cable shapes\n#define ROUNDEDX\n//#define BOX\n\n// Colour themes\n//#define THEME0\n#define THEME1\n//#define THEME2\n\n// If using aces approx \n#define HDR\n\n// Another distance field, slightly different\n//#define DF0\n\n// Number of iterations used for distance field\n#define MAX_ITER  3\n\n// ---\n\n\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\nconst float cam_amp = 1.0;\n\nmat2 g_rot = ROT(0.0);\nfloat g_quad = 0.0;\nint g_hit = 0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 > dbuffer) return -1.0;\n    if (t2 < dbuffer) return -1.0;\n    return min(t1, t2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, float r) {\n  b -= r;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat cables(vec3 p3) {\n  const float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= g_rot;\n  float s = 1.0;\n  \n  float d = 1E6;\n  float quad = 1.0;\n  int hit = 0; \n  for (int i = 0; i < MAX_ITER; ++i) {\n    p *= pp;\n    p = abs(p);\n#if defined(DF0)\n    const float scaling = 3.0;\n    p -= 0.5*s*scaling;\n    s *= 1.0/ss;\n    float sz = scaling*s;\n#else\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    const float sz = 1.0;\n#endif    \n    \n#if defined(ROUNDEDX)\n    float dd = roundedX(p, sz*1.5*cylr, sz*0.25*cylr)*s;\n#elif defined(BOX)\n    float dd = box(p, vec2(sz*cylr), sz*cylr*0.1)*s;\n#else\n    float dd = (length(p)-sz*cylr)*s;\n#endif\n    vec2 s = sign(p);\n    float q = s.x*s.y;\n    \n    if (dd < d) {\n      d = dd;\n      quad = q;\n      hit = i;\n    }\n    \n  }\n  \n  g_quad = quad;\n  g_hit = hit;\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  float d = cables(p);\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  float quad = g_quad;\n  float hit  = float(g_hit);\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*BPM/60.0));\n  vec3 bcol   = mix(HSV2RGB(vec3(0.6, 0.6, 3.0)), HSV2RGB(vec3(0.55, 0.8, 7.0)), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n  \n  vec3 nor    = normal(pos);\n\n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n\n  const vec3 black = vec3(0.0);\n#if defined(THEME0)\n  const vec3 dcol0 = HSV2RGB(vec3(0.6, 0.5, 1.0));\n  const vec3 dcol1 = dcol0;\n#elif defined(THEME1)\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));\n#elif defined(THEME2)\n  vec3 dcol0 = hsv2rgb(vec3(0.6-0.05*hit, 0.75, 1.0));\n  const vec3 dcol1 = HSV2RGB(vec3(0.8, 1.0, 0.));\n#else\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = dcol0;\n#endif\n  col += dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float tm = TIME;\n  g_rot = ROT(-0.2*tm);\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n#if defined(RDD0)\n  float rdd = (2.0-0.5*tanh_approx(dot(p, p)));\n#elif defined(RDD1)\n  float rdd = (2.0+0.75*tanh_approx(dot(p, p)));\n#else\n  const float rdd = 2.5;\n#endif  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p);\n#if defined(HDR)\n  col = aces_approx(col);\n  col = sRGB(col);\n#else  \n  col = sqrt(col);\n#endif  \n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// License CC0: Cable nest v2\n//  Revisited the old Cable nest shader and recoloured + tweaked distance field\n//  Thought it turned out nice enough to share again\n\n\n// ---\n\n// Some parameters to play with.\n\n#define BPM 120.0\n\n// Controls camera \"fisheye\" \n//#define RDD0\n//#define RDD1\n\n// cable shapes\n#define ROUNDEDX\n//#define BOX\n\n// Colour themes\n//#define THEME0\n#define THEME1\n//#define THEME2\n\n// If using aces approx \n#define HDR\n\n// Another distance field, slightly different\n//#define DF0\n\n// Number of iterations used for distance field\n#define MAX_ITER  3\n\n// ---\n\n\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\nconst float cam_amp = 1.0;\n\nmat2 g_rot = ROT(0.0);\nfloat g_quad = 0.0;\nint g_hit = 0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, float r) {\n  b -= r;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  vec2 d = abs(p) - w;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat cables(vec3 p3) {\n  const float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= g_rot;\n  float s = 1.0;\n  \n  float d = 1E6;\n  float quad = 1.0;\n  int hit = 0; \n  for (int i = 0; i < MAX_ITER; ++i) {\n    p *= pp;\n    p = abs(p);\n#if defined(DF0)\n    const float scaling = 3.0;\n    p -= 0.5*s*scaling;\n    s *= 1.0/ss;\n    float sz = scaling*s;\n#else\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    const float sz = 1.0;\n#endif    \n    \n#if defined(ROUNDEDX)\n    float dd = roundedX(p, sz*1.5*cylr, sz*0.25*cylr)*s;\n#elif defined(BOX)\n    float dd = box(p, vec2(sz*cylr), sz*cylr*0.1)*s;\n#else\n    float dd = (length(p)-sz*cylr)*s;\n#endif\n    vec2 s = sign(p);\n    float q = s.x*s.y;\n    \n    if (dd < d) {\n      d = dd;\n      quad = q;\n      hit = i;\n    }\n    \n  }\n  \n  g_quad = quad;\n  g_hit = hit;\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  float d = cables(p);\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  float quad = g_quad;\n  float hit  = float(g_hit);\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*BPM/60.0));\n  vec3 bcol   = mix(HSV2RGB(vec3(0.6, 0.6, 3.0)), HSV2RGB(vec3(0.55, 0.8, 7.0)), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n  \n  vec3 nor    = normal(pos);\n\n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n\n  const vec3 black = vec3(0.0);\n#if defined(THEME0)\n  const vec3 dcol0 = HSV2RGB(vec3(0.6, 0.5, 1.0));\n  const vec3 dcol1 = dcol0;\n#elif defined(THEME1)\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));\n#elif defined(THEME2)\n  vec3 dcol0 = hsv2rgb(vec3(0.6-0.05*hit, 0.75, 1.0));\n  const vec3 dcol1 = HSV2RGB(vec3(0.8, 1.0, 0.));\n#else\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = dcol0;\n#endif\n  col += dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float tm = TIME;\n  g_rot = ROT(-0.2*tm);\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n#if defined(RDD0)\n  float rdd = (2.0-0.5*tanh_approx(dot(p, p)));\n#elif defined(RDD1)\n  float rdd = (2.0+0.75*tanh_approx(dot(p, p)));\n#else\n  const float rdd = 2.5;\n#endif  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p);\n#if defined(HDR)\n  col = aces_approx(col);\n  col = sRGB(col);\n#else  \n  col = sqrt(col);\n#endif  \n  \n  fragColor = vec4(col, 1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to the a cross made of four y(x) = 1/x curves. Minimizing the\n// distance squared d\u00b2(x,y) = (x-t)\u00b2+(y-1/t)\u00b2 produces a 4th degree\n// polyonomial in t, which I'm solving with Ferrari's Method as described\n// here: https://en.wikipedia.org/wiki/Quartic_equation\n//\n// I added a paramter k in the open range (0,1) to control its shape.\n// Compare to negative squircle here: https://www.shadertoy.com/view/7stcR4\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, float k )\n{\n    float k2 = k*k;\n    float l = length(p);\n    float l2 = l*l;\n    float d = l2 - k2;\n    float d2 = d*d;\n    float d4 = d2*d2;\n    float d6 = d4*d2;\n    float d8 = d4*d4;\n    float d10 = d6*d4;\n    float d12 = d6*d6;\n    float d14 = d6*d8;\n    float d16 = d8*d8;\n    float d18 = d12*d6;\n    float d20 = d10*d10;\n    float d22 = d12*d8;\n    float d24 = d12*d12;\n    float d26 = d14*d12;\n    float d28 = d16*d12;\n    float d30 = d20*d10;\n    float d32 = d16*d16;\n    float d34 = d22*d16;\n    float d36 = d24*d16;\n    float d38 = d26*d16;\n    float d40 = d28*d16;\n    float d42 = d30*d16;\n    float d44 = d32*d16;\n    float d46 = d34*d16;\n    float d48 = d36*d16;\n    float d50 = d38*d16;\n    float d52 = d40*d16;\n    float d54 = d42*d16;\n    float d56 = d44*d16;\n    float d58 = d46*d16;\n    float d60 = d48*d16;\n    float d62 = d50*d16;\n    float d// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 1.5;\n    \n\tvec2  p = scale*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = scale*2.0/iResolution.y;\n    \n    float k = 0.5 + 0.45*sin(3.14159*iTime);\n    \n    float d = sdHyperbolicCross(p, k);\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-10.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(70.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,4.0*px,abs(d)) );\n    \n    // mouse\n    if( iMouse.z>0.001 )\n    {\n        float d = sdHyperbolicCross(m, k);\n        float l = length(p-m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, abs(l-abs(d))));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, l-px*3.0));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to the y(x)=1/x curve. \n\n\n// Minimizing the distance squared D\u00b2 = (x-t)\u00b2+(y-1/t)\u00b2 produces\n//\n// t\u2074 - xt\u00b3 + yt - 1 = 0\n//\n// which can be solved with the quartic formula, as described in Wikipedia:\n// https://en.wikipedia.org/wiki/Quartic_equation. I followed the \n// section \"Summary of Ferrari's method\" and simplified a lot of things\n// (complex branches to reals, trigonometrics, constant unfolding, etc)\n// until I got this expression.\n//\n// I wrote the shader for comparison with the numerically computed version\n// of the SDF implemented here: https://www.shadertoy.com/view/sttyWr\n\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n  return length(p*vec2(1.0,-1.0))-1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float scale = 3.0;\n    \n\tvec2  p = scale*fragCoord/iResolution.y;\n    vec2  m = scale*iMouse.xy/iResolution.y;\n    float px = scale/iResolution.y;\n    \n    float d = sdOOX(p);\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(73.33*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,3.0*px,abs(d)) );\n    \n    // mouse\n    if( iMouse.z>0.001 )\n    {\n        float d = sdOOX(m);\n        float l = length(p-m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, abs(l-abs(d))));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, l-px*3.0));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// License CC0: Dark chocolate FBM\n//  Working on a cake related shader and created kind of dark chocolate\n//  background. Nothing unique but different colors than what I usually \n//  do so sharing.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define DOT2(p)     dot(p, p)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  p.y -= -0.6;\n  p.x = pabs(p.x, 0.125);\n\n  if( p.y+p.x>1.0 )\n      return sqrt(DOT2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(DOT2(p-vec2(0.00,1.00)),\n                  DOT2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 n = floor(p + 0.5);\n  p = fract(p+0.5)-0.5;\n  return n;\n}\n\nfloat hf(vec2 p) {  \n  p *= 0.25;\n  vec2 p0 = p;\n  vec2 n0 = mod2_1(p0);\n  vec2 p1 = p*vec2(1.0, -1.0)+vec2(0.5, 0.66);\n  vec2 n1 = mod2_1(p1);\n  const float ss = 0.60;\n  float d0 = heart(p0/ss)*ss;\n  float d1 = heart(p1/ss)*ss;\n  float d = min(d0, d1);\n  return tanh_approx(smoothstep(0.0, -0.1,d)*exp(8.0*-d));\n}\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.0);\n  float tm = 123.0+TTIME/240.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 4; ++i) {\n    h += a*hf(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec2 ppp = p;\n  const float s     = 1.0;\n  const vec3 lp1    = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2    = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lcol1  = HSV2RGB(vec3(0.06, 0.9 , .5));\n  const vec3 lcol2  = HSV2RGB(vec3(0.05, 0.25, 1.0));\n  const vec3 mcol   = HSV2RGB(vec3(0.1 , 0.95, 0.2));\n  const float spe1  = 20.0;\n  const float spe2  = 40.0;\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lpow1 = 0.15*lcol1/DOT2(ld1);\n  vec3 lpow2 = 0.25*lcol2/DOT2(ld2);\n  vec3 dm = mcol*tanh_approx(-h*5.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*lpow1;\n  col += dm*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, spe1)*lcol1;\n  col += rm*pow(ref2, spe2)*lcol2;\n\n  const float top = 10.0;\n\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, q);  \n  \n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// License CC0: Dark chocolate FBM\n//  Working on a cake related shader and created kind of dark chocolate\n//  background. Nothing unique but different colors than what I usually \n//  do so sharing.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define DOT2(p)     dot(p, p)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n    return k * (a + 1.0) - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  p.y -= -0.6;\n  p.x = pabs(p.x, 0.125);\n\n  if( p.y+p.x>1.0 )\n      return sqrt(DOT2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(DOT2(p-vec2(0.00,1.00)),\n                  DOT2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 n = floor(p + 0.5);\n  p = fract(p+0.5)-0.5;\n  return n;\n}\n\nfloat hf(vec2 p) {  \n  p *= 0.25;\n  vec2 p0 = p;\n  vec2 n0 = mod2_1(p0);\n  vec2 p1 = p*vec2(1.0, -1.0)+vec2(0.5, 0.66);\n  vec2 n1 = mod2_1(p1);\n  const float ss = 0.60;\n  float d0 = heart(p0/ss)*ss;\n  float d1 = heart(p1/ss)*ss;\n  float d = min(d0, d1);\n  return tanh_approx(smoothstep(0.0, -0.1,d)*exp(8.0*-d));\n}\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.0);\n  float tm = 123.0+TTIME/240.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 4; ++i) {\n    h += a*hf(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec2 ppp = p;\n  const float s     = 1.0;\n  const vec3 lp1    = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2    = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lcol1  = HSV2RGB(vec3(0.06, 0.9 , .5));\n  const vec3 lcol2  = HSV2RGB(vec3(0.05, 0.25, 1.0));\n  const vec3 mcol   = HSV2RGB(vec3(0.1 , 0.95, 0.2));\n  const float spe1  = 20.0;\n  const float spe2  = 40.0;\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lpow1 = 0.15*lcol1/DOT2(ld1);\n  vec3 lpow2 = 0.25*lcol2/DOT2(ld2);\n  vec3 dm = mcol*tanh_approx(-h*5.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*lpow1;\n  col += dm*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, spe1)*lcol1;\n  col += rm*pow(ref2, spe2)*lcol2;\n\n  const float top = 10.0;\n\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, q);  \n  \n  fragColor = vec4(col, 1.0);\n}\n\n"], ["// Copyright \u00a9 2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise12(vec2 p) {\n    vec2 t = fract(p);\n    p = floor(p) + vec2(1.365, -0.593);\n    vec2 e = vec2(0, 1);\n    return mix(\n        mix(hash12(p + e.xx), hash12(p + e.yx), t.x),\n        mix(hash12(p + e.yx), hash12(p + e.yy), t.x),\n        t.y\n    );\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    O = vec4(0.95, 0.95, 0.9, 1);\n    vec2 r = iResolution.xy, m = vec2(0), M = r, p = m, k, l, e = vec2(0, 1);\n    float a;\n    for (int i = 0; i < int(log2(length(r))/1.2); i++) {\n        a = noise12(p + iTime * 0.1);\n        if (a > 0.1 * dot(r, e) / dot(r, e.yx)) e = 1.0 - e;\n        a = 0.35 + 0.3 * hash12(p + r * sign(U - p));\n        p += (m * (1.0 - a) + M * a - p) * e;\n        if (abs(dot(p - U, e)) < 2.0) {\n            O.xyz *= 0.0;\n            return;\n        }\n        k = clamp(sign(U - p), 0.0, 1.0);\n        l = clamp(sign(p - U), 0.0, 1.0);\n        m += (max(k * p, m) - m) * e;\n        M += (min(k * r + l * p, M) - M) * e;\n    }\n    a = noise12(p + sign(U - p) * r + iTime * 0.25);\n    if (0.3 <= a && a < 0.4) O = vec4(0.9, 0, 0.2, 1);\n    else if (0.4 <= a && a < 0.5) O = vec4(0.9, 0.9, 0, 1);\n    else if (0.5 <= a && a < 0.6) O = vec4(0, 0.2, 1, 1);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a quadratic bezier segment.\n// Faster than central differences or automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a + b;\n    vec2 d = A - pos;\n\n    float k0 = dot(d,d);\n    float k1 = 2.0*dot(d,a);\n    float k2 = dot(a,a);\n    float k3 = 2.0*dot(d,b);\n    float k4 = 2.0*dot(a,b);\n    float k5 = dot(b,b);\n\n    float p = k2 + 2.0*k4 - 3.0*k1;\n    float q = k1 - 2.0*k2 + k3 + 2.0*k4 - 3.0*k5;\n    float r = 2.0*k3 - 4.0*k5;\n    float s = k5;\n\n    float det = 1.5*p*p - 3.0*p*q + 2.0*q*q + 12.0*r;\n    float h = sqrt(max(0.0,det));\n    float x0 = (2.0*h - 1.5*p + sqrt(h*h - 4.0*r))/(2.0*h);\n    float x1 = (2.0*h - 1.5*p - sqrt(h*h - 4.0*r))/(2.0*h);\n\n    float x = max(min(x0,x1),0.0);\n    float y = x*x;\n    float z = x*y;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    \n    // sdf\n    vec3  dg = sdBezier( p, v0, v1, v2 );\n    float d = dg.x;\n    vec2 g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdBezier( m, v0, v1, v2 ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n "], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parabolic segment.\n// Faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he )\n{\n    vec2 p = pos;\n    p.x *= wi/he;\n    float h = 1.0-p.y;\n    float d = length(p);\n    float a = 1.0-d;\n    float b = 1.0-d*d;\n    float c = 1.0-d*d*d;\n    float d2 = length(p.x);\n    float a2 = 1.0-d2;\n    float b2 = 1.0-d2*d2;\n    float c2 = 1.0-d2*d2*d2;\n    float d3 = length(p.y);\n    float a3 = 1.0-d3;\n    float b3 = 1.0-d3*d3;\n    float c3 = 1.0-d3*d3*d3;\n    float d4 = length(p.y);\n    float a4 = 1.0-d4;\n    float b4 = 1.0-d4*d4;\n    float c4 = 1.0-d4*d4*d4;\n    float d5 = length(p.y);\n    float a5 = 1.0-d5;\n    float b5 = 1.0-d5*d5;\n    float c5 = 1.0-d5*d5*d5;\n    float d6 = length(p.y);\n    float a6 = 1.0-d6;\n    float b6 = 1.0-d6*d6;\n    float c6 = 1.0-d6*d6*d6;\n    float d7 = length(p.y);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n\tfloat w = 0.7+0.69*sin(iTime*0.61+0.0);\n    float h = 0.4+0.35*sin(iTime*0.53+2.0);\n    \n    // sdf\n    vec3  dg = sdParabola( p, w, h );\n    float d = dg.x;\n    vec2 g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m, w, h ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n "], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parabola.\n// Probably faster than central differences or\n// automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float k )\n{\n    float d = pos.y - pos.x*pos.x*k;\n    float h = 1.0 - 4.0*k*pos.x;\n    float s = sqrt(h);\n    float t = 0.5*s + pos.x;\n    float u = -0.5*s + pos.x;\n    float v = 0.5*s - pos.x;\n    float w = -0.5*s - pos.x;\n    float a = 0.5*d/s;\n    float b = 0.5*d/s;\n    float c = 0.5*d/s;\n    float e = 0.5*d/s;\n    float f = 0.5*d/s;\n    float g = 0.5*d/s;\n    float h = 0.5*d/s;\n    float i = 0.5*d/s;\n    float j = 0.5*d/s;\n    float k = 0.5*d/s;\n    float l = 0.5*d/s;\n    float m = 0.5*d/s;\n    float n = 0.5*d/s;\n    float o = 0.5*d/s;\n    float p = 0.5*d/s;\n    float q = 0.5*d/s;\n    float r = 0.5*d/s;\n    float s = 0.5*d/s;\n    float t = 0.5*d/s;\n    float u = 0.5*d/s;\n    float v = 0.5*d/s;\n    float w = 0.// incomplete generation!\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n    float px =  0.0 + 0.4*cos(t*1.1+5.5); // x position\n    float py = -0.4 + 0.2*cos(t*1.2+3.0); // y position\n    float pk =  8.0 + 7.5*cos(t*1.3+3.5); // width\n    \n    // sdf\n    vec3  dg = sdParabola( p-vec2(px,py), pk );\n    float d = dg.x;\n    vec2 g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n     vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m-vec2(px,py), pk ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n "], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a moon shape. Faster than\n// central differences or automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdMoon(vec2 p, float d, float ra, float rb )\n{\n    vec2 q = vec2(p.x, p.y);\n    q.x -= sin(ra)*rb;\n    q.y -= cos(ra)*rb;\n    float a = atan(q.x, q.y);\n    float r = length(q);\n    float s = r*sin(a);\n    float c = r*cos(a);\n    float e = 1.0 - d*d;\n    float f = (s*s + c*c - d*d)/(2.0*d);\n    float g = sqrt(d*d - f*f);\n    float x = f*cos(a);\n    float y = f*sin(a);\n    float z = g*cos(ra);\n    float w = g*sin(ra);\n    float t = atan(w, z);\n    float u = atan(y, x);\n    float v = atan(x, y);\n    float k = 1.0 - (1.0 - e)*e;\n    float l = 1.0 - (1.0 - e*e)*e*e;\n    float m = 1.0 - (1.0 - e*e*e)*e;\n    float n = 1.0 - (1.0 - e*e*e*e)*e*e;\n    float o = 1.0 - (1.0 - e*e*e*e*e)*e*e*e;\n    float p = 1.0 - (1.0 - e*e*e*e*e*e)*e*e*e*e;\n    float q = 1.0 - (1.0 - e*e*e*e*e*e*e)*e*e// incomplete generation!\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float ra = 0.9;\n    float rb = 0.7;\n    float di = 1.2*cos(iTime+3.9);\n    \n    // sdf\n    vec3  dg = sdMoon( p, di, ra, rb );\n    float d = dg.x;\n    vec2  g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdMoon(m, di, ra, rb ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n "], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Gradient Noise (http://en.wikipedia.org/wiki/Gradient_noise), not to be confused with\n// Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n// is probably the most convenient way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces smoother and higher quality than Value Noise, but it's of course slighty more\n// expensive.\n//\n// The princpiple is to create a virtual grid/latice all over the plane, and assign one\n// random vector to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random vectors\n// fetched. Then, the position of the current point under  evaluation relative to each\n// vertex is doted (projected) with that vertex' random vector, and the result is\n// bilinearly interpolated with a smooth interpolant.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v)\n{\n    v = v * 1664525 + 1013904223;\n    v = v ^ (v >> 16);\n    v = v * 1664525;\n    v = v ^ (v >> 16);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    uint z = uint(v.z);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    z = z * 1664525u + 1013904223u;\n    x += y * z;\n    y += z * x;\n    z += x * y;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    z ^= z >> 16;\n    x += y * z;\n    y += z * x;\n    z += x * y;\n    return ivec3(x, y, z);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec4 Pcg4(ivec4 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    uint z = uint(v.z);\n    uint w = uint(v.w);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    z = z * 1664525u + 1013904223u;\n    w = w * 1664525u + 1013904223u;\n    x += y * w;\n    y += z * x;\n    z += x * y;\n    w += y * z;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    z ^= z >> 16;\n    w ^= w >> 16;\n    x += y * w;\n    y += z * x;\n    z += x * y;\n    w += y * z;\n    return ivec4(x, y, z, w);\n}\n\nvec2 grad2( ivec2 v )\n{\n    int n = Pcg2(v).x;\n    // higher quality rng in high bits\n    float x = (n & (1<<30)) != 0 ? 1.0 : -1.0;\n    float y = (n & (1<<29)) != 0 ? 1.0 : -1.0;\n    float z = (n & (1<<28)) != 0 ? 1.0 : -1.0;\n    vec3 gr = vec3(x, y, z);\n    return vec2(gr.x, gr.y);\n}\n\nvec3 grad3( ivec3 v)\n{\n    v = Pcg3(v);\n    // higher quality rng in high bits\n    float x = (v.x & (1<<30)) != 0 ? 1.0 : -1.0;\n    float y = (v.y & (1<<29)) != 0 ? 1.0 : -1.0;\n    float z = (v.z & (1<<28)) != 0 ? 1.0 : -1.0;\n    return vec3(x, y, z);\n}\n\nfloat noise2( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f * f * ((f * -2.0f) + 3.0f);\n\n    float c00 = dot(grad2(i + ivec2(0,0)), f - vec2(0.0, 0.0));\n    float c01 = dot(grad2(i + ivec2(1,0)), f - vec2(1.0, 0.0));\n    float c10 = dot(grad2(i + ivec2(0,1)), f - vec2(0.0, 1.0));\n    float c11 = dot(grad2(i + ivec2(1,1)), f - vec2(1.0, 1.0));\n    \n    float c = mix(mix(c00, c01, u.x), mix(c10, c11, u.x), u.y);\n    return c;\n}\n\nfloat noise3(in vec3 p)\n{\n    ivec3 i = ivec3(floor( p ));\n     vec3 f =       fract( p );\n\t\n\tvec3 u = f * f * ((f * -2.0f) + 3.0f);\n\n    float c000 = dot(grad3(i + ivec3(0,0,0)), f - vec3(0.0,0.0,0.0));\n    float c001 = dot(grad3(i + ivec3(0,0,1)), f - vec3(0.0,0.0,1.0));\n    \n    float c010 = dot(grad3(i + ivec3(0,1,0)), f - vec3(0.0,1.0,0.0));\n    float c011 = dot(grad3(i + ivec3(0,1,1)), f - vec3(0.0,1.0,1.0));\n    \n    float c100 = dot(grad3(i + ivec3(1,0,0)), f - vec3(1.0,0.0,0.0));\n    float c101 = dot(grad3(i + ivec3(1,0,1)), f - vec3(1.0,0.0,1.0));\n    \n    float c110 = dot(grad3(i + ivec3(1,1,0)), f - vec3(1.0,1.0,0.0));\n    float c111 = dot(grad3(i + ivec3(1,1,1)), f - vec3(1.0,1.0,1.0));\n    \n    float c00z = mix(c000, c001, u.z);\n    float c01z = mix(c010, c011, u.z);\n    float c10z = mix(c100, c101, u.z);\n    float c11z = mix(c110, c111, u.z);\n    \n    float c0yz = mix(c00z, c01z, u.y);\n    float c1yz = mix(c10z, c11z, u.y);\n    \n    float cxyz = mix(c0yz, c1yz, u.x);\n    \n    return cxyz;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\t\n\tfloat f = 0.0;\n\n    vec2 uv2 = p*vec2(iResolution.x/iResolution.y,1.0);\n    vec3 uv3 = vec3(uv2.x, uv2.y,iTime);\n    uv3.xy = 32.0 * uv3.xy;\n    float freq = 1.0;\n    float scale = 1.0;\n    float peak = 0.0;\n    float u = min(p.x, 1.0);\n    float octaves = 1.0 + u * 3.0;\n    octaves = min(octaves, 4.0);\n    for (float i = 0.0; i < ceil(octaves); i += 1.0)\n    {\n        float amt = min(max(octaves - i, 0.0), 1.0);\n        scale *= amt;\n        peak += scale;\n        f += scale * noise3(uv3 * freq);\n        scale *= 0.55;\n        freq *= 2.0136;\n    }\n    f = f / peak;\n    f = 0.5 + 0.5*f;\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Gradient Noise (http://en.wikipedia.org/wiki/Gradient_noise), not to be confused with\n// Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n// is probably the most convenient way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces smoother and higher quality than Value Noise, but it's of course slighty more\n// expensive.\n//\n// The princpiple is to create a virtual grid/latice all over the plane, and assign one\n// random vector to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random vectors\n// fetched. Then, the position of the current point under  evaluation relative to each\n// vertex is doted (projected) with that vertex' random vector, and the result is\n// bilinearly interpolated with a smooth interpolant.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    x += y * 1664525u;\n    y += x * 1664525u;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    x += y * 1664525u;\n    y += x * 1664525u;\n    return ivec2(x, y);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v)\n{\n    v = v * 1664525 + 1013904223;\n    v = (v ^ (v >> 16)) * 2246822507;\n    v = (v ^ (v >> 16)) * 3266489917;\n    return v ^ (v >> 16);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec4 Pcg4(ivec4 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    uint z = uint(v.z);\n    uint w = uint(v.w);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    z = z * 1664525u + 1013904223u;\n    w = w * 1664525u + 1013904223u;\n    x += y * w;\n    y += z * x;\n    z += x * y;\n    w += y * z;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    z ^= z >> 16;\n    w ^= w >> 16;\n    x += y * w;\n    y += z * x;\n    z += x * y;\n    w += y * z;\n    return ivec4(x, y, z, w);\n}\n\nvec2 grad2( ivec2 v )\n{\n    int n = Pcg2(v).x;\n    // higher quality rng in high bits\n    float x = (n & (1<<30)) != 0 ? 1.0 : -1.0;\n    float y = (n & (1<<29)) != 0 ? 1.0 : -1.0;\n    float z = (n & (1<<28)) != 0 ? 1.0 : -1.0;\n    vec3 gr = vec3(x, y, z);\n    return vec2(gr.x, gr.y);\n}\n\nvec3 grad3( ivec3 v)\n{\n    v = Pcg3(v);\n    // higher quality rng in high bits\n    float x = (v.x & (1<<30)) != 0 ? 1.0 : -1.0;\n    float y = (v.y & (1<<29)) != 0 ? 1.0 : -1.0;\n    float z = (v.z & (1<<28)) != 0 ? 1.0 : -1.0;\n    return vec3(x, y, z);\n}\n\nfloat noise2( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f * f * ((f * -2.0f) + 3.0f);\n\n    float c00 = dot(grad2(i + ivec2(0,0)), f - vec2(0.0, 0.0));\n    float c01 = dot(grad2(i + ivec2(1,0)), f - vec2(1.0, 0.0));\n    float c10 = dot(grad2(i + ivec2(0,1)), f - vec2(0.0, 1.0));\n    float c11 = dot(grad2(i + ivec2(1,1)), f - vec2(1.0, 1.0));\n    \n    float c = mix(mix(c00, c01, u.x), mix(c10, c11, u.x), u.y);\n    return c;\n}\n\nfloat noise3(in vec3 p)\n{\n    ivec3 i = ivec3(floor( p ));\n     vec3 f =       fract( p );\n\t\n\tvec3 u = f * f * ((f * -2.0f) + 3.0f);\n\n    float c000 = dot(grad3(i + ivec3(0,0,0)), f - vec3(0.0,0.0,0.0));\n    float c001 = dot(grad3(i + ivec3(0,0,1)), f - vec3(0.0,0.0,1.0));\n    \n    float c010 = dot(grad3(i + ivec3(0,1,0)), f - vec3(0.0,1.0,0.0));\n    float c011 = dot(grad3(i + ivec3(0,1,1)), f - vec3(0.0,1.0,1.0));\n    \n    float c100 = dot(grad3(i + ivec3(1,0,0)), f - vec3(1.0,0.0,0.0));\n    float c101 = dot(grad3(i + ivec3(1,0,1)), f - vec3(1.0,0.0,1.0));\n    \n    float c110 = dot(grad3(i + ivec3(1,1,0)), f - vec3(1.0,1.0,0.0));\n    float c111 = dot(grad3(i + ivec3(1,1,1)), f - vec3(1.0,1.0,1.0));\n    \n    float c00z = mix(c000, c001, u.z);\n    float c01z = mix(c010, c011, u.z);\n    float c10z = mix(c100, c101, u.z);\n    float c11z = mix(c110, c111, u.z);\n    \n    float c0yz = mix(c00z, c01z, u.y);\n    float c1yz = mix(c10z, c11z, u.y);\n    \n    float cxyz = mix(c0yz, c1yz, u.x);\n    \n    return cxyz;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\t\n\tfloat f = 0.0;\n\n    vec2 uv2 = p*vec2(iResolution.x/iResolution.y,1.0);\n    vec3 uv3 = vec3(uv2.x, uv2.y,iTime);\n    uv3.xy = 32.0 * uv3.xy;\n    float freq = 1.0;\n    float scale = 1.0;\n    float peak = 0.0;\n    float u = min(p.x, 1.0);\n    float octaves = 1.0 + u * 3.0;\n    octaves = min(octaves, 4.0);\n    for (float i = 0.0; i < ceil(octaves); i += 1.0)\n    {\n        float amt = min(max(octaves - i, 0.0), 1.0);\n        scale *= amt;\n        peak += scale;\n        f += scale * noise3(uv3 * freq);\n        scale *= 0.55;\n        freq *= 2.0136;\n    }\n    f = f / peak;\n    f = 0.5 + 0.5*f;\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}"], ["// Using distance-to-quadratic and winding number to generate a closed-form\n// distance field of a font outline, which is specified as lines + quadratic\n// B\u00e9zier curves.\n//\n// Quadratic solver is based on https://www.shadertoy.com/view/MlKcDD, which\n// includes the following copyright notice:\n//\n//      Copyright \u00a9 2018 Inigo Quilez\n//      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Curves are baked by an external tool\n#define QUAD_COUNT 38\nconst vec2 QUADS[QUAD_COUNT * 3] = vec2[QUAD_COUNT * 3](\n    vec2(0.5758487, -4.5724106), vec2(0.5758487, -4.9204984), vec2(0.7176622, -5.221315),\n    vec2(0.7176622, -5.221315), vec2(0.8594757, -5.5221314), vec2(1.1216158, -5.758487),\n    vec2(0.7520412, -2.0842285), vec2(0.8594757, -1.6974645), vec2(1.0034379, -1.3859046),\n    vec2(0.86162436, -3.5904598), vec2(0.5758487, -3.9664803), vec2(0.5758487, -4.5724106),\n    vec2(1.0034379, -1.3859046), vec2(1.1474, -1.0743446), vec2(1.3837559, -0.8036098),\n    vec2(1.1216158, -5.758487), vec2(1.3708637, -5.9819508), vec2(1.7103566, -6.1087236),\n    vec2(1.3794585, -4.9591746), vec2(1.3794585, -4.563816), vec2(1.5642458, -4.3038244),\n    vec2(1.3837559, -0.8036098), vec2(1.6072196, -0.55006444), vec2(1.9058874, -0.3996562),\n    vec2(1.5642458, -4.3038244), vec2(1.7490331, -4.0438333), vec2(2.101418, -3.8762355),\n    vec2(1.6630855, -2.9823806), vec2(1.1474, -3.2144392), vec2(0.86162436, -3.5904598),\n    vec2(1.6673828, -5.599484), vec2(1.3794585, -5.337344), vec2(1.3794585, -4.9591746),\n    vec2(1.6974645, -0.0021486892), vec2(1.2892135, -0.12892136), vec2(0.99269444, -0.30941126),\n    vec2(1.7103566, -6.1087236), vec2(2.0498495, -6.235496), vec2(2.419424, -6.235496),\n    vec2(1.9058874, -0.3996562), vec2(2.2045553, -0.24924795), vec2(2.599914, -0.24924795),\n    vec2(2.101418, -3.8762355), vec2(2.4151268, -3.7258272), vec2(2.718092, -3.616244),\n    vec2(2.2862053, -2.7266867), vec2(1.9252255, -2.862054), vec2(1.6630855, -2.9823806),\n    vec2(2.363558, -5.8616242), vec2(1.9553072, -5.8616242), vec2(1.6673828, -5.599484),\n    vec2(2.419424, -6.235496), vec2(2.840567, -6.235496), vec2(3.173614, -6.106575),\n    vec2(2.5139663, 0.12462398), vec2(2.1057155, 0.12462398), vec2(1.6974645, -0.0021486892),\n    vec2(2.599914, -0.24924795), vec2(2.896433, -0.24924795), vec2(3.117748, -0.32660076),\n    vec2(2.718092, -3.616244), vec2(3.0210571, -3.506661), vec2(3.3046842, -3.382037),\n    vec2(2.9265146, -2.4795873), vec2(2.647185, -2.5913193), vec2(2.2862053, -2.7266867),\n    vec2(3.0167596, -5.7133646), vec2(2.7503223, -5.8616242), vec2(2.363558, -5.8616242),\n    vec2(3.117748, -0.32660076), vec2(3.3390632, -0.40395358), vec2(3.4765792, -0.54576707),\n    vec2(3.173614, -6.106575), vec2(3.506661, -5.9776535), vec2(3.781693, -5.8057585),\n    vec2(3.3046842, -3.382037), vec2(3.5625267, -3.270305), vec2(3.8010314, -3.1284916),\n    vec2(3.4679844, -5.315857), vec2(3.2831972, -5.565105), vec2(3.0167596, -5.7133646),\n    vec2(3.4765792, -0.54576707), vec2(3.6140952, -0.6875806), vec2(3.6807046, -0.8788139),\n    vec2(3.54104, -2.0004296), vec2(3.3347657, -2.316287), vec2(2.9265146, -2.4795873),\n    vec2(3.6807046, -0.8788139), vec2(3.747314, -1.0700473), vec2(3.747314, -1.3192952),\n    vec2(3.747314, -1.3192952), vec2(3.747314, -1.6845723), vec2(3.54104, -2.0004296),\n    vec2(3.775247, -4.7400084), vec2(3.657069, -5.0580144), vec2(3.4679844, -5.315857),\n    vec2(3.8010314, -3.1284916), vec2(4.039536, -2.9866781), vec2(4.2157283, -2.7975934),\n    vec2(3.9879673, -4.073915), vec2(3.893425, -4.4220023), vec2(3.775247, -4.7400084),\n    vec2(3.996562, -0.3996562), vec2(3.3992264, 0.12462398), vec2(2.5139663, 0.12462398),\n    vec2(4.2157283, -2.7975934), vec2(4.4091105, -2.5827246), vec2(4.501504, -2.3270304),\n    vec2(4.501504, -2.3270304), vec2(4.593898, -2.0713365), vec2(4.593898, -1.7318435),\n    vec2(4.593898, -1.7318435), vec2(4.593898, -0.92393637), vec2(3.996562, -0.3996562)\n);\n\n#define LINE_COUNT 8\nconst vec2 LINES[LINE_COUNT * 2] = vec2[LINE_COUNT * 2](\n    vec2(0.40395358, -2.0842285), vec2(0.7520412, -2.0842285),\n    vec2(0.46411687, 0.0042973785), vec2(0.40395358, -2.0842285),\n    vec2(0.80790716, 0.0042973785), vec2(0.46411687, 0.0042973785),\n    vec2(0.99269444, -0.30941126), vec2(0.80790716, 0.0042973785),\n    vec2(3.781693, -5.8057585), vec2(3.9578855, -6.09798),\n    vec2(3.9578855, -6.09798), vec2(4.301676, -6.09798),\n    vec2(4.301676, -6.09798), vec2(4.336055, -4.073915),\n    vec2(4.336055, -4.073915), vec2(3.9879673, -4.073915)\n);\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x * b.y - a.y * b.x; }\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float k = 1.0 / dot(b, b);\n    float p = k * dot(a, b);\n    float q = k * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float r = k * dot(d, a);\n\n    float h = q * q / 4.0 - p * r;\n\n    float z = sqrt(max(0.0, q * q / 4.0 - h));\n    float x = sqrt(max(0.0, h + z * z));\n    float y = sqrt(max(0.0, h - z * z));\n\n    float s = sign(p * r - q * q / 2.0);\n\n    float t0 = -(2.0 * x + p + s * (2.0 * y - p)) / (2.0 * (p + 2.0 * x));\n    float t1 = -(2.0 * x - p + s * (2.0 * y + p)) / (2.0 * (-p + 2.0 * x));\n\n    float t = 0.0;\n    if (t0 >= 0.0 && t0 <= 1.0) {\n        t = t0;\n    } else if (t1 >= 0.0 && t1 <= 1.0) {\n        t = t1;\n    }\n\n    vec2 P = A + t * (2.0 * B - 2.0 * A) + t * t * (A - 2.0 * B + C);\n    vec2 Q = pos - P;\n\n    return length(Q);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 e = b - a;\n    vec2 w = p - a;\n\n    // winding number from http://geomalgorithms.com/a03-_inclusion.html\n    bvec3 cond = bvec3(p.y >= a.y, \n                       p.y < b.y, \n                       e.x*w.y > e.y*w.x);\n    if( all(cond) || all(not(cond))) {\n        return -1.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat winding_angle(in vec2 p, in vec2 a, in vec2 b) {\n    float pa = dot2(a - p);\n    float pb = dot2(b - p);\n    float ab = dot2(a - b);\n    float ang = acos((pa + pb - ab) / (2.0 * sqrt(pa * pb)));\n    return sign(cro(a - p, b - p)) * ang;\n}\n\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p = (p + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m = (m + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n\n    float d = 1e10;\n    float winding = 1.0;\n    for (int i=0; i < QUAD_COUNT; i++) {\n        vec2 v0 = QUADS[i * 3];\n        vec2 v1 = QUADS[i * 3 + 1];\n        vec2 v2 = QUADS[i * 3 + 2];\n\n        float sd = sdBezier(p, v0, v1, v2);\n        d = min(d, abs(sd));\n\n        if (sd > 0.0 == cro(v1 - v2, v1 - v0) < 0.0) {\n            winding *= winding_sign(p, v0, v1);\n            winding *= winding_sign(p, v1, v2);\n        } else {\n            winding *= winding_sign(p, v0, v2);\n        }\n    }\n    for (int i=0; i < LINE_COUNT; i++) {\n        vec2 v0 = LINES[i * 2];\n        vec2 v1 = LINES[i * 2 + 1];\n        d = min(d, udSegment(p, v0, v1));\n        winding *= winding_sign(p, v0, v1);\n    }\n\n    d *= winding;\n\n    // Apply a color based on signed distance\n    vec3 col = vec3(1.0) - vec3(0.1, 0.4, 0.7) * sign(d);\n    col *= 1.0 - exp(-4.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(60.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Draw the mouse stuff\n    if(iMouse.z > 0.001) {\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, abs(sdBezier(m, v0, v1, v2)));\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, udSegment(m, v0, v1));\n        }\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.01));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.05));\n    }\n\n    { // Draw the skeleton of the Bezier curves\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, min(udSegment(p, v0, v1), udSegment(p, v1, v2)));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n            d = min(d, length(p - v2) - 0.05);\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, udSegment(p, v0, v1));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n        }\n        col = mix(col, vec3(1, 0, 0), 1.0 - smoothstep(0.0, 0.014, d));\n    }\n\n    fragColor = vec4(col, 1.0);\n}"], ["// Using distance-to-quadratic and winding number to generate a closed-form\n// distance field of a font outline, which is specified as lines + quadratic\n// B\u00e9zier curves.\n//\n// Quadratic solver is based on https://www.shadertoy.com/view/MlKcDD, which\n// includes the following copyright notice:\n//\n//      Copyright \u00a9 2018 Inigo Quilez\n//      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Curves are baked by an external tool\n#define QUAD_COUNT 38\nconst vec2 QUADS[QUAD_COUNT * 3] = vec2[QUAD_COUNT * 3](\n    vec2(0.5758487, -4.5724106), vec2(0.5758487, -4.9204984), vec2(0.7176622, -5.221315),\n    vec2(0.7176622, -5.221315), vec2(0.8594757, -5.5221314), vec2(1.1216158, -5.758487),\n    vec2(0.7520412, -2.0842285), vec2(0.8594757, -1.6974645), vec2(1.0034379, -1.3859046),\n    vec2(0.86162436, -3.5904598), vec2(0.5758487, -3.9664803), vec2(0.5758487, -4.5724106),\n    vec2(1.0034379, -1.3859046), vec2(1.1474, -1.0743446), vec2(1.3837559, -0.8036098),\n    vec2(1.1216158, -5.758487), vec2(1.3708637, -5.9819508), vec2(1.7103566, -6.1087236),\n    vec2(1.3794585, -4.9591746), vec2(1.3794585, -4.563816), vec2(1.5642458, -4.3038244),\n    vec2(1.3837559, -0.8036098), vec2(1.6072196, -0.55006444), vec2(1.9058874, -0.3996562),\n    vec2(1.5642458, -4.3038244), vec2(1.7490331, -4.0438333), vec2(2.101418, -3.8762355),\n    vec2(1.6630855, -2.9823806), vec2(1.1474, -3.2144392), vec2(0.86162436, -3.5904598),\n    vec2(1.6673828, -5.599484), vec2(1.3794585, -5.337344), vec2(1.3794585, -4.9591746),\n    vec2(1.6974645, -0.0021486892), vec2(1.2892135, -0.12892136), vec2(0.99269444, -0.30941126),\n    vec2(1.7103566, -6.1087236), vec2(2.0498495, -6.235496), vec2(2.419424, -6.235496),\n    vec2(1.9058874, -0.3996562), vec2(2.2045553, -0.24924795), vec2(2.599914, -0.24924795),\n    vec2(2.101418, -3.8762355), vec2(2.4151268, -3.7258272), vec2(2.718092, -3.616244),\n    vec2(2.2862053, -2.7266867), vec2(1.9252255, -2.862054), vec2(1.6630855, -2.9823806),\n    vec2(2.363558, -5.8616242), vec2(1.9553072, -5.8616242), vec2(1.6673828, -5.599484),\n    vec2(2.419424, -6.235496), vec2(2.840567, -6.235496), vec2(3.173614, -6.106575),\n    vec2(2.5139663, 0.12462398), vec2(2.1057155, 0.12462398), vec2(1.6974645, -0.0021486892),\n    vec2(2.599914, -0.24924795), vec2(2.896433, -0.24924795), vec2(3.117748, -0.32660076),\n    vec2(2.718092, -3.616244), vec2(3.0210571, -3.506661), vec2(3.3046842, -3.382037),\n    vec2(2.9265146, -2.4795873), vec2(2.647185, -2.5913193), vec2(2.2862053, -2.7266867),\n    vec2(3.0167596, -5.7133646), vec2(2.7503223, -5.8616242), vec2(2.363558, -5.8616242),\n    vec2(3.117748, -0.32660076), vec2(3.3390632, -0.40395358), vec2(3.4765792, -0.54576707),\n    vec2(3.173614, -6.106575), vec2(3.506661, -5.9776535), vec2(3.781693, -5.8057585),\n    vec2(3.3046842, -3.382037), vec2(3.5625267, -3.270305), vec2(3.8010314, -3.1284916),\n    vec2(3.4679844, -5.315857), vec2(3.2831972, -5.565105), vec2(3.0167596, -5.7133646),\n    vec2(3.4765792, -0.54576707), vec2(3.6140952, -0.6875806), vec2(3.6807046, -0.8788139),\n    vec2(3.54104, -2.0004296), vec2(3.3347657, -2.316287), vec2(2.9265146, -2.4795873),\n    vec2(3.6807046, -0.8788139), vec2(3.747314, -1.0700473), vec2(3.747314, -1.3192952),\n    vec2(3.747314, -1.3192952), vec2(3.747314, -1.6845723), vec2(3.54104, -2.0004296),\n    vec2(3.775247, -4.7400084), vec2(3.657069, -5.0580144), vec2(3.4679844, -5.315857),\n    vec2(3.8010314, -3.1284916), vec2(4.039536, -2.9866781), vec2(4.2157283, -2.7975934),\n    vec2(3.9879673, -4.073915), vec2(3.893425, -4.4220023), vec2(3.775247, -4.7400084),\n    vec2(3.996562, -0.3996562), vec2(3.3992264, 0.12462398), vec2(2.5139663, 0.12462398),\n    vec2(4.2157283, -2.7975934), vec2(4.4091105, -2.5827246), vec2(4.501504, -2.3270304),\n    vec2(4.501504, -2.3270304), vec2(4.593898, -2.0713365), vec2(4.593898, -1.7318435),\n    vec2(4.593898, -1.7318435), vec2(4.593898, -0.92393637), vec2(3.996562, -0.3996562)\n);\n\n#define LINE_COUNT 8\nconst vec2 LINES[LINE_COUNT * 2] = vec2[LINE_COUNT * 2](\n    vec2(0.40395358, -2.0842285), vec2(0.7520412, -2.0842285),\n    vec2(0.46411687, 0.0042973785), vec2(0.40395358, -2.0842285),\n    vec2(0.80790716, 0.0042973785), vec2(0.46411687, 0.0042973785),\n    vec2(0.99269444, -0.30941126), vec2(0.80790716, 0.0042973785),\n    vec2(3.781693, -5.8057585), vec2(3.9578855, -6.09798),\n    vec2(3.9578855, -6.09798), vec2(4.301676, -6.09798),\n    vec2(4.301676, -6.09798), vec2(4.336055, -4.073915),\n    vec2(4.336055, -4.073915), vec2(3.9879673, -4.073915)\n);\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x * b.y - a.y * b.x; }\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    if(h >= 0.0) { // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        // When p\u22480 and p<0, h - q has catastrophic cancelation. So, we do\n        // h=\u221a(q\u00b2 + 4p\u00b3)=q\u00b7\u221a(1 + 4p\u00b3/q\u00b2)=q\u00b7\u221a(1 + w) instead. Now we approximate\n        // \u221a by a linear Taylor expansion into h\u2248q(1 + \u00bdw) so that the q's\n        // cancel each other in h - q. Expanding and simplifying further we\n        // get x=vec2(p\u00b3/q, -p\u00b3/q - q). And using a second degree Taylor\n        // expansion instead: x=vec2(k, -k - q) with k=(1 - p\u00b3/q\u00b2)\u00b7p\u00b3/q\n        if(abs(abs(h/q) - 1.0) < 0.0001) {\n            float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n            x = vec2(k, -k - q);\n        }\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2  q = d + (c + b * t) * t;\n        res = dot2(q);\n        sgn = cro(c + 2.0 * b * t, q);\n    } else { // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2  qx=d + (c + b * t.x) * t.x;\n        float dx = dot2(qx), sx = cro(c + 2.0 * b * t.x, qx);\n        vec2  qy=d + (c + b * t.y) * t.y;\n        float dy = dot2(qy);\n        float sy = cro(c + 2.0 * b * t.y, qy);\n        if (dx<dy) {\n            res=dx;\n            sgn=sx;\n        } else {\n            res=dy;\n            sgn=sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    return sign(cross(a - p, b - p));\n}\n\nfloat winding_angle(in vec2 p, in vec2 a, in vec2 b) {\n    float pa = dot2(a - p);\n    float pb = dot2(b - p);\n    float ab = dot2(a - b);\n    float ang = acos((pa + pb - ab) / (2.0 * sqrt(pa * pb)));\n    return sign(cro(a - p, b - p)) * ang;\n}\n\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p = (p + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m = (m + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n\n    float d = 1e10;\n    float winding = 1.0;\n    for (int i=0; i < QUAD_COUNT; i++) {\n        vec2 v0 = QUADS[i * 3];\n        vec2 v1 = QUADS[i * 3 + 1];\n        vec2 v2 = QUADS[i * 3 + 2];\n\n        float sd = sdBezier(p, v0, v1, v2);\n        d = min(d, abs(sd));\n\n        if (sd > 0.0 == cro(v1 - v2, v1 - v0) < 0.0) {\n            winding *= winding_sign(p, v0, v1);\n            winding *= winding_sign(p, v1, v2);\n        } else {\n            winding *= winding_sign(p, v0, v2);\n        }\n    }\n    for (int i=0; i < LINE_COUNT; i++) {\n        vec2 v0 = LINES[i * 2];\n        vec2 v1 = LINES[i * 2 + 1];\n        d = min(d, udSegment(p, v0, v1));\n        winding *= winding_sign(p, v0, v1);\n    }\n\n    d *= winding;\n\n    // Apply a color based on signed distance\n    vec3 col = vec3(1.0) - vec3(0.1, 0.4, 0.7) * sign(d);\n    col *= 1.0 - exp(-4.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(60.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Draw the mouse stuff\n    if(iMouse.z > 0.001) {\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, abs(sdBezier(m, v0, v1, v2)));\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, udSegment(m, v0, v1));\n        }\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.01));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.05));\n    }\n\n    { // Draw the skeleton of the Bezier curves\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, min(udSegment(p, v0, v1), udSegment(p, v1, v2)));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n            d = min(d, length(p - v2) - 0.05);\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, udSegment(p, v0, v1));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n        }\n        col = mix(col, vec3(1, 0, 0), 1.0 - smoothstep(0.0, 0.014, d));\n    }\n\n    fragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray and a wedge.\n//\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and https://iquilezles.org/articles/intersectors\n\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*s;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec4( -1.0 );\n    vec3  iu = vec3( t1.y<0.0, t1.z<0.0, t1.x<0.0 );\n    vec3 id = vec3( t2.y<0.0, t2.z<0.0, t2.x<0.0 );\n    vec3  is = vec3(iu.y*iu.z,iu.x*iu.z,iu.x*iu.y);\n    vec3  id2 = vec3(id.y*id.z,id.x*id.z,id.x*id.y);\n    vec3  ns = vec3(iu.y*id.z,iu.x*id.z,iu.x*id.y);\n    vec3  nd = vec3(id.y*iu.z,id.x*iu.z,id.x*iu.y);\n    vec3  n2 = vec3(iu.y*id.z,iu.x*id.z,iu.x*id.y);\n    vec3  n3 = vec3(id.y*iu.z,id.x*iu.z,id.x*iu.y);\n    vec3  n4 = vec3(iu.y*id.// incomplete generation!\n\nvec3 pattern( in vec2 uv )\n{\n    return vec3(0.6 + 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)))\n           *smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 1.0*sin(an), 0.4*sin(1.6*an), 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, 0.01, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // wedge\n    const vec3 siz = vec3(0.5,0.2,0.4);\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // ray direction\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // background\n\t    vec3 col = vec3(0.08+0.02*rd.y)*(1.0-0.3*length(p));\n\n        // wedge\n        vec4 tnor = iWedge( ro, rd, siz );\n        if( tnor.x>0.0 )\n        {\n            float t = tnor.x;\n            vec3  pos = ro + t*rd;\n            vec3  nor = tnor.yzw;\n\n            // texture\n            vec3 mor = abs(nor);\n            vec2 uv = (mor.x>mor.y && mor.x>mor.z) ? pos.yz : \n                      (mor.y>mor.z)                ? pos.zx : \n                                                     pos.xy;\n            col = pattern( 47.0*uv );\n\n            // lighting\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.6 + 0.4*nor.y, 0.0, 1.0 );\n            col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        // gamma\n        col = sqrt( col );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,17,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    fragColor = vec4( tot, 1.0 );\n}"], ["/*\n\n24-bit fixed * 12-mantissa-bit multiply\nhttps://www.shadertoy.com/view/ctf3z8\n\nMultiply 24-bit signed integer by float using 12 bits of mantissa into\nwhole part and fract part without loss of precision over the integer argument's\nrange.\nClick left/right to compare one at a time.\n\nCopyright 2022 Theron Tarigo.  All rights reserved.\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.\n\n*/\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x) {\n    float a_f = (float)a;\n    float a_f_abs = abs(a_f);\n    float a_f_abs_24 = a_f_abs - (a_f_abs / 256.0f) * 256.0f;\n    float a_f_abs_24_2 = a_f_abs_24 * 2.0f;\n    float a_f_abs_24_2_2 = a_f_abs_24_2 * 2.0f;\n    float a_f_abs_24_2_2_2 = a_f_abs_24_2_2 * 2.0f;\n    float a_f_abs_24_2_2_2_2 = a_f_abs_24_2_2_2 * 2.0f;\n    float a_f_abs_24_2_2_2_2_2 = a_f_abs_24_2_2_2_2 * 2.0f;\n    float a_f_abs_24_2_2_2_2_2_2 = a_f_abs_24_2_2_2_2_2 * 2.0f;\n    float a_f_abs_24_2_2_2_2_2_2_2 = a_f_abs_24_2_2_2_2_2_2 * 2.0f;\n    float a_f_abs_24_2_2_2_2_2_2_2_2 = a_f_abs_24_2_2_2_2_2_2_2// incomplete generation!\n\nvoid mainImage (out vec4 O, vec2 f) {\n  vec2 uv = f/iResolution.xy;\n  float yplt=fract(uv.y*2.);\n  int i=int(floor(uv.x*160.))+0x1000000; // index\n  float b=intBitsToFloat(0x3da3d000); // frequency = 7.9986572e-02\n  float x=.2; // phase shift\n  \n  float Af,Bf;\n  int Ai,Bi;\n  \n  // mad f32 result (imprecise)\n  Af=fract(float(i)*b+x);\n  Ai=int(floor(float(i)*b+x));\n  \n  // frac_mad_i24_m12_f32 result\n  Bf=frac_mad_i24_m12_f32(Bi,i,b,x);\n  \n  vec3 col=vec3(0.);\n  if(uv.y>.5){\n    col.r=float(yplt<Af);\n    col.g=float(yplt<Bf);\n  }\n  else{\n    int shift=1341950;\n    int range=20;\n    col.r=float(yplt<float(Ai-shift)/float(range));\n    col.g=float(yplt<float(Bi-shift)/float(range));\n  }\n  if(iMouse.z>0.){\n    float m=iMouse.x/iResolution.x;\n    if(m<.5)col=vec3(col.r);\n    else col=vec3(col.g);\n  }\n  \n  // sRGB output https://www.shadertoy.com/view/sl3cRs\n  {vec3 c=col;O.rgb=min(12.9*c,abs(1.054*pow(c,c-c+.4166)-.095)+.04);}\n}\n\n/*\nCopyright 2022 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient of the quadratic smooth minimum.\n// (https://iquilezles.org/articles/smin)\n//\n// Please note that the smooth-minimum is not a SDF preserving\n// operator. It's a good approximation when far enough from the\n// surfaces, but quickly distorts near them. However, the gradient\n// stays smaller than 1, which explains why it does NOT break\n// raymarchers, but just slows them down.\n//\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n{\n    vec3 h = max(k-abs(a),0.0);\n    return min(a,b) - h*(h.x+h.y+h.z)/3.0;\n}\n\n// .x = f(p)\n// .y = \u2202f(p)/\u2202x\n// .z = \u2202f(p)/\u2202y\n// .yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgMin( in vec3 a, in vec3 b )\n{\n    return (a.x<b.x) ? a : b;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l   : g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d,q/d);\n}\n\nvec3 map(vec2 p)\n{\n    // sdf(p) and gradient(sdf(p))\n    vec3 dg1 = sdgBox(p,vec2(0.8,0.3));\n    vec3 dg2 = sdgSegment( p, vec2(-1.0,-0.5), vec2(0.7,0.7) ) - vec3(0.15,0.0,0.0);\n    \n    return sdgSMin(dg1,dg2,0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // sdf(p) and gradient(sdf(p))\n\n  //vec3 dg = sdgMin(dg1,dg2);\n    vec3 dg = map(p);\n    float d = dg.x;\n    vec2  g = dg.yz;\n    \n    // central differenes based gradient, for validation\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    if( iMouse.z>0.001 )\n    {\n        d = map(m).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Analytical distance to an 2D ellipse, which is more\n// complicated than it seems. It ends up being a quartic\n// equation, which can be resolved through a cubic, then\n// a quadratic. Some steps through the derivation can be\n// found in this article: \n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\n\n\n\n\n\n// MIT License\n// Copyright \u00a9 2023 Paul Soulanille\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat cbrt(in float x) {\n    return sign(x)*pow(abs(x),1.0/3.0);\n}\nfloat quart(in float x) {\n    x *= x;\n    return x*x;\n}\n\n// Hyperbola \n//  \n// y=1/t       |\n// x=t         \\__\n// rotate 45\u00b0  (we do this to be able to change the open angle via x and y scaling)\n// x = t-1/t     \\_/\n// y = t+1/t\n// has min Y at 2 and focus at 2\u221a2\n//     \n//  z,w s.t. |(x,y)-(z,w)| is min\n//       https://www.wolframalpha.com/input?i=d%2Fdt+%28%28a*%28t-1%2Ft%29-z%29%5E2%2B%28b*%28t%2B1%2Ft%29-w%29%5E2+%29+\n//  (2 a^2 t^4 - 2 a^2 - 2 a t^3 z - 2 a t z + 2 b^2 t^4 - 2 b^2 - 2 b t^3 w + 2 b t w)/t^3 = 0\n//  t^4 : 2 a^2 + 2 b^2 \n//  t^3 : - 2 a z - 2 b w\n//  t^2 : 0\n//  t   : - 2 a z + 2 b w\n//  1   : - 2 a^2 - 2 b^2\n// using: https://en.wikipedia.org/wiki/Quartic_equation#Summary_of_Ferrari's_method\n// let r^2 = a^2 + b^2\n// coeffs (A\u2026E): 2r^2, -2(ab\u2022zw), 0, -2((a,b)\u2022(z,-w)), -2r^2\n//  \u03b1 = -3/8 (B/A)^2 + C/A\n//  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n//  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n// \n// when \u03b2 = 0\n//  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n// else\n//  P = - \u03b1^2/12 - \u03b3\n//  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n//  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n//  U = \u221bR\n//\n//  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n//  W = \u221a(\u03b1 + 2d)\n//  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n//\n//\n\n\n// currently suffers from precision loss in some areas\n//  which can be shown by uncommenting \"col = p.x<m.x?ploss: col;\" in mainImage\n//\nvec2 pHyperbola( vec2 p, in vec2 ab){\n    \n    //vec2 s1 = pHyperbola_sols(p,ab,1.0,1.0);\n    //vec2 s2 = pHyperbola_sols(p,ab,-1.0,1.0);\n    //vec2 s3 = pHyperbola_sols(p,ab,-1.0,-1.0);\n    //vec2 s4 = pHyperbola_sols(p,ab,1.0,-1.0);\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2;\n    //s2 = (length(s3-p)<length(s4-p))?s3:s4;\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2; \n    //return s1;\n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //          = (-3/256 boa^3 - 1/4 doa)*boa - 1\n    //          _     \u239baz+bw\u239e4   \u239baz+bw\u239e\u239baz-bw\u239e\n    //          \u00af  -3 \u239d\u00af4\u00afr2\u23a0  - \u239d\u00af4\u00afr2\u23a0\u239d\u00afr2\u00af\u00af\u23a0 - 1\n    //          = \n    //          -(3 x^4)/(256 d^4) - (3 x^3 y)/(64 d^4) - (9 x^2 y^2)/(128 d^4) - (3 x y^3)/(64 d^4) - (3 y^4)/(256 d^4) - x^2/(4 d^2) + y^2/(4 d^2) - 1\n    //float gamma = -3.0/256.0 * quart(az / r2) - 3.0*(az\n    \n    \n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    //float P = - alpha2 / 12.0 - gamma;\n    //  P = - (3/8 * boa2)^2/12 - (-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0);\n    //    = - 3/256 boa^4 + 3.0/256.0 * (boa2*boa2) + 0.25 * boa*doa + 1.0;\n    //    = 0.25 * boa*doa + 1.0;\n    float P = 0.25 * boa*doa + 1.0;\n    \n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //                     ^^^ lowers cancellation error\n    \n    \n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float dp56a = (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    float d = -5.0/6.0 * alpha + dp56a;\n    //  W = \u221a(\u03b1 + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //  W = \u221a(\u03b1 + -5/3 \u03b1 + (U==0? -2\u221bQ : 2U - 2P/(3U))\n    //    = \u221a(-2/3 \u03b1 + )\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * dp56a));\n    //  W = \u221a(-2/3 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    // case U==0\n    //  W = \u221a(-2/3 \u03b1 -\u221bQ)\n    //    = \u221a(-2/3 \u03b1 -\u221b(- \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8))\n    // case U!=0\n    //  W = \u221a(-2/3 \u03b1 + U + (\u03b1^2/12 + \u03b3)/(3U))\n    //    = \u221a(-2/3 \u03b1 + U - P/(3U))\n    //  W = \u221a(-2/3 \u03b1 + \u221bR - P/(3\u221bR))\n    \n    \n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    //float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //        3\u03b1 + 2d = 3\u03b1 + 2(-5/6 \u03b1  + dp56a)\n    //                = (3-5/3) \u03b1  + 2 dp56a\n    //                =  4/3 \u03b1  + 2 dp56a\n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + 2.0*beta/W)));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + -2.0*beta/W)));\n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    return (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return (p.x*p.x - p.y*p.y) - (ab.x*ab.x - ab.y*ab.y);\n}\n\n\n//precision loss testing\nfloat add_ploss(in float a, in float b){\n    return -log2(abs(a+b)/(abs(a)+abs(b)))/24.0;\n}\nvec3 pHyperbola_loss( vec2 p, in vec2 ab)\n{\n    \n                                                                                                  \n    float loss1 = 0.0;\n    float loss2 = 0.0;\n    float loss3 = 0.0;\n    \n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //loss3 = add_ploss(0.125 * boa2*boa, doa);\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) ,- 0.25 * boa*doa-1.0);\n    loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa,-1.0);\n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    float P = - alpha2 / 12.0 - gamma;\n    loss1 = add_ploss(alpha2 / 12.0,gamma);\n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //loss3 = add_ploss(alpha2 / 108.0, - gamma/3.0);\n    //loss3 = add_ploss(- alpha*(alpha2 / 108.0 - gamma/3.0),- beta*beta / 8.0); \n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //loss3 = add_ploss(Q*Q*0.25,P*P*P/27.0);\n    //loss3 = add_ploss(- Q * 0.5,sqrt(abs(Q*Q*0.25 + P*P*P/27.0))); //lines up with P in upper half, fixed\n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    //loss3 = add_ploss(-5.0/6.0 * alpha, (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))); //not here\n    //loss3 = add_ploss(U, - P/(3.0*U));// not here\n    //  W = \u221a(\u03b1 + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //loss2 = add_ploss(alpha,2.0*d);\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))));\n    loss2 = add_ploss(-2.0/3.0 * alpha,2.0*(abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U)));\n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    //  W = \u221a(-2/3 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    // case U==0\n    //  W = \u221a(-2/3 \u03b1 -\u221bQ)\n    //    = \u221a(-2/3 \u03b1 -\u221b(- \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8))\n    // case U!=0\n    //  W = \u221a(-2/3 \u03b1 + U + (\u03b1^2/12 + \u03b3)/(3U))\n    //    = \u221a(-2/3 \u03b1 + U - P/(3U))\n    //  W = \u221a(-2/3 \u03b1 + \u221bR - P/(3\u221bR))\n    //loss3 = add_ploss(-2.0/3.0 *alpha, + U);\n    \n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(W+sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W))));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(-W+sqrt(abs(3.0*alpha + 2.0*d - 2.0*beta/W))));\n    \n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    vec2 result = (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n    \n    return vec3(loss1,loss2,loss3);\n    \n}\n\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    float t = 0.0;\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*p.x;\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float C = 0.0;\n    float D = -2.0*(az-bw);\n    float E = -2.0*r2;\n    \n    \n    float boa = B/A;\n    float coa = C/A;\n    float doa = D/A;\n    float eoa = E/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2 + coa;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa - 0.5*boa*coa + doa;\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) + 0.0625 * coa*boa2 - 0.25 * boa*doa + eoa;\n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    float P = - alpha2 / 12.0 - gamma;\n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (U==0.0? -cbrt(Q) : U - P/(3.0*U));\n    //  W = \u221a(\u03b1 + 2d)\n    float W = sqrt(alpha + 2.0 * d);\n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    t = -boa*0.25 + 0.5 * (s1*W + s2*sqrt(abs(3.0*alpha + 2.0*d + s1*2.0*beta/W)));\n    \n    float recip_t = 1.0/t;\n    return vec2(t-recip_t,t+recip_t)*ab;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 ra = (vec2(0.25,0.25) + 0.25*cos(iTime*vec2(1.1,1.3)+vec2(1.0,1.0) ))*0.25*(1.0625-sin(iTime));\n\t\n \tvec2 pd = pHyperbola( p, ra);\n    float d = length(pd-p)*inside_Hyperbola(p,ra);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    vec3 ploss = pHyperbola_loss(p,ra);\n    //uncomment the next line to see a map of floating point precision loss on the solution\n    col = p.x<m.x?ploss: col;\n    \n    \n    if( iMouse.z>0.001 )\n    {\n    pd = pHyperbola(m, ra);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0030));\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.030));\n    \n    pd = pHyperbola_sols(m, ra,1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.025));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0020));\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.020));\n    \n    pd = pHyperbola_sols(m, ra,1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0015));\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.015));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0010));\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.010));\n    \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4( col, 1.0 );;\n}"], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Analytical distance to an 2D ellipse, which is more\n// complicated than it seems. It ends up being a quartic\n// equation, which can be resolved through a cubic, then\n// a quadratic. Some steps through the derivation can be\n// found in this article: \n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\n\n\n\n\n\n// MIT License\n// Copyright \u00a9 2023 Paul Soulanille\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat cbrt(in float x) {\n    return sign(x)*pow(abs(x),1.0/3.0);\n}\nfloat quart(in float x) {\n    x *= x;\n    return x*x;\n}\n\n// Hyperbola \n//  \n// y=1/t       |\n// x=t         \\__\n// rotate 45\u00b0  (we do this to be able to change the open angle via x and y scaling)\n// x = t-1/t     \\_/\n// y = t+1/t\n// has min Y at 2 and focus at 2\u221a2\n//     \n//  z,w s.t. |(x,y)-(z,w)| is min\n//       https://www.wolframalpha.com/input?i=d%2Fdt+%28%28a*%28t-1%2Ft%29-z%29%5E2%2B%28b*%28t%2B1%2Ft%29-w%29%5E2+%29+\n//  (2 a^2 t^4 - 2 a^2 - 2 a t^3 z - 2 a t z + 2 b^2 t^4 - 2 b^2 - 2 b t^3 w + 2 b t w)/t^3 = 0\n//  t^4 : 2 a^2 + 2 b^2 \n//  t^3 : - 2 a z - 2 b w\n//  t^2 : 0\n//  t   : - 2 a z + 2 b w\n//  1   : - 2 a^2 - 2 b^2\n// using: https://en.wikipedia.org/wiki/Quartic_equation#Summary_of_Ferrari's_method\n// let r^2 = a^2 + b^2\n// coeffs (A\u2026E): 2r^2, -2(ab\u2022zw), 0, -2((a,b)\u2022(z,-w)), -2r^2\n//  \u03b1 = -3/8 (B/A)^2 + C/A\n//  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n//  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n// \n// when \u03b2 = 0\n//  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n// else\n//  P = - \u03b1^2/12 - \u03b3\n//  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n//  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n//  U = \u221bR\n//\n//  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n//  W = \u221a(\u03b1 + 2d)\n//  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n//\n//\n\n\n// currently suffers from precision loss in some areas\n//  which can be shown by uncommenting \"col = p.x<m.x?ploss: col;\" in mainImage\n//\nvec2 pHyperbola( vec2 p, in vec2 ab){\n    \n    //vec2 s1 = pHyperbola_sols(p,ab,1.0,1.0);\n    //vec2 s2 = pHyperbola_sols(p,ab,-1.0,1.0);\n    //vec2 s3 = pHyperbola_sols(p,ab,-1.0,-1.0);\n    //vec2 s4 = pHyperbola_sols(p,ab,1.0,-1.0);\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2;\n    //s2 = (length(s3-p)<length(s4-p))?s3:s4;\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2; \n    //return s1;\n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //          = (-3/256 boa^3 - 1/4 doa)*boa - 1\n    //          _     \u239baz+bw\u239e4   \u239baz+bw\u239e\u239baz-bw\u239e\n    //          \u00af  -3 \u239d\u00af4\u00afr2\u23a0  - \u239d\u00af4\u00afr2\u23a0\u239d\u00afr2\u00af\u00af\u23a0 - 1\n    //          = \n    //          -(3 x^4)/(256 d^4) - (3 x^3 y)/(64 d^4) - (9 x^2 y^2)/(128 d^4) - (3 x y^3)/(64 d^4) - (3 y^4)/(256 d^4) - x^2/(4 d^2) + y^2/(4 d^2) - 1\n    //float gamma = -3.0/256.0 * quart(az / r2) - 3.0*(az\n    \n    \n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    //float P = - alpha2 / 12.0 - gamma;\n    //  P = - (3/8 * boa2)^2/12 - (-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0);\n    //    = - 3/256 boa^4 + 3.0/256.0 * (boa2*boa2) + 0.25 * boa*doa + 1.0;\n    //    = 0.25 * boa*doa + 1.0;\n    float P = 0.25 * boa*doa + 1.0;\n    \n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //                     ^^^ lowers cancellation error\n    \n    \n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float dp56a = (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    float d = -5.0/6.0 * alpha + dp56a;\n    //  W = \u221a(\u03b1 + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //  W = \u221a(\u03b1 + -5/3 \u03b1 + (U==0? -2\u221bQ : 2U - 2P/(3U))\n    //    = \u221a(-2/3 \u03b1 + )\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * dp56a));\n    //  W = \u221a(-2/3 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    // case U==0\n    //  W = \u221a(-2/3 \u03b1 -\u221bQ)\n    //    = \u221a(-2/3 \u03b1 -\u221b(- \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8))\n    // case U!=0\n    //  W = \u221a(-2/3 \u03b1 + U + (\u03b1^2/12 + \u03b3)/(3U))\n    //    = \u221a(-2/3 \u03b1 + U - P/(3U))\n    //  W = \u221a(-2/3 \u03b1 + \u221bR - P/(3\u221bR))\n    \n    \n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    //float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //        3\u03b1 + 2d = 3\u03b1 + 2(-5/6 \u03b1  + dp56a)\n    //                = (3-5/3) \u03b1  + 2 dp56a\n    //                =  4/3 \u03b1  + 2 dp56a\n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + 2.0*beta/W)));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + -2.0*beta/W)));\n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    return (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    float sqrt2 = sqrt(2.0);//foci are at (0,\u00b1\u221a2)\n    p /= ab;\n    p /= 2.0;\n    return sign(length(p-vec2(0,sqrt2))-length(p-vec2(0,-sqrt2))+2.0);\n}\n\n\n//precision loss testing\nfloat add_ploss(in float a, in float b){\n    return a + b;\n}\nvec3 pHyperbola_loss( vec2 p, in vec2 ab)\n{\n    \n                                                                                                  \n    float loss1 = 0.0;\n    float loss2 = 0.0;\n    float loss3 = 0.0;\n    \n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //loss3 = add_ploss(0.125 * boa2*boa, doa);\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) ,- 0.25 * boa*doa-1.0);\n    loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa,-1.0);\n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    float P = - alpha2 / 12.0 - gamma;\n    loss1 = add_ploss(alpha2 / 12.0,gamma);\n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //loss3 = add_ploss(alpha2 / 108.0, - gamma/3.0);\n    //loss3 = add_ploss(- alpha*(alpha2 / 108.0 - gamma/3.0),- beta*beta / 8.0); \n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //loss3 = add_ploss(Q*Q*0.25,P*P*P/27.0);\n    //loss3 = add_ploss(- Q * 0.5,sqrt(abs(Q*Q*0.25 + P*P*P/27.0))); //lines up with P in upper half, fixed\n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    //loss3 = add_ploss(-5.0/6.0 * alpha, (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))); //not here\n    //loss3 = add_ploss(U, - P/(3.0*U));// not here\n    //  W = \u221a(\u03b1 + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //loss2 = add_ploss(alpha,2.0*d);\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))));\n    loss2 = add_ploss(-2.0/3.0 * alpha,2.0*(abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U)));\n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    //  W = \u221a(-2/3 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    // case U==0\n    //  W = \u221a(-2/3 \u03b1 -\u221bQ)\n    //    = \u221a(-2/3 \u03b1 -\u221b(- \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8))\n    // case U!=0\n    //  W = \u221a(-2/3 \u03b1 + U + (\u03b1^2/12 + \u03b3)/(3U))\n    //    = \u221a(-2/3 \u03b1 + U - P/(3U))\n    //  W = \u221a(-2/3 \u03b1 + \u221bR - P/(3\u221bR))\n    //loss3 = add_ploss(-2.0/3.0 *alpha, + U);\n    \n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(W+sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W))));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(-W+sqrt(abs(3.0*alpha + 2.0*d - 2.0*beta/W))));\n    \n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    vec2 result = (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n    \n    return vec3(loss1,loss2,loss3);\n    \n}\n\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    float t = 0.0;\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*p.x;\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float C = 0.0;\n    float D = -2.0*(az-bw);\n    float E = -2.0*r2;\n    \n    \n    float boa = B/A;\n    float coa = C/A;\n    float doa = D/A;\n    float eoa = E/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2 + coa;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa - 0.5*boa*coa + doa;\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) + 0.0625 * coa*boa2 - 0.25 * boa*doa + eoa;\n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    float P = - alpha2 / 12.0 - gamma;\n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (U==0.0? -cbrt(Q) : U - P/(3.0*U));\n    //  W = \u221a(\u03b1 + 2d)\n    float W = sqrt(alpha + 2.0 * d);\n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    t = -boa*0.25 + 0.5 * (s1*W + s2*sqrt(abs(3.0*alpha + 2.0*d + s1*2.0*beta/W)));\n    \n    float recip_t = 1.0/t;\n    return vec2(t-recip_t,t+recip_t)*ab;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 ra = (vec2(0.25,0.25) + 0.25*cos(iTime*vec2(1.1,1.3)+vec2(1.0,1.0) ))*0.25*(1.0625-sin(iTime));\n\t\n \tvec2 pd = pHyperbola( p, ra);\n    float d = length(pd-p)*inside_Hyperbola(p,ra);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    vec3 ploss = pHyperbola_loss(p,ra);\n    //uncomment the next line to see a map of floating point precision loss on the solution\n    col = p.x<m.x?ploss: col;\n    \n    \n    if( iMouse.z>0.001 )\n    {\n    pd = pHyperbola(m, ra);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0030));\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.030));\n    \n    pd = pHyperbola_sols(m, ra,1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.025));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0020));\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.020));\n    \n    pd = pHyperbola_sols(m, ra,1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0015));\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.015));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0010));\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.010));\n    \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4( col, 1.0 );;\n}"], ["// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Analytical distance to an 2D ellipse, which is more\n// complicated than it seems. It ends up being a quartic\n// equation, which can be resolved through a cubic, then\n// a quadratic. Some steps through the derivation can be\n// found in this article: \n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\n\n\n\n\n\n// MIT License\n// Copyright \u00a9 2023 Paul Soulanille\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat cbrt(in float x) {\n    return sign(x)*pow(abs(x),1.0/3.0);\n}\nfloat quart(in float x) {\n    x *= x;\n    return x*x;\n}\n\n// Hyperbola \n//  \n// y=1/t       |\n// x=t         \\__\n// rotate 45\u00b0  (we do this to be able to change the open angle via x and y scaling)\n// x = t-1/t     \\_/\n// y = t+1/t\n// has min Y at 2 and focus at 2\u221a2\n//     \n//  z,w s.t. |(x,y)-(z,w)| is min\n//       https://www.wolframalpha.com/input?i=d%2Fdt+%28%28a*%28t-1%2Ft%29-z%29%5E2%2B%28b*%28t%2B1%2Ft%29-w%29%5E2+%29+\n//  (2 a^2 t^4 - 2 a^2 - 2 a t^3 z - 2 a t z + 2 b^2 t^4 - 2 b^2 - 2 b t^3 w + 2 b t w)/t^3 = 0\n//  t^4 : 2 a^2 + 2 b^2 \n//  t^3 : - 2 a z - 2 b w\n//  t^2 : 0\n//  t   : - 2 a z + 2 b w\n//  1   : - 2 a^2 - 2 b^2\n// using: https://en.wikipedia.org/wiki/Quartic_equation#Summary_of_Ferrari's_method\n// let r^2 = a^2 + b^2\n// coeffs (A\u2026E): 2r^2, -2(ab\u2022zw), 0, -2((a,b)\u2022(z,-w)), -2r^2\n//  \u03b1 = -3/8 (B/A)^2 + C/A\n//  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n//  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n// \n// when \u03b2 = 0\n//  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n// else\n//  P = - \u03b1^2/12 - \u03b3\n//  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n//  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n//  U = \u221bR\n//\n//  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n//  W = \u221a(\u03b1 + 2d)\n//  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n//\n//\n\n\n// currently suffers from precision loss in some areas\n//  which can be shown by uncommenting \"col = p.x<m.x?ploss: col;\" in mainImage\n//\nvec2 pHyperbola( vec2 p, in vec2 ab){\n    \n    //vec2 s1 = pHyperbola_sols(p,ab,1.0,1.0);\n    //vec2 s2 = pHyperbola_sols(p,ab,-1.0,1.0);\n    //vec2 s3 = pHyperbola_sols(p,ab,-1.0,-1.0);\n    //vec2 s4 = pHyperbola_sols(p,ab,1.0,-1.0);\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2;\n    //s2 = (length(s3-p)<length(s4-p))?s3:s4;\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2; \n    //return s1;\n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //          = (-3/256 boa^3 - 1/4 doa)*boa - 1\n    //          _     \u239baz+bw\u239e4   \u239baz+bw\u239e\u239baz-bw\u239e\n    //          \u00af  -3 \u239d\u00af4\u00afr2\u23a0  - \u239d\u00af4\u00afr2\u23a0\u239d\u00afr2\u00af\u00af\u23a0 - 1\n    //          = \n    //          -(3 x^4)/(256 d^4) - (3 x^3 y)/(64 d^4) - (9 x^2 y^2)/(128 d^4) - (3 x y^3)/(64 d^4) - (3 y^4)/(256 d^4) - x^2/(4 d^2) + y^2/(4 d^2) - 1\n    //float gamma = -3.0/256.0 * quart(az / r2) - 3.0*(az\n    \n    \n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    //float P = - alpha2 / 12.0 - gamma;\n    //  P = - (3/8 * boa2)^2/12 - (-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0);\n    //    = - 3/256 boa^4 + 3.0/256.0 * (boa2*boa2) + 0.25 * boa*doa + 1.0;\n    //    = 0.25 * boa*doa + 1.0;\n    float P = 0.25 * boa*doa + 1.0;\n    \n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //                     ^^^ lowers cancellation error\n    \n    \n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float dp56a = (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    float d = -5.0/6.0 * alpha + dp56a;\n    //  W = \u221a(\u03b1 + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //  W = \u221a(\u03b1 + -5/3 \u03b1 + (U==0? -2\u221bQ : 2U - 2P/(3U))\n    //    = \u221a(-2/3 \u03b1 + )\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * dp56a));\n    //  W = \u221a(-2/3 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    // case U==0\n    //  W = \u221a(-2/3 \u03b1 -\u221bQ)\n    //    = \u221a(-2/3 \u03b1 -\u221b(- \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8))\n    // case U!=0\n    //  W = \u221a(-2/3 \u03b1 + U + (\u03b1^2/12 + \u03b3)/(3U))\n    //    = \u221a(-2/3 \u03b1 + U - P/(3U))\n    //  W = \u221a(-2/3 \u03b1 + \u221bR - P/(3\u221bR))\n    \n    \n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    //float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //        3\u03b1 + 2d = 3\u03b1 + 2(-5/6 \u03b1  + dp56a)\n    //                = (3-5/3) \u03b1  + 2 dp56a\n    //                =  4/3 \u03b1  + 2 dp56a\n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + 2.0*beta/W)));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + -2.0*beta/W)));\n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    return (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    float sqrt2 = sqrt(2.0);//foci are at (0,\u00b1\u221a2)\n    p /= ab;\n    p /= 2.0;\n    return sign(length(p-vec2(0,sqrt2))-length(p-vec2(0,-sqrt2))+2.0);\n}\n\n\n//precision loss testing\nfloat add_ploss(in float a, in float b){\n    return -log2(abs(a+b)/(abs(a)+abs(b)))/24.0;\n}\nvec3 pHyperbola_loss( vec2 p, in vec2 ab)\n{\n    \n                                                                                                  \n    float loss1 = 0.0;\n    float loss2 = 0.0;\n    float loss3 = 0.0;\n    \n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //  \u03b1 = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //  \u03b2 = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //loss3 = add_ploss(0.125 * boa2*boa, doa);\n    //  \u03b3 = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) ,- 0.25 * boa*doa-1.0);\n    loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa,-1.0);\n    // when \u03b2 = 0\n    //  t = -B/4A \u00b1 \u221a((-\u03b1 \u00b1 \u221a(\u03b1^2-4\u03b3))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - \u03b1^2/12 - \u03b3\n    float P = - alpha2 / 12.0 - gamma;\n    loss1 = add_ploss(alpha2 / 12.0,gamma);\n    //  Q = - \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //loss3 = add_ploss(alpha2 / 108.0, - gamma/3.0);\n    //loss3 = add_ploss(- alpha*(alpha2 / 108.0 - gamma/3.0),- beta*beta / 8.0); \n    //  R = - Q/2 \u00b1 \u221a((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //loss3 = add_ploss(Q*Q*0.25,P*P*P/27.0);\n    //loss3 = add_ploss(- Q * 0.5,sqrt(abs(Q*Q*0.25 + P*P*P/27.0))); //lines up with P in upper half, fixed\n    //  U = \u221bR\n    float U = cbrt(R);\n    \n    //  d = -5/6 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    //loss3 = add_ploss(-5.0/6.0 * alpha, (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))); //not here\n    //loss3 = add_ploss(U, - P/(3.0*U));// not here\n    //  W = \u221a(\u03b1 + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //loss2 = add_ploss(alpha,2.0*d);\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))));\n    loss2 = add_ploss(-2.0/3.0 * alpha,2.0*(abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U)));\n    //  t = -B/4A + 1/2( \u00b1_s W \u00b1 \u221a(-(3\u03b1 + 2d \u00b1_s 2\u03b2/W)))\n    //  W = \u221a(-2/3 \u03b1 + (U==0? -\u221bQ : U - P/(3U))\n    // case U==0\n    //  W = \u221a(-2/3 \u03b1 -\u221bQ)\n    //    = \u221a(-2/3 \u03b1 -\u221b(- \u03b1^3/108 + \u03b1\u03b3/3 - \u03b2^2/8))\n    // case U!=0\n    //  W = \u221a(-2/3 \u03b1 + U + (\u03b1^2/12 + \u03b3)/(3U))\n    //    = \u221a(-2/3 \u03b1 + U - P/(3U))\n    //  W = \u221a(-2/3 \u03b1 + \u221bR - P/(3\u221bR))\n    //loss3 = add_ploss(-2.0/3.0 *alpha, + U);\n    \n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(W+sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W))));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(-W+sqrt(abs(3.0*alpha + 2.0*d - 2.0*beta/W))));\n    \n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    vec2 result = (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n    \n    return vec3(loss1,loss2,loss3);\n    \n}\n\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float s = s1;\n    float t = s2;\n    float x1 = (a*a*b*b*s*s - a*a*b*b*t*t - a*a*b*b*s*t + a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s*t + a*a*b*b*s*t - a*a*b*b*s// incomplete generation!\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 ra = (vec2(0.25,0.25) + 0.25*cos(iTime*vec2(1.1,1.3)+vec2(1.0,1.0) ))*0.25*(1.0625-sin(iTime));\n\t\n \tvec2 pd = pHyperbola( p, ra);\n    float d = length(pd-p)*inside_Hyperbola(p,ra);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    vec3 ploss = pHyperbola_loss(p,ra);\n    //uncomment the next line to see a map of floating point precision loss on the solution\n    col = p.x<m.x?ploss: col;\n    \n    \n    if( iMouse.z>0.001 )\n    {\n    pd = pHyperbola(m, ra);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0030));\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.030));\n    \n    pd = pHyperbola_sols(m, ra,1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.025));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0020));\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.020));\n    \n    pd = pHyperbola_sols(m, ra,1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0015));\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.015));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0010));\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.010));\n    \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4( col, 1.0 );;\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capped cone. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3  ba = b - a;\n    float baba = dot(ba,ba);\n    float babap1 = baba + 1.0;\n    float babap1r = 1.0 / babap1;\n    float baba2 = baba + 2.0;\n    float baba2r = 1.0 / baba2;\n    float baba2r2 = baba2r * baba2r;\n    float baba2r3 = baba2r2 * baba2r;\n    float baba2r4 = baba2r2 * baba2r2;\n    float baba2r5 = baba2r4 * baba2r;\n    float baba2r6 = baba2r4 * baba2r2;\n    float baba2r7 = baba2r6 * baba2r;\n    float baba2r8 = baba2r4 * baba2r4;\n    float baba2r9 = baba2r8 * baba2r;\n    float baba2r10 = baba2r8 * baba2r2;\n    float baba2r11 = baba2r10 * baba2r;\n    float baba2r12 = baba2r8 * baba2r4;\n    float baba2r13 = baba2r12 * baba2r;\n    float baba2r14 = baba2r12 * baba2r2;\n    float baba2r15 = baba2r14 * baba2r;\n    float baba2r16 = baba2r8 * baba2r8;\n    float baba2r17 = baba2r16 * baba2r;\n    float baba2r18 = baba2r16 * baba2r2;\n    float baba2r19 = baba2r1// incomplete generation!\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst vec3 pa = vec3(0.4, 0.6, 0.0);\nconst vec3 pb = vec3(0.0,-0.4, 0.0);\nconst float ra = 0.2;\nconst float rb = 0.8;\n    \nvec2 map( in vec3 pos, bool showSurface, vec3 samplePoint )\n{\n\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = sdcCappedCone(samplePoint, pa, pb, ra, rb ).yzw;\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // object\n    if( showSurface )\n    {\n    float d = sdcCappedCone( pos, pa, pb, ra, rb ).x;\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.0*0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make shape transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.0*cos(an), 0.8, 2.0*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.9*vec3(1.0,1.1,1.2)+vec3(0.0,4.0,5.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface,samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdcCappedCone( samplePoint, pa, pb, ra, rb ).x;\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface,samplePoint);\n              col += 1.5*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.5*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capped cone. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n// .x   distance to the cone\n// .yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    //--------------------------------------\n    // 3D to 2D : p.xyz -> (u,v)\n    //--------------------------------------\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    \n    float baba = dot(ba,ba);\n    float bale = sqrt(baba);\n    \n    vec3  w = ba/bale;\n    float v = dot(pa,w);\n\n    vec3  q = a + w*v;\n    vec3  pq = p-q;\n    float pqpq = dot(pq,pq);\n    float u = sqrt(pqpq);\n    \n    //--------------------------------------\n    // distance and closest in 2D, in (u,v)\n    // from https://www.shadertoy.com/view/ddt3Rs\n    //--------------------------------------\n\n    float he = 0.5*bale;\n    v -= he;\n\n\n    float sy = (v<0.0)?-1.0:1.0;\n    \n    vec4 res;\n\n    // top and bottom edges\n    {\n    float h = min(u,(v<0.0)?ra:rb);\n    vec2  c = vec2(h,sy*he);\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = abs(v)-he;\n    res = vec4(d,c.x,c.y,s);\n    }\n    \n    // side edge\n    {\n    vec2  k = vec2(rb-ra,2.0*he);\n    vec2  w = vec2(u,v)-vec2(ra,-he);\n    float h = clamp(dot(w,k)/dot(k,k),0.0,1.0);\n    vec2  c = vec2(ra,-he) + h*k;\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = w.x*k.y - w.y*k.x;\n    res = vec4( (d<res.x) ? vec3(d,c.x,c.y) : res.xyz,\n                (s>res.w) ?      s          : res.w );\n    }\n   \n    // distance and sign\n    res.x = sqrt(res.x)*sign(res.w);\n    // closest is in res.yz\n\n    //--------------------------------------\n    // 2D to 3D : res.yz -> xyz\n    //--------------------------------------\n\n    float d = res.x;\n    vec2 cl = vec2(res.y,res.z+he);\n    \n    return vec4( d, a + w*cl.y + (p-q)*cl.x/u );\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst vec3 pa = vec3(0.4, 0.6, 0.0);\nconst vec3 pb = vec3(0.0,-0.4, 0.0);\nconst float ra = 0.2;\nconst float rb = 0.8;\n    \nvec2 map( in vec3 pos, bool showSurface, vec3 samplePoint )\n{\n\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = sdcCappedCone(samplePoint, pa, pb, ra, rb ).yzw;\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // object\n    if( showSurface )\n    {\n    float d = sdcCappedCone( pos, pa, pb, ra, rb ).x;\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.0*0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make shape transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.0*cos(an), 0.8, 2.0*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.9*vec3(1.0,1.1,1.2)+vec3(0.0,4.0,5.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface,samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdcCappedCone( samplePoint, pa, pb, ra, rb ).x;\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface,samplePoint);\n              col += 1.5*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.5*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capped cone. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n// .x   distance to the cone\n// .yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    //--------------------------------------\n    // 3D to 2D : p.xyz -> (u,v)\n    //--------------------------------------\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    \n    float baba = dot(ba,ba);\n    float bale = sqrt(baba);\n    \n    vec3  w = ba/bale;\n    float v = dot(pa,w);\n\n    vec3  q = a + w*v;\n    vec3  pq = p-q;\n    float pqpq = dot(pq,pq);\n    float u = sqrt(pqpq);\n    \n    //--------------------------------------\n    // distance and closest in 2D, in (u,v)\n    // from https://www.shadertoy.com/view/ddt3Rs\n    //--------------------------------------\n\n    float he = 0.5*bale;\n    v -= he;\n\n\n    float sy = (v<0.0)?-1.0:1.0;\n    \n    vec4 res;\n\n    // top and bottom edges\n    {\n    float h = min(u,(v<0.0)?ra:rb);\n    vec2  c = vec2(h,sy*he);\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = abs(v)-he;\n    res = vec4(d,c.x,c.y,s);\n    }\n    \n    // side edge\n    {\n    vec2  k = vec2(rb-ra,2.0*he);\n    vec2  w = vec2(u,v)-vec2(ra,-he);\n    float h = clamp(dot(w,k)/dot(k,k),0.0,1.0);\n    vec2  c = vec2(ra,-he) + h*k;\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = w.x*k.y - w.y*k.x;\n    res = vec4( (d<res.x) ? vec3(d,c.x,c.y) : res.xyz,\n                (s>res.w) ?      s          : res.w );\n    }\n   \n    // distance and sign\n    res.x = sqrt(res.x)*sign(res.w);\n    // closest is in res.yz\n\n    //--------------------------------------\n    // 2D to 3D : res.yz -> xyz\n    //--------------------------------------\n\n    float d = res.x;\n    vec2 cl = vec2(res.y,res.z+he);\n    \n    return vec4( d, a + w*cl.y + (p-q)*cl.x/u );\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst vec3 pa = vec3(0.4, 0.6, 0.0);\nconst vec3 pb = vec3(0.0,-0.4, 0.0);\nconst float ra = 0.2;\nconst float rb = 0.8;\n    \nvec2 map( in vec3 pos, bool showSurface, vec3 samplePoint )\n{\n\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = sdcCappedCone(samplePoint, pa, pb, ra, rb ).yzw;\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // object\n    if( showSurface )\n    {\n    float d = sdcCappedCone( pos, pa, pb, ra, rb ).x;\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.0*0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make shape transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.0*cos(an), 0.8, 2.0*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.9*vec3(1.0,1.1,1.2)+vec3(0.0,4.0,5.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface,samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdcCappedCone( samplePoint, pa, pb, ra, rb ).x;\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface,samplePoint);\n              col += 1.5*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.5*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capped cone. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n// .x   distance to the cone\n// .yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    //--------------------------------------\n    // 3D to 2D : p.xyz -> (u,v)\n    //--------------------------------------\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    \n    float baba = dot(ba,ba);\n    float bale = sqrt(baba);\n    \n    vec3  w = ba/bale;\n    float v = dot(pa,w);\n\n    vec3  q = a + w*v;\n    vec3  pq = p-q;\n    float pqpq = dot(pq,pq);\n    float u = sqrt(pqpq);\n    \n    //--------------------------------------\n    // distance and closest in 2D, in (u,v)\n    // from https://www.shadertoy.com/view/ddt3Rs\n    //--------------------------------------\n\n    float he = 0.5*bale;\n    v -= he;\n\n\n    float sy = (v<0.0)?-1.0:1.0;\n    \n    vec4 res;\n\n    // top and bottom edges\n    {\n    float h = min(u,(v<0.0)?ra:rb);\n    vec2  c = vec2(h,sy*he);\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = abs(v)-he;\n    res = vec4(d,c.x,c.y,s);\n    }\n    \n    // side edge\n    {\n    vec2  k = vec2(rb-ra,2.0*he);\n    vec2  w = vec2(u,v)-vec2(ra,-he);\n    float h = clamp(dot(w,k)/dot(k,k),0.0,1.0);\n    vec2  c = vec2(ra,-he) + h*k;\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = w.x*k.y - w.y*k.x;\n    res = vec4( (d<res.x) ? vec3(d,c.x,c.y) : res.xyz,\n                (s>res.w) ?      s          : res.w );\n    }\n   \n    // distance and sign\n    res.x = sqrt(res.x)*sign(res.w);\n    // closest is in res.yz\n\n    //--------------------------------------\n    // 2D to 3D : res.yz -> xyz\n    //--------------------------------------\n\n    float d = res.x;\n    vec2 cl = vec2(res.y,res.z+he);\n    \n    return vec4( d, a + w*cl.y + (p-q)*cl.x/u );\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst vec3 pa = vec3(0.4, 0.6, 0.0);\nconst vec3 pb = vec3(0.0,-0.4, 0.0);\nconst float ra = 0.2;\nconst float rb = 0.8;\n    \nvec2 map( in vec3 pos, bool showSurface, vec3 samplePoint )\n{\n\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = sdcCappedCone(samplePoint, pa, pb, ra, rb ).yzw;\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // object\n    if( showSurface )\n    {\n    float d = sdcCappedCone( pos, pa, pb, ra, rb ).x;\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        calcDist( pos + eps.xyy, showSurface, samplePoint ) - calcDist( pos - eps.xyy, showSurface, samplePoint ),\n        calcDist( pos + eps.yxy, showSurface, samplePoint ) - calcDist( pos - eps.yxy, showSurface, samplePoint ),\n        calcDist( pos + eps.yyx, showSurface, samplePoint ) - calcDist( pos - eps.yyx, showSurface, samplePoint )\n    );\n    return normalize( nor );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.0*0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make shape transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.0*cos(an), 0.8, 2.0*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.9*vec3(1.0,1.1,1.2)+vec3(0.0,4.0,5.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface,samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdcCappedCone( samplePoint, pa, pb, ra, rb ).x;\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface,samplePoint);\n              col += 1.5*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.5*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capped cone. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n// .x   distance to the cone\n// .yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    //--------------------------------------\n    // 3D to 2D : p.xyz -> (u,v)\n    //--------------------------------------\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    \n    float baba = dot(ba,ba);\n    float bale = sqrt(baba);\n    \n    vec3  w = ba/bale;\n    float v = dot(pa,w);\n\n    vec3  q = a + w*v;\n    vec3  pq = p-q;\n    float pqpq = dot(pq,pq);\n    float u = sqrt(pqpq);\n    \n    //--------------------------------------\n    // distance and closest in 2D, in (u,v)\n    // from https://www.shadertoy.com/view/ddt3Rs\n    //--------------------------------------\n\n    float he = 0.5*bale;\n    v -= he;\n\n\n    float sy = (v<0.0)?-1.0:1.0;\n    \n    vec4 res;\n\n    // top and bottom edges\n    {\n    float h = min(u,(v<0.0)?ra:rb);\n    vec2  c = vec2(h,sy*he);\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = abs(v)-he;\n    res = vec4(d,c.x,c.y,s);\n    }\n    \n    // side edge\n    {\n    vec2  k = vec2(rb-ra,2.0*he);\n    vec2  w = vec2(u,v)-vec2(ra,-he);\n    float h = clamp(dot(w,k)/dot(k,k),0.0,1.0);\n    vec2  c = vec2(ra,-he) + h*k;\n    vec2  q = vec2(u,v) - c;\n    float d = dot(q,q);\n    float s = w.x*k.y - w.y*k.x;\n    res = vec4( (d<res.x) ? vec3(d,c.x,c.y) : res.xyz,\n                (s>res.w) ?      s          : res.w );\n    }\n   \n    // distance and sign\n    res.x = sqrt(res.x)*sign(res.w);\n    // closest is in res.yz\n\n    //--------------------------------------\n    // 2D to 3D : res.yz -> xyz\n    //--------------------------------------\n\n    float d = res.x;\n    vec2 cl = vec2(res.y,res.z+he);\n    \n    return vec4( d, a + w*cl.y + (p-q)*cl.x/u );\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst vec3 pa = vec3(0.4, 0.6, 0.0);\nconst vec3 pb = vec3(0.0,-0.4, 0.0);\nconst float ra = 0.2;\nconst float rb = 0.8;\n    \nvec2 map( in vec3 pos, bool showSurface, vec3 samplePoint )\n{\n\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = sdcCappedCone(samplePoint, pa, pb, ra, rb ).yzw;\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // object\n    if( showSurface )\n    {\n    float d = sdcCappedCone( pos, pa, pb, ra, rb ).x;\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    float t = 0.0;\n    float d = 0.0;\n    float eps = 0.001;\n    float maxd = 10.0;\n    float maxd2 = 10.0;\n    float maxd3 = 10.0;\n    float maxd4 = 10.0;\n    float maxd5 = 10.0;\n    float maxd6 = 10.0;\n    float maxd7 = 10.0;\n    float maxd8 = 10.0;\n    float maxd9 = 10.0;\n    float maxd10 = 10.0;\n    float maxd11 = 10.0;\n    float maxd12 = 10.0;\n    float maxd13 = 10.0;\n    float maxd14 = 10.0;\n    float maxd15 = 10.0;\n    float maxd16 = 10.0;\n    float maxd17 = 10.0;\n    float maxd18 = 10.0;\n    float maxd19 = 10.0;\n    float maxd20 = 10.0;\n    float maxd21 = 10.0;\n    float maxd22 = 10.0;\n    float maxd23 = 10.0;\n    float maxd24 = 10.0;\n    float maxd25 = 10.0;\n    float maxd26 = 10.0;\n    float maxd27 = 10.0;\n    float maxd28 = 10.0;\n    float maxd29 = 10.0;\n    float maxd30 = 10.0;\n    float maxd31 = 10.0;\n    float// incomplete generation!\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.0*0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make shape transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.0*cos(an), 0.8, 2.0*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.9*vec3(1.0,1.1,1.2)+vec3(0.0,4.0,5.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface,samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdcCappedCone( samplePoint, pa, pb, ra, rb ).x;\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface,samplePoint);\n              col += 1.5*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.5*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance, closest point and gradient to a trapezoid.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\n    vec2  q = abs(p);\n    float d = 0.0;\n    if( q.y > he )\n    {\n        d = length(q-vec2(ra,he))-rb;\n        ocl = vec2(sign(p.x),1.0);\n    }\n    else\n    {\n        d = max(q.y-he,q.x-ra);\n        ocl = vec2(sign(p.x),0.0);\n    }\n    return vec3( d, 0.0, 0.0 );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n        // animation\n        float ra = 0.2+0.15*sin(iTime*1.3+0.0);\n        float rb = 0.2+0.15*sin(iTime*1.4+1.1);\n        float he = 0.5+0.2*sin(1.3*iTime);\n\n\n        // sdf(p) and gradient(sdf(p))\n        vec2 kk;\n        vec3  dg = sdgTrapezoid( p, ra, rb, he, kk );\n        float d = dg.x;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n \n        // interaction\n        if( iMouse.z>0.001 )\n        {\n            vec2 cl;\n            d = sdgTrapezoid(m, ra, rb, he, cl).x;\n            col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n            col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n            col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.015));\n        }\n\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgTorus() returns the torus SDF and its gradient, by \n// computing it analytically. This means the normal to\n// the torus surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n// Ellipsoid: https://www.shadertoy.com/view/flXyRS\n\n\n// .x = f(p)\n// .y = \u2202f(p)/\u2202x\n// .z = \u2202f(p)/\u2202y\n// .w = \u2202f(p)/\u2202z\n// .yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    vec2 q = abs(vec2(length(p.xz)-ra,p.y))-rb;\n    return vec4( min(max(q.x,q.y),0.0), max(q.x,q.y), q.x>q.y? vec2(1.0,0.0) : vec2(0.0,1.0) );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    float size = 0.2;\n   \n   float idk = 1.0;\n   \n    // animate torus\n    float majorRadius = idk*size + idk*size*sin(iTime); //major radius\n    float minorRadius = size; //minor radius\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgTorus(pos,majorRadius,minorRadius).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgTorus(pos,majorRadius,minorRadius).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgTorus( pos + e.xyy*eps, majorRadius, minorRadius ).x + \n                             e.yyx*sdgTorus( pos + e.yyx*eps, majorRadius, minorRadius ).x + \n                             e.yxy*sdgTorus( pos + e.yxy*eps, majorRadius, minorRadius ).x + \n                             e.xxx*sdgTorus( pos + e.xxx*eps, majorRadius, minorRadius ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a vesica given by two points and a (semi)width, using\n// two square roots per evaluation.\n\n// See also https://www.shadertoy.com/view/XtVfRW for an axis aligned vesica\n\n// List of some other 2D distances:\n//     https://www.shadertoy.com/playlist/MXdSRf\n// and\n//     iquilezles.org/articles/distfunctions2d\n\n\nfloat sdVesicaSegment( in vec2 p, in vec2 a, in vec2 b, float w )\n{\n    // shape constants\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    \n    // center, orient and mirror\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    \n    // feature selection (vertex or body)\n    vec3 h = (r*q.x < d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    // distance\n    return length(q-h.xy) - h.z;\n}\n\n\n// iquilezles.org/articles/distfunctions2d\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    // animation\n    vec2  v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2  v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.40*(0.5+0.495*cos(iTime*1.1+2.0));\n    float ra = 0.15*(0.5+0.495*cos(iTime*1.3+1.0));\n    float al = smoothstep( -0.5, 0.5,sin(iTime+0.1) );\n    ra *= 1.0-al;\n    \n    // distance\n    float d = sdVesicaSegment( p, v1, v2, th ) - ra;\n    \n    // color\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-10.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(100.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // mouse\n    if( iMouse.z>0.001 )\n    {\n    d = sdVesicaSegment( m, v1, v2, th ) - ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // geometry\n    {\n    vec2 c = (v1+v2)/2.0;\n    vec2 u = normalize( vec2(v2.y-v1.y,v1.x-v2.x) );\n    vec2 v3 = c + u*(th+ra);\n    vec2 v4 = c - u*(th+ra);\n    d = min(min(min(length(p-v1),\n                    length(p-v2)),\n                min(length(p-v3),\n                    length(p-v4))) - 0.015,\n                min(udSegment(p,v1,v2),\n                    udSegment(p,v3,v4)) - 0.004 );\n                  \n    col = mix(col, vec3(1.0,1.0,0.0), al*(1.0-smoothstep(0.0, 0.005, d)));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Based on:\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n#define INF 1.0 / 0.0\n\nfloat distLine(vec3 p, vec3 dir) {\n    return length(cross(p, dir))/length(dir)-0.1;\n}\n\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p-s.xyz)-s.w;\n}\n\nbool bounded = false;\n// Rounded capsule https://iquilezles.org/articles/distfunctions/\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat sdBranchFast(vec3 p, vec4 a, vec4 b, float minDist) {\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b.xyz - a.xyz;\n    float l2 = dot(ba, ba);\n    float bound = length(cross(p-a.xyz, ba))/sqrt(l2) -a.w;\n    if (bound > minDist) {\n        bounded = true;\n        return minDist; // Early skip\n    } // Bounding cylinder\n    float rr = a.w - b.w;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n        \n    // sampling dependant computations\n    vec3 pa = p - a.xyz;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2>k ) return min(sqrt(x2 + z2)         *il2 - b.w, minDist);\n    if( sign(y)*a2*y2<k ) return min(sqrt(x2 + y2)         *il2 - a.w, minDist);\n                          return min((sqrt(x2*a2*il2)+y*rr)*il2 - a.w, minDist);\n}\n\nfloat map(vec2 p2) {\n    vec3 p = vec3(p2.x, p2.y, 0.0);\n    float other = sdSphere(p, vec4(0.5, 0.0, 0.0, 0.3));\n    //return distLine(p, vec3(1.0, 1.0, 0.0));\n    return sdBranchFast(p, vec4(-0.3, -0.3, 0.0, 0.4), vec4(0.5, 0.5, 0.0, 0.1), other);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = map(p);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 ) {\n        d = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    if (bounded) col *= 0.5;\n\tfragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Based on:\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    vec2 d = abs(p) - maxCorner;\n    return min(max(d.x,d.y),0.0) + dot(max(d,vec2(0.0)),max(d,vec2(0.0)));\n}\n\nfloat map(vec2 p) {\n    float bb1 = sqAABB(p,vec2(-abs(sin(iTime)) * 0.5),vec2(abs(cos(iTime))) * 0.5);\n    float bb2 = sqAABB(p,vec2(cos(iTime), 0.0),vec2(cos(iTime)+0.3, 0.3));\n    return sqrt(min(bb1, bb2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = map(p);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = map(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}"], ["// \"Wind Waker Ocean\" by @Polyflare (29/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Source code for the texture generator is available at:\n// https://github.com/lmurray/circleator\n\n//-----------------------------------------------------------------------------\n// User settings\n\n// 0 = No antialiasing\n// 1 = 2x2 supersampling antialiasing\n#define ANTIALIAS 1\n\n// 0 = Static camera\n// 1 = Animate the camera\n#define ANIMATE_CAM 0\n\n// 0 = Do not distort the water texture\n// 1 = Apply lateral distortion to the water texture\n#define DISTORT_WATER 1\n\n// 0 = Disable parallax effects\n// 1 = Change the height of the water with parallax effects\n#define PARALLAX_WATER 1\n\n// 0 = Antialias the water texture\n// 1 = Do not antialias the water texture\n#define FAST_CIRCLES 1\n\n//-----------------------------------------------------------------------------\n#define WATER3_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER4_COL vec3(0.0, 0.4180, 0.6758)\n\n#define WATER_COL vec3(0.374, 0.8453, 0.5305)\n#define WATER2_COL vec3(0.374, 0.8180, 0.4758)\n#define FOAM_COL vec3(0.5125, 0.9609, 0.9648)\n#define FOG_COL vec3(0.7006, 0.9453, 0.9336)\n#define SKY_COL vec3(0.0, 0.8203, 1.0)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n#if FAST_CIRCLES\n    return dot(c, c) < s ? -1.0 : 0.0;\n#else\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n#endif\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv, vec3 cdir)\n{\n    vec2 uv2 = uv * 10.0;\n    vec2 uv3 = uv * 100.0;\n    vec2 uv4 = uv * 1000.0;\n    vec2 uv5 = uv * 10000.0;\n\n    vec2 uv6 = uv * 100000.0;\n    vec2 uv7 = uv * 1000000.0;\n    vec2 uv8 = uv * 10000000.0;\n    vec2 uv9 = uv * 100000000.0;\n\n    vec2 uv10 = uv * 1000000000.0;\n    vec2 uv11 = uv * 10000000000.0;\n    vec2 uv12 = uv * 100000000000.0;\n    vec2 uv13 = uv * 1000000000000.0;\n\n    vec2 uv14 = uv * 10000000000000.0;\n    vec2 uv15 = uv * 100000000000000.0;\n    vec2 uv16 = uv * 1000000000000000.0;\n    vec2 uv17 = uv * 10000000000000000.0;\n\n    vec2 uv18 = uv * 100000000000000000.0;\n    vec2 uv19 = uv * 1000000000000000000.0;\n    vec2 uv20 = uv * // incomplete generation!\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 pixpos;\n    pixpos.xy = uv - 0.5;\n    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction\n    pixpos.z = -0.6; // Focal length (Controls field of view)\n    return normalize(pixpos);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 qvec = q.xyz;\n    vec3 uv = cross(qvec, v);\n    vec3 uuv = cross(qvec, uv);\n    uv *= (2.0 * q.w);\n    uuv *= 2.0;\n    return v + uv + uuv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if ANTIALIAS\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n        \tvec2 offset = vec2(0.5) * vec2(x, y) - vec2(0.25);\n#else\n        \tvec2 offset = vec2(0.0);\n#endif\n            // Camera stuff\n            vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n            vec3 cpos = vec3(0.0, 7.0, 10.0); // Camera position\n            vec3 cdir = pixtoray(uv);\n            cdir = quatmul( // Tilt down slightly\n                vec4(-0.19867, 0.0, 0.0, 0.980067), cdir);\n#if ANIMATE_CAM\n            // Rotating camera\n            float cost = cos(iTime * -0.05);\n            float sint = sin(iTime * -0.05);\n            cdir.xz = cost * cdir.xz + sint * vec2(-cdir.z, cdir.x);\n            cpos.xz = cost * cpos.xz + sint * vec2(-cpos.z, cpos.x);\n#endif\n\n            // Ray-plane intersection\n            const vec3 ocean = vec3(0.0, 1.0, 0.0);\n            float dist = -dot(cpos, ocean) / dot(cdir, ocean);\n            vec3 pos = cpos + dist * cdir;\n\n            vec3 pix;\n            if(dist > 0.0 && dist < 100.0) {\n                // Ocean\n                vec3 wat = water(pos.xz, cdir);\n                pix = mix(wat, FOG_COL, min(dist * 0.01, 1.0));\n            } else {\n                // Sky\n                pix = mix(FOG_COL, SKY_COL, min(cdir.y * 4.0, 1.0));\n            }\n#if ANTIALIAS\n        \tfragColor.rgb += pix * vec3(0.25);\n    \t}\n    }\n#else\n    fragColor.rgb = pix;\n#endif\n}"], ["// \"Wind Waker Ocean\" by @Polyflare (29/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Source code for the texture generator is available at:\n// https://github.com/lmurray/circleator\n\n//-----------------------------------------------------------------------------\n// User settings\n\n// 0 = No antialiasing\n// 1 = 2x2 supersampling antialiasing\n#define ANTIALIAS 1\n\n// 0 = Static camera\n// 1 = Animate the camera\n#define ANIMATE_CAM 0\n\n// 0 = Do not distort the water texture\n// 1 = Apply lateral distortion to the water texture\n#define DISTORT_WATER 1\n\n// 0 = Disable parallax effects\n// 1 = Change the height of the water with parallax effects\n#define PARALLAX_WATER 1\n\n// 0 = Antialias the water texture\n// 1 = Do not antialias the water texture\n#define FAST_CIRCLES 1\n\n//-----------------------------------------------------------------------------\n#define WATER3_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER4_COL vec3(0.0, 0.4180, 0.6758)\n\n#define WATER_COL vec3(0.374, 0.8453, 0.5305)\n#define WATER2_COL vec3(0.374, 0.8180, 0.4758)\n#define FOAM_COL vec3(0.5125, 0.9609, 0.9648)\n#define FOG_COL vec3(0.7006, 0.9453, 0.9336)\n#define SKY_COL vec3(0.0, 0.8203, 1.0)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n#if FAST_CIRCLES\n    return dot(c, c) < s ? -1.0 : 0.0;\n#else\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n#endif\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv, vec3 cdir)\n{\n    uv *= vec2(0.25);\n    \n#if PARALLAX_WATER\n    // Parallax height distortion with two directional waves at\n    // slightly different angles.\n    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset\n    float h = sin(uv.x + iTime); // Height at UV\n    uv += a * h;\n    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);\n    uv += a * h;\n#endif\n    \n#if DISTORT_WATER\n    // Texture distortion\n    float d1 = mod(uv.x + uv.y, M_2PI);\n    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);\n    d1 = iTime * 0.07 + d1;\n    d2 = iTime * 0.5 + d2;\n    vec2 dist = vec2(\n    \tsin(d1) * 0.15 + sin(d2) * 0.05,\n    \tcos(d1) * 0.15 + cos(d2) * 0.05\n    );\n#else\n    const vec2 dist = vec2(0.0);\n#endif\n    \n    vec3 ret = mix(WATER_COL, WATER2_COL, waterlayer(uv + dist.xy));\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 2.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 qvec = q.xyz;\n    vec3 uv = cross(qvec, v);\n    vec3 uuv = cross(qvec, uv);\n    uv *= (2.0 * q.w);\n    uuv *= 2.0;\n    return v + uv + uuv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if ANTIALIAS\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n        \tvec2 offset = vec2(0.5) * vec2(x, y) - vec2(0.25);\n#else\n        \tvec2 offset = vec2(0.0);\n#endif\n            // Camera stuff\n            vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n            vec3 cpos = vec3(0.0, 7.0, 10.0); // Camera position\n            vec3 cdir = pixtoray(uv);\n            cdir = quatmul( // Tilt down slightly\n                vec4(-0.19867, 0.0, 0.0, 0.980067), cdir);\n#if ANIMATE_CAM\n            // Rotating camera\n            float cost = cos(iTime * -0.05);\n            float sint = sin(iTime * -0.05);\n            cdir.xz = cost * cdir.xz + sint * vec2(-cdir.z, cdir.x);\n            cpos.xz = cost * cpos.xz + sint * vec2(-cpos.z, cpos.x);\n#endif\n\n            // Ray-plane intersection\n            const vec3 ocean = vec3(0.0, 1.0, 0.0);\n            float dist = -dot(cpos, ocean) / dot(cdir, ocean);\n            vec3 pos = cpos + dist * cdir;\n\n            vec3 pix;\n            if(dist > 0.0 && dist < 100.0) {\n                // Ocean\n                vec3 wat = water(pos.xz, cdir);\n                pix = mix(wat, FOG_COL, min(dist * 0.01, 1.0));\n            } else {\n                // Sky\n                pix = mix(FOG_COL, SKY_COL, min(cdir.y * 4.0, 1.0));\n            }\n#if ANTIALIAS\n        \tfragColor.rgb += pix * vec3(0.25);\n    \t}\n    }\n#else\n    fragColor.rgb = pix;\n#endif\n}"], ["// \"Wind Waker Ocean\" by @Polyflare (29/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Source code for the texture generator is available at:\n// https://github.com/lmurray/circleator\n\n//-----------------------------------------------------------------------------\n// User settings\n\n// 0 = No antialiasing\n// 1 = 2x2 supersampling antialiasing\n#define ANTIALIAS 1\n\n// 0 = Static camera\n// 1 = Animate the camera\n#define ANIMATE_CAM 0\n\n// 0 = Do not distort the water texture\n// 1 = Apply lateral distortion to the water texture\n#define DISTORT_WATER 1\n\n// 0 = Disable parallax effects\n// 1 = Change the height of the water with parallax effects\n#define PARALLAX_WATER 1\n\n// 0 = Antialias the water texture\n// 1 = Do not antialias the water texture\n#define FAST_CIRCLES 1\n\n//-----------------------------------------------------------------------------\n#define WATER3_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER4_COL vec3(0.0, 0.4180, 0.6758)\n\n#define WATER_COL vec3(0.374, 0.8453, 0.5305)\n#define WATER2_COL vec3(0.374, 0.8180, 0.4758)\n#define FOAM_COL vec3(0.5125, 0.9609, 0.9648)\n#define FOG_COL vec3(0.7006, 0.9453, 0.9336)\n#define SKY_COL vec3(0.0, 0.8203, 1.0)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n#if FAST_CIRCLES\n    return dot(c, c) < s ? -1.0 : 0.0;\n#else\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n#endif\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv, vec3 cdir)\n{\n    uv *= vec2(0.25);\n    \n#if PARALLAX_WATER\n    // Parallax height distortion with two directional waves at\n    // slightly different angles.\n    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset\n    float h = sin(uv.x + iTime); // Height at UV\n    uv += a * h;\n    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);\n    uv += a * h;\n#endif\n    \n#if DISTORT_WATER\n    // Texture distortion\n    float d1 = mod(uv.x + uv.y, M_2PI);\n    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);\n    d1 = iTime * 0.07 + d1;\n    d2 = iTime * 0.5 + d2;\n    vec2 dist = vec2(\n    \tsin(d1) * 0.15 + sin(d2) * 0.05,\n    \tcos(d1) * 0.15 + cos(d2) * 0.05\n    );\n#else\n    const vec2 dist = vec2(0.0);\n#endif\n    \n    vec3 ret = mix(WATER_COL, WATER2_COL, waterlayer(uv + dist.xy));\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 pixpos;\n    pixpos.xy = uv - 0.5;\n    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction\n    pixpos.z = -0.6; // Focal length (Controls field of view)\n    return normalize(pixpos);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if ANTIALIAS\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n        \tvec2 offset = vec2(0.5) * vec2(x, y) - vec2(0.25);\n#else\n        \tvec2 offset = vec2(0.0);\n#endif\n            // Camera stuff\n            vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n            vec3 cpos = vec3(0.0, 7.0, 10.0); // Camera position\n            vec3 cdir = pixtoray(uv);\n            cdir = quatmul( // Tilt down slightly\n                vec4(-0.19867, 0.0, 0.0, 0.980067), cdir);\n#if ANIMATE_CAM\n            // Rotating camera\n            float cost = cos(iTime * -0.05);\n            float sint = sin(iTime * -0.05);\n            cdir.xz = cost * cdir.xz + sint * vec2(-cdir.z, cdir.x);\n            cpos.xz = cost * cpos.xz + sint * vec2(-cpos.z, cpos.x);\n#endif\n\n            // Ray-plane intersection\n            const vec3 ocean = vec3(0.0, 1.0, 0.0);\n            float dist = -dot(cpos, ocean) / dot(cdir, ocean);\n            vec3 pos = cpos + dist * cdir;\n\n            vec3 pix;\n            if(dist > 0.0 && dist < 100.0) {\n                // Ocean\n                vec3 wat = water(pos.xz, cdir);\n                pix = mix(wat, FOG_COL, min(dist * 0.01, 1.0));\n            } else {\n                // Sky\n                pix = mix(FOG_COL, SKY_COL, min(cdir.y * 4.0, 1.0));\n            }\n#if ANTIALIAS\n        \tfragColor.rgb += pix * vec3(0.25);\n    \t}\n    }\n#else\n    fragColor.rgb = pix;\n#endif\n}"], ["// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Shader for https://www.youtube.com/watch?v=tfLku5IjUzE (cosmetics removed)\n\n// When a ray doesn't intersect a sphere, it still does it if one is\n// willing to take complex coordinates for the intersection points.\n// This shader shows where these complex intersections are in space,\n// for some arbitrary moving ray.\n\n\n//-------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return (d<m.x) ? vec2(d,a) : m;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n    \n    if( h>0.0 )\n    {\n        // real\n        h = sqrt(h);\n        p1 = vec4( ro + (-b+h)*rd, ro );\n        p2 = vec4( ro + (-b-h)*rd, ro );\n    }\n    else\n    {\n        // complex\n        h = sqrt(-h);\n        p1 = vec4( ro - b*rd, ro + h*rd );\n        p2 = vec4( ro - b*rd, ro - h*rd );\n    }\n}\n\n//-------------------------------------------------------------------\n\nvoid get_ray( out vec2 ro, out vec2 rd, in float t )\n{\n    float an = 3.1415927*(0.5 + 0.2*sin(t*0.735+4.0));\n    ro = vec2(-1.0*cos(t*0.525),-1.0+0.1*sin(t*1.5));\n    rd = vec2(cos(an),sin(an));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    p.y -= 0.4;\n\n\n    const float rad = 0.4;\n    const float cth = 0.03;\n    \n\n    // background\n    vec3 col = vec3(0.2 - 0.1*length(p*0.5));\n    \n    // circle\n    {\n    float d = sdCircle( p, vec2(0.0,0.0), rad );\n    col = mix( col, vec3(0.75), 1.0-smoothstep(0.0,0.01,abs(d)-0.005) );\n    }\n    \n    // trails\n    {\n        vec2 dr = vec2(1e20,1.0);\n        vec2 di = vec2(1e20,1.0);\n        vec4 op1;\n        vec4 op2;\n        const int num = 256;\n        for( int i=0; i<num; i++ )\n        {\n            float a = float(i)/float(num);\n\n            vec2 ro, rd; get_ray( ro, rd, iTime - 3.0*a );\n\n            vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n            \n            if( i>0 )\n            {\n            dr = opUnion(dr, min(sdLine( p, p1.xy, op1.xy ), sdLine( p, p2.xy, op2.xy )), a);\n            di = opUnion(di, min(sdLine( p, p1.zw, op1.zw ), sdLine( p, p2.zw, op2.zw )), a);\n            }\n\n            op1 = p1;\n            op2 = p2;\n        }\n        \n        col = mix( col, vec3(0.0,0.7,1.2), smoothstep(1.0,0.7,dr.y)*(1.0-smoothstep(0.0,0.01,dr.x)) );\n        col = mix( col, vec3(1.2,0.7,0.0), smoothstep(1.0,0.7,di.y)*(1.0-smoothstep(0.0,0.01,di.x)) );\n    }\n\n    vec2 ro, rd; get_ray( ro, rd, iTime );\n\n    // ray\n    {\n        {\n        float d = sdLine( p, ro-rd*10.0, ro+rd*10.0 );\n        col = mix( col, vec3(1.0), 0.25*(1.0-smoothstep(0.0,0.008,d)) );\n        }\n        \n        {\n        vec2 rdp = vec2(-rd.y,rd.x);\n        vec2 tip = ro+rd*0.2;\n        float d = sdLine( p, ro, tip );\n        \n        d = min( d, sdLine( p, tip, tip + 0.05*normalize( rdp-2.0*rd) ) );\n        d = min( d, sdLine( p, tip, tip + 0.05*normalize(-rdp-2.0*rd) ) );\n      //d = min( d, sdCircle( p, ro, cth ) );\n        col = mix( col, vec3(0.75), 1.0-smoothstep(0.005,0.01,d) );\n        }\n    }\n    \n    // intersections\n    {\n        vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n\n        float dr = min( sdCircle( p, p1.xy, cth ), sdCircle( p, p2.xy, cth ) );\n        float di = min( sdCircle( p, p1.zw, cth ), sdCircle( p, p2.zw, cth ) );\n        col = mix( col, vec3(0.0,0.7,1.2), 1.0-smoothstep(0.005,0.01,dr) );\n        col = mix( col, vec3(1.2,0.7,0.0), 1.0-smoothstep(0.005,0.01,di) );\n    }\n\n    // cheap dithering\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Shader for https://www.youtube.com/watch?v=tfLku5IjUzE (cosmetics removed)\n\n// When a ray doesn't intersect a sphere, it still does it if one is\n// willing to take complex coordinates for the intersection points.\n// This shader shows where these complex intersections are in space,\n// for some arbitrary moving ray.\n\n\n//-------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return (d<m.x) ? vec2(d,a) : m;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n    \n    if( h>0.0 )\n    {\n        // real\n        h = sqrt(h);\n        p1 = vec4( ro + (-b+h)*rd, ro );\n        p2 = vec4( ro + (-b-h)*rd, ro );\n    }\n    else\n    {\n        // complex\n        h = sqrt(-h);\n        p1 = vec4( ro - b*rd, ro + h*rd );\n        p2 = vec4( ro - b*rd, ro - h*rd );\n    }\n}\n\n//-------------------------------------------------------------------\n\nvoid get_ray( out vec2 ro, out vec2 rd, in float t )\n{\n    float an = 3.1415927*(0.5 + 0.2*sin(t*0.735+4.0));\n    ro = vec2(-1.0*cos(t*0.525),-1.0+0.1*sin(t*1.5));\n    rd = vec2(cos(an),sin(an));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    p.y -= 0.4;\n\n\n    const float rad = 0.4;\n    const float cth = 0.03;\n    \n\n    // background\n    vec3 col = vec3(0.2 - 0.1*length(p*0.5));\n    \n    // circle\n    {\n    float d = sdCircle( p, vec2(0.0,0.0), rad );\n    col = mix( col, vec3(0.75), 1.0-smoothstep(0.0,0.01,abs(d)-0.005) );\n    }\n    \n    // trails\n    {\n        vec2 dr = vec2(1e20,1.0);\n        vec2 di = vec2(1e20,1.0);\n        vec4 op1;\n        vec4 op2;\n        const int num = 256;\n        for( int i=0; i<num; i++ )\n        {\n            float a = float(i)/float(num);\n\n            vec2 ro, rd; get_ray( ro, rd, iTime - 3.0*a );\n\n            vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n            \n            if( i>0 )\n            {\n            dr = opUnion(dr, min(sdLine( p, p1.xy, op1.xy ), sdLine( p, p2.xy, op2.xy )), a);\n            di = opUnion(di, min(sdLine( p, p1.zw, op1.zw ), sdLine( p, p2.zw, op2.zw )), a);\n            }\n\n            op1 = p1;\n            op2 = p2;\n        }\n        \n        col = mix( col, vec3(0.0,0.7,1.2), smoothstep(1.0,0.7,dr.y)*(1.0-smoothstep(0.0,0.01,dr.x)) );\n        col = mix( col, vec3(1.2,0.7,0.0), smoothstep(1.0,0.7,di.y)*(1.0-smoothstep(0.0,0.01,di.x)) );\n    }\n\n    vec2 ro, rd; get_ray( ro, rd, iTime );\n\n    // ray\n    {\n        {\n        float d = sdLine( p, ro-rd*10.0, ro+rd*10.0 );\n        col = mix( col, vec3(1.0), 0.25*(1.0-smoothstep(0.0,0.008,d)) );\n        }\n        \n        {\n        vec2 rdp = vec2(-rd.y,rd.x);\n        vec2 tip = ro+rd*0.2;\n        float d = sdLine( p, ro, tip );\n        \n        d = min( d, sdLine( p, tip, tip + 0.05*normalize( rdp-2.0*rd) ) );\n        d = min( d, sdLine( p, tip, tip + 0.05*normalize(-rdp-2.0*rd) ) );\n      //d = min( d, sdCircle( p, ro, cth ) );\n        col = mix( col, vec3(0.75), 1.0-smoothstep(0.005,0.01,d) );\n        }\n    }\n    \n    // intersections\n    {\n        vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n\n        float dr = min( sdCircle( p, p1.xy, cth ), sdCircle( p, p2.xy, cth ) );\n        float di = min( sdCircle( p, p1.zw, cth ), sdCircle( p, p2.zw, cth ) );\n        col = mix( col, vec3(0.0,0.7,1.2), 1.0-smoothstep(0.005,0.01,dr) );\n        col = mix( col, vec3(1.2,0.7,0.0), 1.0-smoothstep(0.005,0.01,di) );\n    }\n\n    // cheap dithering\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Shader for https://www.youtube.com/watch?v=tfLku5IjUzE (cosmetics removed)\n\n// When a ray doesn't intersect a sphere, it still does it if one is\n// willing to take complex coordinates for the intersection points.\n// This shader shows where these complex intersections are in space,\n// for some arbitrary moving ray.\n\n\n//-------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    float h = max(m.x,-d);\n    return vec2( m.x + h, m.y + h*h*a );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n    \n    if( h>0.0 )\n    {\n        // real\n        h = sqrt(h);\n        p1 = vec4( ro + (-b+h)*rd, ro );\n        p2 = vec4( ro + (-b-h)*rd, ro );\n    }\n    else\n    {\n        // complex\n        h = sqrt(-h);\n        p1 = vec4( ro - b*rd, ro + h*rd );\n        p2 = vec4( ro - b*rd, ro - h*rd );\n    }\n}\n\n//-------------------------------------------------------------------\n\nvoid get_ray( out vec2 ro, out vec2 rd, in float t )\n{\n    float an = 3.1415927*(0.5 + 0.2*sin(t*0.735+4.0));\n    ro = vec2(-1.0*cos(t*0.525),-1.0+0.1*sin(t*1.5));\n    rd = vec2(cos(an),sin(an));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    p.y -= 0.4;\n\n\n    const float rad = 0.4;\n    const float cth = 0.03;\n    \n\n    // background\n    vec3 col = vec3(0.2 - 0.1*length(p*0.5));\n    \n    // circle\n    {\n    float d = sdCircle( p, vec2(0.0,0.0), rad );\n    col = mix( col, vec3(0.75), 1.0-smoothstep(0.0,0.01,abs(d)-0.005) );\n    }\n    \n    // trails\n    {\n        vec2 dr = vec2(1e20,1.0);\n        vec2 di = vec2(1e20,1.0);\n        vec4 op1;\n        vec4 op2;\n        const int num = 256;\n        for( int i=0; i<num; i++ )\n        {\n            float a = float(i)/float(num);\n\n            vec2 ro, rd; get_ray( ro, rd, iTime - 3.0*a );\n\n            vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n            \n            if( i>0 )\n            {\n            dr = opUnion(dr, min(sdLine( p, p1.xy, op1.xy ), sdLine( p, p2.xy, op2.xy )), a);\n            di = opUnion(di, min(sdLine( p, p1.zw, op1.zw ), sdLine( p, p2.zw, op2.zw )), a);\n            }\n\n            op1 = p1;\n            op2 = p2;\n        }\n        \n        col = mix( col, vec3(0.0,0.7,1.2), smoothstep(1.0,0.7,dr.y)*(1.0-smoothstep(0.0,0.01,dr.x)) );\n        col = mix( col, vec3(1.2,0.7,0.0), smoothstep(1.0,0.7,di.y)*(1.0-smoothstep(0.0,0.01,di.x)) );\n    }\n\n    vec2 ro, rd; get_ray( ro, rd, iTime );\n\n    // ray\n    {\n        {\n        float d = sdLine( p, ro-rd*10.0, ro+rd*10.0 );\n        col = mix( col, vec3(1.0), 0.25*(1.0-smoothstep(0.0,0.008,d)) );\n        }\n        \n        {\n        vec2 rdp = vec2(-rd.y,rd.x);\n        vec2 tip = ro+rd*0.2;\n        float d = sdLine( p, ro, tip );\n        \n        d = min( d, sdLine( p, tip, tip + 0.05*normalize( rdp-2.0*rd) ) );\n        d = min( d, sdLine( p, tip, tip + 0.05*normalize(-rdp-2.0*rd) ) );\n      //d = min( d, sdCircle( p, ro, cth ) );\n        col = mix( col, vec3(0.75), 1.0-smoothstep(0.005,0.01,d) );\n        }\n    }\n    \n    // intersections\n    {\n        vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n\n        float dr = min( sdCircle( p, p1.xy, cth ), sdCircle( p, p2.xy, cth ) );\n        float di = min( sdCircle( p, p1.zw, cth ), sdCircle( p, p2.zw, cth ) );\n        col = mix( col, vec3(0.0,0.7,1.2), 1.0-smoothstep(0.005,0.01,dr) );\n        col = mix( col, vec3(1.2,0.7,0.0), 1.0-smoothstep(0.005,0.01,di) );\n    }\n\n    // cheap dithering\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Shader for https://www.youtube.com/watch?v=tfLku5IjUzE (cosmetics removed)\n\n// When a ray doesn't intersect a sphere, it still does it if one is\n// willing to take complex coordinates for the intersection points.\n// This shader shows where these complex intersections are in space,\n// for some arbitrary moving ray.\n\n\n//-------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return (d<m.x) ? vec2(d,a) : m;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) p1 = p2 = vec4(0.0);\n    else\n    {\n        h = sqrt(h);\n        p1 = vec4( -b-h, 1.0 );\n        p2 = vec4( -b+h, 1.0 );\n    }\n}\n\n//-------------------------------------------------------------------\n\nvoid get_ray( out vec2 ro, out vec2 rd, in float t )\n{\n    float an = 3.1415927*(0.5 + 0.2*sin(t*0.735+4.0));\n    ro = vec2(-1.0*cos(t*0.525),-1.0+0.1*sin(t*1.5));\n    rd = vec2(cos(an),sin(an));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    p.y -= 0.4;\n\n\n    const float rad = 0.4;\n    const float cth = 0.03;\n    \n\n    // background\n    vec3 col = vec3(0.2 - 0.1*length(p*0.5));\n    \n    // circle\n    {\n    float d = sdCircle( p, vec2(0.0,0.0), rad );\n    col = mix( col, vec3(0.75), 1.0-smoothstep(0.0,0.01,abs(d)-0.005) );\n    }\n    \n    // trails\n    {\n        vec2 dr = vec2(1e20,1.0);\n        vec2 di = vec2(1e20,1.0);\n        vec4 op1;\n        vec4 op2;\n        const int num = 256;\n        for( int i=0; i<num; i++ )\n        {\n            float a = float(i)/float(num);\n\n            vec2 ro, rd; get_ray( ro, rd, iTime - 3.0*a );\n\n            vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n            \n            if( i>0 )\n            {\n            dr = opUnion(dr, min(sdLine( p, p1.xy, op1.xy ), sdLine( p, p2.xy, op2.xy )), a);\n            di = opUnion(di, min(sdLine( p, p1.zw, op1.zw ), sdLine( p, p2.zw, op2.zw )), a);\n            }\n\n            op1 = p1;\n            op2 = p2;\n        }\n        \n        col = mix( col, vec3(0.0,0.7,1.2), smoothstep(1.0,0.7,dr.y)*(1.0-smoothstep(0.0,0.01,dr.x)) );\n        col = mix( col, vec3(1.2,0.7,0.0), smoothstep(1.0,0.7,di.y)*(1.0-smoothstep(0.0,0.01,di.x)) );\n    }\n\n    vec2 ro, rd; get_ray( ro, rd, iTime );\n\n    // ray\n    {\n        {\n        float d = sdLine( p, ro-rd*10.0, ro+rd*10.0 );\n        col = mix( col, vec3(1.0), 0.25*(1.0-smoothstep(0.0,0.008,d)) );\n        }\n        \n        {\n        vec2 rdp = vec2(-rd.y,rd.x);\n        vec2 tip = ro+rd*0.2;\n        float d = sdLine( p, ro, tip );\n        \n        d = min( d, sdLine( p, tip, tip + 0.05*normalize( rdp-2.0*rd) ) );\n        d = min( d, sdLine( p, tip, tip + 0.05*normalize(-rdp-2.0*rd) ) );\n      //d = min( d, sdCircle( p, ro, cth ) );\n        col = mix( col, vec3(0.75), 1.0-smoothstep(0.005,0.01,d) );\n        }\n    }\n    \n    // intersections\n    {\n        vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n\n        float dr = min( sdCircle( p, p1.xy, cth ), sdCircle( p, p2.xy, cth ) );\n        float di = min( sdCircle( p, p1.zw, cth ), sdCircle( p, p2.zw, cth ) );\n        col = mix( col, vec3(0.0,0.7,1.2), 1.0-smoothstep(0.005,0.01,dr) );\n        col = mix( col, vec3(1.2,0.7,0.0), 1.0-smoothstep(0.005,0.01,di) );\n    }\n\n    // cheap dithering\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Approximating the SDF of the subtraction of two SDFs,\n// by finding the closest intersection between the two shapes.\n// Not working very well :(\n\n\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r ) \n{\n    vec2  d = p - c;\n    float l = length(d);\n    return vec3( l-r, d/l );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l: g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n//-----------------\n\n#define opSubtract(p,A,B)\\\n    /* regular subtraction */ \\\n    max(A.x,-B.x);\\\n    if( d>0.0 )\\\n    {\\\n        vec2 op = p;\\\n        /* find closest intersection of the two shapes */ \\\n        /* by recursively averaging the two closest points */ \\\n        for( int i=0; i<512; i++ ) \\\n        { \\\n            float d1=A.x; vec2 g1=A.yz; \\\n            float d2=B.x; vec2 g2=B.yz; \\\n            if( max(abs(d1),abs(d2))<0.001 ) break; \\\n            p -= 0.5*(d1*g1 + d2*g2); \\\n        } \\\n        /* distance to closest intersection*/ \\\n        float d3 = length(p-op);\\\n        /* decide whether we should update distance */ \\\n        vec2  g1 = A.yz;\\\n        vec2  g2 = B.yz;\\\n        float no = cro(g1,g2);\\\n        if( min(cro(op-p,g1)*no,cro(op-p,g2)*no)>0.0) d = d3;\\\n    }\n    \n\n\nfloat map( in vec2 p )\n{\n    vec2 off = 0.1*sin(iTime+vec2(0.0,2.0));\n\n    float d = opSubtract( p, sdgBox(p,vec2(0.3,0.6)), \n                             sdgCircle(p,vec2(0.0,0.2)+off,0.4) );\n    return d;\n}\n\nvec2 gra( in vec2 p )\n{\n    const float e = 0.0002;\n    return vec2(map(p+vec2(e,0.0))-map(p-vec2(e,0.0)),\n                map(p+vec2(0.0,e))-map(p-vec2(0.0,e)))/(2.0*e);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // distance\n    float d = map(p);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n\tcol *= 1.0 - exp2(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.002,0.005,abs(d)) );\n\n    // debug gradient\n    {\n    #if 0\n        vec2 g = gra(p);\n        col *= 1.0 + vec3(0.5*g,0.0);\n        float l = length(g);\n        if( l>1.01 ) col=vec3(1,0,0);\n        if( l<0.99 ) col=vec3(0,0,1);\n    #endif\n    }\n\n    // debug distance with mouse\n    if( iMouse.z>0.001 )\n    {\n    d = map(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Approximating the SDF of the subtraction of two SDFs,\n// by finding the closest intersection between the two shapes.\n// Not working very well :(\n\n\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r ) \n{\n    p -= c;\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  v = max(w,0.0);\n    float a = length(v);\n    float b = min(max(w.x,w.y),0.0);\n    return vec3(a+b,s*((g>0.0)?(a*g+b):vec2(dot(v,v),dot(p,v))));\n}\n\n\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n//-----------------\n\n#define opSubtract(p,A,B)\\\n    /* regular subtraction */ \\\n    max(A.x,-B.x);\\\n    if( d>0.0 )\\\n    {\\\n        vec2 op = p;\\\n        /* find closest intersection of the two shapes */ \\\n        /* by recursively averaging the two closest points */ \\\n        for( int i=0; i<512; i++ ) \\\n        { \\\n            float d1=A.x; vec2 g1=A.yz; \\\n            float d2=B.x; vec2 g2=B.yz; \\\n            if( max(abs(d1),abs(d2))<0.001 ) break; \\\n            p -= 0.5*(d1*g1 + d2*g2); \\\n        } \\\n        /* distance to closest intersection*/ \\\n        float d3 = length(p-op);\\\n        /* decide whether we should update distance */ \\\n        vec2  g1 = A.yz;\\\n        vec2  g2 = B.yz;\\\n        float no = cro(g1,g2);\\\n        if( min(cro(op-p,g1)*no,cro(op-p,g2)*no)>0.0) d = d3;\\\n    }\n    \n\n\nfloat map( in vec2 p )\n{\n    vec2 off = 0.1*sin(iTime+vec2(0.0,2.0));\n\n    float d = opSubtract( p, sdgBox(p,vec2(0.3,0.6)), \n                             sdgCircle(p,vec2(0.0,0.2)+off,0.4) );\n    return d;\n}\n\nvec2 gra( in vec2 p )\n{\n    const float e = 0.0002;\n    return vec2(map(p+vec2(e,0.0))-map(p-vec2(e,0.0)),\n                map(p+vec2(0.0,e))-map(p-vec2(0.0,e)))/(2.0*e);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // distance\n    float d = map(p);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n\tcol *= 1.0 - exp2(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.002,0.005,abs(d)) );\n\n    // debug gradient\n    {\n    #if 0\n        vec2 g = gra(p);\n        col *= 1.0 + vec3(0.5*g,0.0);\n        float l = length(g);\n        if( l>1.01 ) col=vec3(1,0,0);\n        if( l<0.99 ) col=vec3(0,0,1);\n    #endif\n    }\n\n    // debug distance with mouse\n    if( iMouse.z>0.001 )\n    {\n    d = map(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a heart. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//   https://iquilezles.org/articles/distgradfunctions2d\n// and\n//   https://www.shadertoy.com/playlist/M3dSRf\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart( in vec2 p )\n{\n    p.x *= 0.57735;\n    p.y *= 0.57735;\n    p.x += 0.5*p.y;\n\n    vec3 res = vec3(length(p),0.0,1.0);\n\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float c = 1.0-abs(cos(a));\n    float s = 1.0-abs(sin(a));\n    float t = 0.5*sqrt(2.0)*r;\n    float u = 0.5*sqrt(2.0)*r*c;\n    float v = 0.5*sqrt(2.0)*r*s;\n\n    res = min(res, vec3(t,0.0,1.0));\n    res = min(res, vec3(u,v,1.0));\n    res = min(res, vec3(v,u,1.0));\n\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    p.y += 0.5;\n    m.y += 0.5;\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgHeart(p);\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n \n    // interaction\n    if( iMouse.z>0.001 )\n    {\n        d = sdgHeart(m).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}"], ["// License: CC0\n\n#define pi 3.14159\n#define ss(a) smoothstep(-1./R.y, 1./R.y, .02 - length(u - a))\n\n// Spring easing function:\n// https://www.desmos.com/calculator/vluz5j0svo\n\n// Wobble both ways (green) \n// https://www.desmos.com/calculator/9atfimg1ox\n#define f(a,b,x) sign(cos(x)) \\\n              * (1. - exp(-(a) * abs(cos(x))) * cos((b) * abs(cos(x))))\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    // Multiply by square wave to flip-flop sign of wave\n    float s = sign(mod(x, 4.) - 2.); \n    \n    // Make x periodic\n    x = mod(x, 2.);\n    \n    // Clamp x so mix(f,g,v) is a quarter superellipse for 1 < x < 2\n    float v = min(1., x);\n    \n    // Spring equation\n    float f = 1. - exp(-a * x) * cos(b * x);\n    \n    // Half superellipse equation (n = 2. is circle)\n    float g = pow(1. - pow(1.-x, n), 1./n); \n    // g = sqrt(1. - (1.-x) * (1.-x));\n    \n    // Mix spring into circle, then mix with an equation which\n    // is vertical at 0 so that the start/end gradients \n    // match at x = 0, 2, 4 etc.\n    // (sloppy and expensive)\n    float l = mix(mix(f, g, v), \n                  1. - exp(-7. * sqrt(x)), \n                  1. - pow(v, .1)); \n    \n    return l * s;    \n}\n      \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float t = iTime;\n    \n    vec2 R = iResolution.xy,\n         u = (I-.5*R)/R.y,\n         p = vec2(.5 * f(5., 10., pi/2. * (t + 1.)), .1),\n         q = vec2(.5 * g(12., 20., 6., 16., .5 * t), 0),\n         r = vec2(.5 * h(8., 22., 4., t), -.1);\n         \n    O = vec4(ss(q), ss(p), ss(r), 0);\n}"], ["// License: CC0\n\n#define pi 3.14159\n#define ss(a) smoothstep(-1./R.y, 1./R.y, .02 - length(u - a))\n\n// Spring easing function:\n// https://www.desmos.com/calculator/vluz5j0svo\n\n// Wobble both ways (green) \n// https://www.desmos.com/calculator/9atfimg1ox\n#define f(a,b,x) sign(cos(x)) \\\n              * (1. - exp(-(a) * abs(cos(x))) * cos((b) * abs(cos(x))))\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    x = mod(x, 2.);\n    float f1 = 1. - exp(-a1 * x) * cos(b1 * x); \n    float f2 = exp(-a2 * (x-1.)) * cos(b2 * (x-1.));\n    f2 = mix(1., f2, step(1., x));\n    return 1. - 2. * f1 * f2;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n  return pow(pow(abs(x), n) + pow(abs(a * sin(b * x)), n), 1.0 / n);\n}\n      \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float t = iTime;\n    \n    vec2 R = iResolution.xy,\n         u = (I-.5*R)/R.y,\n         p = vec2(.5 * f(5., 10., pi/2. * (t + 1.)), .1),\n         q = vec2(.5 * g(12., 20., 6., 16., .5 * t), 0),\n         r = vec2(.5 * h(8., 22., 4., t), -.1);\n         \n    O = vec4(ss(q), ss(p), ss(r), 0);\n}"], ["//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C=vec2(1./6.,1./3.);\n    const vec4 D=vec4(0.,.5,1.,2.);\n    \n    // First corner\n    vec3 i=floor(v+dot(v,C.yyy));\n    vec3 x0=v-i+dot(i,C.xxx);\n    \n    // Other corners\n    vec3 g=step(x0.yzx,x0.xyz);\n    vec3 l=1.-g;\n    vec3 i1=min(g.xyz,l.zxy);\n    vec3 i2=max(g.xyz,l.zxy);\n    \n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1=x0-i1+C.xxx;\n    vec3 x2=x0-i2+C.yyy;// 2.0*C.x = 1/3 = C.y\n    vec3 x3=x0-D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y\n    \n    // Permutations\n    i=mod289(i);\n    vec4 p=permute(permute(permute(\n                i.z+vec4(0.,i1.z,i2.z,1.))\n                +i.y+vec4(0.,i1.y,i2.y,1.))\n                +i.x+vec4(0.,i1.x,i2.x,1.));\n                \n                // Gradients: 7x7 points over a square, mapped onto an octahedron.\n                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n                float n_=.142857142857;// 1.0/7.0\n                vec3 ns=n_*D.wyz-D.xzx;\n                \n                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,7*7)\n                \n                vec4 x_=floor(j*ns.z);\n                vec4 y_=floor(j-7.*x_);// mod(j,N)\n                \n                vec4 x=x_*ns.x+ns.yyyy;\n                vec4 y=y_*ns.x+ns.yyyy;\n                vec4 h=1.-abs(x)-abs(y);\n                \n                vec4 b0=vec4(x.xy,y.xy);\n                vec4 b1=vec4(x.zw,y.zw);\n                \n                //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n                //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n                vec4 s0=floor(b0)*2.+1.;\n                vec4 s1=floor(b1)*2.+1.;\n                vec4 sh=-step(h,vec4(0.));\n                \n                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n                \n                vec3 p0=vec3(a0.xy,h.x);\n                vec3 p1=vec3(a0.zw,h.y);\n                vec3 p2=vec3(a1.xy,h.z);\n                vec3 p3=vec3(a1.zw,h.w);\n                \n                //Normalise gradients\n                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n                p0*=norm.x;\n                p1*=norm.y;\n                p2*=norm.z;\n                p3*=norm.w;\n                \n                // Mix final noise value\n                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n                m=m*m;\n                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),\n                dot(p2,x2),dot(p3,x3)));\n            }\n            \n            float fbm(vec3 p){\n                float value=0.;\n                float amplitude=1.;\n                // float frequency=1.;\n                float frequency=.025;\n                float lacunarity=2.;\n                float persistance=.5;\n                // float scale=1.;\n                float scale=.5;\n                int octaves=8;\n                \n                for(int i=0;i<octaves;i++){\n                    float noiseVal=snoise(p*frequency*scale);\n                    \n                    value+=amplitude*noiseVal;\n                    frequency*=lacunarity;\n                    amplitude*=persistance;\n                }\n                \n                return value;\n            }\n            \n            // inspired from: https://www.shadertoy.com/view/fsjyR3\n            float paperNoise(vec2 uv){\n                float noise = 0.0;\n                float scale = 1.0;\n                for(int i = 0; i < 8; i++){\n                    noise += texture(iResolution, uv * scale).x;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n            \n            void mainImage(out vec4 fragColor,in vec2 fragCoord){\n                vec2 uv=fragCoord/iResolution.xy;\n                vec3 col=vec3(.8);\n                float noise=paperNoise(uv*iResolution.xy)*.3;\n                col+=noise;\n                fragColor=vec4(col,1.);\n            }"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The shader I used while designing the Human Shader experiment\n//\n// https://humanshader.com\n\nint shift( int x, int n )\n{\n    if( n==1 ) { return (x+5)/10; }\n    if( n==2 ) { return (x+50)/100; }\n    if( n==3 ) { return (x+500)/1000; }\n                 return (x+5000)/10000;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 p = vec3(x,y,0);\n    vec3 q = vec3(x,y,0);\n    vec3 r = vec3(x,y,0);\n    vec3 s = vec3(x,y,0);\n    vec3 t = vec3(x,y,0);\n    vec3 u = vec3(x,y,0);\n    vec3 v = vec3(x,y,0);\n    vec3 w = vec3(x,y,0);\n    vec3 x = vec3(x,y,0);\n    vec3 y = vec3(x,y,0);\n    vec3 z = vec3(x,y,0);\n    vec3 a = vec3(x,y,0);\n    vec3 b = vec3(x,y,0);\n    vec3 c = vec3(x,y,0);\n    vec3 d = vec3(x,y,0);\n    vec3 e = vec3(x,y,0);\n    vec3 f = vec3(x,y,0);\n    vec3 g = vec3(x,y,0);\n    vec3 h = vec3(x,y,0);\n    vec3 i = vec3(x,y,0);\n    vec3 j = vec3(x,y,0);\n    vec3 k = vec3(x,y,0);\n    vec3 l = vec3(x,y,0);\n    vec3 m = vec3(x,y,0);\n    vec3 n = vec3(x,y,0);\n    vec3 o = vec3(x,y,0);\n    vec3 p = vec3(x,y,0);\n    vec3 q = vec3(x,y,0);\n    vec3 r = vec3(x,y,0);\n    vec3 s = vec3(x,y,0);\n    vec3 t = vec3(x,y,0);\n    vec3 u = vec3(x,y,0);\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 resolution = vec2(71,40);\n\n    ivec2 ij = ivec2(floor(resolution*fragCoord/iResolution.xy));\n    \n    vec3 col = compute( ij.x, 39-ij.y );\n    \n    // draw grid lines\n    {\n    ivec2 ijp = ivec2(floor(resolution*(fragCoord-vec2(1,1))/iResolution.xy));\n    ivec2 ijn = ivec2(floor(resolution*(fragCoord+vec2(1,1))/iResolution.xy));\n    if( ijn.x!=ij.x || ijn.y!=ij.y || ijp.x!=ij.x || ijp.y!=ij.y) col*=0.75;\n    }\n    \n    fragColor = vec4( col/255.0, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction\n//\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and https://iquilezles.org/articles/intersectors\n//\n// Other cylinder functions:\n//   Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n//   Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n//   Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction.\n//\n// Arguments:\n//     - ro: The origin of the ray being cast.\n//     - rd: The direction of the ray being cast.\n//     - pa: One endpoint of the cylinder's axis.\n//     - pb: The other endpoint of the cylinder's axis.\n//     - ra: Cylinder's radius.\n//\n// Returns vec4:\n//     - x: -1 if no hit, otherwise the distance from the ray to the hit point.\n//     - yzw: Hit surface's normal.\nvec4 iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra ) \n{\n    // Vector from point A to point B, defining the cylinder's main axis\n    vec3  ba = pb - pa;\n    // Vector from ray origin (ro) to point A on the cylinder\n    vec3  oc = ro - pa;\n    \n    // Dot product of ba with itself, representing the squared length of the cylinder's axis\n    float baba = dot(ba,ba);\n    // Dot product of ba with ray direction (rd), representing alignment of ray with cylinder's axis\n    float bard = dot(ba,rd);\n    // Dot product of ba with oc, representing alignment of the cylinder's axis with the vector to the ray origin\n    float baoc = dot(ba,oc);\n    \n    // Quadratic coefficients for solving ray-cylinder intersection\n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    /*\n    // In case you really need to handle parallel raycasts.\n    if( k2==0.0 )\n    {\n        // Handle the case where the ray is parallel to the cylinder's axis.\n\n        // If this special case is detected (i.e., k2 == 0.0), calculate intersections with the two endpoints of the\n        // cylinder and verify that the intersection is within the cylinder's radius. If so, it returns the intersection\n        // point and surface normal information. If not, it returns -1.0, indicating no intersection.\n        \n        // Parameters for intersection with the two endpoints of the cylinder.\n        float ta = -dot(ro-pa,ba)/bard;\n        float tb = ta + baba/bard;\n        \n        // Determining the intersection point based on ray direction.\n        vec4 pt = (bard>0.0) ? vec4(pa,-ta) : vec4(pb,tb);\n        \n        // Calculating the offset from the intersection point to determine if the intersection is within the cylinder's radius.\n        vec3 q = ro + rd*abs(pt.w) - pt.xyz;\n        if( dot(q,q)>ra*ra ) return vec4(-1.0);\n        \n        // Returning the intersection point and surface normal information.\n        return vec4( abs(pt.w), sign(pt.w)*ba/sqrt(baba) );\n    }\n    */\n    \n    // Discriminant of the quadratic equation; determines whether there is an intersection.\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); // No intersection.\n    h = sqrt(h);\n    float t = (-k1-h)/k2; // The \"t\" value where the intersection occurs.\n    \n    // Checking intersection with the body of the cylinder.\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return vec4( t, (oc+t*rd - ba*y/baba)/ra );\n    \n    // Checking intersection with the end caps of the cylinder.\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h ) return vec4( t, ba*sign(y)/sqrt(baba) );\n    \n    return vec4(-1.0); // No intersection.\n}\n\n\n// Get the normal of a cylinder's body from a point on the surface.\n//\n// Arguments:\n//     - p: Point on the cylinder body.\n//     - 'a' and 'b': Points along the axis of the cylinder, defining its direction.\n//     - 'ra': The radius of the cylinder.\n//\n// Returns the cylinder body's normal.\n//\nvec3 nCylinder( in vec3 p, in vec3 a, in vec3 b, in float ra )\n{\n    // 'pa' is the vector from point 'a' to the point 'p' where we want to find the normal.\n    vec3  pa = p - a;\n\n    // 'ba' is the vector from point 'a' to point 'b', defining the direction of the cylinder's axis.\n    vec3  ba = b - a;\n\n    // 'baba' is the squared length of vector 'ba', used to normalize 'ba'.\n    float baba = dot(ba,ba);\n\n    // 'paba' is the projection of 'pa' onto 'ba', giving us the portion of 'pa' that is parallel to the cylinder's axis.\n    float paba = dot(pa,ba);\n\n    // Subtracting the projected vector (ba * paba / baba) from 'pa' gives us the vector perpendicular to the axis, \n    // pointing towards the surface of the cylinder from 'p'. Dividing by 'ra' scales it to the normal direction.\n    return (pa - ba*paba/baba)/ra;\n}\n\n\n// Same as above, but specialized to the Y axis.\n//\n// Arguments:\n//     - ro: The origin of the ray being cast.\n//     - rd: The direction of the ray being cast.\n//     - he: Cylinder's height.\n//     - ra: Cylinder's radius.\n//\n// Returns vec4:\n//     - x: -1 if no hit, otherwise the distance from the ray to the hit point.\n//     - yzw: Hit surface's normal.\n//\nvec4 iCylinderVertical( in vec3 ro, in vec3 rd, float he, float ra )\n{\n    // Quadratic coefficients for ray-cylinder intersection with a vertical axis.\n    float k2 = 1.0        - rd.y*rd.y;\n    float k1 = dot(ro,rd) - ro.y*rd.y;\n    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;\n\n    // Discriminant of the quadratic equation; determines whether there is an intersection.\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); // No intersection.\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // Checking intersection with the body of the cylinder.\n    float y = ro.y + t*rd.y;\n    if( y>-he && y<he ) return vec4( t, (ro + t*rd - vec3(0.0,y,0.0))/ra );\n\n    // Checking intersection with the end caps of the cylinder.\n    t = ( ((y<0.0)?-he:he) - ro.y)/rd.y;\n    if( abs(k1+k2*t)<h ) return vec4( t, vec3(0.0,sign(y),0.0) );\n\n    return vec4(-1.0); // No intersection\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 10.0;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = 1.0 - abs(f.x - 0.5);\n    float b = 1.0 - abs(f.y - 0.5);\n    float c = 1.0 - max(a, b);\n    col = vec3(a, b, c);\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define camera rotation and position.\n    float an = 0.5*iTime;\n    vec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    // Create camera's orthonormal basis (u,v,w).\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n\n    // Anti-aliasing loop (if AA > 1).\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // Subpixel sampling.\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // Create view ray.\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // Define cylinder.\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n\n        // Initialize background color.\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // Cylinder-ray intersection.\n        vec4 tnor = iCylinder( ro, rd, capA, capB, capR );\n        if( tnor.x>0.0 )\n        {\n            // Compute shading, texture, and lighting if intersection occurred.\n\n            // SHADING\n            // Calculating the position and normal at the intersection.\n            float t = tnor.x;\n            vec3  pos = ro + t*rd;\n            vec3  nor = tnor.yzw;\n\n            // LIGHTING\n            // Define the light direction and halfway vector.\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n\n            // Calculate the diffuse and ambient components using dot products.\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 ); // Diffuse lighting\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 ); // Ambient lighting\n            float occ = 0.5 + 0.5*nor.y; // Occlusion factor, contributes to ambient shading\n\n            // TEXTURING\n            // Coordinate transformation for texture mapping on the cylinder.\n            vec3 w = normalize(capB-capA);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-capA)*mat3(u,v,w);\n            col = pattern( vec2(12.0,64.0)*vec2(atan(q.y,q.x),q.z) ); // Apply texture pattern.\n\n            // Combine shading, texturing, and lighting\n            col *= vec3(0.2,0.3,0.4)*amb*occ + vec3(1.0,0.9,0.7)*dif; // Apply ambient and diffuse components.\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif; // Apply specular reflection.\n        }\n        col = sqrt( col );\n\n        // Accumulate color.\n        tot += col;\n    #if AA>1\n    }\n    // Average color for anti-aliasing.\n    tot /= float(AA*AA);\n    #endif\n\n    // Add dithering to remove banding in the background.\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    // Output final color.\n    fragColor = vec4( tot, 1.0 );\n}\n"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}                    \n\n/*\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q); // distance\n    vec2  g = q/d;       // gradient\n    return p-(d-th)*g; // closest point\n} \n*/\n\n// distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    return length(q) - th;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.1,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    vec2 v1 = 0.7*cos( 0.5*iTime*vec2(1.3,1.0) + vec2(2,4) );\n    vec2 v2 = 0.7*cos( 0.5*iTime*vec2(0.9,1.2) + vec2(1,5) );\n    float th = 0.2*(0.7+0.3*sin(iTime*1.2+2.0));\n\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdSegment(p,v1,v2,th);\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdSegment(m,v1,v2,th); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloSegment(m,v1,v2,th); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  c = a + h*ba;\n    return c + th*normalize(p-c);\n}                    \n\n/*\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q); // distance\n    vec2  g = q/d;       // gradient\n    return p-(d-th)*g; // closest point\n} \n*/\n\n// distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.1,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    vec2 v1 = 0.7*cos( 0.5*iTime*vec2(1.3,1.0) + vec2(2,4) );\n    vec2 v2 = 0.7*cos( 0.5*iTime*vec2(0.9,1.2) + vec2(1,5) );\n    float th = 0.2*(0.7+0.3*sin(iTime*1.2+2.0));\n\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdSegment(p,v1,v2,th);\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdSegment(m,v1,v2,th); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloSegment(m,v1,v2,th); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r )\n{\n    return p - clamp( p, -b, b ) + clamp( abs( p ) - b, -r, r );\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    vec2  w = abs(p)-b;\n    float g = max(w.x,w.y);\n    return ((g>0.0)?length(max(w,0.0)):g) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.2,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    const vec2  bs = vec2(0.7,0.3);\n    const float ra = 0.2;\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdRoundBox(p,bs,ra); \n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdRoundBox(m,bs,ra); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloRoundBox(m,bs,ra); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r )\n{\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    vec2 w = abs(p) - b;\n    if( max(w.x,w.y)>0.0 )\n    {\n        vec2  q = max(w,0.0);\n        float l = length(q);\n        p -= s*(l-r)*q/l;\n    }\n    else\n    {\n        if( w.x>w.y ) p.x = s.x*(b.x+r);\n        else          p.y = s.y*(b.y+r);\n    }\n    return p;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n  vec2 q = abs(p) - b;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.2,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    const vec2  bs = vec2(0.7,0.3);\n    const float ra = 0.2;\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdRoundBox(p,bs,ra); \n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdRoundBox(m,bs,ra); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloRoundBox(m,bs,ra); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Closest point on box\n//\n//   For points inside the box where 3 or 4 closest points exist (p.y=0 or p.x=0) or \n//   where 2 solutions exit (the diagonals |p.x-p.y|=|b.x-b.y|, you need to take\n//   extra precautions, for example:\n//\n//   if( g<0.0 )\n//   {\n//     if( w.x==w.y ) return vec2(1e20);                                          // 2 solutions\n//     if( (b.x>b.y) && abs(p.x)<=(b.x-b.y) && abs(p.y)==0.0 ) return vec2(1e20); // 3 solutions\n//     if( (b.x<b.y) && abs(p.y)<=(b.y-b.x) && abs(p.x)==0.0 ) return vec2(1e20); // 3 solutions\n//   }\n//\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\nvec2 cloBox( in vec2 p, in vec2 b )\n{\n    vec2   s = sign(p);\n    vec2   w = abs(p) - b;\n    float  g = max(w.x,w.y);\n    float  m = min(0.0,g);\n    return p - vec2(w.x>=m?w.x:0.0,w.y>=m?w.y:0.0)*s;\n}\n\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.2,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n    \n    vec2 b1 = vec2(0.7,0.5);\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdBox(p,b1); \n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdBox(m,b1); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloBox(m,b1); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n"], ["// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nint getDigits(float f, int digc, int index) {\n    // Note: For 32-bit floats, the precision is typically up to about 7 decimal places.\n    // Exceeding this may lead to accuracy issues.\n    // 1. Multiply the float by a power of 10 to shift the desired digits to the integer part.\n    //    This depends on both the desired number of digits (dig) and the offset (id).\n    f = f * pow(10., float(digc + index));\n    // 2. Convert the float to an integer to discard any fractional part.\n    // 3. Return the last 'dig' digits of the integer.\n    return int(f) % int(pow(10., float(digc)));\n}\n\nbool inRange(float v, float min, float max) {\n    return v > min && v < max;\n}\n\nbool inRange(int v, int min, int max) {\n    return v > min && v < max;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord=floor(fragCoord/8.+(iTime*8.));\n    \n    float f = hash12(fragCoord);\n    \n    const int ans0 = 123;\n    const int ans1 = 456;\n    const int ans2 = 789;\n    \n    int digt = getDigits(f, 3, 1);\n    \n    if(ans0==digt)\n        fragColor = vec4(1,0,0,1);\n    else\n    if(ans1==digt)\n        fragColor = vec4(0,1,0,1);\n    else\n    if(ans2==digt)\n        fragColor = vec4(0,0,1,1);\n    else\n    if(inRange(digt, ans2-5, ans2+5))\n        fragColor = vec4(1,1,0,1);\n    else\n    fragColor = vec4(f*.0125);\n    \n    fragColor = pow(fragColor,vec4(.4545));\n}"], ["/*\n * Copyright 2014 Roman Bobniev (FatumR)\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define OCTAVES  8.0\n\n#define LIVE_SMOKE 1\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Rough Value noise implementation\nfloat valueNoiseSimple(vec2 vl) {\n    float n = 0.0;\n    n += texture2D(noiseTexture, vl).x;\n    n += texture2D(noiseTexture, vl + vec2(1.0, 0.0)).x;\n    n += texture2D(noiseTexture, vl + vec2(0.0, 1.0)).x;\n    n += texture2D(noiseTexture, vl + vec2(1.0, 1.0)).x;\n    return n / 4.0;\n}\n\nfloat getLowFreqs()\n{\n    const int NUM_FREQS = 32;\n    /* Close to the spectrum of the voice frequencies for this song. */\n    const float lowStart = 0.65;\n    const float lowEnd = 0.75;\n    float result = 0.0;\n    \n    for (int i = 0; i < NUM_FREQS; i++)\n    {\n        result += texture(iChannel0,\n                            vec2(lowStart + (lowEnd - lowStart)*float(i)/float(NUM_FREQS - 1),\n                                 0.25)).x;\n    }\n\n    return smoothstep(0.0, 1.0, (result / float(NUM_FREQS)) * 2.);\n}\n\nfloat fractalNoise(vec2 vl) {\n    float persistance = 2.0;\n    float amplitude = 0.5;\n    float rez = 0.0;\n    vec2 p = vl;\n    \n    for (float i = 0.0; i < OCTAVES; i++) {\n        rez += amplitude * valueNoiseSimple(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez;\n}\n\nfloat complexFBM(vec2 p) {\n    float sound = getLowFreqs();\n    float slow = iTime / 2.5;\n    float fast = iTime / .5;\n    vec2 offset1 = vec2(slow  , 0.); // Main front\n    vec2 offset2 = vec2(sin(fast )* 0.1, 0.); // sub fronts\n\n    return \n#if LIVE_SMOKE\n        (1. + sound) * \n#endif\n        fractalNoise( p + offset1 + fractalNoise(\n            \tp + fractalNoise(\n                \tp + 2. * fractalNoise(p - offset2)\n            \t)\n        \t)\n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec3 blueColor = vec3(0.07,0.2,.5);\n    vec3 orangeColor2 = vec3(0, 0, 0);\n    \n    vec3 rez = mix(orangeColor2, blueColor, complexFBM(uv));\n    \n    fragColor = vec4(rez, 1.0);\n    \n}"], ["/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n// Swap with other noise implementations to check for differences\n// (best seen when VIEW is set to fbm). The novel implementations\n// are triValueNoise and triGradNoise\n#define NOISE triValueNoise\n//#define NOISE triGradNoise\n//#define NOISE quadValueNoise\n//#define NOISE quadGradNoise\n\n#define VIEW pattern\n//#define VIEW fbm\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Your average 4-point value noise implementation\nfloat quadValueNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn \n        mix\n        (\n            mix(random(b),        random(b + d.yx), f.x), \n            mix(random(b + d.xy), random(b + d.yy), f.x), \n            f.y\n        );\n}\n\n// Your average 4-point, Perlin-like noise implementation\nfloat quadGradNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 r = fract(n);\n    vec2 l = floor(n);\n    vec2 f = r*r*(3.0-2.0*r);\n\treturn \n        .5+.5*mix\n        (\n            mix\n            (\n                dot(random2(l), r),        \n                dot(random2(l + d.yx), r-d.yx), \n                f.x\n            ), \n            mix\n            (\n                dot(random2(l + d.xy), r-d.xy), \n                dot(random2(l + d.yy), r-d.yy), \n                f.x\n            ), \n            f.y\n        );\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = random(l+s*e.yx);\n    float b = random(l+s*e.yx+e.xy);\n    float c = random(l+s*e.xy+(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    r *= r*(3.-2.*r); // Same cubic profile as smoothstep\n    return mix(mix(a, b, r.x), c, r.y);\n}\n\n// Same as before but using gradients, much smoother\nfloat triGradNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = dot(random2(l+s*e.yx), r-s*e.yx);\n    float b = dot(random2(l+s*e.yx+e.xy), r-s*e.yx-e.xy);\n    float c = dot(random2(l+s*e.xy+(1.-s)*e.yx), r-s*e.xy-(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    // Quintic profile to have null second derivate at \n    // boundaries\n    r *= 6.*r*r*r*r-15.*r*r*r+10.*r*r; \n    return .5+.5*mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float n = 0.;\n    float A = 0.;\n    vec2 af = vec2(1., 2.);\n    for (int i=0; i<4; i++)\n    {\n        // Rotate each octave\n        float s = sin(float(2*i));\n        float c = cos(float(2*i));\n        mat2 m = mat2(c, s, -s, c);\n        n += af.x*NOISE(af.y*m*x);\n        A += af.x;\n        af *= vec2(.4,2.);\n    }\n    return n/A;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    vec2 a = vec2(fbm(x)+iTime/15., fbm(x+vec2(2.2,0.)));\n    float b = fbm(x+a+iTime/10.);\n    vec2 c = vec2(fbm(x+b), fbm(a-vec2(1.7,0.)));\n    return fbm(x+.5*c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/10.));\n    fragColor = vec4(vec3(VIEW(2.*uv+d)), 1.);\n}"], ["/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n// Swap with other noise implementations to check for differences\n// (best seen when VIEW is set to fbm). The novel implementations\n// are triValueNoise and triGradNoise\n#define NOISE triValueNoise\n//#define NOISE triGradNoise\n//#define NOISE quadValueNoise\n//#define NOISE quadGradNoise\n\n#define VIEW pattern\n//#define VIEW fbm\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(138912.*sin(dot(x, vec2(138.9, 191.2))));\n}\n\n// From iq\nvec2 random2(vec2 st){\n  st = vec2( dot(st,vec2(127.1,311.7)),\n            dot(st,vec2(269.5,183.3)) );\n  return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Your average 4-point value noise implementation\nfloat quadValueNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn \n        mix\n        (\n            mix(random(b),        random(b + d.yx), f.x), \n            mix(random(b + d.xy), random(b + d.yy), f.x), \n            f.y\n        );\n}\n\n// Your average 4-point, Perlin-like noise implementation\nfloat quadGradNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 r = fract(n);\n    vec2 l = floor(n);\n    vec2 f = r*r*(3.0-2.0*r);\n\treturn \n        .5+.5*mix\n        (\n            mix\n            (\n                dot(random2(l), r),        \n                dot(random2(l + d.yx), r-d.yx), \n                f.x\n            ), \n            mix\n            (\n                dot(random2(l + d.xy), r-d.xy), \n                dot(random2(l + d.yy), r-d.yy), \n                f.x\n            ), \n            f.y\n        );\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = random(l+s*e.yx);\n    float b = random(l+s*e.yx+e.xy);\n    float c = random(l+s*e.xy+(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    r *= r*(3.-2.*r); // Same cubic profile as smoothstep\n    return mix(mix(a, b, r.x), c, r.y);\n}\n\n// Same as before but using gradients, much smoother\nfloat triGradNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = dot(random2(l+s*e.yx), r-s*e.yx);\n    float b = dot(random2(l+s*e.yx+e.xy), r-s*e.yx-e.xy);\n    float c = dot(random2(l+s*e.xy+(1.-s)*e.yx), r-s*e.xy-(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    // Quintic profile to have null second derivate at \n    // boundaries\n    r *= 6.*r*r*r*r-15.*r*r*r+10.*r*r; \n    return .5+.5*mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float n = 0.;\n    float A = 0.;\n    vec2 af = vec2(1., 2.);\n    for (int i=0; i<4; i++)\n    {\n        // Rotate each octave\n        float s = sin(float(2*i));\n        float c = cos(float(2*i));\n        mat2 m = mat2(c, s, -s, c);\n        n += af.x*NOISE(af.y*m*x);\n        A += af.x;\n        af *= vec2(.4,2.);\n    }\n    return n/A;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    vec2 a = vec2(fbm(x)+iTime/15., fbm(x+vec2(2.2,0.)));\n    float b = fbm(x+a+iTime/10.);\n    vec2 c = vec2(fbm(x+b), fbm(a-vec2(1.7,0.)));\n    return fbm(x+.5*c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/10.));\n    fragColor = vec4(vec3(VIEW(2.*uv+d)), 1.);\n}"], ["/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n// Swap with other noise implementations to check for differences\n// (best seen when VIEW is set to fbm). The novel implementations\n// are triValueNoise and triGradNoise\n#define NOISE triValueNoise\n//#define NOISE triGradNoise\n//#define NOISE quadValueNoise\n//#define NOISE quadGradNoise\n\n#define VIEW pattern\n//#define VIEW fbm\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(138912.*sin(dot(x, vec2(138.9, 191.2))));\n}\n\n// From iq\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Your average 4-point value noise implementation\nfloat quadValueNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn \n        mix\n        (\n            mix(random(b),        random(b + d.yx), f.x), \n            mix(random(b + d.xy), random(b + d.yy), f.x), \n            f.y\n        );\n}\n\n// Your average 4-point, Perlin-like noise implementation\nfloat quadGradNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 r = fract(n);\n    vec2 l = floor(n);\n    vec2 f = r*r*(3.0-2.0*r);\n\treturn \n        .5+.5*mix\n        (\n            mix\n            (\n                dot(random2(l), r),        \n                dot(random2(l + d.yx), r-d.yx), \n                f.x\n            ), \n            mix\n            (\n                dot(random2(l + d.xy), r-d.xy), \n                dot(random2(l + d.yy), r-d.yy), \n                f.x\n            ), \n            f.y\n        );\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // fade factors\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // noise contributions from the four corners\n    float n =\n        mix(mix(noise(i + vec2(0.0, 0.0)), noise(i + vec2(1.0, 0.0)), u.x),\n            mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), u.x), u.y);\n\n    return n;\n}\n\n// Same as before but using gradients, much smoother\nfloat triGradNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = dot(random2(l+s*e.yx), r-s*e.yx);\n    float b = dot(random2(l+s*e.yx+e.xy), r-s*e.yx-e.xy);\n    float c = dot(random2(l+s*e.xy+(1.-s)*e.yx), r-s*e.xy-(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    // Quintic profile to have null second derivate at \n    // boundaries\n    r *= 6.*r*r*r*r-15.*r*r*r+10.*r*r; \n    return .5+.5*mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float n = 0.;\n    float A = 0.;\n    vec2 af = vec2(1., 2.);\n    for (int i=0; i<4; i++)\n    {\n        // Rotate each octave\n        float s = sin(float(2*i));\n        float c = cos(float(2*i));\n        mat2 m = mat2(c, s, -s, c);\n        n += af.x*NOISE(af.y*m*x);\n        A += af.x;\n        af *= vec2(.4,2.);\n    }\n    return n/A;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    vec2 a = vec2(fbm(x)+iTime/15., fbm(x+vec2(2.2,0.)));\n    float b = fbm(x+a+iTime/10.);\n    vec2 c = vec2(fbm(x+b), fbm(a-vec2(1.7,0.)));\n    return fbm(x+.5*c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/10.));\n    fragColor = vec4(vec3(VIEW(2.*uv+d)), 1.);\n}"], ["/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n// Swap with other noise implementations to check for differences\n// (best seen when VIEW is set to fbm). The novel implementations\n// are triValueNoise and triGradNoise\n#define NOISE triValueNoise\n//#define NOISE triGradNoise\n//#define NOISE quadValueNoise\n//#define NOISE quadGradNoise\n\n#define VIEW pattern\n//#define VIEW fbm\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(138912.*sin(dot(x, vec2(138.9, 191.2))));\n}\n\n// From iq\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Your average 4-point value noise implementation\nfloat quadValueNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn \n        mix\n        (\n            mix(random(b),        random(b + d.yx), f.x), \n            mix(random(b + d.xy), random(b + d.yy), f.x), \n            f.y\n        );\n}\n\n// Your average 4-point, Perlin-like noise implementation\nfloat quadGradNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 r = fract(n);\n    vec2 l = floor(n);\n    vec2 f = r*r*(3.0-2.0*r);\n\treturn \n        .5+.5*mix\n        (\n            mix\n            (\n                dot(random2(l), r),        \n                dot(random2(l + d.yx), r-d.yx), \n                f.x\n            ), \n            mix\n            (\n                dot(random2(l + d.xy), r-d.xy), \n                dot(random2(l + d.yy), r-d.yy), \n                f.x\n            ), \n            f.y\n        );\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = random(l+s*e.yx);\n    float b = random(l+s*e.yx+e.xy);\n    float c = random(l+s*e.xy+(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    r *= r*(3.-2.*r); // Same cubic profile as smoothstep\n    return mix(mix(a, b, r.x), c, r.y);\n}\n\n// Same as before but using gradients, much smoother\nfloat triGradNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = dot(random2(l+s*e.yx), r-s*e.yx);\n    float b = dot(random2(l+s*e.yx+e.xy), r-s*e.yx-e.xy);\n    float c = dot(random2(l+s*e.xy+(1.-s)*e.yx), r-s*e.xy-(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    // Quintic profile to have null second derivate at \n    // boundaries\n    r *= 6.*r*r*r*r-15.*r*r*r+10.*r*r; \n    return .5+.5*mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 1; i++)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    vec2 a = vec2(fbm(x)+iTime/15., fbm(x+vec2(2.2,0.)));\n    float b = fbm(x+a+iTime/10.);\n    vec2 c = vec2(fbm(x+b), fbm(a-vec2(1.7,0.)));\n    return fbm(x+.5*c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/10.));\n    fragColor = vec4(vec3(VIEW(2.*uv+d)), 1.);\n}"], ["/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n// Swap with other noise implementations to check for differences\n// (best seen when VIEW is set to fbm). The novel implementations\n// are triValueNoise and triGradNoise\n#define NOISE triValueNoise\n//#define NOISE triGradNoise\n//#define NOISE quadValueNoise\n//#define NOISE quadGradNoise\n\n#define VIEW pattern\n//#define VIEW fbm\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(138912.*sin(dot(x, vec2(138.9, 191.2))));\n}\n\n// From iq\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Your average 4-point value noise implementation\nfloat quadValueNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn \n        mix\n        (\n            mix(random(b),        random(b + d.yx), f.x), \n            mix(random(b + d.xy), random(b + d.yy), f.x), \n            f.y\n        );\n}\n\n// Your average 4-point, Perlin-like noise implementation\nfloat quadGradNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 r = fract(n);\n    vec2 l = floor(n);\n    vec2 f = r*r*(3.0-2.0*r);\n\treturn \n        .5+.5*mix\n        (\n            mix\n            (\n                dot(random2(l), r),        \n                dot(random2(l + d.yx), r-d.yx), \n                f.x\n            ), \n            mix\n            (\n                dot(random2(l + d.xy), r-d.xy), \n                dot(random2(l + d.yy), r-d.yy), \n                f.x\n            ), \n            f.y\n        );\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = random(l+s*e.yx);\n    float b = random(l+s*e.yx+e.xy);\n    float c = random(l+s*e.xy+(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    r *= r*(3.-2.*r); // Same cubic profile as smoothstep\n    return mix(mix(a, b, r.x), c, r.y);\n}\n\n// Same as before but using gradients, much smoother\nfloat triGradNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = dot(random2(l+s*e.yx), r-s*e.yx);\n    float b = dot(random2(l+s*e.yx+e.xy), r-s*e.yx-e.xy);\n    float c = dot(random2(l+s*e.xy+(1.-s)*e.yx), r-s*e.xy-(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    // Quintic profile to have null second derivate at \n    // boundaries\n    r *= 6.*r*r*r*r-15.*r*r*r+10.*r*r; \n    return .5+.5*mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float n = 0.;\n    float A = 0.;\n    vec2 af = vec2(1., 2.);\n    for (int i=0; i<4; i++)\n    {\n        // Rotate each octave\n        float s = sin(float(2*i));\n        float c = cos(float(2*i));\n        mat2 m = mat2(c, s, -s, c);\n        n += af.x*NOISE(af.y*m*x);\n        A += af.x;\n        af *= vec2(.4,2.);\n    }\n    return n/A;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    float s = 0.0;\n    float a = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        s += cos(x + a);\n        a += 1.0;\n    }\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/10.));\n    fragColor = vec4(vec3(VIEW(2.*uv+d)), 1.);\n}"], ["/*\n\nThis shader visualises the relative solid angle of the texels\nof the face of a cubemap (compared to the center texel).\n\nA very simple approximation is proposed. The approximation is\ntoo crude for very low resolutions, but beyond 8x8 it seems\nto result in under 1% error.\n\nMaybe a fitting or offset could correct the error for the\nvery low resolutions as well?\n\n\nTop center: texels of the cubemap face.\nBottom left: relative solid angle of the texels.\nBottom right: approximation of the relative solid angle.\nCenter: (200x exaggerated) error of the approximation.\n\nThe bottom histogram shows the error accross the diagonal, on\na squeezed scale. The short dashed graduations indicate the\n0.125%, 0.25%, 0.5%, 1% and 2% error. The longer dashed\ngraduations indicate the 10%, 20%, 40% and 80% error.\n\nLicense: CC BY 4.0\n\n-- \nZavie\n*/\n\nfloat approximateRelativeSolidAngle(vec2 uv, float resolution)\n{\n    vec2 p = uv * 2. - 1.;\n\n#if 0\n    // Verbose version:\n\n    // The more off-center the texel, the further the distance.\n    // So we scale by the inverse square distance.\n    float invSqrDist = 1. / (dot(p, p) + 1.);\n\n    // The more off-center the texel, the more it's facing away.\n    // So we scale by the cosine.\n    float cos_factor = 1. / sqrt(dot(p, p) + 1.);\n\n    // Combine the two factors:\n    return invSqrDist * cos_factor;\n#else\n    // Short version:\n\n    // After derivation, the whole thing becomes just\n    float sqrDist = dot(p, p) + 1.;\n    return 1. / sqrt(sqrDist * sqrDist * sqrDist);\n#endif\n}\n\n//\n// areaElement and texelSolidAngle are adapted from\n// AMD cubemapgen source code:\n// https://code.google.com/archive/p/cubemapgen/\n//\n// See the derivation here:\n// https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n//\nfloat areaElement(float x, float y)\n{\n    float theta = atan(x, y);\n    float phi = acos(y / sin(theta));\n    return (sin(theta) * cos(phi) + sin(theta) * sin(phi) + cos(theta)) / 6.0;\n}\n\nfloat texelSolidAngle(vec2 uv, float resolution)\n{\n    vec2 p = uv * 2. - 1.;\n\n    float invResolution = 1. / resolution;\n \n    // p is the -1..1 texture coordinate on the current face.\n    // Get projected area for this texel\n    vec2 pmin = p - invResolution;\n    vec2 pmax = p + invResolution;\n    float solidAngle = (\n        areaElement(pmin.x, pmin.y) -\n        areaElement(pmin.x, pmax.y) -\n        areaElement(pmax.x, pmin.y) +\n        areaElement(pmax.x, pmax.y));\n \n    return solidAngle;\n}\n\nfloat exactRelativeSolidAngle(vec2 uv, float resolution)\n{\n    return texelSolidAngle(uv, resolution) / texelSolidAngle(vec2(0.5), resolution);\n}\n\n// ----------------------------------------------------------\n\nvec2 remap(vec2 a, vec2 b, vec2 u)\n{\n    return (u - a) / (b - a);\n}\n\nvec2 getMask(vec2 uv)\n{\n    vec2 du = 2.*vec2(dFdx(uv.x), dFdy(uv.y));\n    return smoothstep(vec2(0.), du, uv) * (1. - smoothstep(vec2(1.) - du, vec2(1.), uv));\n}\n\nvec2 getRectangle(vec2 uv, float x, float y, float width, float height)\n{\n    vec2 p = vec2(x, y);\n    vec2 size = vec2(width, height);\n    return remap(p - size/2., p + size/2., uv);\n}\n\nvec2 getSquare(vec2 uv, float x, float y, float size)\n{\n    vec2 p = vec2(x, y);\n    return remap(p - size/2., p + size/2., uv);\n}\n\nvec2 discretise(vec2 uv, float resolution)\n{\n    return (floor(uv * resolution) + 0.5) / resolution;\n}\n\nvec3 errorToColor(float error)\n{\n    // Colours picked from:\n    // https://www.kennethmoreland.com/color-advice/\n    // The publication explains how to properly interpolate,\n    // but I was too lazy to implement it.\n    vec3 midPoint = vec3(0.865, 0.865, 0.865);\n    vec3 positive = vec3(0.230, 0.299, 0.754);\n    vec3 negative = vec3(0.706, 0.016, 0.150);\n\n    if (error > 0.)\n    {\n        if (error <= 1.)\n            return mix(midPoint, positive, error);\n        // Saturate to blue above 1:\n        return vec3(0., 0., 1.);\n    }\n    else\n    {\n        if (error >= -1.)\n            return mix(midPoint, negative, -error);\n        // Saturate to red below -1:\n        return vec3(1., 0., 0.);\n    }\n}\n\nfloat logScale(float x)\n{\n    float scale = 9.;\n    return (exp(scale * x) - 1.) / (exp(scale) - 1.);\n}\n\nvec4 errorHistogram(vec2 uvPlot, vec2 uvFace, float error)\n{\n    float x = uvPlot.x;\n    float dx = dFdy(x);\n    float y = logScale(uvPlot.y);\n    float dy = dFdy(y);\n    vec4 color = vec4(errorToColor(0.), 0.1);\n    if (error > 0.)\n    {\n        float e = (error);\n        color = mix(color, vec4(errorToColor(200. * error), 1.), smoothstep(y, y + dy, e));\n    }\n    else if (error < 0.)\n    {\n        float e = (-error);\n        color = mix(color, vec4(errorToColor(200. * -error), 1.), smoothstep(y, y + dy, e));\n    }\n\n    // Draw graduations at 0.125%, 0.25%, 0.5%, 1% and 2%\n    for (float graduation = 0.00125; graduation <= 0.02; graduation *= 2.)\n    {\n        float line = smoothstep(y - dy, y, graduation) * (1. - smoothstep(y, y + dy, graduation));\n        float dotted = fract(100. * x);\n        float dottedLine = line * smoothstep(0., dx, dotted) * (1. - smoothstep(0.75, 0.75 + dx, dotted));\n        color = mix(color, vec4(1. - color.rgb, 1.), 0.5*dottedLine);\n    }\n\n    // Draw graduations at 10%, 20%, 40% and 80%\n    for (float graduation = 0.1; graduation < 1.0; graduation *= 2.0)\n    {\n        float line = smoothstep(y - dy, y, graduation) * (1. - smoothstep(y, y + dy, graduation));\n        float dotted = fract(25. * x);\n        float dottedLine = line * smoothstep(0., dx, dotted) * (1. - smoothstep(0.85, 0.85 + dx, dotted));\n        color = mix(color, vec4(1. - color.rgb, 1.), 0.5*dottedLine);\n    }\n\n    return color;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float evolution = abs(fract(iTime * 0.05) * 2. - 1.);\n    float cubeMapResolution = pow(2., 1. + floor(evolution * 10.));\n\n    vec2 uv = fragCoord/iResolution.x;\n    vec3 color = vec3(0.2);\n\n    // Visualise the texels depending on the cubemap resolution\n    {\n        vec2 uvFace = getSquare(uv, 0.5, 0.45, 0.22);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        vec3 texels = vec3(uvFace, 0.);\n        color = mix(color, texels, mask.x * mask.y);\n    }\n\n    // Visualise the texel relative solid angle\n    {\n        vec2 uvFace = getSquare(uv, 0.2, 0.32, 0.35);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float ersa = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        color = mix(color, vec3(ersa), mask.x * mask.y);\n    }\n\n    // Visualise the approximated texel relative solid angle\n    {\n        vec2 uvFace = getSquare(uv, 1. - 0.2, 0.32, 0.35);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        color = mix(color, vec3(arsa), mask.x * mask.y);\n    }\n\n    // Visualise the difference between the texel relative\n    // solid angle and the approximation\n    {\n        vec2 uvFace = getSquare(uv, 0.5, 0.22, 0.22);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa2 = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        float ersa2 = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        float error = ersa2 - arsa2;\n        color = mix(color, errorToColor(200. * error), mask.x * mask.y);\n    }\n    \n    // Visualise more precisely the error across the diagonal\n    {\n        vec2 uvPlot = getRectangle(uv, 0.5, 0.05, 1., 0.1);\n        vec2 mask5 = getMask(uvPlot);\n        vec2 uvFace = vec2(uvPlot.x);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa2 = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        float ersa2 = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        float error = ersa2 - arsa2;\n\n        vec4 histogram = errorHistogram(uvPlot, uvFace, error);\n        color = mix(color, histogram.rgb, mask5.x * mask5.y * histogram.a);\n    }\n\n    fragColor = vec4(color, 1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2024 Giorgi Azmaipharashvili\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031,.11369,.13787));\n  p3 += dot(p3, p3.yxz + 19.19);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(1.0 / 3.0)));\n\t vec3 x = p - s + dot(s, vec3(1.0 / 6.0));\n\t vec3 e = step(vec3(0), x - x.yzx);\n\t vec3 i1 = e * (1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\t vec3 x1 = x - i1 + 1.0 / 6.0;\n\t vec3 x2 = x - i2 + 1.0 / 3.0;\n\t vec3 x3 = x - 0.5;\n\t vec4 w = max(0.6 - vec4(dot(x, x), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\t w *= w;\n\t return dot(vec4(dot(hash33(s), x), \n                     dot(hash33(s + i1), x1), \n                     dot(hash33(s + i2), x2),  \n                     dot(hash33(s + 1.0), x3)) * w * w, vec4(52));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    float time = iTime * 2.0;\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / mr * 0.5;\n    vec2 p = vec2(0.5) + normalize(uv) * min(length(uv), 0.05);\n    vec3 p3 = 13.0 * vec3(p.xy, 0) + vec3(0, 0, time * 0.025);\n    float noise = simplex3d(p3 * 32.0) * 0.5 + 0.5;\n    float dist = abs(clamp(length(uv) / 12.0, 0.0, 1.0) * noise * 2.0 - 1.0);\n    const float e = 0.3;\n    float stepped = smoothstep(e - 0.5, e + 0.5, noise * (1.0 - pow(dist, 4.0)));\n    float final = smoothstep(e - 0.05, e + 0.05, noise * stepped);\n\tfragColor = vec4(vec3(final),1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2024 Giorgi Azmaipharashvili\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx) - 0.5;\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p) {\n    vec3 f = floor(p);\n    vec3 s = f + dot(f, vec3(1.0, 3.0, 5.0)) * (1.0 / 9.0);\n    vec3 u = p - f;\n    vec3 v = u - 1.0 + 2.0 * fract(s * vec3(7.0, 15.0, 31.0));\n    vec3 d = abs(v);\n    vec3 g = min(min(v.xzx, v.yxy), v.zzy) > 0.5? 1.0 - d : d;\n    vec3 h = 0.5 + min(min(g.xzx, g.yxy), g.zzy);\n    vec3 a = max(h, 0.0);\n    vec3 b = a * a;\n    vec3 c = b * a;\n    vec3 i = mod(s, 6.0);\n    vec3 j = mod(i + vec3(1.0, 2.0, 1.0), 6.0);\n    vec3 k = mod(i + vec3(2.0, 1.0, 2.0), 6.0);\n    vec3 m = 0.5 * (i - j * (2.0 / 3.0) + 1.0) + f;\n    vec3 n = 0.5 * (i - k * (2.0 / 3.0) + 1.0) + f;\n    vec3 o = m + (j - i) * (1.0 / 3.0);\n    vec3 p = n + (k - i) * (1.0 / 3.0);\n    vec3 x = max(0.5 - vec3(dot(u, u), dot(v, v), dot(g, g)), 0.0);\n    vec3 y = x * x// incomplete generation!\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    float time = iTime * 2.0;\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / mr * 0.5;\n    vec2 p = vec2(0.5) + normalize(uv) * min(length(uv), 0.05);\n    vec3 p3 = 13.0 * vec3(p.xy, 0) + vec3(0, 0, time * 0.025);\n    float noise = simplex3d(p3 * 32.0) * 0.5 + 0.5;\n    float dist = abs(clamp(length(uv) / 12.0, 0.0, 1.0) * noise * 2.0 - 1.0);\n    const float e = 0.3;\n    float stepped = smoothstep(e - 0.5, e + 0.5, noise * (1.0 - pow(dist, 4.0)));\n    float final = smoothstep(e - 0.05, e + 0.05, noise * stepped);\n\tfragColor = vec4(vec3(final),1.0);\n}"], ["// The MIT License\n// Copyright \u00a9 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Analytic derivatives for a simple field of random Gabor kernels\n\n// please never use this hash or any other fract based\n// hash in production. they are really bad.\nvec2 hash( in vec2 x )   \n{\n    return fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))));\n}\n\nvec3 gabor_wave(in vec2 p)\n{    \n    vec2  ip = floor(p);\n    vec2  fp = fract(p);\n    \n    const float fr = 2.0*6.283185;\n    const float fa = 4.0;\n    \n    vec3 av = vec3(0.0,0.0,0.0);\n    vec3 at = vec3(0.0,0.0,0.0);\n\tfor( int j=-2; j<=2; j++ ) // can reduce this search to just [-1,1] \n    for( int i=-2; i<=2; i++ ) // if you are okey with some small errors\n\t{\t\t\n        vec2  o = vec2( i, j );\n        vec2  h = hash(ip+o);\n        vec2  r = fp - (o+h);\n\n        vec2  k = normalize(-1.0+2.0*hash(ip+o+vec2(11,31)) );\n\n        float d = dot(r, r);\n        float l = dot(r, k);\n        float w = exp(-fa*d);\n        vec2 cs = vec2( cos(fr*l), sin(fr*l) );\n        \n        av += w*vec3(cs.x, -2.0*fa*r*cs.x - cs.y*fr*k );\n        at += w*vec3(1.0,  -2.0*fa*r);\n\t}\n  //return av;\n    return vec3( av.x, av.yz-av.x*at.yz/at.x  ) /at.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n\n    vec3 f = gabor_wave(8.0*p);\n\n    vec3 col = vec3(0.5 + 0.5*f.x);\n    if( p.y<0.5 )\n    {\n        // show analytical derivatives\n        col = 0.5 + 0.01*vec3(f.yz*8.0,0.0);\n        \n        // show low quality numerical derivatives (check correctness)\n        //col = 0.5 + 0.01*vec3(dFdx(f.x)*iResolution.y, dFdy(f.x)*iResolution.y, 0.0 );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}"], ["// The MIT License\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Using Newtown's root solver to compute the distance to\n// an ellipse, instead of using the analytical solution in\n// https://www.shadertoy.com/view/4sS3zz.\n//\n// In retrospect, it's the same as Antonalog's https://www.shadertoy.com/view/MtXXW7\n//\n// More information here:\n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat sdEllipse( vec2 p, vec2 a, vec2 b )\n{\n    // do transformations and get the minor/major radii\n    float la = length(a);\n    float lb = length(b);\n    p *= mat2(a/la, b/lb);\n    vec2 ab = vec2(la, lb);\n    \n    // everything past this point is by iq\n    \n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 a = vec2(sin(iTime*2.5)*0.1 + 0.5, 0);\n    vec2 b = vec2(0, sin(iTime*1.5)*0.1 + 0.5);\n    a *= rot(iTime*0.25);\n    b *= rot(iTime*0.25);\n    if(iMouse.z > 0.001)\n    {\n        a = m;\n        b = (normalize(a)*(sin(iTime*1.5)*0.1+0.5))*rot(1.57);\n    }\n\t\n\tfloat d = sdEllipse( p, a, b );\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    // added these lines to show the vectors\n    col = mix( col, vec3(1.0, 1.0, 0.0), 1.0-smoothstep(0.0,0.01,sdSegment(p, vec2(0), a)) );\n    col = mix( col, vec3(0.0, 1.0, 1.0), 1.0-smoothstep(0.0,0.01,sdSegment(p, vec2(0), b)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}"], ["// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// I'm starting with 2D but should scale up to 3D no problem\n// This demonstrates having different radius ratios\n// I need this for my SDF CAD stuff\n\n\n// Most mininal example. You see it stretches the circle.\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(vec2(p.x / 2., p.y))-r;\n}\n\n// Derived from the SDF box video from IQ.  The max(r.y/r.x, 1.) is my stuff\nfloat sdBox1(in vec2 p, in vec2 r) {\n  return sqrt(pow(max((p.x-r.x)*max(r.y/r.x, 1.), 0.0),2.) + pow(max((p.y-r.y)*max(r.x/r.y, 1.),0.0),2.));\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdBox(p * 10., vec2(1.0, 1.0), vec2(4.00, 1.00)) / 10.;\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdBox(p * 10., vec2(1.0, 1.0), vec2(4.00, 1.00)) / 10.;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}"], ["// Forked from https://www.shadertoy.com/view/ll3Xzf\n// Original license text:\n\n// The MIT License\n// Copyright \u00a9 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Disk projection code (project_disk()) is by me and is CC0.\n// Currently, there's some float instability near grazing angles.\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://en.wikipedia.org/wiki/Ellipse#General_ellipse\nvoid project_disk(\n    vec3 center,\n    vec3 normal,\n    float radius,\n    vec2 proj_info,\n    out vec2 proj_center,\n    out vec2 major,\n    out vec2 minor\n){\n    vec3 proj_normal = normalize(normal);\n    vec3 proj_center_vec = center - proj_normal * proj_info.x;\n    vec3 proj_major = normalize(cross(proj_normal, vec3(0.0, 1.0, 0.0)));\n    vec3 proj_minor = normalize(cross(proj_normal, proj_major));\n    proj_center = vec2(dot(proj_center_vec, proj_major), dot(proj_center_vec, proj_minor));\n    major = vec2(radius * dot(proj_major, proj_major), radius * dot(proj_major, proj_minor));\n    minor = vec2(radius * dot(proj_minor, proj_major), radius * dot(proj_minor, proj_minor));\n}\n\n// ray-disk intersection\nfloat iDisk( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 cen, in vec3 nor, float rad ) // disk: center, normal, radius\n{\n\tvec3  q = ro - cen;\n    float t = -dot(nor,q)/dot(rd,nor);\n    if( t<0.0 ) return -1.0;\n    vec3 d = q + rd*t;\n    if( dot(d,d)>(rad*rad) ) return -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n\n    vec2 p = (fragCoord.xy/iResolution.xy) * 2.0f - 1.0f;\n    float aspect = iResolution.x / iResolution.y;\n    p.x *= aspect;\n\n\n    // camera position\n\tvec3 ro = vec3( 0,0,1.5 );\n\t// create view ray\n\tvec3 rd = normalize(vec3(p.xy, -1.5) );\n\n    // disk animation\n\tvec3  disk_center = 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n\tvec3  disk_axis = normalize( sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0)) );\n    float disk_radius = 0.4 + 0.2*sin(iTime*1.3+0.5);\n\n\n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace disk\n    float t = iDisk( ro, rd, disk_center, disk_axis, disk_radius );\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3)*(0.7+0.2*abs(disk_axis.y));\n\t}\n\n    tot += col;\n\n    float proj_plane_dist = 1.5 * aspect * 0.5f;\n    vec2 proj_info = vec2(proj_plane_dist, proj_plane_dist);\n    vec2 proj_center;\n    vec2 major;\n    vec2 minor;\n    project_disk(\n        disk_center-ro,\n        disk_axis,\n        disk_radius,\n        proj_info,\n        proj_center,\n        major,\n        minor\n    );\n\n    vec2 nmajor = normalize(major);\n    vec2 nminor = normalize(minor);\n\n    // Paint major axis point\n    if(distance(p, proj_center + major) < 0.015f)\n        tot = vec3(0,1,0);\n\n    // Paint major axis line\n    if(distance(p, proj_center + dot(p-proj_center, nmajor) * nmajor) < 0.005f && abs(dot(p-proj_center, nmajor)) < length(major))\n        tot = vec3(0,1,0);\n\n    // Paint minor axis point\n    if(distance(p, proj_center + minor) < 0.015f)\n        tot = vec3(0,0,1);\n\n    // Paint minor axis line\n    if(distance(p, proj_center + dot(p-proj_center, nminor) * nminor) < 0.005f && abs(dot(p-proj_center, nminor)) < length(minor))\n        tot = vec3(0,0,1);\n\n    // Paint center of projected ellipse\n    if(distance(p, proj_center) < 0.015f)\n        tot = vec3(1,0,0);\n\n\tfragColor = vec4( tot, 1.0 );\n}"], ["/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A simple christmas tree made from 2D points.\n*\n*/\n\n#define PI 3.1415926535\n#define TAU 6.2831853071\n#define ROTATE(v, x) mat2(cos(x), sin(x), -sin(x), cos(x)) * v\n#define REMAP_HALF_NDC(x, c, d) (((x + 0.5) * (d - c)) + c) // Remap from [-0.5, 0.5] domain to [c, d]\n\n#define N 512.0\n#define N_ONE_QUARTER N * 0.25\n// This is mostly to cull any points at the bottom that are too close to the \"camera\".\n#define N_OFFSET 1.0\n#define STAR_N 7.0\n#define STAR_BEAM_THICKNESS 3.0\n\nconst vec3 LIGHT_COLORS[3] = vec3[3](\n                                        vec3(1.0,  0.05,  0.05), \n                                        vec3(0.05, 1.0,   0.05), \n                                        vec3(1.0,  0.25,  0.05)\n                                    );\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m) // m=[2,n]\n{\n    float en = PI / m;\n    vec2  ecs = vec2(cos(en), sin(en));\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nvoid DrawStar(in vec2 uv, in float time, inout vec3 outColor)\n{\n    uv -= vec2(0.001, 0.225);\n    uv = ROTATE(uv, time * 0.75);\n    // Some common pre-calculation in order to avoid duplication\n    float an = PI / STAR_N;\n    float bn = mod(atan(uv.x, uv.y), 2.0 * an) - an;\n    vec2 acs = vec2(cos(an), sin(an));\n    // Top star\n    outColor += 5e-4 / pow(abs(SignedDistanceNStar2D(uv, 0.01, an, bn, acs, STAR_N * 0.5)), 1.23) * LIGHT_COLORS[2];\n    // Star beams\n    outColor += smoothstep(STAR_BEAM_THICKNESS / max(iResolution.x, iResolution.y), 0.0, SignedDistanceNStar2D(uv, 1.5, an, bn, acs, STAR_N)) * \n        LIGHT_COLORS[2] * smoothstep(0.75, -5.0, length(uv));\n}\n\nvoid DrawTree(in vec2 uv, in float time, inout vec3 outColor)\n{\n    float u, theta, pointHeight, invN = 1.0 / N;\n    vec2 st, hash, layer;\n    vec3 pointOnCone, pointColor = vec3(1.0);\n    const vec2 radius = vec2(1.5, 3.2);\n    uvec3 colorThreshold;\n    for (float i = N_OFFSET; i < N; ++i)\n    {\n        // Modify this to change the tree pattern\n        hash = Hash21(2.0 * TAU * i);\n        \n        // Some basic light color based on hash\n        colorThreshold.x = uint(hash.x < 0.45); // red;\n        colorThreshold.y = 1u - colorThreshold.x; // green\n        colorThreshold.z = uint(hash.x > 0.9); // white;\n        pointColor = vec3(colorThreshold | colorThreshold.z);\n        \n        // Calculate point on cone based on: https://mathworld.wolfram.com/Cone.html\n        u = i * invN;\n        theta = 1609.0 * hash.x + time * 0.5;\n        pointHeight = 1.0 - u;\n        \n        // Split the cone into layers to make it look more like a christmas tree\n        layer = vec2(3.2 * mod(i, N_ONE_QUARTER) * invN, 0.0);\n        pointOnCone = 0.5 * (radius.xyx - layer.xyx) * vec3(pointHeight * cos(theta), u - 0.5, pointHeight * sin(theta)); // [-0.5, 0.5]\n        \n        // Scale uv based on depth of the point\n        st = uv * (REMAP_HALF_NDC(pointOnCone.z, 0.5, 1.0) + hash.y) * 4.5;\n        \n        // outColor += smoothstep(0.01, 0.0, length(st - pointOnCone.xy));\n        outColor += REMAP_HALF_NDC(pointOnCone.z, 3.0, 0.6) * // Slightly adjust the size of the point based on distance to \"camera\" \n            2e-5 / pow(length(st - pointOnCone.xy), 1.7) * pointColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // [-0.5, 0.5] adjusted for aspect ratio\n    vec3 outColor = vec3(0.005, 0.01, 0.03); // Background color\n    vec4 m = iMouse / iResolution.yyyy;\n    float t = 0.0;\n    \n    if (m.z > 0.0)\n    {\n        t = m.x * TAU;\n    }\n    else\n    {\n        t = iTime * 0.5;\n    }\n    \n    DrawTree(uv, t, outColor);\n    DrawStar(uv, t, outColor);\n    \n    float vignette = dot(uv, uv);\n    vignette *= vignette;\n    vignette = 1.0 / (vignette * vignette + 1.0);\n    \n    fragColor = vec4(pow(outColor * vignette, vec3(0.4545)), 1.0) - Hash12(fragCoord.xy * t + iResolution.yy) * 0.04;\n}"], ["/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A simple christmas tree made from 2D points.\n*\n*/\n\n#define PI 3.1415926535\n#define TAU 6.2831853071\n#define ROTATE(v, x) mat2(cos(x), sin(x), -sin(x), cos(x)) * v\n#define REMAP_HALF_NDC(x, c, d) (((x + 0.5) * (d - c)) + c) // Remap from [-0.5, 0.5] domain to [c, d]\n\n#define N 512.0\n#define N_ONE_QUARTER N * 0.25\n// This is mostly to cull any points at the bottom that are too close to the \"camera\".\n#define N_OFFSET 1.0\n#define STAR_N 7.0\n#define STAR_BEAM_THICKNESS 3.0\n\nconst vec3 LIGHT_COLORS[3] = vec3[3](\n                                        vec3(1.0,  0.05,  0.05), \n                                        vec3(0.05, 1.0,   0.05), \n                                        vec3(1.0,  0.25,  0.05)\n                                    );\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m) // m=[2,n]\n{\n    float n = 1.0/bn;\n    float a = an*n;\n    float c = cos(a);\n    float s = sin(a);\n    mat2  m1 = mat2(c,-s,s,c);\n    mat2  m2 = mat2(c,s,-s,c);\n    vec2  q = m1*p;\n    float k = abs(q.x)/r;\n    float ax = acs.x*n;\n    float ay = acs.y*n;\n    float k2 = (k*k);\n    float d = abs(q.y) - (r*abs(cos(ax*k2 + ay)));\n    float sd = d*sign(q.y);\n    float d2 = abs(q.y) - (r*abs(cos(ax*k2 + ay + 1.57079632679489661923)));\n    float sd2 = d2*sign(q.y);\n    sd = min(sd,sd2);\n    sd = min(sd,abs(q.x)-r);\n    sd = min(sd,abs(q.y)-r);\n    return sd;\n}\n\nvoid DrawStar(in vec2 uv, in float time, inout vec3 outColor)\n{\n    uv -= vec2(0.001, 0.225);\n    uv = ROTATE(uv, time * 0.75);\n    // Some common pre-calculation in order to avoid duplication\n    float an = PI / STAR_N;\n    float bn = mod(atan(uv.x, uv.y), 2.0 * an) - an;\n    vec2 acs = vec2(cos(an), sin(an));\n    // Top star\n    outColor += 5e-4 / pow(abs(SignedDistanceNStar2D(uv, 0.01, an, bn, acs, STAR_N * 0.5)), 1.23) * LIGHT_COLORS[2];\n    // Star beams\n    outColor += smoothstep(STAR_BEAM_THICKNESS / max(iResolution.x, iResolution.y), 0.0, SignedDistanceNStar2D(uv, 1.5, an, bn, acs, STAR_N)) * \n        LIGHT_COLORS[2] * smoothstep(0.75, -5.0, length(uv));\n}\n\nvoid DrawTree(in vec2 uv, in float time, inout vec3 outColor)\n{\n    float u, theta, pointHeight, invN = 1.0 / N;\n    vec2 st, hash, layer;\n    vec3 pointOnCone, pointColor = vec3(1.0);\n    const vec2 radius = vec2(1.5, 3.2);\n    uvec3 colorThreshold;\n    for (float i = N_OFFSET; i < N; ++i)\n    {\n        // Modify this to change the tree pattern\n        hash = Hash21(2.0 * TAU * i);\n        \n        // Some basic light color based on hash\n        colorThreshold.x = uint(hash.x < 0.45); // red;\n        colorThreshold.y = 1u - colorThreshold.x; // green\n        colorThreshold.z = uint(hash.x > 0.9); // white;\n        pointColor = vec3(colorThreshold | colorThreshold.z);\n        \n        // Calculate point on cone based on: https://mathworld.wolfram.com/Cone.html\n        u = i * invN;\n        theta = 1609.0 * hash.x + time * 0.5;\n        pointHeight = 1.0 - u;\n        \n        // Split the cone into layers to make it look more like a christmas tree\n        layer = vec2(3.2 * mod(i, N_ONE_QUARTER) * invN, 0.0);\n        pointOnCone = 0.5 * (radius.xyx - layer.xyx) * vec3(pointHeight * cos(theta), u - 0.5, pointHeight * sin(theta)); // [-0.5, 0.5]\n        \n        // Scale uv based on depth of the point\n        st = uv * (REMAP_HALF_NDC(pointOnCone.z, 0.5, 1.0) + hash.y) * 4.5;\n        \n        // outColor += smoothstep(0.01, 0.0, length(st - pointOnCone.xy));\n        outColor += REMAP_HALF_NDC(pointOnCone.z, 3.0, 0.6) * // Slightly adjust the size of the point based on distance to \"camera\" \n            2e-5 / pow(length(st - pointOnCone.xy), 1.7) * pointColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // [-0.5, 0.5] adjusted for aspect ratio\n    vec3 outColor = vec3(0.005, 0.01, 0.03); // Background color\n    vec4 m = iMouse / iResolution.yyyy;\n    float t = 0.0;\n    \n    if (m.z > 0.0)\n    {\n        t = m.x * TAU;\n    }\n    else\n    {\n        t = iTime * 0.5;\n    }\n    \n    DrawTree(uv, t, outColor);\n    DrawStar(uv, t, outColor);\n    \n    float vignette = dot(uv, uv);\n    vignette *= vignette;\n    vignette = 1.0 / (vignette * vignette + 1.0);\n    \n    fragColor = vec4(pow(outColor * vignette, vec3(0.4545)), 1.0) - Hash12(fragCoord.xy * t + iResolution.yy) * 0.04;\n}"], ["// https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant, 2023 jt\n// based on https://www.shadertoy.com/view/ctyBzm orthogonal circles flower sdf 3d\n// based on https://www.shadertoy.com/view/clGBzm orthogonal circles flower sdf 2\n// based on https://www.shadertoy.com/view/dldBWl orthogonal circles flower sdf\n// exact sdf for shape related to https://www.shadertoy.com/view/cltfW2 orthogonal circles flower\n// SDF exactness using https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n\n// Circle arcs orthogonal to unit sphere\n// with circle segment endpoints at equidistant latitude / longitude.\n// Reminds me of a clumpy grass variant I like.\n\n// TODO: Can something similar be done with spherical fibonacci instead?\n//       (see e.g. https://www.shadertoy.com/view/lllXz4 )\n\n// tags: sdf, flower, circle, grass, distance, conformal, disk, plant, loopless, exact, orthogonal\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//succulent makes DF not so precise, so set to 0 if you want exact SDF\n//It doesn't appear to miss the surface, but it will jump further into the grass rather than landing on the 0 contour\n#define SUCCULENT_RADIUS .08\n\n//exact SDF radius, if somewhat boring looking\n#define GRASS_RADIUS 0.01\n\n#define pi 3.1415926\n\nfloat ortho_circle_flower_sdf(float n, vec2 p) // https://www.shadertoy.com/view/dldBWl orthogonal circle flower sdf (jt)\n{\n    p.x = abs(p.x);\n \n    n = 2.01+ abs(sin(iTime*.5)*10.0);//Any N > 2 will work now\n\n    float slice2 = (pi*2.0)/float(n);\n    \n    // endpoints\n    float phiReal = atan(p.x,p.y);\n\n    float endPtRound = fract(n*.5);\n    \n   //quantized phi--but do it so it works with any N value not just odd\n    float phi = (round(phiReal/slice2 - endPtRound)+endPtRound)*slice2;\n    \n    vec2 c = vec2(sin(phi),cos(phi));\n    \n    float d = length(p-c);//distance to endpoint\n    \n\n    bool wantCircle = dot(p,c)<1.0 \n                    ||  phi <0.0; //Without this sometimes you get a floating tip at center/top with non odd N :/\n    \n    \n    //we can skip this circle stuff when outside the shape\n    if(wantCircle){\n    \n        float slice = slice2*.5;\n        float a = (p.y*p.y+2.0*p.y+p.x*p.x+1.0);\n        float b = p.x*2.0;\n    \n        float ang1 = floor(atan(a,b)/slice)*slice;\n    \n        float r0 = tan(ang1);         // quantize floor angle\n        float r1 = tan(ang1 + slice); // quantize ceil angle\n \n        d =  min(abs(length(p-vec2(r0,-1))-r0),\n                 abs(length(p-vec2(r1,-1))-r1));\n    }\n    return d;\n }\n\nfloat dot2(vec2 a){\n   // return length(a);\n    return dot(a,a);\n}\nfloat fade(float f){\n   // return sin(f*pi);\n    f = 1.0-f*f;\n    f = 1.0-f*f;\n    return f;\n}\nfloat ortho_circle_flower_sdf(float m, float n, vec3 p) // https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant (jt)\n{\n    float phi = round(atan(p.y,p.x)/(2.0*pi/float(m)))*(2.0*pi/float(m)); // polar & quantize\n  //  phi  = abs(phi);\n    p.xy = mat2(cos(phi),-sin(phi),sin(phi),cos(phi))*p.xy;\n   // p.x = abs(p.x);\n//    return length(vec2(ortho_circle_flower_sdf(n, vec2(p.xz)),p.y));\n    \n    float q = ortho_circle_flower_sdf(float(n), vec2(p.x,p.z));\n\n    return length(vec2(q,p.y))-SUCCULENT_RADIUS*fade(1.0-min(dot2(p.xz),1.0));;\n    \n}\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat map(vec3 p)\n{\n    float n = float(mix(3.0, 11.0, 0.5+0.5*cos(2.0*pi*iTime/10.0))); // animate number of leafs\n   // n = 5.0;\n    float m =2.01 + cos(iTime*.2)*10.0;\n   // m =3;\n    return ortho_circle_flower_sdf(m, n, p)-GRASS_RADIUS;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p )\n{\n    vec3 e = vec3(0.001,0.0,0.0);\n    return normalize( vec3(\n        map( p+e.xyy )-map( p-e.xyy ),\n        map( p+e.yxy )-map( p-e.yxy ),\n        map( p+e.yyx )-map( p-e.yyx ) ) );\n}\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1) // pass on running out of iterations\n{\n    // NOTE: Limited number of iterations to avoid stalling\n    //       when ray passes closely (just above EPSILON)\n    //       in parallel to a surface.\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n\n    return t; // stop on running out of iterations\n    //return t1; // pass on running out of iterations\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1)\n{\n    return trace(ro, rd, t0, t1) < t1 ? 0.0 : 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\nvec3 material(vec3 p)\n{\n    return vec3(0.1,1.0,0.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 I)\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0)); // NOTE: omitting normalization results in clipped edges artifact\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    //ro.z += 1.0;\n\n    vec3 color = vec3(1);\n    float dist = trace(ro, rd, 0.0, DIST_MAX);\n    if(dist < DIST_MAX)\n    {\n        vec3 dst = ro + rd * dist;\n        vec3 n = normal(dst);\n\n        //color *= (n * 0.5 + 0.5);\n        color *= material(dst);\n\n        vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0)\n        {\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular;\n        }\n\n        vec3 fog_color = vec3(0.2);\n        color = mix(fog_color, vec3(color), exp(-pow(dist/20.0, 2.0))); // fog\n    }\n    else\n    {\n        //color *= mix(vec3(0,0.5,0.5),vec3(0,0,1),abs(-rd.z)); // sky\n        color *= 0.0;\n    }\n\n    color = tanh(color); // roll-off overly bright colors\n    color = sqrt(color); // approximate gamma\n    fragColor = vec4(color, 1);\n}\n"], ["// https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant, 2023 jt\n// based on https://www.shadertoy.com/view/ctyBzm orthogonal circles flower sdf 3d\n// based on https://www.shadertoy.com/view/clGBzm orthogonal circles flower sdf 2\n// based on https://www.shadertoy.com/view/dldBWl orthogonal circles flower sdf\n// exact sdf for shape related to https://www.shadertoy.com/view/cltfW2 orthogonal circles flower\n// SDF exactness using https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n\n// Circle arcs orthogonal to unit sphere\n// with circle segment endpoints at equidistant latitude / longitude.\n// Reminds me of a clumpy grass variant I like.\n\n// TODO: Can something similar be done with spherical fibonacci instead?\n//       (see e.g. https://www.shadertoy.com/view/lllXz4 )\n\n// tags: sdf, flower, circle, grass, distance, conformal, disk, plant, loopless, exact, orthogonal\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//succulent makes DF not so precise, so set to 0 if you want exact SDF\n//It doesn't appear to miss the surface, but it will jump further into the grass rather than landing on the 0 contour\n#define SUCCULENT_RADIUS .08\n\n//exact SDF radius, if somewhat boring looking\n#define GRASS_RADIUS 0.01\n\n#define pi 3.1415926\n\nfloat ortho_circle_flower_sdf(float n, vec2 p) // https://www.shadertoy.com/view/dldBWl orthogonal circle flower sdf (jt)\n{\n    p.x = abs(p.x);\n \n    n = 2.01+ abs(sin(iTime*.5)*10.0);//Any N > 2 will work now\n\n    float slice2 = (pi*2.0)/float(n);\n    \n    // endpoints\n    float phiReal = atan(p.x,p.y);\n\n    float endPtRound = fract(n*.5);\n    \n   //quantized phi--but do it so it works with any N value not just odd\n    float phi = (round(phiReal/slice2 - endPtRound)+endPtRound)*slice2;\n    \n    vec2 c = vec2(sin(phi),cos(phi));\n    \n    float d = length(p-c);//distance to endpoint\n    \n\n    bool wantCircle = dot(p,c)<1.0 \n                    ||  phi <0.0; //Without this sometimes you get a floating tip at center/top with non odd N :/\n    \n    \n    //we can skip this circle stuff when outside the shape\n    if(wantCircle){\n    \n        float slice = slice2*.5;\n        float a = (p.y*p.y+2.0*p.y+p.x*p.x+1.0);\n        float b = p.x*2.0;\n    \n        float ang1 = floor(atan(a,b)/slice)*slice;\n    \n        float r0 = tan(ang1);         // quantize floor angle\n        float r1 = tan(ang1 + slice); // quantize ceil angle\n \n        d =  min(abs(length(p-vec2(r0,-1))-r0),\n                 abs(length(p-vec2(r1,-1))-r1));\n    }\n    return d;\n }\n\nfloat dot2(vec2 a){\n   // return length(a);\n    return dot(a,a);\n}\nfloat fade(float f){\n   // return sin(f*pi);\n    f = 1.0-f*f;\n    f = 1.0-f*f;\n    return f;\n}\nfloat ortho_circle_flower_sdf(float m, float n, vec3 p) // https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant (jt)\n{\n    float phi = round(atan(p.y,p.x)/(2.0*pi/float(m)))*(2.0*pi/float(m)); // polar & quantize\n  //  phi  = abs(phi);\n    p.xy = mat2(cos(phi),-sin(phi),sin(phi),cos(phi))*p.xy;\n   // p.x = abs(p.x);\n//    return length(vec2(ortho_circle_flower_sdf(n, vec2(p.xz)),p.y));\n    \n    float q = ortho_circle_flower_sdf(float(n), vec2(p.x,p.z));\n\n    return length(vec2(q,p.y))-SUCCULENT_RADIUS*fade(1.0-min(dot2(p.xz),1.0));;\n    \n}\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat map(vec3 p)\n{\n    float n = float(mix(3.0, 11.0, 0.5+0.5*cos(2.0*pi*iTime/10.0))); // animate number of leafs\n   // n = 5.0;\n    float m =2.01 + cos(iTime*.2)*10.0;\n   // m =3;\n    return ortho_circle_flower_sdf(m, n, p)-GRASS_RADIUS;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) +\n                      k.yyx*map( p + k.yyx*h ) +\n                      k.yxy*map( p + k.yxy*h ) +\n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1) // pass on running out of iterations\n{\n    // NOTE: Limited number of iterations to avoid stalling\n    //       when ray passes closely (just above EPSILON)\n    //       in parallel to a surface.\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n\n    return t; // stop on running out of iterations\n    //return t1; // pass on running out of iterations\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1)\n{\n    float res = 1.0;\n    float t = t0;\n    for(int i=0; i<128; i++)\n    {\n        float h = map(ro + rd*t);\n        res = min(res, 4.0*h/t);\n        t += h;\n        if(h<0.001 || t>t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\nvec3 material(vec3 p)\n{\n    return vec3(0.1,1.0,0.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 I)\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0)); // NOTE: omitting normalization results in clipped edges artifact\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    //ro.z += 1.0;\n\n    vec3 color = vec3(1);\n    float dist = trace(ro, rd, 0.0, DIST_MAX);\n    if(dist < DIST_MAX)\n    {\n        vec3 dst = ro + rd * dist;\n        vec3 n = normal(dst);\n\n        //color *= (n * 0.5 + 0.5);\n        color *= material(dst);\n\n        vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0)\n        {\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular;\n        }\n\n        vec3 fog_color = vec3(0.2);\n        color = mix(fog_color, vec3(color), exp(-pow(dist/20.0, 2.0))); // fog\n    }\n    else\n    {\n        //color *= mix(vec3(0,0.5,0.5),vec3(0,0,1),abs(-rd.z)); // sky\n        color *= 0.0;\n    }\n\n    color = tanh(color); // roll-off overly bright colors\n    color = sqrt(color); // approximate gamma\n    fragColor = vec4(color, 1);\n}\n"], ["// https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant, 2023 jt\n// based on https://www.shadertoy.com/view/ctyBzm orthogonal circles flower sdf 3d\n// based on https://www.shadertoy.com/view/clGBzm orthogonal circles flower sdf 2\n// based on https://www.shadertoy.com/view/dldBWl orthogonal circles flower sdf\n// exact sdf for shape related to https://www.shadertoy.com/view/cltfW2 orthogonal circles flower\n// SDF exactness using https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n\n// Circle arcs orthogonal to unit sphere\n// with circle segment endpoints at equidistant latitude / longitude.\n// Reminds me of a clumpy grass variant I like.\n\n// TODO: Can something similar be done with spherical fibonacci instead?\n//       (see e.g. https://www.shadertoy.com/view/lllXz4 )\n\n// tags: sdf, flower, circle, grass, distance, conformal, disk, plant, loopless, exact, orthogonal\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//succulent makes DF not so precise, so set to 0 if you want exact SDF\n//It doesn't appear to miss the surface, but it will jump further into the grass rather than landing on the 0 contour\n#define SUCCULENT_RADIUS .08\n\n//exact SDF radius, if somewhat boring looking\n#define GRASS_RADIUS 0.01\n\n#define pi 3.1415926\n\nfloat ortho_circle_flower_sdf(float n, vec2 p) // https://www.shadertoy.com/view/dldBWl orthogonal circle flower sdf (jt)\n{\n    p.x = abs(p.x);\n \n    n = 2.01+ abs(sin(iTime*.5)*10.0);//Any N > 2 will work now\n\n    float slice2 = (pi*2.0)/float(n);\n    \n    // endpoints\n    float phiReal = atan(p.x,p.y);\n\n    float endPtRound = fract(n*.5);\n    \n   //quantized phi--but do it so it works with any N value not just odd\n    float phi = (round(phiReal/slice2 - endPtRound)+endPtRound)*slice2;\n    \n    vec2 c = vec2(sin(phi),cos(phi));\n    \n    float d = length(p-c);//distance to endpoint\n    \n\n    bool wantCircle = dot(p,c)<1.0 \n                    ||  phi <0.0; //Without this sometimes you get a floating tip at center/top with non odd N :/\n    \n    \n    //we can skip this circle stuff when outside the shape\n    if(wantCircle){\n    \n        float slice = slice2*.5;\n        float a = (p.y*p.y+2.0*p.y+p.x*p.x+1.0);\n        float b = p.x*2.0;\n    \n        float ang1 = floor(atan(a,b)/slice)*slice;\n    \n        float r0 = tan(ang1);         // quantize floor angle\n        float r1 = tan(ang1 + slice); // quantize ceil angle\n \n        d =  min(abs(length(p-vec2(r0,-1))-r0),\n                 abs(length(p-vec2(r1,-1))-r1));\n    }\n    return d;\n }\n\nfloat dot2(vec2 a){\n   // return length(a);\n    return dot(a,a);\n}\nfloat fade(float f){\n   // return sin(f*pi);\n    f = 1.0-f*f;\n    f = 1.0-f*f;\n    return f;\n}\nfloat ortho_circle_flower_sdf(float m, float n, vec3 p) // https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant (jt)\n{\n    float phi = round(atan(p.y,p.x)/(2.0*pi/float(m)))*(2.0*pi/float(m)); // polar & quantize\n  //  phi  = abs(phi);\n    p.xy = mat2(cos(phi),-sin(phi),sin(phi),cos(phi))*p.xy;\n   // p.x = abs(p.x);\n//    return length(vec2(ortho_circle_flower_sdf(n, vec2(p.xz)),p.y));\n    \n    float q = ortho_circle_flower_sdf(float(n), vec2(p.x,p.z));\n\n    return length(vec2(q,p.y))-SUCCULENT_RADIUS*fade(1.0-min(dot2(p.xz),1.0));;\n    \n}\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat map(vec3 p)\n{\n    float n = float(mix(3.0, 11.0, 0.5+0.5*cos(2.0*pi*iTime/10.0))); // animate number of leafs\n   // n = 5.0;\n    float m =2.01 + cos(iTime*.2)*10.0;\n   // m =3;\n    return ortho_circle_flower_sdf(m, n, p)-GRASS_RADIUS;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) +\n                      k.yyx*map( p + k.yyx*h ) +\n                      k.yxy*map( p + k.yxy*h ) +\n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1) // pass on running out of iterations\n{\n    // NOTE: Limited number of iterations to avoid stalling\n    //       when ray passes closely (just above EPSILON)\n    //       in parallel to a surface.\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n\n    return t; // stop on running out of iterations\n    //return t1; // pass on running out of iterations\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1)\n{\n    return trace(ro, rd, t0, t1) < t1 ? 0.0 : 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.11*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 material(vec3 p)\n{\n    return vec3(0.1,1.0,0.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 I)\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0)); // NOTE: omitting normalization results in clipped edges artifact\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    //ro.z += 1.0;\n\n    vec3 color = vec3(1);\n    float dist = trace(ro, rd, 0.0, DIST_MAX);\n    if(dist < DIST_MAX)\n    {\n        vec3 dst = ro + rd * dist;\n        vec3 n = normal(dst);\n\n        //color *= (n * 0.5 + 0.5);\n        color *= material(dst);\n\n        vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0)\n        {\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular;\n        }\n\n        vec3 fog_color = vec3(0.2);\n        color = mix(fog_color, vec3(color), exp(-pow(dist/20.0, 2.0))); // fog\n    }\n    else\n    {\n        //color *= mix(vec3(0,0.5,0.5),vec3(0,0,1),abs(-rd.z)); // sky\n        color *= 0.0;\n    }\n\n    color = tanh(color); // roll-off overly bright colors\n    color = sqrt(color); // approximate gamma\n    fragColor = vec4(color, 1);\n}\n"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        axis.x * axis.x * oc + c,\n        axis.y * axis.x * oc + axis.z * s,\n        axis.z * axis.x * oc - axis.y * s,\n        axis.x * axis.y * oc - axis.z * s,\n        axis.y * axis.y * oc + c,\n        axis.z * axis.y * oc + axis.x * s,\n        axis.x * axis.z * oc + axis.y * s,\n        axis.y * axis.z * oc - axis.x * s,\n        axis.z * axis.z * oc + c\n    );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;\n  vec3 ray = normalize(vec3(uv, 1.0));\n  ray.z *= aspect;\n  return ray;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(n * 43758.5453123);\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n    float n = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += a * snoise3d(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return n;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float amp = 1.0;\n    float freq = 1.0;\n    float val = 0.0;\n    for(int i = 0; i < 8; i++){\n        val += amp * abs(noise(p * freq));\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return val;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    vec3 p = pos;\n    float density = 0.0;\n    float color = 0.0;\n    float density_sum = 0.0;\n    float color_sum = 0.0;\n    float density_sum_2 = 0.0;\n    float color_sum_2 = 0.0;\n    float density_sum_3 = 0.0;\n    float color_sum_3 = 0.0;\n    float density_sum_4 = 0.0;\n    float color_sum_4 = 0.0;\n    float density_sum_5 = 0.0;\n    float color_sum_5 = 0.0;\n    float density_sum_6 = 0.0;\n    float color_sum_6 = 0.0;\n    float density_sum_7 = 0.0;\n    float color_sum_7 = 0.0;\n    float density_sum_8 = 0.0;\n    float color_sum_8 = 0.0;\n    float density_sum_9 = 0.0;\n    float color_sum_9 = 0.0;\n    float density_sum_10 = 0.0;\n    float color_sum_10 = 0.0;\n    float density_sum_11 = 0.0;\n    float color_sum_11 = 0.0;\n    float density_sum_12 = 0.0;\n    float color_sum_12 = 0.0;\n    float density_sum_13 = 0.0;\n    float color_sum_13 = 0.0;\n    float density_sum_14 = 0.0;\n    float color_sum_14 = 0.0;\n    float density_sum_15 = 0.0;\n    float color_sum_15 = 0.0;\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float light = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float shadow = 1.0;\n    float coverage = 0.0;\n    float coverage2 = 0.0;\n    float coverage3 = 0.0;\n    float coverage4 = 0.0;\n    float coverage5 = 0.0;\n    float coverage6 = 0.0;\n    float coverage7 = 0.0;\n    float coverage8 = 0.0;\n    float coverage9 = 0.0;\n    float coverage10 = 0.0;\n    float coverage11 = 0.0;\n    float coverage12 = 0.0;\n    float coverage13 = 0.0;\n    float coverage14 = 0.0;\n    float coverage15 = 0.0;\n    float coverage16 = 0.0;\n    float coverage17 = 0.0;\n    float coverage18 = 0.0;\n    float coverage19 = 0.0;\n    float coverage20 = 0.0;\n    float coverage21 = 0.0;\n    float coverage22 = 0.0;\n    float coverage23 = 0.0;\n    float coverage24 = 0.0;\n    float coverage25 = 0.0;\n    float coverage26 = 0.0;\n    float coverage27 = 0.0;\n    float coverage28 = 0.0;\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec3 color = vec3(0.0);\n    vec3 fogColor = vec3(0.0);\n    vec3 fogColor2 = vec3(0.0);\n    vec3 fogColor3 = vec3(0.0);\n    vec3 fogColor4 = vec3(0.0);\n    vec3 fogColor5 = vec3(0.0);\n    vec3 fogColor6 = vec3(0.0);\n    vec3 fogColor7 = vec3(0.0);\n    vec3 fogColor8 = vec3(0.0);\n    vec3 fogColor9 = vec3(0.0);\n    vec3 fogColor10 = vec3(0.0);\n    vec3 fogColor11 = vec3(0.0);\n    vec3 fogColor12 = vec3(0.0);\n    vec3 fogColor13 = vec3(0.0);\n    vec3 fogColor14 = vec3(0.0);\n    vec3 fogColor15 = vec3(0.0);\n    vec3 fogColor16 = vec3(0.0);\n    vec3 fogColor17 = vec3(0.0);\n    vec3 fogColor18 = vec3(0.0);\n    vec3 fogColor19 = vec3(0.0);\n    vec3 fogColor20 = vec3(0.0);\n    vec3 fogColor21 = vec3(0.0);\n    vec3 fogColor22 = vec3(0.0);\n    vec3 fogColor23 = vec3(0.0);\n    vec3 fogColor24 = vec3(0.0);\n    vec3 fogColor25 = vec3(0.0);\n    vec3 fogColor26 = vec3(0.0);\n    vec3 fogColor27 = vec3(0.0);\n    vec3 fogColor28 = vec3(0.0);\n    vec3 fogColor29 = vec3(0.0// incomplete generation!\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"], ["// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}"]]