{"generations": ["\n\treturn 0.282095;\n}\n\nfloat SH_1_m1( in vec3 s ) {\n\treturn -0.488603 * s.y;\n}\n\nfloat SH_1_0( in vec3 s ) {\n\treturn 0.488603 * s.z;\n}\n\nfloat SH_1_1( in vec3 s ) {\n\treturn -0.488603 * s.x;\n}\n\nfloat SH_2_m2( in vec3 s ) {\n\treturn 1.092548 * s.x * s.y;\n}\n\nfloat SH_2_m1( in vec3 s ) {\n\treturn -1.092548 * s.y * s.z;\n}\n\nfloat SH_2_0( in vec3 s ) {\n\treturn 0.315392 * ( 3.0 * s.z * s.z - 1.0 );\n}\n\nfloat SH_2_1( in vec3 s ) {\n\treturn -1.092548 * s.x * s.z;\n}\n\nfloat SH_2_2( in vec3 s ) {\n\treturn 0.546274 * ( s.x * s.x - s.y * s.y );\n}\n\nfloat SH_3_m3( in vec3 s ) {\n\treturn -0.590044 * s.x * s.x * s.y;\n}\n\nfloat SH_3_m2( in vec3 s ) {\n\treturn 0.590044 * s.y * s.z * s.z;\n}\n\nfloat SH_3_m1( in vec3 s ) {\n\treturn -1.180088 * s.x * s.y * s.z;\n}\n\nfloat SH_3_0( in vec3 s ) {\n\treturn 0.590044 * ( 5.0 * s.z * s.z * s.z - 3.0 * s.", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle (can't get simpler than this)\nfloat circle( in vec2 p, in vec2 c, in float r )\n{\n    return length( p-c ) - r;\n}\n\n// distance to a rectangle (can't get simpler than this)\nfloat rect( in vec2 p, in vec2 c, in vec2 r )\n{\n    p -= c;\n    return max( abs(p.x)-r.x, abs(p.y)-r.y );\n}\n\n// distance to a triangle (can't get simpler than this)\nfloat tri( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = p-a, ba = b-a, ca = c-a;\n    float s = sign( ba.x*ca.y - ba.y*ca.x );\n    float h = clamp( s*(pa.x*ba.y - pa.y*ba.x + ba.x*ca.y - ba.y*ca.x)/dot(ba,ca), 0.0, 1.0 );\n    return s*length( pa - ba*h );\n}\n\n// distance to a polygon (can't get simpler than this)\nfloat poly( in vec2 p, in vec2[] ps )\n{\n    float d = 1e38;\n    for( int i=0; i<ps.length; i++ )\n    {\n        vec2 a = ps[i], b = ps[(i+1)%ps.length];\n        d = min( d, line( a, b, p ) );\n    }\n    return d;\n}\n\n// distance to a star (can't get simpler than this)\nfloat star( in vec2 p, in vec2 c, in float r, in float ra, in int n )\n{\n    float d = 1e38;\n    for( int i=0; i<n; i++ )\n    {\n        float a = float(i)*6.28", "\n\treturn ( dot( v, r ) < 0.0 )? v * (float(-1.0)) : v;\n}\n\n// Rotate a vector around an axis\nvec3 rotate( in vec3 v, in vec3 axis, in float angle )\n{\n\taxis = normalize( axis );\n\tfloat s = sin( angle );\n\tfloat c = cos( angle );\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3( oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c ) * v;\n}\n\n// Rotate a vector around an axis\nvec2 rotate( in vec2 v, in vec2 axis, in float angle )\n{\n\taxis = normalize( axis );\n\tfloat s = sin( angle );\n\tfloat c = cos( angle );\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat2( oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,\n\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c ) * v;\n}\n\n// Rotate a vector around an axis\nvec3 rotate( in vec3 v, in vec3 axis, in vec3 angle )\n{\n\treturn rotate( rotate( rotate( v, axis.x, angle.x ), axis.y, angle.y ), axis.z, angle.z );\n}\n\n// Rotate a vector around an axis\nvec2 rotate( in vec2 v, in vec2 axis, in vec2 angle )\n{\n\treturn rotate( rotate( v, axis.x, angle.x ), axis.y, angle", "\n\treturn (v.x*r.x+v.y*r.y < 0.0)? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n\treturn (v.x*r.x+v.y*r.y+v.z*r.z < 0.0)? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n\treturn (v.x*r.x+v.y*r.y+v.z*r.z+v.w*r.w < 0.0)? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in float r )\n{\n\treturn (v.x*r < 0.0)? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in float r )\n{\n\treturn (v.x*r < 0.0)? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in float r )\n{\n\treturn (v.x*r < 0.0)? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float r2 )\n{\n\treturn (v.x*r.x+v.y*r.y < 0.0)? -v*r2 : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\n", "\n\treturn (v.x < 0.0)? r.xy : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n\treturn (v.x > 0.0)? r.xy : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n\treturn (v.x < 0.0)? r.xyz : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n\treturn (v.x > 0.0)? r.xyz : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n\treturn (v.x < 0.0)? r.xyzw : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n\treturn (v.x > 0.0)? r.xyzw : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in float r )\n{\n\treturn (v.x < 0.0)? vec2(r,r) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in float r )\n{\n\treturn (v.x > 0.0)? vec2(r,r) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v", "\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - w1*(1.0-h) - w2*h;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float ra, in float rb )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - mix( ra, rb, h );\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float ra, in float rb, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - mix( ra, rb, h ) - r;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float ra, in float rb, in float r, in float r2 )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot4 = sunDot2 * sunDot2;\n\tfloat sunDot9 = sunDot4 * sunDot4 * sunDot;\n\tfloat sunDot16 = sunDot9 * sunDot9;\n\tfloat sunDot25 = sunDot16 * sunDot9;\n\tfloat sunDot36 = sunDot25 * sunDot16;\n\tfloat sunDot49 = sunDot36 * sunDot16;\n\tfloat sunDot64 = sunDot49 * sunDot16;\n\tfloat sunDot81 = sunDot64 * sunDot16;\n\tfloat sunDot100 = sunDot81 * sunDot16;\n\tfloat sunDot121 = sunDot100 * sunDot16;\n\tfloat sunDot144 = sunDot121 * sunDot16;\n\tfloat sunDot169 = sunDot144 * sunDot16;\n\tfloat sunDot196 = sunDot169 * sunDot16;\n\tfloat sunDot225 = sunDot196 * sunDot16;\n\tfloat sunDot256 = sunDot225 * sunDot16;\n\tfloat sunDot289 = sunDot256 * sunDot16;\n\tfloat sunDot324 = sunDot289 * sunDot16;\n\tfloat sunDot361 = sunDot324 * sunDot16;\n\tfloat sunDot400 = sunDot361 * sunDot16;\n\tfloat sunDot441 = sunDot400 * sunDot16;\n\tfloat sunDot484 = sunDot441 * sunDot16;\n\tfloat sunDot529 = sunDot484 * sunDot16;\n\tfloat sunDot576 = sunDot529 * sunDot16;\n\tfloat sunDot625 = sunDot576 * sunDot16;\n\tfloat sunDot676 = sunDot625 * sunDot16;\n\tfloat sunDot729", "\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\treturn 0.5f * ((2.0f * p1) +\n\t\t(-p0 + p2) * t +\n\t\t(2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +\n\t\t(-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);\n}\n\n// This is a spline used for the camera path\nvec4 Hermite(vec4 p0, vec4 t0, vec4 p1, vec4 t1, float t)\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tfloat s = 2.0f * t3 - 3.0f * t2 + 1.0f;\n\tfloat s2 = -2.0f * t3 + 3.0f * t2;\n\tfloat s3 = t3 - 2.0f * t2 + t;\n\tfloat s4 = t3 - t2;\n\treturn s * p0 + s2 * t0 + s3 * p1 + s4 * t1;\n}\n\n// This is a spline used for the camera path\nvec4 Bezier(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\treturn (1.0f - t3) * p0 + 3.0f * t * t2 * p1 + 3.0f * t2 * t * p2 + t3 * p3;\n}\n\n// This is a spline used for the camera path\nvec4 BSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\treturn (2.0f / 3.0f) * p1 + (1.0f / 3.0f) * p", "\n\tfloat r = 0.0;\n\tfloat a = 1.0;\n\tfloat b = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\tfloat t = a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*p.y) * a;\n\t\ta = a * nudge;\n\t\tb = b * nudge + 1.0;\n\t\tr += sin(a*p.x + b*", "\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\tfloat a0 = -0.5f * t3 + t2 - 0.5f * t;\n\tfloat a1 = 1.5f * t3 - 2.5f * t2 + 1.0f;\n\tfloat a2 = -1.5f * t3 + 2.0f * t2 + 0.5f * t;\n\tfloat a3 = 0.5f * t3 - 0.5f * t2;\n\n\treturn a0 * p0 + a1 * p1 + a2 * p2 + a3 * p3;\n}\n\n// This is the camera path.  It is a Catmull-Rom spline.\n// It is a list of 4 points, and the camera will move from\n// point 0 to point 1, then from point 1 to point 2, then\n// from point 2 to point 3.  The camera will then repeat\n// this path.\nvec4 CamPath[4] = vec4[4](\n\tvec4(0.0, 0.0, 0.0, 1.0),\n\tvec4(0.0, 0.0, 0.0, 1.0),\n\tvec4(0.0, 0.0, 0.0, 1.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n);\n\n// This is the camera's speed.  It is the distance it moves\n// in one second.\nfloat CamSpeed = 1.0;\n\n// This is the camera's rotation", "\n\treturn fract(sin(u * 1234.5678) * 12345.6789);\n}\n\nfloat Hash2d(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n}\n\nfloat Hash4d(vec4 p)\n{\n\treturn fract(sin(dot(p, vec4(127.1, 311.7, 74.7, 157.3))) * 43758.5453);\n}\n\n// gradient noise functions\nfloat Grad1d(float u)\n{\n\treturn 0.5 * Hash1d(u);\n}\n\nfloat Grad2d(vec2 p)\n{\n\treturn 0.5 * Hash2d(p);\n}\n\nfloat Grad3d(vec3 p)\n{\n\treturn 0.5 * Hash3d(p);\n}\n\nfloat Grad4d(vec4 p)\n{\n\treturn 0.5 * Hash4d(p);\n}\n\n// value noise functions\nfloat Noise1d(float u)\n{\n\tfloat i = floor(u);\n\tfloat f = fract(u);\n\tfloat g = Grad1d(i);\n\treturn mix(g, g + 1.0, f);\n}\n\nfloat Noise2d(vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(Grad2d(i + vec2(0.0, 0.0)), Grad2d(i + vec2(1.0, 0.0)), u.x", "\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += amp * sin(freq * p.x + p.y * nudge);\n\t\tp = p * 2.0 + vec3(0.0, 0.0, 1.0);\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D version of the 2D Perlin noise function.\n// It's a bit slower than the 2D version, but it's a lot more fun.\nfloat PerlinNoise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// This is a 3D version of the 2D simplex noise function.\n// It's a bit slower than the 2D version, but it's a lot more fun.\nfloat SimplexNoise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// This is a", "\nfloat d = 1e30;\n\n// This is the distance to the plane\nd = min(d, p.y + 1.0);\n\n// This is the distance to the sphere\nd = min(d, length(p - vec3(0.0, 0.0, -1.0)) - 0.5);\n\n// This is the distance to the cylinder\nd = min(d, length(p - vec3(0.0, 0.0, 0.0)) - 0.5);\n\n// This is the distance to the torus\nd = min(d, length(p - vec3(0.0, 0.0, 0.0)) - 0.25);\n\n// This is the distance to the box\nd = min(d, length(max(abs(p) - vec3(0.5, 0.5, 0.5), 0.0)) - 0.05);\n\n// This is the distance to the cone\nd = min(d, length(p - vec3(0.0, 0.0, 0.0)) - 0.5);\n\n// This is the distance to the pyramid\nd = min(d, length(max(abs(p) - vec3(0.5, 0.5, 0.5), 0.0)) - 0.05);\n\n// This is the distance to the tetrahedron\nd = min(d, length(max(abs(p) - vec3(0.5, 0.5, 0.5), 0.0)) - 0.05);\n\n// This is the distance to the octahedron\nd = min(d, length(max(abs(p) - vec3(0.5, 0.5, 0.5), 0.0)) - 0.05);\n\n// This is the distance to the dodecahedron\nd = min(d, length(max(abs(p) - vec3(0.5, 0.5, 0.5), 0.0)) - 0.05);\n\n// This is the distance to the icosahedron\n", "\n\tvec3 envColor = vec3(0.0);\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot4 = sunDot2 * sunDot2;\n\tfloat sunDot8 = sunDot4 * sunDot4;\n\tfloat sunDot16 = sunDot8 * sunDot8;\n\tfloat sunDot32 = sunDot16 * sunDot16;\n\tfloat sunDot64 = sunDot32 * sunDot32;\n\tfloat sunDot128 = sunDot64 * sunDot64;\n\tfloat sunDot256 = sunDot128 * sunDot128;\n\tfloat sunDot512 = sunDot256 * sunDot256;\n\tfloat sunDot1024 = sunDot512 * sunDot512;\n\tfloat sunDot2048 = sunDot1024 * sunDot1024;\n\tfloat sunDot4096 = sunDot2048 * sunDot2048;\n\tfloat sunDot8192 = sunDot4096 * sunDot4096;\n\tfloat sunDot16384 = sunDot8192 * sunDot8192;\n\tfloat sunDot32768 = sunDot16384 * sunDot16384;\n\tfloat sunDot65536 = sunDot32768 * sunDot32768;\n\tfloat sunDot131072 = sunDot65536 * sunDot65536;\n\tfloat sunDot262144 = sunDot131072 * sunDot131072;\n\tfloat sunDot524288 = sunDot262144 * sunDot262144;\n\tfloat sunDot1048576 = sunDot524288 * sunDot524288;\n\tfloat sunDot2097152 = sunDot1048576 * sunDot1048576;\n\tfloat", "\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// 2D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec2 p )\n{\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\t// Four corners in 2D of a tile\n\tfloat a = random(i);\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\t\n\treturn mix( a, b, u.x ) +\n\t\t\t(c - a)* u.y * (1.0 - u.x) +\n\t\t\t(d - b) * u.x * u.y;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n\tvec2 Pi = floor(P);\n\tvec2 Pf = fract(P);\n\tPf = Pf*Pf*(3.0-2.0*Pf);\n\t\n\tvec2 p = Pi + vec2( 0.0, 1.0 );\n\tvec2 o = mod( (Pi + rep), 2.0 ); // Hard wrap\n\tvec2 b0 = o.x + vec2( o.y );\n\tvec2 b1 = o.x + vec2( 1.0 ) - o.y;\n\tvec4 s = vec4( lessThan(b0,Pf) );\n\tvec4 t = vec4( equal(b0,Pf) );\n\treturn mix( mix( hash( p + vec2( 0.0, 0.0 ) ), \n\t\thash( p + vec2( 1.0, 0.0 )", "\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 dirVecToCenter = spherePos - pos;\n\tfloat a = dot(dirVec, dirVec);\n\tfloat b = 2.0 * dot(dirVec, dirVecToCenter);\n\tfloat c = dot(dirVecToCenter, dirVecToCenter) - rad * rad;\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t\treturn -1.0;\n\telse\n\t{\n\t\tfloat t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n\t\tfloat t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\t\tif (t1 < 0.0)\n\t\t\treturn t2;\n\t\telse if (t2 < 0.0)\n\t\t\treturn t1;\n\t\telse\n\t\t\treturn min(t1, t2);\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 hitPoint)\n{\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 dirVecToCenter = spherePos - pos;\n\tfloat a = dot(dirVec, dirVec);\n\tfloat b = 2.0 * dot(dirVec, dirVecToCenter);\n\tfloat c = dot(dirVecToCenter, dirVecToCenter) - rad * rad;\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t{\n\t\thitPoint = vec3(0.0);\n\t\treturn -1.0;\n\t}\n\telse\n\t{\n\t\tfloat t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n\t\tfloat t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\t\tif (t1 < 0.0)\n\t\t{\n\t\t\thitPoint = pos + dirVec * t2;\n\t\t\treturn t2;\n\t\t}\n\t", "\n// Calculate the distance to the sphere.\nvec2 sphere = vec2(length(p) - 1.0, 1.0);\n\n// Calculate the distance to the box.\nvec2 box = abs(p) - vec2(1.0);\nbox = min(box, vec2(max(box.x, box.y), min(box.x, box.y)));\nbox = vec2(length(box) - 0.5, 1.0);\n\n// Combine the distances.\nreturn min(sphere, box);\n}\n\n// Calculate the normal of the object.\nvec3 NormalToObject(vec3 p)\n{\n// Calculate the normal to the sphere.\nvec3 sphere = normalize(p);\n\n// Calculate the normal to the box.\nvec3 box = sign(p);\n\n// Combine the normals.\nreturn normalize(sphere + box);\n}\n\n// Calculate the color of the object.\nvec3 ColorToObject(vec3 p)\n{\n// Calculate the color of the sphere.\nvec3 sphere = vec3(1.0, 0.0, 0.0);\n\n// Calculate the color of the box.\nvec3 box = vec3(0.0, 1.0, 0.0);\n\n// Combine the colors.\nreturn sphere + box;\n}\n\n// Calculate the color of the object.\nvec3 ColorToObject(vec3 p, vec3 n)\n{\n// Calculate the color of the sphere.\nvec3 sphere = vec3(1.0, 0.0, 0.0);\n\n// Calculate the color of the box.\nvec3 box = vec3(0.0, 1.0, 0.0);\n\n// Combine the colors.\nreturn sphere + box;\n}\n\n// Calculate the color of the object.\nvec3 ColorToObject(vec3 p, vec3 n, vec3 l)\n{\n// Calculate the color of the sphere.\nvec3 sphere = vec3(1.0, 0.0, 0.0);\n\n// Calculate the color of the box.\nvec3 box = vec3(0.0, 1.0, 0.0);\n\n// Combine the colors.\nreturn sphere + box", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD1(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD2(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD3(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD4(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD5(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD6(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD7(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD8(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD9(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD10(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD11(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD12(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec3 mapD13(float t)\n{\n\treturn vec3(0.0, 0.0", "\n\tvec3 p = map(t);\n\tvec3 d = mapD(t);\n\treturn normalize(d - dot(d, p) * p);\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n\tvec3 p = map(t);\n\tvec3 d = mapD(t);\n\tvec3 dd = mapDD(t);\n\treturn normalize(dd - dot(dd, p) * p - dot(d, d) * p);\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n\tvec3 p = map(t);\n\tvec3 d = mapD(t);\n\tvec3 dd = mapDD(t);\n\tvec3 ddd = mapDDD(t);\n\treturn normalize(ddd - dot(ddd, p) * p - dot(dd, d) * p - dot(d, d) * d);\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n\tvec3 p = map(t);\n\tvec3 d = mapD(t);\n\tvec3 dd = mapDD(t);\n\tvec3 ddd = mapDDD(t);\n\tvec3 dddd = mapDDDD(t);\n\treturn normalize(dddd - dot(dddd, p) * p - dot(ddd, d) * p - dot(dd, dd) * p - dot(d, d) * dd);\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n\tvec3 p = map(t);\n\tvec3 d = mapD(t);\n\tvec3 dd = mapDD(t);\n\tvec3 ddd = mapDDD(t);\n\tvec3 dddd = mapDDDD(t);\n\tvec3 ddddd = mapDDDDD(t);\n\treturn normalize(ddddd - dot(ddddd, p) * p - dot(dddd, d) * p - dot(ddd, dd) * p - dot(dd, dd) * d - dot(d, d) * ddd);\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t", "\n\tvec3 p = map(t);\n\tvec3 p1 = map(t + 0.001);\n\tvec3 p2 = map(t - 0.001);\n\treturn (p1 - 2.0 * p + p2) / 0.001;\n}\n\n// curve curvature\nfloat mapCurvature(float t)\n{\n\tvec3 p = map(t);\n\tvec3 p1 = map(t + 0.001);\n\tvec3 p2 = map(t - 0.001);\n\tvec3 p12 = p1 - p2;\n\tvec3 p21 = p2 - p1;\n\tvec3 p1p2 = p1 - p2;\n\treturn length(cross(p12, p21)) / length(p1p2) / 0.001;\n}\n\n// curve torsion\nfloat mapTorsion(float t)\n{\n\tvec3 p = map(t);\n\tvec3 p1 = map(t + 0.001);\n\tvec3 p2 = map(t - 0.001);\n\tvec3 p12 = p1 - p2;\n\tvec3 p21 = p2 - p1;\n\tvec3 p1p2 = p1 - p2;\n\tvec3 p12p21 = p12 - p21;\n\treturn length(cross(p12, p21)) / length(cross(p1p2, p12p21)) / 0.001;\n}\n\n// curve normal\nvec3 mapNormal(float t)\n{\n\tvec3 p = map(t);\n\tvec3 p1 = map(t + 0.001);\n\tvec3 p2 = map(t - 0.001);\n\tvec3 p12 = p1 - p2;\n\tvec3 p21 = p2 - p1;\n\treturn normalize(cross(p12, p21));\n}\n\n// curve binormal\nvec3 mapBinormal(float t)\n{\n\tvec3 p =", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn vec2( dot( pa, pa ) - h * h * dot( ba, ba ), h );\n}\n\n// signed squared distance between point and segment\nfloat ssqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn dot( pa, pa ) - h * h * dot( ba, ba );\n}\n\n// signed squared distance between point and triangle\nfloat ssqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\tvec3 cb = c - b;\n\tvec3 pb = p - b;\n\tvec3 ac = a - c;\n\tvec3 pc = p - c;\n\tvec3 nor = cross( ba, ac );\n\tfloat d1 = dot( ba, pa );\n\tfloat d2 = dot( ac, pb );\n\tfloat d3 = dot( ba, pc );\n\tfloat d4 = dot( ac, pa );\n\tfloat d5 = dot( cb, pb );\n\tfloat d6 = dot( cb, pc );\n\tif ( d1 < 0.0 ) return dot( pa, pa );\n\tif ( d2 < 0.0 ) return dot( pb, pb );\n\tif ( d3 > d1 ) return dot( pc, pc );\n\tif ( d4 > d1 ) return dot( pa, pa );\n\tif ( d5 > d2 ) return dot( pb, pb );\n\tif ( d6 > d2 ) return dot( pc, pc );\n\tfloat invLenSq = 1.0 / dot( nor, nor );\n\treturn dot( nor, pa ) * dot( nor, pa ) * invLenSq", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tfloat t = dot( ao, ab ) / dot( ad, ab );\n\tt = clamp( t, 0.0, 1.0 );\n\tvec3 p = a + ad * t;\n\tvec3 e = p - o;\n\treturn vec2( dot( e, e ), t );\n}\n\n// signed squared distance between ray and segment\nvec2 ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tfloat t = dot( ao, ab ) / dot( ad, ab );\n\tt = clamp( t, 0.0, 1.0 );\n\tvec3 p = a + ad * t;\n\tvec3 e = p - o;\n\treturn vec2( dot( e, e ), t );\n}\n\n// signed squared distance between ray and triangle\nvec2 ssqdTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tvec3 n = cross( ab, ac );\n\tfloat t = dot( ao, n ) / dot( ad, n );\n\tt = clamp( t, 0.0, 1.0 );\n\tvec3 p = a + ad * t;\n\tvec3 e = p - o;\n\treturn vec2( dot( e, e ), t );\n}\n\n// signed squared distance between ray and triangle\nvec2 ssqdTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d, out vec3 n )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tn = cross( ab, ac );\n\tfloat t = dot( ao, n ) / dot(", "\n  vec2 q = abs(p) - b + r.z;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.x;\n}\n\n// 2D Rounded Rectangle\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundRectangle( in vec2 p, in vec2 b, in vec4 r ) \n{\n  return sdRoundBox(p, vec2(max(b.x,b.y),min(b.x,b.y)), r);\n}\n\n// 2D Rounded Rectangle\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundRectangle( in vec2 p, in vec2 b, in float r ) \n{\n  return sdRoundBox(p, vec2(max(b.x,b.y),min(b.x,b.y)), vec4(r));\n}\n\n// 2D Rounded Rectangle\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundRectangle( in vec2 p, in vec2 b, in float r, in float r2 ) \n{\n  return sdRoundBox(p, vec2(max(b.x,b.y),min(b.x,b.y)), vec4(r,r2,r,r2));\n}\n\n// 2D Rounded Rectangle\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot3 = sunDot2 * sunDot;\n\tfloat sunDot4 = sunDot3 * sunDot;\n\tfloat sunDot5 = sunDot4 * sunDot;\n\tfloat sunDot6 = sunDot5 * sunDot;\n\tfloat sunDot7 = sunDot6 * sunDot;\n\tfloat sunDot8 = sunDot7 * sunDot;\n\tfloat sunDot9 = sunDot8 * sunDot;\n\tfloat sunDot10 = sunDot9 * sunDot;\n\tfloat sunDot11 = sunDot10 * sunDot;\n\tfloat sunDot12 = sunDot11 * sunDot;\n\tfloat sunDot13 = sunDot12 * sunDot;\n\tfloat sunDot14 = sunDot13 * sunDot;\n\tfloat sunDot15 = sunDot14 * sunDot;\n\tfloat sunDot16 = sunDot15 * sunDot;\n\tfloat sunDot17 = sunDot16 * sunDot;\n\tfloat sunDot18 = sunDot17 * sunDot;\n\tfloat sunDot19 = sunDot18 * sunDot;\n\tfloat sunDot20 = sunDot19 * sunDot;\n\tfloat sunDot21 = sunDot20 * sunDot;\n\tfloat sunDot22 = sunDot21 * sunDot;\n\tfloat sunDot23 = sunDot22 * sunDot;\n\tfloat sunDot24 = sunDot23 * sunDot;\n\tfloat sunDot25 = sunDot24 * sunDot;\n\tfloat sunDot26 = sunDot25 * sunDot;\n\tfloat sunDot27 = sunDot26 * sunDot;\n\tfloat sunDot28 = sunDot27 * sunDot;\n\tfloat sunDot29 = sunDot28 * sunDot;\n\tfloat sunDot30 = sunDot29 * sunDot;\n\tfloat sunDot31 = sunDot30 * sunDot;\n\tfloat sunDot32 = sunDot31 * sunDot;\n\tfloat sunDot33 = sunDot32 * sunDot;\n\tfloat sun", "\n\t// This is the vector that points from the center of the screen to the center of the lens\n\tvec3 cw = normalize( ta - ro );\n\n\t// This is the vector that points up from the center of the lens\n\tvec3 cp = vec3( sin( roll ), cos( roll ), 0.0 );\n\n\t// This is the vector that points to the right from the center of the lens\n\tvec3 cu = normalize( cross( cw, cp ) );\n\n\t// This is the vector that points down from the center of the lens\n\tcp = normalize( cross( cu, cw ) );\n\n\treturn mat3( cu, cp, cw );\n}\n\n// This is the function that actually calculates the ray that goes through the window\n// and hits the scene.\nvec3 calculateRay( in vec3 ro, in vec3 ta, in float roll, in vec2 uv )\n{\n\t// This is the matrix that transforms the rays coming out of our eyes and going through the window\n\tmat3 m = calculateEyeRayTransformationMatrix( ro, ta, roll );\n\n\t// This is the vector that points from the center of the screen to the center of the lens\n\tvec3 cw = normalize( ta - ro );\n\n\t// This is the vector that points up from the center of the lens\n\tvec3 cp = vec3( sin( roll ), cos( roll ), 0.0 );\n\n\t// This is the vector that points to the right from the center of the lens\n\tvec3 cu = normalize( cross( cw, cp ) );\n\n\t// This is the vector that points down from the center of the lens\n\tcp = normalize( cross( cu, cw ) );\n\n\t// This is the vector that points to the left from the center of the lens\n\tvec3 cl = normalize( cross( cp, cw ) );\n\n\t// This is the vector that points forward from the center of the lens\n\tvec3 cf = normalize( cross( cw, cl ) );\n\n\t// This is the vector that points backward from the center of the lens\n\tvec3 cb = normalize( cross( cw, cu ) );\n\n\t// This is the vector that points up from the center of the lens\n\tvec3 cp2 = vec3( 0.0, 1.0, 0.0 );\n\n\t// This is", "\n\tvec2 res = vec2(10000.0);\n\tfloat r = 0.0;\n\tfloat h = 0.0;\n\tfloat d = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat c = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat w = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat l = 0.0;\n\tfloat k = 0.0;\n\tfloat j = 0.0;\n\tfloat i = 0.0;\n\tfloat f = 0.0;\n\tfloat e = 0.0;\n\tfloat g = 0.0;\n\tfloat balloonRadius = 0.0;\n\tfloat balloonHeight = 0.0;\n\tfloat balloonThickness = 0.0;\n\tfloat balloonOffset = 0.0;\n\tfloat balloonScale = 0.0;\n\tfloat balloonRotation = 0.0;\n\tfloat balloonRotationOffset = 0.0;\n\tfloat balloonRotationSpeed = 0.0;\n\tfloat balloonRotationSpeedOffset = 0.0;\n\tfloat balloonRotationSpeedScale = 0.0;\n\tfloat balloonRotationSpeedScaleOffset = 0.0;\n\tfloat balloonRotationSpeedScaleSpeed = 0.0;\n\tfloat balloonRotationSpeedScaleSpeedOffset = 0.0;\n\tfloat balloonRotationSpeedScaleSpeedScale = 0.0;\n\tfloat balloonRotationSpeedScaleSpeedScaleOffset = 0.0;\n\tfloat balloonRotationSpeedScaleSpeedScaleSpeed = 0.0;\n\tfloat balloonRotationSpeedScaleSpeedScaleSpeedOffset =", "\n\tvec2 distanceToThing1 = vec2( distance( thing1, mouse ), distance( thing1, vec2( 0.0 ) ) );\n\tvec2 distanceToThing2 = vec2( distance( thing2, mouse ), distance( thing2, vec2( 0.0 ) ) );\n\tif( distanceToThing1.x < distanceToThing2.x ){\n\t\treturn thing1;\n\t}\n\telse{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3 ){\n\tvec2 distanceToThing1 = vec2( distance( thing1, mouse ), distance( thing1, vec2( 0.0 ) ) );\n\tvec2 distanceToThing2 = vec2( distance( thing2, mouse ), distance( thing2, vec2( 0.0 ) ) );\n\tvec2 distanceToThing3 = vec2( distance( thing3, mouse ), distance( thing3, vec2( 0.0 ) ) );\n\tif( distanceToThing1.x < distanceToThing2.x && distanceToThing1.x < distanceToThing3.x ){\n\t\treturn thing1;\n\t}\n\telse if( distanceToThing2.x < distanceToThing1.x && distanceToThing2.x < distanceToThing3.x ){\n\t\treturn thing2;\n\t}\n\telse{\n\t\treturn thing3;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3, vec2 thing4 ){\n\tvec2 distanceToThing1 = vec2( distance( thing1, mouse ), distance( thing1, vec2( 0.0 ) ) );\n", "\n\tvec2 closestObject = vec2( 1000000.0, -1.0 );\n\tfor( int i = 0; i < 100; i++ ){\n\t\tif( closestObject.x < 0.001 || closestObject.x > 1000.0 ){\n\t\t\tbreak;\n\t\t}\n\t\tvec3 position = texture( textureSampler, currentRayPosition ).xyz;\n\t\tvec3 normal = texture( normalSampler, currentRayPosition ).xyz;\n\t\tfloat distanceToObject = length( position - currentRayPosition );\n\t\tclosestObject = vec2( distanceToObject, texture( textureSampler, currentRayPosition ).w );\n\t\tcurrentRayPosition += normal * distanceToObject * 0.75;\n\t}\n\treturn closestObject;\n}\n\n// Takes in the position of the ray, and feeds back\n// the color of the object it is closest to.\nvec3 getColor( vec3 currentRayPosition ){\n\tvec2 closestObject = mapTheWorld( currentRayPosition );\n\tif( closestObject.y < 0.0 ){\n\t\treturn vec3( 0.0, 0.0, 0.0 );\n\t}\n\treturn texture( textureSampler, currentRayPosition ).xyz;\n}\n\n// Takes in the position of the ray, and feeds back\n// the normal of the object it is closest to.\nvec3 getNormal( vec3 currentRayPosition ){\n\tvec2 closestObject = mapTheWorld( currentRayPosition );\n\tif( closestObject.y < 0.0 ){\n\t\treturn vec3( 0.0, 0.0, 0.0 );\n\t}\n\treturn texture( normalSampler, currentRayPosition ).xyz;\n}\n\n// Takes in the position of the ray, and feeds back\n// the color of the object it is closest to.\nvec3 getLight( vec3 currentRayPosition, vec3 normal, vec3 lightPosition ){\n\tvec3 lightColor = vec3( 1.0, 1.0, 1.0 );\n\tvec3 lightDirection = normalize( lightPosition - currentRayPosition );\n\tfloat diffuse = max( dot( lightDirection, normal ), 0.0 );\n\treturn lightColor * diffuse;\n}\n", "\n\tvec3 normal;\n\tnormal.x = distance( positionOfHit + vec3( 1.0, 0.0, 0.0 ), positionOfHit ) - distance( positionOfHit + vec3( -1.0, 0.0, 0.0 ), positionOfHit );\n\tnormal.y = distance( positionOfHit + vec3( 0.0, 1.0, 0.0 ), positionOfHit ) - distance( positionOfHit + vec3( 0.0, -1.0, 0.0 ), positionOfHit );\n\tnormal.z = distance( positionOfHit + vec3( 0.0, 0.0, 1.0 ), positionOfHit ) - distance( positionOfHit + vec3( 0.0, 0.0, -1.0 ), positionOfHit );\n\treturn normalize( normal );\n}\n\n// This is the function that calculates the color of the surface\n// It is a simple function that takes in the position of the hit\n// and the normal of the surface, and returns a color.\nvec3 getColorOfSurface( in vec3 positionOfHit, in vec3 normalOfHit ){\n\t// This is the color of the surface\n\tvec3 color = vec3( 0.0 );\n\t// This is the color of the light\n\tvec3 lightColor = vec3( 1.0 );\n\t// This is the position of the light\n\tvec3 lightPosition = vec3( 0.0, 0.0, 10.0 );\n\t// This is the position of the camera\n\tvec3 cameraPosition = vec3( 0.0, 0.0, 0.0 );\n\t// This is the direction of the light\n\tvec3 lightDirection = normalize( lightPosition - positionOfHit );\n\t// This is the direction of the camera\n\tvec3 cameraDirection = normalize( cameraPosition - positionOfHit );\n\t// This is the direction of the reflection\n\tvec3 reflectionDirection = reflect( lightDirection, normalOfHit );\n\t// This is the direction of the refraction\n\tvec3 refractionDirection = refract( lightDirection, normalOfHit, 1.0 / 1.5 );\n\t// This is the", "\nreturn vec3(0.0);\n}\n\n// this is the main function that we will call\n// to render our scene.\nvoid main(){\n// get the color of the background\nvec3 backgroundColor = doBackgroundColor();\n\n// get the color of the object\nvec3 objectColor = doObjectColor();\n\n// get the color of the light\nvec3 lightColor = doLightColor();\n\n// calculate the final color of the pixel\nvec3 finalColor = backgroundColor + objectColor * lightColor;\n\n// set the color of the pixel\ngl_FragColor = vec4(finalColor, 1.0);\n}\n\n\n## The Code\n\nThe code for this post is up on github.\n\n## The Result\n\nHere is the result of the code above.\n\nThe code is a bit rough around the edges, but it\u2019s a start!\n\n# A Simple Ray Tracer in 100 Lines of\u00a0C++\n\nThis post is an attempt to explain how to write a simple ray tracer, and how to make it render a simple scene.\n\nThe code for this post is up on github.\n\n## The Idea\n\nThe idea of a ray tracer is that you shoot rays out from the camera, and see where they hit things.\n\nThe simplest way to do this is to shoot a ray from the camera position, and see where it hits something.\n\nIf it hits something, you know what color to show for that pixel.\n\nIf it doesn\u2019t hit anything, you know that the pixel is in the background, and you can show whatever color you want.\n\n## The Math\n\nTo do this, we need to know how to shoot a ray out from the camera.\n\nThe ray starts at the camera position, and goes in the direction that the camera is facing.\n\nThe camera is facing the direction that the camera is looking at, and is rotated by the camera\u2019s pitch and yaw.\n\nThe pitch is how much the camera is up or down.\n\nThe yaw is how much the camera is rotating left or right.\n\nPitch and yaw are measured in degrees.\n\nPitch is measured up and down, and ranges from -90 to 90 degrees.\n\nYaw is measured left and right, and ranges from -180 to 180 degrees.\n\n", "\n\n// This is the color of the box\nvec3 boxColor = vec3(0.0, 0.0, 0.0);\n\n// This is the color of the light\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// This is the position of the light\nvec3 lightPosition = vec3(0.0, 0.0, 0.0);\n\n// This is the position of the camera\nvec3 cameraPosition = vec3(0.0, 0.0, 0.0);\n\n// This is the direction of the light\nvec3 lightDirection = normalize(lightPosition - positionOfHit);\n\n// This is the direction of the camera\nvec3 cameraDirection = normalize(cameraPosition - positionOfHit);\n\n// This is the direction of the surface\nvec3 surfaceDirection = normalize(normalOfSurface);\n\n// This is the reflection of the light\nvec3 reflection = reflect(lightDirection, surfaceDirection);\n\n// This is the dot product of the reflection and the camera direction\nfloat dotProduct = dot(reflection, cameraDirection);\n\n// This is the color of the box\nboxColor = mix(boxColor, lightColor, dotProduct);\n\n// This is the color of the box\nboxColor = mix(boxColor, vec3(1.0, 1.0, 1.0), 0.5);\n\n// This is the color of the box\nboxColor = mix(boxColor, vec3(0.0, 0.0, 0.0), 0.25);\n\n// This is the color of the box\nboxColor = mix(boxColor, vec3(1.0, 0.0, 0.0), 0.125);\n\n// This is the color of the box\nboxColor = mix(boxColor, vec3(0.0, 1.0, 0.0), 0.0625);\n\n// This is the color of the box\nboxColor = mix(boxColor, vec3(0.0, 0.0, 1.0), 0.03125);\n\n// This is the color of the box\nboxColor = mix(boxColor", "\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\tvec3 color = vec3(0.0);\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t// This is where we decide\n\t// what color the world will be!\n\t// and what marvelous colors it will be!\n\t//", "\n\treturn (x - 0.5) / (1.0 - b) + 0.5;\n}\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec2 bias(vec2 x, float b) {\n\treturn (x - 0.5) / (1.0 - b) + 0.5;\n}\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec3 bias(vec3 x, float b) {\n\treturn (x - 0.5) / (1.0 - b) + 0.5;\n}\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec4 bias(vec4 x, float b) {\n\treturn (x - 0.5) / (1.0 - b) + 0.5;\n}\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n", "\n\treturn fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n\treturn fract(sin(dot(p,vec3(12.9898,78.233,151.7182))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n\treturn fract(sin(dot(p,vec4(12.9898,78.233,151.7182,31.5154))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p){\n\treturn fract(sin(p) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(int p){\n\treturn fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(uint p){\n\treturn fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, float seed){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233))) * seed);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p, float seed){\n\treturn fract(sin(dot(p,vec3(12.9898,78.233,151.7182))) * seed);\n}\n", "\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range -1..1 including -1 including 1\nfloat rand_inclusive_signed(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 0.99999;\n}\n\n// creates white noise in the range -1..1 excluding -1 and 1\nfloat rand_exclusive_signed(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 0.99999 * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 including 0 and 1\nfloat rand_inclusive_01(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0;\n}\n\n// creates white noise in the range -1..1 including -1 and 1\nfloat rand_inclusive_signed_01(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 4.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input r --> is box radius\n// pretty simple, just compare point to radius of box\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// pretty simple, just compare point to radius of cylinder\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input r --> is torus radius\n// pretty simple, just compare point to radius of torus\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed fistance fuction for capsule\n// input r --> is capsule radius\n// pretty simple, just compare point to radius of capsule\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r --> is cone radius\n// pretty simple, just compare point to radius of cone\nfloat sdCone(vec3 p, vec3 c)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    return max(q.x - c.z - c.y * 0", "\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input t --> cylinder specs where:\n// \tt.x = cylinder radius\n//\tt.y = cylinder height\n//  \n// think of the cylinder as a rectangle with a circle on top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder thickenss from that \nfloat sdCylinder(vec3 p, vec2 t)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - t;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input t --> cone specs where:\n// \tt.x = cone radius\n//\tt.y = cone height\n//  \n// think of the cone as a rectangle with a circle on top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cone circumference/core/radius which is flat on the y axis\n// then simply subtract the cone thickenss from that \nfloat sdCone(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz),abs(p.y));\n\treturn max(q.x*0.8-q.y*0.8,q.y-t.y*0.5);\n}\n\n// ~~~~~~~ signed distance function for a capsule\n// input t --> capsule specs where:\n// \tt.x = capsule radius\n//\tt.y = capsule height\n//  \n// think of the capsule as a rectangle with a circle on top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the capsule circumference/core/", "\n\tconst float k = 0.1;\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance function for a sphere\n// input p --> position of the sphere\n// input r --> radius of the sphere\n// output --> distance to the sphere\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ distance function for a box\n// input p --> position of the box\n// input b --> size of the box\n// output --> distance to the box\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ distance function for a torus\n// input p --> position of the torus\n// input t --> size of the torus\n// output --> distance to the torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ distance function for a cylinder\n// input p --> position of the cylinder\n// input h --> height of the cylinder\n// input r --> radius of the cylinder\n// output --> distance to the cylinder\nfloat sdCylinder( vec3 p, float h, float r )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ distance function for a cone\n// input p --> position of the cone\n// input h --> height of the cone\n// input r --> radius of the cone\n// output --> distance to the cone", "\n\treturn max(d2,-d1);\n}\n\n// ~~~~~~~ union of 2 shapes\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> union of the 2 objects\nfloat opUnion( float d1, float d2)\n{\n\treturn min(d1,d2);\n}\n\n// ~~~~~~~ intersection of 2 shapes\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> intersection of the 2 objects\nfloat opIntersect( float d1, float d2)\n{\n\treturn max(d1,d2);\n}\n\n// ~~~~~~~ subtraction of 2 shapes\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> subtraction of the 2 objects\nfloat opSubtract( float d1, float d2)\n{\n\treturn max(-d1,d2);\n}\n\n// ~~~~~~~ smooth union of 2 shapes\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> smoothness\n// output --> smooth union of the 2 objects\nfloat opSmoothUnion( float d1, float d2, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth intersection of 2 shapes\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> smoothness\n// output --> smooth intersection of the 2 objects\nfloat opSmoothIntersect( float d1, float d2, float k)\n{\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth subtraction of 2 shapes\n// input d1 --> distance", "\n\tfloat c = cos(yaw);\n\tfloat s = sin(yaw);\n\tmat2  m = mat2(c,-s,s,c);\n\tvec3  q = vec3(m*p.xz,p.y);\n\treturn p + q*t;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, vec2 twist )\n{\n\tfloat c = cos(twist.x);\n\tfloat s = sin(twist.x);\n\tmat2  m = mat2(c,-s,s,c);\n\tvec3  q = vec3(m*p.xz,p.y);\n\treturn p + q*t;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, vec2 twist, float yaw )\n{\n\tfloat c = cos(twist.x+yaw);\n\tfloat s = sin(twist.x+yaw);\n\tmat2  m = mat2(c,-s,s,c);\n\tvec3  q = vec3(m*p.xz,p.y);\n\treturn p + q*t;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, vec2 twist, float yaw, float pitch )\n{\n\tfloat c = cos(twist.x+yaw);\n\tfloat s = sin(twist.x+yaw);\n\tmat2  m", "\n\treturn o1.x<o2.x? o1 : o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n\treturn o1.x>o2.x? o1 : o2;\n}\n\n// ~~~~~~~ do Subtraction / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\n\treturn o1.x>o2.x? o1 : o2;\n}\n\n// ~~~~~~~ do Smooth Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSU(vec2 o1, vec2 o2)\n{\n\tfloat d1 = o1.x, d2 = o2.x;\n\tfloat h = clamp(0.5 + 0.5*(d2-d1)/fwidth(d1), 0.0, 1.0);\n\treturn vec2(mix(d1, d2, h) - h*(1.0-h)*k, o1.y);\n}\n\n// ~~~~~~~ do Smooth Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opSI(vec2 o1, vec2 o2)\n{\n\tfloat d1 = o1.x, d2 = o2.x;\n\tfloat h = clamp(0.5 + 0.5*(d2-d1)/fwidth(d1), 0.0, 1.0);\n\treturn vec2(mix(d1, d2, h) + h*(1", "\n\t// ~~~~~~~ sphere\n\tvec2 sphere = sphere_map(p);\n\t// ~~~~~~~ box\n\tvec2 box = box_map(p);\n\t// ~~~~~~~ cylinder\n\tvec2 cylinder = cylinder_map(p);\n\t// ~~~~~~~ plane\n\tvec2 plane = plane_map(p);\n\t// ~~~~~~~ union\n\tvec2 union_ = union_map(sphere, box);\n\t// ~~~~~~~ intersection\n\tvec2 intersection = intersection_map(union_, cylinder);\n\t// ~~~~~~~ subtraction\n\tvec2 subtraction = subtraction_map(intersection, plane);\n\t// ~~~~~~~ return\n\treturn subtraction;\n}\n\n// ~~~~~~~ ray marching\n// input p --> is ray position\n// input d --> is ray direction\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nfloat ray_march(vec3 p, vec3 d)\n{\n\t// ~~~~~~~ sphere\n\tfloat sphere = sphere_ray_march(p, d);\n\t// ~~~~~~~ box\n\tfloat box = box_ray_march(p, d);\n\t// ~~~~~~~ cylinder\n\tfloat cylinder = cylinder_ray_march(p, d);\n\t// ~~~~~~~ plane\n\tfloat plane = plane_ray_march(p, d);\n\t// ~~~~~~~ union\n\tfloat union_ = union_ray_march(sphere, box);\n\t// ~~~~~~~ intersection\n\tfloat intersection = intersection_ray_march(union_, cylinder);\n\t// ~~~~~~~ subtraction\n\tfloat subtraction = subtraction_ray_march(intersection, plane);\n\t// ~~~~~~~ return\n\treturn subtraction;\n}\n\n// ~~~~~~~ normal\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec3 normal(vec3 p)\n{\n\t// ~~~~~~~ sphere\n\tvec3 sphere = sphere_normal(p);\n\t// ~~~~~~~ box\n\tvec", "\n\tvec2 res = vec2(1000000.0, -1.0);\n\tfloat t = 0.0;\n\tfor( int i=0; i<MAX_STEPS; i++ )\n\t{\n\t\tvec3 p = ro + rd*t;\n\t\tfloat d = map(p);\n\t\tres = vec2(t,d);\n\t\tif( abs(d)<0.001 || t>MAX_DIST ) break;\n\t\tt += d*0.5;\n\t}\n\treturn res;\n}\n\n// ~~~~~~~ calculate normal\n// input p --> point on surface\n// output is normal vector\n//\nvec3 calcNormal( in vec3 p )\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize( e.xyy*map( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ) );\n}\n\n// ~~~~~~~ calculate lighting\n// input p --> point on surface\n// input n --> normal vector\n// input l --> light vector\n// input c --> color\n// output is color\n//\nvec3 calcLighting( in vec3 p, in vec3 n, in vec3 l, in vec3 c )\n{\n\tfloat dif = clamp( dot(n,l), 0.0, 1.0 );\n\tfloat bac = clamp( dot(n,-l), 0.0, 1.0 );\n\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\treturn c*dif + c*bac*0.1 + c*amb*0.3;\n}\n\n// ~~~~~~~ calculate fog\n// input d --> distance travelled by ray\n// output is color\n//\nvec3 calcFog( in float d )\n{\n\treturn vec3( 0.5 + 0.5*sin(d*0.01) );\n}\n\n// ~~~~", "\n\t// ~~~~~~~ raymarching\n\tfloat t = 0.0;\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\t// ~~~~~~~ get current position\n\t\tvec3 p = ro + t * rd;\n\n\t\t// ~~~~~~~ get current distance to closest surface\n\t\tfloat d = map(p);\n\n\t\t// ~~~~~~~ if we hit a surface, return the color\n\t\tif (d < EPSILON)\n\t\t{\n\t\t\treturn getColor(p, d);\n\t\t}\n\n\t\t// ~~~~~~~ if we hit the sky, return the sky color\n\t\tif (p.y > SKY_HEIGHT)\n\t\t{\n\t\t\treturn SKY_COLOR;\n\t\t}\n\n\t\t// ~~~~~~~ advance ray\n\t\tt += d;\n\t}\n\n\t// ~~~~~~~ if we didn't hit anything, return the background color\n\treturn BACKGROUND_COLOR;\n}\n\n// ~~~~~~~ main\nvoid main()\n{\n\t// ~~~~~~~ get pixel coordinates\n\tvec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// ~~~~~~~ get camera position\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\n\t// ~~~~~~~ get camera direction\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\n\t// ~~~~~~~ render pixel\n\tvec3 color = render(ro, rd);\n\n\t// ~~~~~~~ output color\n\tgl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 camDir = normalize( targetPos - camPos );\n\tvec3 camUp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 camRight = normalize( cross( camUp, camDir ) );\n\tcamUp = normalize( cross( camDir, camRight ) );\n\tmat3 camMat = mat3( camRight, camUp, camDir );\n\tcamMat = rotate( camMat, roll );\n\treturn camMat;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 camUp, float roll )\n{\n\tvec3 camDir = normalize( targetPos - camPos );\n\tvec3 camRight = normalize( cross( camUp, camDir ) );\n\tcamUp = normalize( cross( camDir, camRight ) );\n\tmat3 camMat = mat3( camRight, camUp, camDir );\n\tcamMat = rotate( camMat, roll );\n\treturn camMat;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 camUp, in vec3 camRight, float roll )\n{\n\tvec3 camDir = normalize( targetPos - camPos );\n\tcamUp = normalize( cross( camDir, camRight ) );\n\tcamRight = normalize( cross( camUp, camDir ) );\n\tmat3 camMat = mat3( camRight, camUp, camDir );\n\tcamMat = rotate( camMat, roll );\n\treturn camMat;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat4 setCamera", "\n    if(id == 0.0) return vec3(1.0,0.0,0.0);\n    if(id == 1.0) return vec3(0.0,1.0,0.0);\n    if(id == 2.0) return vec3(0.0,0.0,1.0);\n    if(id == 3.0) return vec3(1.0,1.0,0.0);\n    if(id == 4.0) return vec3(1.0,0.0,1.0);\n    if(id == 5.0) return vec3(0.0,1.0,1.0);\n    if(id == 6.0) return vec3(1.0,1.0,1.0);\n    if(id == 7.0) return vec3(0.0,0.0,0.0);\n    if(id == 8.0) return vec3(0.5,0.5,0.5);\n    if(id == 9.0) return vec3(0.5,0.0,0.0);\n    if(id == 10.0) return vec3(0.0,0.5,0.0);\n    if(id == 11.0) return vec3(0.0,0.0,0.5);\n    if(id == 12.0) return vec3(0.5,0.5,0.0);\n    if(id == 13.0) return vec3(0.5,0.0,0.5);\n    if(id == 14.0) return vec3(0.0,0.5,0.5);\n    if(id == 15.0) return vec3(0.5,0.5,0.5);\n    if(id == 16.0) return vec3(0.25,0.25,0.25);\n    if(id == 17.0) return vec3(0.25,0.0,0.0);\n    if(id == 18.0) return vec3(0.0,0.25,0.0);\n    if(id", "\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input t --> cylinder specs where:\n//  t.x = cylinder radius\n//  t.y = cylinder height\n//  \n// think of the cylinder as a rectangle with a circle on top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder thickenss from that \nfloat sdCylinder(vec3 p, vec2 t)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - t;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input t --> cone specs where:\n//  t.x = cone radius\n//  t.y = cone height\n//  \n// think of the cone as a rectangle with a circle on top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cone circumference/core/radius which is flat on the y axis\n// then simply subtract the cone thickenss from that \nfloat sdCone(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz),abs(p.y));\n\treturn max(q.x*0.8-q.y*0.6,q.y-t.y*0.5);\n}\n\n// ~~~~~~~ signed distance function for a capsule\n// input t --> capsule specs where:\n//  t.x = capsule radius\n//  t.y = capsule height\n//  \n// think of the capsule as a rectangle with a circle on top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the capsule circumference/core/radius which is", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> width\n// sphere extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdSphere(vec3 p)\n{\n    return length(p) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n// box extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdBox(vec3 p)\n{\n    vec3 d = abs(p) - ps.xyz;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> width\n// cylinder extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdCylinder(vec3 p)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - ps.xy;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> width\n// torus extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdTorus(vec3 p)\n{\n    vec2 q = vec2(length(p.xz)-ps.x,p.y);\n    return length(q)-ps.y;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance function for a sphere\n// input p --> position of the sphere\n// input r --> radius of the sphere\n// output --> distance value\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ distance function for a box\n// input p --> position of the box\n// input b --> size of the box\n// output --> distance value\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ distance function for a torus\n// input p --> position of the torus\n// input t --> size of the torus\n// output --> distance value\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ distance function for a cylinder\n// input p --> position of the cylinder\n// input h --> height of the cylinder\n// input r --> radius of the cylinder\n// output --> distance value\nfloat sdCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ distance function for a cone\n// input p --> position of the cone\n// input h --> height of the cone\n// input r --> radius of the cone\n// output --> distance value\nfloat sdCone( vec3 p, float h, float r )\n{\n    vec2 q = vec2(length(p.xz),p", "\n\tfloat d = min(o1.x,o2.x);\n\tfloat m = mix(o1.y,o2.y,bf);\n\treturn vec4(d,m,m,m);\n}\n\n// ~~~~~~~ union is the closest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> closest dist, blended material color\nvec4 opUnion( vec4 o1, vec4 o2 )\n{\n\treturn min(o1,o2);\n}\n\n// ~~~~~~~ intersection is the farthest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> farthest dist, blended material color\nvec4 opIntersect( vec4 o1, vec4 o2 )\n{\n\treturn max(o1,o2);\n}\n\n// ~~~~~~~ subtraction is first object minus second object\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> subtracted dist, blended material color\nvec4 opSubtract( vec4 o1, vec4 o2 )\n{\n\treturn max(o1,-o2);\n}\n\n// ~~~~~~~ smooth union is the closest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input k --> blend factor\n// output --> closest dist, blended material color\nvec4 opSmoothUnion( vec4 o1, vec4 o2, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(o2.x-o1.x)/k, 0.0, 1.0 );\n\treturn vec4( mix(o1.x, o2.x, h) - k*h*(1.0-h), o1.y );\n}\n\n// ~~~~~~~ smooth intersection is the farthest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 -->", "\n\treturn max(-d1,d2);\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nvec2 opSub(vec2 d1,vec2 d2)\n{\n\treturn vec2(max(-d1.x,d2.x),max(-d1.y,d2.y));\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nvec3 opSub(vec3 d1,vec3 d2)\n{\n\treturn vec3(max(-d1.x,d2.x),max(-d1.y,d2.y),max(-d1.z,d2.z));\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nvec4 opSub(vec4 d1,vec4 d2)\n{\n\treturn vec4(max(-d1.x,d2.x),max(-d1.y,d2.y),max(-d1.z,d2.z),max(-d1.w,d2.w));\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2,float k)\n{\n\treturn max(-d1,d2-k);\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of", "\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (1.0 - 2.0 * random(vec2(0.0, 0.0))) * 100.0;\n    lightPos.y = (1.0 - 2.0 * random(vec2(0.0, 1.0))) * 100.0;\n    lightPos.z = (1.0 - 2.0 * random(vec2(0.0, 2.0))) * 100.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos2()\n{\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (1.0 - 2.0 * random(vec2(0.0, 0.0))) * 100.0;\n    lightPos.y = (1.0 - 2.0 * random(vec2(0.0, 1.0))) * 100.0;\n    lightPos.z = (1.0 - 2.0 * random(vec2(0.0, 2.0))) * 100.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos3()\n{\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (1.0 - 2.0 * random(vec2(0.0, 0.0))) * 100.0;\n    lightPos.y = (1.0 - 2.0 * random(vec2(0.0, 1.0))) * 100.0;\n    lightPos.z = (1.0 - 2.0 * random(vec2(0.0, 2.0))) * 100.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos4()\n{\n    vec3 lightPos = vec3(0.0);\n   ", "\n\t// ~~~~~~~ define the objects\n\t// sphere\n\tfloat sphere = sdSphere(p, 1.0);\n\t// box\n\tfloat box = sdBox(p, vec3(1.0));\n\t// cylinder\n\tfloat cylinder = sdCylinder(p, vec2(1.0));\n\t// torus\n\tfloat torus = sdTorus(p, vec2(0.5, 0.2));\n\t// ~~~~~~~ combine the objects\n\t// union\n\tfloat dist = opU(sphere, box);\n\t// intersection\n\tdist = opI(dist, cylinder);\n\t// subtraction\n\tdist = opS(dist, torus);\n\t// ~~~~~~~ return the distance and color\n\treturn vec4(dist, 0.0, 0.0, 1.0);\n}\n\n// ~~~~~~~ raymarching\n// input p --> is ray position\n// input d --> is ray direction\n// outputs the distance to the closest surface\nfloat raymarch(vec3 p, vec3 d)\n{\n\t// ~~~~~~~ define the objects\n\t// sphere\n\tfloat sphere = sdSphere(p, 1.0);\n\t// box\n\tfloat box = sdBox(p, vec3(1.0));\n\t// cylinder\n\tfloat cylinder = sdCylinder(p, vec2(1.0));\n\t// torus\n\tfloat torus = sdTorus(p, vec2(0.5, 0.2));\n\t// ~~~~~~~ combine the objects\n\t// union\n\tfloat dist = opU(sphere, box);\n\t// intersection\n\tdist = opI(dist, cylinder);\n\t// subtraction\n\tdist = opS(dist, torus);\n\t// ~~~~~~~ return the distance\n\treturn dist;\n}\n\n// ~~~~~~~ main\nvoid main()\n{\n\t// ~~~~~~~ get the ray position and direction\n\tvec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\tvec3 p = vec3(0.0, 0.0, 2.0);\n\tvec3 d = normalize(vec3(", "\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t// ~~~~~~~ ray marching\n\t", "\n    float shadow = 1.0;\n    float t = 0.0;\n    float d = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float m = 0.0;\n    float c = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tinc = 0.001;\n    float tstep = 0.0;\n    float tstep2 = 0.0;\n    float tstep3 = 0.0;\n    float tstep4 = 0.0;\n    float tstep5 = 0.0;\n    float tstep6 = 0.0;\n    float tstep7 = 0.0;\n    float tstep8 = 0.0;\n    float tstep9 = 0.0;\n    float tstep10 = 0.0;\n    float tstep11 = 0.0;\n    float tstep12 = 0.0;\n    float tstep13 = 0.0;\n    float tstep14 = 0.0;\n    float tstep15 = 0.0;\n    float tstep16 = 0.0;\n    float tstep17 = 0.0;\n    float tstep18 = 0.0;\n    float tstep19 = 0.0;\n    float tstep20 = 0.0;\n    float tstep21 = 0.0;\n    float tstep22 = 0.0;\n    float tstep23 = 0.0;\n    float tstep24 = 0.0;\n    float tstep25 = 0.0;\n    float tstep26 = 0.0;\n    float tstep27 = 0.0;\n    float tstep28 = 0.0;\n    float tstep29 = 0.0;\n    float tstep30 = 0.0;\n    float tstep31 = 0.0;\n    float tstep32 = 0.0;\n    float tstep33 = 0.0;\n    float tstep34 = 0.0;\n    float tstep35 = 0.0;\n    float t", "\n    float res = 1.0;\n    float t = 0.0;\n    float precis = 0.001;\n    float h = 1.0;\n    const int NUM_STEPS = 10;\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        if (h < precis || t > 10.0) break;\n        t += h;\n        vec3 pos = sp + t * nor;\n        float d = map(pos);\n        h = d * 0.5;\n    }\n    if (t < 10.0) res = 0.0;\n    return res;\n}\n\n// ~~~~~~~ lighting\nvec3 calcNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx));\n    return normalize(nor);\n}\n\nvec3 calcLight(vec3 pos, vec3 nor, vec3 lightDir, vec3 lightCol)\n{\n    float diff = clamp(dot(nor, lightDir), 0.0, 1.0);\n    vec3 ref = reflect(lightDir, nor);\n    float spec = pow(clamp(dot(ref, normalize(camPos - pos)), 0.0, 1.0), 16.0);\n    return lightCol * (diff + spec);\n}\n\n// ~~~~~~~ main\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec3 camTar = vec3(0.0, 0.0, 0.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camFwd = normalize(camTar - camPos);\n    vec3 camRight = normalize(cross(", "\n\tvec3 n1 = normalize(p + vec3(0.0, 0.0, 0.01) - p);\n\tvec3 n2 = normalize(p + vec3(0.0, 0.0, -0.01) - p);\n\tvec3 n3 = normalize(p + vec3(0.01, 0.0, 0.0) - p);\n\tvec3 n4 = normalize(p + vec3(-0.01, 0.0, 0.0) - p);\n\tvec3 n5 = normalize(p + vec3(0.0, 0.01, 0.0) - p);\n\tvec3 n6 = normalize(p + vec3(0.0, -0.01, 0.0) - p);\n\tvec3 n7 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n8 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n9 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n10 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n11 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n12 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n13 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n14 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n15 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec3 n16 = normalize(p + vec3(0.0, 0.0, 0.0) - p);\n\tvec", "\n\treturn pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma)\n{\n\treturn pow(c, vec3(1.0/gamma));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float exposure)\n{\n\treturn pow(c, vec3(1.0/gamma)) * exposure;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float exposure, float gammaCorrection)\n{\n\treturn pow(c, vec3(1.0/gamma)) * exposure * gammaCorrection;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float exposure, float gammaCorrection, float gammaCorrection2)\n{\n\treturn pow(c, vec3(1.0/gamma)) * exposure * gammaCorrection * gammaCorrection2;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c", "\n\t// fog color\n\tvec3 fc=mix(fc1,fc2,pow(clamp(1.0-exp(-fs.x*d),0.0,1.0),fs.y));\n\t// fog amount\n\tfloat f=clamp(1.0-exp(-fs.x*d),0.0,1.0);\n\t// fog color lerp\n\tfc=mix(c,fc,f);\n\t// fog specular\n\tfloat fspec=pow(clamp(dot(cRD,lRD),0.0,1.0),16.0);\n\t// fog specular lerp\n\tfc=mix(c,fc,fspec);\n\t// return final color\n\treturn fc;\n}\n\n// ~~~~~~~ do lighting\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyLighting(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n\t// fog color\n\tvec3 fc=mix(fc1,fc2,pow(clamp(1.0-exp(-fs.x*d),0.0,1.0),fs.y));\n\t// fog amount\n\tfloat f=clamp(1.0-exp(-fs.x*d),0.0,1.0);\n\t// fog color lerp\n\tfc=mix(c,fc,f);\n\t// fog specular\n\tfloat fspec=pow(clamp(dot(cRD,lRD),0.0,1.0),16.0);\n\t// fog specular lerp\n\tfc=mix(c,fc,fspec);\n\t// return final color\n\treturn fc;\n}\n\n// ~~~~~~~ do lighting\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 -->", "\n\treturn 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, vec3 pos, vec3 lightPos)\n{\n\treturn 1.0 / (cF + lF * length(pos - lightPos) + qF * length(pos - lightPos) * length(pos - lightPos));\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, vec3 pos, vec3 lightPos, float lightRadius)\n{\n\tfloat d = length(pos - lightPos);\n\tif (d > lightRadius)\n\t\treturn 0.0;\n\treturn 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, vec3 pos, vec3 lightPos, float lightRadius, float lightRadius2)\n{\n\tfloat d = length(pos - lightPos);", "\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, 1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate the color of the pixel\n// input rayDir --> ray direction\n// input scene --> scene object\n// output --> color of the pixel\nvec3 calculatePixelColor(vec3 rayDir, Scene scene)\n{\n    vec3 color = vec3(0.0);\n    vec3 hitPoint = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    float lightIntensity = 0.0;\n    float lightDistance = 0.0;\n    float lightAttenuation = 0.0;\n    float lightDot = 0.0;\n    float lightSpecular = 0.0;\n    float lightSpecularIntensity = 0.0;\n    float lightSpecularPower = 0.0;\n    float lightSpecularDot = 0.0;\n    float lightSpecularAttenuation = 0.0;\n    float lightSpecularIntensityAttenuation = 0.0;\n    float lightSpecularPowerAttenuation = 0.0;\n    float lightSpecularDotAttenuation = 0.0;\n    float lightSpecularIntensityDotAttenuation = 0.0;\n    float lightSpecularPowerDotAttenuation = 0.0;\n    float lightSpecularIntensityDotAttenuationPower = 0.0;\n    float lightSpecularPowerDotAttenuationIntensity = 0.0;\n    float lightSpecularIntensityDotAttenuationPowerIntensity = 0.0;\n    float lightSpecularPowerDotAttenuationIntensityPower = 0.0;\n    float lightSpecularIntensityDotAttenuationPowerIntensityPower = 0.0;\n    float lightSpecularPowerDotAttenuationIntensityPowerIntensity = 0.0;\n    float lightSpecularIntensityDotAttenuationPowerIntensityPowerIntensity = 0.0;\n    float lightSpecularPowerDotAttenuationIntensityPowerIntensityPower = 0.0;\n    float lightSpecularIntensityDotAttenuationPowerIntensityPowerIntensityPower = 0.0;\n    float lightSpecularPowerDotAttenuationIntensityPowerIntensityPowerIntensity = 0.0;\n    float lightSpecularIntensityDotAttenuationPowerIntensityPowerIntensityPowerIntensity = 0.0;\n    float lightSpecularPowerDotAttenuationIntensityPowerIntensityPowerIntensityPowerIntensity", "\n    // ~~~~~~~ get pixel's itteration/march count\n    float itt = get_itt(fCoord,cPos,cMat);\n    // ~~~~~~~ get pixel's color\n    vec3 col = get_col(fCoord,cPos,cMat);\n    // ~~~~~~~ get pixel's alpha\n    float alpha = get_alpha(fCoord,cPos,cMat);\n    // ~~~~~~~ get pixel's color based on itteration/march count\n    vec3 col_AA = get_col_AA(itt,col,alpha);\n    // ~~~~~~~ return pixel's color\n    return col_AA;\n}\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat,float itt)\n{\n    // ~~~~~~~ get pixel's color\n    vec3 col = get_col(fCoord,cPos,cMat);\n    // ~~~~~~~ get pixel's alpha\n    float alpha = get_alpha(fCoord,cPos,cMat);\n    // ~~~~~~~ get pixel's color based on itteration/march count\n    vec3 col_AA = get_col_AA(itt,col,alpha);\n    // ~~~~~~~ return pixel's color\n    return col_AA;\n}\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat,float itt,vec3 col)\n{\n    // ~~~~~~~ get pixel's alpha\n    float alpha = get_alpha(fCoord,cPos,cMat);\n    // ~~~~~~~ get pixel's color based on itteration/march count\n    vec3 col_AA = get_col_AA(itt,", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float zoom = 1.0;\n    float x = 0.0;\n    float y = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z = 0.0;\n    float z1 = 0.0;\n    float z2 = 0.0;\n    float z3 = 0.0;\n    float z4 = 0.0;\n    float z5 = 0.0;\n    float z6 = 0.0;\n    float z7 = 0.0;\n    float z8 = 0.0;\n    float z9 = 0.0;\n    float z10 = 0.0;\n    float z11 = 0.0;\n    float z12 = 0.0;\n    float z13 = 0.0;\n    float z14 = 0.0;\n    float z15 = 0.0;\n    float z16 = 0.0;\n    float z17 = 0.0;\n    float z18 = 0.0;\n    float z19 = 0.0;\n    float z20 = 0.0;\n    float z21 = 0.0;\n    float z22 = 0.0;\n    float z23 = 0.0;\n    float z24 = 0.0;\n    float z25 = 0.0;\n    float z26 = 0.0", "\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec2 c)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    return max(dot(q, c) - c.y, length(q) - c.x);\n}\n\n// capsule distance field\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n// distance field for a 3D grid\nfloat sdGrid(vec3 p, vec3 cellSize, vec3 cellCount)\n{\n    vec3 q = abs(p) / cellSize;\n    vec3 r = fract(q);\n    vec3 s = step(q, vec3(0.5));\n    return length(max(r - vec3(0.5) * s, 0.0)) * sign(dot", "\n\treturn length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// simple torus distance field\nfloat torus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// simple cone distance field\nfloat cone(vec3 p, float r, float h)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\treturn max(q.y - h, dot(q, q) - r * r);\n}\n\n// simple capsule distance field\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\n// simple plane distance field\nfloat plane(vec3 p, vec4 n)\n{\n\treturn dot(p, n.xyz) + n.w;\n}\n\n// simple triangle distance field\nfloat tri(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 v0 = c - a, v1 = b - a, v2 = p - a;\n\tfloat d00 = dot(v0, v0);\n\tfloat d01 = dot(v0, v1);\n\tfloat d11 = dot(v1, v1);\n\tfloat d20 = dot(v2, v0);\n\tfloat d21 = dot(v2, v1);\n\tfloat denom =", "\n\t// The distance to the nearest surface is the minimum of all the distances\n\t// to the surfaces of the objects.\n\t// The material number is the material number of the nearest surface.\n\tfloat d = 1e30;\n\tint material = 0;\n\n\t// The distance to the plane is the z coordinate.\n\t// The material number is 1.\n\tfloat dz = p.z;\n\tif (dz < d)\n\t{\n\t\td = dz;\n\t\tmaterial = 1;\n\t}\n\n\t// The distance to the sphere is the length of the vector from the sphere center\n\t// to the point.\n\t// The material number is 2.\n\tfloat ds = length(p - vec3(0, 0, 1));\n\tif (ds < d)\n\t{\n\t\td = ds;\n\t\tmaterial = 2;\n\t}\n\n\t// The distance to the torus is the length of the vector from the torus center\n\t// to the point minus the radius of the torus.\n\t// The material number is 3.\n\tfloat dt = length(p - vec3(0, 0, 2)) - 0.5;\n\tif (dt < d)\n\t{\n\t\td = dt;\n\t\tmaterial = 3;\n\t}\n\n\t// The distance to the cone is the length of the vector from the cone tip\n\t// to the point minus the radius of the cone.\n\t// The material number is 4.\n\tfloat dc = length(p - vec3(0, 0, 3)) - 0.5;\n\tif (dc < d)\n\t{\n\t\td = dc;\n\t\tmaterial = 4;\n\t}\n\n\t// The distance to the cylinder is the length of the vector from the cylinder center\n\t// to the point minus the radius of the cylinder.\n\t// The material number is 5.\n\tfloat dy = length(p - vec3(0, 0, 4)) - 0.5;\n\tif (dy < d)\n\t{\n\t\td = dy;\n\t\tmaterial = 5;\n\t}\n\n\t// The distance to the box is the length of the vector from the box center\n\t", "\n    vec2 z = vec2(0.0);\n    vec2 z2 = vec2(0.0);\n    vec2 z3 = vec2(0.0);\n    vec2 z4 = vec2(0.0);\n    vec2 z5 = vec2(0.0);\n    vec2 z6 = vec2(0.0);\n    vec2 z7 = vec2(0.0);\n    vec2 z8 = vec2(0.0);\n    vec2 z9 = vec2(0.0);\n    vec2 z10 = vec2(0.0);\n    vec2 z11 = vec2(0.0);\n    vec2 z12 = vec2(0.0);\n    vec2 z13 = vec2(0.0);\n    vec2 z14 = vec2(0.0);\n    vec2 z15 = vec2(0.0);\n    vec2 z16 = vec2(0.0);\n    vec2 z17 = vec2(0.0);\n    vec2 z18 = vec2(0.0);\n    vec2 z19 = vec2(0.0);\n    vec2 z20 = vec2(0.0);\n    vec2 z21 = vec2(0.0);\n    vec2 z22 = vec2(0.0);\n    vec2 z23 = vec2(0.0);\n    vec2 z24 = vec2(0.0);\n    vec2 z25 = vec2(0.0);\n    vec2 z26 = vec2(0.0);\n    vec2 z27 = vec2(0.0);\n    vec2 z28 = vec2(0.0);\n    vec2 z29 = vec2(0.0);\n    vec2 z30 = vec2(0.0);\n    vec2 z31 = vec2(0.0);\n    vec2 z32 = vec2(0.0);\n    vec2 z33 = vec2(0.0);\n    vec2 z34 = vec2(0.0);\n    vec2 z35 = vec2(0.0);\n    vec2 z36 = vec2(0.0);\n    vec2 z37 = vec2(0.0);\n    vec2 z", "\n\tvec4 color = vec4(0.0);\n\tvec2 coord2 = coord * morphConstant;\n\tvec2 coord3 = coord2 * morphConstant;\n\tvec2 coord4 = coord3 * morphConstant;\n\tvec2 coord5 = coord4 * morphConstant;\n\tvec2 coord6 = coord5 * morphConstant;\n\tvec2 coord7 = coord6 * morphConstant;\n\tvec2 coord8 = coord7 * morphConstant;\n\tvec2 coord9 = coord8 * morphConstant;\n\tvec2 coord10 = coord9 * morphConstant;\n\tvec2 coord11 = coord10 * morphConstant;\n\tvec2 coord12 = coord11 * morphConstant;\n\tvec2 coord13 = coord12 * morphConstant;\n\tvec2 coord14 = coord13 * morphConstant;\n\tvec2 coord15 = coord14 * morphConstant;\n\tvec2 coord16 = coord15 * morphConstant;\n\tvec2 coord17 = coord16 * morphConstant;\n\tvec2 coord18 = coord17 * morphConstant;\n\tvec2 coord19 = coord18 * morphConstant;\n\tvec2 coord20 = coord19 * morphConstant;\n\tvec2 coord21 = coord20 * morphConstant;\n\tvec2 coord22 = coord21 * morphConstant;\n\tvec2 coord23 = coord22 * morphConstant;\n\tvec2 coord24 = coord23 * morphConstant;\n\tvec2 coord25 = coord24 * morphConstant;\n\tvec2 coord26 = coord25 * morphConstant;\n\tvec2 coord27 = coord26 * morphConstant;\n\tvec2 coord28 = coord27 * morphConstant;\n\tvec2 coord29 = coord28 * morphConstant;\n\tvec2 coord30 = coord29 * morphConstant;\n\tvec2 coord31 = coord30 * morphConstant;\n\tvec2 coord32 = coord31 * morphConstant;\n\tvec2 coord33 = coord32 * morphConstant;\n\tvec2 coord34 = coord33 * morphConstant;\n\tvec2 coord35 = coord34 * morphConstant;\n\tvec2 coord36", "\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcolor += texture(tex, uv + vec2(i, j) * constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Biomorphing\n//This is the main function\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec2 constant = 1.0 / iResolution.xy;\n\tvec4 color = texture(tex, uv);\n\tcolor = antiAliasedBiomorph(uv, constant);\n\tfragColor = color;\n}", "\n    return fract(x);\n}\n\n// A sawtooth wave\nfloat saw(float x) {\n    return fract(x + 0.5) - 0.5;\n}\n\n// A square wave\nfloat square(float x) {\n    return step(0.5, fract(x));\n}\n\n// A triangle wave\nfloat triangle(float x) {\n    return abs(fract(x) - 0.5) - 0.5;\n}\n\n// A sawtooth wave with a smooth transition between the two edges\nfloat smoothSaw(float x) {\n    return mix(fract(x), fract(x + 0.5), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// A square wave with a smooth transition between the two edges\nfloat smoothSquare(float x) {\n    return mix(step(0.5, fract(x)), step(0.5, fract(x + 0.5)), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// A triangle wave with a smooth transition between the two edges\nfloat smoothTriangle(float x) {\n    return mix(abs(fract(x) - 0.5) - 0.5, abs(fract(x + 0.5) - 0.5) - 0.5, smoothstep(0.0, 1.0, fract(x)));\n}\n\n// A sawtooth wave with a smooth transition between the two edges\nfloat smoothSaw(float x) {\n    return mix(fract(x), fract(x + 0.5), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// A square wave with a smooth transition between the two edges\nfloat smoothSquare(float x) {\n    return mix(step(0.5, fract(x)), step(0.5, fract(x + 0.5)), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// A triangle wave with a smooth transition between the two edges\nfloat smoothTriangle(float x) {\n    return mix(abs(fract(x) - 0.5) - 0.5, abs", "\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tdir = dir / len;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = uv - pA;\n\tfloat d = dot(p, dir);\n\tfloat dPerp = dot(p, perp);\n\tfloat dA = abs(dPerp) - thick.y * 0.5;\n\tfloat dB = abs(dPerp) + thick.y * 0.5;\n\tfloat dC = abs(d) - len * 0.5;\n\tfloat dD = abs(d) + len * 0.5;\n\tfloat dE = abs(dPerp) - thick.y * 0.5 - thick.x;\n\tfloat dF = abs(dPerp) + thick.y * 0.5 + thick.x;\n\tfloat dG = abs(d) - len * 0.5 - thick.x;\n\tfloat dH = abs(d) + len * 0.5 + thick.x;\n\tfloat dI = abs(dPerp) - thick.y * 0.5 + thick.x;\n\tfloat dJ = abs(dPerp) + thick.y * 0.5 - thick.x;\n\tfloat dK = abs(d) - len * 0.5 + thick.x;\n\tfloat dL = abs(d) + len * 0.5 - thick.x;\n\tfloat dM = abs(dPerp) - thick.y * 0.5;\n\tfloat dN = abs(dPerp) + thick.y * 0.5;\n\tfloat dO = abs(d) - len * 0.5;\n\tfloat dP = abs(d) + len * 0.5;\n\tfloat dQ = abs(dPerp) - thick.y * 0.5 - thick.x;\n\tfloat dR = abs(dPerp) + thick.y * 0.5 + thick.x;\n\tfloat dS =", "\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tif (len < 0.0001) return 0.0;\n\tdir /= len;\n\tvec2 pos = uv - pA;\n\tfloat dist = dot(pos, dir);\n\tif (dist < 0.0) return 0.0;\n\tif (dist > len) return 0.0;\n\tfloat d = abs(dist - len * 0.5);\n\tfloat r = thick.x * 0.5;\n\tif (rounded > 0.0) {\n\t\tfloat r2 = r * r;\n\t\tfloat d2 = d * d;\n\t\tif (d2 > r2) return 0.0;\n\t\tfloat a = asin(d / r);\n\t\ta *= 1.0 / (3.14159265359 * 0.5);\n\t\ta = clamp(a + 0.5, 0.0, 1.0);\n\t\treturn a;\n\t}\n\treturn smoothstep(r - thick.y * 0.5, r + thick.y * 0.5, d);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn FillLinePix(uv, pA, pB, vec2(thick, 0.0), rounded);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick) {\n\treturn FillLinePix(uv, pA, pB, vec2(thick, 0.0), 0.0);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB) {\n\treturn FillLinePix(uv", "\n\tfloat d = DrawLinePix(uv, pA, pB, thick, rounded);\n\treturn 1.0 - smoothstep(outlineThick, outlineThick + 1.0, d);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat DrawLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tdir /= len;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = pA + dir * (dot(uv - pA, dir) - thick.x);\n\tvec2 q = p + perp * thick.y;\n\tfloat d = max(abs(dot(uv - p, perp)), abs(dot(uv - q, perp)));\n\tif (rounded > 0.0) {\n\t\td = max(d, length(max(abs(uv - pA) - thick.x, 0.0)) - rounded);\n\t\td = max(d, length(max(abs(uv - pB) - thick.x, 0.0)) - rounded);\n\t}\n\treturn d;\n}\n\n// This makes a filled rectangle in pixel units. A 1.0 thick rectangle will be 1 pixel thick.\nfloat DrawRectPix(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tdir /= len;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = pA + dir * (dot(uv - pA, dir) - thick.x);\n\tvec2 q = p + perp * thick.y;\n\tfloat d = max(abs(dot(uv - p, perp)), abs(dot(uv - q, perp)));\n\td = max(d, length(max(abs(uv - pA) - thick.x, 0.0", "\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tdir /= len;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = uv - pA;\n\tfloat d = abs(dot(p, dir));\n\tfloat r = thick.x * 0.5;\n\tfloat c = thick.y * 0.5;\n\tfloat w = r + c;\n\tfloat h = r + c;\n\tfloat t = 0.0;\n\tif (d < w) {\n\t\tfloat a = d - r;\n\t\tfloat b = d + r;\n\t\tfloat s = 0.0;\n\t\tif (a < 0.0) {\n\t\t\ts = -a;\n\t\t} else if (b > len) {\n\t\t\ts = b - len;\n\t\t}\n\t\tfloat e = clamp(s / w, 0.0, 1.0);\n\t\tt = 1.0 - e;\n\t}\n\tif (rounded > 0.0) {\n\t\tfloat r2 = r * r;\n\t\tfloat c2 = c * c;\n\t\tfloat d2 = d * d;\n\t\tfloat w2 = w * w;\n\t\tfloat h2 = h * h;\n\t\tfloat a = d2 - r2;\n\t\tfloat b = d2 + r2;\n\t\tfloat s = 0.0;\n\t\tif (a < 0.0) {\n\t\t\ts = -a;\n\t\t} else if (b > len) {\n\t\t\ts = b - len;\n\t\t}\n\t\tfloat e = clamp(s / w2, 0.0, 1.0);\n\t\tt = max(t, 1.0 - e);\n\t}\n\treturn t;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n\treturn FillLine(uv, pA, pB, thick, 0.0);\n}\n\n// This makes a line in UV units", "\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tif (len < 0.0001) {\n\t\treturn 0.0;\n\t}\n\tdir /= len;\n\tvec2 p = uv - pA;\n\tfloat t = dot(p, dir);\n\tif (t < 0.0) {\n\t\treturn 0.0;\n\t}\n\tif (t > len) {\n\t\treturn 0.0;\n\t}\n\tvec2 p2 = pA + dir * t;\n\tfloat d = length(p - p2);\n\tif (d > thick.x) {\n\t\treturn 0.0;\n\t}\n\tif (d < thick.y) {\n\t\treturn 1.0;\n\t}\n\treturn 0.0;\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n\treturn FillLineDash(uv, pA, pB, thick, 0.0);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn FillLineDash(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, float thick) {\n\treturn FillLineDash(uv, pA, pB, vec2(thick, thick), 0.0);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB", "\n\tfloat d = distance(uv, pA);\n\tfloat d2 = distance(uv, pB);\n\tfloat d3 = distance(uv, (pA + pB) / 2.0);\n\tfloat d4 = distance(uv, (pA + pB) / 2.0 - (pB - pA) * 0.5);\n\tfloat d5 = distance(uv, (pA + pB) / 2.0 + (pB - pA) * 0.5);\n\tfloat d6 = distance(uv, (pA + pB) / 2.0 - (pB - pA) * 0.5 * vec2(1.0, -1.0));\n\tfloat d7 = distance(uv, (pA + pB) / 2.0 + (pB - pA) * 0.5 * vec2(1.0, -1.0));\n\tfloat d8 = distance(uv, (pA + pB) / 2.0 - (pB - pA) * 0.5 * vec2(-1.0, 1.0));\n\tfloat d9 = distance(uv, (pA + pB) / 2.0 + (pB - pA) * 0.5 * vec2(-1.0, 1.0));\n\tfloat d10 = distance(uv, (pA + pB) / 2.0 - (pB - pA) * 0.5 * vec2(1.0, 1.0));\n\tfloat d11 = distance(uv, (pA + pB) / 2.0 + (pB - pA) * 0.5 * vec2(1.0, 1.0));\n\tfloat d12 = distance(uv, (pA + pB) / 2.0 - (pB - pA) * 0.5 * vec2(-1.0, -1.0));\n\tfloat d13 = distance(uv, (pA + pB) / 2.0 + (pB - pA) * 0.5 * vec2(-1.0, -1.0));\n\tfloat d", "\n\tfloat d = distance(uv, p);\n\tif (d < 0.001) {\n\t\tcol = vec3(1.0, 0.0, 0.0);\n\t}\n}\n\n// This is the main function that is called for each pixel.\nvoid main() {\n\t// Get the UV coordinates of the current pixel.\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\t// Get the color of the pixel.\n\tvec3 col = vec3(0.0);\n\n\t// Get the mouse position.\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the time.\n\tfloat time = iTime;\n\n\t// Get the number of points.\n\tint numPoints = iNumPoints;\n\n\t// Get the points.\n\tvec2 points[numPoints];\n\tfor (int i = 0; i < numPoints; i++) {\n\t\tpoints[i] = iPoints[i];\n\t}\n\n\t// Get the radius.\n\tfloat radius = iRadius;\n\n\t// Get the strength.\n\tfloat strength = iStrength;\n\n\t// Get the falloff.\n\tfloat falloff = iFalloff;\n\n\t// Get the smoothness.\n\tfloat smoothness = iSmoothness;\n\n\t// Get the color.\n\tvec3 color = iColor;\n\n\t// Get the alpha.\n\tfloat alpha = iAlpha;\n\n\t// Get the blend mode.\n\tint blendMode = iBlendMode;\n\n\t// Get the blend amount.\n\tfloat blendAmount = iBlendAmount;\n\n\t// Get the blend color.\n\tvec3 blendColor = iBlendColor;\n\n\t// Get the blend alpha.\n\tfloat blendAlpha = iBlendAlpha;\n\n\t// Get the blend mode.\n\tint blendMode2 = iBlendMode2;\n\n\t// Get the blend amount.\n\tfloat blendAmount2 = iBlendAmount2;\n\n\t// Get the blend color.\n\tvec3 blendColor2 = iBlendColor2;\n\n\t// Get the blend alpha.\n\tfloat blendAlpha2 = iBlendAlpha2;\n\n\t// Get the blend mode.\n\tint blendMode3 = iBlendMode3;\n\n\t// Get the blend amount.\n", "\n    vec3 oc = ro - cen;\n    float b = dot( oc, nor );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad )\n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 mi, in vec3 ma )\n{\n    vec3 invR = 1.0 / rd;\n    vec3 n = invR * rd;\n    vec3 k = (mi - ro) * invR;\n    vec3 p = (ma - ro) * invR;\n    vec3 t1 = max(k, p);\n    vec3 t2 = min(k, p);\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.0 ) return -1.0;\n    return tN;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 v0 = c - a;\n    vec3 v1 = b - a;\n    vec3 v2 = ro - a;\n    vec3 pvec = cross( rd, v1 );\n    float det = dot( v0, pvec );\n    if( det < 0.0001 ) return -1.0;\n    float invDet = 1.0 / det;\n    vec3 tvec = ro - a;\n    float u = dot( tvec, p", "\n\tvec3  invR = 1.0 / rd;\n\tvec3  n = cen - ro;\n\tvec3  k1 = vec3( invR.x > 0.0? (n.x*invR.x) : (n.x*invR.x-1.0),\n\t\t\t\t\tinvR.y > 0.0? (n.y*invR.y) : (n.y*invR.y-1.0),\n\t\t\t\t\tinvR.z > 0.0? (n.z*invR.z) : (n.z*invR.z-1.0) );\n\tvec3  k2 = vec3( invR.x > 0.0? (k1.x+rad.x*invR.x) : (k1.x-rad.x*invR.x),\n\t\t\t\t\tinvR.y > 0.0? (k1.y+rad.y*invR.y) : (k1.y-rad.y*invR.y),\n\t\t\t\t\tinvR.z > 0.0? (k1.z+rad.z*invR.z) : (k1.z-rad.z*invR.z) );\n\tfloat t1 = max( k1.x, max(k1.y,k1.z) );\n\tfloat t2 = min( k2.x, min(k2.y,k2.z) );\n\treturn vec2(t1,t2);\n}\n\n// ray-sphere intersection (simplified)\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad ) \n{\n\tvec3  oc = ro - cen;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\treturn vec2(-b - sqrt(h), -b + sqrt(h) );\n}\n\n// ray-plane intersection (simplified)\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3", "\n    vec3  c = (pa+pb)*0.5;\n    vec3  h = pb-pa;\n    float r = length(h)*0.5;\n    float d = length(h.xz);\n    float s = ra*0.5;\n    float m = max(r,s);\n    return bound3( c-vec3(m,m,d+s), c+vec3(m,m,d+s) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  c = (pa+pb)*0.5;\n    vec3  h = pb-pa;\n    float r = length(h)*0.5;\n    float d = length(h.xz);\n    float s = ra*0.5;\n    float m = max(r,s);\n    return bound3( c-vec3(m,m,d+s), c+vec3(m,m,d+s) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a torus (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 TorusAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  c = (pa+pb)*0.5;\n    vec3  h = pb-pa;\n    float r = length(h)*0.5;\n    float d = length(h.xz);\n    float s = ra*0.5;\n    float m = max(r,s);\n    return bound3( c-vec3(m,m,d+s), c+vec3(m,m,d+s) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a capsule (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  c = (pa+pb)*0.5;\n    vec", "\n    vec3 a = pa - ro;\n    vec3 b = pb - ro;\n    vec3 m = normalize( b - a );\n    vec3 n = cross( rd, m );\n    float t = dot( a, m );\n    float h = dot( a, n );\n    float k = dot( m, n );\n    float l = ra * ra * k * k;\n    float p = h * h - l * ( dot( a, a ) - dot( b, b ) + l );\n    if( p < 0.0 ) return vec4( 1e20 );\n    p = sqrt( p );\n    float t0 = t - p * k;\n    float t1 = t + p * k;\n    float d0 = t0 < 0.0? 1e20 : abs( t0 );\n    float d1 = t1 < 0.0? 1e20 : abs( t1 );\n    float d = min( d0, d1 );\n    vec3 pos = ro + rd * d;\n    vec3 nor = normalize( pos - pa );\n    return vec4( pos, d );\n}\n\n// ray-sphere intersetion (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, in float ra ) // center, radius\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra * ra;\n    float h = b * b - c;\n    if( h < 0.0 ) return vec4( 1e20 );\n    h = sqrt( h );\n    return vec4( ro + rd * ( -b - h ), -b - h );\n}\n\n// ray-plane intersetion (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec3 np, in float no ) // normal, offset\n{\n    float t = -( dot( ro, np ) + no ) / dot( rd, np );\n    return vec4( ro + rd * t, t );\n}\n\n// ray-triangle intersetion (returns t and normal)\nvec4 iTriangle( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b", "\n\tvec3  h = abs(rd) - rad;\n\tvec3  n = max(h,0.0);\n\tfloat t1 = length(n+rd*h)/length(rd);\n\tfloat t2 = dot(n,ro-cen)/dot(rd,h);\n\treturn vec2(t1,t2);\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad ) \n{\n\tvec3  oc = ro - cen;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\treturn vec2( -b - sqrt(h), -b + sqrt(h) );\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 nor ) \n{\n\tfloat d = dot(nor,ro);\n\treturn vec2(-d/dot(nor,rd),-1.0);\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3  e1 = v1 - v0;\n\tvec3  e2 = v2 - v0;\n\tvec3  p = cross(rd,e2);\n\tfloat det = dot(e1,p);\n\tif( det>EPSILON )\n\t{\n\t\tvec3  t = ro - v0;\n\t\tfloat u = dot(t,p);\n\t\tif( u<0.0 || u>det ) return vec2(-1.0);\n\t\tvec3  q = cross(t,e1);\n\t\tfloat v = dot(rd,q);\n\t\tif( v<0.0 || u+v>det ) return vec2(-1.0);\n\t\tfloat invDet = 1.0/det;\n\t\tfloat t1 = dot(e2,q)*invDet;\n\t\treturn vec2(t1,-", "\n\tvec3 a = pa - ro;\n\tvec3 b = pb - ro;\n\tfloat h = dot(a,rd);\n\tfloat m2 = dot(a,a) - h*h;\n\tfloat n2 = dot(b,b) - h*h;\n\tfloat d1 = -h - sqrt(m2-r*r);\n\tfloat d2 = -h + sqrt(n2-r*r);\n\treturn min(d1,d2);\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec3 sp, in float r )\n{\n\tvec3 a = ro - sp;\n\tfloat b = dot(a,rd);\n\tfloat c = dot(a,a) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt(h);\n}\n\n// intersect plane : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat planeIntersect( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n\tfloat d = dot(n,p) - dot(n,ro);\n\treturn -d/dot(n,rd);\n}\n\n// intersect box : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 bmin, in vec3 bmax )\n{\n\tvec3 invR = 1.0/rd;\n\tvec3 n = invR*ro - (sign(invR)*0.5);\n\tvec3 k = abs(invR)*bmax - n;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x,t1.y),t1.z);\n\tfloat tF = min(min(t2.x,t2.y),t", "\n\tvec3 pa = pos - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn normalize( pa - h*ba );\n}\n\n// compute color\nvec3 capColor( in vec3 p, in vec3 a, in vec3 b, in float r, in vec3 ca, in vec3 cb )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn mix( ca, cb, h );\n}\n\n// compute color\nvec3 capColor( in vec3 p, in vec3 a, in vec3 b, in float r, in vec3 c )\n{\n\treturn capColor( p, a, b, r, c, c );\n}\n\n// compute color\nvec3 capColor( in vec3 p, in vec3 a, in vec3 b, in float r, in float c )\n{\n\treturn capColor( p, a, b, r, vec3(c), vec3(c) );\n}\n\n// compute color\nvec3 capColor( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n\treturn capColor( p, a, b, r, vec3(1.0), vec3(1.0) );\n}\n\n// compute color\nvec3 capColor( in vec3 p, in vec3 a, in vec3 b, in float r, in vec3 ca, in vec3 cb, in float h )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat hh = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn mix( ca, cb, mix( h, 1.0-h, hh ) );\n}\n\n// compute color\nvec3 capColor( in vec3 p, in vec3 a, in vec3 b, in float r, in vec3 c, in float h )\n{\n\treturn capColor( p, a, b, r,", "\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs(m) * rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\treturn vec2(tN, tF);\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt(h);\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pln )\n{\n\treturn (dot(ro,pln.xyz) + pln.w) / dot(rd,pln.xyz);\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 tri[3] )\n{\n\tvec3 e1 = tri[1] - tri[0];\n\tvec3 e2 = tri[2] - tri[0];\n\tvec3 p = cross(rd,e2);\n\tfloat det = 1.0 / dot(e1,p);\n\tvec3 t = ro - tri[0];\n\tfloat u = det * dot(t,p);\n\tif( u<0.0 || u>1.0 ) return -1.0;\n\tvec3 q = cross(t,e1);\n\tfloat v = det * dot(rd,q);\n\tif( v<0.0 || u+v > 1.0 ) return -1.0;\n\tfloat t_ = det * dot(e2,q);\n\tif( t_<", "\n\tfloat t = 0.0;\n\tfloat d = 1.0;\n\tfor( int i=0; i<MAX_STEPS; i++ )\n\t{\n\t\tvec3 p = ro + rd*t;\n\t\tfloat d = map( p );\n\t\tt += d;\n\t\tif( abs(d)<EPSILON || t>MAX_DIST ) break;\n\t}\n\treturn vec4( ro+rd*t, d );\n}\n\n// normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// lighting\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tfloat dd = map( aopos );\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t", "\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float theta = i * 2.0 * PI / n;\n    float x = cos(theta) / sqrt(phi);\n    float y = sin(theta) / sqrt(phi);\n    float z = 0.5 * sqrt(2.0 / phi);\n    return vec3(x, y, z);\n}\n\n// inverse spherical fibonazzi mapping\nvec2 inverseSF( vec3 v ) \n{\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float theta = atan(v.y, v.x);\n    float i = theta / (2.0 * PI);\n    float n = sqrt(phi * v.z * v.z + 0.25);\n    return vec2(i, n);\n}\n\n// spherical harmonics\n// http://www.thetenthplanet.de/archives/1180\nvec3 sh( vec3 v, float l, float m, float n ) \n{\n    float c = sqrt((2.0 * l + 1.0) * factorial(l - abs(m)) / (4.0 * PI * factorial(l + abs(m))));\n    float p = 1.0;\n    float t = 1.0;\n    float s = 1.0;\n    if (m < 0.0) \n    {\n        p = -1.0;\n    }\n    else if (m > 0.0) \n    {\n        t = -1.0;\n    }\n    if (m!= 0.0 && n == 0.0) \n    {\n        s = 0.0;\n    }\n    float x = p * sqrt(1.0 - v.z * v.z) * cos(v.y * m);\n    float y = t * sqrt(1.0 - v.z * v.z) * sin(v.y * m);\n    float z = s * v.z;\n    return vec3(c * (x * cos(v.x * n) - y * sin(v.x * n)), c * (z * cos(v.x * n) + x * sin(v.x * n)), c", "\n\tfloat t = 0.0;\n\tfloat d = 1.0;\n\tfloat h = 1.0;\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat s = 0.0;\n\tfloat res = -1.0;\n\tfloat res2 = -1.0;\n\tfloat res3 = -1.0;\n\tfloat res4 = -1.0;\n\tfloat res5 = -1.0;\n\tfloat res6 = -1.0;\n\tfloat res7 = -1.0;\n\tfloat res8 = -1.0;\n\tfloat res9 = -1.0;\n\tfloat res10 = -1.0;\n\tfloat res11 = -1.0;\n\tfloat res12 = -1.0;\n\tfloat res13 = -1.0;\n\tfloat res14 = -1.0;\n\tfloat res15 = -1.0;\n\tfloat res16 = -1.0;\n\tfloat res17 = -1.0;\n\tfloat res18 = -1.0;\n\tfloat res19 = -1.0;\n\tfloat res20 = -1.0;\n\tfloat res21 = -1.0;\n\tfloat res22 = -1.0;\n\tfloat res23 = -1.0;\n\tfloat res24 = -1.0;\n\tfloat res25 = -1.0;\n\tfloat res26 = -1.0;\n\tfloat res27 = -1.0;\n\tfloat res28 = -1.0;\n\tfloat res29 = -1.0;\n\tfloat res30 = -1.0;\n\tfloat res31 = -1.0;\n\tfloat res32 = -1.0;\n\tfloat res33 = -1.0;\n\tfloat res34 = -1.0;\n\tfloat res35 = -1.0;\n\tfloat res36 = -1.0;\n\tfloat res37 = -1.0;\n\tfloat res38 = -1.0;\n\tfloat res39", "\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\t// Four corners in 2D of a tile\n\tfloat a = hash( i + vec2(0.0,0.0) );\n\tfloat b = hash( i + vec2(1.0,0.0) );\n\tfloat c = hash( i + vec2(0.0,1.0) );\n\tfloat d = hash( i + vec2(1.0,1.0) );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\t\n\treturn mix( a, b, u.x ) +\n\t\t(c - a)* u.y * (1.0 - u.x) +\n\t\t(d - b) * u.x * u.y;\n}\n\n// 3D simplex noise\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n// 3D simplex noise, periodic variant\nfloat pnoise( in vec3 x, in vec3 rep )\n{\n\tvec3 p = floor(mod(x,rep));\n\tvec3 f = fract(mod(x,rep));\n\t\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 1", "\n\tvec2 d = abs(p) - size;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 size)\n{\n\treturn boxDist(p, size, 0.0);\n}\n\nfloat boxDist(vec3 p, vec3 size, float radius)\n{\n\tvec3 d = abs(p) - size;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0) - radius;\n}\n\nfloat boxDist(vec3 p, vec3 size)\n{\n\treturn boxDist(p, size, 0.0);\n}\n\nfloat boxDist(vec4 p, vec4 size, float radius)\n{\n\tvec4 d = abs(p) - size;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, max(d.z, d.w))), 0.0) - radius;\n}\n\nfloat boxDist(vec4 p, vec4 size)\n{\n\treturn boxDist(p, size, 0.0);\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n\treturn mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge(float d1, float d2)\n{\n\treturn smoothMerge(d1, d2, 0.1);\n}\n\nfloat smoothMerge(vec2 d1, vec2 d2, float k)\n{\n\treturn vec2(smoothMerge(d1.x, d2.x, k), smoothMerge(d1.y, d2.y, k));\n}\n\nfloat smoothMerge(vec2 d1, vec2 d2)\n{\n\treturn smoothMerge(d1, d2, ", "\n    uv *= 10.0;\n    float s = sin(dot(uv, orient));\n    float c = cos(dot(uv, orient));\n    vec2 tex = uv * mat2(c, -s, s, c);\n    return vec3(1.0) * texture(iChannel0, tex / 10.0).r;\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    uv *= 10.0;\n    float s = sin(dot(uv, orient));\n    float c = cos(dot(uv, orient));\n    vec2 tex = uv * mat2(c, -s, s, c);\n    return vec3(1.0) * texture(iChannel0, tex / 10.0).g;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    uv *= 10.0;\n    float s = sin(dot(uv, orient));\n    float c = cos(dot(uv, orient));\n    vec2 tex = uv * mat2(c, -s, s, c);\n    return vec3(1.0) * texture(iChannel0, tex / 10.0).b;\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    uv *= 10.0;\n    float s = sin(dot(uv, orient));\n    float c = cos(dot(uv, orient));\n    vec2 tex = uv * mat2(c, -s, s, c);\n    return vec3(1.0) * texture(iChannel0, tex / 10.0).a;\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    uv *= 10.0;\n    float s = sin(dot(uv, orient));\n    float c = cos(dot(uv, orient));\n    vec2 tex = uv * mat2(c, -s, s, c);\n    return vec3(1.0) * texture(iChannel0, tex / 10.0).r;\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    uv", "\n    float s = sin(iTime), c = cos(iTime);\n    mat2 m = mat2(c, -s, s, c);\n    uv = m * uv;\n    vec2 q = vec2(0.3, 0.5);\n    vec2 p = vec2(0.5 + 0.2 * sin(iTime), 0.6);\n    vec2 f = (uv - q) / p;\n    f = 0.5 + 0.5 * sin(vec2(sin(f.x + 0.1) * 10.0, cos(f.y + 0.1) * 10.0) * 2.0);\n    return vec3(f.x * f.y);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    float s = sin(iTime), c = cos(iTime);\n    mat2 m = mat2(c, -s, s, c);\n    uv = m * uv;\n    vec2 q = vec2(0.3, 0.5);\n    vec2 p = vec2(0.5 + 0.2 * sin(iTime), 0.6);\n    vec2 f = (uv - q) / p;\n    f = 0.5 + 0.5 * cos(vec2(cos(f.x + 0.1) * 10.0, sin(f.y + 0.1) * 10.0) * 2.0);\n    return vec3(f.x * f.y);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    float s = sin(iTime), c = cos(iTime);\n    mat2 m = mat2(c, -s, s, c);\n    uv = m * uv;\n    vec2 q = vec2(0.3, 0.5);\n    vec2 p = vec2(0.5 + 0.2 * sin(iTime), 0.6);\n    vec2 f = (uv - q) / p;\n    f = 0.5 + 0.5 * sin(vec2(sin(f.x + 0.", "\n\tvec2 grid = floor( p * gridRatio );\n\tvec2 f = fract( p * gridRatio );\n\tvec2 mf = 1.0 - f;\n\tvec2 px = vec2( mf.x * mf.y, f.x * mf.y );\n\tvec2 py = vec2( mf.x * f.y, f.x * f.y );\n\tfloat gx = texture2D( gridTexture, grid + vec2( 0.0, 0.0 ) ).x;\n\tfloat gy = texture2D( gridTexture, grid + vec2( 1.0, 0.0 ) ).x;\n\tfloat dx = texture2D( gridTexture, grid + vec2( 0.0, 1.0 ) ).x;\n\tfloat dy = texture2D( gridTexture, grid + vec2( 1.0, 1.0 ) ).x;\n\tfloat dgx = gx - dx;\n\tfloat dgy = gy - dy;\n\treturn dot( vec2( dot( px, vec2( dgx, dgy ) ), dot( py, vec2( dgx, dgy ) ) ), ddx * ddy );\n}\n\n// grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float gridRatio )\n{\n\tvec2 grid = floor( p * gridRatio );\n\tvec2 f = fract( p * gridRatio );\n\tvec2 mf = 1.0 - f;\n\tvec2 px = vec2( mf.x * mf.y, f.x * mf.y );\n\tvec2 py = vec2( mf.x * f.y, f.x * f.y );\n\tfloat gx = texture2D( gridTexture, grid + vec2( 0.0, 0.0 ) ).x;\n\tfloat gy = texture2D( gridTexture, grid + vec2( 1.0, 0.0 ) ).x;\n\tfloat dx = texture2D( gridTexture, grid + vec2( 0.0, 1.0 ) ).x;\n\tfloat dy = texture2D( gridTexture, grid + vec2( 1.0", "\n    vec3 q = p;\n    float s = 1.0;\n    for( int i=0; i<ITER_GEOMETRY; i++ )\n    {\n        q = abs(q)/dot(q,q) - F_KLEIN*s;\n        s *= F_KLEIN;\n    }\n    return q;\n}\n\n// normal of map\nvec3 norm( in vec3 p )\n{\n    const float eps = 0.001;\n    return normalize( dmap(p+vec3(eps,0.0,0.0)) - dmap(p+vec3(-eps,0.0,0.0)) );\n}\n\n// distance to surface\nfloat sdScene( in vec3 p )\n{\n    float d = 1e10;\n    for( int i=0; i<ITER_GEOMETRY; i++ )\n    {\n        vec3 q = abs(p)/dot(p,p) - F_KLEIN;\n        d = min( d, length(q)*F_KLEIN );\n        p = q;\n    }\n    return d;\n}\n\n// coloring\nvec3 color( in vec3 p )\n{\n    vec3 n = norm(p);\n    vec3 l = normalize( vec3(0.5,0.7,0.5) );\n    float dif = clamp( dot(n,l), 0.0, 1.0 );\n    float bac = clamp( dot(n,normalize(vec3(-l.x,0.0,-l.z))), 0.0, 1.0 )*0.5+0.5;\n    return vec3(dif)+vec3(bac)*0.7;\n}\n\n// lighting\nvec3 shade( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float d = sdScene(p);\n        col += color(p)*d;\n        t += d*0.7;\n        if( abs(d)<0.001 || t>20.0 ) break;\n    }\n    return col;\n}", "\n\tv33 c=a;\n\ta.x=b.x;\n\ta.y=b.y;\n\ta.z=b.z;\n\tb.x=c.x;\n\tb.y=c.y;\n\tb.z=c.z;\n}\n\n//this is the main function that does the actual ray-triangle intersection test\n//it returns the distance to the intersection point, or -1 if there is no intersection\nfloat rayTriangle(v33 rayOrigin,v33 rayDirection,v33 triangle1,v33 triangle2,v33 triangle3,out v33 intersectionPoint){\n\t//first, we need to find the plane that the triangle lies in\n\tv33 planeNormal=cross(triangle2-triangle1,triangle3-triangle1);\n\tfloat planeD=dot(planeNormal,triangle1);\n\t//now we need to find the distance from the ray origin to the plane\n\tfloat t=dot(planeNormal,rayOrigin)+planeD;\n\t//if the ray is parallel to the plane, there is no intersection\n\tif(abs(t)<0.000001)return -1.0;\n\t//now we need to find the intersection point\n\tv33 rayPoint=rayOrigin+rayDirection*t;\n\t//now we need to find the barycentric coordinates of the intersection point\n\tv33 v0=triangle1-rayPoint;\n\tv33 v1=triangle2-rayPoint;\n\tv33 v2=triangle3-rayPoint;\n\tfloat d00=dot(v0,v0);\n\tfloat d01=dot(v0,v1);\n\tfloat d11=dot(v1,v1);\n\tfloat d20=dot(v2,v0);\n\tfloat d21=dot(v2,v1);\n\tfloat denom=d00*d11-d01*d01;\n\tfloat v=d11*d20-d01*d21;\n\tfloat w=d00*d21-d01*d20;\n\tfloat u=v/denom;\n\tfloat z=w", "return vec3(a.a-b.x,a.b-b.y,a.c-b.z);}\nv33 sub(v33 a,v33 b){return vec3(a.a-b.a,a.b-b.b,a.c-b.c);}\nv33 sub(v33 a,float b){return vec3(a.a-b,a.b-b,a.c-b);}\nv33 sub(float a,v33 b){return vec3(a-b.a,a-b.b,a-b.c);}\n\n//multiply [a] with [b]\nv33 mul(v33 a,vec3 b){return vec3(a.a*b.x,a.b*b.y,a.c*b.z);}\nv33 mul(v33 a,v33 b){return vec3(a.a*b.a,a.b*b.b,a.c*b.c);}\nv33 mul(v33 a,float b){return vec3(a.a*b,a.b*b,a.c*b);}\nv33 mul(float a,v33 b){return vec3(a*b.a,a*b.b,a*b.c);}\n\n//divide [a] by [b]\nv33 div(v33 a,vec3 b){return vec3(a.a/b.x,a.b/b.y,a.c/b.z);}\nv33 div(v33 a,v33 b){return vec3(a.a/b.a,a.b/b.b,a.c/b.c);}\nv33 div(v33 a,float b){return vec3(a.a/b,a.b/b,a.c/b);}\nv33 div(float a,v33 b){return vec3(a/b.a,a/b.b,a/b.c);}\n\n//dot product of [a] and [b]\nfloat dot(v33 a,vec3 b){return a", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//scale a ray by a scalar\nv33 scale(v33 a,float b){\n\tv33 c;\n\tc.x=a.x*b;\n\tc.y=a.y*b;\n\tc.z=a.z*b;\n\treturn c;\n}\n\n//scale a ray by a scalar\nv33 scalec(v33 a,v33 b){\n\tv33 c;\n\tc.x=a.x*b.x;\n\tc.y=a.y*b.y;\n\tc.z=a.z*b.z;\n\treturn c;\n}\n\n//scale a ray by a scalar\nv33 scalev(v33 a,v3 b){\n\tv33 c;\n\tc.x=a.x*b.x;\n\tc.y=a.y*b.y;\n\tc.z=a.z*b.z;\n\treturn c;\n}\n\n//scale a ray by a scalar\nv33 scalev2(v33 a,float b){\n\tv33 c;\n\tc.x=a.x*b;\n\tc.y=a.y*b;\n\tc.z=a.z*b;\n\treturn c;\n}\n\n//scale a ray by a scalar\nv33 scalev3(v33 a,v3 b){\n\tv33 c;\n\tc.x=a.x*b.x;\n\tc.y=a.y*b.y;\n\tc.z=a.z*b.z;\n\treturn c;\n}\n\n//scale a ray by a scalar\nv33 scalev4(v33 a,v3 b){\n\tv33 c;\n\tc.x=a.x*b.x;\n\tc.y=a.y*b.y;\n\t", "return a.xy-b.xy;}\nvec2 dt(v33 a,v33 b,v33 c){return dt(a,b)+dt(b,c);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d){return dt(a,b)+dt(b,c)+dt(c,d);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){return dt(a,b)+dt(b,c)+dt(c,d)+dt(d,e);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){return dt(a,b)+dt(b,c)+dt(c,d)+dt(d,e)+dt(e,f);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){return dt(a,b)+dt(b,c)+dt(c,d)+dt(d,e)+dt(e,f)+dt(f,g);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){return dt(a,b)+dt(b,c)+dt(c,d)+dt(d,e)+dt(e,f)+dt(f,g)+dt(g,h);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h,v33 i){return dt(a,b)+dt(b,c)+dt(c,d)+dt(d,e)+dt(e,f)+dt(f,g)+dt(g,h)+dt(h,i);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v", "return vec2(dot(a.x,b),dot(a.y,b));}\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,v33 b){return vec2(dot(a,b.x),dot(a,b.y));}\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){return vec2(dot(a.x,b.x),dot(a.y,b.y));}\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){return vec2(dot(a.x,b.x)+dot(a.x,c.x),dot(a.y,b.y)+dot(a.y,c.y));}\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){return vec2(dot(a.x,b.x)+dot(a.x,c.x)+dot(a.x,d.x),dot(a.y,b.y)+dot(a.y,c.y)+dot(a.y,d.y));}\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){return vec2(dot(a.x,b.x)+dot(a.x,c.x)+dot(a.x,d.x)+dot(a.x,e.x),dot(a.y,b.y)+dot(a.y,c.y)+dot(a.y,d.y)+dot(a.y,e.y));}\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){return vec2(dot(a.x,b.x)+dot(a.x,c.x)+dot(a.x,d.x)+dot(a.x", "return v33(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 mul(v33 a,v33 b){return v33(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 mul(v33 a,float b){return v33(a.x*b,a.y*b,a.z*b);}\nv33 mul(float a,v33 b){return v33(a*b.x,a*b.y,a*b.z);}\n\n//dual div\nv33 div(v33 a,vec2 b){return v33(a.x/b.x,a.y/b.y,a.z/b.z);}\nv33 div(v33 a,v33 b){return v33(a.x/b.x,a.y/b.y,a.z/b.z);}\nv33 div(v33 a,float b){return v33(a.x/b,a.y/b,a.z/b);}\nv33 div(float a,v33 b){return v33(a/b.x,a/b.y,a/b.z);}\n\n//dual add\nv33 add(v33 a,vec2 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 add(v33 a,v33 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 add(v33 a,float b){return v33(a.x+b,a.y+b,a.z+b);}\nv33 add(float a,v33 b){return v33(a+b.x,a+b.y,a+b.z);}\n\n//dual sub\nv33 sub(v33 a,vec2 b){return v33(a.x", "\n\tvec3 q=floor(p);\n\tfloat f=fract(p.x+p.y+p.z);\n\treturn mix(mix(mix(1.0,0.0,f),mix(0.0,1.0,f),step(0.5,w.y)),mix(mix(0.0,1.0,f),mix(1.0,0.0,f),step(0.5,w.y)),step(0.5,w.x));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF3(vec3 p,vec3 w){\n\tvec3 q=floor(p);\n\tfloat f=fract(p.x+p.y+p.z);\n\treturn mix(mix(mix(1.0,0.0,f),mix(0.0,1.0,f),step(0.5,w.z)),mix(mix(0.0,1.0,f),mix(1.0,0.0,f),step(0.5,w.z)),step(0.5,w.x));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 q=floor(p);\n\tfloat f=fract(p.x+p.y+p.z);\n\treturn mix(mix(mix(1.0,0.0,f),mix(0.0,1.0,f),step(0.5,w.x)),mix(mix(0.0,1.0,f),mix(1.0,0.0,f),step(0.5,w.x)),step(0.5,w.y));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(", "\n\tvec3 q=floor(p/w);\n\tfloat a=mod(q.x+q.y+q.z,2.0);\n\treturn a;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 q=floor(p/w);\n\tfloat a=mod(q.x+q.y+q.z,2.0);\n\treturn a*a;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF5(vec3 p,vec3 w){\n\tvec3 q=floor(p/w);\n\tfloat a=mod(q.x+q.y+q.z,2.0);\n\treturn a*a*a;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF6(vec3 p,vec3 w){\n\tvec3 q=floor(p/w);\n\tfloat a=mod(q.x+q.y+q.z,2.0);\n\treturn a*a*a*a;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF7(vec3 p,vec3 w){\n\tvec3 q=floor(p/w);\n\tfloat a=mod(q.x+q.y+q.z,2.0);\n\treturn a*a*a*a*a;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF8(vec3 p,vec3 w){\n\tvec3 q=floor(p/w);\n\tfloat a=mod(q.x+q.y+", "\n\tfloat d=length(r.o-s.xyz);\n\tfloat t=d-s.w;\n\treturn t>0.?0.:d-sqrt(s.w*s.w-t*t);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sss(v33 r,vec4 s){\n\tfloat d=length(r.o-s.xyz);\n\tfloat t=d-s.w;\n\treturn t>0.?0.:d-sqrt(s.w*s.w-t*t);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sss(v33 r,vec4 s,float k){\n\tfloat d=length(r.o-s.xyz);\n\tfloat t=d-s.w;\n\treturn t>0.?0.:d-sqrt(s.w*s.w-t*t)*k;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sss(v33 r,vec4 s,float k,float l){\n\tfloat d=length(r.o-s.xyz);\n\tfloat t=d-s.w;\n\treturn t>0.?0.:d-sqrt(s.w*s.w-t*t)*k*l;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sss(v33 r,vec4 s,float k,float l,float m){\n\tfloat d=length(r.o-s.xyz);\n\tfloat t=d-s.w;\n\treturn t>0.?0.:d-sqrt(s.w*s.w-t*t)*k*l*m;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sss(v33 r,vec4 s,float k,float l,float m,float n){\n\tfloat d=length(r.o-s.xyz);\n\tfloat t=d-s.w;\n\treturn t>0.?0.:d-sqrt(s.w*s.w-t*t)*k*l*m*n;\n}\n\n//sphere softShadow of(", "\n\treturn 1.0-clamp(length(u-s.xyz)/s.w,0.0,1.0);\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 p){\n\treturn 1.0-clamp(dot(u,p.xyz)+p.w,0.0,1.0);\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 b){\n\tvec3 d = abs(u-b.xyz)-b.w;\n\treturn 1.0-clamp(min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)),0.0,1.0);\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 c){\n\tvec2 d = abs(vec2(length(u.xz-c.xy),u.y))-c.z;\n\treturn 1.0-clamp(min(max(d.x,d.y),0.0)+length(max(d,0.0)),0.0,1.0);\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 c){\n\tvec2 d = abs(vec2(length(u.xz-c.xy),u.y))-c.z;\n\treturn 1.0-clamp(min(max(d.x,d.y),0.0)+length(max(d,0.0)),0.0,1.0);\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 t){\n\tvec2 d = vec2(length(u.xz-t.xy)-t.z,u.y);\n\treturn 1.0-clamp(min(max(d.x,d.y),0.0)+length(max(d,0.0)),0.0,1.0);\n}\n\n//capsule occlusion\nfloat occCapsule(vec3 u,vec3 n,vec4 c){\n\tvec3 d = abs(", "\n    vec2 min = min(p0, min(p1, p2));\n    vec2 max = max(p0, max(p1, p2));\n    return vec4(min, max);\n}\n\n// Exact BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 min = min(p0, min(p1, min(p2, p3)));\n    vec2 max = max(p0, max(p1, max(p2, p3)));\n    return vec4(min, max);\n}\n\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 min = min(p0, min(p1, p2));\n    vec3 max = max(p0, max(p1, p2));\n    return vec4(min, max);\n}\n\n// Exact BBox to a cubic bezier\nvec4 bboxBezier(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3 )\n{\n    vec3 min = min(p0, min(p1, min(p2, p3)));\n    vec3 max = max(p0, max(p1, max(p2, p3)));\n    return vec4(min, max);\n}\n\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec4 p0, in vec4 p1, in vec4 p2 )\n{\n    vec4 min = min(p0, min(p1, p2));\n    vec4 max = max(p0, max(p1, p2));\n    return vec4(min, max);\n}\n\n// Exact BBox to a cubic bezier\nvec4 bboxBezier(in vec4 p0, in vec4 p1, in vec4 p2, in vec4 p3 )\n{\n    vec4 min = min(p0, min(p1, min(p2, p3)));\n    vec4 max = max(p0, max(p1, max(p2, p3)));\n    return vec4(min", "\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\tvec2 p012_p0 = p012 - p0;\n\tvec2 p012_p2 = p012 - p2;\n\tvec2 p012_p01 = p012 - p01;\n\tvec2 p012_p12 = p012 - p12;\n\tvec2 p012_p012 = p012 - p012;\n\tvec2 p012_p012_p0 = p012_p012 - p0;\n\tvec2 p012_p012_p2 = p012_p012 - p2;\n\tvec2 p012_p012_p01 = p012_p012 - p01;\n\tvec2 p012_p012_p12 = p012_p012 - p12;\n\tvec2 p012_p012_p012 = p012_p012 - p012;\n\tvec2 p012_p012_p012_p0 = p012_p012_p012 - p0;\n\tvec2 p012_p012_p012_p2 = p012_p012_p012 - p2;\n\tvec2 p012_p012_p012_p01 = p012_p012_p012 - p01;\n\tvec2 p012_p012_p012_p12 = p012_p012_p012 - p12;\n\tvec2 p012_p012_p0", "\n    vec3 a, b, c, d;\n    a = p0 - p1;\n    b = p2 - p1;\n    c = p3 - p1;\n    d = p0 + p3 - 2.0*p1;\n    vec3 ab = abs(b);\n    vec3 bc = abs(c);\n    vec3 mn = min(ab,bc);\n    vec3 mx = max(ab,bc);\n    vec3 dn = min(mn,a);\n    vec3 mx2 = max(mx,abs(d));\n    return bound3( p1 + (dn-mx2), p1 + (mx2+mn) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t )\n{\n    vec3 a, b, c, d;\n    a = p0 - p1;\n    b = p2 - p1;\n    c = p3 - p1;\n    d = p0 + p3 - 2.0*p1;\n    vec3 ab = abs(b);\n    vec3 bc = abs(c);\n    vec3 mn = min(ab,bc);\n    vec3 mx = max(ab,bc);\n    vec3 dn = min(mn,a);\n    vec3 mx2 = max(mx,abs(d));\n    return bound3( p1 + (dn-mx2)*t, p1 + (mx2+mn)*t );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t0, in float t1 )\n{\n    vec3 a, b, c, d;\n    a = p0 - p1;\n    b = p2 - p1;\n    c = p3 - p1;\n    d = p0 + p3 - 2.0*p1;\n    vec3 ab = abs", "\n\tvec4 bbox = vec4(p0, p0);\n\tbbox.xy = min(bbox.xy, p1);\n\tbbox.xy = min(bbox.xy, p2);\n\tbbox.xy = min(bbox.xy, p3);\n\tbbox.zw = max(bbox.zw, p1);\n\tbbox.zw = max(bbox.zw, p2);\n\tbbox.zw = max(bbox.zw, p3);\n\treturn bbox;\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec4 bbox = bboxBezierSimple(p0, p1, p2, p3);\n\tbbox = bboxBezierSimple(bbox.xy, bbox.xy + bbox.zw - p0, bbox.xy + bbox.zw - p1, bbox.xy + bbox.zw - p2);\n\tbbox = bboxBezierSimple(bbox.xy, bbox.xy + bbox.zw - p0, bbox.xy + bbox.zw - p1, bbox.xy + bbox.zw - p2);\n\tbbox = bboxBezierSimple(bbox.xy, bbox.xy + bbox.zw - p0, bbox.xy + bbox.zw - p1, bbox.xy + bbox.zw - p2);\n\treturn bbox;\n}\n\n// Approximated conservative BBox to a quadratic bezier\nvec4 bboxQuadratic(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec4 bbox = bboxBezierSimple(p0, p1, p1, p2);\n\tbbox = bboxBezierSimple(bbox.xy, bbox.xy + bbox.zw - p0, bbox.xy + bbox.zw - p1, bbox.xy + bbox.zw - p2);\n\tbbox = bboxBezierSimple(bbox.xy, bbox.xy + bbox.zw - p0, bbox.xy + bbox.zw - p1, bbox.xy + bbox.zw - p2);\n\treturn bbox;\n}\n\n// Approximated conservative BBox to a line\nvec4 bboxLine(in vec2 p0", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n\n    vec2 p0123_p01 = mix(p0123, p01, 0.5);\n    vec2 p0123_p12 = mix(p0123, p12, 0.5);\n    vec2 p0123_p23 = mix(p0123, p23, 0.5);\n    vec2 p0123_p012 = mix(p0123, p012, 0.5);\n    vec2 p0123_p123 = mix(p0123, p123, 0.5);\n\n    vec2 p0123_p0123 = mix(p0123, p0123, 0.5);\n\n    vec2 p0123_p0123_p01 = mix(p0123_p0123, p01, 0.5);\n    vec2 p0123_p0123_p12 = mix(p0123_p0123, p12, 0.5);\n    vec2 p0123_p0123_p23 = mix(p0123_p0123, p23, 0.5);\n    vec2 p0123_p0123_p012 = mix(p0123_p0123, p012, 0.5);\n    vec2 p0123_p0123_p123 = mix(", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross(rd,e2);\n\tfloat det = dot(e1,p);\n\tif (det > -EPSILON && det < EPSILON) return vec3(0.0);\n\tfloat inv_det = 1.0 / det;\n\tvec3 t = ro - v0;\n\tfloat u = dot(t,p) * inv_det;\n\tif (u < 0.0 || u > 1.0) return vec3(0.0);\n\tvec3 q = cross(t,e1);\n\tfloat v = dot(rd,q) * inv_det;\n\tif (v < 0.0 || u + v > 1.0) return vec3(0.0);\n\treturn vec3(1.0,u,v);\n}\n\n// Ray-sphere intersection. Returns { t, n }\nvec2 raySphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\treturn vec2(-b - sqrt(h),-b + sqrt(h));\n}\n\n// Ray-plane intersection. Returns { t, n }\nvec2 rayPlaneIntersect( in vec3 ro, in vec3 rd, in vec4 pln )\n{\n\tfloat d = dot(pln.xyz,rd);\n\tif( abs(d)<EPSILON ) return vec2(-1.0);\n\treturn vec2(0.0, -(dot(pln.xyz,ro) + pln.w) / d);\n}\n\n// Ray-box intersection. Returns { t, n }\nvec2 rayBoxIntersect( in vec3 ro, in vec3 rd, in vec3 boxmin, in vec3 boxmax )\n{\n\tvec3 invR = 1.0/rd;\n\t", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 h = normalize( cross( nor, e2 ) );\n\tvec3 s = normalize( vec3( dot(e1,h), dot(e2,h), 0.0 ) );\n\tvec3 q = vec3( dot(s,e1), dot(s,e2), 0.0 );\n\tvec2 st = vec2( dot(q,s), dot(q,e2) ) / vec2( dot(e1,s), dot(e1,e2) );\n\tst = clamp( st, 0.0, 1.0 );\n\tvec3 p = v0 + st.x*e1 + st.y*e2;\n\treturn clamp( 1.0 - length(p-pos)/length(nor), 0.0, 1.0 );\n}\n\n// Distance to a triangle\nfloat triDist( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 h = normalize( cross( nor, e2 ) );\n\tvec3 s = normalize( vec3( dot(e1,h), dot(e2,h), 0.0 ) );\n\tvec3 q = vec3( dot(s,e1), dot(s,e2), 0.0 );\n\tvec2 st = vec2( dot(q,s), dot(q,e2) ) / vec2( dot(e1,s), dot(e1,e2) );\n\tst = clamp( st, 0.0, 1.0 );\n\tvec3 p = v0 + st.x*e1 + st.y*e2;\n\treturn length(p-pos);\n}\n\n// Distance to a line\nfloat lineDist( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 h = normalize(", "\n\tvec2  p = pos - A;\n\tvec2  ab = B - A;\n\tvec2  bc = C - B;\n\tfloat len2 = dot(ab,ab);\n\tfloat t = clamp( dot(p,ab)/len2, 0.0, 1.0 );\n\treturn length( p - ab*t ) - sqrt( max( 0.0, len2*(1.0-t)*(1.0-t) - dot(p-ab*t,p-ab*t) ) );\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n\tvec2  p = pos - A;\n\tvec2  a = B - A;\n\tvec2  b = C - B;\n\tvec2  c = D - C;\n\tfloat len2 = dot(a,a);\n\tfloat t = clamp( dot(p,a)/len2, 0.0, 1.0 );\n\treturn sdBezier( p - a*t, A, B, C ) * sqrt( max( 0.0, len2*(1.0-t)*(1.0-t) - dot(p-a*t,p-a*t) ) );\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 pos, in float r )\n{\n\treturn length(pos) - r;\n}\n\n// signed distance to an ellipse\nfloat sdEllipse( in vec2 pos, in vec2 r )\n{\n\tpos = abs(pos)/r;\n\treturn (pos.x - pos.y)*0.5;\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 pos, in vec2 size, in float r )\n{\n\tvec2 q = size*0.5 - r;\n\treturn length(max(abs(pos)-q,0.0)) + min(max(abs(pos.x)-q.x,abs(pos.y)-q.y),0.0) - r;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in", "\n    float h = abs(p.y);\n    if( h > he ) return length(p) - r1;\n    float d1 = abs(p.x) - r1;\n    float d2 = r2 - r1;\n    float h1 = sqrt(d1*d1 + h*h);\n    float h2 = sqrt(d2*d2 + h*h);\n    return min(h1,h2) - h;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidX( in vec2 p, in float r1, float r2, float he )\n{\n    float h = abs(p.x);\n    if( h > he ) return length(p) - r1;\n    float d1 = abs(p.y) - r1;\n    float d2 = r2 - r1;\n    float h1 = sqrt(d1*d1 + h*h);\n    float h2 = sqrt(d2*d2 + h*h);\n    return min(h1,h2) - h;\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoidY( in vec2 p, in float r1, float r2, float he )\n{\n    float h = abs(p.y);\n    if( h > he ) return length(p) - r1;\n    float d1 = abs(p.x) - r1;\n    float d2 = r2 - r1;\n    float h1 = sqrt(d1*d1 + h*h);\n    float h2 = sqrt(d2*d2 + h*h);\n    return min(h1,h2) - h;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidX( in vec2 p, in float r1, float r2, float he )\n{\n    float h = abs(p.x);\n    if( h > he ) return length(p) - r1;\n    float d1 = abs(p.y) - r1;\n    float d2 = r2 - r1;\n    float h1 = sqrt(d1*d1 + h*h);\n    float h2 =", "\n    vec2 pa = abs(p)-a;\n    vec2 pb = abs(p)-b;\n    float d1 = max(pa.x,pa.y);\n    float d2 = max(pb.x,pb.y);\n    return min(max(d1,d2)+length(max(pa,pb))-ra,max(d1,d2)-rb);\n}\n\n// triangular prism\nfloat sdPrism( in vec3 p, in vec2 h )\n{\n    float d1 = -max(p.y+h.y,0.0);\n    float d2 = length(max(vec2(length(p.xz),p.y),0.0)-h);\n    return min(d1,d2);\n}\n\n// triangular prism, capped\nfloat sdPrismCapped( in vec3 p, in vec2 h, float ra, float rb )\n{\n    float d1 = -max(p.y+h.y,0.0);\n    float d2 = sdCylinder(p.xz,h.x,h.y);\n    return min(max(d1,d2),max(d2-ra,d1-rb));\n}\n\n// triangular prism, capped, with rounded ends\nfloat sdPrismCappedRound( in vec3 p, in vec2 h, float ra, float rb )\n{\n    float d1 = -max(p.y+h.y,0.0);\n    float d2 = sdCylinder(p.xz,h.x,h.y);\n    return min(max(d1,d2),max(d2-ra,abs(d1)-rb));\n}\n\n// triangular prism, capped, with conical ends\nfloat sdPrismCappedCone( in vec3 p, in vec2 h, float ra, float rb )\n{\n    float d1 = -max(p.y+h.y,0.0);\n    float d2 = sdCylinder(p.xz,h.x,h.y);\n    return min(max(d1,d2),max(d2-ra,sdCone(d1,h.y,rb)));\n}\n\n// triangular prism, capped, with con", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float", "\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<50; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, const float k, const int numSamples, const float jitter )\n{\n\tfloat res = 1.0;\n\tfloat dt = (maxt-mint)/float(numSamples);\n\tfloat t = mint + dt*0.5;\n\tfor( int i=0; i<numSamples; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += dt;\n\t}\n\tres = clamp( res, 0.0, 1.0 );\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, const float k, const int numSamples, const float jitter, const float fade )\n{\n\tfloat res = 1.0;\n\tfloat dt = (maxt-mint)/float(numSamples);\n\tfloat t = mint + dt*0.5;\n\tfor( int i=0; i<numSamples; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t*fade );\n\t\tt += dt;\n\t}\n\tres = clamp( res, 0.0, 1.0 );\n\treturn res;\n}\n\n// http", "\n\treturn fract(sin(dot(q,vec2(127.1,311.7)))*43758.5453);\n}\n\n// random value in [0,1]\nfloat random( in ivec2 p )\n{\n\treturn fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// voronoi\nfloat voronoi( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat res = 8.0;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2(i,j);\n\t\tvec2 r = vec2(b) - f + hash( p + b );\n\t\tfloat d = dot(r,r);\n\t\tres = min(res,d);\n\t}\n\treturn sqrt(res);\n}\n\n// voronoi\nfloat voronoi( in vec2 x, out vec2 id )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat res = 8.0;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2(i,j);\n\t\tvec2 r = vec2(b) - f + hash( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d<res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid = b;\n\t\t}\n\t}\n\treturn sqrt(res);\n}\n\n// voronoi\nfloat voronoi( in vec2 x, out vec2 id, out float d )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat res = 8.0;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1;", "\n    vec2 i = floor( x );\n    vec2 f = fract( x );\n\n    float a = p == 0? 1.0 : 0.0;\n    float b = p == 1? 1.0 : 0.0;\n    float c = p == 2? 1.0 : 0.0;\n    float d = p == 3? 1.0 : 0.0;\n\n    float aa = mix( a, b, f.x );\n    float bb = mix( c, d, f.x );\n    float cc = mix( aa, bb, f.y );\n\n    float r = mix( a, b, f.x );\n    float g = mix( c, d, f.x );\n    float b = mix( r, g, f.y );\n\n    return mix( cc, b, f.y );\n}\n\n// 2D simplex noise\nfloat snoise( vec2 v )\n{\n    const vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439 ); // 1.0 / 41.0\n// First corner\n    vec2 i  = floor( v + dot( v, C.yy ) );\n    vec2 x0 = v -   i + dot( i, C.xx );\n\n// Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0", "\n\tfloat f = 0.0;\n\tfloat w = 0.5;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += w * noise( x );\n\t\tx *= 2.0;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n// value noise\nfloat vnoise( in vec2 x, in int p )\n{\n\tfloat f = 0.0;\n\tfloat w = 1.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += w * noise( x );\n\t\tx *= 2.0;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n// cellular noise\nfloat cnoise( in vec2 x, in int p )\n{\n\tfloat f = 0.0;\n\tfloat w = 1.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += w * cellnoise( x );\n\t\tx *= 2.0;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n// value noise\nfloat vnoise( in vec3 x, in int p )\n{\n\tfloat f = 0.0;\n\tfloat w = 1.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += w * noise( x );\n\t\tx *= 2.0;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n// cellular noise\nfloat cnoise( in vec3 x, in int p )\n{\n\tfloat f = 0.0;\n\tfloat w = 1.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += w * cellnoise( x );\n\t\tx *= 2.0;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n// value noise\nfloat vnoise( in vec4 x, in int p )\n{\n\tfloat f = 0.0;\n\tfloat", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// generic capsule - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// generic cylinder - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// generic cone - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCone( vec3 p, vec3 c )\n{\n\t// c is the cone axis, length is the radius of the base\n\t// d is the distance to the cone axis\n\t// h is the height of the cone\n\t// r is the radius of the top of the cone\n\tfloat d = dot(p,c);\n\tfloat h = length(p-d*c);\n\tfloat r = c.z;\n\treturn (d>0.0)? h - sqrt(r*r-d*d) : length(p) - r;\n}\n\n// generic pyramid - approximated distance: https://", "\n\tvec3 q = abs(p);\n\treturn (q.x/r.x)+(q.z/r.y)-length(q*vec2(r.y,r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYYZ( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p);\n\treturn (q.y/r.x)+(q.z/r.y)-length(q*vec2(r.y,r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZZZ( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p);\n\treturn (q.z/r.x)+(q.z/r.y)-length(q*vec2(r.y,r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXX( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p);\n\treturn (q.x/r.x)+(q.x/r.y)-length(q*vec2(r.y,r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYYY( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p);\n\treturn (q.y/r.x)+(q.y/r.y)-length(q*vec2(r.y,r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZZZ( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p);\n\treturn (q.z/r.x)+(q.z/r.y)-length(q*vec2(r.y,r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXX( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p);\n\treturn (q.x/r.x)+(q.x/r.y)-length(q*vec", "\n\treturn length( p / r ) - 1.0;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good( in vec3 p, in vec3 r ) \n{\n\tvec3 q = abs(p) / r;\n\treturn length( q ) * sign(p.x)*sign(p.y)*sign(p.z) - 1.0;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good2( in vec3 p, in vec3 r ) \n{\n\tvec3 q = abs(p) / r;\n\treturn length( q ) * sign(p.x)*sign(p.y)*sign(p.z) - 1.0;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good3( in vec3 p, in vec3 r ) \n{\n\tvec3 q = abs(p) / r;\n\treturn length( q ) * sign(p.x)*sign(p.y)*sign(p.z) - 1.0;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good4( in vec3 p, in vec3 r ) \n{\n\tvec3 q = abs(p) / r;\n\treturn length( q ) * sign(p.x)*sign(p.y)*sign(p.z) - 1.0;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good5( in vec3 p, in vec3 r ) \n{\n\tvec3 q = abs(p) / r;\n\treturn length( q ) * sign(p.x)*sign(p.y)*sign(p.z) - 1.0;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good6( in vec3 p, in vec3 r ) \n{\n\tvec3 q = abs(p) / r;\n\treturn length( q ) * sign(p.x)*sign(p.y)*sign(p.z) - 1.0;\n}\n\n// generic", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 normal ) \n{\n\tvec3 q = abs(p) - r;\n\tfloat d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\tnormal = normalize(p);\n\treturn d;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 normal, out vec3 tangent ) \n{\n\tvec3 q = abs(p) - r;\n\tfloat d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\tnormal = normalize(p);\n\ttangent = normalize(vec3(normal.z,0.0,-normal.x));\n\treturn d;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 normal, out vec3 tangent, out vec3 bitangent ) \n{\n\tvec3 q = abs(p) - r;\n\tfloat d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\tnormal = normalize(p);\n\ttangent = normalize(vec3(normal.z,0.0,-normal.x));\n\tbitangent = cross( normal, tangent );\n\treturn d;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 normal, out vec3 tangent, out vec3 bitangent, out vec3 binormal ) \n{\n\tvec3 q = abs(p) - r;\n\tfloat d = length(max(q,", "\n    vec2 q = floor(p);\n    float c = mod(q.x+q.y,2.0);\n    return mix( 0.0, 1.0, smoothstep( 0.0, 0.05, abs(fract(p)-0.5) ) );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 d )\n{\n    vec2 q = floor(p);\n    float c = mod(q.x+q.y,2.0);\n    return mix( 0.0, 1.0, smoothstep( 0.0, 0.05, abs(fract(p)-0.5) ) );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 d, in float s )\n{\n    vec2 q = floor(p);\n    float c = mod(q.x+q.y,2.0);\n    return mix( 0.0, 1.0, smoothstep( 0.0, 0.05, abs(fract(p)-0.5) ) );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 d, in float s, in float t )\n{\n    vec2 q = floor(p);\n    float c = mod(q.x+q.y,2.0);\n    return mix( 0.0, 1.0, smoothstep( 0.0, 0.05, abs(fract(p)-0.5) ) );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 d, in float s, in float t, in float u )\n{\n    vec2 q = floor(p);\n    float c = mod(q.x+q.y,2.0);\n    return mix( 0.0, 1.0", "\n\treturn x / ( a * x + ( 1.0 - a ) );\n}\n\n// Schlick approximation of the Fresnel equation\nvec3 fresnel( vec3 f0, float f90, float x )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( 5.0, x ), 5.0 );\n}\n\n// Schlick approximation of the Fresnel equation\nvec3 fresnel( vec3 f0, float f90, vec3 x )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( 5.0, x ), 5.0 );\n}\n\n// Schlick approximation of the Fresnel equation\nvec3 fresnel( vec3 f0, float f90, float x, float y, float z )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( 5.0, x ), 5.0 ) * pow( bias( 5.0, y ), 5.0 ) * pow( bias( 5.0, z ), 5.0 );\n}\n\n// Schlick approximation of the Fresnel equation\nvec3 fresnel( vec3 f0, float f90, vec3 x, vec3 y, vec3 z )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( 5.0, x ), 5.0 ) * pow( bias( 5.0, y ), 5.0 ) * pow( bias( 5.0, z ), 5.0 );\n}\n\n// Schlick approximation of the Fresnel equation\nvec3 fresnel( vec3 f0, float f90, float x, float y, float z, float w )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( 5.0, x ), 5.0 ) * pow( bias( 5.0, y ), 5.0 ) * pow( bias( 5.0, z ), 5.0 ) * pow( bias( 5.0, w ), 5.0 );\n}\n\n// Schlick approximation of the Fresnel equation", "\n\treturn (x - floor(x + 0.5)) * 2.0 - 1.0;\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n\treturn 2.0 * abs(x - floor(x + 0.5)) - 1.0;\n}\n\n// biased square\nfloat my_sq( float x, float p )\n{\n\treturn 1.0 - 4.0 * abs(x - floor(x + 0.5));\n}\n\n// biased sawtooth\nfloat my_saw2( float x, float p )\n{\n\treturn (x - floor(x + 0.5)) * 2.0 - 1.0;\n}\n\n// biased triangle\nfloat my_tri2( float x, float p )\n{\n\treturn 2.0 * abs(x - floor(x + 0.5)) - 1.0;\n}\n\n// biased square\nfloat my_sq2( float x, float p )\n{\n\treturn 1.0 - 4.0 * abs(x - floor(x + 0.5));\n}\n\n// biased sawtooth\nfloat my_saw3( float x, float p )\n{\n\treturn (x - floor(x + 0.5)) * 2.0 - 1.0;\n}\n\n// biased triangle\nfloat my_tri3( float x, float p )\n{\n\treturn 2.0 * abs(x - floor(x + 0.5)) - 1.0;\n}\n\n// biased square\nfloat my_sq3( float x, float p )\n{\n\treturn 1.0 - 4.0 * abs(x - floor(x + 0.5));\n}\n\n// biased sawtooth\nfloat my_saw4( float x, float p )\n{\n\treturn (x - floor(x + 0.5)) * 2.0 - 1.0;\n}\n\n// biased triangle\nfloat my_tri4( float x, float p )\n{\n\treturn 2.0 * abs(x - floor(x", "\n\tvec3 c = vec3( 0.0 );\n\tfloat s = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat t = 0.0;\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b1 = 0.0;\n\tfloat b2 = 0.0;\n\tfloat b3 = 0.0;\n\tfloat b4 = 0.0;\n\tfloat b5 = 0.0;\n\tfloat b6 = 0.0;\n\tfloat b7 = 0.0;\n\tfloat b8 = 0.0;\n\tfloat b9 = 0.0;\n\tfloat b10 = 0.0;\n\tfloat b11 = 0.0;\n\tfloat b12 = 0.0;\n\tfloat b13 = 0.0;\n\tfloat b14 = 0.0;\n\tfloat b15 = 0.0;\n\tfloat b16 = 0.0;\n\tfloat b17 = 0.0;\n\tfloat b18 = 0.0;\n\tfloat b19 = 0.0;\n\tfloat b20 = 0.0;\n\tfloat b21 = 0.0;\n\tfloat b22 = 0.0;\n\tfloat b23 = 0.0;\n\tfloat b24 = 0.0;\n\tfloat b25 = 0.0;\n\tfloat b26 = 0.0;\n\tfloat b27 = 0.0;\n\tfloat b28 = 0.0;\n\tfloat b29 = 0.0;\n\tfloat b30 = 0.0;\n\tfloat b31 = 0.0;\n\tfloat b32 = 0.0;\n\tfloat b33 = 0.0;\n\tfloat b34 = 0.0;\n\tfloat b35 = 0.0;\n\tfloat b36 = 0.0;\n\tfloat b37 = 0.0;\n\tfloat", "\n\tvec3 a = pa - ro;\n\tvec3 b = pb - ro;\n\tfloat h = clamp( dot(a,b)/dot(b,b), 0.0, 1.0 );\n\tvec3 c = ro + b*h - pa;\n\tfloat d = length(c)-r;\n\treturn d;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 ce, in float ra )\n{\n\tvec3 oc = ro - ce;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - ra*ra;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt(h);\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pl )\n{\n\treturn (dot(ro,pl.xyz) + pl.w) / dot(rd,pl.xyz);\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 mi, in vec3 ma )\n{\n\tvec3 invR = 1.0 / rd;\n\tvec3 n = invR * rd;\n\tvec3 k = abs(invR) * (ma-mi);\n\tvec3 c = -ro - mi*invR;\n\tvec3 a = max(k*c - c*n, 0.0);\n\tvec3 b = max(abs(c) - k, 0.0);\n\tfloat res = max(max(a.x,a.y),a.z);\n\tif( res<max(max(b.x,b.y),b.z) )\n\t{\n\t\tres = length(max(a,b));\n\t\tfloat t = dot(n,max(a,b));\n\t\treturn", "\n    vec3 q = p - a;\n    float h = dot(q, b);\n    if(h < 0.0) return length(q) - ra;\n    vec3 c = cross(b, q);\n    float d = length(c);\n    return sqrt(h*h + d*d) - ra;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdPlane", "\n\tfloat res = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tif( h<0.001 ) return 0.0;\n\t\tres = min( res, k*h/t );\n\t\tt += h;\n\t\tif( t>r ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// raymarching\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n\tfloat t = 0.0;\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tif( h<0.001 || t>20.0 ) break;\n\t\tt += h;\n\t}\n\treturn t;\n}\n\n// normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize", "\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float r1 = rad1 + th;\n    float r2 = rad2 - th;\n    float r3 = rad1 - th;\n    float r4 = rad2 + th;\n    float r5 = rad1;\n    float r6 = rad2;\n    float r7 = rad1 - 2.0 * th;\n    float r8 = rad2 + 2.0 * th;\n    float r9 = rad1 + 2.0 * th;\n    float r10 = rad2 - 2.0 * th;\n    float r11 = rad1 - 3.0 * th;\n    float r12 = rad2 + 3.0 * th;\n    float r13 = rad1 + 3.0 * th;\n    float r14 = rad2 - 3.0 * th;\n    float r15 = rad1 - 4.0 * th;\n    float r16 = rad2 + 4.0 * th;\n    float r17 = rad1 + 4.0 * th;\n    float r18 = rad2 - 4.0 * th;\n    float r19 = rad1 - 5.0 * th;\n    float r20 = rad2 + 5.0 * th;\n    float r21 = rad1 + 5.0 * th;\n    float r22 = rad2 - 5.0 * th;\n    float r23 = rad1 - 6.0 * th;\n    float r24 = rad2 + 6.0 * th;\n    float r25 = rad1 + 6.0 * th;\n    float r26 = rad2 - 6.0 * th;\n    float r27 = rad1 - 7.0 * th;\n    float r28 = rad2 + 7.0 * th;\n    float r29 = rad1 + 7.0 * th;\n    float r30 = rad2 - 7.0 * th;\n    float r31 = rad1 - 8.0 * th;\n    float r32 = rad2 + 8.0 * th;\n    float r33 = rad1 + 8.0 * th;\n    float r34", "\n\tfloat a = atan(p.x,p.y) - atan(c.x,c.y);\n\tfloat d = length(p)*cos(a) - r*sin(a);\n\treturn d;\n}\n\n// 2D Circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// 2D Rectangle\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 2D Rounded Rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in float r )\n{\n    b = max(b,vec2(2.0*r));\n    return sdRectangle(p,b-vec2(r))-r;\n}\n\n// 2D Ellipse\nfloat sdEllipse( in vec2 p, in vec2 b )\n{\n    return length(p/b);\n}\n\n// 2D Rounded Ellipse\nfloat sdRoundedEllipse( in vec2 p, in vec2 b, in float r )\n{\n    return length((p-b*0.5)/(b*0.5+vec2(r)));\n}\n\n// 2D Triangle\nfloat sdTriangle( in vec2 p, in vec2 q )\n{\n    vec2 r = p - q;\n    float k = clamp( dot(r,q)/dot(q,q), 0.0, 1.0 );\n    return length(r - q*k);\n}\n\n// 2D Hexagon\nfloat sdHexagon( in vec2 p, in float r )\n{\n    vec2 k = vec2( -0.86602540378443864676372317075294, 0.5 );\n    p = abs(p);\n    p -= 2.0*min( dot(k,p-r), 0.0 );\n    return length(max(p,vec2(0.0)))-r;\n}\n\n// ", "\n\tvec3 grad = vec3( 4.0*pos.x*pos.x, 4.0*pos.y*pos.y, 4.0*pos.z*pos.z );\n\treturn grad;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere5( in vec3 pos )\n{\n\tvec3 grad = vec3( 4.0*pos.x*pos.x, 4.0*pos.y*pos.y, 4.0*pos.z*pos.z );\n\treturn grad;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere6( in vec3 pos )\n{\n\tvec3 grad = vec3( 4.0*pos.x*pos.x, 4.0*pos.y*pos.y, 4.0*pos.z*pos.z );\n\treturn grad;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere7( in vec3 pos )\n{\n\tvec3 grad = vec3( 4.0*pos.x*pos.x, 4.0*pos.y*pos.y, 4.0*pos.z*pos.z );\n\treturn grad;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere8( in vec3 pos )\n{\n\tvec3 grad = vec3( 4.0*pos.x*pos.x, 4.0*pos.y*pos.y, 4.0*pos.z*pos.z );\n\treturn grad;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x", "\n\tvec2 pa = p * sca;\n\tfloat a = atan( pa.y, pa.x ) + PI;\n\tfloat d = length( pa ) * scb.x;\n\treturn max( abs( d - ra ), abs( d - rb ) ) * sign( d - ra ) - scb.y;\n}\n\n// 2D Circle\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// 2D Rectangle\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 2D Rounded Rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in float r )\n{\n\tvec2 q = abs(p);\n\treturn max(q.x,q.y)-length(max(q-b,0.0))-r;\n}\n\n// 2D Ellipse\nfloat sdEllipse( in vec2 p, in vec2 b )\n{\n\treturn length(p/b);\n}\n\n// 2D Triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// 2D Hexagon\nfloat sdHexagon( in vec2 p, in vec2 h )\n{\n\tconst vec2 k = vec2( -0.86602540378443864676, 0.5 );\n\tp.x = abs(p.x); p.y += h.y*0.5;\n\tvec2 q = p - k*h.x*0.5;\n\treturn max( dot(q,q)/dot(h,h), dot(abs(q)-h,abs", "\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k, in float w )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += w*h;\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.", "\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 16.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadow", "\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.0 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.0 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.0 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.", "\n    vec2 q = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( q, vec2( 17.0, 59.0 ) ),\n                    dot( q+vec2( 100.0, 0.0 ), vec2( 17.0, 59.0 ) ), u.x ),\n                mix( dot( q+vec2( 0.0, 51.0 ), vec2( 17.0, 59.0 ) ),\n                    dot( q+vec2( 100.0, 51.0 ), vec2( 17.0, 59.0 ) ), u.x ), u.y );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale )\n{\n    vec2 q = floor( p*scale );\n    vec2 f = fract( p*scale );\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( q, vec2( 17.0, 59.0 ) ),\n                    dot( q+vec2( 100.0, 0.0 ), vec2( 17.0, 59.0 ) ), u.x ),\n                mix( dot( q+vec2( 0.0, 51.0 ), vec2( 17.0, 59.0 ) ),\n                    dot( q+vec2( 100.0, 51.0 ), vec2( 17.0, 59.0 ) ), u.x ), u.y );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale, in float offset )\n{\n    vec2 q = floor( p*scale + offset );\n    vec2 f = fract", "\n\treturn floor( x*k )/k;\n}\n\n//\n// 2D staircase function y=f(x,y)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2 p, in float k )\n{\n\treturn vec2( staircase( p.x, k ), staircase( p.y, k ) );\n}\n\n//\n// 3D staircase function y=f(x,y,z)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec3 staircase( in vec3 p, in float k )\n{\n\treturn vec3( staircase( p.x, k ), staircase( p.y, k ), staircase( p.z, k ) );\n}\n\n//\n// 4D staircase function y=f(x,y,z,w)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec4 staircase( in vec4 p, in float k )\n{\n\treturn vec4( staircase( p.x, k ), staircase( p.y, k ), staircase( p.z, k ), staircase( p.w, k ) );\n}\n\n//\n// 2D staircase function y=f(x,y)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2 p, in vec2 k )\n{\n\t", "\n    // Calculate the ray direction\n    vec3 ray_dir = normalize(sample_pos - camera_pos);\n\n    // Calculate the ray length\n    float ray_length = length(sample_pos - camera_pos);\n\n    // Calculate the ray marching step size\n    float step_size = ray_length / float(STEPS);\n\n    // Calculate the ray marching direction\n    vec3 ray_march_dir = ray_dir * step_size;\n\n    // Calculate the ray marching start position\n    vec3 ray_march_pos = camera_pos;\n\n    // Calculate the ray marching end position\n    vec3 ray_march_end = sample_pos;\n\n    // Calculate the ray marching direction\n    vec3 ray_march_dir = ray_dir * step_size;\n\n    // Calculate the ray marching start position\n    vec3 ray_march_pos = camera_pos;\n\n    // Calculate the ray marching end position\n    vec3 ray_march_end = sample_pos;\n\n    // Calculate the ray marching direction\n    vec3 ray_march_dir = ray_dir * step_size;\n\n    // Calculate the ray marching start position\n    vec3 ray_march_pos = camera_pos;\n\n    // Calculate the ray marching end position\n    vec3 ray_march_end = sample_pos;\n\n    // Calculate the ray marching direction\n    vec3 ray_march_dir = ray_dir * step_size;\n\n    // Calculate the ray marching start position\n    vec3 ray_march_pos = camera_pos;\n\n    // Calculate the ray marching end position\n    vec3 ray_march_end = sample_pos;\n\n    // Calculate the ray marching direction\n    vec3 ray_march_dir = ray_dir * step_size;\n\n    // Calculate the ray marching start position\n    vec3 ray_march_pos = camera_pos;\n\n    // Calculate the ray marching end position\n    vec3 ray_march_end = sample_pos;\n\n    // Calculate the ray marching direction\n    vec3 ray_march_dir = ray_dir * step_size;\n\n    // Calculate the ray marching start position\n    vec3 ray_march_pos = camera_pos;\n\n    // Calculate the ray marching end position\n    vec3 ray_march", "\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    vec3 normal = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    float light_intensity = 1.0;\n    float light_falloff = 1.0;\n    float light_radius = 1.0;\n    float light_angle = 0.0;\n    float light_angle_falloff = 0.0;\n    float light_angle_falloff_power = 0.0;\n    float light_angle_falloff_bias = 0.0;\n    float light_angle_falloff_scale = 0.0;\n    float light_angle_falloff_clamp = 0.0;\n    float light_angle_falloff_clamp_power = 0.0;\n    float light_angle_falloff_clamp_bias = 0.0;\n    float light_angle_falloff_clamp_scale = 0.0;\n    float light_angle_falloff_clamp_clamp = 0.0;\n    float light_angle_falloff_clamp_clamp_power = 0.0;\n    float light_angle_falloff_clamp_clamp_bias = 0.0;\n    float light_angle_falloff_clamp_clamp_scale = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_power = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_bias = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_scale = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_clamp = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_clamp_power = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_clamp_bias = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_clamp_scale = 0.0;\n    float light_angle_falloff_clamp_clamp_clamp_clamp_clamp = 0.0;\n    float light_angle_", "\n    vec3 camera_vector = normalize(vec3(coord.x, coord.y, 1.0) - vec3(0.5, 0.5, 0.0));\n    camera_vector.x *= resolution.x / resolution.y;\n    return camera_vector;\n}\n\n/*\nnow we need a way to calculate the color of a pixel\n\nwe need to know the camera vector, the scattering function, and the distance to the sun\n\nthe scattering function is calculated by the scattering function function\nthe distance to the sun is calculated by the distance_to_sun function\n\nthe color is calculated by the color function\n*/\nvec3 get_color(vec3 camera_vector, vec3 scattering_function, float distance_to_sun) {\n    return vec3(1.0) * scattering_function * distance_to_sun;\n}\n\n/*\nnow we need a way to calculate the scattering function\n\nwe need to know the camera vector, the distance to the sun, and the sun color\n\nthe scattering function is calculated by the scattering function function\n*/\nvec3 get_scattering_function(vec3 camera_vector, float distance_to_sun, vec3 sun_color) {\n    return vec3(1.0) * sun_color * distance_to_sun;\n}\n\n/*\nnow we need a way to calculate the distance to the sun\n\nwe need to know the camera vector\n\nthe distance to the sun is calculated by the distance_to_sun function\n*/\nfloat get_distance_to_sun(vec3 camera_vector) {\n    return 1.0;\n}\n\n/*\nnow we need a way to calculate the sun color\n\nwe need to know the camera vector\n\nthe sun color is calculated by the sun_color function\n*/\nvec3 get_sun_color(vec3 camera_vector) {\n    return vec3(1.0);\n}\n\n/*\nnow we need a way to calculate the sun color\n\nwe need to know the camera vector\n\nthe sun color is calculated by the sun_color function\n*/\nvec3 get_sun_color(vec3 camera_vector) {\n    return vec3(1.0);\n}\n\n/*\nnow we need a way to calculate the sun", "\n\tfloat d = length(p);\n\tfloat a = atan(p.z, p.x);\n\tfloat r = ra * d;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tfloat t = 1.0 - c * c;\n\tfloat h = sqrt(t);\n\tfloat b = s * h;\n\tfloat m = max(0.0, c - b);\n\tfloat n = max(0.0, c + b);\n\tfloat x = clamp(r / n, 0.0, 1.0);\n\tfloat y = clamp(r / m, 0.0, 1.0);\n\tfloat z = clamp(r, 0.0, 1.0);\n\treturn min(x, min(y, z));\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone(vec3 p, vec2 c)\n{\n\tfloat q = length(p.xy);\n\treturn max(q * c.x - p.z * c.y, 0.0) + length(max(vec2(0.0), p.xy)) * c.y;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdConeSection(vec3 p, vec2 c, float ra, float rb)\n{\n\tfloat d = length(p);\n\tfloat a = atan(p.z, p.x);\n\tfloat r = ra * d;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tfloat t = 1.0 - c * c;\n\tfloat h = sqrt(t);\n\tfloat b = s * h;\n\tfloat m = max(0.0, c - b);\n\tfloat n = max(0.0, c + b);\n\tfloat x = clamp(r / n, 0.0, 1.0);\n\tfloat y = clamp(r / m, 0.0, 1.0);\n\tfloat z = clamp(r, 0.0, 1.0);\n\tfloat e = sdEllipsoid(p, vec3(1.0, 1.", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 1) {\n        return vec3(1.0, 1.0, 1.0);\n    } else if (material == 2) {\n        return vec3(0.0, 0.0, 1.0);\n    } else if (material == 3) {\n        return vec3(1.0, 0.0, 0.0);\n    } else if (material == 4) {\n        return vec3(0.0, 1.0, 0.0);\n    } else if (material == 5) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 6) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 7) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 8) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 9) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 10) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 11) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 12) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 13) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 14) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 15) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 16) {\n        return vec3(0.0, 0.0, 0", "\n    return material_reflectivity[material];\n}\n\n// Get refractive index of a material.\n// 1.0 is not refractive at all.\n// 1.5 is a typical value for glass.\nfloat get_material_refractive_index(int material) {\n    return material_refractive_index[material];\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return material_color[material];\n}\n\n// Get the ambient color of a material.\nvec3 get_material_ambient_color(int material) {\n    return material_ambient_color[material];\n}\n\n// Get the diffuse color of a material.\nvec3 get_material_diffuse_color(int material) {\n    return material_diffuse_color[material];\n}\n\n// Get the specular color of a material.\nvec3 get_material_specular_color(int material) {\n    return material_specular_color[material];\n}\n\n// Get the shininess of a material.\nfloat get_material_shininess(int material) {\n    return material_shininess[material];\n}\n\n// Get the transparency of a material.\nfloat get_material_transparency(int material) {\n    return material_transparency[material];\n}\n\n// Get the refraction index of a material.\nfloat get_material_refraction_index(int material) {\n    return material_refraction_index[material];\n}\n\n// Get the refraction index of a material.\nfloat get_material_refraction_index(int material) {\n    return material_refraction_index[material];\n}\n\n// Get the refraction index of a material.\nfloat get_material_refraction_index(int material) {\n    return material_refraction_index[material];\n}\n\n// Get the refraction index of a material.\nfloat get_material_refraction_index(int material) {\n    return material_refraction_index[material];\n}\n\n// Get the refraction index of a material.\nfloat get_material_refraction_index(int material) {\n    return material_refraction_index[material];\n}\n\n// Get the refraction index of a material.\nfloat", "\n\treturn materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index(int material) {\n\treturn materials[material].refraction_index;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_squared(int material) {\n\treturn materials[material].refraction_index_squared;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_squared_inverse(int material) {\n\treturn materials[material].refraction_index_squared_inverse;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse(int material) {\n\treturn materials[material].refraction_index_inverse;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse_squared(int material) {\n\treturn materials[material].refraction_index_inverse_squared;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse_squared_inverse(int material) {\n\treturn materials[material].refraction_index_inverse_squared_inverse;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse_squared_inverse_squared(int material) {\n\treturn materials[material].refraction_index_inverse_squared_inverse_squared;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse_squared_inverse_squared_inverse(int material) {\n\treturn materials[material].refraction_index_inverse_squared_inverse_squared_inverse;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse_squared_inverse_squared_inverse_squared(int material) {\n\treturn materials[material].refraction_index_inverse_squared_inverse_squared_inverse_squared;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_inverse_squared_inverse_squared_inverse_squared_", "\n    return materials[material].opacity;\n}\n\n// Get ambient color of a material.\nvec3 get_material_ambient(int material) {\n    return materials[material].ambient;\n}\n\n// Get diffuse color of a material.\nvec3 get_material_diffuse(int material) {\n    return materials[material].diffuse;\n}\n\n// Get specular color of a material.\nvec3 get_material_specular(int material) {\n    return materials[material].specular;\n}\n\n// Get shininess of a material.\nfloat get_material_shininess(int material) {\n    return materials[material].shininess;\n}\n\n// Get texture of a material.\nint get_material_texture(int material) {\n    return materials[material].texture;\n}\n\n// Get texture of a material.\nint get_material_normal_map(int material) {\n    return materials[material].normal_map;\n}\n\n// Get texture of a material.\nint get_material_specular_map(int material) {\n    return materials[material].specular_map;\n}\n\n// Get texture of a material.\nint get_material_emissive_map(int material) {\n    return materials[material].emissive_map;\n}\n\n// Get texture of a material.\nint get_material_alpha_map(int material) {\n    return materials[material].alpha_map;\n}\n\n// Get texture of a material.\nint get_material_light_map(int material) {\n    return materials[material].light_map;\n}\n\n// Get texture of a material.\nint get_material_ao_map(int material) {\n    return materials[material].ao_map;\n}\n\n// Get texture of a material.\nint get_material_bump_map(int material) {\n    return materials[material].bump_map;\n}\n\n// Get texture of a material.\nint get_material_displacement_map(int material) {\n    return materials[material].displacement_map;\n}\n\n// Get texture of a material.\nint get_material_reflection_map(int material) {\n    return materials[material].reflection_map;\n}\n\n// Get texture of a material.\nint get_material", "\n    vec3 ba = tri_b - tri_a;\n    vec3 ca = tri_c - tri_a;\n    vec3 n = cross(ba, ca);\n    vec3 p = line_a - tri_a;\n    vec3 q = line_b - tri_a;\n    float u = dot(p, cross(q, ca)) / dot(n, ca);\n    float v = dot(p, cross(ba, q)) / dot(n, ba);\n    float t = dot(p, n) / dot(n, ba);\n    return vec3(t >= 0.0 && t <= 1.0 && u >= 0.0 && u + v <= 1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_n) {\n    vec3 ba = tri_b - tri_a;\n    vec3 ca = tri_c - tri_a;\n    vec3 n = tri_n;\n    vec3 p = line_a - tri_a;\n    vec3 q = line_b - tri_a;\n    float u = dot(p, cross(q, ca)) / dot(n, ca);\n    float v = dot(p, cross(ba, q)) / dot(n, ba);\n    float t = dot(p, n) / dot(n, ba);\n    return vec3(t >= 0.0 && t <= 1.0 && u >= 0.0 && u + v <= 1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_n, vec3 tri_p", "\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d) {\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    vec3 v3 = tri_d - tri_a;\n    return normalize(cross(v1, v2) + cross(v2, v3));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d, vec3 tri_e) {\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    vec3 v3 = tri_d - tri_a;\n    vec3 v4 = tri_e - tri_a;\n    return normalize(cross(v1, v2) + cross(v2, v3) + cross(v3, v4));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri", "\n    vec3 z = normalize(camera_position - camera_target);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target, vec3 camera_up) {\n    vec3 z = normalize(camera_position - camera_target);\n    vec3 x = normalize(cross(camera_up, z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target, vec3 camera_up, vec3 camera_right) {\n    vec3 z = normalize(camera_position - camera_target);\n    vec3 x = normalize(cross(camera_up, z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target, vec3 camera_up, vec3 camera_right, vec3 camera_forward) {\n    vec3 z = normalize(camera_position - camera_target);\n    vec3 x = normalize(cross(camera_up, z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratch", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = INFINITY;\n    result.normal = vec3(0.0, 0.0, 0.0);\n    result.color = vec3(0.0, 0.0, 0.0);\n    result.material = 0;\n    result.texture_coord = vec2(0.0, 0.0);\n    result.texture_index = 0;\n    result.texture_color = vec3(0.0, 0.0, 0.0);\n    result.texture_normal = vec3(0.0, 0.0, 0.0);\n    result.texture_specular = vec3(0.0, 0.0, 0.0);\n    result.texture_shininess = 0.0;\n    result.texture_opacity = 0.0;\n    result.texture_bump = 0.0;\n    result.texture_reflection = 0.0;\n    result.texture_refraction = 0.0;\n    result.texture_refraction_index = 0.0;\n    result.texture_refraction_color = vec3(0.0, 0.0, 0.0);\n    result.texture_refraction_normal = vec3(0.0, 0.0, 0.0);\n    result.texture_refraction_specular = vec3(0.0, 0.0, 0.0);\n    result.texture_refraction_shininess = 0.0;\n    result.texture_refraction_opacity = 0.0;\n    result.texture_refraction_bump = 0.0;\n    result.texture_refraction_reflection = 0.0;\n    result.texture_refraction_reflection_color = vec3(0.0, 0.0, 0.0);\n    result.texture_refraction_reflection_normal = vec3(0.0, 0.0, 0.0);\n    result.texture_refraction_reflection_specular = vec3(0.0, 0.0, 0.0);\n    result.texture_refraction_reflection_shininess = 0.0;\n    result.texture_refraction_", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float shadow_factor = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n        t += RAY_STEP_SIZE;\n        vec3 ray_end = ray_origin + ray_direction * t;\n        vec3 ray_end_floor = floor(ray_end);\n        vec3 ray_end_ceil = ceil(ray_end);\n        vec3 ray_end_floor_center = ray_end_floor + 0.5;\n        vec3 ray_end_ceil_center = ray_end_ceil - 0.5;\n        vec3 ray_end_floor_center_to_ray_end = ray_end_floor_center - ray_end;\n        vec3 ray_end_ceil_center_to_ray_end = ray_end_ceil_center - ray_end;\n        vec3 ray_end_floor_center_to_ray_end_length = length(ray_end_floor_center_to_ray_end);\n        vec3 ray_end_ceil_center_to_ray_end_length = length(ray_end_ceil_center_to_ray_end);\n        vec3 ray_end_floor_center_to_ray_end_direction = normalize(ray_end_floor_center_to_ray_end);\n        vec3 ray_end_ceil_center_to_ray_end_direction = normalize(ray_end_ceil_center_to_ray_end);\n        vec3 ray_end_floor_center_to_ray_end_direction_to_light = normalize(ray_end_floor_center_to_ray_end_direction - light_direction);\n        vec3 ray_end_ceil_center_to_ray_end_direction_to_light = normalize(ray_end_ceil_center_to_ray_end_direction - light_direction);\n        vec3 ray_end_floor_center_to_ray_end_direction_to_light_length = length(ray_end_floor_center_to_ray_end_direction_to_light);\n        vec3 ray_end_ceil_center_to_ray_end_direction", "\n\treturn fract(sin(x)*43758.5453);\n}\n\n// Interpolated noise\nfloat snoise( in float x )\n{\n\tfloat floorX = floor(x);\n\tfloat t = fract(x);\n\tfloat y1 = bnoise(floorX);\n\tfloat y2 = bnoise(floorX+1.0);\n\treturn mix(y1,y2,t);\n}\n\n// 1D simplex noise\nfloat snoise(vec2 v)\n{\n\tconst vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n\t\t\t\t\t  0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t\t-0.577350269189626,  // -1.0 + 2.0 * C.x\n\t\t\t\t\t  0.024390243902439); // 1.0 / 41.0\n// First corner\n\tvec2 i  = floor(v + dot(v, C.yy) );\n\tvec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n\tvec2 i1;\n\t//i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n\t//i1.y = 1.0 - i1.x;\n\ti1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t// x0 = x0 - 0.0 + 0.0 * C.xx ;\n\t// x1 = x0 - i1 + 1.0 * C.xx ;\n\t// x2 = x0 - 1.0 + 2.0 * C.xx ;\n\tvec4 x12 = x0.xyxy + C.xxzz;\n", "\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix( rand(fl), rand(fl+1.0), fc);\n}\n\n// Classic Perlin noise\nfloat pnoise( in float x, in float y )\n{\n    float u = fade(x);\n    float v = fade(y);\n    float i = floor(x);\n    float j = floor(y);\n    float f = fract(x);\n    float g = fract(y);\n    float a = rand(i)+rand(j+1.0);\n    float b = rand(i+1.0)+rand(j+1.0);\n    return mix(mix(rand(i+1.0,j),rand(i,j),u),mix(rand(i+1.0,j+1.0),rand(i,j+1.0),u),v);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise( in float x, in float y, float px, float py )\n{\n    float u = fade(x);\n    float v = fade(y);\n    float i = floor(x);\n    float j = floor(y);\n    float f = fract(x);\n    float g = fract(y);\n    float a = rand(i,j);\n    float b = rand(i+px,j);\n    float c = rand(i,j+py);\n    float d = rand(i+px,j+py);\n    return mix(mix(a,b,u),mix(c,d,u),v);\n}\n\n// 1D simplex noise\nfloat snoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = fade(f);\n    return mix( rand(i), rand(i+1.0), u);\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 v )\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt", "\n    n = (n << 13) ^ n;\n    return 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;\n}\n\n// 1D simplex noise\nfloat noise( float x ) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix( hash(int(i)), hash(int(i + 1)), u);\n}\n\n// 2D simplex noise\nfloat noise( vec2 v ) \n{\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y +", "\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix( rand(fl), rand(fl+1.0), fc);\n}\n\n// 1D simplex noise\nfloat snoise( in float p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    float i = floor(p+dot(p,vec2(K1,-K1)));\n    float x0 = p-i+dot(i,vec2(-K1,K1));\n\n    float g = step(x0,x0.y);\n    float x1 = x0-(1.0-4.0*g)*K1;\n    float x2 = x0-(2.0-4.0*g)*K1;\n\n    return mix( mix( rand(i), rand(i+1.0), x0 ),\n                mix( rand(i+ivec2(1,0)), rand(i+ivec2(2,0)), x1 ), x0.x );\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x+p.y)*K1);\n\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y)? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max(0.5-vec3", "\n\tfloat f = 0.0;\n\tf += 0.50000*noise( x ); x = x*2.02;\n\tf += 0.25000*noise( x ); x = x*2.03;\n\tf += 0.12500*noise( x ); x = x*2.01;\n\tf += 0.06250*noise( x ); x = x*2.04;\n\tf += 0.03125*noise( x );\n\treturn f;\n}\n\n// fbm\nfloat fbm( in vec2 x, in float G )\n{\n\tfloat f = 0.0;\n\tf += 0.50000*noise( x ); x = x*2.02;\n\tf += 0.25000*noise( x ); x = x*2.03;\n\tf += 0.12500*noise( x ); x = x*2.01;\n\tf += 0.06250*noise( x ); x = x*2.04;\n\tf += 0.03125*noise( x );\n\treturn f;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G )\n{\n\tfloat f = 0.0;\n\tf += 0.50000*noise( x ); x = x*2.02;\n\tf += 0.25000*noise( x ); x = x*2.03;\n\tf += 0.12500*noise( x ); x = x*2.01;\n\tf += 0.06250*noise( x ); x = x*2.04;\n\tf += 0.03125*noise( x );\n\treturn f;\n}\n\n// fbm\nfloat fbm( in vec4 x, in float G )\n{\n\tfloat f = 0.0;\n\tf += 0.50000*noise( x ); x = x*2.02", "\n\tvec3 c = vec3(0.0);\n\tfloat d = 0.0;\n\tfloat r = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c1 = 0.0;\n\tfloat c2 = 0.0;\n\tfloat c3 = 0.0;\n\tfloat c4 = 0.0;\n\tfloat c5 = 0.0;\n\tfloat c6 = 0.0;\n\tfloat c7 = 0.0;\n\tfloat c8 = 0.0;\n\tfloat c9 = 0.0;\n\tfloat c10 = 0.0;\n\tfloat c11 = 0.0;\n\tfloat c12 = 0.0;\n\tfloat c13 = 0.0;\n\tfloat c14 = 0.0;\n\tfloat c15 = 0.0;\n\tfloat c16 = 0.0;\n\tfloat c17 = 0.0;\n\tfloat c18 = 0.0;\n\tfloat c19 = 0.0;\n\tfloat c20 = 0.0;\n\tfloat c21 = 0.0;\n\tfloat c22 = 0.0;\n\tfloat c23 = 0.0;\n\tfloat c24 = 0.0;\n\tfloat c25 = 0.0;\n\tfloat c26 = 0.0;\n\tfloat c27 = 0.0;\n\tfloat c28 = 0.0;\n\tfloat c29 = 0.0;\n\tfloat c30 = 0.0;\n\tfloat c31 = 0.0;\n\tfloat c32 = 0.0;\n\tfloat c33 = 0.0;\n\tfloat c34 = 0.0;\n\tfloat c35 = 0.0;\n\tfloat c36 = 0.0;\n\tfloat c37 = 0.0;\n\tfloat c", "\n\tvec3 p = pb*0.5+0.5;\n\tfloat a = p.x*p.x*p.x - p.x*p.y*p.y;\n\tfloat b = p.x*p.y*p.y - p.y*p.y*p.y;\n\tfloat c = p.y*p.y*p.y - p.x*p.x*p.x;\n\tfloat d = -p.x*p.x*p.y*p.y;\n\tfloat e = p.x*p.y*p.y*p.y;\n\tfloat f = -p.y*p.y*p.y*p.y;\n\tfloat g = p.x*p.x*p.x*p.y*p.y;\n\tfloat h = -p.x*p.y*p.y*p.y*p.y;\n\tfloat i = p.y*p.y*p.y*p.y*p.y;\n\tfloat j = -p.x*p.x*p.x*p.x*p.y*p.y;\n\tfloat k = p.x*p.x*p.y*p.y*p.y*p.y;\n\tfloat l = -p.x*p.y*p.y*p.y*p.y*p.y;\n\tfloat m = p.y*p.y*p.y*p.y*p.y*p.y;\n\tfloat n = -p.x*p.x*p.x*p.x*p.x*p.y*p.y;\n\tfloat o = p.x*p.x*p.x*p.y*p.y*p.y*p.y;\n\tfloat p = -p.x*p.x*p.y*p.y*p.y*p.y*p.y;\n\tfloat q = p.y*p.y*p.y*p.y*p.y*p.y*p.y;\n\tfloat r = -p.x*p.x*p.", "\n\tvec3 q = abs(ro-cen) - rad;\n\tvec3 t = vec3(length(max(q,0.0)), length(max(q,vec3(0.0))), length(max(q,vec3(0.0))));\n\treturn vec4(min(t.x,min(t.y,t.z)), max(t.x,max(t.y,t.z)), t.x<t.y && t.x<t.z? 1.0 : 0.0, t.y<t.z? 2.0 : 0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n ", "\n\tvec3 d = abs(ro - cen) - rad;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec3 c, in float h )\n{\n ", "\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n        float h = map(ro + rd*t).x;\n        res = min(res, w*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//\n// Soft shadows, based on\n//\n// https://www.shadertoy.com/view/4djSRW\n//\n// and\n//\n// https://www.shadertoy.com/view/4djSRW\n//\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n        float h = map(ro + rd*t).x;\n        res = min(res, k*h/t);\n        t += h;\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//\n// Soft shadows, based on\n//\n// https://www.shadertoy.com/view/4djSRW\n//\n// and\n//\n// https://www.shadertoy.com/view/4djSRW\n//\nfloat softShadow2(vec3 ro, vec3 rd, float mint, float tmax, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n        float h = map(ro + rd*t).x;\n        res = min(res, k*h/t);\n        t += h*0.5;\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//\n// Soft shadows, based on\n//\n// https://www.shadertoy.com/view", " seed = seed * 16807.0f; return seed / 65536.0f; }\nfloat rand(float min, float max) { return min + rand() * (max - min); }\nfloat rand(vec2 min, vec2 max) { return min + rand() * (max - min); }\nfloat rand(vec3 min, vec3 max) { return min + rand() * (max - min); }\nfloat rand(vec4 min, vec4 max) { return min + rand() * (max - min); }\nfloat rand(float min, float max, float seed) { float r = seed; r = r * 16807.0f; return min + r / 65536.0f * (max - min); }\nfloat rand(vec2 min, vec2 max, float seed) { float r = seed; r = r * 16807.0f; return min + r / 65536.0f * (max - min); }\nfloat rand(vec3 min, vec3 max, float seed) { float r = seed; r = r * 16807.0f; return min + r / 65536.0f * (max - min); }\nfloat rand(vec4 min, vec4 max, float seed) { float r = seed; r = r * 16807.0f; return min + r / 65536.0f * (max - min); }\nfloat rand(float min, float max, vec2 seed) { float r = dot(seed, vec2(12.9898, 78.233)); r = r * 16807.0f; return min + r / 65536.0f * (max - min); }\nfloat rand(vec2 min, vec2 max, vec2 seed) { float r = dot(seed, vec2(12.9898, 78.233)); r = r * 16807.0f; return min + r / 65536.0f * (max - min); }\nfloat rand(vec3 min, vec3", "\n\treturn a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Noise Function\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n//Inigo Quilez's 3D Noise Function\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y", "\n    vec3 q = abs(p);\n    float d = max(q.z-h,max((q.x*la+q.y*lb-la*lb)/sqrt(la*la+lb*lb),q.y-h));\n    return max(-d,min(q.x,q.y)-ra);\n}\n\n// 3D Rhombus\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, vec2 la, vec2 lb, float h, float ra)\n{\n    vec3 q = abs(p);\n    float d = max(q.z-h,max((q.x*la.x+q.y*lb.x-la.x*lb.x)/sqrt(la.x*la.x+lb.x*lb.x),q.y-h));\n    return max(-d,min(q.x,q.y)-ra);\n}\n\n// 3D Rhombus\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, vec2 la, vec2 lb, float h, vec2 ra)\n{\n    vec3 q = abs(p);\n    float d = max(q.z-h,max((q.x*la.x+q.y*lb.x-la.x*lb.x)/sqrt(la.x*la.x+lb.x*lb.x),q.y-h));\n    return max(-d,min(q.x,q.y)-max(ra.x,ra.y));\n}\n\n// 3D Rhombus\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, vec2 la, vec2 lb, float h, float ra, float rb)\n{\n    vec3 q = abs(p);\n    float d = max(q.z-h,max((q.x*la.x+q.y*lb.x-la.x*lb.x)/sqrt(la.x*la.x+lb.x*lb.x),q.y-h));\n    return max(-d,min(q.x,q.y)-", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2  pb = pa - ba*h;\n\tfloat d = length(pb);\n\tfloat d2 = max(d,r-band);\n\tfloat d1 = max(d,r+band);\n\treturn vec4( d2, d1, d, h );\n}\n\n// p = point\n// a = segment start\n// b = segment end\n// r = radius\n// band = band around the radius\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r ) \n{\n\treturn paSegment( p, a, b, r, 0.0 );\n}\n\n// p = point\n// a = segment start\n// b = segment end\n// r = radius\n// band = band around the radius\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float t ) \n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2  pb = pa - ba*h;\n\tfloat d = length(pb);\n\tfloat d2 = max(d,r-band);\n\tfloat d1 = max(d,r+band);\n\treturn vec4( d2, d1, d, h );\n}\n\n// p = point\n// a = segment start\n// b = segment end\n// r = radius\n// band = band around the radius\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a,", "\n    vec2 q = abs(p) - b;\n    return vec4( max(q+r,0.0), min(max(q,0.0),r)*s );\n}\n\n// p = local position\n// b = local box size\n// r = local radius\n// s = global scale\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, \n            in float t )\n{\n    vec2 q = abs(p) - b;\n    return vec4( max(q+r,0.0), min(max(q,0.0),r)*s, t );\n}\n\n// p = local position\n// b = local box size\n// r = local radius\n// s = global scale\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, \n            in float t, \n            in float u )\n{\n    vec2 q = abs(p) - b;\n    return vec4( max(q+r,0.0), min(max(q,0.0),r)*s, t, u );\n}\n\n// p = local position\n// b = local box size\n// r = local radius\n// s = global scale\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, \n            in float t, \n            in float u, \n            in float v )\n{\n    vec2 q = abs(p) - b;\n    return vec4( max(q+r,0.0), min(max(q,0.0),r)*s, t, u, v );\n}\n\n// p = local position\n// b = local box size\n// r = local radius\n// s = global scale\n// x = local dist\n// y = local perimeter dist\n// z", "\n    vec2 d = abs(p) - b;\n    return vec3(d.x*sign(p.x), d.y*sign(p.y));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    float d = length(p) - r;\n    return vec3(d, p.x/length(p), p.y/length(p));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 r )\n{\n    vec2 q = p/r;\n    float d = length(q) - 1.0;\n    return vec3(d, q.x/length(q), q.y/length(q));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3(length(pa - ba*h), pa.x/length(pa), pa.y/length(pa));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = ", "\n\tvec2 q = abs(p);\n\tfloat d = max(q.x,q.y) - r;\n\tfloat s = step(q.x,q.y);\n\tfloat t = step(q.y,q.x);\n\tfloat e = 1.0 - s - t;\n\treturn vec4( vec3(d,s,t), e );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paEllipse( in vec2 p, vec2 r, float band ) \n{\n\tvec2 q = abs(p/r);\n\tfloat d = max(q.x,q.y) - 1.0;\n\tfloat s = step(q.x,q.y);\n\tfloat t = step(q.y,q.x);\n\tfloat e = 1.0 - s - t;\n\treturn vec4( vec3(d,s,t), e );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRect( in vec2 p, vec2 r, float band ) \n{\n\tvec2 q = abs(p) - r;\n\tfloat d = max(q.x,q.y);\n\tfloat s = step(q.x,q.y);\n\tfloat t = step(q.y,q.x);\n\tfloat e = 1.0 - s - t;\n\treturn vec4( vec3(d,s,t), e );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRoundRect( in vec2 p, vec2 r, float band ) \n{\n\tvec2 q = abs(p) - r;\n\tfloat d = max(q.x,q.y);\n\tfloat s = step(q.x,q.y);\n\tfloat t = step(q.y,q.x);\n\tfloat e = 1.0 - s - t;\n\t", "\n\tfloat d = 1e38;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tvec2 e = verts[i]-verts[(i+1)%5];\n\t\tvec2 n = vec2(-e.y,e.x);\n\t\td = min(d,abs(dot(p-verts[i],n))/length(e));\n\t}\n\treturn d-r;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4s23zN\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h =", "\n\tvec4 res = vec4(0.0);\n\tfloat d = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d41 = 0.0;\n\tfloat d42 = 0.0;\n\tfloat d4", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec3( a + ba*h, pa - ba*h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n\tvec2 pc = p - c;\n\tfloat h = dot(pc,pc) - r*r;\n\treturn vec3( c + pc*h/dot(pc,pc), pc );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n\tvec2 pc = p - c;\n\tfloat h = dot(pc,pc) - dot(r,r);\n\treturn vec3( c + pc*h/dot(pc,pc), pc );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRect( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec3( a + ba*h, pa - ba*h );\n}\n\n//.x = f(p)\n//.y = \ufffd", "\n    vec2 q = abs(p);\n    float d = max(q.x,q.y);\n    float s = step(d,r);\n    float t = step(d,r-0.001);\n    vec2 n = vec2(0.0);\n    n.x = -sign(p.x)*s + sign(p.y)*t;\n    n.y = -sign(p.y)*s + sign(p.x)*t;\n    return vec3(d,n.x,n.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float s ) \n{\n    vec2 q = abs(p);\n    float d = max(q.x,q.y);\n    float t = step(d,r);\n    vec2 n = vec2(0.0);\n    n.x = -sign(p.x)*t;\n    n.y = -sign(p.y)*t;\n    return vec3(d,n.x,n.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float s, in float t ) \n{\n    vec2 q = abs(p);\n    float d = max(q.x,q.y);\n    float u = step(d,r);\n    vec2 n = vec2(0.0);\n    n.x = -sign(p.x)*u;\n    n.y = -sign(p.y)*u;\n    return vec3(d,n.x,n.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f", "\n    vec3 Xp = X * p;\n    float a = dot(Xp, Xp);\n    float b = 2.0 * dot(Xp, X[2]);\n    float c = dot(X[2], X[2]);\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) {\n        return false;\n    }\n    float t = sqrt(d);\n    tan1 = (b - t) * X[2] / (2.0 * a);\n    tan2 = (b + t) * X[2] / (2.0 * a);\n    return true;\n}\n\n// Return the point on the conic X closest to p.\nvec3 closestPoint(vec3 p, mat3 X) {\n    vec3 Xp = X * p;\n    float a = dot(Xp, Xp);\n    float b = 2.0 * dot(Xp, X[2]);\n    float c = dot(X[2], X[2]);\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) {\n        return p;\n    }\n    float t = sqrt(d);\n    vec3 closest = (b - t) * X[2] / (2.0 * a);\n    return X * closest;\n}\n\n// Return the point on the conic X closest to p, and the tangent to X at that point.\nvec3 closestPoint(vec3 p, mat3 X, out vec3 tangent) {\n    vec3 Xp = X * p;\n    float a = dot(Xp, Xp);\n    float b = 2.0 * dot(Xp, X[2]);\n    float c = dot(X[2], X[2]);\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) {\n        tangent = X[2];\n        return p;\n    }\n    float t = sqrt(d);\n    vec3 closest = (b - t) * X[2] / (2.0 * a);\n    tangent = (b - t) * X[2] / (2.0 * a);\n    return X * closest;\n}\n\n// Return the point on the conic X closest to p, and", "\n\tb = max(b, vec3(0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x * c + p.y * s, p.y * c - p.x * s, p.z);\n}\n\n// Distance functions\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat sdCylinder(vec3 p, vec2 c)\n{\n\treturn length(p.xz - c.x * vec2(sign(p.x), 1.0)) - c.y;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\nfloat sdCone(vec3 p, vec3 c, float r1, float r2)\n{\n", "\n\tfloat f = (x*x) / (R*R);\n\treturn f*f*(3.0f - 2.0f*f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2)\n{\n\tfloat f = (x*x) / (R*R);\n\tfloat f2 = (x*x) / (R2*R2);\n\treturn f*f*(3.0f - 2.0f*f) + f2*f2*(3.0f - 2.0f*f2);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3)\n{\n\tfloat f = (x*x) / (R*R);\n\tfloat f2 = (x*x) / (R2*R2);\n\tfloat f3 = (x*x) / (R3*R3);\n\treturn f*f*(3.0f - 2.0f*f) + f2*f2*(3.0f - 2.0f*f2) + f3*f3*(3.0f - 2.0f*f3);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4)\n{\n\tfloat f = (x*x) / (R*R);\n\tfloat f2 = (x*x) / (R2*R2);\n\tfloat f3 = (x*x) / (R3*R3);\n\tfloat f4 = (x*x) / (R4*R4);\n\treturn f*f*(3.0f - 2.0f*f) + f2*f2*(3.0f - 2.0f*f2) + f3*f3*(3.0f - 2.0f*f3) + f4*f4*(3.0f - 2.0f*f4);\n}\n\n//", "\n\tfloat k = 0.0f;\n\tif (e < 0.0f)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse if (e < 1.0f)\n\t{\n\t\tk = 1.0f;\n\t}\n\telse\n\t{\n\t\tk = 1.0f / (1.0f - e);\n\t}\n\treturn k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0)\n{\n\tfloat k = 0.0f;\n\tif (e < 0.0f)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse if (e < 1.0f)\n\t{\n\t\tk = 1.0f;\n\t}\n\telse\n\t{\n\t\tk = 1.0f / (1.0f - e);\n\t}\n\treturn k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1)\n{\n\tfloat k = 0.0f;\n\tif (e < 0.0f)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse if (e < 1.0f)\n\t{\n\t\tk = 1.0f;\n\t}\n\telse\n\t{\n\t\tk = 1.0f / (1.0f - e);\n\t}\n\treturn k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1, float R2)\n{\n\tfloat k = 0.0f;\n\tif (e < 0.0f)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse if (e < 1.0f)\n\t{\n\t\tk =", "\n\tfloat k = 0.0f;\n\tif (a > 0.0f)\n\t{\n\t\tk = (b - a) / (R * R);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R * e);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k)\n{\n\tfloat k2 = 0.0f;\n\tif (a > 0.0f)\n\t{\n\t\tk2 = (b - a) / (R * R);\n\t}\n\telse\n\t{\n\t\tk2 = (b - a) / (R * R * e);\n\t}\n\treturn k2;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k2)\n{\n\tfloat k3 = 0.0f;\n\tif (a > 0.0f)\n\t{\n\t\tk3 = (b - a) / (R * R);\n\t}\n\telse\n\t{\n\t\tk3 = (b - a) / (R * R * e);\n\t}\n\treturn k3;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k2, float k3)\n{\n\tfloat k4 = 0.0f;\n\tif (a > 0.0f)\n\t{\n\t\tk4 = (b - a) / (R * R);\n\t}\n\telse\n\t{\n\t\tk4 = (b - a) /", "\n\treturn length(p - c) - R;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n\treturn length(p - c) - R;\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Box(vec3 p, vec3 c, vec3 R, float e)\n{\n\tvec3 d = abs(p - c) - R;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float r, float e)\n{\n\tvec2 q = vec2(length(p.xz - c.xz) - R, p.y - c.y);\n\treturn length(q) - r;\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n\tvec2 d = vec2(length(p.xz - c.xz), p.y - c.y);\n\treturn max(length(d) - R, 0.0);\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n\tvec2 d = vec2(length(p.xz - c.xz), p.y - c.y);\n\treturn max(d.y, length(d) - R);\n}\n\n// Plane primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Plane(vec3 p, vec3 c, vec3 n, float e", "\n    float d = length(a - b);\n    float r = R + e;\n    float t = clamp(dot(c - a, b - a) / d, 0.0, 1.0);\n    vec3 p = a + t * (b - a);\n    float d2 = length(c - p);\n    return d2 / r;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t)\n{\n    float d = length(a - b);\n    float r = R + e;\n    float t = clamp(t, 0.0, 1.0);\n    vec3 p = a + t * (b - a);\n    float d2 = length(c - p);\n    return d2 / r;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t, float dt)\n{\n    float d = length(a - b);\n    float r = R + e;\n    float t = clamp(t, 0.0, 1.0);\n    vec3 p = a + t * (b - a);\n    float d2 = length(c - p);\n    return d2 / r;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t, float dt, float ddt)\n{\n    float d = length(a - b);\n    float r = R + e;\n    float t = clamp(t, 0.0, 1.0);\n    vec3 p =", "\n\tfloat d = 1e10;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td = min(d, OpU(p, i));\n\t}\n\treturn d;\n}\n\n// Camera ray origin\nvec3 camPos = vec3(0.0, 0.0, 1.0);\n\n// Camera ray direction\nvec3 camTarget = vec3(0.0, 0.0, 0.0);\n\n// Camera up direction\nvec3 camUp = vec3(0.0, 1.0, 0.0);\n\n// Camera field of view\nfloat camFov = 0.5;\n\n// Camera aspect ratio\nfloat camAspect = 1.0;\n\n// Camera aperture\nfloat camAperture = 0.0;\n\n// Camera focus distance\nfloat camFocus = 1.0;\n\n// Camera jitter\nvec2 camJitter = vec2(0.0);\n\n// Camera ray direction\nvec3 camRay(in vec2 p)\n{\n\tvec2 q = vec2(p.x, p.y);\n\tq.x *= camAspect;\n\tq.x = (q.x - 0.5) * 2.0;\n\tq.y = (q.y - 0.5) * 2.0;\n\tvec3 rd = normalize(vec3(q.x, q.y, camFov));\n\trd += normalize(cross(camUp, rd)) * camAperture * (q.x * 0.5 + 0.5);\n\trd += normalize(cross(rd, camUp)) * camAperture * (q.y * 0.5 + 0.5);\n\trd = normalize(rd);\n\treturn rd;\n}\n\n// Camera ray direction\nvec3 camRay(in vec2 p, in float time)\n{\n\tvec2 q = vec2(p.x, p.y);\n\tq.x *= camAspect;\n\tq.x = (q.x - 0.5) * 2.0;\n\tq.y = (q.y - 0.5) *", "\n\treturn length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r)\n{\n\treturn length(a - b) - r;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t)\n{\n\treturn length(a - b) - r * t;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s)\n{\n\treturn length(a - b) - r * t * s;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s, float p)\n{\n\treturn length(a - b) - r * t * s * p;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s, float p, float q)\n{\n\treturn length(a - b) - r * t * s * p * q;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s, float p, float q, float m)\n{\n\treturn length(a - b) - r * t * s * p * q * m;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s, float p, float q, float m, float n)\n{\n\treturn length(a - b) - r * t * s * p * q * m * n;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s, float p, float q, float m, float n, float o)\n{\n\treturn length(a - b) - r * t * s * p * q * m * n * o;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float r, float t, float s, float p, float q, float m, float n, float o, float l)\n{\n\treturn length(a - b) - r * t * s * p *", "\n\tvec3 n;\n\tn.x = Map(p+vec3(EPSILON,0.0,0.0)) - Map(p+vec3(-EPSILON,0.0,0.0));\n\tn.y = Map(p+vec3(0.0,EPSILON,0.0)) - Map(p+vec3(0.0,-EPSILON,0.0));\n\tn.z = Map(p+vec3(0.0,0.0,EPSILON)) - Map(p+vec3(0.0,0.0,-EPSILON));\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n )\n{\n\tvec3 nn;\n\tnn.x = Map(p+vec3(EPSILON,0.0,0.0)) - Map(p+vec3(-EPSILON,0.0,0.0));\n\tnn.y = Map(p+vec3(0.0,EPSILON,0.0)) - Map(p+vec3(0.0,-EPSILON,0.0));\n\tnn.z = Map(p+vec3(0.0,0.0,EPSILON)) - Map(p+vec3(0.0,0.0,-EPSILON));\n\treturn normalize(nn-n*dot(nn,n));\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in float d )\n{\n\tvec3 nn;\n\tnn.x = Map(p+vec3(EPSILON,0.0,0.0)) - Map(p+vec3(-EPSILON,0.0,0.0));\n\tnn.y = Map(p+vec3(0.0,EPSILON,0.0)) - Map(p+vec3(0.0,-EPSILON,0.0));\n\tnn.z = Map(p+vec3(0.0,0.0,EPSILON)) - Map(p+vec3(0.0,0.0,-EPSILON));\n\treturn normalize(nn-n*dot(nn,n));\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3", "\n    float t = 0.0;\n    float d = 0.0;\n    float r = 0.0;\n    float m = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float det = 0.0;\n    float invDet = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.", "\n    float t = 0.0;\n    for (s = 0; s < MAX_STEPS; s++)\n    {\n        vec3 p = o + t * u;\n        if (p.x < -1.0 || p.x > 1.0 || p.y < -1.0 || p.y > 1.0 || p.z < -1.0 || p.z > 1.0)\n        {\n            h = false;\n            return t;\n        }\n        if (map(p) < 0.001)\n        {\n            h = true;\n            return t;\n        }\n        t += 0.01;\n    }\n    h = false;\n    return t;\n}\n\n// Calculate normal\nvec3 CalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Calculate lighting\nvec3 CalcLighting(vec3 p, vec3 n, vec3 l, vec3 c)\n{\n    vec3 s = normalize(l - p);\n    float diff = clamp(dot(n, s), 0.0, 1.0);\n    vec3 r = reflect(s, n);\n    float spec = pow(clamp(dot(r, normalize(viewPos - p)), 0.0, 1.0), 16.0);\n    return (diff * c) + (spec * vec3(1.0));\n}\n\n// Calculate fog\nfloat CalcFog(float d)\n{\n    return exp(-d * d * 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 Sky(vec3 rd)\n{\n\tfloat sunAmount = max(dot(rd, sunDirection), 0.0);\n\tfloat sunSize = 0.0025;\n\tfloat sunFade = clamp(1.0 - length(rd - sunDirection) / sunSize, 0.0, 1.0);\n\tvec3 skyColor = mix(vec3(0.1, 0.2, 0.3), vec3(0.3, 0.4, 0.5), pow(1.0 - max(rd.y, 0.0), 6.0));\n\treturn mix(skyColor, vec3(1.0), sunAmount) * sunFade;\n}\n\nvec3 Shade(vec3 pos, vec3 nor, vec3 rd)\n{\n\tvec3 col = vec3(0.0);\n\tvec3 lightDir = normalize(sunDirection);\n\tfloat lightAmount = max(dot(nor, lightDir), 0.0);\n\tcol += vec3(0.5, 0.7, 1.0) * lightAmount;\n\tcol += vec3(0.0, 0.05, 0.1) * pow(lightAmount, 80.0);\n\tcol += vec3(0.0, 0.05, 0.1) * pow(max(dot(reflect(lightDir, nor), -rd), 0.0), 64.0);\n\treturn col;\n}\n\n// Raymarching functions\nfloat Map(vec3 pos)\n{\n\tfloat d = 0.0;\n\td += sdBox(pos, vec3(0.5));\n\td += sdSphere(pos, 0.25);\n\treturn d;\n}\n\nvec3 Normal(vec3 pos)\n{\n\tvec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tMap(pos + e.xyy) - Map(pos - e.xyy),\n\t\tMap(pos + e.yxy) - Map", "\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r * h;\n}\n\n// arbitrary orientation\nfloat sdConeSection(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - mix(ra, rb, h);\n}\n\n// arbitrary orientation\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r * (1.0 - h);\n}\n\n// arbitrary orientation\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n\tvec3 q = p / r;\n\treturn length(q) - 1.0;\n}\n\n// arbitrary orientation\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// arbitrary orientation\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max((q.x * 0.86", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x,t1.y),t1.z);\n\tfloat tF = min(min(t2.x,t2.y),t2.z);\n\treturn vec2(tN,tF);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.", "\n\treturn coord / iResolution.xy;\n}\n\n// normalized pixel coordinate\nvec2 px_coord(vec2 coord) {\n\treturn coord / iResolution.xy * 2.0 - 1.0;\n}\n\n// normalized pixel coordinate\nvec2 px_coord(vec2 coord, vec2 resolution) {\n\treturn coord / resolution.xy * 2.0 - 1.0;\n}\n\n// normalized pixel coordinate\nvec2 px_coord(vec2 coord, vec2 resolution, vec2 offset) {\n\treturn (coord + offset) / resolution.xy * 2.0 - 1.0;\n}\n\n// normalized pixel coordinate\nvec2 px_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale) {\n\treturn (coord + offset) / resolution.xy * 2.0 * scale - 1.0;\n}\n\n// normalized pixel coordinate\nvec2 px_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation) {\n\tvec2 center = px_coord(offset, resolution, offset, scale);\n\tvec2 p = px_coord(coord, resolution, offset, scale);\n\tfloat angle = rotation.x * 3.1415926535897932384626433832795 / 180.0;\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn center + m * (p - center);\n}\n\n// normalized pixel coordinate\nvec2 px_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation, vec2 shear) {\n\tvec2 center = px_coord(offset, resolution, offset, scale);\n\tvec2 p = px_coord(coord, resolution, offset, scale);\n\tfloat angle = rotation.x * 3.1415926535897932384626433832795 / 180.0;\n\tfloat s = sin(angle);\n\tfloat", "\n\tvec2 d = p - q;\n\tfloat a = length( d );\n\tfloat b = length( p );\n\tfloat c = length( q );\n\tfloat s = ( a + b + c ) / 2.0;\n\tfloat area = sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n\tfloat cotA = ( b * b + c * c - a * a ) / ( 2.0 * b * c );\n\tfloat cotB = ( a * a + c * c - b * b ) / ( 2.0 * a * c );\n\tfloat cotC = ( a * a + b * b - c * c ) / ( 2.0 * a * b );\n\tfloat x = area * cotA;\n\tfloat y = area * cotB;\n\tfloat z = area * cotC;\n\treturn vec3( x, y, z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleRight( in vec2 p, in vec2 q )\n{\n\tvec2 d = p - q;\n\tfloat a = length( d );\n\tfloat b = length( p );\n\tfloat c = length( q );\n\tfloat s = ( a + b + c ) / 2.0;\n\tfloat area = sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n\tfloat cotA = ( b * b + c * c - a * a ) / ( 2.0 * b * c );\n\tfloat cotB = ( a * a + c * c - b * b ) / ( 2.0 * a * c );\n\tfloat cotC = ( a * a + b * b - c * c ) / ( 2.0 * a * b );\n\tfloat x = area * cotA;\n\tfloat y = area * cotB;\n\tfloat z = area * cotC", "\n    float a = atan(p.y, p.x);\n    float b = acos(p.x / length(p));\n    float c = acos(r / d);\n    float s = sin(b);\n    float t = tan(b);\n    float u = sin(c);\n    float v = cos(c);\n    float w = sin(a);\n    float x = cos(a);\n    float y = s * u;\n    float z = s * v;\n    float yz = sqrt(1.0 - y * y);\n    return vec3(x * yz, y, z) * w + vec3(x * y, -s, 0.0) * v + vec3(0.0, 0.0, 1.0) * u;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float a)\n{\n    float b = acos(r / d);\n    float c = acos(p.x / length(p));\n    float s = sin(b);\n    float t = tan(b);\n    float u = sin(c);\n    float v = cos(c);\n    float w = sin(a);\n    float x = cos(a);\n    float y = s * u;\n    float z = s * v;\n    float yz = sqrt(1.0 - y * y);\n    return vec3(x * yz, y, z) * w + vec3(x * y, -s, 0.0) * v + vec3(0.0, 0.0, 1.0) * u;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float a, float b", "\n\tfloat a = atan( p.x, p.y );\n\tfloat d = length( p );\n\treturn vec3( sin( a ), cos( a ), d ) * r * c;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in float c, in float r )\n{\n\tfloat a = atan( p.x, p.y );\n\tfloat d = length( p );\n\treturn vec3( sin( a ), cos( a ), d ) * r * c;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c )\n{\n\tfloat a = atan( p.x, p.y );\n\tfloat d = length( p );\n\treturn vec3( sin( a ), cos( a ), d ) * c;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in float c )\n{\n\tfloat a = atan( p.x, p.y );\n\tfloat d = length( p );\n\treturn vec3( sin( a ), cos( a ), d ) * c;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f", "\n    vec3 e1 = v[1] - v[0];\n    vec3 e2 = v[2] - v[0];\n    vec3 p1 = p - v[0];\n    vec3 p2 = p - v[1];\n    vec3 p3 = p - v[2];\n\n    float d1 = dot( e1, p1 );\n    float d2 = dot( e2, p2 );\n    float d3 = dot( e1, p3 );\n    float d4 = dot( e2, p3 );\n\n    float s = d1 + d2 - d3 - d4;\n    if( s < 0.0 ) return vec3( 1.0, 0.0, 0.0 );\n\n    float t = d3 + d4 - d1 - d2;\n    if( t < 0.0 ) return vec3( 1.0, 0.0, 0.0 );\n\n    float a = d1 + d3;\n    float b = d2 + d4;\n    if( a > b )\n    {\n        float tmp = s;\n        s = t;\n        t = tmp;\n    }\n\n    float inv_denom = inversesqrt( s*s + t*(a-b) );\n    return vec3( s*inv_denom, t*inv_denom, 1.0 - s*inv_denom - t*inv_denom );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float d2 = dot( d, d );\n    float s = sqrt( d2 ) - r;\n    if( s < 0.0 ) return vec3( 1.0, 0.0, 0.0 );\n\n    float inv_denom = inversesqrt( d2 + s*s );\n    return vec3( s*inv_denom, 1.0 - s*inv_denom, 0.0 );\n}\n\n//.x", "\n\tvec2 q = p * sca;\n\tfloat a = atan( q.y, q.x );\n\tfloat r = length( q );\n\tfloat d = abs( r - ra ) - rb;\n\tfloat s = sign( r - ra );\n\tfloat da = d * s;\n\tfloat sa = sin( a );\n\tfloat ca = cos( a );\n\treturn vec3( d, sa, ca ) * s;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float a0, in float a1 )\n{\n\tvec2 q = p * sca;\n\tfloat a = atan( q.y, q.x );\n\tfloat r = length( q );\n\tfloat d = abs( r - ra ) - rb;\n\tfloat s = sign( r - ra );\n\tfloat da = d * s;\n\tfloat sa = sin( a );\n\tfloat ca = cos( a );\n\treturn vec3( d, sa, ca ) * s;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float a0, in float a1, in float a2, in float a3 )\n{\n\tvec2 q = p * sca;\n\tfloat a = atan( q.y, q.x );\n\tfloat r = length( q );\n\tfloat d = abs( r - ra ) - rb;\n\tfloat s = sign( r - ra );\n\tfloat da = d * s;\n\tfloat sa = sin( a );\n\tfloat ca = cos(", " return a.x*b.y - a.y*b.x; }\nfloat cro( in vec3 a, in vec3 b ) { return a.x*b.y - a.y*b.x; }\nfloat cro( in vec3 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat cro( in vec2 a, in vec3 b ) { return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 croc( in vec3 a, in vec3 b ) { return vec4( a.x*b.y - a.y*b.x, a.x*b.z - a.z*b.x, a.y*b.z - a.z*b.y, 1.0 ); }\nvec4 croc( in vec3 a, in vec2 b ) { return vec4( a.x*b.y - a.y*b.x, a.x*b.z - a.z*b.x, 0.0, 1.0 ); }\nvec4 croc( in vec2 a, in vec3 b ) { return vec4( a.x*b.y - a.y*b.x, 0.0, a.x*b.z - a.z*b.x, 1.0 ); }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 croc( in vec4 a, in vec4 b ) { return vec4( a.x*b.y - a.y*b.x, a", "\n    vec2 q = p / ab;\n    float r = dot( q, q );\n    float s = sqrt( r );\n    float c = cos( s );\n    float s2 = sin( s );\n    float c2 = cos( 2.0 * s );\n    float s22 = sin( 2.0 * s );\n    float c3 = cos( 3.0 * s );\n    float s3 = sin( 3.0 * s );\n    float c4 = cos( 4.0 * s );\n    float s4 = sin( 4.0 * s );\n    float c5 = cos( 5.0 * s );\n    float s5 = sin( 5.0 * s );\n    float c6 = cos( 6.0 * s );\n    float s6 = sin( 6.0 * s );\n    float c7 = cos( 7.0 * s );\n    float s7 = sin( 7.0 * s );\n    float c8 = cos( 8.0 * s );\n    float s8 = sin( 8.0 * s );\n    float c9 = cos( 9.0 * s );\n    float s9 = sin( 9.0 * s );\n    float c10 = cos( 10.0 * s );\n    float s10 = sin( 10.0 * s );\n    float c11 = cos( 11.0 * s );\n    float s11 = sin( 11.0 * s );\n    float c12 = cos( 12.0 * s );\n    float s12 = sin( 12.0 * s );\n    float c13 = cos( 13.0 * s );\n    float s13 = sin( 13.0 * s );\n    float c14 = cos( 14.0 * s );\n    float s14 = sin( 14.0 * s );\n    float c15 = cos( 15.0 * s );\n    float s15 = sin( 15.0 * s );\n    float c16 = cos( 16.0 * s );\n    float s16 = sin( 16.0 * s );\n    float c17 = cos( 17.0 * s );\n    float s", "\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    float d = length(q) - rb;\n    return vec4( p, d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc )\n{\n    vec3 q = vec3( length(p.xy) - ra, p.z, length(p.xz) - rc );\n    float d = length(q) - rb;\n    return vec4( p, d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd )\n{\n    vec3 q = vec3( length(p.xy) - ra, p.z, length(p.xz) - rc );\n    float d = length(q) - rb;\n    return vec4( p, d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re )\n{\n    vec3 q = vec3( length(p.xy) - ra, p.z, length(p.xz) - rc );\n    float d = length(q) - rb;\n    return vec4( p, d );\n}\n", "\n    vec3 ab = b - a;\n    float l = length( ab );\n    vec3 n = normalize( ab );\n    vec3 pa = p - a;\n    float h = clamp( dot( pa, n ), 0.0, l );\n    vec3 q = a + n * h;\n    vec3 pq = p - q;\n    float d = length( pq );\n    float m = r - d;\n    vec3 g = normalize( pq );\n    float s = sign( m );\n    float t = s * sqrt( max( 0.0, r * r - d * d ) );\n    vec3 x = q + g * t;\n    vec3 y = q - g * t;\n    vec3 z = a + n * ( h + s * r );\n    return vec4( x, y, z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSegment( vec3 p, vec3 a, vec3 b, float r, float t )\n{\n    vec3 ab = b - a;\n    float l = length( ab );\n    vec3 n = normalize( ab );\n    vec3 pa = p - a;\n    float h = clamp( dot( pa, n ), 0.0, l );\n    vec3 q = a + n * h;\n    vec3 pq = p - q;\n    float d = length( pq );\n    float m = r - d;\n    vec3 g = normalize( pq );\n    float s = sign( m );\n    float tt = s * sqrt( max( 0.0, r * r - d * d ) );\n    vec3 x = q + g * tt;\n    vec3 y = q - g * tt;\n    vec3 z = a + n * ( h + s * r );\n    return vec4( x, y, z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w =", "\n    vec2 q = vec2( abs(p.x), abs(p.y) );\n    float s = (q.x + q.y)*sk;\n    float d = max( q.x, q.y );\n    float c = min( q.x, q.y );\n    float e = max( (s+d)*0.5, c );\n    return length(p)*max(0.5-e/he, 0.0) - min(e, wi*0.5);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = vec2( abs(p.x), abs(p.y) );\n    float s = (q.x + q.y)*sk;\n    float d = max( q.x, q.y );\n    float c = min( q.x, q.y );\n    float e = max( (s+d)*0.5, c );\n    return length(p)*max(0.5-e/he, 0.0) - min(e, wi*0.5);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = vec2( abs(p.x), abs(p.y) );\n    float s = (q.x + q.y)*sk;\n    float d = max( q.x, q.y );\n    float c = min( q.x, q.y );\n    float e = max( (s+d)*0.5, c );\n    return length(p)*max(0.5-e/he, 0.0) - min(e, wi*0.5);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = vec2( abs(p.x), abs(p.y) );\n    float s = (q.x", "\n\tvec2 q = vec2( wi, he ) * p;\n\tvec2 r = vec2( wi, he ) * ( p + vec2( 1.0, 0.0 ) );\n\tvec2 s = vec2( wi, he ) * ( p + vec2( 0.0, 1.0 ) );\n\tvec2 t = vec2( wi, he ) * ( p + vec2( 1.0, 1.0 ) );\n\tvec2 u = vec2( wi, he ) * ( p + vec2( sk, 0.0 ) );\n\tvec2 v = vec2( wi, he ) * ( p + vec2( 0.0, sk ) );\n\tvec2 w = vec2( wi, he ) * ( p + vec2( sk, sk ) );\n\tvec2 x = vec2( wi, he ) * ( p + vec2( 1.0, sk ) );\n\tvec2 y = vec2( wi, he ) * ( p + vec2( sk, 1.0 ) );\n\tvec2 z = vec2( wi, he ) * ( p + vec2( 1.0, 1.0 ) + vec2( sk, sk ) );\n\tvec2 a = vec2( wi, he ) * ( p + vec2( sk, sk ) + vec2( 1.0, 0.0 ) );\n\tvec2 b = vec2( wi, he ) * ( p + vec2( sk, sk ) + vec2( 0.0, 1.0 ) );\n\tvec2 c = vec2( wi, he ) * ( p + vec2( sk, sk ) + vec2( 1.0, 1.0 ) );\n\tvec2 d = vec2( wi, he ) * ( p + vec2( sk, sk ) + vec2( sk, 0.0 ) );\n\tvec2 e = vec2( wi, he ) * ( p + vec2( sk, sk ) + vec2( 0.0, sk ) );\n\tvec2 f = vec2( wi, he ) * ( p + vec2( sk, sk ) + vec2( sk, sk ) );\n\tvec2 g", "\n\treturn mod(p,c);\n\t}\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\treturn mod(p,c)-0.5*c;\n\t}\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\treturn mod(p,c)-0.5*c;\n\t}\n\n//----------oPeraciones de Simetr\u00eda\nfloat opSime1D( float p, float c )\n\t{\n\treturn abs(p)-c;\n\t}\nfloat opSime2D( vec2 p, vec2 c )\n\t{\n\treturn abs(p)-c;\n\t}\nfloat opSime3D( vec3 p, vec3 c )\n\t{\n\treturn abs(p)-c;\n\t}\n\n//----------oPeraciones de Rotaci\u00f3n\nfloat opRot1D( float p, float a )\n\t{\n\treturn cos(a)*p - sin(a)*p;\n\t}\nfloat opRot2D( vec2 p, float a )\n\t{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn m*p;\n\t}\nfloat opRot3D( vec3 p, vec3 a )\n\t{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tmat3 m = mat3(c,-s,0,s,c,0,0,0,1);\n\treturn m*p;\n\t}\n\n//----------oPeraciones de Escalado\nfloat opEscal1D( float p, float c )\n\t{\n\treturn p*c;\n\t}\nfloat opEscal2D( vec2 p, vec2 c )\n\t{\n\treturn p*c;\n\t}\nfloat opEscal3D( vec3 p, vec3 c )\n\t{\n\treturn p*c;\n\t}\n\n//----------oPeraciones de Traslaci\u00f3n\nfloat opTrasl1D( float p, float c )\n\t{\n\treturn p+c;\n\t}\nfloat opTrasl2D( vec2 p,", "\n\treturn (a < b)? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n\treturn (a > b)? a : b;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) {\n\treturn pmin(pmax(a, b, k), 1.0, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) {\n\tfloat t = pclamp((k - a) / (b - a), 0.0, 1.0);\n\treturn t * t * (3.0 - 2.0 * t);\n}\n\n// IQ's polynominal mix\nfloat pmix(float a, float b, float k) {\n\treturn a + (b - a) * psmoothstep(0.0, 1.0, k);\n}\n\n// IQ's polynominal lerp\nfloat plerp(float a, float b, float k) {\n\treturn a + (b - a) * k;\n}\n\n// IQ's polynominal smooth lerp\nfloat psmoothlerp(float a, float b, float k) {\n\treturn a + (b - a) * psmoothstep(0.0, 1.0, k);\n}\n\n// IQ's polynominal cubic lerp\nfloat pcubiclerp(float a, float b, float k) {\n\tfloat p = (k - 0.5) * 2.0;\n\tif (p < 0.0) {\n\t\treturn a + (b - a) * (0.5 + p * p * 0.5);\n\t} else {\n\t\treturn b + (a - b) * (0.5 - p * p * 0.5);\n\t}\n}\n\n// IQ's polynominal cubic smooth lerp\nfloat pcubicsmoothlerp(float a, float b, float k) {\n\tfloat p = (k - 0.5) * 2.0;\n\tif (p < 0.0) {\n\t\t", "\n\tvec2 c = floor((p+size*0.5)/size);\n\tp = mod(p+size*0.5,size)-size*0.5;\n\treturn c;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( vec3 p, vec3 c, float h )\n{\n  vec3 q = abs(p);\n  return max(h*q.z - length(q.xy),0.0) +\n         length(max(vec2(q.x,q.y)-c.xy,0.0)) - c.z;\n}\n\nfloat sdConeSection( vec3 p, vec3 c, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  float k1 = dot( q, c.xz );\n  float k", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2hsl(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x", "\n\tvec3 oc = ro - s.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - s.w * s.w;\n\tfloat h = b * b - c;\n\tif (h < 0.0) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 p) {\n\tfloat denom = dot(rd, p.xyz);\n\treturn (denom!= 0.0)? vec2(0.0, -(dot(ro, p.xyz) + p.w) / denom) : vec2(-1.0);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax) {\n\tvec3 invd = 1.0 / rd;\n\tvec3 n = invd * (ro - bmin);\n\tvec3 f = invd * (ro - bmax);\n\tvec3 nmin = min(n, f);\n\tvec3 nmax = max(n, f);\n\tfloat d1 = max(max(nmin.x, nmin.y), nmin.z);\n\tfloat d2 = min(min(nmax.x, nmax.y), nmax.z);\n\treturn (d2 >= 0.0 && d1 <= d2)? vec2(d1, d2) : vec2(-1.0);\n}\n\n// IQ's ray cylinder intersection\nvec2 rayCylinder(vec3 ro, vec3 rd, vec4 c) {\n\tvec3 oc = ro - c.xyz;\n\tvec3 h = c.w * rd;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(oc, rd);\n\tfloat c = dot(oc, oc) - c.w * c.w;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0) return vec2(-1.0);", "\n    vec3 invR = 1.0 / rd;\n    vec3 tbot = invR * (boxSize - ro);\n    vec3 ttop = invR * (-ro);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    float t0 = max(max(tmin.x, tmin.y), tmin.z);\n    float t1 = min(min(tmax.x, tmax.y), tmax.z);\n    if (t0 > t1) return vec2(-1.0);\n    outNormal = -sign(rd) * step(tmin.x, tmax.x) * step(tmin.y, tmax.y) * step(tmin.z, tmax.z);\n    return vec2(t0, t1);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sp, float r) {\n    vec3 oc = ro - sp;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray cylinder intersection\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cylPos, vec3 cylDir, float cylRad) {\n    vec3 oc = ro - cylPos;\n    vec3 h = cross(rd, cylDir);\n    float a = dot(h, h);\n    float b = 2.0 * dot(oc, h);\n    float c = dot(oc, oc) - cylRad * cylRad;\n    float h2 = b * b - 4.0 * a * c;\n    if (h2 < 0.0) return vec2(-1.0);\n    h2 = sqrt(h2);\n    float t = (-b - h2) / (2.0 * a);\n    if (t > 0.0) {\n        vec3 p = ro + t * rd;\n        vec3 q = p -", "\n\te1 = vec2(p.x, p.y - d.y);\n\te2 = vec2(p.x + d.x, p.y);\n\te3 = vec2(p.x, p.y + d.y);\n\te4 = vec2(p.x - d.x, p.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n\te1 = vec2(p.x, p.y - d.y);\n\te2 = vec2(p.x + d.x, p.y);\n\te3 = vec2(p.x, p.y + d.y);\n\te4 = vec2(p.x - d.x, p.y);\n\te5 = vec2(p.x - d.x, p.y - d.y);\n\te6 = vec2(p.x + d.x, p.y + d.y);\n\te7 = vec2(p.x + d.x, p.y - d.y);\n\te8 = vec2(p.x - d.x, p.y + d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8, inout vec2 e9, inout vec2 e10, inout vec2 e11, inout vec2 e12, inout vec2 e13, inout vec2 e1", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n\treturn linedist(p, a, b) - 0.005;\n}\n\nfloat box(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n\treturn box(p, b) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f) {\n\treturn box(p, b, r) - f;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f, float t) {\n\treturn box(p, b, r, f) - t;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f, float t, float s) {\n\treturn box(p, b, r, f, t) - s;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f, float t, float s, float q) {\n\treturn box(p, b, r, f, t, s) - q;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f, float t, float s, float q, float w) {\n\treturn box(p, b, r, f, t, s, q) - w;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f, float t, float s, float q, float w, float e) {\n\treturn box(p, b, r, f, t, s, q, w) - e;\n}\n\nfloat box(vec2 p, vec2 b, float r, float f, float t, float s,", "\n\tfloat d = sdSegment( p, a, b );\n\tfloat d1 = sdSegment( p, a, b - normalize(b-a)*w1 );\n\tfloat d2 = sdSegment( p, a, b - normalize(b-a)*w1 - normalize(b-a)*w2 );\n\treturn min( d, min( d1, d2 ) );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec3 p, vec3 a, vec3 b, float w1, float w2 )\n{\n\tfloat d = sdSegment( p, a, b );\n\tfloat d1 = sdSegment( p, a, b - normalize(b-a)*w1 );\n\tfloat d2 = sdSegment( p, a, b - normalize(b-a)*w1 - normalize(b-a)*w2 );\n\treturn min( d, min( d1, d2 ) );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec4 p, vec4 a, vec4 b, float w1, float w2 )\n{\n\tfloat d = sdSegment( p, a, b );\n\tfloat d1 = sdSegment( p, a, b - normalize(b-a)*w1 );\n\tfloat d2 = sdSegment( p, a, b - normalize(b-a)*w1 - normalize(b-a)*w2 );\n\treturn min( d, min( d1, d2 ) );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float r )\n{\n\tfloat d = sdSegment( p, a, b );\n\tfloat d1 = sdSegment( p, a, b - normalize(b-a)*w1 );\n\tfloat d2 = sdSegment( p, a, b - normalize(b-a)*w1 - normalize(b-a)*w2 );", "\n    vec3 q = vec3(length(ro.xz)-tor.x,ro.y,length(ro.xz)-tor.y);\n    float a = dot(rd,rd);\n    float b = 2.0*dot(rd,q);\n    float c = dot(q,q) - tor.x*tor.y;\n    float h = b*b-4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-b-h)/(2.0*a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCylinder( vec3 ro, vec3 rd, vec2 h )\n{\n    vec3 q = vec3( length(ro.xz), ro.y, 0.0 );\n    float a = dot(rd,rd);\n    float b = 2.0*dot(rd,q);\n    float c = dot(q,q) - h.x*h.x;\n    float h = b*b-4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-b-h)/(2.0*a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCone( vec3 ro, vec3 rd, vec2 h )\n{\n    vec3 q = vec3( length(ro.xz), ro.y, 0.0 );\n    float a = dot(rd,rd);\n    float b = 2.0*dot(rd,q);\n    float c = dot(q,q) - h.x*h.x;\n    float h = b*b-4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-b+h)/(2.0*a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iqu", "\n    vec3 q = vec3(length(pos.xz)-tor.x, pos.y, 0.0);\n    return normalize(vec3(-pos.x, pos.y, -pos.z));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torus(vec3 pos, vec2 tor) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 boxNormal(vec3 pos, vec3 b) {\n    vec3 d = vec3(0.0);\n    if(pos.x < -b.x) d.x = pos.x+b.x;\n    if(pos.x >  b.x) d.x = pos.x-b.x;\n    if(pos.y < -b.y) d.y = pos.y+b.y;\n    if(pos.y >  b.y) d.y = pos.y-b.y;\n    if(pos.z < -b.z) d.z = pos.z+b.z;\n    if(pos.z >  b.z) d.z = pos.z-b.z;\n    return normalize(d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat box(vec3 pos, vec3 b) {\n    vec3 d = abs(pos) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 sphereNormal(vec3 pos, float r) {", "\n\tfloat x2 = x * x;\n\treturn x * (1.0f - x2 * (0.000127323954f + x2 * (0.0000015707963267948966f + x2 * (0.00000000288818359375f + x2 * 0.00000000000248015873015873015873f))));\n}\n\n// License: Public Domain, author: <NAME>, found: https://github.com/nothings/stb/blob/master/stb_image.h\nint stbi_info_from_memory(const unsigned char *buffer, int len, int *x, int *y, int *comp) {\n\tint i, j, s;\n\tunsigned char *marker;\n\tif (len < 2 || buffer[0]!= 'M' || buffer[1]!= 'M') return 0;\n\tif (buffer[2]!= 0 || buffer[3]!= 42) return 0;\n\tif (len < 8 + 4) return 0;\n\tif (buffer[8]!= 0 || buffer[9]!= 0 || buffer[10]!= 0 || buffer[11]!= 4) return 0;\n\t*x = buffer[20] + buffer[21] * 256;\n\t*y = buffer[22] + buffer[23] * 256;\n\tif (buffer[24]!= 1) return 0;\n\t*comp = buffer[25];\n\tif (buffer[26]!= 0 || buffer[27]!= 0 || buffer[28]!= 0 || buffer[29]!= 0) return 0;\n\tif (buffer[30]!= 0 || buffer[31]!= 0) return 0;\n\tmarker = (unsigned char *)memchr(buffer, 0xff, len);\n\tif (!marker) return 0;\n\t", "\n    // col = pow(col, vec3(0.4545));\n    // col = pow(col, vec3(0.45));\n    // col = pow(col, vec3(0.454545));\n    // col = pow(col, vec3(0.45454545));\n    // col = pow(col, vec3(0.4545454545));\n    // col = pow(col, vec3(0.454545454545));\n    // col = pow(col, vec3(0.45454545454545));\n    // col = pow(col, vec3(0.4545454545454545));\n    // col = pow(col, vec3(0.454545454545454545));\n    // col = pow(col, vec3(0.45454545454545454545));\n    // col = pow(col, vec3(0.4545454545454545454545));\n    // col = pow(col, vec3(0.454545454545454545454545));\n    // col = pow(col, vec3(0.45454545454545454545454545));\n    // col = pow(col, vec3(0.4545454545454545454545454545));\n    // col = pow(col, vec3(0.454545454545454545454545454545));\n    // col = pow(col, vec3(0.45454545454545454545454545454545));\n    // col = pow(col, vec3(0.454", "\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p, size) - size * 0.5;\n    return c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 d = vec2(max(q.x - c.x, q.y), max(q.y - c.y, 0.0));\n    return length(d) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\n\nfloat", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n\n    // 4 octaves\n    for (int i = 0; i < 4; i++) {\n        v += a * noise(uv);\n        uv = uv * 2.0 + shift;\n        a *= 0.5;\n    }\n\n    return v;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    float v = fbm(uv * 10.0);\n    v = smoothstep(0.0, 1.0, v);\n\n    gl_FragColor = vec4(vec3(v), 1.0);\n}\n", "\n    return length(p-c)-r;\n}\n\n// signed distance to a rectangle\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p);\n    return sdRectangle(q-b, vec2(max(b.x-r,0.0), max(b.y-r,0.0))) +\n           max(max(q.x,q.y) - max(b.x,b.y), 0.0);\n}\n\n// signed distance to a polygon\nfloat sdPolygon( in vec2 p, in vec2[] vertices, in int n )\n{\n    float d = 1e38;\n    for( int i = 0; i < n; i++ )\n    {\n        vec2 a = vertices[i];\n        vec2 b = vertices[(i+1)%n];\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        vec2 pb = pa - ba*h;\n        d = min(d, length(pb));\n    }\n    return d;\n}\n\n// signed distance to a star\nfloat sdStar( in vec2 p, in float r, in float ra, in float rb )\n{\n    float k = 0.809016994;\n    float c = cos(radians(30.0));\n    float s = sin(radians(30.0));\n    p.x = abs(p.x); p.y = abs(p.y);\n    vec2 q = vec2(c*p.x-s*p.y, s*p.x+c*p.y);\n    return sdPolygon( q, vec2[]( vec2(r,0.0), vec2(ra,rb), vec2(rb,ra) ), 3 );\n}\n", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// distance to a circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// distance to a rectangle\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to a rounded rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in float r )\n{\n    b = max(b,vec2(2.0*r));\n    return sdRectangle(p,b-vec2(2.0*r))-r;\n}\n\n// distance to a polygon\nfloat sdPolygon( in vec2 p, in vec2[] vertices, in int n )\n{\n    float d = 1e38;\n    for( int i = 0; i < n; i++ )\n    {\n        vec2 a = vertices[i];\n        vec2 b = vertices[(i+1)%n];\n        d = min( d, sdSegment( p, a, b ) );\n    }\n    return d;\n}\n\n// distance to a star\nfloat sdStar( in vec2 p, in float r, in float ra, in float rb )\n{\n    float k = 0.5625;\n    p.x = abs(p.x); p.y = abs(p.y) * k;\n    return sdSegment( p, vec2(-r,0.0), vec2(r,0.0) ) - ra;\n}\n\n// distance to a star\nfloat sdStar( in vec2 p, in float r, in float ra, in float rb, in float rc, in float rd )\n{\n    float k = 0.5625;\n    p.x = abs(p.x); p.y = abs(p.y) * k;\n    return sdSegment( p,", " return a.x*b.y - a.y*b.x; }\nfloat tri(in vec2 a, in vec2 b, in vec2 c, in vec2 p) {\n\tvec2 v0 = b-a, v1 = c-a, v2 = p-a;\n\tfloat d00 = dot(v0,v0);\n\tfloat d01 = dot(v0,v1);\n\tfloat d11 = dot(v1,v1);\n\tfloat d20 = dot(v2,v0);\n\tfloat d21 = dot(v2,v1);\n\tfloat denom = d00*d11 - d01*d01;\n\tfloat v = (d11*d20 - d01*d21)/denom;\n\tfloat w = (d00*d21 - d01*d20)/denom;\n\tfloat u = 1.0-v-w;\n\treturn sign(cro(v0,v1))*sqrt(max(d20*d20*d11, max(d21*d21*d00, d20*d20*d01)));\n}\n\n// signed distance to a 3D triangle\nfloat tri(in vec3 a, in vec3 b, in vec3 c, in vec3 p) {\n\tvec3 v0 = b-a, v1 = c-a, v2 = p-a;\n\tfloat d00 = dot(v0,v0);\n\tfloat d01 = dot(v0,v1);\n\tfloat d11 = dot(v1,v1);\n\tfloat d20 = dot(v2,v0);\n\tfloat d21 = dot(v2,v1);\n\tfloat denom = d00*d11 - d01*d01;\n\tfloat v = (d11*d20 - d01*d21)/denom;\n\tfloat w = (d00*d21 - d01*d20)/denom;\n\tfloat u = 1.0-v-w;\n\treturn sign(cro(v0,", "\n    vec2 q = abs(p);\n    return max(q.x,q.y)-clamp(max(q.x,q.y)-min(q.x,q.y),0.0,r)-s;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRectangle( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b+r;\n    return length(max(q,0.0))-clamp(min(max(q.x,q.y),0.0),-r,0.0);\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundOctagon( in vec2 p, in float s, in float r ) \n{\n    p = abs(p);\n    p -= s;\n    vec2 q = max(p,0.0);\n    return length(q)+min(max(q.x,q.y),0.0)-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundTriangle( in vec2 p, in float s, in float r ) \n{\n    p = abs(p);\n    p -= s;\n    vec2 q = max(p,0.0);\n    return length(q)+min(max(q.x,q.y),0.0)-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundPentagon( in vec2 p, in float s, in float r ) \n{\n    p = abs(p);\n    p -= s;\n    vec2 q = max(p,0.0);\n    return length(q)+min(max(q.x,q.y),0.0)-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundHexagon( in vec2 p, in float s, in float r ) \n{\n    p = abs(p);\n    p -= s;\n    vec2 q = max(p,0.0);\n    return length(q)+min(max(q.x,q.y),0.0)-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundHeptagon( in", "\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_inv(vec3 x)\n{\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn saturate((x*(c*x+d))/(x*(a*x+b)+e));\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_inv_deriv(vec3 x)\n{\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn saturate((a*x+b)/(x*(c*x+d)+e) + (c*x+d)/(x*(a*x+b)+e)*(-a*x*x/(x*(c*x+d)+e) + c*x*x/(x*(a*x+b)+e)));\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to different", "\n\treturn 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n\treturn 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n\treturn 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n\treturn 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n\treturn 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n\treturn 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n\treturn 3.0 * x * (1.0 - x);\n}\n", "\n\tfloat a = atan( p.x, p.y ) / ( 2.0 * PI );\n\tfloat r = length(p) * 2.0;\n\treturn cos( a * k ) * r - w;\n}\n\n// 2D Spiral\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float a )\n{\n\tfloat r = length(p) * 2.0;\n\treturn cos( a * k ) * r - w;\n}\n\n// 2D Spiral\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float a, in float b )\n{\n\tfloat r = length(p) * 2.0;\n\treturn cos( a * k ) * r - w * cos( b * k );\n}\n\n// 2D Spiral\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float a, in float b, in float c )\n{\n\tfloat r = length(p) * 2.0;\n\treturn cos( a * k ) * r - w * cos( b * k ) * cos( c * k );\n}\n\n// 2D Spiral\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float a, in float b, in float c, in float d )\n{\n\tfloat r = length(p) * 2.0;\n\treturn cos( a * k ) * r - w * cos( b * k ) * cos( c * k ) * cos( d * k );\n}\n\n// 2D Spiral\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float a, in float b, in float c", "\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g)\n{\n\treturn exp(-opticalDepth * g);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g)\n{\n\treturn exp(-opticalDepth * g);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, float g_scale)\n{\n\treturn exp(-opticalDepth * g * g_scale);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g_scale)\n{\n\treturn exp(-opticalDepth * g * g_scale);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g_scale, float g_bias)\n{\n\treturn exp(-opticalDepth * g * g_scale + g_bias);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g_scale, vec3 g_bias)\n{\n\treturn exp(-opticalDepth * g * g_scale + g_bias);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g_scale, vec3 g_bias, float g_power)\n{\n\treturn exp(-pow(opticalDepth * g * g_scale + g_bias, g_power));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g_scale, vec3 g_bias, vec3 g_power)\n{\n\treturn exp(-pow(opticalDepth * g * g_scale + g_bias, g_power));\n}\n\n// Calculate a luminance transmittance value from optical", "\n\tvec3 scattering = vec3(0.0);\n\tvec3 attenuation = vec3(1.0);\n\tvec3 transmittanceAccum = vec3(1.0);\n\tvec3 transmittanceAccumPrev = vec3(1.0);\n\tfloat stepSize = rayLength / float(SCATTERING_STEPS);\n\tfloat stepSizePrev = 0.0;\n\tfloat stepSizeAccum = 0.0;\n\tfloat stepSizeAccumPrev = 0.0;\n\tfloat stepSizeAccumPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat stepSizeAccumPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev", "\n\tfloat r = ra + rb;\n\tfloat h = length(p2) - d;\n\treturn length(max(vec2(h,rb),vec2(0.0))) - r;\n}\n\n// 3D Death Star\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar3D( in vec3 p2, in float ra, float rb, in float d )\n{\n\tfloat r = ra + rb;\n\tfloat h = length(p2) - d;\n\treturn length(max(vec3(h,rb,rb),vec3(0.0))) - r;\n}\n\n// 3D Death Star\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar3D( in vec3 p2, in float ra, float rb, in float d, in float t )\n{\n\tfloat r = ra + rb;\n\tfloat h = length(p2) - d;\n\treturn length(max(vec3(h,rb,rb),vec3(0.0))) - r*t;\n}\n\n// 3D Death Star\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar3D( in vec3 p2, in float ra, float rb, in float d, in float t, in float s )\n{\n\tfloat r = ra + rb;\n\tfloat h = length(p2) - d;\n\treturn length(max(vec3(h,rb,rb),vec3(0.0))) - r*t*s;\n}\n\n// 3D Death Star\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar3D( in vec3 p2, in float ra, float rb, in float d, in float t, in float s, in float p )\n{\n\tfloat r = ra + rb;\n\tfloat h = length(p2) - d;\n\treturn length(max(vec3(", "\n    float d1 = sdSphere( p, r );\n    float d2 = sdSphere( p, r-t );\n    return max( d1, -d2 );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSphere( vec3 p, float r, float h, float t )\n{\n    float d1 = sdSphere( p, r );\n    float d2 = sdSphere( p, r-t );\n    return max( d1, d2 );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCylinder( vec3 p, float r, float h, float t )\n{\n    float d1 = sdCylinder( p, r );\n    float d2 = sdCylinder( p, r-t );\n    return max( d1, -d2 );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutCylinder( vec3 p, float r, float h, float t )\n{\n    float d1 = sdCylinder( p, r );\n    float d2 = sdCylinder( p, r-t );\n    return max( d1, d2 );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCone( vec3 p, float r, float h, float t )\n{\n    float d1 = sdCone( p, r );\n    float d2 = sdCone( p, r-t );\n    return max( d1, -d2 );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutCone( vec3 p, float r, float h, float t )\n{\n    float d1 = sdCone( p, r );\n    float d2 = sdCone( p, r-t );\n    return max( d1, d2 );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowTorus( vec3 p, float r, float h, float t )", "\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<50; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\t\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat calcSoftAO( in vec3 pos, in vec3 nor, const float aa )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -(dd-hr)*(0.5+0.5*pow(clamp(1.0-aa+2.0*hr,0.0,1.0),5.0))*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0", "\n    float d1 = sdSphere( p, r );\n    float d2 = sdPlane( p, vec4( 0.0, 1.0, 0.0, h ) );\n    return max( d1, -d2 );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec4 h )\n{\n    float d1 = sdSphere( p, r );\n    float d2 = sdPlane( p, h );\n    return max( d1, -d2 );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 n, in float h )\n{\n    float d1 = sdSphere( p, r );\n    float d2 = sdPlane( p, n, h );\n    return max( d1, -d2 );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 n, in vec3 h )\n{\n    float d1 = sdSphere( p, r );\n    float d2 = sdPlane( p, n, h );\n    return max( d1, -d2 );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 n, in vec4 h )\n{\n    float d1 = sdSphere( p, r );\n    float d2 = sdPlane( p, n, h );\n    return max( d1, -d2 );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec4 n, in float h )\n{\n    float d1 = sdSphere( p, r );\n    float d2 = sdPlane( p, n, h );\n    return max( d1, -d2 );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec4 n, in vec3 h )\n{\n    float d1 = sdSphere( p, r );", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// https://www.shader", "\n    float d1 = length(p)-r;\n    float d2 = abs(p.y)-h;\n    return max(d1,d2);\n}\n\n// r=radius, h=height\nfloat sdCutCylinder( in vec3 p, in float r, in float h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec3 p, in float r, in float h )\n{\n    vec2 q = vec2( length(p.xz), abs(p.y) );\n    float d1 = q.x - r;\n    float d2 = q.y - h;\n    return max(d1,d2);\n}\n\n// r=radius, h=height\nfloat sdCutTorus( in vec3 p, in float r, in float h )\n{\n    vec2 q = vec2( length(p.xz)-r, abs(p.y)-h );\n    return length(q) + min(max(q.x,q.y),0.0);\n}\n\n// r=radius, h=height\nfloat sdCutPrism( in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n// r=radius, h=height\nfloat sdCutPyramid( in vec3 p, in vec2 h )\n{\n    float d1 = -p.y-h.y;\n    float d2 = p.z-h.x;\n    float d3 = p.x-h.x;\n    float d4 = p.y-h.y;\n    float d5 = p.z-h.y;\n    float d6 = p.x-h.y;\n    return max(max(d1,d2),max(d3,max(d4,max(d5,", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// 3d noise function\nfloat noise( in vec3 x, in float time )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, time ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// 3d noise function\nfloat noise( in vec3 x, in vec3 p )\n{\n    vec3 pi = floor(x);\n    vec3 pf = fract(x);\n\tpf = pf*pf*(3.0-2.0*pf);\n\t\n\tvec2 uv = (pi.xy+vec2(37.0,17.0)*pi.z) + pf.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, pf.z ) + dot(pi,p);\n}\n\n// 3d noise function\nfloat noise( in vec3 x, in vec3 p, in float time )\n{\n    vec3 pi = floor(x);\n    vec3 pf = fract(x);\n\tpf = pf*pf*(3.0-2.0*pf);\n\t\n\tvec2 uv = (pi.xy+vec2(37.0,1", "\n\tfloat f = 0.0;\n\tf += 0.5000*noise( p ); p = m*p*2.02;\n\tf += 0.2500*noise( p ); p = m*p*2.03;\n\tf += 0.1250*noise( p ); p = m*p*2.01;\n\tf += 0.0625*noise( p );\n\treturn f/0.9375;\n}\n\n// 3d simplex noise\nfloat snoise( vec3 p )\n{\n\tconst float F3 = 1.0/3.0;\n\tconst float G3 = 1.0/6.0;\n\tfloat s = (p.x + p.y + p.z)*F3;\n\tint i = floor(p.x + s);\n\tint j = floor(p.y + s);\n\tint k = floor(p.z + s);\n\tvec3 g = vec3(p.x - i + s, p.y - j + s, p.z - k + s);\n\tvec3 o = vec3(float(i), float(j), float(k));\n\tvec3 r = g - (g.x >= g.y && g.x >= g.z) * vec3(1.0, 0.0, 0.0) +\n\t\t(g.y >= g.z) * vec3(0.0, 1.0, 0.0) +\n\t\t(g.z >= g.x) * vec3(0.0, 0.0, 1.0);\n\tg = g*g*(3.0 - 2.0*g);\n\tvec3 h = abs(r) - 0.5;\n\tvec3 a0 = r.x >= 0.0? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0);\n\tvec3 a1 = r.y >= 0.0? vec3(0.0, 1.0, 0.0) : vec3", "\n\tp3  = fract(p3 * vec3(.1031,.1030,.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise\nfloat noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash31(n+  0.0), hash31(n+  1.0),f.x),\n\t\t\t\t\tmix( hash31(n+ 57.0), hash31(n+ 58.0),f.x),f.y),\n\t\t\t\tmix(mix( hash31(n+113.0), hash31(n+114.0),f.x),\n\t\t\t\t\tmix( hash31(n+170.0), hash31(n+171.0),f.x),f.y),f.z);\n}\n\n//value noise\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0;\n\t\n\treturn mix(mix( hash31(n+  0.0), hash31(n+  1.0),f.x),\n\t\t\t\tmix( hash31(n+ 57.0), hash31(n+ 58.0),f.x),f.y);\n}\n\n//value noise\nfloat noise(float x)\n{\n\treturn hash31(floor(x));\n}\n\n//value noise\nfloat noise(vec2 x, float scale)\n{\n\treturn noise(x*scale);\n}\n\n//value", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Get the color of the pixel\n    color = texture(iChannel0, uv).rgb;\n\n    // Apply the color correction\n    color = color * iChannel1.rgb;\n\n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}\n```", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n```", "\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// 3D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p - i) * a) * (-.5) +.5;\n    a = abs(f);\n    i = mod(i, 289.);\n    vec4 k = mod(i * (.142857142857), 12.);\n    vec4 h = k.z * k.z + f.z;\n    k = k * k + f.x * f.x;\n    return 57.0 * dot(k, -1.) - 20.0 * dot(k, f.y * f.y) - 20.0 * h * f.x;\n}\n\n// 3D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 p, float time) {\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p - i) * a) * (-.5) +.5;\n    a = abs(f);\n    i = mod(i, 289.);\n    vec4 k = mod(i * (.142857142857), 12.);\n    vec4 h = k.z * k.z + f.z;\n    k = k * k + f.x * f.x;\n    return 57.0 * dot(k, -1.) - 20.", "\n    return fract(sin(co) * 43758.5453123);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + i.y * 57.0 + 1.0);\n    float c = hash(i.x + 1.0 + i.y * 57.0);\n    float d = hash(i.x + 1.0 + i.y * 57.0 + 1.0);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec2 p, float octaves) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n   ", " return t <= 0.0031308? 12.92 * t : 1.055 * pow(t, 0.41666) - 0.055; }\nvec3 sRGB(vec3 t) { return vec3(sRGB(t.x), sRGB(t.y), sRGB(t.z)); }\n\n// https://www.shadertoy.com/view/4s23zN\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = 2.02 * p;\n    f += 0.2500 * noise(p); p = 2.03 * p;\n    f += 0.1250 * noise(p); p = 2.01 * p;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p, float octaves) {\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise(p)); p = 2.02 * p;\n    for (int i = 1; i < int(octaves); i++) {\n        f += 0.500", " return pow(c, vec3(1.0/2.2)); }\nvec3 sRGB(in vec3 c, in float gamma) { return pow(c, vec3(1.0/gamma)); }\nvec3 sRGB(in vec3 c, in vec3 gamma) { return pow(c, vec3(1.0/gamma)); }\nvec3 sRGB(in vec3 c, in float gamma, in float exposure) { return pow(c, vec3(1.0/gamma)) * exposure; }\nvec3 sRGB(in vec3 c, in vec3 gamma, in vec3 exposure) { return pow(c, vec3(1.0/gamma)) * exposure; }\n\n// Gamma correction\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 gamma(in vec3 c, in float gamma) { return pow(c, vec3(gamma)); }\nvec3 gamma(in vec3 c, in vec3 gamma) { return pow(c, gamma); }\n\n// Gamma correction\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 gamma(in vec3 c, in float gamma, in float exposure) { return pow(c, vec3(gamma)) * exposure; }\nvec3 gamma(in vec3 c, in vec3 gamma, in vec3 exposure) { return pow(c, gamma) * exposure; }\n\n// Gamma correction\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 gamma(in vec3 c, in float gamma, in float exposure, in float gammaCorrection) { return pow(c, vec3(gamma)) * exposure * gammaCorrection; }\nvec3 gamma(in vec3 c, in vec3 gamma, in vec3 exposure, in vec3 gammaCorrection) { return pow(c, gamma) * exposure * gammaCorrection; }\n\n// Gamma correction\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\n", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a, b, h) + k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a, b, h) + k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat opU(float d1, float d2) {\n    return min(d1,d2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat opS(float d1, float d2) {\n    return max(-d1,d2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat opB(float d1, float d2)", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h - dbuffer;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereNormal(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec3(0.0);\n    h = sqrt(h);\n    return normalize(ro + rd * (b + h) - sph.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereNormal(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec3(0.0);\n    h = sqrt(h);\n    return normalize(ro + rd * (b + h", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    p.w = abs(p.w);\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;\n    p.x = p.x + p.y;\n    p.y = p.y + p.z;\n    p.z = p.z + p.w;\n    p.w = p.w + p.x;", "\n    vec3 q = p / r;\n    float d = dot( q, q );\n    float f = d - 1.0;\n    vec3 g = f * q;\n    float h = dot( g, g );\n    float i = sqrt( h );\n    return vec4( f, g.x / i, g.y / i, g.z / i );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, vec2 r )\n{\n    vec2 q = vec2( length( p.xz ) - r.x, p.y );\n    float f = length( q ) - r.y;\n    vec3 g = f * normalize( vec3( q, 0.0 ) );\n    float h = length( g );\n    return vec4( f, g.x / h, g.y / h, g.z / h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec2 r )\n{\n    float f = length( p.xz ) - r.x;\n    vec3 g = f * normalize( vec3( p.xz, 0.0 ) );\n    float h = length( g );\n    return vec4( f, g.x / h, g.y / h, g.z / h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)", "\n\treturn mix(back, front, front.a);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4s23zN\nvec4 blendOverlay(vec4 back, vec4 front) {\n\treturn mix(back, back * (1.0 - 2.0 * (1.0 - front.a) * (1.0 - back.a)), front.a);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4s23zN\nvec4 blendSoftLight(vec4 back, vec4 front) {\n\treturn mix(back, back * (1.0 - 2.0 * (1.0 - front.a) * (1.0 - back.a)) + 2.0 * front.a * front.rgb * back.a, front.a);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4s23zN\nvec4 blendHardLight(vec4 back, vec4 front) {\n\treturn mix(back, back * (1.0 - 2.0 * (1.0 - front.a) * (1.0 - back.a)) + 2.0 * front.a * front.rgb * (1.0 - back.a), front.a);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4s23zN\nvec4 blendVividLight(vec4 back, vec4 front) {\n\treturn mix(back, back * (1.0 - 2.0 * (1.0 - front.a) * (1.0 - back.a)) + 2.0 * front.a * front.rgb * (1.0 - back.a), front.a);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4s23zN\nvec4 blendLinearLight(vec4 back, vec4 front) {\n\treturn mix(back, back * (1.0 - 2.0 * (1", "\n    return mix(back, front.rgb, front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return mix(back, front, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha) {\n    return mix(back, front, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha) {\n    return mix(back, front, alpha.rgb);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, vec3 alpha) {\n    return mix(back, front.rgb, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, vec4 alpha) {\n    return mix(back, front.rgb, alpha.rgb);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec3 front) {\n    return mix(back.rgb, front, back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec3 front, float alpha) {\n    return mix(back.rgb, front, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec3 front, vec3 alpha) {\n    return mix(back.rgb, front, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec3 front, vec4 alpha) {\n    return mix(back.rgb, front, alpha.rgb);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec4 front) {\n    return mix(back.rgb, front.rgb, back.a);\n}\n\n// License: Unknown, author: Unknown", "\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p,0.0))-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float q ) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p,0.0))-r-q;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float q, float s ) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p,0.0))-r-q-s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float q, float s, float t ) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p,0.0))-r-q-s-t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float q, float s, float t, float u ) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p,0.0))-r-q-s-t-u;\n}\n\n// License: MIT, author: Inigo Qu", "\n\tconst mat3 m = mat3(\n\t\tvec3(0.59719, 0.07600, 0.02840),\n\t\tvec3(0.35458, 0.90834, 0.13383),\n\t\tvec3(0.04823, 0.01566, 0.83777)\n\t);\n\tconst vec3 a = vec3(0.15, 0.15, 0.15);\n\tconst vec3 b = vec3(0.50, 0.50, 0.50);\n\tconst vec3 c = vec3(0.02, 0.02, 0.02);\n\tconst vec3 d = vec3(0.30, 0.30, 0.30);\n\tconst vec3 e = vec3(0.10, 0.10, 0.10);\n\tconst vec3 f = vec3(0.20, 0.20, 0.20);\n\treturn m * (v * (a * v + c * b) + d * e) / (v * (a * v + b) + d * f) - e / f;\n}\n\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 aces_approx_inverse(vec3 v) {\n\tconst mat3 m = mat3(\n\t\tvec3(1.60475, -0.10208, -0.00327),\n\t\tvec3(-0.53108, 1.10813, -0.07276),\n\t\tvec3(-0.07367, -0.00605, 1.07602)\n\t);\n\tconst vec3 a = vec3(0.60935, 0.08616, 0.01020);\n\tconst vec3 b = vec3(0.2", "\n\tp = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// License: MIT License, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat noise(in vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash2(i);\n\tfloat b = hash2(i + vec2(1.0, 0.0));\n\tfloat c = hash2(i + vec2(0.0, 1.0));\n\tfloat d = hash2(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT License, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(p); p = 2.02 * p;\n\tf += 0.2500 * noise(p); p = 2.03 * p;\n\tf += 0.1250 * noise(p); p = 2.01 * p;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\n// License: MIT License, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p, float scale) {\n\tfloat f", "\n\tfloat T = Temp;\n\tfloat T2 = T * T;\n\tfloat T3 = T2 * T;\n\tfloat T4 = T3 * T;\n\tfloat T5 = T4 * T;\n\tfloat T6 = T5 * T;\n\tfloat T7 = T6 * T;\n\tfloat T8 = T7 * T;\n\tfloat T9 = T8 * T;\n\tfloat T10 = T9 * T;\n\tfloat T11 = T10 * T;\n\tfloat T12 = T11 * T;\n\tfloat T13 = T12 * T;\n\tfloat T14 = T13 * T;\n\tfloat T15 = T14 * T;\n\tfloat T16 = T15 * T;\n\tfloat T17 = T16 * T;\n\tfloat T18 = T17 * T;\n\tfloat T19 = T18 * T;\n\tfloat T20 = T19 * T;\n\tfloat T21 = T20 * T;\n\tfloat T22 = T21 * T;\n\tfloat T23 = T22 * T;\n\tfloat T24 = T23 * T;\n\tfloat T25 = T24 * T;\n\tfloat T26 = T25 * T;\n\tfloat T27 = T26 * T;\n\tfloat T28 = T27 * T;\n\tfloat T29 = T28 * T;\n\tfloat T30 = T29 * T;\n\tfloat T31 = T30 * T;\n\tfloat T32 = T31 * T;\n\tfloat T33 = T32 * T;\n\tfloat T34 = T33 * T;\n\tfloat T35 = T34 * T;\n\tfloat T36 = T35 * T;\n\tfloat T37 = T36 * T;\n\tfloat T38 = T37 * T;\n\tfloat T39 = T38 * T;\n\tfloat T40 = T39 * T;\n\tfloat T41 = T40 * T;\n\tfloat", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(random2(i+vec2(0.0,0.0)), f - vec2(0.0,0.0)),\n                   dot(random2(i+vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n               mix(dot(random2(i+vec2(0.0,1.0)), f - vec2(0.0,1.0)),\n                   dot(random2(i+vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n}\n\n// 3D simplex noise\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec3 p) {\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d*d*(3.0-2.0*d);\n    vec2 uv = (a.xy+vec2(37.0,17.0)*a.z) + d.xy;\n    vec2 rg = random2(uv);\n    return mix(rg.x, rg.y, d.z);\n}\n\n// 2D simplex noise\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(random2(i+vec2(0.0,0.0)), f - vec2(0.0,0.0)),\n                   dot(random2(i+vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n               mix(dot(random2(i+vec2(0.0,1.0)),", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereNormal(vec3 ro, vec3 p) {\n    return normalize(p - ro);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphereSDF(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphereSDF(vec3 p, vec4 sph) {\n    return length(p - sph.xyz) - sph.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphereSDF(vec3 p, vec4 sph, float s) {\n    return length(p - sph.xyz) - sph.w - s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphereSDF(vec3 p, vec4 sph, float s, float r) {\n    return length(p - sph.xyz) - sph.w - s - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphereSDF(vec3 p", "\n    float r = length(p);\n    float d = r - n;\n    float s = 1.0 - n / r;\n    return vec3(d, s * p.x / r, s * p.y / r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r)\n{\n    float d = length(p) - n;\n    float s = 1.0 - n / r;\n    return vec3(d, s * p.x / r, s * p.y / r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r, float s)\n{\n    float d = length(p) - n;\n    float t = 1.0 - n / r;\n    return vec3(d, t * p.x / r, t * p.y / r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r, float s, float t)\n{\n    float d = length(p) - n;\n    return vec3(d, t * p.x / r, t * p.y / r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3", "\n\tfloat a = 0.0;\n\tfloat b = 1.0;\n\tfloat c = 0.5;\n\tfloat d = 0.5;\n\tfloat e = 0.5;\n\tfloat f = 0.5;\n\tfloat g = 0.5;\n\tfloat h = 0.5;\n\tfloat i = 0.5;\n\tfloat j = 0.5;\n\tfloat k = 0.5;\n\tfloat l = 0.5;\n\tfloat m = 0.5;\n\tfloat n = 0.5;\n\tfloat o = 0.5;\n\tfloat p = 0.5;\n\tfloat q = 0.5;\n\tfloat r = 0.5;\n\tfloat s = 0.5;\n\tfloat u = 0.5;\n\tfloat v = 0.5;\n\tfloat w = 0.5;\n\tfloat y = 0.5;\n\tfloat z = 0.5;\n\tfloat A = 0.5;\n\tfloat B = 0.5;\n\tfloat C = 0.5;\n\tfloat D = 0.5;\n\tfloat E = 0.5;\n\tfloat F = 0.5;\n\tfloat G = 0.5;\n\tfloat H = 0.5;\n\tfloat I = 0.5;\n\tfloat J = 0.5;\n\tfloat K = 0.5;\n\tfloat L = 0.5;\n\tfloat M = 0.5;\n\tfloat N = 0.5;\n\tfloat O = 0.5;\n\tfloat P = 0.5;\n\tfloat Q = 0.5;\n\tfloat R = 0.5;\n\tfloat S = 0.5;\n\tfloat U = 0.5;\n\tfloat V = 0.5;\n\tfloat W = 0.5;\n\tfloat Y = 0.5;\n\tfloat Z = 0.5;\n\tfloat a1 = 0.5;\n\tfloat b1 = 0.5;\n\tfloat c1 = 0.5", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon( in vec2 p, in vec2 h )\n{\n\tconst mat2 m = mat2( 0.866025403784439, 0.5, -0.5, 0.866025403784439 );\n\tp.x = abs(p.x); p.y += h.y*0.5;\n\tvec2 q = abs(p);\n\treturn max(q.y-h.y*0.5,dot(q-h.xy,m*q));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdStar( in vec2 p, in float r, in float ra, in float rb )\n{\n\treturn max(sdCircle(p,r),sdCircle(p,", "\n\tfloat d = 1e10;\n\tfor (int i = 0; i < 10; i++) {\n\t\tfloat t = float(i) / 10.0;\n\t\tvec3 p2 = p + t * vec3(0.0, 0.0, 1.0);\n\t\td = min(d, sdBox(p2, vec3(0.5, 0.5, 0.5)));\n\t}\n\treturn d;\n}\n\n// raymarching\nvec3 raymarch(in vec3 ro, in vec3 rd) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 p = ro + t * rd;\n\t\tfloat d = map(p, 0);\n\t\tif (d < 0.001) {\n\t\t\treturn p;\n\t\t}\n\t\tt += d;\n\t}\n\treturn vec3(0.0);\n}\n\n// main\nvoid main() {\n\tvec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, 1.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 col = raymarch(ro, rd);\n\tgl_FragColor = vec4(col, 1.0);\n}\n", "\n\tfloat a = abs(x);\n\tfloat b = abs(y);\n\tfloat m = max(a, b);\n\tfloat mi = min(a, b) / m;\n\tfloat r = m * 0.225 + (mi * (0.40909090 - mi * 0.16666666));\n\tr = r * r * r;\n\tr = r * r;\n\tr = r * r;\n\tfloat s = sign(x) * sign(y) * r;\n\treturn s;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(float y, float x) {\n\tfloat a = abs(x);\n\tfloat b = abs(y);\n\tfloat s = sign(x) * sign(y);\n\tfloat c, r;\n\tif (a > b) {\n\t\tc = b / a;\n\t\tr = a * 0.225 + c * (0.40909090 - c * 0.16666666);\n\t\tr = r * r * r;\n\t\tr = r * r;\n\t\tr = r * r;\n\t\tr = atan_approx(r, 1.0) * s;\n\t} else if (b > a) {\n\t\tc = a / b;\n\t\tr = b * 0.225 + c * (0.40909090 - c * 0.16666666);\n\t\tr = r * r * r;\n\t\tr = r * r;\n\t\tr = r * r;\n\t\tr = atan_approx(1.0, r) * s + 0.5 * PI;\n\t} else {\n\t\tr = a * 0.31830988618379067153776752674503;\n\t}\n\treturn r;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shader", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x*w.x + z.y*w.y, z.y*w.x - z.x*w.y) / dot(w, w);\n}\n\nvec2 cpow(vec2 z, float p) {\n    return exp(p * log(z));\n}\n\nvec2 csqrt(vec2 z) {\n    return exp(0.5 * log(z));\n}\n\nvec2 clog(vec2 z) {\n    return log(sqrt(dot(z, z))) + vec2(atan(z.y, z.x), 0.0);\n}\n\nvec2 cexp(vec2 z) {\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return cmul(cexp(z), vec2(0.0, 1.0));\n}\n\nvec2 ccos(vec2 z) {\n    return cmul(cexp(z), vec2(1.0, 0.0));\n}\n\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\n\nvec2 casinh(vec2 z) {\n    return clog(z + csqrt(z * z + 1.0));\n}\n\nvec2 cacosh(vec2 z) {\n    return log(z + csqrt(z * z - 1.0));\n}\n\nvec2 catanh(vec2 z) {\n    return 0.5 * clog((1.0 + z) / (1.0 - z));\n}\n\nvec2 catan(vec2 z) {\n    return 0.5 * clog((1.0 - cpow(z, 2.0)) / (1.0 + cpow(z, 2.0)));\n}\n\nvec2 csinh(vec2 z) {\n    return", "\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nfloat catanh(float z) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nfloat catanh(float z, float eps) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z, float eps) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z, float eps) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z, float eps) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nfloat catanh(float z, float eps, float eps2) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z, float eps, float eps2) {\n\treturn 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z, float eps, float eps2) {\n\treturn 0", "\n    vec2 w = exp(z);\n    return (w + 1.0 / w) / 2.0;\n}\n\nvec2 clog(vec2 z) {\n    vec2 w = sqrt(z * z - 1.0);\n    return log(z + w);\n}\n\nvec2 csinh(vec2 z) {\n    return (cexp(z) - cexp(-z)) / 2.0;\n}\n\nvec2 ccosh(vec2 z) {\n    return (cexp(z) + cexp(-z)) / 2.0;\n}\n\nvec2 ctanh(vec2 z) {\n    return csinh(z) / ccosh(z);\n}\n\nvec2 catanh(vec2 z) {\n    return clog((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\nvec2 csqrt(vec2 z) {\n    vec2 w = sqrt(z);\n    return (w + z / w) / 2.0;\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return exp(w * clog(z));\n}\n\nvec2 cpow(vec2 z, float w) {\n    return exp(w * clog(z));\n}\n\nvec2 cpow(float z, vec2 w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(float z, float w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(vec2 z, int w) {\n    return exp(w * clog(z));\n}\n\nvec2 cpow(int z, vec2 w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(int z, int w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(vec2 z, vec3 w) {\n    return exp(w.z * clog(z));\n}\n\nvec2 cpow(vec3 z, vec2 w) {\n    return exp(w.z * clog(vec2(", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x*w.x + z.y*w.y, z.y*w.x - z.x*w.y) / (w.x*w.x + w.y*w.y);\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return exp(w * log(z));\n}\n\nvec2 csqrt(vec2 z) {\n    return exp(0.5 * log(z));\n}\n\nvec2 clog(vec2 z) {\n    return log(sqrt(z.x*z.x + z.y*z.y)) + vec2(atan(z.y, z.x), 0.0);\n}\n\nvec2 cexp(vec2 z) {\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return cmul(cexp(z), vec2(0.0, 1.0));\n}\n\nvec2 ccos(vec2 z) {\n    return cmul(cexp(z), vec2(1.0, 0.0));\n}\n\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\n\nvec2 casinh(vec2 z) {\n    return clog(z + csqrt(z*z + 1.0));\n}\n\nvec2 cacosh(vec2 z) {\n    return clog(z + csqrt(z*z - 1.0));\n}\n\nvec2 catanh(vec2 z) {\n    return 0.5 * clog((1.0 + z) / (1.0 - z));\n}\n\nvec2 csinh(vec2 z) {\n    return cmul(casinh(z), vec2(0.0, 1.0));\n}\n\nvec2 ccosh(vec", "\n    vec2 w = exp(z);\n    return (w + 1.0 / w) / 2.0;\n}\n\nvec2 clog(vec2 z) {\n    vec2 w = sqrt(z * z - 1.0);\n    return log(z + w);\n}\n\nvec2 csinh(vec2 z) {\n    return (cexp(z) - cexp(-z)) / 2.0;\n}\n\nvec2 ccosh(vec2 z) {\n    return (cexp(z) + cexp(-z)) / 2.0;\n}\n\nvec2 ctanh(vec2 z) {\n    return csinh(z) / ccosh(z);\n}\n\nvec2 catanh(vec2 z) {\n    return clog((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\nvec2 csqrt(vec2 z) {\n    vec2 w = sqrt(z);\n    return (w + z / w) / 2.0;\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return exp(w * clog(z));\n}\n\nvec2 cpow(vec2 z, float w) {\n    return exp(w * clog(z));\n}\n\nvec2 cpow(float z, vec2 w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(float z, float w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(vec2 z, int w) {\n    return exp(w * clog(z));\n}\n\nvec2 cpow(int z, vec2 w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(int z, int w) {\n    return exp(w * clog(vec2(z)));\n}\n\nvec2 cpow(vec2 z, vec3 w) {\n    return exp(w.z * clog(z));\n}\n\nvec2 cpow(vec3 z, vec2 w) {\n    return exp(w.z * clog(vec2(", "\n    float alphaSum = alpha.r + alpha.g + alpha.b + alpha.a;\n    float alphaMean = alphaSum / 4.0;\n    float alphaSteep = alphaMean * contrast;\n    return vec4(alpha.rgb * alphaSteep, alphaSum);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float bias) {\n    float alphaSum = alpha.r + alpha.g + alpha.b + alpha.a;\n    float alphaMean = alphaSum / 4.0;\n    float alphaSteep = alphaMean * contrast + bias;\n    return vec4(alpha.rgb * alphaSteep, alphaSum);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float bias, float scale) {\n    float alphaSum = alpha.r + alpha.g + alpha.b + alpha.a;\n    float alphaMean = alphaSum / 4.0;\n    float alphaSteep = alphaMean * contrast + bias;\n    return vec4(alpha.rgb * alphaSteep * scale, alphaSum);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float bias, float scale, float power) {\n    float alphaSum = alpha.r + alpha.g + alpha.b + alpha.a;\n    float alphaMean = alphaSum / 4.0;\n    float alphaSteep = alphaMean * contrast + bias;\n    return vec4(pow(alpha.rgb * alphaSteep * scale, vec3(power)), alphaSum);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example", "\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 1.0;\n}\n\n//Distance from the Edge of Truncated Rhombic Dodecahedron\nfloat rhomTruncDist(vec3 p) {\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 0.5;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 0.86602540378443864676372317075294;\n}\n\n//Distance from the Edge of Truncated Icosahedron\nfloat icoTruncDist(vec3 p) {\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 0.525731112119133606;\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 1.0;\n}\n\n//Distance from the Edge of Truncated Octahedron\nfloat octaTruncDist(vec3 p) {\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 0.61803398874989484820458683436564;\n}\n\n//Distance from the Edge of Snub Cube\nfloat snubCubeDist(vec3 p) {\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - 1.0;\n}\n\n//Distance from the Edge of Truncated Snub Cube\nfloat snubCubeTruncDist(vec3 p) {\n\tp = abs(p);\n\treturn max(", "\n\ttilingVal3D t;\n\tt.uv = uvw;\n\tt.tile = 0;\n\tt.tileType = 0;\n\tt.tileType2 = 0;\n\tt.tileType3 = 0;\n\tt.tileType4 = 0;\n\tt.tileType5 = 0;\n\tt.tileType6 = 0;\n\tt.tileType7 = 0;\n\tt.tileType8 = 0;\n\tt.tileType9 = 0;\n\tt.tileType10 = 0;\n\tt.tileType11 = 0;\n\tt.tileType12 = 0;\n\tt.tileType13 = 0;\n\tt.tileType14 = 0;\n\tt.tileType15 = 0;\n\tt.tileType16 = 0;\n\tt.tileType17 = 0;\n\tt.tileType18 = 0;\n\tt.tileType19 = 0;\n\tt.tileType20 = 0;\n\tt.tileType21 = 0;\n\tt.tileType22 = 0;\n\tt.tileType23 = 0;\n\tt.tileType24 = 0;\n\tt.tileType25 = 0;\n\tt.tileType26 = 0;\n\tt.tileType27 = 0;\n\tt.tileType28 = 0;\n\tt.tileType29 = 0;\n\tt.tileType30 = 0;\n\tt.tileType31 = 0;\n\tt.tileType32 = 0;\n\tt.tileType33 = 0;\n\tt.tileType34 = 0;\n\tt.tileType35 = 0;\n\tt.tileType36 = 0;\n\tt.tileType37 = 0;\n\tt.tileType38 = 0;\n\tt.tileType39 = 0;\n\tt.tileType40 = 0;\n\tt.tileType41 = 0;\n\tt", "\n\tvec3 uvw2 = uvw - offset;\n\tfloat u = uvw2.x;\n\tfloat v = uvw2.y;\n\tfloat w = uvw2.z;\n\tfloat u2 = u * u;\n\tfloat v2 = v * v;\n\tfloat w2 = w * w;\n\tfloat uvw2Len = u2 + v2 + w2;\n\tfloat uvw2Len2 = uvw2Len * uvw2Len;\n\tfloat uvw2Len3 = uvw2Len2 * uvw2Len;\n\tfloat uvw2Len4 = uvw2Len3 * uvw2Len;\n\tfloat uvw2Len5 = uvw2Len4 * uvw2Len;\n\tfloat uvw2Len6 = uvw2Len5 * uvw2Len;\n\tfloat uvw2Len7 = uvw2Len6 * uvw2Len;\n\tfloat uvw2Len8 = uvw2Len7 * uvw2Len;\n\tfloat uvw2Len9 = uvw2Len8 * uvw2Len;\n\tfloat uvw2Len10 = uvw2Len9 * uvw2Len;\n\tfloat uvw2Len11 = uvw2Len10 * uvw2Len;\n\tfloat uvw2Len12 = uvw2Len11 * uvw2Len;\n\tfloat uvw2Len13 = uvw2Len12 * uvw2Len;\n\tfloat uvw2Len14 = uvw2Len13 * uvw2Len;\n\tfloat uvw2Len15 = uvw2Len14 * uvw2Len;\n\tfloat uvw2Len16 = uvw2Len15 * uvw2Len;\n\tfloat uvw2Len17 = uvw2Len16 * uvw2Len;\n\tfloat uvw2Len18 = uvw2Len17 * uvw2Len;\n\tfloat uvw2Len19 = uvw2Len18 * uvw2Len;\n\tfloat uvw2Len20 = uvw2Len19 * uvw2Len;\n\tfloat uvw2Len21 = uvw2Len20 * uvw", "\n    float gridSize = 1.0 / gridRes;\n    float gridOffset = 0.5 / gridRes;\n    float grid = 0.0;\n    float gridContrast = 1.0 - contrast;\n    for (float x = -gridOffset; x < 1.0 + gridOffset; x += gridSize) {\n        for (float y = -gridOffset; y < 1.0 + gridOffset; y += gridSize) {\n            float dist = distance(vec2(x, y), uvw.xy);\n            grid += smoothstep(gridSize - gridOffset, gridSize + gridOffset, dist);\n        }\n    }\n    return vec3(grid * gridContrast);\n}\n\n// 6 Cube tiles offset so their edges get hidden by each other\nvec3 cubeGrid(vec3 uvw, float gridRes, float contrast) {\n    float gridSize = 1.0 / gridRes;\n    float gridOffset = 0.5 / gridRes;\n    float grid = 0.0;\n    float gridContrast = 1.0 - contrast;\n    for (float x = -gridOffset; x < 1.0 + gridOffset; x += gridSize) {\n        for (float y = -gridOffset; y < 1.0 + gridOffset; y += gridSize) {\n            float dist = distance(vec2(x, y), uvw.xy);\n            grid += smoothstep(gridSize - gridOffset, gridSize + gridOffset, dist);\n        }\n    }\n    grid = 1.0 - grid;\n    for (float x = -gridOffset; x < 1.0 + gridOffset; x += gridSize) {\n        for (float y = -gridOffset; y < 1.0 + gridOffset; y += gridSize) {\n            float dist = distance(vec2(x, y), uvw.zy);\n            grid += smoothstep(gridSize - gridOffset, gridSize + gridOffset, dist);\n        }\n    }\n    grid = 1.0 - grid;\n    for (float x = -gridOffset; x < 1.0 + gridOffset; x += gridSize) {\n        for (float y = -gridOffset; y < 1.0 + gridOffset; y += gridSize) {\n            float dist = distance(vec2(x, y), uvw.xz", "\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - sqrt(3.0) * (p.x + p.y)) * 0.57735026918962576450914878050196;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r) {\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - sqrt(3.0) * (p.x + p.y)) * 0.57735026918962576450914878050196 - r;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float r2) {\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - sqrt(3.0) * (p.x + p.y)) * 0.57735026918962576450914878050196 - r - r2;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float r2, float r3) {\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - sqrt(3.0) * (p.x + p.y)) * 0.57735026918962576450914878050196 - r - r2 - r3;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float r2, float r3, float r4) {\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - sqrt(3.0) * (p.x + p.y)) * 0.57735026918962576", "\n\tvec3 c = vec3(0.0);\n\tc.r = 1.0 - t;\n\tc.g = 1.0 - t * t;\n\tc.b = 1.0 - t * t * t;\n\treturn c;\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n\tvec3 c = vec3(0.0);\n\tc.r = 1.0 - t * t * t;\n\tc.g = 1.0 - t * t;\n\tc.b = 1.0 - t;\n\treturn c;\n}\n\n// makes Rainbow colormap with polynimal 6\nvec3 Rainbow(float t) {\n\tvec3 c = vec3(0.0);\n\tc.r = 1.0 - t * t * t;\n\tc.g = 1.0 - t * t;\n\tc.b = 1.0 - t;\n\treturn c;\n}\n\n// makes Rainbow colormap with polynimal 6\nvec3 Rainbow2(float t) {\n\tvec3 c = vec3(0.0);\n\tc.r = 1.0 - t * t * t;\n\tc.g = 1.0 - t * t;\n\tc.b = 1.0 - t;\n\treturn c;\n}\n\n// makes Rainbow colormap with polynimal 6\nvec3 Rainbow3(float t) {\n\tvec3 c = vec3(0.0);\n\tc.r = 1.0 - t * t * t;\n\tc.g = 1.0 - t * t;\n\tc.b = 1.0 - t;\n\treturn c;\n}\n\n// makes Rainbow colormap with polynimal 6\nvec3 Rainbow4(float t) {\n\tvec3 c = vec3(0.0);\n\tc.r = 1.0 - t * t * t;\n\tc.g = 1.0 - t * t;\n\tc.b = 1.0 -", "\n\tfloat c = cos(a.z);\n\tfloat s = sin(a.z);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * v.xy, v.z);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * v.xy, v.z);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec2 a)\n{\n\tfloat c = cos(a.y);\n\tfloat s = sin(a.y);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * v.xy, v.z);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, float a, vec2 p)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * (v.xy - p) + p, v.z);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec2 a, vec2 p)\n{\n\tfloat c = cos(a.y);\n\tfloat s = sin(a.y);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * (v.xy - p) + p, v.z);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec2 p, float scale) {\n    float f = 0.0;\n    f += 0.5000 * noise(p * scale); p = p * 2.02;\n    f += 0.2500 * noise(p * scale); p = p * 2.03;\n    f += 0.1250", "\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p) {\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec4 p) {\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec5 p) {\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec6 p) {\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec7 p) {\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec8 p) {\n    return length(p) * 0.70710678118654752440084436210485;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec9 p) {\n    return length(p) * 0.70710", "\n\tuv = uv * 2.0 - 1.0;\n\tfloat a = atan(uv.x, uv.y) + PI;\n\tfloat r = length(uv);\n\tfloat q = floor(a / (2.0 * PI / 3.0));\n\tfloat f = fract(a / (2.0 * PI / 3.0));\n\tfloat s = sign(f - 0.5);\n\tfloat h = clamp(-q + s * 0.5, -0.5, 0.5);\n\tfloat m = clamp(q + 0.5 - s * 0.5, -0.5, 0.5);\n\tfloat n = 1.0 - abs(h) - abs(m);\n\tfloat t = s * pow(max(h, max(m, n)), 2.0);\n\tvec2 p = vec2(r * cos(a), r * sin(a)) * (vec2(h, n) + t);\n\treturn hexParams(p, q);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexTileUV(vec2 p) {\n\tfloat q = floor(p.x + 0.5);\n\tfloat r = p.y;\n\tfloat s = p.x - q;\n\tfloat t = 1.0 - abs(s);\n\tfloat u = s;\n\tfloat v = r;\n\tif (abs(q & 1.0) == 1.0) {\n\t\tu = 3.0 - s * 2.0;\n\t}\n\treturn vec2(u, v) * t * 0.5 + 0.5;\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexTileUV(hexParams p) {\n\treturn hexTileUV(p.p);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexTileUV(vec2 p, float", "\n\tt = t * 6.0;\n\tfloat i = floor(t);\n\tfloat f = t - i;\n\tfloat v = (1.0 - f) * V[int(i)];\n\tfloat m = f * V[int(i + 1.0)];\n\treturn vec3(v, m, 1.0 - v - m);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a, float b) {\n\tt = t * 6.0;\n\tfloat i = floor(t);\n\tfloat f = t - i;\n\tfloat v = (1.0 - f) * V[int(i)];\n\tfloat m = f * V[int(i + 1.0)];\n\treturn vec3(v, m, 1.0 - v - m) * a + b;\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a, float b, float c) {\n\tt = t * 6.0;\n\tfloat i = floor(t);\n\tfloat f = t - i;\n\tfloat v = (1.0 - f) * V[int(i)];\n\tfloat m = f * V[int(i + 1.0)];\n\treturn vec3(v, m, 1.0 - v - m) * a + b * c;\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a, float b, float c, float d) {\n\tt = t * 6.0;\n\tfloat i = floor(t);\n\tfloat f = t - i;\n\tfloat v = (1.0 - f) * V[int(i)];\n\tfloat m = f * V[int(i + 1.0)];\n\treturn vec3(v, m, 1.0 - v - m) *", "\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(float x) {\n\treturn (x * 2) - 1;\n}\n\n//shifts value range from 0-1 to 0-255\nint make255(float x) {\n\treturn (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make1(int x) {\n\treturn (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make255(float x) {\n\treturn (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make1(int x) {\n\treturn (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make255(float x) {\n\treturn (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make1(int x) {\n\treturn (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make255(float x) {\n\treturn (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make1(int x) {\n\treturn (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make255(float x) {\n\treturn (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make1(int x) {\n\treturn (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make255(", "\n    float cellSize = 1.0 / gridRes;\n    float cellOffset = 0.5 / gridRes;\n    float cell = mod(floor(uv.x / cellSize) + floor(uv.y / cellSize), 2.0);\n    float cellOffsetX = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX2 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY2 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX3 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY3 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX4 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY4 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX5 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY5 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX6 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY6 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX7 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY7 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX8 = cellOffset * (cell == 0.0? 1.0 : -1.0);\n    float cellOffsetY8 = cellOffset * (cell == 0.0? -1.0 : 1.0);\n    float cellOffsetX9 = cellOffset *", "\n    float flow = 0.0;\n    float step = 1.0 / gridRes;\n    float step2 = step * 2.0;\n    float step3 = step * 3.0;\n    float step4 = step * 4.0;\n    float step5 = step * 5.0;\n    float step6 = step * 6.0;\n    float step7 = step * 7.0;\n    float step8 = step * 8.0;\n    float step9 = step * 9.0;\n    float step10 = step * 10.0;\n    float step11 = step * 11.0;\n    float step12 = step * 12.0;\n    float step13 = step * 13.0;\n    float step14 = step * 14.0;\n    float step15 = step * 15.0;\n    float step16 = step * 16.0;\n    float step17 = step * 17.0;\n    float step18 = step * 18.0;\n    float step19 = step * 19.0;\n    float step20 = step * 20.0;\n    float step21 = step * 21.0;\n    float step22 = step * 22.0;\n    float step23 = step * 23.0;\n    float step24 = step * 24.0;\n    float step25 = step * 25.0;\n    float step26 = step * 26.0;\n    float step27 = step * 27.0;\n    float step28 = step * 28.0;\n    float step29 = step * 29.0;\n    float step30 = step * 30.0;\n    float step31 = step * 31.0;\n    float step32 = step * 32.0;\n    float step33 = step * 33.0;\n    float step34 = step * 34.0;\n    float step35 = step * 35.0;\n    float step36 = step * 36.0;\n    float step37 = step * 37.0;\n    float step", "\n\tfloat angle = atan(point.y, point.x);\n\tfloat distance = length(point);\n\tfloat speed = 1.0 - smoothstep(radius, radius + 0.05, distance);\n\tfloat angleOffset = time * 0.05;\n\treturn vec2(cos(angle + angleOffset), sin(angle + angleOffset)) * speed;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float strength) {\n\tfloat angle = atan(point.y, point.x);\n\tfloat distance = length(point);\n\tfloat speed = 1.0 - smoothstep(radius, radius + 0.05, distance);\n\tfloat angleOffset = time * 0.05;\n\treturn vec2(cos(angle + angleOffset), sin(angle + angleOffset)) * speed * strength;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float strength, float angleOffset) {\n\tfloat distance = length(point);\n\tfloat speed = 1.0 - smoothstep(radius, radius + 0.05, distance);\n\treturn vec2(cos(atan(point.y, point.x) + angleOffset), sin(atan(point.y, point.x) + angleOffset)) * speed * strength;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float strength, float angleOffset, float speed) {\n\treturn vec2(cos(atan(point.y, point.x) + angleOffset), sin(atan(point.y, point.x) + angleOffset)) * speed * strength;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float strength, float angleOffset, float speed, float angle) {\n\treturn vec2(cos(atan(point.y, point.x) + angleOffset), sin(atan(point.y, point.x) + angleOffset)) * speed * strength;\n}\n\n// makes a simple flowmap of a cyclone", "\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom) {\n    return floor(pos / tileSize(zoom)) * tileSize(zoom) + tileSize(zoom) / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom, float tileSize) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom, vec2 tileSize) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom, vec2 tileSize, vec2 tileOrigin) {\n    return floor((pos - tileOrigin) / tileSize) * tileSize + tileSize / 2.0 + tileOrigin;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom, vec2 tileSize, vec2 tileOrigin, vec2 tileScale) {\n    return floor((pos - tileOrigin) / tileSize) * tileSize + tileSize / 2.0 + tileOrigin;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom, vec2 tileSize, vec2 tileOrigin, vec2 tileScale, vec2 tileOffset) {\n    return floor((pos - tileOrigin) / tileSize) * tileSize + tileSize / 2.0 + tileOrigin;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float zoom, vec2 tileSize, vec2 tileOrigin, vec2 tileScale, vec2 tileOffset, vec2 tilePixelRatio) {\n    return floor((pos - tileOrigin) / tileSize) * tileSize + tileSize / 2.0 + tileOrigin;\n}\n\n// Computes the center pixel of the", "\n\tvec2 a = p2 - p1;\n\tvec2 b = p - p1;\n\tfloat h = clamp(dot(b, a) / dot(a, a), 0.0, 1.0);\n\treturn length(b - a * h);\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r) {\n\treturn length(p - c) - r;\n}\n\n// Computes the signed distance from a rectangle\nfloat rect(vec2 p, vec2 c, vec2 s) {\n\tvec2 d = abs(p - c) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Computes the signed distance from a rounded rectangle\nfloat roundedRect(vec2 p, vec2 c, vec2 s, float r) {\n\tvec2 d = abs(p - c) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n\tvec2 a = p2 - p1;\n\tvec2 b = p3 - p1;\n\tvec2 c = p - p1;\n\tfloat s = sign(a.x * b.y - b.x * a.y);\n\tfloat h = clamp(-dot(a, c) / dot(a, b), 0.0, 1.0);\n\treturn s * length(c - b * h);\n}\n\n// Computes the signed distance from a polygon\nfloat polygon(vec2 p, vec2[] points) {\n\tfloat d = 1e10;\n\tfor (int i = 0; i < points.length; i++) {\n\t\tint j = (i + 1) % points.length;\n\t\td = min(d, line(p, points[i], points[j]));\n\t}\n\treturn d;\n}\n\n// Computes the signed distance from a", "\n    float d = length(v);\n    float a = atan(v.y, v.x);\n    float r = 0.005;\n    float s = 0.005;\n    float t = 0.005;\n    float w = 0.005;\n    float h = 0.005;\n    float x = cos(a) * d;\n    float y = sin(a) * d;\n    float d1 = sdBox(vec2(x, y), vec2(r, s));\n    float d2 = sdBox(vec2(x, y), vec2(t, h));\n    float d3 = sdBox(vec2(x, y), vec2(w, h));\n    return min(d1, min(d2, d3));\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p) {\n    vec2 v = field(p);\n    return arrow(p, v);\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float t) {\n    vec2 v = field(p);\n    return arrow(p, v) - t;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float t, float s) {\n    vec2 v = field(p);\n    return arrow(p, v) - t * s;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float t, float s, float r) {\n    vec2 v = field(p);\n    return arrow(p, v) - t * s * r;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float t, float s, float r, float a) {\n    vec2 v = field(p);\n    return arrow(p, v) - t * s * r * a;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float t, float s, float r, float a, float b) {\n    vec2 v = field(p);\n    return arrow(p, v) - t * s * r * a * b;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float t, float", "\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x) {\n\treturn (x * 2.0) - 1.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec2 make255to255(vec2 x) {\n\treturn x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec2 make255to1(vec2 x) {\n\treturn x / 255.0;\n}\n\n//shifts value range from 0-1 to 0-65535\nvec2 make65535to65535(vec2 x) {\n\treturn x * 65535.0;\n}\n\n//shifts value range from 0-65535 to 0-1\nvec2 make65535to1(vec2 x) {\n\treturn x / 65535.0;\n}\n\n//shifts value range from 0-1 to 0-4294967295\nvec2 make4294967295to4294967295(vec2 x) {\n\treturn x * 4294967295.0;\n}\n\n//shifts value range from 0-4294967295 to 0-1\nvec2 make4294967295to1(vec2 x) {\n\treturn x / 4294967295.0;\n}\n\n//shifts value range from 0-1 to 0-18446744073709551615\nvec2 make18446744073709551615to18446744073709551615(vec2 x) {\n\treturn x * 18", "\n\tfloat angle = atan(point.y, point.x);\n\tfloat dist = length(point);\n\tfloat dist2 = dist * dist;\n\tfloat dist3 = dist2 * dist;\n\tfloat dist4 = dist3 * dist;\n\tfloat dist5 = dist4 * dist;\n\tfloat dist6 = dist5 * dist;\n\tfloat dist7 = dist6 * dist;\n\tfloat dist8 = dist7 * dist;\n\tfloat dist9 = dist8 * dist;\n\tfloat dist10 = dist9 * dist;\n\tfloat dist11 = dist10 * dist;\n\tfloat dist12 = dist11 * dist;\n\tfloat dist13 = dist12 * dist;\n\tfloat dist14 = dist13 * dist;\n\tfloat dist15 = dist14 * dist;\n\tfloat dist16 = dist15 * dist;\n\tfloat dist17 = dist16 * dist;\n\tfloat dist18 = dist17 * dist;\n\tfloat dist19 = dist18 * dist;\n\tfloat dist20 = dist19 * dist;\n\tfloat dist21 = dist20 * dist;\n\tfloat dist22 = dist21 * dist;\n\tfloat dist23 = dist22 * dist;\n\tfloat dist24 = dist23 * dist;\n\tfloat dist25 = dist24 * dist;\n\tfloat dist26 = dist25 * dist;\n\tfloat dist27 = dist26 * dist;\n\tfloat dist28 = dist27 * dist;\n\tfloat dist29 = dist28 * dist;\n\tfloat dist30 = dist29 * dist;\n\tfloat dist31 = dist30 * dist;\n\tfloat dist32 = dist31 * dist;\n\tfloat dist33 = dist32 * dist;\n\tfloat dist34 = dist33 * dist;\n\tfloat dist35 = dist34 * dist;\n\tfloat dist36 = dist35 * dist;\n\tfloat dist37 = dist36 * dist;\n\tfloat dist38 = dist37 * dist;\n\tfloat dist39 = dist38 * dist;\n\tfloat dist40 = dist39 * dist", "\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n  return length(p)-r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ) \n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c ) \n{\n  vec2 pa = p-a, ba = b-a, ca = c-a;\n  vec2 n = cross(ba,ca);\n  float s = sign(dot(n,pa));\n  vec2 h = vec2(2.0)*s*cross(n,pa)/dot(ba,cross(ba,ca));\n  return length(pa-h)*s;\n}\n\nfloat sdHexagon( in vec2 p, in vec2 h ) \n{\n  const vec3 k = vec3(-0.866025403784439,0.5,0.577350269189626);\n  p.x -= h.x*k.z; p.y -= h.y*k.z;\n  vec3 q = vec3(p.x,p.y,h.x*k.x+h.y*k.y);\n  float d = q.x*q.x + q.y*q.y - q.z*q.z;\n  return d*k.z + length(q.xy);\n}\n\nfloat sdStar( in vec2 p, in float r, in float ra, in float rb ) \n{\n  return max(sdCircle(p,r),sdCircle(p,ra))-rb;\n}\n\nfloat sdHeart( in vec2 p ) \n{\n  p.x *= 1.1;\n  float r =", "\n\tfloat s = 0.0;\n\tfloat d = 1.0;\n\tfloat t = 0.0;\n\tfloat r = 0.0;\n\tfloat c = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat aw = 0.0;\n\tfloat ax = 0.0;\n\tfloat ay = 0.0;\n\tfloat az = 0.0;\n", "\n\tfloat a = atan(p.x,p.y);\n\tfloat r = length(p);\n\tfloat t = mod(a+time*sp,TAU);\n\tfloat d = length(vec2(cos(t),sin(t))*r-p);\n\treturn d-ra;\n}\n\n// the point of this shader\nfloat sdHexagonalRepetition( in vec2 p, float ra, float sp, float time )\n{\n\tfloat a = atan(p.x,p.y);\n\tfloat r = length(p);\n\tfloat t = mod(a+time*sp,TAU);\n\tfloat d = length(vec2(cos(t),sin(t))*r-p);\n\treturn d-ra;\n}\n\n// the point of this shader\nfloat sdHexagonalRepetition2( in vec2 p, float ra, float sp, float time )\n{\n\tfloat a = atan(p.x,p.y);\n\tfloat r = length(p);\n\tfloat t = mod(a+time*sp,TAU);\n\tfloat d = length(vec2(cos(t),sin(t))*r-p);\n\treturn d-ra;\n}\n\n// the point of this shader\nfloat sdHexagonalRepetition3( in vec2 p, float ra, float sp, float time )\n{\n\tfloat a = atan(p.x,p.y);\n\tfloat r = length(p);\n\tfloat t = mod(a+time*sp,TAU);\n\tfloat d = length(vec2(cos(t),sin(t))*r-p);\n\treturn d-ra;\n}\n\n// the point of this shader\nfloat sdHexagonalRepetition4( in vec2 p, float ra, float sp, float time )\n{\n\tfloat a = atan(p.x,p.y);\n\tfloat r = length(p);\n\tfloat t = mod(a+time*sp,TAU);\n\tfloat d = length(vec2(cos(t),sin(t))*r-p);\n\treturn d-ra;\n}\n\n// the point of this shader\nfloat sdHexagonalRepetition5( in vec2 p", "\n\tfloat d = 0.0;\n\td = max(d, abs(uvw.x) - 0.5);\n\td = max(d, abs(uvw.y) - 0.5);\n\td = max(d, abs(uvw.z) - 0.5);\n\treturn d;\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n\treturn length(uvw) - 0.5;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n\tfloat d = length(uvw.xy) - 0.5;\n\td = max(d, abs(uvw.z) - 0.25);\n\treturn d;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n\tfloat d = length(uvw.xy) - 0.5;\n\td = max(d, abs(uvw.z) - 0.5);\n\treturn d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n\tfloat d = length(uvw.xy) - 0.5;\n\td = max(d, uvw.z - 0.5);\n\treturn d;\n}\n\n//edge distance of a Pyramid\nfloat pyramidDist(vec3 uvw) {\n\tfloat d = length(uvw.xy) - 0.5;\n\td = max(d, uvw.z - 0.5);\n\td = max(d, -uvw.z - 0.5);\n\treturn d;\n}\n\n//edge distance of a Octahedron\nfloat octahedronDist(vec3 uvw) {\n\tfloat d = length(uvw) - 0.5;\n\td = max(d, abs(uvw.x) + abs(uvw.y) + abs(uvw.z) - 1.0);\n\treturn d;\n}\n\n//edge distance of a Icosahedron\nfloat icosahedronDist(vec3 uvw) {\n\tfloat d = length(uvw) - 0.5;\n\td = max(d,", "\n    vec3 uvw2 = abs(uvw);\n    vec3 uvw3 = uvw2 * 2.0 - 1.0;\n    vec3 uvw4 = abs(uvw3);\n    vec3 uvw5 = uvw4 * 2.0 - 1.0;\n    vec3 uvw6 = abs(uvw5);\n    vec3 uvw7 = uvw6 * 2.0 - 1.0;\n    vec3 uvw8 = abs(uvw7);\n    vec3 uvw9 = uvw8 * 2.0 - 1.0;\n    vec3 uvw10 = abs(uvw9);\n    vec3 uvw11 = uvw10 * 2.0 - 1.0;\n    vec3 uvw12 = abs(uvw11);\n    vec3 uvw13 = uvw12 * 2.0 - 1.0;\n    vec3 uvw14 = abs(uvw13);\n    vec3 uvw15 = uvw14 * 2.0 - 1.0;\n    vec3 uvw16 = abs(uvw15);\n    vec3 uvw17 = uvw16 * 2.0 - 1.0;\n    vec3 uvw18 = abs(uvw17);\n    vec3 uvw19 = uvw18 * 2.0 - 1.0;\n    vec3 uvw20 = abs(uvw19);\n    vec3 uvw21 = uvw20 * 2.0 - 1.0;\n    vec3 uvw22 = abs(uvw21);\n    vec3 uvw23 = uvw22 * 2.0 - 1.0;\n    vec3 uvw24 = abs(uvw23);\n    vec3 uvw25 = uvw24 * 2.0 - 1.0;\n    vec3 uvw26 = abs(uvw25);\n    vec3 uvw27 = uvw26 * 2.0 - 1.0;\n    vec3 uvw28 = abs(uvw27);\n    vec3 uvw29 = uvw28 * 2.0 - 1.0;\n    vec3 uvw30 = abs(uvw2", "\n\tvec3 cell = floor(uvw * gridRes);\n\tvec3 cellCenter = cell / gridRes;\n\tvec3 cellOffset = fract(uvw * gridRes);\n\tvec3 cellOffset2 = fract(uvw * gridRes * 2.0);\n\tvec3 cellOffset3 = fract(uvw * gridRes * 3.0);\n\tvec3 cellOffset4 = fract(uvw * gridRes * 4.0);\n\tvec3 cellOffset5 = fract(uvw * gridRes * 5.0);\n\tvec3 cellOffset6 = fract(uvw * gridRes * 6.0);\n\tvec3 cellOffset7 = fract(uvw * gridRes * 7.0);\n\tvec3 cellOffset8 = fract(uvw * gridRes * 8.0);\n\tvec3 cellOffset9 = fract(uvw * gridRes * 9.0);\n\tvec3 cellOffset10 = fract(uvw * gridRes * 10.0);\n\tvec3 cellOffset11 = fract(uvw * gridRes * 11.0);\n\tvec3 cellOffset12 = fract(uvw * gridRes * 12.0);\n\tvec3 cellOffset13 = fract(uvw * gridRes * 13.0);\n\tvec3 cellOffset14 = fract(uvw * gridRes * 14.0);\n\tvec3 cellOffset15 = fract(uvw * gridRes * 15.0);\n\tvec3 cellOffset16 = fract(uvw * gridRes * 16.0);\n\tvec3 cellOffset17 = fract(uvw * gridRes * 17.0);\n\tvec3 cellOffset18 = fract(uvw * gridRes * 18.0);\n\tvec3 cellOffset19 = fract(uvw * gridRes * 19.0);\n\tvec3 cellOffset20 = fract(uvw * gridRes * 20.0);\n\tvec3 cellOffset21 = fract(uvw * gridRes * 21.0);\n\tvec3 cellOffset22 = fract(uvw * gridRes * 22.0);\n\tvec3 cell", "\n\tvec3 c = vec3(0.0);\n\tif (t < 0.16666666666666666) {\n\t\tc = vec3(1.0, t * 6.0, 0.0);\n\t} else if (t < 0.3333333333333333) {\n\t\tc = vec3(2.0 - t * 6.0, 1.0, 0.0);\n\t} else if (t < 0.5) {\n\t\tc = vec3(0.0, 1.0, t * 6.0 - 1.0);\n\t} else if (t < 0.6666666666666666) {\n\t\tc = vec3(0.0, 2.0 - t * 6.0, 1.0);\n\t} else if (t < 0.8333333333333334) {\n\t\tc = vec3(t * 6.0 - 3.0, 0.0, 1.0);\n\t} else {\n\t\tc = vec3(1.0, 0.0, 2.0 - t * 6.0);\n\t}\n\treturn c;\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a) {\n\tvec3 c = vec3(0.0);\n\tif (t < 0.16666666666666666) {\n\t\tc = vec3(1.0, t * 6.0, 0.0);\n\t} else if (t < 0.3333333333333333) {\n\t\tc = vec3(2.0 - t * 6.0, 1.0, 0.0);\n\t} else if (t < 0.5) {\n\t\tc = vec", "\n\tvec3 q = abs(p);\n\treturn max(q.x, max(q.y, q.z)) - min(min(q.x, q.y), q.z);\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.x, max(q.y, q.z)) - min(min(q.x, q.y), q.z) * 0.57735026918962576450914878050196;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.x, max(q.y, q.z)) - min(min(q.x, q.y), q.z) * 0.85065080835203993218149688061752;\n}\n\n//Distance from the Edge of Icosidodecahedron\nfloat icosidodecaDist(vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.x, max(q.y, q.z)) - min(min(q.x, q.y), q.z) * 0.90617984593866399279762687829939;\n}\n\n//Distance from the Edge of Truncated Tetrahedron\nfloat tetDist(vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.x, max(q.y, q.z)) - min(min(q.x, q.y), q.z) * 0.86602540378443864676372317075294;\n}\n\n//Distance from the Edge of Truncated Cube\nfloat truncCubeDist(vec3 p) {\n\tvec", "\n\tvec3 c = vec3(0.0);\n\tc += 1.0 * pow(t, 6.0);\n\tc += 1.0 * pow(t, 5.0);\n\tc += 1.0 * pow(t, 4.0);\n\tc += 1.0 * pow(t, 3.0);\n\tc += 1.0 * pow(t, 2.0);\n\tc += 1.0 * pow(t, 1.0);\n\tc += 1.0 * pow(t, 0.0);\n\treturn c;\n}\n\n// makes winter colormap with polynimal 7\nvec3 winter(float t) {\n\tvec3 c = vec3(0.0);\n\tc += 1.0 * pow(t, 7.0);\n\tc += 1.0 * pow(t, 6.0);\n\tc += 1.0 * pow(t, 5.0);\n\tc += 1.0 * pow(t, 4.0);\n\tc += 1.0 * pow(t, 3.0);\n\tc += 1.0 * pow(t, 2.0);\n\tc += 1.0 * pow(t, 1.0);\n\tc += 1.0 * pow(t, 0.0);\n\treturn c;\n}\n\n// makes winter colormap with polynimal 8\nvec3 winter(float t) {\n\tvec3 c = vec3(0.0);\n\tc += 1.0 * pow(t, 8.0);\n\tc += 1.0 * pow(t, 7.0);\n\tc += 1.0 * pow(t, 6.0);\n\tc += 1.0 * pow(t, 5.0);\n\tc += 1.0 * pow(t, 4.0);\n\tc += 1.0 * pow(t, 3.0);\n\tc += 1.0 * pow(t, 2.0);\n\tc += 1.0 * pow(t, 1", "\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 m = mod(i, 2.0);\n    vec2 r = step(m, f);\n    return vec3(r.x * r.y);\n}\n\n// simple hexagonal Tiling\nvec3 hexTile(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 m = mod(i, 2.0);\n    vec2 r = step(m, f);\n    return vec3(r.x * r.y * (1.0 - r.x));\n}\n\n// simple triangular Tiling\nvec3 triTile(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 m = mod(i, 2.0);\n    vec2 r = step(m, f);\n    return vec3(r.x * (1.0 - r.y));\n}\n\n// simple diamond Tiling\nvec3 diamondTile(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 m = mod(i, 2.0);\n    vec2 r = step(m, f);\n    return vec3(r.x * r.y * (1.0 - r.x) * (1.0 - r.y));\n}\n\n// simple checkerboard Tiling\nvec3 checkerTile(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 m = mod(i, 2.0);\n    vec2 r = step(m, f);\n    return vec3(r.x * r.y);\n}\n\n// simple chessboard Tiling\nvec3 chessTile(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 m = mod(i, 2.0);\n    vec2 r = step(m, f);\n    return vec3(r.x * (1.0 - r.y));\n}\n\n// simple bulls eye Tiling\nvec3 bullsEyeTile(vec2", "\n\tuv = abs(uv);\n\tfloat d = max(uv.x, uv.y);\n\tfloat s = step(d, 1.0);\n\treturn vec3(s, s, s);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size) {\n\tuv = abs(uv);\n\tfloat d = max(uv.x, uv.y);\n\tfloat s = step(d, size);\n\treturn vec3(s, s, s);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset) {\n\tuv = abs(uv);\n\tfloat d = max(uv.x, uv.y);\n\tfloat s = step(d, size);\n\treturn vec3(s, s, s) * offset;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset, float scale) {\n\tuv = abs(uv);\n\tfloat d = max(uv.x, uv.y);\n\tfloat s = step(d, size);\n\treturn vec3(s, s, s) * offset * scale;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset, float scale, float offset2) {\n\tuv = abs(uv);\n\tfloat d = max(uv.x, uv.y);\n\tfloat s = step(d, size);\n\treturn vec3(s, s, s) * offset * scale + offset2;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset, float scale, float offset2, float scale2) {\n\tuv = abs(uv);\n\tfloat d = max(uv.x, uv.y);\n\tfloat s = step(d, size);\n\treturn vec3(s, s, s) * offset * scale + offset2 * scale2;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec", "\n    vec2 grid = floor(uv * gridRes + offset);\n    float sq = mod(grid.x + grid.y, 2.0);\n    return vec3(sq);\n}\n\n// nakes a circle pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes + offset);\n    float sq = distance(grid, vec2(gridRes / 2.0));\n    return vec3(sq);\n}\n\n// nakes a circle pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius) {\n    vec2 grid = floor(uv * gridRes + offset);\n    float sq = distance(grid, vec2(gridRes / 2.0));\n    return vec3(sq);\n}\n\n// nakes a circle pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius, float thickness) {\n    vec2 grid = floor(uv * gridRes + offset);\n    float sq = distance(grid, vec2(gridRes / 2.0));\n    return vec3(sq);\n}\n\n// nakes a circle pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius, float thickness, float offsetX, float offsetY) {\n    vec2 grid = floor(uv * gridRes + offset);\n    float sq = distance(grid, vec2(gridRes / 2.0));\n    return vec3(sq);\n}\n\n// nakes a circle pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius, float thickness, float offsetX, float offsetY, float offsetZ) {\n    vec2 grid = floor(uv * gridRes + offset);\n    float sq = distance(grid, vec2(gridRes / 2.0));\n    return vec3(sq);\n}\n\n// nakes a circle pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius, float thickness, float offsetX, float offsetY, float offsetZ, float offsetW) {\n    vec2 grid = floor(uv * gridRes", "\n    float grid = gridRes;\n    float x = floor(uv.x * grid);\n    float y = floor(uv.y * grid);\n    float index = mod(x + y, 2.0);\n    return vec3(index);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2) {\n    float grid = gridRes;\n    float grid2 = gridRes2;\n    float x = floor(uv.x * grid);\n    float y = floor(uv.y * grid);\n    float index = mod(x + y, 2.0);\n    float index2 = mod(x + y, 2.0);\n    return vec3(index, index2);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2, float gridRes3) {\n    float grid = gridRes;\n    float grid2 = gridRes2;\n    float grid3 = gridRes3;\n    float x = floor(uv.x * grid);\n    float y = floor(uv.y * grid);\n    float index = mod(x + y, 2.0);\n    float index2 = mod(x + y, 2.0);\n    float index3 = mod(x + y, 2.0);\n    return vec3(index, index2, index3);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2, float gridRes3, float gridRes4) {\n    float grid = gridRes;\n    float grid2 = gridRes2;\n    float grid3 = gridRes3;\n    float grid4 = gridRes4;\n    float x = floor(uv.x * grid);\n    float y = floor(uv.y * grid);\n    float index = mod(x + y, 2.0);\n    float index2 = mod(x + y, 2.0);\n    float index3 = mod(x + y, 2.0);\n    float index4 = mod(x + y, 2.0);\n    return vec3(index, index2, index3, index4);\n}\n\n// n", "\n    float cellSize = 1.0 / gridRes;\n    float cellOffset = 0.5 / gridRes;\n    float cell = mod(floor(uv.x / cellSize) + floor(uv.y / cellSize), 2.0);\n    float t = mod(time, len);\n    float t2 = mod(t, 0.5);\n    float t3 = mod(t, 0.25);\n    float t4 = mod(t, 0.125);\n    float t5 = mod(t, 0.0625);\n    float t6 = mod(t, 0.03125);\n    float t7 = mod(t, 0.015625);\n    float t8 = mod(t, 0.0078125);\n    float t9 = mod(t, 0.00390625);\n    float t10 = mod(t, 0.001953125);\n    float t11 = mod(t, 0.0009765625);\n    float t12 = mod(t, 0.00048828125);\n    float t13 = mod(t, 0.000244140625);\n    float t14 = mod(t, 0.0001220703125);\n    float t15 = mod(t, 0.00006103515625);\n    float t16 = mod(t, 0.000030517578125);\n    float t17 = mod(t, 0.0000152587890625);\n    float t18 = mod(t, 0.00000762939453125);\n    float t19 = mod(t, 0.000003814697265625);\n    float t20 = mod(t, 0.000001907348632812", "\n    float cellSize = 1.0 / gridRes;\n    float cell = floor(uv.x / cellSize);\n    float cellOffset = cellSize * cell;\n    float cellOffset2 = cellSize * (cell + 1.0);\n    float cellOffset3 = cellSize * (cell + 2.0);\n    float cellOffset4 = cellSize * (cell + 3.0);\n    float cellOffset5 = cellSize * (cell + 4.0);\n    float cellOffset6 = cellSize * (cell + 5.0);\n    float cellOffset7 = cellSize * (cell + 6.0);\n    float cellOffset8 = cellSize * (cell + 7.0);\n    float cellOffset9 = cellSize * (cell + 8.0);\n    float cellOffset10 = cellSize * (cell + 9.0);\n    float cellOffset11 = cellSize * (cell + 10.0);\n    float cellOffset12 = cellSize * (cell + 11.0);\n    float cellOffset13 = cellSize * (cell + 12.0);\n    float cellOffset14 = cellSize * (cell + 13.0);\n    float cellOffset15 = cellSize * (cell + 14.0);\n    float cellOffset16 = cellSize * (cell + 15.0);\n    float cellOffset17 = cellSize * (cell + 16.0);\n    float cellOffset18 = cellSize * (cell + 17.0);\n    float cellOffset19 = cellSize * (cell + 18.0);\n    float cellOffset20 = cellSize * (cell + 19.0);\n    float cellOffset21 = cellSize * (cell + 20.0);\n    float cellOffset22 = cellSize * (cell + 21.0);\n    float cellOffset23 = cellSize * (cell + 22.0);\n    float cellOffset24 = cellSize * (cell + 23.0);\n    float cellOffset25 = cellSize * (cell + 24.0);\n    float cellOffset26 = cellSize * (cell + 25.0);\n    float cellOffset27 = cellSize * (cell + 26.0", "\n    vec2 q = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot(q+vec2(0.0,0.0), ddx), dot(q+vec2(1.0,0.0), ddx), u.x),\n                mix( dot(q+vec2(0.0,1.0), ddx), dot(q+vec2(1.0,1.0), ddx), u.x), u.y) *\n           mix( mix( dot(q+vec2(0.0,0.0), ddy), dot(q+vec2(0.0,1.0), ddy), u.x),\n                mix( dot(q+vec2(1.0,0.0), ddy), dot(q+vec2(1.0,1.0), ddy), u.x), u.y);\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureBox( in vec2 p )\n{\n    vec2 q = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot(q+vec2(0.0,0.0), vec2(1.0)), dot(q+vec2(1.0,0.0), vec2(1.0)), u.x),\n                mix( dot(q+vec2(0.0,1.0), vec2(1.0)), dot(q+vec2(1.0,1.0), vec2(1.0)), u.x), u.y) *\n           mix( mix( dot(q+vec2(0.0,0.0), vec2(1.0)), dot(q+vec2(0.0,1.0), vec2(1.0)), u.x),\n                mix( dot(q+vec2(1.0,0.0), vec2(1.0)), dot(q+vec2(1.0,1.0), vec2(1.0)), u.x),", "\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float w) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p, 0.0)) - r - w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float w, float h) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p, 0.0)) - r - w - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float w, float h, float d) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0.0)*sign(p);\n    return length(max(p, 0.0)) - r - w - h - d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float w, float h, float d, float e) {\n    p = abs(p);\n    p -= 2.0*min(dot(p, vec2(1.0)), 0", "\n    p = fract(p);\n    vec2 q = floor(p);\n    float r = dot(q, vec2(1.0, 0.0));\n    float s = dot(q, vec2(0.0, 1.0));\n    float t = r + s;\n    float u = fract(t * 0.5);\n    float v = fract(t);\n    float w = fract(t * 2.0);\n    float x = fract(t * 3.0);\n    float y = fract(t * 4.0);\n    float z = fract(t * 5.0);\n    float a = fract(t * 6.0);\n    float b = fract(t * 7.0);\n    float c = fract(t * 8.0);\n    float d = fract(t * 9.0);\n    float e = fract(t * 10.0);\n    float f = fract(t * 11.0);\n    float g = fract(t * 12.0);\n    float h = fract(t * 13.0);\n    float i = fract(t * 14.0);\n    float j = fract(t * 15.0);\n    float k = fract(t * 16.0);\n    float l = fract(t * 17.0);\n    float m = fract(t * 18.0);\n    float n = fract(t * 19.0);\n    float o = fract(t * 20.0);\n    float p1 = fract(t * 21.0);\n    float p2 = fract(t * 22.0);\n    float p3 = fract(t * 23.0);\n    float p4 = fract(t * 24.0);\n    float p5 = fract(t * 25.0);\n    float p6 = fract(t * 26.0);\n    float p7 = fract(t * 27.0);\n    float p8 = fract(t * 28.0);\n    float p9 = fract(t * 29.0);\n    float p", "\n    return sin(x)*sin(x*x)*0.5+0.5;\n}\n\n// 2D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// 3D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    // Four corners in 3D of a tetrahedron\n    vec4 uv = vec4(f.x,f.y,f.z,1.0-f.x-f.y-f.z);\n    vec2 u = uv.xy+uv.zw;\n\n    // Normalise gradients\n    vec4 n = vec4(0.0);\n\n    // Gradient contribution from the first corner\n    n += 0.6 - 0.4 * u.x;\n\n    // Gradient contribution from the second corner\n    n += 0.6 - 0.4 * u.y;\n\n    // Gradient contribution from the third corner\n    n += 0.6 - 0.4 * (3.0 - 2.0 * u.x);\n\n    // Gradient contribution from the fourth corner\n    n += 0.6 - 0", "\n    return t <= 0.0031308? 12.92 * t : 1.055 * pow(t, 0.41666) - 0.055;\n}\n\nvec3 sRGBInv(vec3 t) {\n    return t <= 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsl(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb,", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df6(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df7(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df8(vec2 p) {", "\n\treturn 0.5 + 0.5*sin(50.0*p.x)*sin(50.0*p.y);\n}\n\nfloat df2(vec2 p) {\n\treturn 0.5 + 0.5*sin(10.0*p.x)*sin(10.0*p.y);\n}\n\nfloat df3(vec2 p) {\n\treturn 0.5 + 0.5*sin(2.0*p.x)*sin(2.0*p.y);\n}\n\nfloat df4(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.5*p.x)*sin(0.5*p.y);\n}\n\nfloat df5(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.25*p.x)*sin(0.25*p.y);\n}\n\nfloat df6(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.125*p.x)*sin(0.125*p.y);\n}\n\nfloat df7(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.0625*p.x)*sin(0.0625*p.y);\n}\n\nfloat df8(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.03125*p.x)*sin(0.03125*p.y);\n}\n\nfloat df9(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.015625*p.x)*sin(0.015625*p.y);\n}\n\nfloat df10(vec2 p) {\n\treturn 0.5 + 0.5*sin(0.0078125*p.x)*sin(0.0078125*p.y);\n}\n\nfloat df11(vec2 p) {\n\treturn ", "\n\tvec2 v0 = p1 - p0;\n\tvec2 v1 = p2 - p0;\n\tvec2 v2 = p - p0;\n\n\tfloat dot00 = dot( v0.xy, v0.xy );\n\tfloat dot01 = dot( v0.xy, v1.xy );\n\tfloat dot02 = dot( v0.xy, v2.xy );\n\tfloat dot11 = dot( v1.xy, v1.xy );\n\tfloat dot12 = dot( v1.xy, v2.xy );\n\n\tfloat invDenom = 1.0 / ( dot00 * dot11 - dot01 * dot01 );\n\tfloat u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\tfloat v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t// barycentric coordinates\n\tfloat b1 = 1.0 - u - v;\n\tfloat b2 = v;\n\tfloat b3 = u;\n\n\t// check if we are in triangle\n\tif( b1 < 0.0 || b2 < 0.0 || b3 < 0.0 )\n\t{\n\t\treturn length( p - p0 );\n\t}\n\n\treturn dot( v0.xy, v0.xy ) * b1 * b1 + dot( v1.xy, v1.xy ) * b2 * b2 + dot( v2.xy, v2.xy ) * b3 * b3;\n}\n\n// signed distance to a 3D triangle\nfloat sdTriangle( in vec3 p, in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n\tvec3 v0 = p1 - p0;\n\tvec3 v1 = p2 - p0;\n\tvec3 v2 = p - p0;\n\n\tfloat dot00 = dot( v0.xyz, v0.xyz );\n\tfloat dot01 = dot( v0.xyz, v1.xyz );\n\tfloat dot02 = dot( v0.xyz, v2.xyz );\n\tfloat dot11 = dot( v", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h - dbuffer;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec3 sphereNormal(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec3(0.0);\n    h = sqrt(h);\n    return normalize(ro + rd * (-b - h) - sph.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec3 sphereNormal(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h <", "\n    vec2 q = abs(p);\n    return max(q.x-w,max(q.y-r,0.0)) + min(max(q.x,q.y)-w,0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r) {\n    return length(max(abs(p)-b,0.0)) + min(max(abs(p.x)-b.x,abs(p.y)-b.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r, float w) {\n    return roundedBox(p, b, r) - w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r, float w, float h) {\n    return max(roundedBox(p, b, r, w), -h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r, float w, float h, float d) {\n    return max(roundedBox(p, b, r, w), -h) - d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r, float w, float h, float d, float s) {\n    return max(roundedBox(p, b, r, w), -h) - d - s;\n}\n\n// License", "\n\tvec2 q = abs(p);\n    return length(q)*sign(q.x*q.y)*(1.0/k-1.0) + length(max(q,0.0)) - 1.0;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicTorus( in vec3 p, float r, float t, float k )\n{\n\tvec3 q = abs(p);\n    return length(q+vec3(r,t,r))*(1.0/k-1.0) + length(max(q,0.0)) - r;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCylinder( in vec3 p, float h, float k )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,0.0);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0))*(1.0/k-1.0);\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCone( in vec3 p, float h, float k )\n{\n\tvec2 q = abs(vec2(length(p.xz),p.y));\n    return max(q.y-h,q.x*(1.0/k-1.0)) + length(max(q,0.0)) - h;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicEllipsoid( in vec3 p, vec3 r, float k )\n{\n\tvec3 q = abs(p)/r;\n    return length(q)*(1.0/k-1.0) + length(max(q,0.0)) - 1.0;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicEllipticCone( in vec3 p, vec2 r, float k )\n{\n\tvec2 q = abs(vec2(length(p.xz),p.y))/r;\n    return max(q.y-1.0,q.x*(1.0/k-1.0)) +", "\n    return abs(p.x/p.y-1.0);\n}\n\n// distance to y=x\nfloat sdOX( in vec2 p )\n{\n    return abs(p.x-p.y);\n}\n\n// distance to y=x^2\nfloat sdOXSquared( in vec2 p )\n{\n    return abs(p.x-p.y*p.y);\n}\n\n// distance to y=x^3\nfloat sdOXCubed( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y);\n}\n\n// distance to y=x^4\nfloat sdOXQuartic( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y);\n}\n\n// distance to y=x^5\nfloat sdOXQuintic( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=x^6\nfloat sdOXHexic( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=x^7\nfloat sdOXSeptic( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=x^8\nfloat sdOXOctic( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=x^9\nfloat sdOXNonic( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=x^", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a, b, h) + k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k, float t) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h)*t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k, float t) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a, b, h) + k*h*(1.0-h)*t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k, float t, float p) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h)*t*p;\n}\n\n", "\n    return a < 0.0? -pow(-a, k) : pow(a, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float k) {\n    return a < 0.0? -pow(-a, k) : pow(a, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pstep(float edge, float x) {\n    return x < edge? 0.0 : 1.0;\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float edge0, float edge1, float x, float k) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return ppow(t, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float edge0, float edge1, float x, float k0, float k1) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return ppow(t, pmix(k0, k1, t));\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float edge0, float edge1, float x, float k0, float k1,", "\n    float a = 0.5;\n    float b = 0.5;\n    float c = 0.5;\n    float d = 0.5;\n    float e = 0.5;\n    float f = 0.5;\n    float g = 0.5;\n    float h = 0.5;\n    float i = 0.5;\n    float j = 0.5;\n    float k = 0.5;\n    float l = 0.5;\n    float m = 0.5;\n    float n = 0.5;\n    float o = 0.5;\n    float p1 = 0.5;\n    float p2 = 0.5;\n    float p3 = 0.5;\n    float p4 = 0.5;\n    float p5 = 0.5;\n    float p6 = 0.5;\n    float p7 = 0.5;\n    float p8 = 0.5;\n    float p9 = 0.5;\n    float p10 = 0.5;\n    float p11 = 0.5;\n    float p12 = 0.5;\n    float p13 = 0.5;\n    float p14 = 0.5;\n    float p15 = 0.5;\n    float p16 = 0.5;\n    float p17 = 0.5;\n    float p18 = 0.5;\n    float p19 = 0.5;\n    float p20 = 0.5;\n    float p21 = 0.5;\n    float p22 = 0.5;\n    float p23 = 0.5;\n    float p24 = 0.5;\n    float p25 = 0.5;\n    float p26 = 0.5;\n    float p27 = 0.5;\n    float p28 = 0.5;\n    float p29 = 0.5;\n    float p30 = 0.5;\n    float p31 = 0.5;\n    float p32 = 0.5;\n    float p33 = 0.5;\n    float p34 = 0.5;\n    float p35 = 0.5;\n   ", "\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x)*934.345*p.y);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec3 p) {\n\tp = vec3(dot(p,vec3(127.1,311.7, 74.7)), dot(p,vec3(269.5,183.3, 246.1)), dot(p,vec3(113.5,271.9, 124.6)));\n\treturn fract(sin(p.x)*934.345*p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec4 p) {\n\tp = vec4(dot(p,vec4(127.1,311.7, 74.7, 157.9)), dot(p,vec4(269.5,183.3, 246.1, 157.9)), dot(p,vec4(113.5,271.9, 124.6, 623.1)), dot(p,vec4(619.2,371.0, 443.7, 291.7)));\n\treturn fract(sin(p.x)*934.345*p.y);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p, float seed) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x*seed)*934.34", "\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    vec2 ac = C - A;\n    float len2 = dot(ab,ab);\n    float h = dot(ab,ac) / len2;\n    vec2 q = h * ab + p;\n    float len = dot(q,q);\n    float d1 = sqrt(len);\n    float d2 = dot(q,bc) / len;\n    float d3 = dot(bc,bc);\n    float d = d1 * d2 - d3;\n    float t = clamp(d1 / d, 0.0, 1.0);\n    vec2 p2 = t * ab + A;\n    vec2 p3 = (1.0-t) * bc + B;\n    vec2 p4 = t * bc + B;\n    vec2 p5 = (1.0-t) * ab + A;\n    vec2 p6 = t * ac + A;\n    vec2 p7 = (1.0-t) * bc + C;\n    vec2 p8 = t * bc + C;\n    vec2 p9 = (1.0-t) * ac + C;\n    vec2 p10 = t * ab + C;\n    vec2 p11 = (1.0-t) * ac + B;\n    vec2 p12 = t * ac + B;\n    vec2 p13 = (1.0-t) * ab + A;\n    vec2 p14 = t * bc + A;\n    vec2 p15 = (1.0-t) * bc + C;\n    vec2 p16 = t * ab + C;\n    vec2 p17 = (1.0-t) * ac + B;\n    vec2 p18 = t * ac + B;\n    vec2 p19 = (1.0-t) * ab + A;\n    vec2 p20 = t * bc + A;\n    vec2 p21 = (1.0-t) * bc + C;\n    vec2 p22 = t * ab + C;\n    vec2 p23 = (1.0-t) * ac + B;\n    vec2 p24 = t * ac + B;\n    vec2 p2", "\n    vec2 p = pos;\n    p.x = abs(p.x);\n    float k = wi*wi - 4.0*he;\n    float a = k;\n    float b = 2.0*wi*p.x;\n    float c = p.x*p.x - he;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) discard;\n    h = sqrt(h);\n    float x = (-b-h)/(2.0*a);\n    float y = ( wi - x )/2.0;\n    float z = ( wi + x )/2.0;\n    float d = min( x, min( y, z ) );\n    vec3 res = vec3( d, 0.0, 0.0 );\n    if( d==x ) res.yz = vec2( y, z );\n    if( d==y ) res.yz = vec2( x, z );\n    if( d==z ) res.yz = vec2( x, y );\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi )\n{\n    return sdParabola( pos, wi, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos )\n{\n    return sdParabola( pos, 1.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in", "\n    float a = 1.0 + k;\n    float b = -2.0 * pos.x;\n    float c = pos.x * pos.x - pos.y;\n    float h = b * b - 4.0 * a * c;\n    if( h < 0.0 ) discard;\n    h = sqrt( h );\n    float t = ( -b - h ) / ( 2.0 * a );\n    float x = pos.x + t;\n    float y = pos.y + t * t;\n    float z = 2.0 * t;\n    return vec3( x, y, z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdHyperbola( in vec2 pos, in float k )\n{\n    float a = 1.0 + k;\n    float b = -2.0 * pos.x;\n    float c = pos.x * pos.x - pos.y;\n    float h = b * b - 4.0 * a * c;\n    if( h < 0.0 ) discard;\n    h = sqrt( h );\n    float t = ( -b + h ) / ( 2.0 * a );\n    float x = pos.x + t;\n    float y = pos.y + t * t;\n    float z = 2.0 * t;\n    return vec3( x, y, z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos, in vec2 r )\n{\n    float b = r.x * r.x;\n    float a = r.y * r.y;\n    float c = b - a;\n    float h = pos.x * pos.x / a + pos.y * pos.y / b;\n    if( h > 1.0 + EPS", "\n    float r = length(p);\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n    float r35 = r34*r;\n    float r36 = r35*r;\n    float r37 = r36*r;\n    float r38 = r37*r;\n    float r39 = r38*r;\n    float r40 = r39*r;\n    float r41 = r40*r;\n    float r42 = r41*r;\n    float r43 = r42*r;\n    float r44 = r43*r;\n    float r45 =", "\n    v = v * ivec2(1664525, 1013904223);\n    v += 1664525 * v.y + 1013904223 * v.x;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v)\n{\n    v = v * ivec3(1664525, 1013904223, 1664525);\n    v += 1664525 * v.y + 1013904223 * v.x + 1664525 * v.z;\n    return v;\n}\n\nivec4 Pcg4(ivec4 v)\n{\n    v = v * ivec4(1664525, 1013904223, 1664525, 1013904223);\n    v += 1664525 * v.y + 1013904223 * v.x + 1664525 * v.z + 1013904223 * v.w;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - <NAME>\n// https://www.jcgt.org/published/0007/04/01/\nfloat Hash1(float x)\n{\n    return fract(sin(x) * 43758.5453123);\n}\n\nfloat Hash2(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash3(vec3 p)\n{\n    p = fract(p * vec3(.1031,.1030,.0973));\n    p *= p + 33.33;\n    p *= p +", "\n    v = v * ivec3(1664525, 1013904223, 697671993) + ivec3(1740743, 1917528013, 2310459053);\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int n)\n{\n    ivec3 r = v;\n    for (int i = 0; i < n; i++)\n    {\n        r = Pcg3(r);\n    }\n    return r;\n}\n\nfloat Hash3(ivec3 p)\n{\n    p = Pcg3(p);\n    p = Pcg3(p);\n    p = Pcg3(p);\n    return fract(float(p.x) * (1.0 / float(0x7fffffff)));\n}\n\nfloat Hash3(ivec3 p, int n)\n{\n    p = Pcg3(p, n);\n    p = Pcg3(p, n);\n    p = Pcg3(p, n);\n    return fract(float(p.x) * (1.0 / float(0x7fffffff)));\n}\n\nfloat Hash3(vec3 p)\n{\n    ivec3 i = ivec3(floor(p));\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(lerp(Hash3(i), Hash3(i + ivec3(1, 0, 0)), f.x), lerp(Hash3(i + ivec3(0, 1, 0)), Hash3(i + ivec3(1, 1, 0)), f.x), f.y), lerp(lerp(Hash3(i + ivec3(0, 0, 1)), Hash3(i + ivec3(1, 0, 1)), f.x), lerp(Hash3(i + ivec3(0, 1, 1)), Hash3(i + ivec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\n", "\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\tvec2 ab = b - a;\n\tvec2 bc = c - b;\n\tvec2 ca = a - c;\n\tvec2 abc = cross(ab, bc);\n\tvec2 acd = cross(ca, ab);\n\tvec2 bcd = cross(bc, ca);\n\tfloat a2 = dot(ab, ab);\n\tfloat b2 = dot(bc, bc);\n\tfloat c2 = dot(ca, ca);\n\tfloat d = dot(abc, abc);\n\tfloat e = dot(acd, acd);\n\tfloat f = dot(bcd, bcd);\n\tfloat g = 2.0 * dot(abc, acd);\n\tfloat h = 2.0 * dot(abc, bcd);\n\tfloat j = 2.0 * dot(acd, bcd);\n\tfloat c0 = dot(ab, p) * dot(ab, p) + dot(bc, p) * dot(bc, p) + dot(ca, p) * dot(ca, p);\n\tfloat c1 = 2.0 * (dot(ab, p) * dot(ab, b) + dot(bc, p) * dot(bc, c) + dot(ca, p) * dot(ca, a));\n\tfloat c2 = 2.0 * (dot(ab, b) * dot(ab, b) + dot(bc, c) * dot(bc, c) + dot(ca, a) * dot(ca, a)) - 2.0 * (dot(ab, a) * dot(ab, b) + dot(bc, b) * dot(bc, c) + dot(ca, c) * dot(ca, a));\n\tfloat c3 = dot(ab, a) * dot(ab, a) + dot(bc, b) * dot(bc, b) + dot(ca, c) * dot(ca, c) - 2.0 * (dot(ab, a) * dot(ab, c) + dot(bc, b) * dot(bc, a) + dot(ca, c) *", "\n    return sign(cross(p-a, b-a));\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_number(in vec2 p, in vec2[] poly) {\n    float w = 0.0;\n    for (int i = 0; i < poly.length(); i++) {\n        w += winding_sign(p, poly[i], poly[i+1]);\n    }\n    return w;\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_number(in vec2 p, in vec2[] poly, in float threshold) {\n    float w = 0.0;\n    for (int i = 0; i < poly.length(); i++) {\n        w += winding_sign(p, poly[i], poly[i+1]);\n    }\n    return abs(w) > threshold? 1.0 : 0.0;\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_number(in vec2 p, in vec2[] poly, in float threshold, in float smoothness) {\n    float w = 0.0;\n    for (int i = 0; i < poly.length(); i++) {\n        w += winding_sign(p, poly[i], poly[i+1]);\n    }\n    return smoothstep(threshold-smoothness, threshold+smoothness, abs(w));\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_number(in vec2 p, in vec2[] poly, in float threshold, in float smoothness, in float offset) {\n    float w = 0.0;\n    for (int i = 0; i < poly.length(); i++) {\n        w += winding_sign(p, poly[i], poly[i+1]);\n    }\n    return smoothstep(threshold-smoothness, threshold+smoothness, abs(w+offset));\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_number(in vec2 p, in vec2[] poly, in float threshold, in float smoothness,", "\n\tvec3 p = ro - s.yzx;\n\tvec3 q = rd;\n\tvec3 r = s.yzx;\n\tvec3 t = s.zxy;\n\tvec3 u = s.xyz;\n\tvec3 v = s.zxy;\n\tvec3 w = s.yzx;\n\tvec3 x = s.xyz;\n\tvec3 y = s.zxy;\n\tvec3 z = s.yzx;\n\tfloat a = dot(q,q);\n\tfloat b = dot(p,q);\n\tfloat c = dot(p,p);\n\tfloat d = dot(r,q);\n\tfloat e = dot(r,r);\n\tfloat f = dot(r,p);\n\tfloat g = dot(t,q);\n\tfloat h = dot(t,r);\n\tfloat i = dot(t,t);\n\tfloat j = dot(t,p);\n\tfloat k = dot(u,q);\n\tfloat l = dot(u,r);\n\tfloat m = dot(u,t);\n\tfloat n = dot(u,u);\n\tfloat o = dot(u,p);\n\tfloat p1 = dot(v,q);\n\tfloat p2 = dot(v,r);\n\tfloat p3 = dot(v,t);\n\tfloat p4 = dot(v,u);\n\tfloat p5 = dot(v,v);\n\tfloat p6 = dot(v,p);\n\tfloat p7 = dot(w,q);\n\tfloat p8 = dot(w,r);\n\tfloat p9 = dot(w,t);\n\tfloat p10 = dot(w,u);\n\tfloat p11 = dot(w,v);\n\tfloat p12 = dot(w,w);\n\tfloat p13 = dot(w,p);\n\tfloat p14 = dot(x,q);\n\tfloat p15 = dot(x,r);\n\tfloat p16 = dot(x,t);\n\tfloat p17 = dot(x,u);\n\tfloat p18 = dot(x,v);\n\tfloat p19 = dot(x,w);\n\t", "\n\tint n = a * b;\n\tret_n = n;\n\treturn fract(n * (1.0 / 16777216.0) + x);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x) {\n\tint n = a * b;\n\tret_n = n;\n\treturn fract(n * (1.0 / 16777216.0) + x);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x) {\n\tint n = a * b;\n\tret_n = n;\n\treturn fract(n * (1.0 / 16777216.0) + x);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x) {\n\tint n = a * b;\n\tret_n = n;\n\treturn fract(n * (1.0 / 16777216.0) + x);\n}\n\n// https://www.shadertoy.com/", "\n\tvec3 h = max( k - abs( a - b ), 0.0 ) / k;\n\treturn a + h * ( b - a );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n\tvec3 h = max( k - abs( a - b ), 0.0 ) / k;\n\treturn a - h * ( a - b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k, in float h )\n{\n\tvec3 d = a - b;\n\tfloat m = max( k - abs( d.x ), 0.0 );\n\tfloat n = max( k - abs( d.y ), 0.0 );\n\tfloat o = max( k - abs( d.z ), 0.0 );\n\tm /= k;\n\tn /= k;\n\to /= k;\n\treturn a + vec3( m * d.x, n * d.y, o * d.z ) * ( 1.0 - h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k, in float h )\n{\n\tvec3 d = a - b;\n\tfloat m = max( k - abs( d.x ), 0.0 );\n\tfloat n = max( k - abs( d", "\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = length(p);\n\tfloat d = length(p-vec2(a,0.0));\n\tfloat e = length(p+vec2(a,0.0));\n\treturn (c-d)*(c-e);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in float angle){\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = length(p);\n\tfloat d = length(p-vec2(a,0.0));\n\tfloat e = length(p+vec2(a,0.0));\n\treturn (c-d)*(c-e)*cos(angle);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in float angle, in float angle2){\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = length(p);\n\tfloat d = length(p-vec2(a,0.0));\n\tfloat e = length(p+vec2(a,0.0));\n\treturn (c-d)*(c-e)*cos(angle)*cos(angle2);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in float angle, in float angle2, in float angle3){\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = length(p);\n\tfloat d = length(p-vec2(a,0.0));\n\tfloat e = length(p+vec2(a,0.0));\n\treturn (c-d)*(c-e)*cos(angle)*cos(angle2)*cos(angle3);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in float angle, in float", "\n\treturn a + b;\n}\n\n//precision loss testing\nvec2 add_ploss(in vec2 a, in vec2 b){\n\treturn a + b;\n}\n\n//precision loss testing\nvec3 add_ploss(in vec3 a, in vec3 b){\n\treturn a + b;\n}\n\n//precision loss testing\nvec4 add_ploss(in vec4 a, in vec4 b){\n\treturn a + b;\n}\n\n//precision loss testing\nmat2 add_ploss(in mat2 a, in mat2 b){\n\treturn a + b;\n}\n\n//precision loss testing\nmat3 add_ploss(in mat3 a, in mat3 b){\n\treturn a + b;\n}\n\n//precision loss testing\nmat4 add_ploss(in mat4 a, in mat4 b){\n\treturn a + b;\n}\n\n//precision loss testing\nfloat sub_ploss(in float a, in float b){\n\treturn a - b;\n}\n\n//precision loss testing\nvec2 sub_ploss(in vec2 a, in vec2 b){\n\treturn a - b;\n}\n\n//precision loss testing\nvec3 sub_ploss(in vec3 a, in vec3 b){\n\treturn a - b;\n}\n\n//precision loss testing\nvec4 sub_ploss(in vec4 a, in vec4 b){\n\treturn a - b;\n}\n\n//precision loss testing\nmat2 sub_ploss(in mat2 a, in mat2 b){\n\treturn a - b;\n}\n\n//precision loss testing\nmat3 sub_ploss(in mat3 a, in mat3 b){\n\treturn a - b;\n}\n\n//precision loss testing\nmat4 sub_ploss(in mat4 a, in mat4 b){\n\treturn a - b;\n}\n\n//precision loss testing\nfloat mul_ploss(in float a, in float b){\n\treturn a * b;\n}\n\n//precision loss testing\nvec2 mul_ploss(in vec2 a, in vec2 b){\n\treturn a * b;\n}\n\n//precision loss testing\nvec3 mul_ploss(", "\n\tvec2 q = p;\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = a*a - b*b;\n\tfloat d = 2.0*a*s1;\n\tfloat e = 2.0*a*s2;\n\tfloat f = s1*s1 - s2*s2;\n\tfloat g = 2.0*a*s1*s2;\n\tfloat h = s1*s1*s1 - s2*s2*s2;\n\tfloat i = 2.0*a*s1*s2*s2;\n\tfloat j = s1*s1*s1*s1 - s2*s2*s2*s2;\n\tfloat k = 2.0*a*s1*s2*s2*s2;\n\tfloat l = s1*s1*s1*s1*s1 - s2*s2*s2*s2*s2;\n\tfloat m = 2.0*a*s1*s2*s2*s2*s2;\n\tfloat n = s1*s1*s1*s1*s1*s1 - s2*s2*s2*s2*s2*s2;\n\tfloat o = 2.0*a*s1*s2*s2*s2*s2*s2;\n\tfloat p = s1*s1*s1*s1*s1*s1*s1 - s2*s2*s2*s2*s2*s2*s2;\n\tfloat q = 2.0*a*s1*s2*s2*s2*s2*s2*s2;\n\tfloat r = s1*s1*s1*s1*s1*s1*s1*s1 - s2*s2*s2*s2*s2*s2*s2*s2;\n\tfloat s = 2.0*a*s1*s2*s2*s2*s2*s2*s2*s2;\n\tfloat t = s1*s", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = dot(pa, ba) / dot(ba, ba);\n    vec3  q = a + clamp(h, 0.0, 1.0) * ba;\n    vec3  pq = p - q;\n    float d = length(pq);\n    float r = ra + rb * clamp(h, 0.0, 1.0);\n    return vec4(d - r, pq, h);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float hh = dot(pa, ba) / dot(ba, ba);\n    vec3  q = a + clamp(hh, 0.0, 1.0) * ba;\n    vec3  pq = p - q;\n    float d = length(pq);\n    float r = ra + rb * clamp(hh, 0.0, 1.0);\n    return vec4(d - r, pq, hh);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float hh)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3  q = a + clamp(hh, 0.0, 1.0) * ba;\n    vec3  pq = p - q;\n    float d = length(pq);\n    float r = ra + rb * clamp(hh, 0.0, 1.0);\n    return vec4(d - r, pq, hh);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float hh, float d)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 ", "\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  // c code\n  // float q = length(p.xz);\n  // return dot(p,c)/length(c) - q;\n\n  // optimized version from iq\n  vec2 q = vec2( dot(p.xz,c.xy), p.y );\n  vec2 w = vec2( length(p.xz) - c.x, q.y );\n  return length(max(w,0.0)) + min(max(w.x,w.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdConeSection( in vec3", "\n    return length(p-cen) - rad;\n}\n\nfloat sdBox( vec3 p, vec3 bmin, vec3 bmax )\n{\n    vec3 d = abs(p) - bmax;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( vec3 p, vec3 c, float h, float r1, float r2 )\n{\n    vec3 q = abs(p-c);\n    return (h*h+(r1-r2)*(r1-r2))/(h*length(q-vec2(max(q.x,q.z),q.y))) - r2;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),", "\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return length(p.xz-h.xy*vec2(clamp(p.y/h.y, 0.0, 1.0),1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdCone", "\n\tfloat res = 1.0;\n\tfloat t = 0.0;\n\tfloat tMax = 100.0;\n\tfloat tDelta = 0.01;\n\tfloat tMin = 0.001;\n\tfloat tMin2 = 0.0001;\n\tfloat tMax2 = 0.01;\n\tfloat tDelta2 = 0.0001;\n\tfloat tMin3 = 0.00001;\n\tfloat tMax3 = 0.001;\n\tfloat tDelta3 = 0.00001;\n\tfloat tMin4 = 0.000001;\n\tfloat tMax4 = 0.0001;\n\tfloat tDelta4 = 0.000001;\n\tfloat tMin5 = 0.0000001;\n\tfloat tMax5 = 0.00001;\n\tfloat tDelta5 = 0.0000001;\n\tfloat tMin6 = 0.00000001;\n\tfloat tMax6 = 0.000001;\n\tfloat tDelta6 = 0.00000001;\n\tfloat tMin7 = 0.000000001;\n\tfloat tMax7 = 0.0000001;\n\tfloat tDelta7 = 0.000000001;\n\tfloat tMin8 = 0.0000000001;\n\tfloat tMax8 = 0.00000001;\n\tfloat tDelta8 = 0.0000000001;\n\tfloat tMin9 = 0.00000000001;\n\tfloat tMax9 = 0.000000001;\n\tfloat tDelta9 = 0.00000000001;\n\tfloat tMin10 = 0.000000000001;\n\t", "\n\tfloat d = length(p);\n\tfloat d1 = d - ra;\n\tfloat d2 = d - rb;\n\tfloat d3 = d - he;\n\tfloat d4 = d + he;\n\tfloat d5 = d + rb;\n\tfloat d6 = d + ra;\n\tfloat d12 = d1 - d2;\n\tfloat d34 = d3 - d4;\n\tfloat d56 = d5 - d6;\n\tfloat d1234 = d12 - d34;\n\tfloat d1256 = d12 - d56;\n\tfloat d3456 = d34 - d56;\n\tfloat d123456 = d1234 - d56;\n\tfloat d1234567 = d123456 - d56;\n\tfloat d12345678 = d1234567 - d56;\n\tfloat d123456789 = d12345678 - d56;\n\tfloat d1234567890 = d123456789 - d56;\n\tfloat d12345678901 = d1234567890 - d56;\n\tfloat d123456789012 = d12345678901 - d56;\n\tfloat d1234567890123 = d123456789012 - d56;\n\tfloat d12345678901234 = d1234567890123 - d56;\n\tfloat d123456789012345 = d12345678901234 - d56;\n\tfloat d1234567890123456 = d123456789012345 - d56;\n\t", "\n\tvec2 q = vec2(length(p.xz)-ra,p.y);\n\treturn vec4( q, length(q)-rb, 1.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float r )\n{\n\tvec2 q = vec2(length(p.xz)-ra,p.y);\n\treturn vec4( q, length(q)-rb, r );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float r, float t )\n{\n\tvec2 q = vec2(length(p.xz)-ra,p.y);\n\treturn vec4( q, length(q)-rb, r, t );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float r, float t, float s )\n{\n\tvec2 q = vec2(length(p.xz)-ra,p.y);\n\treturn vec4( q, length(q)-rb, r, t, s );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float r, float t, float s, float q )\n{\n\tvec2 q1 = vec2(length(p.xz)-ra,p.y);\n\treturn vec4( q1, length(q1)-rb, r, t, s, q );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float r, float t, float s, float q, float w )\n{\n\tvec2 q1 = vec2(length(p.xz)-ra,p.y);\n\treturn vec4( q1, length(q1)-rb, r, t, s, q, w );\n", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// iq. 2013\n// https://www.shadertoy.com/view/4dS3Wd\nfloat map( vec3 p )\n{\n\tfloat d = 1e10;\n\tp.xz = mod(p.xz, 20.0) - 10.0;\n\tp.y -= 10.0;\n\tp.xz = abs(p.xz);\n\tp.xz = max(p.xz, p.yz);\n\tp.xz = max(p.xz, p.xy);\n\tp.xz = max(p.xz, p.zx);\n\tp.xz = max(p.xz, p.zy);\n\tp.xz = max(p.xz, p.yz);\n\tp.xz = max(p.xz, p.xy);\n\tp.xz = max(p.xz, p.zx);\n\tp.xz = max(p.xz, p.zy);\n\tp.xz = max(p.xz, p.yz);\n\tp.xz = max(p.xz, p.xy);\n\tp.xz = max(p.xz, p.zx);\n\tp.xz = max(p.xz, p.zy);\n\tp.xz = max(p.xz, p.yz);\n\tp.xz = max(p.xz, p.xy);\n\tp.xz = max(p.xz, p.zx);\n\tp.xz = max(p.xz, p.zy);\n\tp.xz = max(p.xz, p.yz);\n\tp.xz = max(p.xz, p.xy);\n\tp.xz = max(p.xz, p.zx);\n\tp.xz = max(p.xz, p.zy);\n\tp.xz = max(p.xz, p.yz);\n\tp.xz = max(p.xz, p.xy);\n\tp", " return dot(v, v); }\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  vec3 q = p / r;\n  return length(q) - 1.0;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdRoundEllipsoid( vec3 p, vec", "\n\tvec2 d = max(maxCorner - p, p - minCorner);\n\treturn dot(d,d);\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n\treturn sqrt(sqAABB(p, minCorner, maxCorner));\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n\treturn sqrt(sqAABB(p, minCorner, maxCorner));\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n\treturn sqrt(sqAABB(p, minCorner, maxCorner));\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float radius ) \n{\n\treturn AABB(p, minCorner, maxCorner) - radius;\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in float radius ) \n{\n\treturn AABB(p, minCorner, maxCorner) - radius;\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner, in float radius ) \n{\n\treturn AABB(p, minCorner, maxCorner) - radius;\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 radius ) \n{\n\treturn AABB(p, minCorner, maxCorner) - length(radius);\n}\n\n// Returns the distance to the closest point on the box\nfloat AABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in vec3 radius ) \n{\n\treturn AABB(p, minCorner, maxCorner) - length(radius);\n}\n\n// Returns", "\n\t// Calculate the distance from the camera to the water surface\n\tfloat dist = length(cdir);\n\t\n\t// Calculate the height of the water surface at the given UV coordinates\n\tfloat height = 0.5 * sin(uv.x * 10.0) + 0.5 * sin(uv.y * 10.0);\n\t\n\t// Calculate the normal of the water surface at the given UV coordinates\n\tvec3 normal = normalize(vec3(0.0, 1.0, 0.0));\n\t\n\t// Calculate the reflection vector\n\tvec3 reflectVec = reflect(cdir, normal);\n\t\n\t// Calculate the reflection color\n\tvec3 reflectColor = texture(reflectionTexture, reflectVec).rgb;\n\t\n\t// Calculate the refraction color\n\tvec3 refractColor = texture(refractionTexture, uv).rgb;\n\t\n\t// Calculate the final color of the water\n\tvec3 waterColor = mix(reflectColor, refractColor, height);\n\t\n\t// Return the final color of the water\n\treturn waterColor;\n}\n\n// Procedural texture generation for the sky\nvec3 sky(vec3 cdir)\n{\n\t// Calculate the distance from the camera to the sky\n\tfloat dist = length(cdir);\n\t\n\t// Calculate the height of the sky at the given UV coordinates\n\tfloat height = 0.5 * sin(cdir.x * 10.0) + 0.5 * sin(cdir.y * 10.0);\n\t\n\t// Calculate the normal of the sky at the given UV coordinates\n\tvec3 normal = normalize(vec3(0.0, 1.0, 0.0));\n\t\n\t// Calculate the reflection vector\n\tvec3 reflectVec = reflect(cdir, normal);\n\t\n\t// Calculate the reflection color\n\tvec3 reflectColor = texture(reflectionTexture, reflectVec).rgb;\n\t\n\t// Calculate the refraction color\n\tvec3 refractColor = texture(refractionTexture, vec2(0.0)).rgb;\n\t\n\t// Calculate the final color of the sky\n\tvec3 skyColor = mix(reflectColor, refractColor, height);\n\t\n\t// Return the final color of the sky\n\treturn skyColor;\n}\n\n// Procedural texture generation for the ground\nvec3 ground", "\n\tvec3 dir = vec3(uv, 1.0) * 2.0 - 1.0;\n\tdir.z = -1.0;\n\tdir = normalize(dir);\n\tdir = rotate(dir, camrot);\n\tdir = dir * camzoom + camorigin;\n\treturn dir;\n}\n\n// Camera perspective based on [-1..1] viewport\nvec3 pixtoray2(vec2 uv)\n{\n\tvec3 dir = vec3(uv, 1.0);\n\tdir = normalize(dir);\n\tdir = rotate(dir, camrot);\n\tdir = dir * camzoom + camorigin;\n\treturn dir;\n}\n\n// Camera perspective based on [-1..1] viewport\nvec3 pixtoray3(vec2 uv)\n{\n\tvec3 dir = vec3(uv, 1.0);\n\tdir = normalize(dir);\n\tdir = rotate(dir, camrot);\n\tdir = dir * camzoom + camorigin;\n\treturn dir;\n}\n\n// Camera perspective based on [-1..1] viewport\nvec3 pixtoray4(vec2 uv)\n{\n\tvec3 dir = vec3(uv, 1.0);\n\tdir = normalize(dir);\n\tdir = rotate(dir, camrot);\n\tdir = dir * camzoom + camorigin;\n\treturn dir;\n}\n\n// Camera perspective based on [-1..1] viewport\nvec3 pixtoray5(vec2 uv)\n{\n\tvec3 dir = vec3(uv, 1.0);\n\tdir = normalize(dir);\n\tdir = rotate(dir, camrot);\n\tdir = dir * camzoom + camorigin;\n\treturn dir;\n}\n\n// Camera perspective based on [-1..1] viewport\nvec3 pixtoray6(vec2 uv)\n{\n\tvec3 dir = vec3(uv, 1.0);\n\tdir = normalize(dir);\n\tdir = rotate(dir, camrot);\n\tdir = dir * camzoom + camorigin;\n\treturn dir;\n}\n\n// Camera perspective based on [-1..1] viewport\nvec3 pixtoray7(vec2 uv)\n{\n\tvec3", "\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n\treturn vec4(q1.xyz * q2.w + q1.w * q2.xyz + cross(q1.xyz, q2.xyz), q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(mat3 q, vec3 v)\n{\n\treturn v + 2.0 * cross(q[0].xyz, cross(q[0].xyz, v) + q[0].w * v);\n}\n\n// Quaternion-vector multiplication\nvec4 quatmul(mat4 q, vec4 v)\n{\n\treturn vec4(q[0].xyz * v.w + q[0].w * v.xyz + cross(q[0].xyz, v.xyz), q[0].w * v.w - dot(q[0].xyz, v.xyz));\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(mat3 q, vec4 v)\n{\n\treturn v.xyz + 2.0 * cross(q[0].xyz, cross(q[0].xyz, v.xyz) + q[0].w * v.xyz);\n}\n\n// Quaternion-vector multiplication\nvec4 quatmul(mat4 q, vec3 v)\n{\n\treturn vec4(q[0].xyz * v.w + q[0].w * v.xyz + cross(q[0].xyz, v.xyz), q[0].w * v.w - dot(q[0].xyz, v.xyz));\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(mat3 q, mat3 v)\n{\n\treturn v[0].xyz + 2.0 * cross(q[0].xyz, cross(q[0].xyz, v[0].xyz) + q[0].w * v[0].xyz);\n}\n\n// Quaternion-vector multiplication\nvec4 quatmul(mat4 q, mat", "\n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.866025,0.5,0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy,p.xy),0.0)*k.xy;\n  p.z -= h.y;\n  return length(max(p,0.0)) + min(max(p.x,p.y),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  // from iq: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 w = vec2(", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.866025,0.5,0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy,p.xy),0.0)*k.xy;\n  p.z -= h.y;\n  return length(max(p,0.0)) + min(max(p.x,p.y),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n", "\n\treturn (m.x < d)? vec2(m.x, m.y) : vec2(d, a);\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n\treturn (m.x < d)? vec2(m.x, m.y) : vec2(m.x - d, a);\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n\treturn (m.x > d)? vec2(m.x, m.y) : vec2(d, a);\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n\tfloat h = clamp( 0.5 + 0.5*(d-m.x)/a, 0.0, 1.0 );\n\treturn vec2( mix( m.x, d, h ) - a*h*(1.0-h), m.y );\n}\n\nvec2 opSmoothSubtraction( vec2 m, float d, float a )\n{\n\tfloat h = clamp( 0.5 - 0.5*(d+m.x)/a, 0.0, 1.0 );\n\treturn vec2( mix( m.x, d, h ) + a*h*(1.0-h), m.y );\n}\n\nvec2 opSmoothIntersection( vec2 m, float d, float a )\n{\n\tfloat h = clamp( 0.5 - 0.5*(d-m.x)/a, 0.0, 1.0 );\n\treturn vec2( mix( m.x, d, h ) + a*h*(1.0-h), m.y );\n}\n\nvec2 opSmoothUnion( vec2 m, vec2 d, float a )\n{\n\tfloat h = clamp( 0.5 + 0.5*(d.x-m.x)/a, 0.0, 1.0 );\n\treturn vec2( mix( m.x, d.x, h ) - a*h*(1.0-h), mix( m.y, d.y, h ) );\n}\n\nvec2 opSmooth", "\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ro );\n    float c = dot( ro, ro ) - rad * rad;\n    float d = b * b - 4.0 * a * c;\n    if( d < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n    }\n    else\n    {\n        float t = (-b - sqrt( d )) / (2.0 * a);\n        p1 = vec4( ro + rd * t, t );\n        t = (-b + sqrt( d )) / (2.0 * a);\n        p2 = vec4( ro + rd * t, t );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectSphere( in vec3 ro, in vec3 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ro );\n    float c = dot( ro, ro ) - rad * rad;\n    float d = b * b - 4.0 * a * c;\n    if( d < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n    }\n    else\n    {\n        float t = (-b - sqrt( d )) / (2.0 * a);\n        p1 = vec4( ro + rd * t, t );\n        t = (-b + sqrt( d )) / (2.0 * a);\n        p2 = vec4( ro + rd * t, t );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectBox( in vec3 ro, in vec3 rd, in vec3 boxmin, in vec3 boxmax, out vec4 p1, out vec4 p2 )\n{\n    vec3 invR = 1.0 / rd;\n    vec3 n = invR * rd;\n    vec3 k = abs( invR ) * ( boxmax - boxmin );\n    vec3 t1 = - ( boxmin - ro ) * invR;\n    vec3 t2", "\n    vec2 q = p - c;\n    float d = length(q);\n    return vec3(d - r, q / d, 0.0);\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b ) \n{\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)), sign(p)*clamp(d,0.0,1.0));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r, sign(p)*clamp(d,0.0,1.0));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r, in float f ) \n{\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r, sign(p)*clamp(d,0.0,1.0), f);\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r, in float f, in float g ) \n{\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r, sign(p)*clamp(d,0.0,1.0), f, g);\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r, in float f, in float g, in float h ) \n{\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r, sign(p)*clamp(d,0.0,1.0), f, g,", "\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0), sign(p.x)*step(b.x,abs(p.x)) - sign(p.y)*step(b.y,abs(p.y)), 0.0);\n}\n\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    return vec3(length(p)-r, 0.0, 0.0);\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float d )\n{\n    return vec3(length(p)-r, 0.0, d);\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float d, in float w )\n{\n    return vec3(length(p)-r, 0.0, d - w);\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float d, in float w, in float a )\n{\n    return vec3(length(p)-r, 0.0, d - w*cos(a));\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float d, in float w, in float a, in float b )\n{\n    return vec3(length(p)-r, 0.0, d - w*cos(a)*cos(b));\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float d, in float w, in float a, in float b, in float c )\n{\n    return vec3(length(p)-r, 0.0, d - w*cos(a)*cos(b)*cos(c));\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float d, in float w, in float a, in float b, in float c, in float s )\n{\n    return vec3(length(p)-r, 0.0, d - w*cos(a)*cos(b)*cos(c)*sin(s));\n}\n\nvec3 sdgCircle( in vec2 p, in", "\n    float a = 0.5 + 0.5 * sin( iTime );\n    float b = 0.5 + 0.5 * cos( iTime );\n    float c = 0.5 + 0.5 * sin( iTime * 0.5 );\n    float d = 0.5 + 0.5 * cos( iTime * 0.5 );\n    float e = 0.5 + 0.5 * sin( iTime * 0.25 );\n    float f = 0.5 + 0.5 * cos( iTime * 0.25 );\n    float g = 0.5 + 0.5 * sin( iTime * 0.125 );\n    float h = 0.5 + 0.5 * cos( iTime * 0.125 );\n    float i = 0.5 + 0.5 * sin( iTime * 0.0625 );\n    float j = 0.5 + 0.5 * cos( iTime * 0.0625 );\n    float k = 0.5 + 0.5 * sin( iTime * 0.03125 );\n    float l = 0.5 + 0.5 * cos( iTime * 0.03125 );\n    float m = 0.5 + 0.5 * sin( iTime * 0.015625 );\n    float n = 0.5 + 0.5 * cos( iTime * 0.015625 );\n    float o = 0.5 + 0.5 * sin( iTime * 0.0078125 );\n    float p = 0.5 + 0.5 * cos( iTime * 0.0078125 );\n    float q = 0.5 + 0.5 * sin( iTime * 0.00390625 );\n    float r = 0.5 + 0.5 * cos( iTime * 0.00390625 );\n    float s = 0.5 + 0.5 * sin( iTime * 0.001953125 );\n    float", "\n  float a = a1 - a2;\n  float b = b1 - b2;\n  float c = a1 * a1 + b1 * b1 - a2 * a2 - b2 * b2;\n  float d = 2 * (a * x + b * y);\n  float e = x * x + y * y - 1;\n  return (a * x + b * y + sqrt(c - d + e * e)) / (2 * e);\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/333333333333333\nfloat h(float a1, float b1, float a2, float b2, float x) {\n  float a = a1 - a2;\n  float b = b1 - b2;\n  float c = a1 * a1 + b1 * b1 - a2 * a2 - b2 * b2;\n  float d = 2 * (a * x + b * y);\n  float e = x * x + y * y - 1;\n  return (a * x + b * y - sqrt(c - d + e * e)) / (2 * e);\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/333333333333333\nfloat i(float a1, float b1, float a2, float b2, float x) {\n  float a = a1 - a2;\n  float b = b1 - b2;\n  float c = a1 * a1 + b1 * b1 - a2 * a2 - b2 * b2;\n  float d = 2 * (a * x + b * y);\n  float e = x * x + y * y - 1;\n  return (a * x + b * y + sqrt(c - d - e * e)) / (2 * e);\n}\n\n// Instant push -> wobble (yellow)\n// https://www.desmos.com/calculator/333333333333333\nfloat j(float a1, float b1, float a2, float", "\n    float y = 0.0;\n    float t = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float a1 = 0.0;\n    float a2 = 0.0;\n    float a3 = 0.0;\n    float a4 = 0.0;\n    float a5 = 0.0;\n    float a6 = 0.0;\n    float", "\n                float t = iTime;\n                float a = 0.0;\n                float b = 0.0;\n                float c = 0.0;\n                float d = 0.0;\n                float e = 0.0;\n                float f = 0.0;\n                float g = 0.0;\n                float h = 0.0;\n                float i = 0.0;\n                float j = 0.0;\n                float k = 0.0;\n                float l = 0.0;\n                float m = 0.0;\n                float n = 0.0;\n                float o = 0.0;\n                float p = 0.0;\n                float q = 0.0;\n                float r = 0.0;\n                float s = 0.0;\n                float t = 0.0;\n                float u = 0.0;\n                float v = 0.0;\n                float w = 0.0;\n                float x = 0.0;\n                float y = 0.0;\n                float z = 0.0;\n                float aa = 0.0;\n                float ab = 0.0;\n                float ac = 0.0;\n                float ad = 0.0;\n                float ae = 0.0;\n                float af = 0.0;\n                float ag = 0.0;\n                float ah = 0.0;\n                float ai = 0.0;\n                float aj = 0.0;\n                float ak = 0.0;\n                float al = 0.0;\n                float am = 0.0;\n                float an = 0.0;\n                float ao = 0.0;\n                float ap = 0.0;\n                float aq = 0.0;\n                float ar = 0.0;\n                float as = 0.0;\n                float at = 0.0;\n                float au = 0.0;\n                float av = 0.0;\n                float aw = 0.0;\n                float ax = 0.0;\n                float ay = 0.0;\n                float az = 0.0;\n                float ba = 0.0;\n                float bb = 0.0;\n                float bc = 0.0;\n                float bd = 0.0;", "\n    vec3 c = vec3(0.0);\n    for( int i = 0; i < 3; i++ )\n    {\n        for( int j = 0; j < 3; j++ )\n        {\n            c += texture( tex, vec2(x+i,y+j) ).rgb;\n        }\n    }\n    return c/9.0;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec3 c = compute( int(uv.x*iResolution.x), int(uv.y*iResolution.y) );\n    gl_FragColor = vec4(c,1.0);\n}\n", "\n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexagon( in vec2 p, in vec2 c, in float r )\n{\n    vec2 k = vec2(-0.86602540378443864676372317075294,0.5);\n    p = abs(p-c);\n    p -= r*k;\n    return max(max(p.x,p.y),dot(p,k));\n}\n\nfloat sdHexagon( in vec2 p, in vec2 c, in float r, in float s )\n{\n    vec2 k = vec2(-0.86602540378443864676372317075294,0.5);\n    p = abs(p-c);\n    p -= r*k;\n    return max(max(p.x,p.y),dot(p,k))-s;\n}\n\nfloat sdHexagon( in vec2 p, in vec2 c, in float r, in float s, in float t )\n{\n    vec2 k = vec2(-0.86602540378443864676372317075294,0.5);\n    p = abs(p-c);\n    p -= r*k;\n    return max(max(p.x,p.y),dot(p,k))-s-t;\n}\n\nfloat sdHexagon( in vec2 p, in vec2 c, in float r, in float s, in float t, in float u )\n{\n    vec2 k = vec2(-0.86602540378443864676372317075294,0.5);\n    p = abs(p-c);\n    p -= r", "\n    vec2 q = abs(p) - c;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*smoothstep(0.0,1.0,h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 q = abs(p-c);\n    return max(q.x*0.866025+q.y*0.5, -q.y)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in vec2 c, in float r, in float w ) \n{\n    vec2 q = abs(p-c);\n    return max(q.x*0.866025+q.y*0.5, -q.y)-r-w;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in vec2 c, in", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length(pa-ba*h), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn vec2(length(p-a)-length(b-a),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdCircle( in vec2 p, in float r )\n{\n\treturn vec2(length(p)-r,0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn vec2(length(max(d,0.0)) + min(max(d.x,d.y),0.0),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n\tvec2 q = abs(p)-b;\n\treturn vec2(length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r,0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdHexagon( in vec2 p, in float r )\n{\n\tvec2 q = abs(p);\n\treturn vec2(max(q.y-r,max(q.x-r*0.866025,q.x*0.866025+q.y)-r),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdTriangle( in vec2 p, in vec2 a, in vec2 b, in", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h*h;\n    float k2 = dot(ba,ba);\n    float e = clamp( 1.0 - h2/k2, 0.0, 1.0 );\n    float q = sqrt( e*e - 1.0 );\n    vec2 c = a + ba*e + cross( vec2(q,e), ba )*h;\n    vec2 d = a + ba*e - cross( vec2(q,e), ba )*h;\n    vec2 m = -dot(pa,ba)/k2*ba;\n    float s = sign( dot(m,pa) );\n    float t = clamp( dot(m,p-c), 0.0, 1.0 );\n    float u = clamp( dot(m,p-d), 0.0, 1.0 );\n    vec2  n = (t>u)? c : d;\n    float r = length(p-n);\n    float d2 = dot(p-n,p-n);\n    return vec2( s*r, d2min > d2? d2 : d2min );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdArc( in vec2 p, in vec2 a, in vec2 b, in float h )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h*h;\n    float k2 = dot(ba,ba);\n    float e = clamp( 1.0 - h2/k2, 0.0, 1.0 );\n    float q = sqrt( e*e - 1.0 );\n    vec2 c = a + ba*e + cross( vec2(q,e), ba )*h;\n    vec2 d = a + ba*e - cross( vec2(q,e), ba )*h;\n    float s = sign( dot(ba,pa) );\n    float t = clamp( dot(ba,p-c), 0.0, 1.0 );\n    float u = clamp( dot(ba,p-d), 0.0, 1.0 );\n    vec2  n", "\n\tfloat d = 1e30;\n\tfloat d1;\n\tfloat d2;\n\tfloat d3;\n\tfloat d4;\n\tfloat d5;\n\tfloat d6;\n\tfloat d7;\n\tfloat d8;\n\tfloat d9;\n\tfloat d10;\n\tfloat d11;\n\tfloat d12;\n\tfloat d13;\n\tfloat d14;\n\tfloat d15;\n\tfloat d16;\n\tfloat d17;\n\tfloat d18;\n\tfloat d19;\n\tfloat d20;\n\tfloat d21;\n\tfloat d22;\n\tfloat d23;\n\tfloat d24;\n\tfloat d25;\n\tfloat d26;\n\tfloat d27;\n\tfloat d28;\n\tfloat d29;\n\tfloat d30;\n\tfloat d31;\n\tfloat d32;\n\tfloat d33;\n\tfloat d34;\n\tfloat d35;\n\tfloat d36;\n\tfloat d37;\n\tfloat d38;\n\tfloat d39;\n\tfloat d40;\n\tfloat d41;\n\tfloat d42;\n\tfloat d43;\n\tfloat d44;\n\tfloat d45;\n\tfloat d46;\n\tfloat d47;\n\tfloat d48;\n\tfloat d49;\n\tfloat d50;\n\tfloat d51;\n\tfloat d52;\n\tfloat d53;\n\tfloat d54;\n\tfloat d55;\n\tfloat d56;\n\tfloat d57;\n\tfloat d58;\n\tfloat d59;\n\tfloat d60;\n\tfloat d61;\n\tfloat d62;\n\tfloat d63;\n\tfloat d64;\n\tfloat d65;\n\tfloat d66;\n\tfloat d67;\n\tfloat d68;\n\tfloat d69;\n\tfloat d70;\n\tfloat d71;\n\tfloat d72;\n\tfloat d73", "\n    float d = sdCircle(p, 0.5);\n    return max(d, -d);\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return -max(d, -d);\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return -min(d, -d);\n}\n\n// correct outside, incorrect inside\nfloat sdD( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return min(d, -d);\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return -abs(d);\n}\n\n// correct outside, incorrect inside\nfloat sdF( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return abs(d);\n}\n\n// correct inside, incorrect outside\nfloat sdG( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return -sign(d);\n}\n\n// correct outside, incorrect inside\nfloat sdH( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return sign(d);\n}\n\n// correct inside, incorrect outside\nfloat sdI( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return -step(0.0, d);\n}\n\n// correct outside, incorrect inside\nfloat sdJ( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return step(0.0, d);\n}\n\n// correct inside, incorrect outside\nfloat sdK( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);\n    return -smoothstep(0.0, 0.5, d);\n}\n\n// correct outside, incorrect inside\nfloat sdL( in vec2 p )\n{\n    float d = sdCircle(p, 0.5);", "\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdF( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdG( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdH( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0),0.0))-0.1;\n}\n\n// correct inside, incorrect outside\nfloat sdI( in vec2 p )\n{\n    vec2 q = vec2(abs(p.x),p.y);\n    return length(max(q-vec2(0.2,0.0", "\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern2( in vec2 uv )\n{\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern3( in vec2 uv )\n{\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern4( in vec2 uv )\n{\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern5( in vec2 uv )\n{\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern6( in vec2 uv )\n{\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern7( in vec2 uv )\n{\n\tvec2 grid = floor( uv * 10.0 );\n\tfloat v = mod( grid.x + grid.y, 2.0 );\n\treturn vec3( v );\n}\n\n// Generate", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn mix( a, b, h ) + pa - ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn mix( a, b, h );\n}\n\n// Closest point on ray\nvec2 cloRay( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn a + ba*h;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r )\n{\n\tvec2 pc = p - c;\n\tfloat d = length(pc);\n\treturn c + pc*(r/d);\n}\n\n// Closest point on ellipse\nvec2 cloEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n\tvec2 pc = p - c;\n\tfloat d = length(pc);\n\treturn c + pc*(r/d);\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 c, in vec2 r )\n{\n\tvec2 pc = p - c;\n\tvec2 q = abs(pc) - r;\n\treturn c + pc - 2.0*clamp(q,0.0,1.0);\n}\n\n// Closest point on rounded rectangle\nvec2 cloRoundRect( in vec2 p, in vec2 c, in vec2 r, in float th )\n{\n\tvec2 pc = p - c;\n\tvec2 q =", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\n// distance to rectangle\nfloat sdRectangle( in vec2 p, in vec2 s, in vec2 r )\n{\n\tvec2 q = abs(p) - s + r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// distance to rounded rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 q = abs(p)-b+r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.x*r.y*8.0;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2[] ps, in int n )\n{\n\tfloat d = 1e38;\n\tfor( int i=0; i<n-1; i++ )\n\t{\n\t\tvec2 a = ps[i], b = ps[i+1];\n\t\td = min(d, sdSegment(p,a,b,0.05));\n\t}\n\tvec2 a = ps[n-1], b = ps[0];\n\td = min(d, sdSegment(p,a,b,0.05));\n\treturn d;\n}\n\n// distance to star\n", "\n    vec2 q = abs(p) - b;\n    return length(q) > r? vec2(0.0) : q;\n}\n\n// rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    vec2 q = cloRoundBox(p,b,r);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float s )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - s;\n}\n\n// rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float s, float e )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - s - e;\n}\n\n// rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float s, float e, float f )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - s - e - f;\n}\n\n// rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float s, float e, float f, float g )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q", "\n  vec2 q = abs(p)-b+r;\n  return length(max(q,0.0))-r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n  vec3 q = abs(p)-b+r;\n  return length(max(q,0.0))-r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r )\n{\n  vec4 q = abs(p)-b+r;\n  return length(max(q,0.0))-r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 q = abs(p)-b+r;\n  return length(max(q,0.0))-min(max(q.x,q.y),0.0);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n  vec3 q = abs(p)-b+r;\n  return length(max(q,0.0))-min(max(max(q.x,q.y),q.z),0.0);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r )\n{\n  vec4 q = abs(p)-b+r;\n  return length(max(q,0.0))-min(max(max(max(q.x,q.y),q.z),q.w),0.0);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r, float k )\n{\n  vec2 q = abs(p)-b+r;\n  return length(max(q,0.0))-r*k;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float k )\n{\n  vec3 q = abs(p)-b+r;\n  return length(max(q,0.0))-r*k;\n}", "\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0))-r*min(max(q.x,q.y),0.0);\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\n// distance to rounded circle\nfloat sdRoundCircle( in vec2 p, in float r, in float r2 )\n{\n  return length(p)-r-r2*clamp(length(p)-r,0.0,1.0);\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 b )\n{\n  return length(p/b);\n}\n\n// distance to rounded ellipse\nfloat sdRoundEllipse( in vec2 p, in vec2 b, in float r )\n{\n  return length((p-b*clamp(length(p)/length(b),0.0,1.0))/vec2(b.x-r,b.y));\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2[] ps )\n{\n  float d = 1e30;\n  for( int i = 0; i < ps.length; i++ )\n  {\n    vec2 a = ps[i];\n    vec2 b = ps[(i+1)%ps.length];\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    d = min( d, length( pa - ba*h ) );\n  }\n  return d;\n}\n\n// distance to star\nfloat sdStar( in vec2 p, in float r, in float ra, in int n )\n{\n  float d = 1e30;\n  for( int i = 0; i < n;", "\n\tp = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x*9e-1)*43758.5453123);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tp = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x*9e-1)*43758.5453123);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tp = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x*9e-1)*43758.5453123);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tp = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x*9e-1)*43758.5453123);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shader", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 43.758))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 43.758, 12.9892))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(int x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(uint x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x, float seed)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * seed);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x, float seed)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 43.758))) * seed);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x, float seed)\n{\n    return fract(sin(dot(x, vec4(12", "\n    st = vec2(dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From iq\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// From iq\nfloat fbm(vec2 st){\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i) {\n        v += a * noise(st);\n        st = rot * st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// From iq\nfloat fbm(vec2 st, float scale){\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix(rand(vec2(n+  0.0,n+  0.0)),rand(vec2(n+  1.0,n+  0.0)),f.x),\n                    mix(rand(vec2(n+  0.0,n+  1.0)),rand(vec2(n+  1.0,n+  1.0)),f.x),f.y);\n    return res;\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + p.z*113.0;\n\n    float res = mix(mix(mix(rand(vec2(n+  0.0,n+  0.0)),rand(vec2(n+  1.0,n+  0.0)),f.x),\n                        mix(rand(vec2(n+  0.0,n+  1.0)),rand(vec2(n+  1.0,n+  1.0)),f.x),f.y),\n                    mix(mix(rand(vec2(n+  1.0,n+  0.0)),rand(vec2(n+  2.0,n+  0.0)),f.x),\n                        mix(rand(vec2(n+  1.0,n+  1.0)),rand(vec2(n+  2.0,n+  1.0)),f.x),f.y),f.z);\n    return res;\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D simplex noise\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n// First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4", "\n    float a = atan(x.y, x.x);\n    float r = length(x);\n    float c = cos(a);\n    float s = sin(a);\n    return 0.5 + 0.5 * cos(r * 6.0 - 8.0 * a + 6.2831 * c);\n}\n\n// A simple checkerboard pattern\nfloat checker(vec2 x)\n{\n    return mod(floor(x.x) + floor(x.y), 2.0);\n}\n\n// A simple gradient pattern\nfloat gradient(vec2 x)\n{\n    return fract(x.x + x.y);\n}\n\n// A simple radial gradient pattern\nfloat radialGradient(vec2 x)\n{\n    return length(x);\n}\n\n// A simple radial gradient pattern with a checkerboard pattern\nfloat radialGradientChecker(vec2 x)\n{\n    return fract(length(x) + checker(x));\n}\n\n// A simple radial gradient pattern with a warp pattern\nfloat radialGradientWarp(vec2 x)\n{\n    return fract(length(x) + pattern(x));\n}\n\n// A simple radial gradient pattern with a checkerboard pattern and a warp pattern\nfloat radialGradientCheckerWarp(vec2 x)\n{\n    return fract(length(x) + checker(x) + pattern(x));\n}\n\n// A simple radial gradient pattern with a checkerboard pattern and a warp pattern, with a random offset\nfloat radialGradientCheckerWarpRandom(vec2 x)\n{\n    return fract(length(x) + checker(x) + pattern(x + random2(x)));\n}\n\n// A simple radial gradient pattern with a checkerboard pattern and a warp pattern, with a random offset and a random scale\nfloat radialGradientCheckerWarpRandomScale(vec2 x)\n{\n    return fract(length(x) * random2(x) + checker(x) + pattern(x + random2(x)));\n}\n\n// A simple radial gradient pattern with a checkerboard pattern and a warp pattern, with a random offset and a random scale, and a random rotation\nfloat radialGradientCheckerWarpRandomScaleRotate(vec2 x)\n{\n    float a = atan(x.y, x.x);\n    float r = length", "\n    float z = 1.0f - x - y;\n    float s = (x + y + z) / 3.0f;\n    return 4.0f * atanf(sqrtf(max(0.0f, s)));\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    float a = areaElement(x, y);\n    return a * a;\n}\n\n//\n// Convert a direction vector to a cube face index.\n//\n// The direction vector is assumed to be normalized.\n//\n// The cube face index is in the range [0, 5].\n//\n// The cube face index is the same as the index of the face in the\n// face array.\n//\nint directionToCubeFace(const glm::vec3& direction)\n{\n    int face = 0;\n    if (direction.x < 0.0f)\n    {\n        face = 1;\n    }\n    else if (direction.y < 0.0f)\n    {\n        face = 2;\n    }\n    else if (direction.z < 0.0f)\n    {\n        face = 3;\n    }\n    else if (direction.x > 0.0f)\n    {\n        face = 4;\n    }\n    else if (direction.y > 0.0f)\n    {\n        face = 5;\n    }\n    return face;\n}\n\n//\n// Convert a direction vector to a cube face index and a UV coordinate.\n//\n// The direction vector is assumed to be normalized.\n//\n// The cube face index is in the range [0, 5].\n//\n// The cube face index is the same as the index of the face in the\n// face array.\n//\n// The UV coordinate is in the range [0, 1].\n//\nvoid directionToCubeFaceUV(const glm::vec3& direction, int& face, glm::vec2& uv)\n{\n    face = directionToCubeFace(direction);\n    float x = direction.x;\n    float y = direction.y;\n    float z = direction.z;\n    switch (face)\n    {\n    case 0:\n        uv = glm::vec2(1.0f - x, 1.0f - y);\n        break;\n    case 1:", "\n\tp3 = fract(p3 * vec3(.1031,.1030,.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(dot(hash33(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),\n\t\tdot(hash33(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),\n\t\tmix(dot(hash33(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),\n\t\t\tdot(hash33(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),\n\t\tmix(mix(dot(hash33(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),\n\t\t\tdot(hash33(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),\n\t\t\tmix(dot(hash33(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.", "\n    const float F3 = 1.0/3.0;\n    const float G3 = 1.0/6.0;\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    vec4 w, d;\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    w = max(0.6 - w, 0.0);\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    w *= w;\n    w *= w;\n    d *= w;\n    return dot(d, vec4(52.0));\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex4d(vec4 p) {\n    const float F4 = (sqrt(5.0) - 1.0)/4.0;\n    const float G4 = (5.0 - sqrt(5.0))/20.0;\n    vec4 s = floor(p + dot(p, vec4(F4)));\n    vec4 x = p - s + dot(s, vec4(G4));\n    vec4 e = step(vec4(0.0), x - x.yzxw);\n    vec4 i1 = e*(1", "\n    return fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 1D simplex noise\nfloat snoise( in float x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    vec2  d0 = vec2(0.0, 0.0);\n    vec2  d1 = vec2(0.0, 1.0);\n    vec2  offset = 57.0*vec2(1.0, 0.0);\n\n    vec2  mg, mg0, mg1;\n    mg0 = 0.5 - vec2(dot(hash(n+d0.xy), f.yx), dot(hash(n+d0.yx), f.xy));\n    mg1 = 0.5 - vec2(dot(hash(n+d1.xy), f.yx), dot(hash(n+d1.yx), f.xy));\n    mg = mg0*mg0 + mg1*mg1;\n\n    return 0.5 + dot(mg, mg);\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    vec2  d0 = vec2(0.0, 0.0);\n    vec2  d1 = vec2(1.0, 0.0);\n    vec2  offset = 57.0*vec2(1.0, 0.0);\n\n    vec2  mg0, mg1;\n    mg0 = 0.5 - vec2(dot(hash(n+d0.xy), f.yx), dot(hash(n+d0.yx), f.xy));\n   ", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// 2D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec3 st) {\n    vec2 i = floor(st.xy);\n    vec2 f = fract(st.xy);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Noise based on <NAME> @morgan3d\n// https://www.", "\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    vec4 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y", "\n    vec3 proj_center_3d = proj_info.x * center + proj_info.y * normal;\n    proj_center = proj_center_3d.xy / proj_center_3d.z;\n    vec3 major_3d = proj_info.x * center + proj_info.y * (normal + vec3(0, 0, 1));\n    major = major_3d.xy / major_3d.z;\n    vec3 minor_3d = proj_info.x * center + proj_info.y * (normal + vec3(0, 0, -1));\n    minor = minor_3d.xy / minor_3d.z;\n    major -= proj_center;\n    minor -= proj_center;\n    float major_len = length(major);\n    float minor_len = length(minor);\n    major /= major_len;\n    minor /= minor_len;\n    float major_minor_ratio = major_len / minor_len;\n    float major_minor_ratio_sq = major_minor_ratio * major_minor_ratio;\n    float major_minor_ratio_sq_inv = 1.0 / major_minor_ratio_sq;\n    float major_minor_ratio_sq_inv_sqrt = sqrt(major_minor_ratio_sq_inv);\n    float major_minor_ratio_inv = 1.0 / major_minor_ratio;\n    float major_minor_ratio_inv_sqrt = sqrt(major_minor_ratio_inv);\n    float major_minor_ratio_inv_sqrt_sq = major_minor_ratio_inv_sqrt * major_minor_ratio_inv_sqrt;\n    float major_minor_ratio_inv_sqrt_sq_inv = 1.0 / major_minor_ratio_inv_sqrt_sq;\n    float major_minor_ratio_inv_sqrt_sq_inv_sqrt = sqrt(major_minor_ratio_inv_sqrt_sq_inv);\n    float major_minor_ratio_inv_sqrt_sq_inv_sqrt_sq = major_minor_ratio_inv_sqrt_sq_inv_sqrt * major_minor_ratio_inv_sqrt_sq_inv_sqrt;\n    float major_minor_ratio_inv_sqrt_sq_inv_sqrt_sq_inv = 1", "\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p.x)*91.0+sin(p.y)*19.0);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\t\n\tfloat a = Hash12(i);\n\tfloat b = Hash12(i + vec2(1.0, 0.0));\n\tfloat c = Hash12(i + vec2(0.0, 1.0));\n\tfloat d = Hash12(i + vec2(1.0, 1.0));\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\t\n\treturn mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p)\n{\n\tfloat f = 0.0;\n\tf += 0.5000*noise(p); p = 2.0*p;\n\tf += 0.2500*noise(p); p = 2.0*p;\n\tf += 0.1250*noise(p); p = 2.0*p;\n\tf += 0.0625*noise(p);\n\treturn f/0.9375;\n}\n\nfloat fbm(vec2 p, float scale)\n{\n\tfloat f = 0.0;\n\tf += 0.5000*noise(p*scale); p = 2.0*p;\n\tf += 0.2500*noise(p*scale); p = 2.0*p;\n\tf += 0.1250*noise(p*scale); p = 2.0*p;\n\tf += 0.0625*noise(p*scale);\n\treturn f/", "\n\tfloat d = length(p);\n\tfloat a = atan(p.y, p.x);\n\tfloat b = acos(clamp(dot(p, acs) / (d * length(acs)), -1.0, 1.0));\n\tfloat s = sign(dot(p, acs));\n\tfloat t = mod(b / an + s * 0.5, 1.0);\n\tfloat c = cos(t * an);\n\tfloat n = floor(t * bn);\n\tfloat f = fract(t * bn);\n\tfloat g = 1.0 - f;\n\tfloat h = 1.0 - c;\n\tfloat i = 1.0 - g * h;\n\tfloat j = 1.0 - f * h;\n\tfloat k = 1.0 - f * c;\n\tfloat l = 1.0 - g * c;\n\tfloat o = 1.0 - f * g * h;\n\tfloat p = 1.0 - f * g * c;\n\tfloat q = 1.0 - f * h * c;\n\tfloat u = 1.0 - g * h * c;\n\tfloat v = 1.0 - f * g * h * c;\n\tfloat w = 1.0 - f * g * h * i;\n\tfloat x = 1.0 - f * g * h * j;\n\tfloat y = 1.0 - f * g * h * k;\n\tfloat z = 1.0 - f * g * h * l;\n\tfloat A = 1.0 - f * g * h * i * j;\n\tfloat B = 1.0 - f * g * h * i * k;\n\tfloat C = 1.0 - f * g * h * i * l;\n\tfloat D = 1.0 - f * g * h * j * k;\n\tfloat E = 1.0 - f * g * h * j * l;\n\tfloat F = 1.0 - f * g * h * k * l;\n\tfloat G = 1.0 - f * g * h * i * j * k;\n\tfloat H = ", "\n    vec3 n = vec3(0.0);\n    n += 0.57735026919*vec3( 1.0, 1.0, 1.0);\n    n += 0.57735026919*vec3(-1.0, 1.0, 1.0);\n    n += 0.57735026919*vec3( 1.0,-1.0, 1.0);\n    n += 0.57735026919*vec3(-1.0,-1.0, 1.0);\n    n += 0.57735026919*vec3( 1.0, 1.0,-1.0);\n    n += 0.57735026919*vec3(-1.0, 1.0,-1.0);\n    n += 0.57735026919*vec3( 1.0,-1.0,-1.0);\n    n += 0.57735026919*vec3(-1.0,-1.0,-1.0);\n    n = normalize(n);\n    return normalize(n);\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p, float t )\n{\n    vec3 n = vec3(0.0);\n    n += 0.57735026919*vec3( 1.0, 1.0, 1.0);\n    n += 0.57735026919*vec3(-1.0, 1.0, 1.0);\n    n += 0.57735026919*vec3( 1.0,-1.0, 1.0);\n    n += 0.57735026919*vec3(-1.0,-1.0, 1.0);\n    n += 0.57735026919*vec3(", "\n\tfloat res = 1.0;\n\tfor(int i=0; i<NUM_SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(ro + rd*t0).x;\n\t\tres = min(res, 8.0*h/t0);\n\t\tt0 += h;\n\t\tif(h<EPSILON || t0>t1) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1, float k)\n{\n\tfloat res = 1.0;\n\tfor(int i=0; i<NUM_SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(ro + rd*t0).x;\n\t\tres = min(res, k*h/t0);\n\t\tt0 += h;\n\t\tif(h<EPSILON || t0>t1) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1, float k, float fade)\n{\n\tfloat res = 1.0;\n\tfor(int i=0; i<NUM_SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(ro + rd*t0).x;\n\t\tres = min(res, k*h/t0*fade);\n\t\tt0 += h;\n\t\tif(h<EPSILON || t0>t1) break;\n\t}\n\treturn clamp(res, 0.0, 1.", "\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\t\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, vec3 angle) {\n    return createRotationMatrixAxisAngle(axis, angle.x) * createRotationMatrixAxisAngle(axis, angle.y) * createRotationMatrixAxisAngle(axis, angle.z);\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, vec4 angle) {\n    return createRotationMatrixAxisAngle(axis, angle.xyz) * createRotationMatrixAxisAngle(axis, angle.w);\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec4 axis, float angle) {\n    return createRotationMatrixAxisAngle(axis.xyz, angle) * createRotationMatrixAxisAngle(axis.xyz, angle.w);\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec4 axis, vec3 angle) {\n    return createRotationMatrixAxisAngle(axis.xyz, angle) * createRotationMatrixAxisAngle(axis.xyz, angle.w);\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec4 axis, vec4 angle) {\n    return createRotationMatrixAxisAngle(axis.xyz, angle.xyz) * createRotationMatrixAxisAngle(axis.xyz, angle.w);\n}\n", "\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    return origin + dir * 10.0;\n}\n\n// Helper function that generates random number\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates random number\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// Helper function that generates random number\nfloat rand(vec2 co, float n) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * n);\n}\n\n// Helper function that generates random number\nfloat rand(float n, float m) {\n    return fract(sin(n) * m);\n}\n\n// Helper function that generates random number\nfloat rand(vec2 co, float n, float m) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * n * m);\n}\n\n// Helper function that generates random number\nfloat rand(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\n// Helper function that generates random number\nfloat rand(vec3 co, float n) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 151.7182))) * n);\n}\n\n// Helper function that generates random number\nfloat rand", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.164))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.164))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co, float seed){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * seed);\n}\n\n// 3d noise\nfloat rand3d(vec3 co, float seed){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.164))) * seed);\n}\n\n// 2d noise\nfloat rand2d(vec2 co, float seed, float time){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * seed + time);\n}\n\n// 3d noise\nfloat rand3d(vec3 co, float seed, float time){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.164))) * seed + time);\n}\n\n// 2d noise\nfloat rand2d(vec", "\n\treturn fract(sin(dot(p,vec3(12.9898,78.233,45.164)))*43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n\treturn fract(sin(p)*43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n\treturn fract(sin(dot(p,vec4(12.9898,78.233,45.164,94.673)))*43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n\treturn fract(sin(p)*43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n\treturn fract(sin(dot(p,vec4(12.9898,78.233,45.164,94.673)))*43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n\treturn fract(sin(p)*43758.54", "\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\tfloat res = mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix(hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix(hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res*2.0-1.0;\n}\n\n// 4D value noise\nfloat noise4d(vec4 x){\n\tvec4 p = floor(x);\n\tvec4 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z + 973.0*p.w;\n\t\n\tfloat res = mix(mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\t\tmix(hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\t\tmix(mix(hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\t\tmix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z),\n\t\t\t\t\tmix(mix(mix(hash(n+973.0), hash(n+974.0),f.x),\n\t\t\t\t\t\t\tmix(hash(n+979.0), hash(n+980.0),f.x),f.y),\n\t\t\t\t\t\tmix(", "\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = i.x + i.y*57.0 + 113.0*i.z;\n\tfloat res = mix(mix(mix(dot(rand3(n+  0.0), f), dot(rand3(n+  1.0), f-vec3(1.0, 0.0, 0.0)), f.x),\n\t\tmix(dot(rand3(n+ 57.0), f-vec3(0.0, 1.0, 0.0)), dot(rand3(n+ 58.0), f-vec3(1.0, 1.0, 0.0)), f.x), f.y),\n\t\tmix(mix(dot(rand3(n+113.0), f-vec3(0.0, 0.0, 1.0)), dot(rand3(n+114.0), f-vec3(1.0, 0.0, 1.0)), f.x),\n\t\tmix(dot(rand3(n+170.0), f-vec3(0.0, 1.0, 1.0)), dot(rand3(n+171.0), f-vec3(1.0, 1.0, 1.0)), f.x), f.y), f.z);\n\treturn res*res;\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = i.x + i.y*57.0;\n\tfloat res = mix(mix(dot(rand2(n+  0.0), f), dot(rand2(n+  1.0), f-vec2(1.0, 0.0)), f.x),\n\t\tmix(dot(rand2(n+ ", "\n    float fbm = 0.0;\n    float amp = 0.5;\n    float freq = 0.0;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    for(int i = 0; i < 6; i++){\n        fbm += amp * noise(p);\n        p *= lacunarity;\n        amp *= gain;\n    }\n    return fbm;\n}\n\n// Clouds are a bit more complex than the sky, so we'll use a different\n// approach to calculate them.\n//\n// We'll use a 3D noise function to generate a cloud shape, then we'll\n// use that shape to calculate the cloud color.\n//\n// The cloud shape is generated by a 3D noise function, which is then\n// used to calculate the cloud color.\n//\n// The cloud color is calculated by using the cloud shape to calculate\n// the cloud density, then using that density to calculate the cloud\n// color.\n//\n// The cloud shape is generated by a 3D noise function, which is then\n// used to calculate the cloud color.\n//\n// The cloud color is calculated by using the cloud shape to calculate\n// the cloud density, then using that density to calculate the cloud\n// color.\n//\n// The cloud shape is generated by a 3D noise function, which is then\n// used to calculate the cloud color.\n//\n// The cloud color is calculated by using the cloud shape to calculate\n// the cloud density, then using that density to calculate the cloud\n// color.\n//\n// The cloud shape is generated by a 3D noise function, which is then\n// used to calculate the cloud color.\n//\n// The cloud color is calculated by using the cloud shape to calculate\n// the cloud density, then using that density to calculate the cloud\n// color.\n//\n// The cloud shape is generated by a 3D noise function, which is then\n// used to calculate the cloud color.\n//\n// The cloud color is calculated by using the cloud shape to calculate\n// the cloud density, then using that density to calculate the cloud\n// color.\n//\n// The cloud shape is generated by a 3D noise function, which is then\n// used to calculate the cloud color.\n//\n// The cloud color is calculated by using the cloud", "\n\tvec2 res = vec2(0.0);\n\tvec3 p = pos;\n\tp.y = max(p.y, 0.0);\n\tfloat d = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d", "\n\tfloat coverage = clamp(1.0 - dist * 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec3 color = vec3(0.0);\n\tfloat stepSize = 0.001;\n\tfloat stepDist = 0.0;\n\tfloat stepCount = 0.0;\n\tfloat stepDistMax = 0.0;\n\tfloat stepDistMin = 0.0;\n\tfloat stepDistMax2 = 0.0;\n\tfloat stepDistMin2 = 0.0;\n\tfloat stepDistMax3 = 0.0;\n\tfloat stepDistMin3 = 0.0;\n\tfloat stepDistMax4 = 0.0;\n\tfloat stepDistMin4 = 0.0;\n\tfloat stepDistMax5 = 0.0;\n\tfloat stepDistMin5 = 0.0;\n\tfloat stepDistMax6 = 0.0;\n\tfloat stepDistMin6 = 0.0;\n\tfloat stepDistMax7 = 0.0;\n\tfloat stepDistMin7 = 0.0;\n\tfloat stepDistMax8 = 0.0;\n\tfloat stepDistMin8 = 0.0;\n\tfloat stepDistMax9 = 0.0;\n\tfloat stepDistMin9 = 0.0;\n\tfloat stepDistMax10 = 0.0;\n\tfloat stepDistMin10 = 0.0;\n\tfloat stepDistMax11 = 0.0;\n\tfloat stepDistMin11 = 0.0;\n\tfloat stepDistMax12 = 0.0;\n\tfloat stepDistMin12 = 0.0;\n\tfloat stepDistMax13 = 0.0;\n\tfloat stepDistMin13 = 0.0;\n\tfloat stepDistMax14 = 0.0;\n\tfloat stepDistMin14 = 0.0;\n\tfloat stepDistMax15 = 0.0;\n\tfloat stepDistMin15 = 0.0;\n\tfloat stepDistMax16 = 0.0;\n\tfloat stepDistMin16 = 0.0;\n\tfloat stepDistMax17 = 0.0;\n\tfloat stepDistMin17 = 0.0;\n\tfloat stepDistMax18", "\n\tconst float a = 2.51;\n\tconst float b = 0.03;\n\tconst float c = 2.43;\n\tconst float d = 0.59;\n\tconst float e = 0.14;\n\treturn clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\nvoid main() {\n\tvec3 color = texture(tex, texCoord).rgb;\n\tcolor = aces_tonemap(color);\n\tcolor = pow(color, vec3(1.0 / 2.2));\n\tfragColor = vec4(color, 1.0);\n}\n"]}