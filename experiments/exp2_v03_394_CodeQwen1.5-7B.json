{"generations": ["\n    return 0.282095;\n}\n\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat", "\n    return ( dot(v,r) < 0.0 )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n    return v.x < 0.0? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n    return vec2( v.x, max( v.y, r.y ) );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix( w1, w2, h );\n}\n\nfloat", "\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle3 = sunAngle2 * sunAngle;\n    float sunAngle4 = sunAngle3 * sunAngle;\n    float sunAngle5 = sunAngle4 * sunAngle;\n    float sunAngle6 = sunAngle5 * sunAngle;\n    float sunAngle7 = sunAngle6 * sunAngle;\n    float sunAngle8 = sunAngle7 * sunAngle;\n    float sunAngle9 = sunAngle8 * sunAngle;\n    float sunAngle10 = sunAngle9 * sunAngle;\n    float sunAngle11 = sunAngle10 * sunAngle;\n    float sunAngle12 = sunAngle11 * sunAngle;\n    float sunAngle13 = sunAngle12 * sunAngle;\n    float sunAngle14 = sunAngle13 * sunAngle;\n    float sunAngle15 = sunAngle14 * sunAngle;\n    float sunAngle16 = sunAngle15 * sunAngle;\n    float sunAngle17 = sunAngle16 * sunAngle;\n    float sunAngle18 = sunAngle17 * sunAngle;\n    float sunAngle19 = sunAngle18 * sunAngle;\n    float sunAngle20 = sunAngle19 * sunAngle;\n    float sunAngle21 = sunAngle20 * sunAngle;\n    float sunAngle22 = sunAngle21 * sunAngle;\n    float sunAngle23 = sunAngle22 * sunAngle;\n    float sunAngle24 = sunAngle23 * sunAngle;\n    float sunAngle25 = sunAngle24 * sunAngle;\n    float sunAngle26 = sunAngle25 * sunAngle;\n    float sunAngle27 = sunAngle26 * sunAngle;\n    float sunAngle28 = sunAngle27 * sunAngle;\n    float sunAngle29 = sunAngle28 * sunAngle;\n    float sunAngle30 = sunAngle29 * sunAngle;\n    float sunAngle31 = sunAngle30 * sunAngle;\n    float sunAngle32 = sunAngle31 * sunAngle;\n    float sunAngle33 = sunAngle32 * sunAngle;\n    float sunAngle34 = sunAngle33 * sunAngle;\n    float sunAngle35 = sunAngle34 * sunAngle;\n    float sunAngle36 = sunAngle35 * sunAngle;\n    float sunAngle37 = sunAngle", "\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return 0.5 * ((2.0 * p1) +\n                  (-p0 + p2) * t +\n                  (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n                  (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t3);\n}\n\n// This is a spline used for the camera path\nvec", "\n\tfloat r = 0.0;\n\tfloat w = 1.0;\n\tfloat time = iTime * 0.05;\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\t// add sin and cos scaled and translated by the current wave scale\n\t\tr += sin(p.y*w + time) + cos(p.x*w) + sin(p.z*w);\n\t\t// rotate the axes of the system and scale down\n\t\tp = p * 2.0 * nudge + normalizer * (cross(p, vec3(w, w, w)));\n\t\tw *= 1.975;\n\t}\n\treturn r / 2.0;\n}", "\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\treturn 0.5 * ((2.0 * p1) + (-p0 + p2) * t + (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 + (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t3);\n}\n\n// from a time t, this finds the derivative of the camera path.\n// It uses Catmull-Rom splines\nvec", "\n    u = fract(u * 0.8);\n    u = u * u * (3. - 2. * u);\n    return u;\n}\n\nfloat", "\n\tfloat rot = 0.0;\n\tfloat f = 0.0;\n\tfloat w = 0.5;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec3 p2 = vec3(dot(p, vec3(w, w, w)), dot(p, vec3(w, w, w)), dot(p, vec3(w, w, w)));\n\t\tp = abs(fract(p2 + rot) * 6.0 - 3.0);\n\t\trot += 0.1;\n\t\tf += w * sin(p.x * p.y * p.z);\n\t\tw *= 0.95;\n\t}\n\treturn f * normalizer;\n}\n\n// This is a derivative of the work by <NAME>\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// It was simplified and speedup a little bit, also the rotation matrix is removed since it's not needed\n// It can be much faster than other noise functions if you're ok with some repetition.\nfloat", "\n    // This is the distance to the sphere\n    float d = length(p) - 1.0;\n    \n    // This is the distance to the cylinder\n    float c = length(vec2(p.x, p.z)) - 1.0;\n    \n    // This is the distance to the cone\n    float cone = length(vec2(p.x, p.z)) - cos(p.y);\n    \n    // This is the distance to the torus\n    float torus = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus2 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus3 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus4 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus5 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus6 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus7 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25;\n    \n    // This is the distance to the torus\n    float torus8 = length(vec2(length(vec2(p.x, p.z)) - 0.5, p.y)) - 0.25", "\n    vec3 envColor = vec3(0.0);\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle3 = sunAngle2 * sunAngle;\n    float sunAngle4 = sunAngle3 * sunAngle;\n    float sunAngle5 = sunAngle4 * sunAngle;\n    float sunAngle6 = sunAngle5 * sunAngle;\n    float sunAngle7 = sunAngle6 * sunAngle;\n    float sunAngle8 = sunAngle7 * sunAngle;\n    float sunAngle9 = sunAngle8 * sunAngle;\n    float sunAngle10 = sunAngle9 * sunAngle;\n    float sunAngle11 = sunAngle10 * sunAngle;\n    float sunAngle12 = sunAngle11 * sunAngle;\n    float sunAngle13 = sunAngle12 * sunAngle;\n    float sunAngle14 = sunAngle13 * sunAngle;\n    float sunAngle15 = sunAngle14 * sunAngle;\n    float sunAngle16 = sunAngle15 * sunAngle;\n    float sunAngle17 = sunAngle16 * sunAngle;\n    float sunAngle18 = sunAngle17 * sunAngle;\n    float sunAngle19 = sunAngle18 * sunAngle;\n    float sunAngle20 = sunAngle19 * sunAngle;\n    float sunAngle21 = sunAngle20 * sunAngle;\n    float sunAngle22 = sunAngle21 * sunAngle;\n    float sunAngle23 = sunAngle22 * sunAngle;\n    float sunAngle24 = sunAngle23 * sunAngle;\n    float sunAngle25 = sunAngle24 * sunAngle;\n    float sunAngle26 = sunAngle25 * sunAngle;\n    float sunAngle27 = sunAngle26 * sunAngle;\n    float sunAngle28 = sunAngle27 * sunAngle;\n    float sunAngle29 = sunAngle28 * sunAngle;\n    float sunAngle30 = sunAngle29 * sunAngle;\n    float sunAngle31 = sunAngle30 * sunAngle;\n    float sunAngle32 = sunAngle31 * sunAngle;\n    float sunAngle33 = sunAngle32 * sunAngle;\n    float sunAngle34 = sunAngle33 * sunAngle;\n    float sunAngle35 = sunAngle34 * sunAngle;\n    float sunAngle36 = sunAngle", "\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}", "\n\tvec3 distVec = spherePos - pos;\n\tfloat dist = length(distVec);\n\tfloat distSq = dist * dist;\n\tfloat radSq = rad * rad;\n\tfloat distSqMinusRadSq = distSq - radSq;\n\tfloat distSqMinusRadSqSq = distSqMinusRadSq * distSqMinusRadSq;\n\tfloat dirVecDotDistVec = dot(dirVecPLZNormalizeMeFirst, distVec);\n\tfloat dirVecDotDistVecSq = dirVecDotDistVec * dirVecDotDistVec;\n\tfloat dirVecDotDistVecSqMinusDistSqMinusRadSqSq = dirVecDotDistVecSq - distSqMinusRadSqSq;\n\tfloat dirVecDotDistVecSqMinusDistSqMinusRadSqSqSq = dirVecDotDistVecSqMinusDistSqMinusRadSqSq * dirVecDotDistVecSqMinusDistSqMinusRadSqSq;\n\tfloat dirVecDotDistVecSqMinusDistSqMinusRadSqSqSqSqrt = sqrt(dirVecDotDistVecSqMinusDistSqMinusRadSqSqSq);\n\tfloat t1 = dirVecDotDistVec - dirVecDotDistVecSqMinusDistSqMinusRadSqSqSqSqrt;\n\tfloat t2 = dirVecDotDistVec + dirVecDotDistVecSqMinusDistSqMinusRadSqSqSqSqrt;\n\tfloat t = min(t1, t2);\n\treturn t;\n}", "\n    // Calculate the distance to the sphere.\n    vec2 sphere = Sphere(p, 1.0);\n\n    // Calculate the distance to the cylinder.\n    vec2 cylinder = Cylinder(p, vec2(0.0, 0.0), vec2(1.0, 1.0));\n\n    // Return the minimum distance to the sphere or cylinder.\n    return min(sphere, cylinder);\n}", "\n    return vec3(t, 0.0, 0.0);\n}\n\nvec", "\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.0001);\n    return normalize(p1 - p);\n}\n\n// curve second derivative (acceleration)\nvec", "\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.01);\n    vec3 p2 = map(t + 0.02);\n    vec3 p3 = map(t + 0.03);\n    vec3 p4 = map(t + 0.04);\n    vec3 p5 = map(t + 0.05);\n    vec3 p6 = map(t + 0.06);\n    vec3 p7 = map(t + 0.07);\n    vec3 p8 = map(t + 0.08);\n    vec3 p9 = map(t + 0.09);\n    vec3 p10 = map(t + 0.1);\n    vec3 p11 = map(t + 0.11);\n    vec3 p12 = map(t + 0.12);\n    vec3 p13 = map(t + 0.13);\n    vec3 p14 = map(t + 0.14);\n    vec3 p15 = map(t + 0.15);\n    vec3 p16 = map(t + 0.16);\n    vec3 p17 = map(t + 0.17);\n    vec3 p18 = map(t + 0.18);\n    vec3 p19 = map(t + 0.19);\n    vec3 p20 = map(t + 0.2);\n    vec3 p21 = map(t + 0.21);\n    vec3 p22 = map(t + 0.22);\n    vec3 p23 = map(t + 0.23);\n    vec3 p24 = map(t + 0.24);\n    vec3 p25 = map(t + 0.25);\n    vec3 p26 = map(t + 0.26);\n    vec3 p27 = map(t + 0.27);\n    vec3 p28 = map(t + 0.28);\n    vec3 p29 = map(t + 0.29);\n    vec3 p30 = map(t + 0.3);\n    vec3 p31 = map(t + 0", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa - ba*h), h );\n}\n\n// signed squared distance between point and segment\nvec", "\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    vec3 abd = cross( ab, d );\n    vec3 oab = cross( ao, ab );\n    float t = dot( ao, abd ) / dot( abd, abd );\n    float u = dot( d, oab ) / dot( abd, abd );\n    vec3 p = a + ab * clamp( t, 0.0, 1.0 );\n    return vec2( length( o - p ), u );\n}", "\n    vec2 q = abs(p)-b+r.xy;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) + r.z;\n}", "\n\tfloat sunAngle = dot(rayDir, sunDir);\n\tfloat sunAngle2 = sunAngle * sunAngle;\n\tfloat sunAngle3 = sunAngle2 * sunAngle;\n\tfloat sunAngle4 = sunAngle3 * sunAngle;\n\tfloat sunAngle5 = sunAngle4 * sunAngle;\n\tfloat sunAngle6 = sunAngle5 * sunAngle;\n\tfloat sunAngle7 = sunAngle6 * sunAngle;\n\tfloat sunAngle8 = sunAngle7 * sunAngle;\n\tfloat sunAngle9 = sunAngle8 * sunAngle;\n\tfloat sunAngle10 = sunAngle9 * sunAngle;\n\tfloat sunAngle11 = sunAngle10 * sunAngle;\n\tfloat sunAngle12 = sunAngle11 * sunAngle;\n\tfloat sunAngle13 = sunAngle12 * sunAngle;\n\tfloat sunAngle14 = sunAngle13 * sunAngle;\n\tfloat sunAngle15 = sunAngle14 * sunAngle;\n\tfloat sunAngle16 = sunAngle15 * sunAngle;\n\tfloat sunAngle17 = sunAngle16 * sunAngle;\n\tfloat sunAngle18 = sunAngle17 * sunAngle;\n\tfloat sunAngle19 = sunAngle18 * sunAngle;\n\tfloat sunAngle20 = sunAngle19 * sunAngle;\n\tfloat sunAngle21 = sunAngle20 * sunAngle;\n\tfloat sunAngle22 = sunAngle21 * sunAngle;\n\tfloat sunAngle23 = sunAngle22 * sunAngle;\n\tfloat sunAngle24 = sunAngle23 * sunAngle;\n\tfloat sunAngle25 = sunAngle24 * sunAngle;\n\tfloat sunAngle26 = sunAngle25 * sunAngle;\n\tfloat sunAngle27 = sunAngle26 * sunAngle;\n\tfloat sunAngle28 = sunAngle27 * sunAngle;\n\tfloat sunAngle29 = sunAngle28 * sunAngle;\n\tfloat sunAngle30 = sunAngle29 * sunAngle;\n\tfloat sunAngle31 = sunAngle30 * sunAngle;\n\tfloat sunAngle32 = sunAngle31 * sunAngle;\n\tfloat sunAngle33 = sunAngle32 * sunAngle;\n\tfloat sunAngle34 = sunAngle33 * sunAngle;\n\tfloat sunAngle35 = sunAngle34 * sunAngle;\n\tfloat sunAngle36 = sunAngle35 * sunAngle;\n\tfloat sunAngle37 = sunAngle", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}", "\n    vec3 p = currentRayPosition - vec3( 0.0, 0.0, 0.0 );\n    float d = length( p ) - 1.0;\n    return vec2( d, 0.0 );\n}", "\n    \n    // get the distance to each thing\n    float distanceToThing1 = distance( thing1, vec2(0.0) );\n    float distanceToThing2 = distance( thing2, vec2(0.0) );\n    \n    // compare the distances\n    if( distanceToThing1 < distanceToThing2 ){\n        return thing1;\n    }\n    else{\n        return thing2;\n    }\n}", "\n    float distanceToSphere = distanceToSphere( currentRayPosition );\n    float distanceToPlane = distanceToPlane( currentRayPosition );\n    \n    if( distanceToSphere < distanceToPlane ){\n        return vec2( distanceToSphere, 0.0 );\n    }\n    else{\n        return vec2( distanceToPlane, 1.0 );\n    }\n}", "\n    // We are going to use the SDF to figure out the normal\n    // of the surface. We are going to do this by taking the\n    // SDF at the position of the hit, and the SDF at the \n    // position of the hit + a small amount in the x direction.\n    // We are going to do the same thing in the y and z directions.\n    // We are going to take the difference between the SDF at the \n    // position of the hit and the SDF at the position of the hit + \n    // a small amount in the x direction. We are going to do the same\n    // thing in the y and z directions. We are going to take the \n    // difference between the SDF at the position of the hit and the \n    // SDF at the position of the hit + a small amount in the x direction.\n    // We are going to do the same thing in the y and z directions.\n    // We are going to take the difference between the SDF at the \n    // position of the hit and the SDF at the position of the hit + \n    // a small amount in the x direction. We are going to do the same\n    // thing in the y and z directions. We are going to take the \n    // difference between the SDF at the position of the hit and the \n    // SDF at the position of the hit + a small amount in the x direction.\n    // We are going to do the same thing in the y and z directions.\n    // We are going to take the difference between the SDF at the \n    // position of the hit and the SDF at the position of the hit + \n    // a small amount in the x direction. We are going to do the same\n    // thing in the y and z directions. We are going to take the \n    // difference between the SDF at the position of the hit and the \n    // SDF at the position of the hit + a small amount in the x direction.\n    // We are going to do the same thing in the y and z directions.\n    // We are going to take the difference between the SDF at the \n    // position of the hit and the SDF at the position of the hit + \n    // a small amount in the x direction", "\n    return vec3(0.0);\n}", "\n    return normalOfSurface * 0.5 + 0.5;\n}", "\n\n    // get the color of the sky\n    vec3 skyColor = getSkyColor( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the ground\n    vec3 groundColor = getGroundColor( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the stars\n    vec3 starColor = getStarColor( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the clouds\n    vec3 cloudColor = getCloudColor( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the sun\n    vec3 sunColor = getSunColor( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the moon\n    vec3 moonColor = getMoonColor( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the stars\n    vec3 starColor2 = getStarColor2( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the clouds\n    vec3 cloudColor2 = getCloudColor2( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the sun\n    vec3 sunColor2 = getSunColor2( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the moon\n    vec3 moonColor2 = getMoonColor2( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the stars\n    vec3 starColor3 = getStarColor3( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the clouds\n    vec3 cloudColor3 = getCloudColor3( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the sun\n    vec3 sunColor3 = getSunColor3( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the moon\n    vec3 moonColor3 = getMoonColor3( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the stars\n    vec3 starColor4 = getStarColor4( rayHitInfo, eyePosition, rayDirection );\n\n    // get the color of the clouds\n    vec3 cloudColor4 = getCloudColor4( rayH", "\n    return x / (((1.0 / b - 2.0) * (1.0 - x)) + 1.0);\n}\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range -1..1 including -1 excluding 1\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// input r --> is box radius\n// pretty simple, just compare point to radius of box\nfloat", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/smoothness, 0.0, 1.0 );\n    return mix( d2, d1, h ) - smoothness*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat", "\n    return max(min(d1,d2),-min(max(d1,d2),max(d1,d2)+d1*d2));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat", "\n    float c = cos(t*p.y);\n    float s = sin(t*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec", "\n    if (o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y -= 0.5;\n    // p.y = mod(p.y, 1.0);\n    // p.y += 0.5;\n    // p.y = mod(p.y, 1.0);\n    ", "\n\tvec2 res = vec2( INF, -1.0 );\n\tfloat t = 0.0;\n\tfor( int i=0; i<MAX_STEPS; i++ )\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = scene( p );\n\t\tres.x = t;\n\t\tif( d<EPS )\n\t\t{\n\t\t\tres.y = float(i);\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tif( t>MAX_DIST ) break;\n\t}\n\treturn res;\n}", "\n    // ~~~~~~~ find closest surface\n    float t = 0.0;\n    float tmin = 100000.0;\n    int id = -1;\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float t1 = intersect(ro, rd, spheres[i]);\n        if (t1 > 0.0 && t1 < tmin)\n        {\n            tmin = t1;\n            id = i;\n        }\n    }\n\n    // ~~~~~~~ apply color\n    if (id == -1)\n    {\n        return vec3(0.0);\n    }\n    else\n    {\n        vec3 p = ro + rd * tmin;\n        vec3 n = normal(p, id);\n        vec3 l = normalize(light - p);\n        float diff = max(0.0, dot(n, l));\n        return diff * spheres[id].color;\n    }\n}", "\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat", "\n    if(id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if(id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if(id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if(id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if(id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if(id == 7.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if(id == 8.0)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if(id == 9.0)\n    {\n        return vec3(0.5, 0.0, 0.0);\n    }\n    else if(id == 10.0)\n    {\n        return vec3(0.0, 0.5, 0.0);\n    }\n    else if(id == 11.0)\n    {\n        return vec3(0.0, 0.0, 0.5);\n    }\n    else if(id == 12.0)\n    {\n        return vec3(0.5, 0.5, 0.0);\n    }\n    else if(id == 13.0)\n    {\n        return vec", "\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}", "\n    return p.y;\n}", "\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    vec3 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}", "\n    return max(d1,-d2);\n}", "\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    lightPos.x = sin(u_time) * 5.0;\n    lightPos.y = cos(u_time) * 5.0;\n    lightPos.z = sin(u_time) * 5.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec", "\n    // vec4(distance, color)\n    vec4 res = vec4(10000., vec3(0.));\n    // sphere\n    vec3 q = p;\n    float d = sdSphere(q, 1.);\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(1.));\n    }\n    // plane\n    d = sdPlane(p, vec3(0., 1., 0.), 0.);\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(0., 1., 0.));\n    }\n    // torus\n    d = sdTorus(p, vec2(.5,.25));\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(1., 0., 0.));\n    }\n    // box\n    d = sdBox(p, vec3(.5));\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(0., 0., 1.));\n    }\n    // cylinder\n    d = sdCylinder(p, vec2(.5,.25));\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(1., 1., 0.));\n    }\n    // capsule\n    d = sdCapsule(p, vec3(0., -.5, 0.), vec3(0.,.5, 0.),.25);\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(0., 1., 1.));\n    }\n    // torus knot\n    d = sdTorusKnot(p, vec2(.5,.25), 2., 3.);\n    if (d < res.x)\n    {\n        res = vec4(d, vec3(1., 0., 1.));\n    }\n    // torus 2\n    d = sdTorus(p, vec2(.5,.25));\n    if (d < res.x", "\n    vec4 hit = vec4(0.0,0.0,0.0,0.0);\n    float t = 0.0;\n    float id = 0.0;\n    float tMax = 100.0;\n    float tMin = 0.0;\n    float tStep = 0.0;\n    float tStepMax = 0.0;\n    float tStepMin = 0.0;\n    float tStepRatio = 0.0;\n    float tStepRatioMax = 0.0;\n    float tStepRatioMin = 0.0;\n    float tStepRatioMax2 = 0.0;\n    float tStepRatioMin2 = 0.0;\n    float tStepRatioMax3 = 0.0;\n    float tStepRatioMin3 = 0.0;\n    float tStepRatioMax4 = 0.0;\n    float tStepRatioMin4 = 0.0;\n    float tStepRatioMax5 = 0.0;\n    float tStepRatioMin5 = 0.0;\n    float tStepRatioMax6 = 0.0;\n    float tStepRatioMin6 = 0.0;\n    float tStepRatioMax7 = 0.0;\n    float tStepRatioMin7 = 0.0;\n    float tStepRatioMax8 = 0.0;\n    float tStepRatioMin8 = 0.0;\n    float tStepRatioMax9 = 0.0;\n    float tStepRatioMin9 = 0.0;\n    float tStepRatioMax10 = 0.0;\n    float tStepRatioMin10 = 0.0;\n    float tStepRatioMax11 = 0.0;\n    float tStepRatioMin11 = 0.0;\n    float tStepRatioMax12 = 0.0;\n    float tStepRatioMin12 = 0.0;\n    float tStepRatioMax13 = 0.0;\n    float tStepRatioMin13 = 0.0;\n    float tStepRatioMax14", "\n    const int maxIter = 20;\n    const float maxDist = 100.0;\n    const float minDist = 0.001;\n    const float eps = 0.001;\n    const float k = 1.0;\n    const float k2 = k * k;\n    const float k3 = k2 * k;\n    const float k4 = k3 * k;\n    const float k5 = k4 * k;\n    const float k6 = k5 * k;\n    const float k7 = k6 * k;\n    const float k8 = k7 * k;\n    const float k9 = k8 * k;\n    const float k10 = k9 * k;\n    const float k11 = k10 * k;\n    const float k12 = k11 * k;\n    const float k13 = k12 * k;\n    const float k14 = k13 * k;\n    const float k15 = k14 * k;\n    const float k16 = k15 * k;\n    const float k17 = k16 * k;\n    const float k18 = k17 * k;\n    const float k19 = k18 * k;\n    const float k20 = k19 * k;\n    const float k21 = k20 * k;\n    const float k22 = k21 * k;\n    const float k23 = k22 * k;\n    const float k24 = k23 * k;\n    const float k25 = k24 * k;\n    const float k26 = k25 * k;\n    const float k27 = k26 * k;\n    const float k28 = k27 * k;\n    const float k29 = k28 * k;\n    const float k30 = k29 * k;\n    const float k31 = k30 * k;\n    const float k32 = k31 * k;\n    const float k33 = k32 * k;\n    const float k34 = k33 * k;\n    const float k35 = k34 * k;\n    const float k36 = k35 * k;\n    const float k37 = k36 * k;\n    const float k38 = k37 * k;\n    const float k39 = k38 * k;", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<16; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/16.0;\n        vec3 aop = sp + hr*nor;\n        float dd = map(aop);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0-3.0*occ, 0.0, 1.0);\n}\n\n// ~~~~~~~ normal\n// calculate normal from surface point\nvec", "\n    vec3 n = oN;\n    vec3 n1 = oN;\n    vec3 n2 = oN;\n    vec3 n3 = oN;\n    vec3 n4 = oN;\n    vec3 n5 = oN;\n    vec3 n6 = oN;\n    vec3 n7 = oN;\n    vec3 n8 = oN;\n    vec3 n9 = oN;\n    vec3 n10 = oN;\n    vec3 n11 = oN;\n    vec3 n12 = oN;\n    vec3 n13 = oN;\n    vec3 n14 = oN;\n    vec3 n15 = oN;\n    vec3 n16 = oN;\n    vec3 n17 = oN;\n    vec3 n18 = oN;\n    vec3 n19 = oN;\n    vec3 n20 = oN;\n    vec3 n21 = oN;\n    vec3 n22 = oN;\n    vec3 n23 = oN;\n    vec3 n24 = oN;\n    vec3 n25 = oN;\n    vec3 n26 = oN;\n    vec3 n27 = oN;\n    vec3 n28 = oN;\n    vec3 n29 = oN;\n    vec3 n30 = oN;\n    vec3 n31 = oN;\n    vec3 n32 = oN;\n    vec3 n33 = oN;\n    vec3 n34 = oN;\n    vec3 n35 = oN;\n    vec3 n36 = oN;\n    vec3 n37 = oN;\n    vec3 n38 = oN;\n    vec3 n39 = oN;\n    vec3 n40 = oN;\n    vec3 n41 = oN;\n    vec3 n42 = oN;\n    vec3 n43 = oN;\n    vec3 n44 = oN;\n    vec3 n45 = oN;\n    vec3 n46 = oN;\n    vec3 n47 = oN;\n    vec3 n48 = oN;\n    vec3 n49 = oN;\n    vec3 n50 = oN;\n    vec", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec", "\n    float f = 1.0-exp(-fs.x*d);\n    f = smoothstep(0.0,1.0,f);\n    vec3 fc = mix(fc1,fc2,pow(dot(cRD,lRD),fs.y));\n    return mix(c,fc,f);\n}", "\n\treturn 1.0f/(cF + lF*d + qF*d*d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat", "\n    vec3 rayDir = vec3(0.0);\n    rayDir.xy = fCoord * 2.0 - 1.0;\n    rayDir.z = -1.0;\n    rayDir = normalize(rayDir);\n    rayDir = cMatrix * rayDir;\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec", "\n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    float d_prev = 0.0;\n    float d_next = 0.0;\n    float d_max = 0.0;\n    float d_min = 0.0;\n    float d_avg = 0.0;\n    float d_sum = 0.0;\n    float d_count = 0.0;\n    float d_count_max = 0.0;\n    float d_count_min = 0.0;\n    float d_count_avg = 0.0;\n    float d_count_sum = 0.0;\n    float d_count_sum_max = 0.0;\n    float d_count_sum_min = 0.0;\n    float d_count_sum_avg = 0.0;\n    float d_count_sum_sum = 0.0;\n    float d_count_sum_sum_max = 0.0;\n    float d_count_sum_sum_min = 0.0;\n    float d_count_sum_sum_avg = 0.0;\n    float d_count_sum_sum_sum = 0.0;\n    float d_count_sum_sum_sum_max = 0.0;\n    float d_count_sum_sum_sum_min = 0.0;\n    float d_count_sum_sum_sum_avg = 0.0;\n    float d_count_sum_sum_sum_sum = 0.0;\n    float d_count_sum_sum_sum_sum_max = 0.0;\n    float d_count_sum_sum_sum_sum_min = 0.0;\n    float d_count_sum_sum_sum_sum_avg = 0.0;\n    float d_count_sum_sum_sum_sum_sum = 0.0;\n    float d_count_sum_sum_sum_sum_sum_max = 0.0;\n    float d_count_sum_sum_sum_sum_", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat", "\n    // The distance to the nearest surface and the material number\n    vec2 d = vec2(0.0, 0.0);\n\n    // The distance to the sphere\n    d.x = length(p) - 1.0;\n\n    // The distance to the plane\n    d.x = max(d.x, p.y);\n\n    // The material number\n    d.y = 0.0;\n\n    // Return the distance to the nearest surface and the material number\n    return d;\n}", "\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float theta2 = theta * theta;\n    float theta3 = theta2 * theta;\n    float theta4 = theta3 * theta;\n    float theta5 = theta4 * theta;\n    float r5 = pow(r, 5.0);\n    float r4 = r5 * r;\n    float r3 = r4 * r;\n    float r2 = r3 * r;\n    float r1 = r2 * r;\n    float r0 = r1 * r;\n    float r_theta = r0 * cos(5.0 * theta);\n    float i_theta = r0 * sin(5.0 * theta);\n    return vec2(r_theta, i_theta);\n}", "\n    //Get the biomorph at the given position\n    vec4 biomorph = getBiomorph(coord);\n    \n    //Get the color of the biomorph\n    vec4 color = getBiomorphColor(biomorph, morphConstant);\n    \n    //Return the color\n    return color;\n}", "\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec2 offset = vec2(0.0);\n        if (i == 0) offset = vec2(0.25, 0.25);\n        if (i == 1) offset = vec2(-0.25, 0.25);\n        if (i == 2) offset = vec2(0.25, -0.25);\n        if (i == 3) offset = vec2(-0.25, -0.25);\n        color += texture(iChannel0, uv + offset * constant);\n    }\n    return color / 4.0;\n}", "\n    return x - floor(x);\n}\n\nfloat", "\n    vec2 p = pB - pA;\n    float len = length(p);\n    vec2 dir = p / len;\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 perp3 = vec2(-dir.y, dir.x) * 0.5;\n    vec2 perp4 = vec2(dir.y, -dir.x) * 0.5;\n    vec2 perp5 = vec2(-dir.y, dir.x) * 0.25;\n    vec2 perp6 = vec2(dir.y, -dir.x) * 0.25;\n    vec2 perp7 = vec2(-dir.y, dir.x) * 0.125;\n    vec2 perp8 = vec2(dir.y, -dir.x) * 0.125;\n    vec2 perp9 = vec2(-dir.y, dir.x) * 0.0625;\n    vec2 perp10 = vec2(dir.y, -dir.x) * 0.0625;\n    vec2 perp11 = vec2(-dir.y, dir.x) * 0.03125;\n    vec2 perp12 = vec2(dir.y, -dir.x) * 0.03125;\n    vec2 perp13 = vec2(-dir.y, dir.x) * 0.015625;\n    vec2 perp14 = vec2(dir.y, -dir.x) * 0.015625;\n    vec2 perp15 = vec2(-dir.y, dir.x) * 0.0078125;\n    vec2 perp16 = vec2(dir.y, -dir.x) * 0.0078125;\n    vec2 perp17 = vec2(-dir.y, dir.x) * 0.00390625;\n    vec2 perp18 = vec2(dir.y, -dir.x) * 0.00390625;\n    vec2 perp19 = vec2(-dir.y, dir.x) * ", "\n    vec2 p = uv - pA;\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 p1 = p - perp * thick.x;\n    vec2 p2 = p - perp * thick.y;\n    vec2 p3 = p + perp * thick.y;\n    vec2 p4 = p + perp * thick.x;\n    float d1 = dot(p1, perp2);\n    float d2 = dot(p2, perp2);\n    float d3 = dot(p3, perp2);\n    float d4 = dot(p4, perp2);\n    float d = max(max(d1, d2), max(d3, d4));\n    float r = length(p - pB);\n    float r2 = length(p - pA);\n    float rd = max(r, r2);\n    float rd2 = min(r, r2);\n    float rd3 = length(pB - pA);\n    float rd4 = length(p - pA);\n    float rd5 = length(p - pB);\n    float rd6 = length(pA - pB);\n    float rd7 = max(rd4, rd5);\n    float rd8 = min(rd4, rd5);\n    float rd9 = max(rd6, rd7);\n    float rd10 = min(rd6, rd7);\n    float rd11 = max(rd8, rd9);\n    float rd12 = min(rd8, rd9);\n    float rd13 = max(rd10, rd11);\n    float rd14 = min(rd10, rd11);\n    float rd15 = max(rd12, rd13);\n    float rd16 = min(rd12, rd13);\n    float rd17 = max(rd14, rd15);\n    float rd18 = min(rd14, rd", "\n    float dist = length(pB - pA);\n    float angle = atan(pB.y - pA.y, pB.x - pA.x);\n    vec2 p = vec2(cos(angle), sin(angle));\n    vec2 p2 = vec2(cos(angle + 3.1415926535897932384626433832795 / 2.0), sin(angle + 3.1415926535897932384626433832795 / 2.0));\n    vec2 p3 = vec2(cos(angle - 3.1415926535897932384626433832795 / 2.0), sin(angle - 3.1415926535897932384626433832795 / 2.0));\n    vec2 p4 = vec2(cos(angle + 3.1415926535897932384626433832795), sin(angle + 3.1415926535897932384626433832795));\n    vec2 p5 = vec2(cos(angle - 3.1415926535897932384626433832795), sin(angle - 3.1415926535897932384626433832795));\n    vec2 p6 = vec2(cos(angle + 3.1415926535897932384626433832795 / 2.0), sin(angle + 3.1415926535897932384626433832795 / 2.0));\n    vec2 p7 = vec2(cos(angle - 3.1415926535897932384626433832795 / 2.0), sin(angle - 3.1415926535897932384626433832795 / 2.0));\n    vec2 p8 = vec2(cos(angle + 3.1415926535897932384626433832795), sin(angle + 3.1415926535897932384626433832795));\n    vec2 p9 = vec2(cos(angle - 3.1415926535897932384626433832795), sin(angle - 3.1415926535897932384626433832795));\n    vec2 p10 = vec2(cos(angle + 3.1415926535897932384626433832795 / ", "\n    vec2 p = uv - pA;\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 pPerp = p * perp;\n    vec2 pPerp2 = p * perp2;\n    vec2 pDir = p * dir;\n    float d = abs(pDir.x) - thick.x;\n    float d2 = abs(pDir.y) - thick.y;\n    float dPerp = abs(pPerp.x) - thick.x;\n    float dPerp2 = abs(pPerp2.x) - thick.y;\n    float dRounded = length(pPerp.xy) - rounded;\n    float dRounded2 = length(pPerp2.xy) - rounded;\n    float dRoundedPerp = length(pPerp.xy) - rounded;\n    float dRoundedPerp2 = length(pPerp2.xy) - rounded;\n    float dRoundedDir = length(pDir.xy) - rounded;\n    float dRoundedDir2 = length(pDir.xy) - rounded;\n    float dRoundedPerpDir = length(pPerp.xy) - rounded;\n    float dRoundedPerpDir2 = length(pPerp2.xy) - rounded;\n    float dRoundedPerpDir3 = length(pPerp.xy) - rounded;\n    float dRoundedPerpDir4 = length(pPerp2.xy) - rounded;\n    float dRoundedPerpDir5 = length(pPerp.xy) - rounded;\n    float dRoundedPerpDir6 = length(pPerp2.xy) - rounded;\n    float dRoundedPerpDir7 = length(pPerp.xy) - rounded;\n    float dRoundedPerpDir8 = length(pPerp2.xy) - rounded;\n    float dRoundedPerpDir9 = length(pPerp.xy) - rounded;\n    float dRoundedPerpDir10 = length(", "\n    vec2 p = uv - pA;\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 p2 = p - perp * rounded;\n    vec2 p3 = p - perp2 * rounded;\n    float d = length(max(vec2(0.0), abs(p2) - thick)) + min(0.0, p2.x) + min(0.0, p3.x);\n    return 1.0 - smoothstep(0.0, 1.0, d);\n}", "\n    float dist = distance(uv, pA);\n    float dist2 = distance(uv, pB);\n    float dist3 = distance(uv, pA + (pB - pA) * 0.5);\n    float dist4 = distance(uv, pA + (pB - pA) * 0.25);\n    float dist5 = distance(uv, pA + (pB - pA) * 0.75);\n    float dist6 = distance(uv, pA + (pB - pA) * 0.125);\n    float dist7 = distance(uv, pA + (pB - pA) * 0.875);\n    float dist8 = distance(uv, pA + (pB - pA) * 0.375);\n    float dist9 = distance(uv, pA + (pB - pA) * 0.625);\n    float dist10 = distance(uv, pA + (pB - pA) * 0.125);\n    float dist11 = distance(uv, pA + (pB - pA) * 0.875);\n    float dist12 = distance(uv, pA + (pB - pA) * 0.375);\n    float dist13 = distance(uv, pA + (pB - pA) * 0.625);\n    float dist14 = distance(uv, pA + (pB - pA) * 0.125);\n    float dist15 = distance(uv, pA + (pB - pA) * 0.875);\n    float dist16 = distance(uv, pA + (pB - pA) * 0.375);\n    float dist17 = distance(uv, pA + (pB - pA) * 0.625);\n    float dist18 = distance(uv, pA + (pB - pA) * 0.125);\n    float dist19 = distance(uv, pA + (pB - pA) * 0.875);\n    float dist20 = distance(uv, pA + (pB - pA) * 0.375);\n    float dist21 = distance(uv, pA + (pB - pA", "\n    vec2 d = p - uv;\n    float dist = length(d);\n    float alpha = 1.0 - smoothstep(0.0, 0.01, dist);\n    col = mix(col, vec3(1.0), alpha);\n}", "\n    float denom = dot( nor, rd );\n    if( abs(denom) < 0.0001 ) return -1.0;\n    float tp = dot( nor, cen - ro );\n    float t = tp / denom;\n    if( t < 0.0 ) return -1.0;\n    vec3 p = ro + t * rd;\n    float d = distance( p, cen ) - rad;\n    return d;\n}", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection (simplified)\nvec", "\n    vec3  ba = pb - pa;\n    float baba = dot(ba,ba);\n    float b = sqrt(baba);\n    vec3  bvn = ba/baba;\n    vec3  ca = pa - vec3(0.0,0.0,0.0);\n    vec3  cv = ca - bvn*dot(ca,bvn);\n    float cva = dot(ca,bvn);\n    float h = (cva > b? b : (cva < 0.0? 0.0 : cva));\n    return bound3( vec3(0.0,0.0,0.0), vec3(ra,ra,h) );\n}", "\n    vec3  ba = pb - pa;\n    vec3  oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float rdba = dot(rd,ba);\n    float rd2  = dot(rd,rd);\n    float tca = baoc / baba;\n    float d2  = baoc*baoc - baba*tca*tca;\n    float h2 = ra*ra * rd2 - d2;\n    if( h2 < 0.0 ) return vec4(0.0);\n    float h = sqrt(h2);\n    float t = (tca - h) / baba;\n    float u = (tca + h) / baba;\n    vec3  n = normalize(oc + t*rd - ba*clamp( u / baba, 0.0, 1.0 ) );\n    return vec4(t,n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(0.0); // no intersection\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec", "\n    vec3  ba = pb - pa;\n    vec3  oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float rdba = dot(rd,ba);\n    float rd oc = dot(rd,oc);\n    float ococ = dot(oc,oc);\n    float ocor2 = ococ - baoc*baoc/baba;\n    float rd2  = dot(rd,rd);\n    float rd2a = rd2 - rdba*rdba/baba;\n    float rad2 = r*r/baba;\n    float tmp = baba*rd2a - rdba*rdba;\n    float delta = baba*ococ - baoc*baoc;\n    float tca = (delta<0.0)? -1.0 : (baoc*rd2a - rdba*ococ)/tmp;\n    float t0 = tca - sqrt(rad2*(rd2a - tca*rdba/baba) + ocor2);\n    float t1 = tca + sqrt(rad2*(rd2a - tca*rdba/baba) + ocor2);\n    if( t0<0.0 && t1<0.0 ) return -1.0;\n    return (t0<0.0)? t1 : t0;\n}", "\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    float d = dot( ap, ab ) / dot( ab, ab );\n    vec3 c = a + d * ab;\n    vec3 n = normalize( c - pos );\n    return n;\n}", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = +n - k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in world space\nvec", "\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 p = ro + rd*t;\n        float d = map( p );\n        if( d<HIT_DISTANCE )\n        {\n            m = float(i);\n            break;\n        }\n        t += d;\n        if( t>FAR ) break;\n    }\n    return vec4( t, m, 0.0, 0.0 );\n}\n\n// normal\nvec", "\n    float phi = 2.0 * PI * i / n;\n    float z = 1.0 - (2.0 * i + 1.0) / n;\n    float r = sqrt(1.0 - z * z);\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\n// inverse spherical fibonazzi mapping\nvec", "\n    const float maxd = 100.0;\n    const float mind = 0.01;\n    const int maxiter = 100;\n    float t = 0.0;\n    float h = 0.0;\n    float d = maxd;\n    float m = -1.0;\n    float iter = 0.0;\n    for( int i=0; i<maxiter; i++ )\n    {\n        if( d<mind || t>maxd ) break;\n        vec3 p = ro + rd*t;\n        vec3 q = p;\n        float r = 1.0;\n        float a = 0.0;\n        float b = 0.0;\n        float c = 0.0;\n        float s = 1.0;\n        float d = 0.0;\n        float e = 0.0;\n        float f = 0.0;\n        float g = 0.0;\n        float h = 0.0;\n        float i = 0.0;\n        float j = 0.0;\n        float k = 0.0;\n        float l = 0.0;\n        float m = 0.0;\n        float n = 0.0;\n        float o = 0.0;\n        float p = 0.0;\n        float q = 0.0;\n        float r = 0.0;\n        float s = 0.0;\n        float t = 0.0;\n        float u = 0.0;\n        float v = 0.0;\n        float w = 0.0;\n        float x = 0.0;\n        float y = 0.0;\n        float z = 0.0;\n        float a = 0.0;\n        float b = 0.0;\n        float c = 0.0;\n        float d = 0.0;\n        float e = 0.0;\n        float f = 0.0;\n        float g = 0.0;\n        float h = 0.0;\n        float i = 0.0;\n        float j", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( vec3( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), hash( i + vec2(0.0,1.0) ) ),\n\t\t\t\t\t vec3( hash( i + vec2(1.0,1.0) ), hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,0.0) ) ), u.x),\n\t\t\t\tmix( vec3( hash( i + vec2(1.0,1.0) ), hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,0.0) ) ),\n\t\t\t\t\t vec3( hash( i + vec2(1.0,1.0) ), hash( i + vec2(1.0,0.0) ), hash( i + vec2(0.0,0.0) ) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) + radius;\n}\n\nfloat", "\n    vec2 p = uv * orient;\n    vec2 q = floor(p);\n    vec2 r = p - q;\n    return vec3(r.x, r.y, 0.0);\n}\n\n// Pattern 2\nvec", "\n    vec2 p = uv * orient;\n    vec2 q = fract(p);\n    vec2 r = abs(fract(p) -.5);\n    return vec3(step(.5, r.x) * step(.5, r.y));\n}", "\n    vec2 a = ddx*ddx + ddy*ddy;\n    vec2 b = ddx*p + ddy*0.5*p.y;\n    vec2 c = p*p;\n    return (a.x*a.y - b.x*b.x) / (c.x*a.y - b.x*b.y);\n}\n\n// grid ratio\nfloat", "\n    vec3 e = vec3(0.01,0.0,0.0);\n    return normalize( vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx) ) );\n}\n\n// raymarching\nfloat", "\n\tv33 c=a;\n\ta.x=c.x;\n\ta.y=c.z;\n\ta.z=c.y;\n\tb.x=c.y;\n\tb.y=c.x;\n\tb.z=c.z;\n}", "\n\treturn {a.a-b,a.b};\n}\nv33 add(v33 a,vec3 b){\n\treturn {a.a+b,a.b};\n}\nv33 mul(v33 a,vec3 b){\n\treturn {a.a*b,a.b};\n}\nv33 div(v33 a,vec3 b){\n\treturn {a.a/b,a.b};\n}\nv33 add(v33 a,v33 b){\n\treturn {a.a+b.a,a.b+b.b};\n}\nv33 sub(v33 a,v33 b){\n\treturn {a.a-b.a,a.b-b.b};\n}\nv33 mul(v33 a,v33 b){\n\treturn {a.a*b.a,a.b*b.b};\n}\nv33 div(v33 a,v33 b){\n\treturn {a.a/b.a,a.b/b.b};\n}\nv33 add(v33 a,float b){\n\treturn {a.a+b,a.b};\n}\nv33 sub(v33 a,float b){\n\treturn {a.a-b,a.b};\n}\nv33 mul(v33 a,float b){\n\treturn {a.a*b,a.b};\n}\nv33 div(v33 a,float b){\n\treturn {a.a/b,a.b};\n}\nv33 add(float a,v33 b){\n\treturn {a+b.a,b.b};\n}\nv33 sub(float a,v33 b){\n\treturn {a-b.a,b.b};\n}\nv33 mul(float a,v33 b){\n\treturn {a*b.a,b.b};\n}\nv33 div(float a,v33 b){\n\treturn {a/b.a,b.b};\n}\nv33 add(v33 a,int b){\n\treturn {a.a+b,a.b};\n}\nv33 sub(v33 a,int b){\n\treturn {a", "\n    v33 result;\n    result.x=a.x-b.x;\n    result.y=a.y-b.y;\n    result.z=a.z-b.z;\n    return result;\n}\n//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    v33 result;\n    result.x=a.x+b.x;\n    result.y=a.y+b.y;\n    result.z=a.z+b.z;\n    return result;\n}\n//multiply all ray components by a scalar\n//component wise ray multiplication(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 mulc(v33  a,float b){\n    v33 result;\n    result.x=a.x*b;\n    result.y=a.y*b;\n    result.z=a.z*b;\n    return result;\n}\n//divide all ray components by a scalar\n//component wise ray division(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 divc(v33  a,float b){\n    v33 result;\n    result.x=a.x/b;\n    result.y=a.y/b;\n    result.z=a.z/b;\n    return result;\n}\n//add two rays\n//ray addition\nv33 add(v33  a,v33 b){\n    v33 result;\n    result.x=a.x+b.x;\n    result.y=a.y+b.y;\n    result.z=a.z+b.z;\n    return result;\n}\n//substract two rays\n//ray substraction\nv33 sub(v33  a,v33 b){\n    v33 result;\n    result.x=a.x-b.x;\n    result.y=a.y-b.y;\n    result.z=a.z-b.z;\n    return", "\n    v33 c=a-b;\n    return vec2(c.x,c.y);\n}\nvec", "\n    return vec2(dot(a.x,b),dot(a.y,b));\n}\nvec", "\n\tv33 c;\n\tc.x=a.x*b.x-a.y*b.y;\n\tc.y=a.x*b.y+a.y*b.x;\n\treturn c;\n}\nv33 add(v33 a,v33 b){\n\tv33 c;\n\tc.x=a.x+b.x;\n\tc.y=a.y+b.y;\n\treturn c;\n}\nv33 sub(v33 a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\treturn c;\n}\nv33 div(v33 a,vec2 b){\n\tv33 c;\n\tc.x=a.x/b.x-a.y/b.y;\n\tc.y=a.x/b.y+a.y/b.x;\n\treturn c;\n}\nv33 neg(v33 a){\n\tv33 c;\n\tc.x=-a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 conj(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 inv(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 pow(v33 a,int b){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 sqrt(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 log(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 exp(v33 a){\n\tv33 c;\n\tc.x=", "\n    vec3 q=vec3(dot(p,w.xyy),dot(p,w.yxx),dot(p,w.yyz));\n    return mod(floor(q.x)+floor(q.y)+floor(q.z),2.0);\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat", "\n\tvec3 a=abs(p);\n\tvec3 b=floor(p);\n\tvec3 c=fract(p);\n\tvec3 d=vec3(1.0)-c;\n\tvec3 e=vec3(1.0)-2.0*abs(c-0.5);\n\tvec3 f=vec3(1.0)-abs(c-0.5);\n\tvec3 g=vec3(1.0)-abs(c-0.5);\n\tvec3 h=vec3(1.0)-abs(c-0.5);\n\tvec3 i=vec3(1.0)-abs(c-0.5);\n\tvec3 j=vec3(1.0)-abs(c-0.5);\n\tvec3 k=vec3(1.0)-abs(c-0.5);\n\tvec3 l=vec3(1.0)-abs(c-0.5);\n\tvec3 m=vec3(1.0)-abs(c-0.5);\n\tvec3 n=vec3(1.0)-abs(c-0.5);\n\tvec3 o=vec3(1.0)-abs(c-0.5);\n\tvec3 p=vec3(1.0)-abs(c-0.5);\n\tvec3 q=vec3(1.0)-abs(c-0.5);\n\tvec3 r=vec3(1.0)-abs(c-0.5);\n\tvec3 s=vec3(1.0)-abs(c-0.5);\n\tvec3 t=vec3(1.0)-abs(c-0.5);\n\tvec3 u=vec3(1.0)-abs(c-0.5);\n\tvec3 v=vec3(1.0)-abs(c-0.5);\n\tvec3 w=vec3(1.0)-abs(c-0.5);\n\tvec3 x=vec3(1.0)-abs(c-0.5);\n\tvec3 y=vec3(1.0)-abs(c-0.5);\n\tvec3 z=vec3(1.0)-abs(c-0.5);", "\n    vec3 d=r.d;\n    vec3 o=r.o;\n    vec3 c=s.xyz;\n    float r=s.w;\n    float t=length(o-c)-r;\n    float t2=dot(d,o-c);\n    float t3=t2*t2-dot(o-c,o-c)+r*r;\n    if(t3<0.)return 1.;\n    t3=sqrt(t3);\n    float t1=t2-t3;\n    if(t1>0.)t=min(t,t1);\n    t1=t2+t3;\n    if(t1>0.)t=min(t,t1);\n    return t<0.?1.:0.;\n}", "\n\tvec3 d=s.xyz-u;\n\tfloat r=s.w;\n\tfloat t=dot(d,n);\n\tfloat h=sqrt(dot(d,d)-t*t);\n\treturn clamp((r-h)/r,0.0,1.0);\n}", "\n    vec2 a = p0 - 2.0*p1 + p2;\n    vec2 b = 2.0*(p1 - p0);\n    vec2 c = p0;\n\n    vec2 d = b*b - 4.0*a*c;\n    vec2 e = sqrt(d);\n\n    vec2 t = vec2(-b + e, -b - e)/(2.0*a);\n    t = clamp(t, 0.0, 1.0);\n\n    vec2 q0 = mix(p0, p1, t.x);\n    vec2 q1 = mix(p1, p2, t.x);\n\n    vec2 r0 = mix(q0, q1, t.y);\n    vec2 r1 = mix(q1, q0, t.y);\n\n    return vec4(min(r0, r1), max(r0, r1));\n}\n\n// Exact BBox to a cubic bezier\nvec", "\n    vec2 minP = min(min(p0, p1), p2);\n    vec2 maxP = max(max(p0, p1), p2);\n    return vec4(minP, maxP);\n}\n\n// Approximated BBox to a quadratic bezier\nvec", "\n    vec3 a = p1 - p0;\n    vec3 b = p2 - p1;\n    vec3 c = p3 - p2;\n\n    vec3 d = p0 - 2.0*p1 + p2;\n    vec3 e = -p0 + p1;\n\n    vec3 k = -0.125*dot(d,d)*c + c;\n    vec3 m = -0.125*dot(d,d)*b + b;\n    vec3 n = -0.125*dot(e,e)*c + 2.0*c;\n    vec3 o = -0.125*dot(e,e)*b + e;\n\n    vec3 r = -0.125*dot(d,d)*m + 0.5*d;\n    vec3 s = -0.125*dot(e,e)*m + 0.5*e;\n    vec3 t = -0.125*dot(d,d)*o + 0.5*k;\n    vec3 u = -0.125*dot(e,e)*o + 0.5*n;\n\n    vec3 v = -0.125*dot(e,e)*r + 0.5*s;\n    vec3 w = -0.125*dot(d,d)*r + 0.5*t;\n    vec3 x = -0.125*dot(e,e)*s + 0.5*u;\n    vec3 y = -0.125*dot(d,d)*s + 0.5*v;\n\n    vec3 z = -0.125*dot(d,d)*t + 0.5*w;\n    vec3 A = -0.125*dot(e,e)*t + 0.5*x;\n    vec3 B = -0.125*dot(d,d)*u + 0.5*y;\n    vec3 C = -0.125*dot(e,e)*u + 0.5*A;\n\n    vec3 D = -0.125*dot(d,d)*w + 0.5*B;\n    vec3 E = -0.125*dot(e,e", "\n    vec2 minP = min(min(p0, p1), min(p2, p3));\n    vec2 maxP = max(max(p0, p1), max(p2, p3));\n    return vec4(minP, maxP);\n}\n\n// Conservative BBox to a cubic bezier\nvec", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return udSegment(p0123, p3, pos);\n}", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross( rd, v0v2 );\n    float det = dot( v0v1, pvec );\n    vec3 tvec;\n    vec3 qvec;\n    if( det > 0.0 )\n    {\n        tvec = ro - v0;\n        qvec = cross( tvec, v0v1 );\n    }\n    else\n    {\n        det = -det;\n        tvec = v0 - ro;\n        qvec = cross( v0v1, tvec );\n    }\n    if( det < 0.00001 ) return vec3( -1.0 );\n    float invDet = 1.0 / det;\n    vec3 uvw = vec3( dot( tvec, pvec ) * invDet, dot( rd, qvec ) * invDet, dot( tvec, v0v2 ) * invDet );\n    if( uvw.y < 0.0 || uvw.x + uvw.y > 1.0 ) return vec3( -1.0 );\n    return uvw;\n}", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross( nor, v0v1 );\n    float det = dot( v0v2, pvec );\n    if( det < 0.000001 ) return 0.0;\n    vec3 tvec = pos - v0;\n    float u = dot( tvec, pvec );\n    if( u < 0.0 || u > det ) return 0.0;\n    vec3 qvec = cross( tvec, v0v2 );\n    float v = dot( nor, qvec );\n    if( v < 0.0 || u + v > det ) return 0.0;\n    return dot( v0v1, qvec ) / det;\n}", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);", "\n    float w = r2-r1;\n    float q = length(p.x);\n    float h = abs(p.y);\n    h = max(h-he,0.0);\n    q -= r1;\n    q = max(q,0.0);\n    float sq = sqrt(q*q+h*h);\n    return sq-w*sq/q;\n}", "\n    vec2 w = (b-a)*0.5;\n    vec2  c = (b+a)*0.5;\n    vec2  s = vec2( w.y, -w.x );\n    \n    float d = length( p - c );\n    float e = length( vec2( dot( p - c, w.yx ), dot( p - c, s.yx ) ) );\n    float f = clamp( dot( p - c, s ) / dot( w, s ), 0.0, length(w) );\n    \n    return sqrt( min( d*d, (e-ra)*(e-ra) + f*f ) ) - rb;\n}", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdf( pos + e.xyy ) + \n                      e.yyx*sdf( pos + e.yyx ) + \n                      e.yxy*sdf( pos + e.yxy ) + \n                      e.xxx*sdf( pos + e.xxx ) );\n}", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    ivec2 p = q;\n    p = ((p >> 16) ^ p) * ivec2( 0x45d9f3b, 0xd2b79f96 );\n    p = ((p >> 16) ^ p) * ivec2( 0x45d9f3b, 0xd2b79f96 );\n    p = ((p >> 16) ^ p);\n    return float( p.x ^ p.y ) / 4294967296.0;\n}\n\n// random hash\nfloat", "\n    vec2 i = floor( x );\n    vec2 f = fract( x );\n    \n    float a = float(p);\n    float b = float(p+1);\n    float c = float(p+p);\n    float d = float(p+p+1);\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix( mix( a*a*a*(a*(a*6.0-15.0)+10.0)*u.x + b*b*b*(b*(b*6.0-15.0)+10.0)*u.y,\n                     c*c*c*(c*(c*6.0-15.0)+10.0)*u.x + d*d*d*(d*(d*6.0-15.0)+10.0)*u.y, u.x),\n                mix( a*a*a*(a*(a*6.0-15.0)+10.0)*u.x + b*b*b*(b*(b*6.0-15.0)+10.0)*u.y,\n                     c*c*c*(c*(c*6.0-15.0)+10.0)*u.x + d*d*d*(d*(d*6.0-15.0)+10.0)*u.y, u.x), u.y);\n}\n\n// basic value noise with derivatives\nvec", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < p; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D simplex noise\n// https://github.com/stegu/webgl-noise/blob/master/src/noise2D.glsl\nfloat", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/Xds3zN\nfloat", "\n    float k0 = length(p.xy);\n    float k1 = length(p.xyz);\n    float z = p.z;\n    float s = (r.x*r.x - r.y*r.y);\n    float k2 = (k0*k0 + z*z - r.x*r.x - r.y*r.y)/s;\n    float k3 = (k0*(p.z*p.z + r.y*r.y) + z*z*r.x*r.x)/s;\n    float d = k2*k2*s + k3*k3 - s;\n    return sqrt(d)*sign(d);\n}\n\n// symmetric ellipsoid - APPROXIMATE distance\nfloat", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0 * (k0-1.0) / k1;\n}\n\n// generic ellipsoid - better but still bad approximated distance\nfloat", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0 * (k0-1.0) / k1;\n}\n\n// generic ellipsoid - exact distance\nfloat", "\n    vec2 q = vec2( p.x, p.y );\n    vec2 s = sign(fract(q)-0.5);\n    vec2 r = s*fract(q);\n    return dot(r,r);\n}\n\nfloat", "\n\treturn a * x / ( a - x * ( a - 1.0 ) );\n}", "\n    float y = x - floor( x );\n    if( y < p )\n        return y / p;\n    else\n        return ( y - p ) / ( 1.0 - p );\n}\n\n// unbiased sawtooth\nfloat", "\n    float h2 = h*h;\n    float h3 = h2*h;\n    float h4 = h3*h;\n    float h5 = h4*h;\n    float h6 = h5*h;\n    float h7 = h6*h;\n    float h8 = h7*h;\n    float h9 = h8*h;\n    float h10 = h9*h;\n    float h11 = h10*h;\n    float h12 = h11*h;\n    float h13 = h12*h;\n    float h14 = h13*h;\n    float h15 = h14*h;\n    float h16 = h15*h;\n    float h17 = h16*h;\n    float h18 = h17*h;\n    float h19 = h18*h;\n    float h20 = h19*h;\n    float h21 = h20*h;\n    float h22 = h21*h;\n    float h23 = h22*h;\n    float h24 = h23*h;\n    float h25 = h24*h;\n    float h26 = h25*h;\n    float h27 = h26*h;\n    float h28 = h27*h;\n    float h29 = h28*h;\n    float h30 = h29*h;\n    float h31 = h30*h;\n    float h32 = h31*h;\n    float h33 = h32*h;\n    float h34 = h33*h;\n    float h35 = h34*h;\n    float h36 = h35*h;\n    float h37 = h36*h;\n    float h38 = h37*h;\n    float h39 = h38*h;\n    float h40 = h39*h;\n    float h41 = h40*h;\n    float h42 = h41*h;\n    float h43 = h42*h;\n    float h44 = h43*h;\n    float h45 = h44*h;\n    float h46 = h45*h;\n    float h47 = h46*h;\n    float h48 = h", "\n    vec3  pa_pb = pb - pa;\n    vec3  pa_ro = ro - pa;\n    float b = dot(pa_pb, rd);\n    float c = dot(pa_pb, pa_pb) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = -b-h;\n    vec3  p = ro + t*rd;\n    vec3  pa_p = p - pa;\n    float s = dot(pa_p, rd);\n    if( s < 0.0 || s > length(pa_pb) )\n    {\n        t = -b+h;\n        p = ro + t*rd;\n        pa_p = p - pa;\n        s = dot(pa_p, rd);\n        if( s < 0.0 || s > length(pa_pb) ) return -1.0;\n    }\n    return t;\n}", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - mix(ra, rb, h);\n}", "\n    vec3  ba = b - a;\n    vec3  oa = a - ro;\n    float baba = dot( ba, ba );\n    float oaba = dot( oa, ba );\n    float t = ( oaba + sqrt( k * k * baba - ( oaba * oaba - baba * ( dot( oa, oa ) - r * r ) ) ) ) / baba;\n    return clamp( t, 0.0, 1.0 );\n}\n\n// soft shadow occlusion\nfloat", "\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float d = rad1 - rad2;\n    float t = rad1 - th;\n    float s = rad1 + th;\n    float f = rad2 - th;\n    float g = rad2 + th;\n    float h = rad1 - rad2 - th;\n    float i = rad1 + rad2 + th;\n    float j = rad1 - rad2 + th;\n    float k = rad1 + rad2 - th;\n    float l = rad1 - rad2 - th;\n    float m = rad1 + rad2 + th;\n    float n = rad1 - rad2 + th;\n    float o = rad1 + rad2 - th;\n    float p = rad1 - rad2 - th;\n    float q = rad1 + rad2 + th;\n    float r = rad1 - rad2 + th;\n    float s = rad1 + rad2 - th;\n    float t = rad1 - rad2 - th;\n    float u = rad1 + rad2 + th;\n    float v = rad1 - rad2 + th;\n    float w = rad1 + rad2 - th;\n    float x = rad1 - rad2 - th;\n    float y = rad1 + rad2 + th;\n    float z = rad1 - rad2 + th;\n    float aa = rad1 + rad2 - th;\n    float ab = rad1 - rad2 - th;\n    float ac = rad1 + rad2 + th;\n    float ad = rad1 - rad2 + th;\n    float ae = rad1 + rad2 - th;\n    float af = rad1 - rad2 - th;\n    float ag = rad1 + rad2 + th;\n    float ah = rad1 - rad2 + th;\n    float ai = rad1 + rad2 - th;\n    float aj = rad1 - rad2 - th;\n    float ak = rad1 + rad2 + th;\n    float al = rad1 - rad2 + th;\n    float am = rad1 + rad2 - th;\n    float an = rad1 - rad2 - th;\n    float ao", "\n    vec2 q = abs(p);\n    return max(q.y-c.y*r,q.x*c.x*r-c.y*p.y);\n}", "\n    float r = 1.0;\n    float a = 0.5;\n    float d = length(pos);\n    float f = d*d*d*d - r*r*r*r;\n    vec3  g = 4.0*pos*(d*d-r*r);\n    return g/length(g);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec", "\n    vec2 pa = vec2( sca.x*p.x - sca.y*p.y, sca.y*p.x + sca.x*p.y );\n    vec2 ba = vec2( scb.x*ra, scb.y*ra );\n    vec2 bb = vec2( scb.x*rb, scb.y*rb );\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float s = ( pa.x*ba.y > pa.y*ba.x )? -1.0 : 1.0;\n    float r = s*length( pa - bb*clamp( dot(pa,bb)/dot(bb,bb), 0.0, 1.0 ) );\n    return ( d - r );\n}", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(\n                          sdf(pos+h.xyy,time) - sdf(pos-h.xyy,time),\n                          sdf(pos+h.yxy,time) - sdf(pos-h.yxy,time),\n                          sdf(pos+h.yyx,time) - sdf(pos-h.yyx,time) ) );\n}", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    vec2 w = vec2( 0.5 ) - mod( p, vec2( 2.0 ) );\n    vec2 ww = smoothstep( vec2( 0.0 ), vec2( 1.0 ), w-dpdx );\n    vec2 ww2 = smoothstep( vec2( 0.0 ), vec2( 1.0 ), w+dpdx );\n    vec2 ww3 = smoothstep( vec2( 0.0 ), vec2( 1.0 ), w-dpdy );\n    vec2 ww4 = smoothstep( vec2( 0.0 ), vec2( 1.0 ), w+dpdy );\n    return ( ww.x * ww.y + ww2.x * ww2.y + ww3.x * ww3.y + ww4.x * ww4.y );\n}\n\nfloat", "\n    return sign(x)*(abs(x)-.5)/(.5*k);\n}\n\n// Inverse of the staircase function\nfloat", "\n    vec3 atmosphere_col = vec3(0.0);\n    float atmosphere_intensity = 0.0;\n    float atmosphere_distance = 0.0;\n    float atmosphere_step = 0.01;\n    float atmosphere_steps = 100.0;\n    for (float i = 0.0; i < atmosphere_steps; i += 1.0) {\n        vec3 atmosphere_pos = sample_pos + light_dir * atmosphere_distance;\n        vec3 atmosphere_sample = texture(atmosphere_texture, atmosphere_pos).rgb;\n        atmosphere_col += atmosphere_sample * atmosphere_step;\n        atmosphere_intensity += atmosphere_sample.r * atmosphere_step;\n        atmosphere_distance += atmosphere_step;\n    }\n    atmosphere_col /= atmosphere_intensity;\n    return atmosphere_col;\n}", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n    float sphere_radius_squared = sphere_radius * sphere_radius;\n    float sphere_radius_squared_inverse = 1.0 / sphere_radius_squared;\n    float sphere_radius_squared_inverse_minus_one = sphere_radius_squared_inverse - 1.0;\n    float sphere_radius_squared_inverse_minus_one_squared = sphere_radius_squared_inverse_minus_one * sphere_radius_squared_inverse_minus_one;\n    float sphere_radius_squared_inverse_minus_one_squared_inverse = 1.0 / sphere_radius_squared_inverse_minus_one_squared;\n    float sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one = sphere_radius_squared_inverse_minus_one_squared_inverse - 1.0;\n    float sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one_squared = sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one * sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one;\n    float sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one_squared_inverse = 1.0 / sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one_squared;\n    float sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one_squared_inverse_minus_one = sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one_squared_inverse - 1.0;\n    float sphere_radius_squared_inverse_minus_one_squared_inverse_minus_one_squared_inverse_minus_one_squared =", "\n    vec2 uv = coord / resolution.xy;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec3 camera_vector = vec3(uv2, 1.0);\n    return camera_vector;\n}\n\n/*\nnow we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec", "\n    // Cone with base 'c' and radius 'ra'\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q);\n    float z = length(p);\n    float a = ra / l;\n    float b = 1.0 - a;\n    float s = max(1.0, dot(c, q / l));\n    float d = dot(q, c) * b + sqrt(a * s - q.x * q.x) * q.y;\n    return z - d;\n}", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 1) {\n        return vec3(1.0, 0.0, 0.0);\n    } else if (material == 2) {\n        return vec3(0.0, 1.0, 0.0);\n    } else if (material == 3) {\n        return vec3(0.0, 0.0, 1.0);\n    } else if (material == 4) {\n        return vec3(1.0, 1.0, 0.0);\n    } else if (material == 5) {\n        return vec3(1.0, 0.0, 1.0);\n    } else if (material == 6) {\n        return vec3(0.0, 1.0, 1.0);\n    } else if (material == 7) {\n        return vec3(1.0, 1.0, 1.0);\n    } else if (material == 8) {\n        return vec3(0.5, 0.5, 0.5);\n    } else if (material == 9) {\n        return vec3(0.5, 0.0, 0.0);\n    } else if (material == 10) {\n        return vec3(0.0, 0.5, 0.0);\n    } else if (material == 11) {\n        return vec3(0.0, 0.0, 0.5);\n    } else if (material == 12) {\n        return vec3(0.5, 0.5, 0.0);\n    } else if (material == 13) {\n        return vec3(0.5, 0.0, 0.5);\n    } else if (material == 14) {\n        return vec3(0.0, 0.5, 0.5);\n    } else if (material == 15) {\n        return vec3(0.5, 0.5, 0.5);\n    ", "\n    switch (material) {\n        case MATERIAL_WATER:\n            return 0.05;\n        case MATERIAL_GLASS:\n            return 0.5;\n        case MATERIAL_METAL:\n            return 0.5;\n        case MATERIAL_PLASTIC:\n            return 0.5;\n        case MATERIAL_RUBBER:\n            return 0.5;\n        case MATERIAL_SILICON:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_WATER:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_GLASS:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_METAL:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_PLASTIC:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_RUBBER:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON_WITH_WATER:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON_WITH_GLASS:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON_WITH_METAL:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON_WITH_PLASTIC:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON_WITH_RUBBER:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILICON_WITH_SILICON:\n            return 0.5;\n        case MATERIAL_SILICON_WITH_SILIC", "\n    switch (material) {\n        case MATERIAL_AIR:\n            return 1.0f;\n        case MATERIAL_WATER:\n            return 1.33f;\n        case MATERIAL_GLASS:\n            return 1.52f;\n        case MATERIAL_DIAMOND:\n            return 2.42f;\n        default:\n            return 1.0f;\n    }\n}\n\n// Get the color of a material.\nvec", "\n    return material_opacity[material];\n}", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    vec3 qp = line_a - line_b;\n    vec3 pa = line_a - tri_a;\n    float d1 = dot(ab, pa);\n    float d2 = dot(ab, qp);\n    if (d1 * d2 < 0.0) {\n        vec3 ad = line_a - tri_c;\n        float d3 = dot(ac, pa);\n        float d4 = dot(ac, qp);\n        if (d3 * d4 < 0.0) {\n            vec3 ap = line_a - tri_b;\n            float d5 = dot(ab, ad);\n            float d6 = dot(ac, ap);\n            if (d5 * d6 < 0.0) {\n                float t = d1 / (d1 - d2);\n                vec3 c = line_a + t * qp;\n                vec3 bc = tri_c - tri_b;\n                vec3 cp = c - tri_b;\n                float u = dot(bc, cp) / dot(bc, bc);\n                float v = (dot(bc, pa) + u * dot(bc, qp)) / dot(bc, bc);\n                return vec3(true, u, v);\n            }\n        }\n    }\n    return vec3(false, 0.0, 0.0);\n}", "\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n\n    return mat3(x_axis, y_axis, z_axis);\n}", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = 0.0;\n    result.normal = vec3(0.0);\n    result.color = vec3(0.0);\n\n    // TODO: implement this function\n    return result;\n}", "\n    vec3 ray_direction = ray_target - ray_origin;\n    float ray_length = length(ray_direction);\n    ray_direction /= ray_length;\n\n    vec3 ray_pos = ray_origin;\n    float shadow_amount = 0.0;\n\n    for (int i = 0; i < 32; i++) {\n        if (ray_length < 0.01) {\n            break;\n        }\n\n        vec3 sample_pos = ray_pos + ray_direction * 0.01;\n        vec3 sample_normal = get_normal(sample_pos);\n        float sample_dist = length(sample_pos - ray_origin);\n        float sample_opacity = get_opacity(sample_pos);\n\n        if (sample_opacity > 0.0) {\n            float sample_shadow = 1.0 - sample_opacity;\n            float sample_dist_to_light = length(sample_pos - light_pos);\n            float sample_light_angle = dot(sample_normal, normalize(light_pos - sample_pos));\n            float sample_light_angle_falloff = 1.0 - clamp(sample_light_angle, 0.0, 1.0);\n            float sample_light_angle_falloff_squared = sample_light_angle_falloff * sample_light_angle_falloff;\n            float sample_light_angle_falloff_cubed = sample_light_angle_falloff_squared * sample_light_angle_falloff;\n            float sample_light_angle_falloff_cubed_squared = sample_light_angle_falloff_cubed * sample_light_angle_falloff_squared;\n            float sample_light_angle_falloff_cubed_squared_squared = sample_light_angle_falloff_cubed_squared * sample_light_angle_falloff_squared;\n            float sample_light_angle_falloff_cubed_squared_squared_squared = sample_light_angle_falloff_cubed_squared_squared * sample_light_angle_falloff_squared;\n", "\n    return fract( sin( x ) * 43758.5453 );\n}\n\n// 2D noise\nfloat", "\n    float i = floor( p );\n    float f = fract( p );\n    float u = f * f * ( 3.0 - 2.0 * f );\n    return mix( hash( i ), hash( i + 1.0 ), u );\n}\n\n// Smooth gradient noise\nfloat", "\n    int k = n;\n    k = (k+0x7ed55d16) + (k<<12);\n    k = (k^0xc761c23c) ^ (k>>19);\n    k = (k+0x165667b1) + (k<<5);\n    k = (k+0xd3a2646c) ^ (k<<9);\n    k = (k+0xfd7046c5) + (k<<3);\n    k = (k^0xb55a4f09) ^ (k>>16);\n    return k;\n}\n\n// float hash copied from Hugo Elias\nfloat", "\n    float i = floor( p );\n    float f = fract( p );\n    float u = f * f * ( 3.0 - 2.0 * f );\n    return mix( hash( i ), hash( i + 1.0 ), u );\n}\n\n// 2D gradient noise\nfloat", "\n    float f = 0.0;\n    float a = 1.0;\n    float p = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x * G + 0.5;\n        a *= p;\n    }\n    return f;\n}\n\n// fbm\nfloat", "\n    vec3 c = vec3(0.0);\n    \n    // Get the solutions of the quadratic polynomial\n    vec2 s = getSolutions( p );\n    \n    // If there are two solutions, draw a line between them\n    if( s.x < s.y )\n    {\n        // Get the line's color\n        c = getLineColor( s );\n    }\n    \n    return c;\n}", "\n    vec3 p = pb * 0.5 + 0.5;\n    \n    // Get the 4D point\n    vec4 p4 = vec4(\n        cos( p.x * 2.0 * PI ),\n        cos( p.y * 2.0 * PI ),\n        cos( p.z * 2.0 * PI ),\n        sin( p.x * 2.0 * PI ) * sin( p.y * 2.0 * PI ) * sin( p.z * 2.0 * PI )\n    );\n    \n    // Get the coefficients of the cubic polynomial\n    vec4 abcd = getCoefficients( p4 );\n    \n    // Get the solutions of the cubic polynomial\n    vec4 solutions = solveCubic( abcd );\n    \n    // Get the color based on the solutions\n    return getColorFromSolutions( solutions );\n}", "\n    vec3 m = (cen-ro)/rd;\n    vec3 n = 1.0/rd;\n    vec3 k = abs(n)*rad;\n    vec3 t1 = -m-k;\n    vec3 t2 = -m+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec4(0.0);\n    return vec4( tN, tF, 0.0, 0.0 );\n}\n\nvec", "\n    vec3  q = ro - cen;\n    float b = dot(rd,q);\n    float c = dot(q,q) - dot(rad,rad);\n    float h = b*b - c;\n    if( h<0.0 ) return 1.0;\n    h = sqrt(h);\n    float t1 = -b-h;\n    float t2 = -b+h;\n    return clamp( min(t1,t2)/dot(rad,rad), 0.0, 1.0 );\n}\n\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 32; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, w * h / t);\n        t += clamp(h, 0.01, 0.5);\n        if (h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}", " seed = fmod(seed * 16807.0, 2147483647.0); return seed / 2147483647.0; }\nfloat", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec", "\n    vec2 q = abs(p.xz);\n    float k = max(la*lb,lb*h);\n    float d = max(q.x*lb+q.y*la,q.x*la+q.y*lb)-k;\n    d = max(d,abs(p.y)-h);\n    d = max(d,length(max(abs(vec2(p.x,p.z))-vec2(la,lb),0.0))-ra);\n    return d;\n}", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + h*ba;\n    float d = length(pa - q) - r;\n    float w = length(q - p);\n    float x = d;\n    float y = w - r;\n    float z = w + r;\n    return vec4(x,y,z,w);\n}", "\n    vec2 d = abs(p)-b;\n    vec2 e = max(d,vec2(0.0));\n    vec2 f = min(d,vec2(0.0));\n    float g = length(e);\n    float h = min(max(e.x,e.y),0.0);\n    float i = max(e.x,e.y);\n    float j = length(max(d,vec2(0.0)));\n    float k = min(max(d.x,d.y),0.0);\n    float l = max(d.x,d.y);\n    float m = length(max(d,vec2(0.0)));\n    float n = min(max(d.x,d.y),0.0);\n    float o = max(d.x,d.y);\n    float p = length(max(d,vec2(0.0)));\n    float q = min(max(d.x,d.y),0.0);\n    float r = max(d.x,d.y);\n    float s = length(max(d,vec2(0.0)));\n    float t = min(max(d.x,d.y),0.0);\n    float u = max(d.x,d.y);\n    float v = length(max(d,vec2(0.0)));\n    float w = min(max(d.x,d.y),0.0);\n    float x = max(d.x,d.y);\n    float y = length(max(d,vec2(0.0)));\n    float z = min(max(d.x,d.y),0.0);\n    float aa = max(d.x,d.y);\n    float ab = length(max(d,vec2(0.0)));\n    float ac = min(max(d.x,d.y),0.0);\n    float ad = max(d.x,d.y);\n    float ae = length(max(d,vec2(0.0)));\n    float af = min(max(d.x,d.y),0.0);\n    ", "\n    vec2 d = abs(p)-b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0),\n                d.x,d.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    float d = length(p) - r;\n    float d2 = length(p) - (r-band);\n    float d3 = length(p) - (r+band);\n    return vec4(d, d2, d3, 0.0);\n}", "\n    int i, j;\n    float d = 1e10;\n    for( i = 0; i < 5; i++ )\n    {\n        j = (i+1)%5;\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        float l2 = dot(e,e);\n        float t = clamp( dot(w,e)/l2, 0.0, 1.0 );\n        d = min( d, length(w-t*e) - r );\n    }\n    return d;\n}\n\nfloat", "\n    vec2 q = p;\n    float a = 0.0;\n    float b = -2.0 * PI;\n    float d = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float t = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float s = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    ", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h), h, dot(pa,ba) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return vec3(length(p)-r, p.x, p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 q = X*p;\n    float a = dot(q,q);\n    float b = dot(p,X[2]);\n    float c = dot(p,p)-1.0;\n    float d = b*b-a*c;\n    if (d < 0.0) {\n        tan1 = tan2 = vec3(0.0);\n        return false;\n    }\n    d = sqrt(d);\n    tan1 = (b*X[0] - d*X[1]) / a;\n    tan2 = (b*X[0] + d*X[1]) / a;\n    return true;\n}", "\n    vec3 c = a;\n    if (b.x == 0.0) {\n        c.x += 0.0001;\n    }\n    if (b.y == 0.0) {\n        c.y += 0.0001;\n    }\n    if (b.z == 0.0) {\n        c.z += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec", "\n    return pow(R - x, 3);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat", "\n    return 1.0f / (e * R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat", "\n    float k = (a - b) / (R * R);\n    return k * e;\n}", "\n    return e * max(0.0, length(p - c) - R);\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// h: height\n// e: energy\nfloat", "\n    vec3 d = b - a;\n    float d2 = dot(d, d);\n    float d3 = d2 * sqrt(d2);\n    float d4 = d2 * d2;\n    float d5 = d4 * sqrt(d2);\n    float d6 = d4 * d2;\n    float d7 = d6 * sqrt(d2);\n    float d8 = d6 * d2;\n    float d9 = d8 * sqrt(d2);\n    float d10 = d8 * d2;\n    float d11 = d10 * sqrt(d2);\n    float d12 = d10 * d2;\n    float d13 = d12 * sqrt(d2);\n    float d14 = d12 * d2;\n    float d15 = d14 * sqrt(d2);\n    float d16 = d14 * d2;\n    float d17 = d16 * sqrt(d2);\n    float d18 = d16 * d2;\n    float d19 = d18 * sqrt(d2);\n    float d20 = d18 * d2;\n    float d21 = d20 * sqrt(d2);\n    float d22 = d20 * d2;\n    float d23 = d22 * sqrt(d2);\n    float d24 = d22 * d2;\n    float d25 = d24 * sqrt(d2);\n    float d26 = d24 * d2;\n    float d27 = d26 * sqrt(d2);\n    float d28 = d26 * d2;\n    float d29 = d28 * sqrt(d2);\n    float d30 = d28 * d2;\n    float d31 = d30 * sqrt(d2);\n    float d32 = d30 * d2;\n    float d33 = d32 * sqrt(d2);\n    float d34 = d32 * d2;\n    float d35 = d34 * sqrt(d2);\n    float d36 = d34 * d2;\n    float d37 = d36 * sqrt(d2);\n    float d38 = d36 * d2;\n    float d", "\n    float d = 1e10;\n    d = min(d, Tree(p));\n    return d;\n}\n\n// Tree\nfloat", "\n    return length(a - b);\n}\n\n// K root\nfloat", "\n    vec2 e = vec2(.001, 0);\n    return normalize(vec3(\n        ObjectDistance(p + e.xyy) - ObjectDistance(p - e.xyy),\n        ObjectDistance(p + e.yxy) - ObjectDistance(p - e.yxy),\n        ObjectDistance(p + e.yyx) - ObjectDistance(p - e.yyx)\n    ));\n}\n\n// Normal evaluation with derivatives\nvec", "\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = length(p) - 1.0;\n        if (d < 0.0001)\n        {\n            h = true;\n            s = i;\n            return t;\n        }\n        t += d;\n    }\n    h = false;\n    s = 0;\n    return t;\n}", "\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        float d = Distance(o + u * t);\n        if (d < 0.001)\n        {\n            h = true;\n            s = i;\n            return t;\n        }\n        t += d;\n    }\n    h = false;\n    s = 0;\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n    return vec3(0.0);\n}\n\nvec", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\nfloat", "\n    return coord / textureSize(tex, 0);\n}\n\n// normalized texture coordinate\nvec", "\n    vec2  d = max( vec2(0.0), p.yx-q.yx );\n    vec2  a = vec2( dot( d, vec2(0.5,0.0) ), d.x );\n    vec2  b = vec2( dot( d, vec2(0.0,0.5) ), d.y );\n    float s = ( a.x*b.y - a.y*b.x ) * 0.5;\n    return vec3( s, b.x, b.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = vec2(length(p), atan(p.y, p.x));\n    float a = 0.5 * (r - d);\n    float b = 0.5 * (r + d);\n    float c = 0.5 * (r - d);\n    float d2 = 0.5 * (r + d);\n    float e = 0.5 * (r + d);\n    float f = 0.5 * (r - d);\n    float g = 0.5 * (r + d);\n    float h = 0.5 * (r - d);\n    float i = 0.5 * (r + d);\n    float j = 0.5 * (r - d);\n    float k = 0.5 * (r + d);\n    float l = 0.5 * (r - d);\n    float m = 0.5 * (r + d);\n    float n = 0.5 * (r - d);\n    float o = 0.5 * (r + d);\n    float p2 = 0.5 * (r - d);\n    float q2 = 0.5 * (r + d);\n    float r2 = 0.5 * (r - d);\n    float s = 0.5 * (r + d);\n    float t = 0.5 * (r - d);\n    float u = 0.5 * (r + d);\n    float v = 0.5 * (r - d);\n    float w = 0.5 * (r + d);\n    float x = 0.5 * (r - d);\n    float y = 0.5 * (r + d);\n    float z = 0.5 * (r - d);\n    float a2 = 0.5 * (r + d);\n    float b2 = 0.5 * (r - d);\n    float c2 = 0.5 * (r + d);\n    float d3 = 0.5 * (r - d);\n    float e3 = 0.5 * (r + d);\n    float f3 = 0.5 * (r -", "\n    vec2 q = abs(p);\n    float d = length(q - c*r);\n    float a = atan(q.y-c.y,q.x-c.x);\n    float s = step(a,c.x);\n    return vec3(d,s,0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec", "\n    vec2 e[3];\n    vec3 w;\n    vec3 res;\n    \n    e[0] = v[1] - v[0];\n    e[1] = v[2] - v[1];\n    e[2] = v[0] - v[2];\n    \n    // Vector from v[0] to position p\n    vec2 v0 = p - v[0];\n    \n    // Project v0 onto each e[i] to get barycentric coordinates\n    w.x = dot( v0, e[2] );\n    w.y = dot( v0, e[0] );\n    w.z = dot( v0, e[1] );\n    \n    // If the point is inside the triangle, the sum of the barycentric coordinates is 1\n    if( w.x < 0.0 || w.y < 0.0 || w.z < 0.0 )\n    {\n        // Find the closest edge\n        vec2 v02 = v[0] - v[2];\n        vec2 v12 = v[1] - v[2];\n        vec2 v01 = v[0] - v[1];\n        vec2 v20 = v[2] - v[0];\n        \n        float d0 = dot( v02, v02 );\n        float d1 = dot( v12, v12 );\n        float d2 = dot( v01, v01 );\n        float d3 = dot( v20, v20 );\n        \n        float minDist = min( d0, min( d1, min( d2, d3 ) ) );\n        \n        if( minDist == d0 )\n        {\n            res.x = dot( v02, v0 );\n            res.y = dot( v02, e[2] );\n            res.z = dot( v02, e[0] );\n        }\n        else if( minDist == d1 )\n        {\n            res.x = dot( v12, v0 );\n            res.y = dot( v12, e[2] );\n            res.z = dot( v12, e[1] );\n", "\n    vec2 q = vec2( dot(sca,p), dot(scb,p) );\n    vec2 w = vec2( ra, rb ) - abs(q);\n    float s = max(w.x,w.y);\n    return vec3(s,sca*(q+sign(w)*s),scb*(q+sign(w)*s));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec", "\n    return a.x*b.y - a.y*b.x;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\n    vec2 q = vec2( dot( p, ab.xy ), dot( p, ab.yx ) );\n    return vec3( q, length(q) );\n}", "\n    vec2 q = vec2( length(p.xz)-2.0*ra+rb, p.y );\n    return vec4(q.x, q.y, 0.0, 1.0);\n}", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3 q = a + h * ba;\n    return vec4( length(pa-q) - r, normalize(pa-q), 0.0, 0.0 );\n}", "\n    vec2 q = vec2( p.x, p.y + sk*p.x );\n    vec2 a = vec2( wi, he );\n    vec2 b = vec2( -wi, he );\n    vec2 c = vec2( 0, 0 );\n    vec2 d = vec2( 0, he );\n    vec2 e = vec2( wi, 0 );\n    vec2 f = vec2( -wi, 0 );\n    vec2 g = vec2( 0, 0 );\n    vec2 h = vec2( 0, he );\n    vec2 n = vec2( 0, 1 );\n    float s = -1.0;\n    float u = sdTriangle( q, a, b, c );\n    float v = sdTriangle( q, d, e, f );\n    float w = sdTriangle( q, g, h, n );\n    return min( min( u, v ), w );\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat", "\n    vec2 q = vec2( p.x, p.y*sk );\n    vec2 a = vec2( 0.0, 0.0 );\n    vec2 b = vec2( wi, 0.0 );\n    vec2 c = vec2( 0.0, he );\n    vec2 d = vec2( wi, he );\n    vec2 e = vec2( 0.0, 0.0 );\n    vec2 f = vec2( wi, 0.0 );\n    vec2 g = vec2( 0.0, he );\n    vec2 h = vec2( wi, he );\n    vec2 n = vec2( 0.0, 1.0 );\n    vec2 o = vec2( 1.0, 0.0 );\n    vec2 p0 = vec2( 0.0, 0.0 );\n    vec2 p1 = vec2( 0.0, 1.0 );\n    vec2 p2 = vec2( 1.0, 0.0 );\n    vec2 p3 = vec2( 1.0, 1.0 );\n    vec2 p4 = vec2( 0.0, 0.0 );\n    vec2 p5 = vec2( 0.0, 1.0 );\n    vec2 p6 = vec2( 1.0, 0.0 );\n    vec2 p7 = vec2( 1.0, 1.0 );\n    vec2 p8 = vec2( 0.0, 0.0 );\n    vec2 p9 = vec2( 0.0, 1.0 );\n    vec2 p10 = vec2( 1.0, 0.0 );\n    vec2 p11 = vec2( 1.0, 1.0 );\n    vec2 p12 = vec2( 0.0, 0.0 );\n    vec2 p13 = vec2( 0.0, 1.0 );\n    vec2 p14 = vec2( 1.0, 0.0 );\n    vec2 p15 = vec2( 1.0, 1.0 );\n    vec", "\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\nfloat", "\n    return a + k * (b - a);\n}\n\n// IQ's polynominal max\nfloat", "\n    vec2 n = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return n;\n}\n\nfloat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tN, tF);\n}\n\n// IQ's ray sphere intersection\nvec", "\n    vec2 p1 = p + vec2(d.x, 0.0);\n    vec2 p2 = p + vec2(0.0, d.y);\n    vec2 p3 = p + vec2(-d.x, 0.0);\n    vec2 p4 = p + vec2(0.0, -d.y);\n    float d1 = distance(p, p1);\n    float d2 = distance(p, p2);\n    float d3 = distance(p, p3);\n    float d4 = distance(p, p4);\n    if (d1 < d2 && d1 < d3 && d1 < d4) {\n        e1 = p1;\n        e2 = p2;\n        e3 = p3;\n        e4 = p4;\n    } else if (d2 < d1 && d2 < d3 && d2 < d4) {\n        e1 = p2;\n        e2 = p1;\n        e3 = p4;\n        e4 = p3;\n    } else if (d3 < d1 && d3 < d2 && d3 < d4) {\n        e1 = p3;\n        e2 = p4;\n        e3 = p1;\n        e4 = p2;\n    } else {\n        e1 = p4;\n        e2 = p3;\n        e3 = p2;\n        e4 = p1;\n    }\n}", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec3 oc = ro - tor.y * rd;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - tor.x * tor.x;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float s1 = -b - h;\n    float s2 = -b + h;\n    float s = (s1 > s2)? s1 : s2;\n    if (s < 0.0) return -1.0;\n    return s;\n}", "\n    vec3 p = pos - tor.y * vec3(sin(pos.z), cos(pos.z), 0.0);\n    return normalize(vec3(tor.x * p.x, tor.x * p.y, tor.y * p.z));\n}\n\nfloat", "\n    float x2 = x * x;\n    return x * (27 + x2) / (27 + 9 * x2);\n}", "\n    col = pow(col, vec3(0.4545));\n    col = vec3(1.0) - exp(-col * 1.0);\n    col = mix(col, vec3(dot(col, vec3(0.2125, 0.7154, 0.0721))), -0.5);\n    col = mix(col, vec3(0.0), smoothstep(0.0, 1.0, q.y));\n    return col;\n}", "\n    vec2 n = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return n;\n}\n\nfloat", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    return length(p-c) - r;\n}\n\n// signed distance to a rectangle\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle\nfloat", " return a.x*b.y - a.y*b.x; }\nfloat", "\n    p = abs(p);\n    return max( length(max(vec2(p.x-s,p.y),vec2(p.x,p.y-s))),\n                p.x+r-s );\n}", "\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec", "\n    return vec3(\n        -6.0 * x.x * x.y * x.z,\n        -3.0 * x.x * x.x * x.z + 6.0 * x.x * x.y * x.z,\n        -3.0 * x.x * x.x * x.y + 3.0 * x.x * x.y * x.z\n    );\n}\n\n// derivative of s-curve\nvec", "\n    float a = atan(p.y,p.x)/6.28318;\n    float b = mod(a,1.0);\n    float c = abs(b-0.5)*2.0;\n    float d = sin(k*6.28318*c);\n    return length(p)-w*d;\n}", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat", "\n    // Calculate the transmittance for the ray.\n    vec3 transmittanceAtStart = exp(-rayLength * lightColor * density);\n    transmittance = transmittanceAtStart * exp(-rayLength * lightColor * density);\n\n    // Calculate the scattering for the ray.\n    vec3 scattering = transmittanceAtStart * exp(-rayLength * lightColor * density) * lightColor * density;\n\n    // Calculate the scattering for the ray.\n    return scattering;\n}", "\n    vec3 p = p2 - vec3(0.0, 0.0, d);\n    float s = length(p.xz) - ra;\n    float b = length(p.xz - p.y*vec2(1.0, 1.0/sqrt(3.0))) - rb;\n    return max(s, b);\n}", "\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y)-h)-t;\n}", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    float d = length(p.xz) - r;\n    return max(d, p.y-h);\n}", "\n    const float eps = 0.0005;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(\n              sdf(pos+h.xyy).x - sdf(pos-h.xyy).x,\n              sdf(pos+h.yxy).x - sdf(pos-h.yxy).x,\n              sdf(pos+h.yyx).x - sdf(pos-h.yyx).x ) );\n}", "\n    float d = length(p.x) - r;\n    return max(d, p.y-h);\n}", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// 3d fractal noise function\nfloat", "\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < 4; i++) {\n        value += amplitude * noise(p);\n        p *= 2.;\n        amplitude *=.5;\n    }\n    return value;\n}", "\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec", "\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat", "\n    return fract(sin(co * 12.9898) * 43758.5453);\n}\n\nfloat", "\n    return t <= 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nvec", "\n    return mix(\n        pow(c, vec3(2.4)) * 1.055 - 0.055,\n        c * 12.92,\n        lessThan(c, vec3(0.0031308))\n    );\n}\n\nvec", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t > 0.0) {\n        if (t < dbuffer) return t;\n        dbuffer = t;\n    }\n    t = -b + h;\n    if (t > 0.0) {\n        if (t < dbuffer) return t;\n        dbuffer = t;\n    }\n    return -1.0;\n}\n\nfloat", "\n    vec4 q = p;\n    q.xyz = abs(q.xyz);\n    q.xyz = q.xyz - 1.0;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz", "\n    vec3 q = abs(p)/r-1.0;\n    return vec4(length(max(q,0.0))*sign(p.x), q.x, q.y, q.z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return vec4(\n        front.rgb * front.a + back.rgb * (1.0 - front.a),\n        front.a + back.a * (1.0 - front.a)\n    );\n}\n\nvec", "\n    return (front.a == 0.0)? back : (front.rgb * front.a + back * back * (1.0 - front.a));\n}\n\nvec", "\n    p = abs(p);\n    float q = length(p.xy);\n    float d = (q - 2.0*r) + sqrt(p.x*p.x + p.y*p.y - r*r);\n    return d;\n}\n\nfloat", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    Temp = clamp(Temp, 0.0, 1.0);\n    vec3 bb = vec3(0.0);\n    bb.r = 3.92 * pow(Temp, 4.0) +.002 * pow(Temp, 5.0);\n    bb.g = 3.92 * pow(Temp, 3.0) +.000 * pow(Temp, 4.0);\n    bb.b = 3.92 * pow(Temp, 2.0) +.000 * pow(Temp, 3.0);\n    return bb;\n}\n\nvec", "\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(dot(hash22(ip), u), dot(hash22(ip + vec2(1.0, 0.0)), u - vec2(1.0, 0.0)), u.x),\n        mix(dot(hash22(ip + vec2(0.0, 1.0)), u - vec2(0.0, 1.0)), dot(hash22(ip + vec2(1.0, 1.0)), u - vec2(1.0, 1.0)), u.x),\n        u.y);\n    return res*res;\n}\n\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h<0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\nvec", "\n    float r = length(p);\n    float d = r - pow(abs(r), n);\n    return vec3(d, p / r, normalize(p));\n}", "\n    return 0.5f * ( 1.0f - cos( M_PI * x / t ) );\n}\n\n// generalization of Devil's Staircase\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    float d = 1e10;\n    for (int i = 0; i < 3; i++) {\n        if (i == idx) continue;\n        vec3 q = p - vec3(0, 0, 0);\n        float r = 1.0;\n        float a = 0.0;\n        for (int j = 0; j < 3; j++) {\n            if (j == i) continue;\n            q = abs(q);\n            q /= r;\n            q -= vec3(0.5);\n            a += atan(q.y, q.x);\n            r *= 3.0;\n        }\n        d = min(d, length(q) * cos(a));\n    }\n    return d;\n}\n\n// main raymarch func\nfloat", "\n    float sign = (x < 0.0)? -1.0 : 1.0;\n    float atan = sign * 0.5 * PI + 0.25 * PI * y * (1.0 - sign * x / (x * x + y * y));\n    return atan;\n}\n\nfloat", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Hyperbolic tangent\nvec", "\n    return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n}\n\nvec", "\n    float alphaSum = alpha.r + alpha.g + alpha.b;\n    alpha = alpha / alphaSum;\n    alpha = pow(alpha, vec4(contrast));\n    alpha = alpha * alphaSum;\n    return alpha;\n}", "\n    vec3 q = abs(p);\n    return max(q.x + q.y, max(q.x, q.y) + q.z) - 1.0;\n}", "\n    tilingVal3D tval;\n    tval.val = 0.0;\n    tval.isBoundary = false;\n    \n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw * 3.0;\n    vec3 uvw4 = uvw * 4.0;\n    vec3 uvw5 = uvw * 5.0;\n    vec3 uvw6 = uvw * 6.0;\n    vec3 uvw7 = uvw * 7.0;\n    vec3 uvw8 = uvw * 8.0;\n    vec3 uvw9 = uvw * 9.0;\n    vec3 uvw10 = uvw * 10.0;\n    vec3 uvw11 = uvw * 11.0;\n    vec3 uvw12 = uvw * 12.0;\n    vec3 uvw13 = uvw * 13.0;\n    vec3 uvw14 = uvw * 14.0;\n    vec3 uvw15 = uvw * 15.0;\n    vec3 uvw16 = uvw * 16.0;\n    vec3 uvw17 = uvw * 17.0;\n    vec3 uvw18 = uvw * 18.0;\n    vec3 uvw19 = uvw * 19.0;\n    vec3 uvw20 = uvw * 20.0;\n    vec3 uvw21 = uvw * 21.0;\n    vec3 uvw22 = uvw * 22.0;\n    vec3 uvw23 = uvw * 23.0;\n    vec3 uvw24 = uvw * 24.0;\n    vec3 uvw25 = uvw * 25.0;\n    vec3 uvw26 = uvw * 26.0;\n    vec3 uvw27 = uvw * 27.0;\n    vec3 uvw28 =", "\n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw2 * 2.0;\n    vec3 uvw4 = uvw3 * 2.0;\n    vec3 uvw5 = uvw4 * 2.0;\n    vec3 uvw6 = uvw5 * 2.0;\n    vec3 uvw7 = uvw6 * 2.0;\n    vec3 uvw8 = uvw7 * 2.0;\n    vec3 uvw9 = uvw8 * 2.0;\n    vec3 uvw10 = uvw9 * 2.0;\n    vec3 uvw11 = uvw10 * 2.0;\n    vec3 uvw12 = uvw11 * 2.0;\n    vec3 uvw13 = uvw12 * 2.0;\n    vec3 uvw14 = uvw13 * 2.0;\n    vec3 uvw15 = uvw14 * 2.0;\n    vec3 uvw16 = uvw15 * 2.0;\n    vec3 uvw17 = uvw16 * 2.0;\n    vec3 uvw18 = uvw17 * 2.0;\n    vec3 uvw19 = uvw18 * 2.0;\n    vec3 uvw20 = uvw19 * 2.0;\n    vec3 uvw21 = uvw20 * 2.0;\n    vec3 uvw22 = uvw21 * 2.0;\n    vec3 uvw23 = uvw22 * 2.0;\n    vec3 uvw24 = uvw23 * 2.0;\n    vec3 uvw25 = uvw24 * 2.0;\n    vec3 uvw26 = uvw25 * 2.0;\n    vec3 uvw27 = uvw26 * 2.0;\n    vec3 uvw28 = uvw27 * 2.0;", "\n    vec3 uvw2 = uvw * gridRes;\n    vec3 uvw3 = uvw2 * uvw2;\n    vec3 uvw4 = uvw3 * uvw2;\n    vec3 uvw5 = uvw4 * uvw2;\n    vec3 uvw6 = uvw5 * uvw2;\n    vec3 uvw7 = uvw6 * uvw2;\n    vec3 uvw8 = uvw7 * uvw2;\n    vec3 uvw9 = uvw8 * uvw2;\n    vec3 uvw10 = uvw9 * uvw2;\n    vec3 uvw11 = uvw10 * uvw2;\n    vec3 uvw12 = uvw11 * uvw2;\n    vec3 uvw13 = uvw12 * uvw2;\n    vec3 uvw14 = uvw13 * uvw2;\n    vec3 uvw15 = uvw14 * uvw2;\n    vec3 uvw16 = uvw15 * uvw2;\n    vec3 uvw17 = uvw16 * uvw2;\n    vec3 uvw18 = uvw17 * uvw2;\n    vec3 uvw19 = uvw18 * uvw2;\n    vec3 uvw20 = uvw19 * uvw2;\n    vec3 uvw21 = uvw20 * uvw2;\n    vec3 uvw22 = uvw21 * uvw2;\n    vec3 uvw23 = uvw22 * uvw2;\n    vec3 uvw24 = uvw23 * uvw2;\n    vec3 uvw25 = uvw24 * uvw2;\n    vec3 uvw26 = uvw25 * uvw2;\n    vec3 uvw27 = uvw26 * uvw2;\n    vec3 uvw28 = uvw27 * uvw2;\n    ", "\n    vec3 a = abs(p);\n    return (a.x + a.y + a.z - 1.0) * sqrt(3.0);\n}\n\n//Icosahedron Distance from Center\nfloat", "\n    vec3 a = vec3(0.5, 0.5, 1.0);\n    vec3 b = vec3(0.5, 1.0, 0.5);\n    vec3 c = vec3(1.0, 0.5, 0.5);\n    vec3 d = vec3(0.8, 0.6, 0.0);\n    return a + b*cos(2.0*3.141592653589793*vec3(0.0, 0.5, 1.0)*t + vec3(0.0, 2.0943951023931953, 4.1887902047863906));\n}\n\n// makes Cool colormap with polynimal 6\nvec", "\n    return v * cos(a.z) + cross(a.xyz, v) * sin(a.z) + a.xyz * dot(a.xyz, v) * (1.0 - cos(a.z));\n}", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    p = abs(p);\n    return (p.x + p.y + p.x * 0.5);\n}\n\n// Hexagonal Distancence from the 0,0 coords\nfloat", "\n    vec2 p = uv * 2. - 1.;\n    vec2 q = p;\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float s = 1. - r;\n    float t = 1. - abs(a);\n    float u = max(s, t);\n    float v = min(s, t);\n    float w = u - v;\n    float x = w * w;\n    float y = x * x;\n    float z = y * y;\n    float d = z * z;\n    float e = 1. - d;\n    float f = e * e;\n    float g = f * f;\n    float h = g * g;\n    float i = h * h;\n    float j = i * i;\n    float k = j * j;\n    float l = k * k;\n    float m = l * l;\n    float n = m * m;\n    float o = n * n;\n    float p = o * o;\n    float q = p * p;\n    float r = q * q;\n    float s = r * r;\n    float t = s * s;\n    float u = t * t;\n    float v = u * u;\n    float w = v * v;\n    float x = w * w;\n    float y = x * x;\n    float z = y * y;\n    float d = z * z;\n    float e = 1. - d;\n    float f = e * e;\n    float g = f * f;\n    float h = g * g;\n    float i = h * h;\n    float j = i * i;\n    float k = j * j;\n    float l = k * k;\n    float m = l * l;\n    float n = m * m;\n    float o = n * n;\n    float p = o * o;\n    float q = p * p;\n    float r = q * q;\n    float s = r * r;\n    float t = s * s;\n    float u = t * t;\n    float v = u * u", "\n    vec3 a = vec3(0.129, 0.278, 0.537);\n    vec3 b = vec3(0.125, 0.533, 0.651);\n    vec3 c = vec3(0.125, 0.533, 0.651);\n    vec3 d = vec3(0.125, 0.533, 0.651);\n    vec3 e = vec3(0.125, 0.533, 0.651);\n    vec3 f = vec3(0.125, 0.533, 0.651);\n    vec3 g = vec3(0.125, 0.533, 0.651);\n    vec3 h = vec3(0.125, 0.533, 0.651);\n    vec3 i = vec3(0.125, 0.533, 0.651);\n    vec3 j = vec3(0.125, 0.533, 0.651);\n    vec3 k = vec3(0.125, 0.533, 0.651);\n    vec3 l = vec3(0.125, 0.533, 0.651);\n    vec3 m = vec3(0.125, 0.533, 0.651);\n    vec3 n = vec3(0.125, 0.533, 0.651);\n    vec3 o = vec3(0.125, 0.533, 0.651);\n    vec3 p = vec3(0.125, 0.533, 0.651);\n    vec3 q = vec3(0.125, 0.533, 0.651);\n    vec3 r = vec3(0.125, 0.533, 0.651);\n    vec3 s = vec3(0.125, 0.533, 0.651);\n    vec3 tc = vec3(0.125, 0.533, 0.651);\n    vec3 u = vec3(0.125, 0.533, 0.651);\n    vec3 v = vec3(0.125, 0.533, 0.651);\n    vec3 w", "\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat", "\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float xi = floor(x);\n    float yi = floor(y);\n    float xf = x - xi;\n    float yf = y - yi;\n    float xi2 = xi * 2.0;\n    float yi2 = yi * 2.0;\n    float xi3 = xi * 3.0;\n    float yi3 = yi * 3.0;\n    float xi4 = xi * 4.0;\n    float yi4 = yi * 4.0;\n    float xi5 = xi * 5.0;\n    float yi5 = yi * 5.0;\n    float xi6 = xi * 6.0;\n    float yi6 = yi * 6.0;\n    float xi7 = xi * 7.0;\n    float yi7 = yi * 7.0;\n    float xi8 = xi * 8.0;\n    float yi8 = yi * 8.0;\n    float xi9 = xi * 9.0;\n    float yi9 = yi * 9.0;\n    float xi10 = xi * 10.0;\n    float yi10 = yi * 10.0;\n    float xi11 = xi * 11.0;\n    float yi11 = yi * 11.0;\n    float xi12 = xi * 12.0;\n    float yi12 = yi * 12.0;\n    float xi13 = xi * 13.0;\n    float yi13 = yi * 13.0;\n    float xi14 = xi * 14.0;\n    float yi14 = yi * 14.0;\n    float xi15 = xi * 15.0;\n    float yi15 = yi * 15.0;\n    float xi16 = xi * 16.0;\n    float yi16 = yi", "\n    float gridSize = 1.0 / gridRes;\n    float gridSizeHalf = gridSize * 0.5;\n    float gridSizeHalf2 = gridSizeHalf * 2.0;\n    float gridSizeHalf3 = gridSizeHalf * 3.0;\n    float gridSizeHalf4 = gridSizeHalf * 4.0;\n    float gridSizeHalf5 = gridSizeHalf * 5.0;\n    float gridSizeHalf6 = gridSizeHalf * 6.0;\n    float gridSizeHalf7 = gridSizeHalf * 7.0;\n    float gridSizeHalf8 = gridSizeHalf * 8.0;\n    float gridSizeHalf9 = gridSizeHalf * 9.0;\n    float gridSizeHalf10 = gridSizeHalf * 10.0;\n    float gridSizeHalf11 = gridSizeHalf * 11.0;\n    float gridSizeHalf12 = gridSizeHalf * 12.0;\n    float gridSizeHalf13 = gridSizeHalf * 13.0;\n    float gridSizeHalf14 = gridSizeHalf * 14.0;\n    float gridSizeHalf15 = gridSizeHalf * 15.0;\n    float gridSizeHalf16 = gridSizeHalf * 16.0;\n    float gridSizeHalf17 = gridSizeHalf * 17.0;\n    float gridSizeHalf18 = gridSizeHalf * 18.0;\n    float gridSizeHalf19 = gridSizeHalf * 19.0;\n    float gridSizeHalf20 = gridSizeHalf * 20.0;\n    float gridSizeHalf21 = gridSizeHalf * 21.0;\n    float gridSizeHalf22 = gridSizeHalf * 22.0;\n    float gridSizeHalf23 = gridSizeHalf * 23.0;\n    float gridSizeHalf24 = gridSizeHalf * 24.0;\n    float gridSizeHalf25 = gridSizeHalf * 25.0;\n    float gridSizeHalf26 = gridSizeHalf * 26.0;\n    float gridSizeHalf", "\n    vec2 center = vec2(0.5, 0.5);\n    vec2 offset = point - center;\n    float distance = length(offset);\n    float angle = atan(offset.y, offset.x);\n    float speed = 0.01;\n    float strength = 0.01;\n    float flow = 0.0;\n    if (distance < radius) {\n        flow = strength * sin(angle * 10.0 + time * speed);\n    }\n    return vec2(flow, 0.0);\n}\n\n// makes a simple flowmap of a wind\nvec", "\n    vec2 tileSize = vec2(1.0 / float(ARROW_TILE_SIZE), 1.0 / float(ARROW_TILE_SIZE));\n    vec2 tileCoord = floor(pos * tileSize);\n    return (tileCoord + 0.5) * tileSize;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec", "\n    vec2 v = p2 - p1;\n    vec2 w = p - p1;\n    float c1 = dot(w, v);\n    if (c1 <= 0.0) {\n        return length(w);\n    }\n    float c2 = dot(v, v);\n    if (c2 <= c1) {\n        return length(p - p2);\n    }\n    return length(cross(v, w) / sqrt(c2));\n}\n\n// Computes the signed distance from a circle\nfloat", "\n    // Arrow is a triangle with a base of 1.0 and height of 0.5\n    // The arrow is centered on the x-axis\n    // The arrow is rotated 45 degrees counterclockwise\n    // The arrow is scaled by the length desired in pixels for arrows\n    // The arrow is translated to the center of the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is", "\n    return (x + 1.0) * 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec", "\n    vec2 flow = vec2(0.0);\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    \n    // make a donut swirl\n    flow.x = cos(angle * spread + offset);\n    flow.y = sin(angle * spread + offset);\n    \n    // make the flowmap smaller in the middle\n    flow *= 1.0 - radius;\n    \n    return flow;\n}", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n    // the base SDF\n    float d = sdCircle( p, 0.5 );\n    \n    // the time-based rotation\n    float a = time * 0.5;\n    \n    // the rotation matrix\n    mat2 m = mat2( cos(a), sin(a), -sin(a), cos(a) );\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p = m * p;\n    \n    // the rotation\n    p =", "\n    float a = atan(p.y,p.x) + time;\n    float r = length(p);\n    float d = cos( floor(.5+a/sp) * sp - a ) * r;\n    return d - ra;\n}\n\nfloat", "\n    vec3 d = abs(uvw) - 0.5;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Cylinder\nfloat", "\n    vec3 uvw2 = uvw * 2.0 - 1.0;\n    vec3 uvw2abs = abs(uvw2);\n    vec3 uvw2absmax = max(uvw2abs.xyz, uvw2abs.yzx);\n    vec3 uvw2absmax2 = max(uvw2abs.xyz, uvw2abs.zxy);\n    vec3 uvw2absmax3 = max(uvw2abs.xyz, uvw2abs.xzy);\n    vec3 uvw2absmax4 = max(uvw2abs.yzx, uvw2abs.zxy);\n    vec3 uvw2absmax5 = max(uvw2abs.yzx, uvw2abs.yzx);\n    vec3 uvw2absmax6 = max(uvw2abs.zxy, uvw2abs.zxy);\n    vec3 uvw2absmax7 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax8 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax9 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax10 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax11 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax12 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax13 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax14 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 uvw2absmax15 = max(uvw2abs.xzy, uvw2abs.xzy);\n    vec3 u", "\n    vec3 uvw_ = uvw - offset;\n    vec3 uvw_abs = abs(uvw_);\n    vec3 uvw_sign = sign(uvw_);\n    vec3 uvw_sign_abs = abs(uvw_sign);\n    vec3 uvw_sign_abs_inv = 1.0 - uvw_sign_abs;\n    vec3 uvw_sign_abs_inv_abs = abs(uvw_sign_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs_inv_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_", "\n    vec3 a = vec3(0.125, 0.375, 0.75);\n    vec3 b = vec3(0.0, 0.5, 1.0);\n    vec3 c = vec3(1.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 1.0, 0.0);\n    vec3 e = vec3(0.0, 0.0, 1.0);\n    vec3 f = vec3(1.0, 1.0, 0.0);\n    vec3 g = vec3(1.0, 0.0, 1.0);\n    vec3 h = vec3(0.0, 1.0, 1.0);\n    vec3 i = vec3(0.5, 0.0, 0.0);\n    vec3 j = vec3(0.0, 0.5, 0.0);\n    vec3 k = vec3(0.0, 0.0, 0.5);\n    vec3 l = vec3(0.5, 0.5, 0.0);\n    vec3 m = vec3(0.5, 0.0, 0.5);\n    vec3 n = vec3(0.0, 0.5, 0.5);\n    vec3 o = vec3(0.5, 0.5, 0.5);\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 q = vec3(1.0, 1.0, 1.0);\n    vec3 r = vec3(0.5, 0.5, 0.5);\n    vec3 s = vec3(0.25, 0.25, 0.25);\n    vec3 t1 = mix(p, q, t);\n    vec3 t2 = mix(a, b, t);\n    vec3 t3 = mix(c, d, t);\n    vec3 t4 = mix(e, f, t);\n    vec3 t5 = mix(g, h, t);", "\n    vec3 q = abs(p);\n    return max(q.x + q.y + q.z - 1.0, max(q.x, max(q.y, q.z)) - 0.5);\n}", "\n    vec3 c = vec3(0.0);\n    if (t < 0.0) {\n        c = vec3(0.0);\n    } else if (t < 0.2) {\n        c = vec3(0.0, 0.0, 0.5) + vec3(0.0, 0.5, 1.0) * t / 0.2;\n    } else if (t < 0.4) {\n        c = vec3(0.0, 0.5, 1.0);\n    } else if (t < 0.6) {\n        c = vec3(0.0, 0.5, 1.0) + vec3(0.0, 1.0, 0.5) * (t - 0.4) / 0.2;\n    } else if (t < 0.8) {\n        c = vec3(0.0, 1.0, 0.5);\n    } else if (t < 1.0) {\n        c = vec3(0.0, 1.0, 0.5) + vec3(1.0, 0.5, 0.0) * (t - 0.8) / 0.2;\n    } else {\n        c = vec3(1.0, 0.5, 0.0);\n    }\n    return c;\n}\n\n// makes summer colormap with polynimal 6\nvec", "\n    vec2 p = fract(uv);\n    vec2 b = step(p, vec2(0.5));\n    return vec3(b.x * b.y);\n}\n\n// simple square Tiling\nvec", "\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x);\n}\n\n//rhombic shape form Manhattan distance\nvec", "\n    vec2 gridUV = uv * gridRes;\n    vec2 gridUVOffset = gridUV + offset;\n    vec2 gridUVFloor = floor(gridUVOffset);\n    vec2 gridUVFract = fract(gridUVOffset);\n    vec2 gridUVFractInverse = 1.0 - gridUVFract;\n    vec2 gridUVFractInverseSqrt = sqrt(gridUVFractInverse);\n    vec2 gridUVFractSqrt = sqrt(gridUVFract);\n    vec2 gridUVFractSqrtInverse = 1.0 - gridUVFractSqrt;\n    vec2 gridUVFractSqrtInverseSqrt = sqrt(gridUVFractSqrtInverse);\n    vec2 gridUVFractSqrtSqrt = sqrt(gridUVFractSqrt);\n    vec2 gridUVFractSqrtSqrtInverse = 1.0 - gridUVFractSqrtSqrt;\n    vec2 gridUVFractSqrtSqrtInverseSqrt = sqrt(gridUVFractSqrtSqrtInverse);\n    vec2 gridUVFractSqrtSqrtSqrt = sqrt(gridUVFractSqrtSqrt);\n    vec2 gridUVFractSqrtSqrtSqrtInverse = 1.0 - gridUVFractSqrtSqrtSqrt;\n    vec2 gridUVFractSqrtSqrtSqrtInverseSqrt = sqrt(gridUVFractSqrtSqrtSqrtInverse);\n    vec2 gridUVFractSqrtSqrtSqrtSqrt = sqrt(gridUVFractSqrtSqrtSqrt);\n    vec2 gridUVFractSqrtSqrtSqrtSqrtInverse = 1.0 - gridUVFractSqrtSqrtSqrtSqrt;\n    vec2 gridUVFractSqrtSqrtSqrtSqrtInverseSqrt = sqrt(gridUVFractSqrtSqrtSqrt", "\n    vec2 grid = vec2(gridRes);\n    vec2 gridPos = floor(uv * grid);\n    vec2 gridUV = gridPos / grid;\n    vec2 gridUV2 = gridUV + vec2(0.5);\n    vec2 gridUV3 = gridUV + vec2(1.0);\n    vec2 gridUV4 = gridUV + vec2(1.5);\n    vec2 gridUV5 = gridUV + vec2(2.0);\n    vec2 gridUV6 = gridUV + vec2(2.5);\n    vec2 gridUV7 = gridUV + vec2(3.0);\n    vec2 gridUV8 = gridUV + vec2(3.5);\n    vec2 gridUV9 = gridUV + vec2(4.0);\n    vec2 gridUV10 = gridUV + vec2(4.5);\n    vec2 gridUV11 = gridUV + vec2(5.0);\n    vec2 gridUV12 = gridUV + vec2(5.5);\n    vec2 gridUV13 = gridUV + vec2(6.0);\n    vec2 gridUV14 = gridUV + vec2(6.5);\n    vec2 gridUV15 = gridUV + vec2(7.0);\n    vec2 gridUV16 = gridUV + vec2(7.5);\n    vec2 gridUV17 = gridUV + vec2(8.0);\n    vec2 gridUV18 = gridUV + vec2(8.5);\n    vec2 gridUV19 = gridUV + vec2(9.0);\n    vec2 gridUV20 = gridUV + vec2(9.5);\n    vec2 gridUV21 = gridUV + vec2(10.0);\n    vec2 gridUV22 = gridUV + vec2(10.5);\n    vec2 gridUV23 = gridUV + vec2(11.0);\n    vec2 gridUV24 = gridUV + vec2(11.5);\n    vec2 gridUV25 = gridUV + vec2(12.0);\n    vec2 gridUV26 = gridUV + vec2(12.5);\n    vec2 gridUV27 = gridUV + vec2(13.0);\n    vec2 gridUV28", "\n    vec2 grid = vec2(gridRes, gridRes);\n    vec2 cell = floor(uv * grid);\n    vec2 cellOffset = vec2(offset.x * cell.x, offset.y * cell.y);\n    vec2 cellUV = fract(uv * grid);\n    float dist = length(cellUV - vec2(0.5));\n    float wave = sin(dist * len + time);\n    return wave * cellOffset.x * cellOffset.y;\n}\n\n// generates pixelated directional waves\nfloat", "\n    float cellSize = 1.0 / gridRes;\n    vec2 cell = floor(uv * gridRes);\n    vec2 cellUV = fract(uv * gridRes);\n    float cellTime = time * 0.1 + cell.x * 0.1 + cell.y * 0.1;\n    float cellFlow = sin(cellTime) * 0.5 + 0.5;\n    float cellFlow2 = sin(cellTime * 2.0) * 0.5 + 0.5;\n    float cellFlow3 = sin(cellTime * 3.0) * 0.5 + 0.5;\n    float cellFlow4 = sin(cellTime * 4.0) * 0.5 + 0.5;\n    float cellFlow5 = sin(cellTime * 5.0) * 0.5 + 0.5;\n    float cellFlow6 = sin(cellTime * 6.0) * 0.5 + 0.5;\n    float cellFlow7 = sin(cellTime * 7.0) * 0.5 + 0.5;\n    float cellFlow8 = sin(cellTime * 8.0) * 0.5 + 0.5;\n    float cellFlow9 = sin(cellTime * 9.0) * 0.5 + 0.5;\n    float cellFlow10 = sin(cellTime * 10.0) * 0.5 + 0.5;\n    float cellFlow11 = sin(cellTime * 11.0) * 0.5 + 0.5;\n    float cellFlow12 = sin(cellTime * 12.0) * 0.5 + 0.5;\n    float cellFlow13 = sin(cellTime * 13.0) * 0.5 + 0.5;\n    float cellFlow14 = sin(cellTime * 14.0) * 0.5 + 0.5;\n    float cellFlow15 = sin(cellTime * 15.0) * 0.5 + 0.5;\n    float cellFlow16 = sin(cellTime * 16.0) * 0.5 + 0.", "\n    // grid\n    vec2 gv = fract(p) - 0.5;\n    vec2 id = floor(p);\n    \n    // derivatives\n    vec2  dpdx = ddx - floor(ddx);\n    vec2  dpdy = ddy - floor(ddy);\n    \n    // grid cell offsets\n    vec2  offa = vec2(-1.0,-1.0);\n    vec2  offb = vec2( 1.0,-1.0);\n    vec2  offc = vec2(-1.0, 1.0);\n    vec2  offd = vec2( 1.0, 1.0);\n    \n    // derivatives\n    vec2  dva = mix( dpdx, -dpdy, step(gv.y,0.0) );\n    vec2  dvb = mix( dpdx,  dpdy, step(gv.y,0.0) );\n    vec2  dvc = mix(-dpdx,  dpdy, step(gv.y,0.0) );\n    vec2  dvd = mix(-dpdx, -dpdy, step(gv.y,0.0) );\n    \n    // grid cell texture coordinates\n    vec2  uv = (gv.xy + offa)*vec2(0.125);\n    \n    // texture gradients\n    vec2  ga = textureGrad( iChannel0, uv, dva, dva );\n    vec2  gb = textureGrad( iChannel0, uv, dvb, dvb );\n    vec2  gc = textureGrad( iChannel0, uv, dvc, dvc );\n    vec2  gd = textureGrad( iChannel0, uv, dvd, dvd );\n    \n    // interpolate\n    vec2  ab = mix( ga, gb, step(gv.x,0.0) );\n    vec2  cd = mix( gc, gd, step(gv.x,0.0) );\n    vec2  abcd = mix( ab, cd, step(gv.y,0.0) );\n    \n    // return\n    return", "\n    vec2 q = abs(p);\n    return max(q.x + q.y * 0.5, q.x * 0.866025 + q.y * 0.5) - r;\n}", "\n    p *= 2.;\n    vec2 ip = floor(p);\n    p = fract(p);\n    p = p * p * (3. - 2. * p);\n    return mix(ip, ip + 1., p);\n}\n\nvec", "\n    return 0.5 + 0.5 * sin( x * 3.1415 );\n}\n\nfloat", "\n    return mix(\n        pow(t, vec3(2.4)) * 1.055 - 0.055,\n        t * 12.92,\n        lessThan(t, vec3(0.0031308))\n    );\n}\n\nvec", "\n    return length(p) - 1.0;\n}\n\nfloat", "\n    vec2 q = vec2(p.x, p.y);\n    q = mod(q, 2.0) - 1.0;\n    float d = length(q);\n    return d - 1.0;\n}\n\nfloat", "\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p-p0, v1 = p-p1, v2 = p-p2;\n    vec2 pq0 = v0-e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1-e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2-e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                        vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) ) ),\n                    vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ) );\n    return -sqrt( d.x )*sign( d.y );\n}", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float s1 = b - h;\n    float s2 = b + h;\n    if (s1 > 0.0) {\n        if (s2 > 0.0) return min(s1, s2);\n        return s1;\n    }\n    if (s2 > 0.0) return s2;\n    return -1.0;\n}\n\nfloat", "\n    return max(abs(p.x) - w + r, -p.y);\n}\n\nfloat", "\n    p.x = abs(p.x);\n    float a = p.x + k*p.y;\n    float b = (k-1.0)*p.y + sqrt( (k-1.0)*(k-1.0)*p.y*p.y + 4.0*k*p.x );\n    return k-2.0*min( min(a,b), max(a,b) );\n}", "\n    float d = length(p);\n    return d - 1.0/d;\n}\n\n// distance to y=1/x\nfloat", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "\n    return a < 0.0? -a : a;\n}\n\nfloat", "\n    p = p * mat2(0.5, -0.5, 0.5, 0.5);\n    p = p - vec2(0.0, 0.5);\n    float x = p.x;\n    float y = p.y;\n    float c = (sqrt(abs(x)) - 1.0) / 2.0;\n    float d = length(p - vec2(x, c));\n    return d;\n}\n\nfloat", "\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    float ks = ky*ky - kx*kx;\n    float ku = kz * kz;\n    float kv = kx * kx;\n    float kvt = kv * kv * kv;\n\n    vec2 p = vec2( ky, kx );\n    vec2 q = vec2( ks*kx - 9.0*kvt*kz, -9.0*ku*ky + ks*kx );\n    vec2 r = vec2( q.x / 2.0, -kvt*ku / 2.0 );\n\n    float m = ku*ku*ku;\n    float n = ku*ku*kvt;\n\n    float D = kv*q.x - ks*q.y;\n    float u = (sqrt(D*D + 4.0*m*r.y) - D) / (2.0*m);\n    float v = (u * u + kv) / ku;\n\n    vec2 w = r / vec2(v, u);\n    vec2 t = w.y < w.x? w.xy : w.yx;\n    t = t.x < t.y? t.xy : t.yx;\n    float s = sign(t.y - t.x);\n\n    vec2 w1 = p + t*q;\n    float d1 = s*(pos.x*w1.y-pos.y*w1.x);\n\n    vec2 e = r + t*vec2(ku, ku*kv);\n    float f = s*(pos.x*e.y-", "\n    vec3 res = vec3( 0.0 );\n    \n    float a = 1.0 / ( wi * wi );\n    float b = 1.0 / ( he * he );\n    \n    float x = pos.x;\n    float y = pos.y;\n    \n    float d = x * x * a + y * y * b - 1.0;\n    \n    res.x = d;\n    res.y = -2.0 * x * a;\n    res.z = -2.0 * y * b;\n    \n    return res;\n}", "\n    float d = pos.y*pos.y - 4.0*k*pos.x;\n    vec3 res = vec3( 0.0 );\n    if( d >= 0.0 )\n    {\n        d = sqrt(d);\n        res.x = -pos.y - d;\n        res.x = max( res.x, -pos.y + d );\n        res.y = 2.0*k;\n        res.z = -2.0*pos.x;\n        res.xyz *= 0.5/res.y;\n    }\n    return res;\n}", "\n    vec2 q = vec2(length(p), atan(p.y, p.x));\n    float a = 0.5 * (ra + rb);\n    float b = 0.5 * (ra - rb);\n    float c = 0.5 * (ra + rb);\n    float d2 = d * d;\n    float a2 = a * a;\n    float b2 = b * b;\n    float c2 = c * c;\n    float q2 = q.x * q.x;\n    float q3 = q2 * q.x;\n    float q4 = q2 * q2;\n    float q5 = q4 * q.x;\n    float q6 = q5 * q.x;\n    float q7 = q6 * q.x;\n    float q8 = q7 * q.x;\n    float q9 = q8 * q.x;\n    float q10 = q9 * q.x;\n    float q11 = q10 * q.x;\n    float q12 = q11 * q.x;\n    float q13 = q12 * q.x;\n    float q14 = q13 * q.x;\n    float q15 = q14 * q.x;\n    float q16 = q15 * q.x;\n    float q17 = q16 * q.x;\n    float q18 = q17 * q.x;\n    float q19 = q18 * q.x;\n    float q20 = q19 * q.x;\n    float q21 = q20 * q.x;\n    float q22 = q21 * q.x;\n    float q23 = q22 * q.x;\n    float q24 = q23 * q.x;\n    float q25 = q24 * q.x;\n    float q26 = q25 * q.x;\n    float q27 = q26 * q.x;\n    float q28 = q27 * q.x;\n    float q29 = q28 * q.x;\n    float q30 = q29 * q.x;\n    float q31 = q30 * q.x;\n    float q32 = q31 * q.x;", "\n    v = v * ivec2(0xff51afd7, 0xc4ceb9fe) + ivec2(0xaaaa, 0x5555);\n    v = v ^ (v >> 16);\n    v = v * ivec2(0xff51afd7, 0xc4ceb9fe) + ivec2(0xaaaa, 0x5555);\n    return v;\n}\n\nfloat", "\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\nfloat", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0.0, 1.0);\n\n        // 1 root\n        res = distance(pos, A + t * (B - A));\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n\n        // 3 roots\n        res = min(distance(pos, A + t.x * (B - A)), distance(pos, A + t.y * (B - A)));\n        res = min(res", "\n    return sign(cross(p - a, b - a));\n}\n\nfloat", "\n    vec3  r = ro - s;\n    float a = dot(rd,rd);\n    float b = 2.0 * dot(rd,r);\n    float c = dot(r,r) - (s.x*s.x + s.y*s.y + s.z*s.z);\n    float d = b*b - 4.0*a*c;\n    if( d < 0.0 ) return vec4(0.0);\n    d = sqrt(d);\n    float t = (-b - d) / (2.0*a);\n    if( t < 0.0 ) return vec4(0.0);\n    vec3  p = ro + t*rd - s;\n    vec3  n = normalize(p);\n    return vec4(t,n.x,n.y,n.z);\n}", "\n    float f = a * b + x;\n    ret_n = int(f);\n    return f - float(ret_n);\n}\n\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat", "\n    vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n    float a = ab.x;\n    float b = ab.y;\n    float c = sqrt(a*a - b*b);\n    float d = sqrt(p.x*p.x + p.y*p.y);\n    float e = atan(p.y/p.x);\n    float f = 1.0 / (a*a);\n    float g = 1.0 / (b*b);\n    float h = 1.0 / (c*c);\n    float i = 1.0 / (d*d);\n    float j = e*e;\n    float k = f + g + h - i - j;\n    return k;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat", "\n    return a + b;\n}\n\nvec", "\n    vec2 q = p;\n    q.x = q.x - ab.x;\n    q.y = q.y - ab.y;\n    float a = ab.x;\n    float b = ab.y;\n    float c = sqrt( a*a - b*b );\n    float d = q.x*q.x + q.y*q.y - c*c;\n    float e = sqrt( d );\n    float f = atan( q.y, q.x );\n    float g = f + s1;\n    float h = f + s2;\n    float i = g - h;\n    float j = e*cos( g );\n    float k = e*cos( h );\n    float l = e*sin( g );\n    float m = e*sin( h );\n    float n = 2.0*i;\n    float o = 2.0*j;\n    float p = 2.0*k;\n    float q = 2.0*l;\n    float r = 2.0*m;\n    float s = 2.0*n;\n    float t = 2.0*o;\n    float u = 2.0*p;\n    float v = 2.0*q;\n    float w = 2.0*r;\n    float x = 2.0*s;\n    float y = 2.0*t;\n    float z = 2.0*u;\n    float A = 2.0*v;\n    float B = 2.0*w;\n    float C = 2.0*x;\n    float D = 2.0*y;\n    float E = 2.0*z;\n    float F = 2.0*A;\n    float G = 2.0*B;\n    float H = 2.0*C;\n    float I = 2.0*D;\n    float J = 2.0*E;\n    float K = 2.0*F;\n    float L = 2.0*G;\n    float M = 2.0*H;\n    float N = ", "\n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float t = clamp(dot(p - a, b - a) / l2, 0.0, 1.0);\n    vec3 c = a + t * ba;\n    vec3 pa = p - a, ba2 = b - a;\n    vec3 v = pa - t * ba2;\n    float r = (t == 0.0 || t == 1.0)? length(v) : length(cross(ba2, v)) / length(ba2);\n    float h2 = l2 - r * r * l2;\n    float d = (h2 <= 0.0)? 0.0 : sqrt(h2);\n    return vec4(sqrt(r * r + h2) - max(r, d), c + (1.0 - t) * ba, 0.0);\n}", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}", "\n    return length(p-cen)-rad;\n}\n\nfloat", "\n    if( showSurface )\n    {\n        return normalize( samplePoint - pos );\n    }\n    else\n    {\n        vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n        return normalize( e.xyy*sdf( pos + e.xyy ) +\n                          e.yyx*sdf( pos + e.yyx ) +\n                          e.yxy*sdf( pos + e.yxy ) +\n                          e.xxx*sdf( pos + e.xxx ) );\n    }\n}", "\n    float res = 1.0;\n    float t = 0.02;\n    float h = 1.0;\n    float s = 1.0;\n    float k = 1.0;\n    float d = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        if( h<0.001 ) break;\n        d = map(ro + rd*t);\n        h = d;\n        res = min( res, k*h/t );\n        t += d;\n        k += 0.05;\n    }\n    if( showSurface )\n    {\n        if( t < 0.02 )\n        {\n            samplePoint = ro + rd*t;\n        }\n    }\n    return res;\n}", "\n    vec2 q = vec2( length(p.x), abs(p.y) );\n    vec2 w = vec2( ra, he );\n    vec2 a = (w-q.x)/vec2(2.0,1.0);\n    vec2 b = (w+q.x)/vec2(2.0,1.0);\n    vec2 k = vec2( 1.0, -1.0 );\n    vec2 uv = k*q.xy/vec2(rb,he);\n    vec2 v = vec2( dot(a,uv), dot(b,uv) );\n    vec2 d = k*vec2(1.0,1.0)/vec2(rb,he);\n    vec2 e = k*vec2(1.0,-1.0)/vec2(ra,he);\n    vec2 g = vec2( 1.0, -1.0 );\n    vec2 t = vec2( 1.0, -1.0 );\n    vec2 s = vec2( 1.0, -1.0 );\n    vec2 n = vec2( 1.0, -1.0 );\n    vec2 m = vec2( 1.0, -1.0 );\n    vec2 o = vec2( 1.0, -1.0 );\n    vec2 r = vec2( 1.0, -1.0 );\n    vec2 h = vec2( 1.0, -1.0 );\n    vec2 l = vec2( 1.0, -1.0 );\n    vec2 j = vec2( 1.0, -1.0 );\n    vec2 i = vec2( 1.0, -1.0 );\n    vec2 c = vec2( 1.0, -1.0 );\n    vec2 f = vec2( 1.0, -1.0 );\n    vec2 dg = vec2( 1.0, -1.0 );\n    vec2 dh = vec2( 1.0, -1.0 );\n    vec2 dj = vec2( 1.0, -1.0 );\n    vec2 dk = vec2", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,1.0);\n}", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat", " return dot(v, v); }\nfloat", "\n    vec2 d = max( minCorner - p, vec2(0.0) ) + max( p - maxCorner, vec2(0.0) );\n    return dot( d, d );\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat", "\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n    float t = 0.0;\n    float f = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0", "\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec", "\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// Quaternion-quaternion multiplication\nvec", "\n    return length(p-c)-r;\n}\n\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat", "\n    if( d < m.x )\n    {\n        m.x = d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec", "\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec4(0.0);\n        p2 = vec4(0.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        p1 = vec4(ro + rd*(-b-h), 1.0);\n        p2 = vec4(ro + rd*(-b+h), 1.0);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec2 p1, out vec2 p2 )\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec2(0.0);\n        p2 = vec2(0.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        p1 = ro + rd*(-b-h);\n        p2 = ro + rd*(-b+h);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec2 p )\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p = vec2(0.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        p = ro + rd*(-b-h);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out float t1, out", "\n    vec2 d = p - c;\n    return vec3( dot(d,d) - r*r, d.x, d.y );\n}\n\nvec", "\n    vec2 d = abs(p)-b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0),\n                d.x,d.y);\n}\n\nvec", "\n    vec3 res;\n    res.x = p.x*p.x*p.x - p.y*p.y*p.y - 0.6;\n    res.y = 3.0*p.x*p.x - p.y*p.y;\n    res.z = -2.0*p.x*p.x;\n    res.yz *= 0.5;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\nfloat", "\n    return pow(abs(x), n) * (a * sign(x) + b);\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                float noise = 0.0;\n                float scale = 1.0;\n                for(int i = 0; i < 4; i++){\n                    noise += texture(iChannel0, uv * scale).r / scale;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n\n            void mainImage(out vec4 fragColor, in vec2 fragCoord){\n                vec2 uv = fragCoord / iResolution.xy;\n                vec3 color = vec3(0.0);\n                float noise = paperNoise(uv);\n                color = vec3(noise);\n                fragColor = vec4(color, 1.0);\n            }", "\n    vec3 color = vec3( 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        color += vec3( 1.0, 0.0, 0.0 );\n        color += vec3( 0.0, 1.0, 0.0 );\n        color += vec3( 0.0, 0.0, 1.0 );\n    }\n    return color;\n}", "\n    return length(p-c)-r;\n}\n\nfloat", "\n    vec2 d = abs(p)-c;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h), h );\n}", "\n    vec2 pa = p-a, ba = b-a;\n    float h2 = h*h;\n    float ba2 = dot(ba,ba);\n    float t = clamp( -dot(pa,ba)/ba2, 0.0, 1.0 );\n    vec2  q = pa - t*ba;\n    float d2 = dot(q,q);\n    float s = (d2-d2min)/h2;\n    return vec2( sqrt(d2), s );\n}", "\n    // kType[0] = 0, 1, 2, 3, 4, 5, 6\n    // kType[1] = 0, 1, 2, 3, 4, 5, 6\n    // kType[2] = 0, 1, 2, 3, 4, 5, 6\n    // kType[3] = 0, 1, 2, 3, 4, 5, 6\n    // kType[4] = 0, 1, 2, 3, 4, 5, 6\n    // kType[5] = 0, 1, 2, 3, 4, 5, 6\n    // kType[6] = 0, 1, 2, 3, 4, 5, 6\n    // kPath[0] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n    // kPath[1] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n    // kPath[2] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n    // kPath[3] = 0.0, 0.0, 0.0, 0.0, ", "\n    vec2 q = vec2( length(p.xy), p.y );\n    return -sdBox( q, vec2(1.0) );\n}\n\nfloat", "\n    vec2 q = abs(p)-vec2(1.,.5);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// correct outside, incorrect inside\nfloat", "\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n    float d = min( min( f.x, f.y ), 1.0 - max( f.x, f.y ) );\n    float n = p.x + p.y * 57.0;\n    float m = dot( f - 0.5, f - 0.5 ) * 100.0;\n    return 1.0 - smoothstep( 0.0, 0.02, abs( fract( n + m ) * d - 0.5 ) );\n}\n\n// Generate a color based on the given UV coordinates.\nvec", "\n    vec2 ap = p - a, ab = b - a;\n    float d = dot( ap, ab ) / dot( ab, ab );\n    if( d < 0.0 ) return a;\n    if( d > 1.0 ) return b;\n    return a + ab * d;\n}\n\n// Distance from point to segment\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat", "\n    vec2 q = abs(p)-b+r;\n    return -min(max(q.x,q.y),0.0) + clamp(q,0.0,1.0);\n}\n\n// closest point on rounded box\nvec", "\n    vec2 q = abs(p)-b+r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to circle\nfloat", "\n    float h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3D Noise from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(mix(dot(u, vec2(0.0, 0.0) - f + i), \n                   dot(u, vec2(0.0, 1.0) - f + i), f.y),\n               mix(dot(u, vec2(1.0, 0.0) - f + i), \n                   dot(u, vec2(1.0, 1.0) - f + i), f.y), f.x);\n}\n\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 4; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}", "\n    float f = 0.0;\n    f += 0.5000*noise( x );\n    f += 0.2500*noise( 2.0*x );\n    f += 0.1250*noise( 4.0*x );\n    f += 0.0625*noise( 8.0*x );\n    return f;\n}", "\n    return 4.0 * atan(1.0) / (x * y);\n}\n\nfloat", "\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nfloat", "\n    const float K1 = 0.3660254037844386; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865405187; // (3-sqrt(3))/6;\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 a = p - i + (i.x + i.y + i.z) * K2;\n    vec3 m = step(a.yzx, a.xyz);\n    vec3 o = m.zxy * m.yzx;\n    vec3 b = a - o + m.zxy;\n    vec3 c = a - 1. + 2. * m.zxy;\n    vec3 d = mix(c, b, a.x);\n    vec3 e = mix(d.xyz, d.yzx, m.x);\n    vec3 g = mix(e.xyz, e.yzx, m.y);\n    return g.x + g.y + g.z;\n}\n\nfloat", "\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y) ) );\n}\n\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat", "\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form\nfloat", "\n    // The projection of a disk is an ellipse.\n    // The center of the ellipse is the projection of the center of the disk.\n    // The major and minor axes are the projections of the radii of the disk.\n    // The major axis is the projection of the normal of the disk.\n    // The minor axis is the projection of the normal of the disk rotated by 90 degrees.\n    // The major and minor axes are perpendicular to each other.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes", "\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4337);\n}\n\nfloat", "\n    float a = acs.x, c = acs.y;\n    float b = bn * a;\n    float n = m * PI / bn;\n    float d = 0.0;\n    float s = 1.0;\n    float t = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n", "\n    const float eps = 0.0001;\n    const vec2  d   = vec2(1.0,-1.0);\n\n    return normalize( d.xyy*sdf( p + d.xyy*eps ) + \n                      d.yyx*sdf( p + d.yyx*eps ) + \n                      d.yxy*sdf( p + d.yxy*eps ) + \n                      d.xxx*sdf( p + d.xxx*eps ) );\n}", "\n    float res = 1.0;\n    float t = t0;\n    for(int i = 0; i < 32; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 64.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(res < EPSILON || t > t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = sdf( aopos )-hr;\n        occ += -(dd*dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float t = 1.0 - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    return mat3(\n        t * x * x + c, t * x * y - s * z, t * x * z + s * y,\n        t * x * y + s * z, t * y * y + c, t * y * z - s * x,\n        t * x * z - s * y, t * y * z + s * x, t * z * z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat", "\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n    return rd;\n}\n\n// Helper function that generates a random number based on UV and mouse\nfloat", "\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453 + sin(time));\n}\n\n// Standard 3d noise\nfloat", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453);\n}\n\n// 3d simplex noise\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 2D value noise\nfloat", "\n    vec3 s = vec3(p.x + p.y + p.z + 100.0);\n    vec3 i = floor(s);\n    vec3 f = s - i;\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (i.xy + i.z * vec2(17.0, 31.0)) + f.xy;\n    vec2 rg = texture2D(noise, uv * 0.001).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 3D simplex noise, cool trick\nfloat", "\n    float f = 0.0;\n    float a = 0.5;\n    float w = 0.5;\n    for(int i = 0; i < 4; i++){\n        f += a * noise(p);\n        p *= 2.0;\n        a *= 0.5;\n        w *= 0.5;\n    }\n    return f;\n}\n\n// FBM with some tweaks\nfloat", "\n    // get the clouds density at this point\n    float density = 0.0;\n    float color = 0.0;\n    float d = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44 = 0.0", "\n    vec3 color = vec3(0.0);\n    float coverage = 0.0;\n    float step = 0.01;\n    float direction = 0.0;\n    float random2 = random * 0.5 + 0.5;\n    for(float i = 0.0; i < 1.0; i += step){\n        float height = 0.0;\n        float height2 = 0.0;\n        float height3 = 0.0;\n        float height4 = 0.0;\n        float height5 = 0.0;\n        float height6 = 0.0;\n        float height7 = 0.0;\n        float height8 = 0.0;\n        float height9 = 0.0;\n        float height10 = 0.0;\n        float height11 = 0.0;\n        float height12 = 0.0;\n        float height13 = 0.0;\n        float height14 = 0.0;\n        float height15 = 0.0;\n        float height16 = 0.0;\n        float height17 = 0.0;\n        float height18 = 0.0;\n        float height19 = 0.0;\n        float height20 = 0.0;\n        float height21 = 0.0;\n        float height22 = 0.0;\n        float height23 = 0.0;\n        float height24 = 0.0;\n        float height25 = 0.0;\n        float height26 = 0.0;\n        float height27 = 0.0;\n        float height28 = 0.0;\n        float height29 = 0.0;\n        float height30 = 0.0;\n        float height31 = 0.0;\n        float height32 = 0.0;\n        float height33 = 0.0;\n        float height34 = 0.0;\n        float height35 = 0.0;\n        float height36 = 0.0;\n        float height37 = 0.0;\n        float height38 = 0.0;\n        float height39 = 0.0", "\n    vec3 ray = pointEnd - pointStart;\n    float rayLength = length(ray);\n    vec3 rayDir = ray / rayLength;\n    vec3 rayPos = pointStart;\n    vec3 rayStep = rayDir * 0.01;\n    float rayDepth = 0.0;\n    float rayDepthMax = 100.0;\n    float rayDepthStep = 0.01;\n    float rayDepthMaxStep = 0.01;\n    float rayDepthMaxStepMax = 0.01;\n    float rayDepthMaxStepStep = 0.01;\n    float rayDepthMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStep = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMax = 0.01;\n    float rayDepthMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStepMaxStep = 0.01;\n    float rayDepth", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}"]}