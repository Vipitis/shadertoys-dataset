{"input_docstring": [[{"generated_text": "\n\treturn cos( a );\n}\n\nfloat"}], [{"generated_text": "\n    vec3 rotated = Rotate(p, rotDir);\n\n    // Scale to the size of the object\n    vec3 scaled = rotated * scale;\n\n    // Translate to the center of the object\n    vec3 translated = scaled + center;\n\n    // Get the distance to the object\n    float dist = length(translated);\n\n    return dist;\n}\n\nvoid main()\n{\n    // Get the position of the pixel\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    // Get the position of the pixel in world space\n    vec3 p = vec3(uv * 2.0 - 1.0, 1.0);\n\n    // Get the distance to the object\n    float dist = DistanceToObject(p);\n\n    // Get the color of the object\n    vec3 color = GetColor(dist);\n\n    // Set the color of the pixel\n    gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n\tfloat glow = max(0.0, glowCounter - 0.001);\n\n\t// Calculate the distance to the voxel\n\tfloat d = length(p - voxelPos);\n\n\t// Calculate the distance to the voxel's center\n\tfloat dc = length(p - voxelCenter);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de = length(p - voxelEdge);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc2 = length(p - voxelCorner);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de2 = length(p - voxelEdge2);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc3 = length(p - voxelCorner2);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de3 = length(p - voxelEdge3);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc4 = length(p - voxelCorner3);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de4 = length(p - voxelEdge4);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc5 = length(p - voxelCorner4);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de5 = length(p - voxelEdge5);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc6 = length(p - voxelCorner5);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de6 = length(p - voxelEdge6);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc7 = length(p - voxelCorner6);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de7 = length(p - voxelEdge7);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc8 = length"}], [{"generated_text": "\n\tvec3 glow = vec3(0.0);\n\tfloat glowIntensity = 0.0;\n\n\t// Update the distance to the scene\n\tfloat dist = 1000000.0;\n\n\t// Update the position of the point\n\tP = p;\n\n\t// Update the distance to the scene\n\tdist = length(p);\n\n\t// Update the glow intensity\n\tglowIntensity = (1.0 - dist) * 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": " position in the screen\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\t// Get the fragment position in the world\n\tvec3 pos = vec3(p * 2.0 - 1.0, 1.0);\n\n\t// Get the ray direction\n\tvec3 rayDir = normalize(vec3(p * 2.0 - 1.0, 1.0));\n\n\t// Get the ray origin\n\tvec3 rayOrigin = vec3(0.0);\n\n\t// Get the ray color\n\tvec3 rayColor = vec3(0.0);\n\n\t// Get the ray depth\n\tfloat rayDepth = 0.0;\n\n\t// Get the ray distance\n\tfloat rayDistance = 0.0;\n\n\t// Get the ray normal\n\tvec3 rayNormal = vec3(0.0);\n\n\t// Get the ray material\n\tfloat rayMaterial = 0.0;\n\n\t// Get the ray material color\n\tvec3 rayMaterialColor = vec3(0.0);\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal2 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth2 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance2 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal3 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth3 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance3 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal4 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth4 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance4 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal5 = ve"}], [{"generated_text": "\n\tstatic const float c[4] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\treturn vec4(c[0], c[1], c[2], c[3]);\n}\n\n//src/main.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cstdint>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstd"}], [{"generated_text": "\n\tvec4 color = texture(color_map, vec2(d, 0.5));\n\t\n\t// apply gamma correction\n\tcolor.rgb = pow(color.rgb, vec3(1.0/2.2));\n\t\n\treturn color;\n}\n\nvoid main()\n{\n\tfloat d = texture(depth_map, v_texcoord).r;\n\t\n\tvec4 color = shade(d);\n\t\n\tgl_FragColor = color;\n}\n"}], [{"generated_text": " and forth\n    float fade = clamp(0.5 - dot(rayDir, sunDir), 0.0, 1.0);\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec"}], [{"generated_text": "\n    float t = ( coords.x - 2.0 ) / 2.0;\n    float a = sin( t * 3.1415926535897932384626433832795 );\n    return a;\n}\n\nvoid main()\n{\n    vec2 coords = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    float d = distance( coords, vec2( 0.0 ) );\n    float a = atan( coords.y, coords.x );\n    float r = ( 1.0 - d ) * 0.5;\n    float h = ( 1.0 - d ) * 0.5;\n    float s = ( 1.0 - d ) * 0.5;\n    vec3 color = vec3( 0.0 );\n    color += vec3( 1.0, 0.0, 0.0 );\n    color += vec3( 0.0, 1.0, 0.0 );\n    color += vec3( 0.0, 0.0, 1.0 );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), h );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), s );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), r );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), a );\n    gl_FragColor = vec4( color, 1.0 );\n}\n"}], [{"generated_text": "\n    float t = (coords.x - 2.0) / 4.0;\n    float a = sin(t) * 4.0 + 2.0;\n    float b = cos(t) * 4.0 + 2.0;\n    return sin(a) * sin(b);\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    float d = F(coords);\n    float a = atan(coords.y, coords.x);\n    float r = length(coords);\n    float t = (a + PI) / (2.0 * PI);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n    float z = d;\n    vec3 n = vec3(x, y, z);\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 v = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 h = normalize(v + l);\n    vec3 color = vec3(0.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, l)), 10.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, h)), 10.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, v)), 10.0);\n    color = pow(color, vec3(1.0 / 2.2));\n    gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n    float t = ( coords.x - 1.0 ) / 3.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n"}], [{"generated_text": "\n    float speed = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    float n = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        n += a;\n        a *= 0.5;\n        p = rot * p * 2.0 + shift;\n        p = mod(p, 289.0) - 155.0;\n    }\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat"}], [{"generated_text": "\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // p = p*p*(3.0-2.0*p.w);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // p = p*p*(3.0-2.0*p.w);\n    // p = p*p*(3.0-2.0*p."}], [{"generated_text": "\n    // This is a simplex grid implementation that is based on the\n    // work of John H. Curtis and John A. Henstridge.\n    //\n    // The grid is a 2D array of 3D vectors.  The grid is a 2D array\n    // of 3D vectors.  The grid is a 2D array of 3D vectors.  The\n    // grid is a 2D array of 3D vectors.  The grid is a 2D array of\n    // 3D vectors.  The grid is a 2D array of 3D vectors.  The grid\n    // is a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors"}], [{"generated_text": "\n    vec2 cell = floor(p);\n    vec2 cell_size = vec2(1.0);\n    vec2 cell_offset = vec2(0.5);\n\n    // Compute the distance from the cell center to the point.\n    vec2 dist = abs(p - cell + (0.5 - cell_offset)) - cell_size * 0.5;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    vec2 closest_edge = min(dist, vec2(0.0));\n\n    // Compute the distance from the point to the closest corner of the cell.\n    vec2 closest_corner = min(closest_edge, min(dist.yx, dist.xy));\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist = min(closest_edge.x, closest_edge.y);\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist = min(closest_corner.x, closest_corner.y);\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_sq = closest_edge_dist * closest_edge_dist;\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist_sq = closest_corner_dist * closest_corner_dist;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_sq_sq = closest_edge_dist_sq * closest_edge_dist_sq;\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist_sq_sq = closest_corner_dist_sq * closest_corner_dist_sq;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_cube = closest_edge_dist_sq_sq * closest_edge_dist;\n\n    // Compute the distance from the"}], [{"generated_text": "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0."}], [{"generated_text": "\n    vec2 res;\n\n    // map the point to the unit cube\n    res.x = (p.x + 1.0) * 0.5;\n    res.y = (p.y + 1.0) * 0.5;\n\n    // map the point to the unit sphere\n    res.x = res.x * 2.0 - 1.0;\n    res.y = res.y * 2.0 - 1.0;\n\n    // map the point to the unit disk\n    if (res.x * res.x + res.y * res.y > 1.0)\n        discard;\n\n    // map the point to the unit disk\n    res.x = res.x * sqrt(1.0 - res.y * res.y);\n    res.y = res.y * sqrt(1.0 - res.x * res.x);\n\n    // map the point to the unit disk\n    res.x *= resolution;\n    res.y *= resolution;\n\n    return res;\n}\n\n// compute the ray direction\nvec"}], [{"generated_text": "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin2 = 0.0;\n\tfloat tmax2 = 10000.0;\n\tfloat tmin3 = 0.0;\n\tfloat tmax3 = 10000.0;\n\tfloat tmin4 = 0.0;\n\tfloat tmax4 = 10000.0;\n\tfloat tmin5 = 0.0;\n\tfloat tmax5 = 10000.0;\n\tfloat tmin6 = 0.0;\n\tfloat tmax6 = 10000.0;\n\tfloat tmin7 = 0.0;\n\tfloat tmax7 = 10000.0;\n\tfloat tmin8 = 0.0;\n\tfloat tmax8 = 10000.0;\n\tfloat tmin9 = 0.0;\n\tfloat tmax9 = 10000.0;\n\tfloat tmin10 = 0.0;\n\tfloat tmax10 = 10000.0;\n\tfloat tmin11 = 0.0;\n\tfloat tmax11 = 10000.0;\n\tfloat tmin12 = 0.0;\n\tfloat tmax12 = 10000.0;\n\tfloat tmin13 = 0.0;\n\tfloat tmax13 = 10000.0;\n\tfloat tmin14 = 0.0;\n\tfloat tmax14 = 10000.0;\n\tfloat tmin15 = 0.0;\n\tfloat tmax15 = 10000.0;\n\tfloat tmin16 = 0.0;\n\tfloat tmax16 = 10000.0;\n\tfloat tmin17 = 0.0;\n\tfloat tmax17 = 10000.0;\n\tfloat tmin18 = 0.0;\n\tfloat tmax18 = 10000.0;\n\tfloat tmin19 = 0.0;\n\tfloat tmax19"}], [{"generated_text": "\n    vec4 res;\n\n    // map the point to the unit cube\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit sphere\n    p.y = abs(p.y);\n\n    // map the point to the unit disk\n    if (p.x * p.x + p.y * p.y > 1.0)\n        return res;\n\n    // map the point to the unit square\n    p.x = abs(p.x);\n\n    // map the point to the unit rectangle\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y > 1.0)\n        return res;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p"}], [{"generated_text": "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 dp;\n    vec3 dp2;\n    vec3 dp3;\n    vec3 dp4;\n    vec3 dp5;\n    vec3 dp6;\n    vec3 dp7;\n    vec3 dp8;\n    vec3 dp9;\n    vec3 dp10;\n    vec3 dp11;\n    vec3 dp12;\n    vec3 dp13;\n    vec3 dp14;\n    vec3 dp15;\n    vec3 dp16;\n    vec3 dp17;\n    vec3 dp18;\n    vec3 dp19;\n    vec3 dp20;\n    vec3 dp21;\n    vec3 dp22;\n    vec3 dp23;\n    vec3 dp24;\n    vec3 dp25;\n    vec3 dp26;\n    vec3 dp27;\n    vec3 dp28;\n    vec3 dp29;\n    vec3 dp30;\n    vec3 dp31;\n    vec3 dp32;\n    vec3 dp33;\n    vec3 dp34;\n    vec3 dp35;\n    vec3 dp36;\n    vec3 dp37;\n    vec3 dp38;\n    vec3 dp39;\n    vec3 dp40;\n    vec3 dp41;\n    vec3 dp42;\n    vec3 dp43;\n    vec3 dp44;\n    vec3 dp45;\n    vec3 dp46;\n    vec3 dp47;\n    vec3 dp48;\n    vec3 dp49;\n    vec3 dp50;\n    ve"}], [{"generated_text": "\n    vec3 wp = (modelMatrix * vec4(p, 1.0)).xyz;\n    vec3 wo = (modelMatrix * vec4(oN, 0.0)).xyz;\n    vec3 wd = wp - wo;\n\n    // world pos diff\n    vec3 wp2 = (modelMatrix * vec4(p + wd, 1.0)).xyz;\n    vec3 wo2 = (modelMatrix * vec4(oN + wd, 0.0)).xyz;\n    vec3 wd2 = wp2 - wo2;\n\n    // world pos diff\n    vec3 wp3 = (modelMatrix * vec4(p + wd2, 1.0)).xyz;\n    vec3 wo3 = (modelMatrix * vec4(oN + wd2, 0.0)).xyz;\n    vec3 wd3 = wp3 - wo3;\n\n    // world pos diff\n    vec3 wp4 = (modelMatrix * vec4(p + wd3, 1.0)).xyz;\n    vec3 wo4 = (modelMatrix * vec4(oN + wd3, 0.0)).xyz;\n    vec3 wd4 = wp4 - wo4;\n\n    // world pos diff\n    vec3 wp5 = (modelMatrix * vec4(p + wd4, 1.0)).xyz;\n    vec3 wo5 = (modelMatrix * vec4(oN + wd4, 0.0)).xyz;\n    vec3 wd5 = wp5 - wo5;\n\n    // world pos diff\n    vec3 wp6 = (modelMatrix * vec4(p + wd5, 1.0)).xyz;\n    vec3 wo6 = (modelMatrix * vec4(oN + wd5, 0.0)).xyz;\n    vec3 wd6 = wp6 - wo6;\n\n    // world pos diff\n    vec3"}], [{"generated_text": "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 p = vec3(uv, 0.0);\n    vec3 col = vec3(0.0);\n    \n    // The camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, -1.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // The ray\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // The raymarching\n    float t = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = noise3D(pos);\n        t += d;\n        if (t > tmax) break;\n    }\n    \n    // The color\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 1.0) * (t / tmax);\n    col += vec3(1.0, 0"}], [{"generated_text": "\n\t//pR(rayDir.xz, sin(-t * 2.));\n\t//pR(rayDir.xy, sin(-t * 3.));\n\t//pR(rayDir.xz, sin(-t * 4.));\n\t//pR(rayDir.yz, sin(-t * 5.));\n\t//pR(rayDir.xy, sin(-t * 6.));\n\t//pR(rayDir.xz, sin(-t * 7.));\n\t//pR(rayDir.yz, sin(-t * 8.));\n\t//pR(rayDir.xy, sin(-t * 9.));\n\t//pR(rayDir.xz, sin(-t * 10.));\n\t//pR(rayDir.yz, sin(-t * 11.));\n\t//pR(rayDir.xy, sin(-t * 12.));\n\t//pR(rayDir.xz, sin(-t * 13.));\n\t//pR(rayDir.yz, sin(-t * 14.));\n\t//pR(rayDir.xy, sin(-t * 15.));\n\t//pR(rayDir.xz, sin(-t * 16.));\n\t//pR(rayDir.yz, sin(-t * 17.));\n\t//pR(rayDir.xy, sin(-t * 18.));\n\t//pR(rayDir.xz, sin(-t * 19.));\n\t//pR(rayDir.yz, sin(-t * 20.));\n\t//pR(rayDir.xy, sin(-t * 21.));\n\t//pR(rayDir.xz, sin(-t * 22.));\n\t//pR(rayDir.yz, sin(-t * 23.));\n\t//pR(rayDir.xy, sin(-t * 24.));\n\t//pR(rayDir.xz, sin(-t * 25.));\n\t//pR(rayDir.yz, sin(-t * 26.));\n\t//pR(rayDir.xy, sin(-t * 27.));\n\t//pR(rayDir.x"}], [{"generated_text": "\n    vec2 box = vec2(abs(A.x - B.x), abs(A.y - B.y));\n    // calculate the distance from the box center to the line\n    float line_dist = distance(coords, vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)));\n    // calculate the height of the line\n    float line_height = height * line_dist / box.x;\n    // calculate the y axis of the line\n    float line_y = coords.y - line_height;\n    // calculate the x axis of the line\n    float line_x = coords.x;\n    // calculate the distance from the line to the box center\n    float line_dist_to_box = distance(vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)), vec2(line_x, line_y));\n    // calculate the height of the line\n    float line_height_to_box = height * line_dist_to_box / box.x;\n    // calculate the y axis of the line\n    float line_y_to_box = line_y - line_height_to_box;\n    // calculate the x axis of the line\n    float line_x_to_box = line_x;\n    // calculate the distance from the line to the box center\n    float line_dist_to_box_2 = distance(vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)), vec2(line_x_to_box, line_y_to_box));\n    // calculate the height of the line\n    float line_height_to_box_2 = height * line_dist_to_box_2 / box.x;\n    // calculate the y axis of the line\n    float line_y_to_box_2 = line_y_to_box - line_height_to_box_2;\n    // calculate the x axis of the line\n    float line_x_to_box_2 = line_x_to_box;\n    //"}], [{"generated_text": "\n     float dot = dot(start, end);\n     // If the dot is 1, the vectors are the same.\n     if (dot > 0.9999)\n     {\n          return end;\n     }\n     // If the dot is -1, the vectors are opposite.\n     if (dot < -0.9999)\n     {\n          return -end;\n     }\n     // If the dot is 0, the vectors are parallel.\n     if (dot == 0)\n     {\n          return vec2(0, 0);\n     }\n     // Compute the angle between the vectors.\n     float angle = acos(dot);\n     // Compute the sin of the angle.\n     float sin = sin(angle);\n     // Compute the ratio of the sin of the angle.\n     float ratio = sin / sin(angle);\n     // Compute the cross product.\n     vec2 cross = cross(start, end);\n     // Compute the cross product.\n     vec2 result = cross * ratio;\n     // Compute the dot product.\n     float dot2 = dot(start, result);\n     // If the dot is 1, the vectors are the same.\n     if (dot2 > 0.9999)\n     {\n          return result;\n     }\n     // If the dot is -1, the vectors are opposite.\n     if (dot2 < -0.9999)\n     {\n          return -result;\n     }\n     // If the dot is 0, the vectors are parallel.\n     if (dot2 == 0)\n     {\n          return vec2(0, 0);\n     }\n     // Compute the angle between the vectors.\n     float angle2 = acos(dot2);\n     // Compute the sin of the angle.\n     float sin2 = sin(angle2);\n     // Compute the ratio of the sin of the angle.\n     float ratio2 = sin2 / sin(angle2);\n     // Compute the cross product.\n     vec2 cross2 = cross(start, result);\n     // Compute the cross product.\n     vec2 result2 = cross2 * ratio2;\n     // Compute the"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n    // raymarch\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float d = map( pos );\n        t += d;\n        if( t>tmax || d<tmin ) break;\n    }\n\n    // lighting\n    vec3 light = vec3(0.0,0.0,1.0);\n    vec3 n = normal( pos );\n    vec3 l = normalize( light - pos );\n    vec3 v = normalize( -pos );\n    float dif = max( dot( n, l ), 0.0 );\n    vec3 col = vec3( dif );\n\n    // tone mapping\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    //"}], [{"generated_text": "\n    //\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b"}], [{"generated_text": " and forth\n    float fade = (1.0 - abs(rayDir.y)) * 0.5;\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec"}], [{"generated_text": "\n    // The cylinder is a circle with a radius of 1.\n    // The space is a box with a width of 2.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is"}], [{"generated_text": "^2\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.z + dir.z) / dir.z;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 + z^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 + (org.z + t*dir.z)^2 = 0.5^2\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) / dir.x;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool plane(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) / dir.x;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool triangle(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) /"}], [{"generated_text": "\n    vec3 q = p - s.xyz;\n    vec3 qx = q.xzy;\n    vec3 qy = q.yzx;\n    vec3 qz = q.zxy;\n    vec3 qw = q.wxy;\n    vec3 qx2 = qx*2.0;\n    vec3 qy2 = qy*2.0;\n    vec3 qz2 = qz*2.0;\n    vec3 qw2 = qw*2.0;\n    vec3 qx3 = qx*3.0;\n    vec3 qy3 = qy*3.0;\n    vec3 qz3 = qz*3.0;\n    vec3 qw3 = qw*3.0;\n    vec3 qx4 = qx*4.0;\n    vec3 qy4 = qy*4.0;\n    vec3 qz4 = qz*4.0;\n    vec3 qw4 = qw*4.0;\n    vec3 qx5 = qx*5.0;\n    vec3 qy5 = qy*5.0;\n    vec3 qz5 = qz*5.0;\n    vec3 qw5 = qw*5.0;\n    vec3 qx6 = qx*6.0;\n    vec3 qy6 = qy*6.0;\n    vec3 qz6 = qz*6.0;\n    vec3 qw6 = qw*6.0;\n    vec3 qx7 = qx*7.0;\n    vec3 qy7 = qy*7.0;\n    vec3 qz7 = qz*7.0;\n    vec3 qw7 = qw*7.0;\n    vec3 qx8 = qx*8.0;\n    vec3 qy8 = qy*8.0;\n    vec3 qz8 = qz*8.0;\n    vec3 qw8 = qw*8"}], [{"generated_text": "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 p = vec3(uv, 0.0);\n    vec3 col = vec3(0.0);\n    \n    // The camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, -1.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // The ray\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // The raymarching\n    float t = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = noise3D(pos);\n        t += d;\n        if (t > tmax) break;\n    }\n    \n    // The color\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 1.0) * (t / tmax);\n    col += vec3(1.0, 0"}], [{"generated_text": "\n    float d = distance(p, vec2(0.5, 0.5));\n    \n    // The circle's radius.\n    float r = 0.2;\n    \n    // The circle's thickness.\n    float t = 0.01;\n    \n    // The circle's thickness, squared.\n    float t2 = t * t;\n    \n    // The circle's thickness, squared.\n    float d2 = d * d;\n    \n    // The circle's thickness, squared.\n    float r2 = r * r;\n    \n    // The circle's thickness, squared.\n    float d4 = d2 * d2;\n    \n    // The circle's thickness, squared.\n    float r4 = r2 * r2;\n    \n    // The circle's thickness, squared.\n    float d8 = d4 * d4;\n    \n    // The circle's thickness, squared.\n    float r8 = r4 * r4;\n    \n    // The circle's thickness, squared.\n    float d16 = d8 * d8;\n    \n    // The circle's thickness, squared.\n    float r16 = r8 * r8;\n    \n    // The circle's thickness, squared.\n    float d32 = d16 * d16;\n    \n    // The circle's thickness, squared.\n    float r32 = r16 * r16;\n    \n    // The circle's thickness, squared.\n    float d64 = d32 * d32;\n    \n    // The circle's thickness, squared.\n    float r64 = r32 * r32;\n    \n    // The circle's thickness, squared.\n    float d128 = d64 * d64;\n    \n    // The circle's thickness, squared.\n    float r128 = r64 * r64;\n    \n    // The circle's thickness, squared.\n    float d256 = d128 * d128;\n    \n    // The circle's thickness,"}], [{"generated_text": "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bump mapping to apply.\n    //\n    // sn - The normal of the surface at the point sp.\n    // snx - Change in \"sn\" in in the X-direction.\n    // sny - Change in \"sn\" in in the Y-direction.\n    // snz - Change in \"sn\" in in the Z-direction.\n    //\n    // sp - The point at which the bump mapping is being applied.\n    // spx - Change in \"sp\" in in the X-direction.\n    // spy - Change in \"sp\" in in the Y-direction.\n    // spz - Change in \"sp\" in in the Z-direction.\n    //\n    // bump - The bump mapping result.\n    //\n    // The following is the bump mapping formula.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpF"}], [{"generated_text": "\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2"}], [{"generated_text": "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  vec3 ambient = vec3(0.1, 0.1, 0.1) * vec3(0.5, 0.5, 0.5);\n  vec3 diffuse = vec3(0.5, 0.5, 0.5) * vec3(0.5, 0.5, 0.5);\n  vec3 specular = vec3(0.5, 0.5, 0.5) * vec3(0.5, 0.5, 0.5);\n  float specular_strength = 0.5;\n  float specular_intensity = 0.5;\n  float diffuse_intensity = 0.5;\n  float attenuation = 1.0;\n  float distance = length(light - p);\n  float attenuation_factor = 1.0 / (attenuation * distance * distance);\n  float diffuse_factor = max(dot(light_dir, n), 0.0);\n  float specular_factor = pow(max(dot(view_dir, reflect_dir), 0.0), 32);\n  vec3 color = ambient * attenuation_factor;\n  color += diffuse * diffuse_factor * diffuse_intensity * attenuation_factor;\n  color += specular * specular_factor * specular_strength * specular_intensity * attenuation_factor;\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.x, gl_FragCoord.y, 0.0);\n  vec3 n = normal(p);\n  vec3 color = shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n    Ray ray = Ray(vec3(0.0), vec3(0.0, 0.0, 1.0));\n    ray.origin = vec3(0.0);\n    ray.direction = normalize(vec3(0.0, 0.0, 1.0));\n\n    //creats a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n\n    //creats a material object\n    Material material = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n\n    //creats a light object\n    Light light = Light(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n\n    //creats a camera object\n    Camera camera = Camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0."}], [{"generated_text": "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(rd, vec3(0.0, 1.0, 0.0));\n    t = clamp(t, 0.0, 1.0);\n    sky = mix(sky, par, t);\n    return sky;\n}\n\nvec"}], [{"generated_text": "i\n    float k = 1.0;\n    float k2 = 1.0;\n    float k3 = 1.0;\n    float k4 = 1.0;\n    float k5 = 1.0;\n    float k6 = 1.0;\n    float k7 = 1.0;\n    float k8 = 1.0;\n    float k9 = 1.0;\n    float k10 = 1.0;\n    float k11 = 1.0;\n    float k12 = 1.0;\n    float k13 = 1.0;\n    float k14 = 1.0;\n    float k15 = 1.0;\n    float k16 = 1.0;\n    float k17 = 1.0;\n    float k18 = 1.0;\n    float k19 = 1.0;\n    float k20 = 1.0;\n    float k21 = 1.0;\n    float k22 = 1.0;\n    float k23 = 1.0;\n    float k24 = 1.0;\n    float k25 = 1.0;\n    float k26 = 1.0;\n    float k27 = 1.0;\n    float k28 = 1.0;\n    float k29 = 1.0;\n    float k30 = 1.0;\n    float k31 = 1.0;\n    float k32 = 1.0;\n    float k33 = 1.0;\n    float k34 = 1.0;\n    float k35 = 1.0;\n    float k36 = 1.0;\n    float k37 = 1.0;\n    float k38 = 1.0;\n    float k39 = 1.0;\n    float k40 = 1.0;\n    float k41 = 1.0;\n    float k42 = 1.0;\n    float k43 = 1.0;\n    float k44 = 1.0;\n    float k45 = 1.0;\n    float k46 = 1.0;\n    float k47 = 1.0;\n    float k"}], [{"generated_text": "\n    return length(p) - rad;\n}\n\nfloat"}], [{"generated_text": "\n    vec3 fp = floor(p);\n    vec3 cp = ceil(p);\n\n    // distance to the nearest point\n    vec3 d0 = p - fp;\n    vec3 d1 = cp - p;\n\n    // interpolate between the two points\n    return mix(mix(d0.x, d0.y, d0.z), mix(d1.x, d1.y, d1.z), smoothstep(0.0, 1.0, param.x));\n}\n\n// ------------------------------------------------------------\n// 2D Fractal Brownian Motion\n// ------------------------------------------------------------\n\nfloat"}], [{"generated_text": "\n    vec3 floor = floor(p);\n    vec3 ceiling = floor + vec3(1.0);\n\n    // get the distance to the floor and ceiling\n    vec3 dist_floor = p - floor;\n    vec3 dist_ceiling = ceiling - p;\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge = min(dist_floor, dist_ceiling);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner = min(dist_to_edge, min(dist_floor.yzx, dist_floor.zxy));\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_2 = min(dist_ceiling, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_2 = min(dist_to_edge_2, min(dist_ceiling.yzx, dist_ceiling.zxy));\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_3 = min(dist_to_corner_2, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_3 = min(dist_to_edge_3, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_4 = min(dist_to_corner_3, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_4 = min(dist_to_edge_4, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_5 = min(dist_to_corner_4, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_5 = min(dist_to_edge_5, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_"}], [{"generated_text": "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(par, rd);\n    if (t > 0.0)\n    {\n        sky = par * t;\n    }\n    return sky;\n}\n\nvec"}], [{"generated_text": "\n    float k = 1.0;\n    float k2 = 1.0;\n    float k3 = 1.0;\n    float k4 = 1.0;\n    float k5 = 1.0;\n    float k6 = 1.0;\n    float k7 = 1.0;\n    float k8 = 1.0;\n    float k9 = 1.0;\n    float k10 = 1.0;\n    float k11 = 1.0;\n    float k12 = 1.0;\n    float k13 = 1.0;\n    float k14 = 1.0;\n    float k15 = 1.0;\n    float k16 = 1.0;\n    float k17 = 1.0;\n    float k18 = 1.0;\n    float k19 = 1.0;\n    float k20 = 1.0;\n    float k21 = 1.0;\n    float k22 = 1.0;\n    float k23 = 1.0;\n    float k24 = 1.0;\n    float k25 = 1.0;\n    float k26 = 1.0;\n    float k27 = 1.0;\n    float k28 = 1.0;\n    float k29 = 1.0;\n    float k30 = 1.0;\n    float k31 = 1.0;\n    float k32 = 1.0;\n    float k33 = 1.0;\n    float k34 = 1.0;\n    float k35 = 1.0;\n    float k36 = 1.0;\n    float k37 = 1.0;\n    float k38 = 1.0;\n    float k39 = 1.0;\n    float k40 = 1.0;\n    float k41 = 1.0;\n    float k42 = 1.0;\n    float k43 = 1.0;\n    float k44 = 1.0;\n    float k45 = 1.0;\n    float k46 = 1.0;\n    float k47 = 1.0;\n    float k4"}], [{"generated_text": "\n    float r = atan(p.y, p.x) + PI/2;\n    float a = atan(diamond.y, diamond.x);\n    float d = abs(r - a);\n    if (d > PI/2) d = PI - d;\n    return d;\n}\n\nfloat"}], [{"generated_text": "\n    // to avoid the need for a separate texture.\n    vec3 color = vec3(0.0);\n    color += texture(iChannel0, uv).rgb;\n    color += texture(iChannel1, uv).rgb;\n    color += texture(iChannel2, uv).rgb;\n    color += texture(iChannel3, uv).rgb;\n    color += texture(iChannel4, uv).rgb;\n    color += texture(iChannel5, uv).rgb;\n    color += texture(iChannel6, uv).rgb;\n    color += texture(iChannel7, uv).rgb;\n    color += texture(iChannel8, uv).rgb;\n    color += texture(iChannel9, uv).rgb;\n    color += texture(iChannel10, uv).rgb;\n    color += texture(iChannel11, uv).rgb;\n    color += texture(iChannel12, uv).rgb;\n    color += texture(iChannel13, uv).rgb;\n    color += texture(iChannel14, uv).rgb;\n    color += texture(iChannel15, uv).rgb;\n    color += texture(iChannel16, uv).rgb;\n    color += texture(iChannel17, uv).rgb;\n    color += texture(iChannel18, uv).rgb;\n    color += texture(iChannel19, uv).rgb;\n    color += texture(iChannel20, uv).rgb;\n    color += texture(iChannel21, uv).rgb;\n    color += texture(iChannel22, uv).rgb;\n    color += texture(iChannel23, uv).rgb;\n    color += texture(iChannel24, uv).rgb;\n    color += texture(iChannel25, uv).rgb;\n    color += texture(iChannel26, uv).rgb;\n    color += texture(iChannel27, uv).rgb;\n    color += texture(iChannel28, uv).rgb;\n   "}], [{"generated_text": "\n\tfloat d = 1000000.0;\n\t\n\t//...add objects here...\n\t\n\treturn d;\n}\n\n// --------------------------------------------------------\n// \n// \tMain\n// \n// --------------------------------------------------------\n\nvoid main()\n{\n\tvec3 pos = vec3(0.0);\n\t\n\tfloat d = dist_field( pos );\n\t\n\tgl_FragColor = vec4( d );\n}\n"}], [{"generated_text": "\n\tvec3 light = vec3( 0.0 );\n\tvec3 diffuse = vec3( 0.0 );\n\tvec3 specular = vec3( 0.0 );\n\tvec3 ambient = vec3( 0.0 );\n\tvec3 halfV = normalize( eye + v );\n\tfloat shininess = 10.0;\n\tfloat attenuation = 1.0;\n\tfloat spotlight = 0.0;\n\tfloat spotlight_cutoff = 0.0;\n\tfloat spotlight_outercutoff = 0.0;\n\tfloat spotlight_constant = 0.0;\n\tfloat spotlight_linear = 0.0;\n\tfloat spotlight_quadratic = 0.0;\n\tfloat spotlight_cutoff_cos = 0.0;\n\tfloat spotlight_outercutoff_cos = 0.0;\n\tfloat spotlight_constant_cos = 0.0;\n\tfloat spotlight_linear_cos = 0.0;\n\tfloat spotlight_quadratic_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos = 0.0;\n\tfloat spotlight_quadratic_cos_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos_cos = 0.0;\n\tfloat spotlight_quadratic_cos_cos_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos_cos_cos = 0.0;"}], [{"generated_text": "\n    //return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n\n    // This is the original, but it's a bit slower.\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat"}], [{"generated_text": "\n    // 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    float aa = a;\n    //Increase Activity Level For Better Performance\n    float aa2 = aa*aa;\n    //Increase Activity Level For Better Performance\n    float aa3 = aa*aa2;\n    //Increase Activity Level For Better Performance\n    float aa4 = aa*aa3;\n    //Increase Activity Level For Better Performance\n    float aa5 = aa*aa4;\n    //Increase Activity Level For Better Performance\n    float aa6 = aa*aa5;\n    //Increase Activity Level For Better Performance\n    float aa7 = aa*aa6;\n    //Increase Activity Level For Better Performance\n    float aa8 = aa*aa7;\n    //Increase Activity Level For Better Performance\n    float aa9 = aa*aa8;\n    //Increase Activity Level For Better Performance\n    float aa10 = aa*aa9;\n    //Increase Activity Level For Better Performance\n    float aa11 = aa*aa10;\n    //Increase Activity Level For Better Performance\n    float aa12 = aa*aa11;\n    //Increase Activity Level For Better Performance\n    float aa13 = aa*aa12;\n    //Increase Activity Level For Better Performance\n    float aa14 = aa*aa13;\n    //Increase Activity Level For Better Performance\n    float aa15 = aa*aa14;\n    //Increase Activity Level For Better Performance\n    float aa16 = aa*aa15;\n    //Increase Activity Level For Better Performance\n    float aa17 = aa*aa16;\n    //Increase Activity Level For Better Performance\n    float aa18 = aa*aa17;\n    //Increase Activity Level For Better Performance\n    float aa19 = aa*aa18;\n    //Increase Activity Level For Better Performance\n    float aa20 = aa*aa19;\n    //Increase Activity Level For Better Performance\n    float aa21 = aa*aa20;\n   "}], [{"generated_text": "\n    float d = length(p.xz) - r;\n    // How far along the cylinder the point is, vertically\n    float a = p.y;\n    // If the point is inside the cylinder, return the distance to the\n    // nearest point on the cylinder. If the point is outside the cylinder,\n    // return the distance to the nearest point on the cylinder's top or\n    // bottom.\n    return max(d, -a + h);\n}\n\nfloat"}], [{"generated_text": "\n    float t = iGlobalTime * 0.001;\n    p.xz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    p.y *= 0.5;\n\n    // SDF of the scene\n    float sdf = sceneSDF(p);\n\n    // Add some noise to the scene\n    sdf += noise(p * 10.0) * 0.01;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100.0) * 0.001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000.0) * 0.0001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000.0) * 0.00001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100000.0) * 0.000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000000.0) * 0.0000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000000.0) * 0.00000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100000000.0) * 0.000000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000000000.0) * 0.0000000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000000000.0) * 0.00000000001;\n\n    // Add some more noise to the scene\n    sdf += noise"}], [{"generated_text": "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    mat3 m = mat3(s.x, u.x, f.x,\n                  s.y, u.y, f.y,\n                  s.z, u.z, f.z);\n\n    return m * mat3(1, 0, 0,\n                    0, 1, 0,\n                    -eye.x, -eye.y, -eye.z);\n}\n\nvoid main() {\n    vec3 eye = vec3(0.0, 0.0, 1.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    mat3 viewMatrix = viewMatrix(eye, center, up);\n\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    vec3 normal = normalize(inNormal);\n    vec3 lightDir = normalize(lightPos - inPosition);\n    vec3 viewDir = normalize(eye - inPosition);\n\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specularColor = specular * lightColor;\n\n    color = (diffuseColor + specularColor) * inColor;\n\n    gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n    float t = (p.x+p.y+p.z)*0.0001;\n    return t;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0);\n    p.x = tweaknoise(p);\n    p.y = tweaknoise(p);\n    p.z = tweaknoise(p);\n    gl_FragColor = vec4(p, 1.0);\n}\n"}], [{"generated_text": "\n    //I'm not sure if this is the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not"}], [{"generated_text": "\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat"}], [{"generated_text": "\n    vec3 q = p;\n    q.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n    q.y *= mat2(1.0, 0.0, 0.0, 1.0);\n    return q;\n}\n\n// This is the bump function that I'm using. It's a bit more complex than\n// the standard cylindrical mapping, but it's much more accurate.\nvec"}], [{"generated_text": "\n    // scr_pt is in screen space, and is in range [0,1]x[0,1].\n    // view_inv is the inverse of the view matrix.\n    // proj_inv is the inverse of the projection matrix.\n    // viewp_inv is the inverse of the view projection matrix.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera"}], [{"generated_text": "\n    float r = length(pA - pB);\n    r = min(r, rounded);\n\n    // Get the distance from the line to the point.\n    float d = distance(pA, uv);\n\n    // If the distance is less than the thickness, it's on the line.\n    if (d < thick.x) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the thickness, it's not on the line.\n    if (d > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the thickness and the rounded radius, it's on the line.\n    if (d > thick.x && d < thick.y) {\n        return 1.0 - smoothstep(thick.x, thick.y, d);\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < rounded) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > rounded) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it"}], [{"generated_text": "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 half_dir = normalize(light_dir + view_dir);\n  float diffuse = max(0.0, dot(n, light_dir));\n  float specular = pow(max(0.0, dot(n, half_dir)), 16.0);\n  return vec3(diffuse, diffuse, diffuse) * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * specular;\n}\n\nvoid main()\n{\n  vec3 n = normalize(normal);\n  vec3 p = vec3(position);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  for (int i = 0; i < num_lights; i++)\n  {\n    color += Shade(p, n);\n  }\n  color = clamp(color, 0.0, 1.0);\n  gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n\tvec3 bmin = cen - rad;\n\tvec3 bmax = cen + rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat tN = max(t0, t3);\n\tfloat tF = min(t2.x, t2.y);\n\tfloat tB = max(t1.y, t1.z);\n\tfloat tL = min(t1.x, t1.z);\n\tfloat tH = max(t1.y, t1.z);\n\tfloat tS = max(t2.y, t2.z);\n\tfloat tFar = max(tF, tB);\n\tfloat tNear = min(tL, tS);\n\tfloat t = max(tN, tNear);\n\tif( t > tFar )\n\t\treturn vec2( -1.0 );\n\treturn vec2( t, tNear );\n}\n\n// ray-sphere intersection\nvec"}], [{"generated_text": "\n    float wave = (sin(x * a) + sin(x * b)) / 2;\n    return wave;\n}\n\nfloat"}], [{"generated_text": "\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\nvec"}], [{"generated_text": "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize( ab );\n    // center the cylinder\n    vec3 ca = pa + abn * 0.5;\n    // distance to cylinder\n    float d = length( rd - ca );\n    // cylinder radius\n    float r = length( pb - pa ) * 0.5;\n    // cylinder height\n    float h = length( pb - pa ) * 0.5;\n    // cylinder normal\n    vec3 n = normalize( pb - pa );\n    // cylinder normal\n    vec3 nn = normalize( n );\n    // cylinder normal\n    vec3 nn2 = normalize( nn );\n    // cylinder normal\n    vec3 nn3 = normalize( nn2 );\n    // cylinder normal\n    vec3 nn4 = normalize( nn3 );\n    // cylinder normal\n    vec3 nn5 = normalize( nn4 );\n    // cylinder normal\n    vec3 nn6 = normalize( nn5 );\n    // cylinder normal\n    vec3 nn7 = normalize( nn6 );\n    // cylinder normal\n    vec3 nn8 = normalize( nn7 );\n    // cylinder normal\n    vec3 nn9 = normalize( nn8 );\n    // cylinder normal\n    vec3 nn10 = normalize( nn9 );\n    // cylinder normal\n    vec3 nn11 = normalize( nn10 );\n    // cylinder normal\n    vec3 nn12 = normalize( nn11 );\n    // cylinder normal\n    vec3 nn13 = normalize( nn12 );\n    // cylinder normal\n    vec3 nn14 = normalize( nn13 );\n    // cylinder normal\n    vec3 nn15 = normalize( nn14 );\n    // cylinder normal\n    vec3 nn16 = normalize( nn15 );\n    // cylinder normal\n    vec3 nn17 = normalize( nn16 );\n    // cylinder normal\n    vec3 nn"}], [{"generated_text": "\n\n\tfloat d = length(P-U);\n\tfloat a = smoothstep(r,r+.001,d);\n\tO.xyz = mix(O.xyz,C,a);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n\n\tvec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n\tvec2 P = (2.*U-R)/R.y;\n\t\n\tvec3 C = vec3(0.);\n\t\n\tsphere(O,U,P,0.001,vec3(1.,0.,0.));\n\tsphere(O,U,P,0.002,vec3(0.,1.,0.));\n\tsphere(O,U,P,0.003,vec3(0.,0.,1.));\n\tsphere(O,U,P,0.004,vec3(1.,1.,0.));\n\tsphere(O,U,P,0.005,vec3(1.,0.,1.));\n\tsphere(O,U,P,0.006,vec3(0.,1.,1.));\n\tsphere(O,U,P,0.007,vec3(1.,1.,1.));\n\t\n\tO.xyz = mix(O.xyz,C,smoothstep(.9,.0,length(P-M)));\n}\n\nvoid main() {\n\tmainImage(O,U);\n}\n"}], [{"generated_text": "\n    float d = dot(p, p) * 100.0;\n    p.x += sin(d) * 0.01;\n    p.y += cos(d) * 0.01;\n    p.z += sin(d) * 0.01;\n\n    // map the scene\n    p = p * 0.5 + 0.5;\n    p.x = p.x * 2.0 - 1.0;\n    p.y = p.y * 2.0 - 1.0;\n    p.z = p.z * 2.0 - 1.0;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0."}], [{"generated_text": "\n    vec2 grid = floor(p);\n    vec2 f = fract(p);\n\n    // We need to scale the grid coordinates by the scale factor.\n    vec2 scale = vec2(1.0, 1.0);\n    scale.x = (grid.x + f.x) * scale.x;\n    scale.y = (grid.y + f.y) * scale.y;\n\n    // We need to scale the layer ID by the scale factor.\n    float scaleID = layerID * scale.x;\n\n    // We need to scale the layer ID by the scale factor.\n    float scaleDec = layerID * scale.y;\n\n    return vec3(scale.x, scale.y, scaleDec);\n}\n\n// This function will be used to draw the grid.\nvec"}], [{"generated_text": "\n    float scale = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u0430\u043c\u044f\n    float distance = length(currentRayPosition.xz) - 1.0;\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u0430\u043c\u044f \u043c\u0435\u043d\u044c\u0448\u0435 0.001, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    if (distance < 0.001)\n        return 1.0;\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u043f\u043b\u0430\u043c\u044f\n    float k = (1.0 - distance / 1.0) * (1.0 - distance / 1.0) * (1.0 - distance / 1.0) * (1.0 - distance / 1.0);\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    vec3 color = vec3(0.0);\n    color.r = k * 0.5;\n    color.g = k * 0.5;\n    color.b = k * 0.5;\n\n    // \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    return color;\n}\n\nvoid main()\n{\n    // \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u043a\u0438 \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\n    vec3 currentRayPosition = vec3(gl_FragCoord.xy, 0.0);\n\n    // \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    vec3 color = flame(currentRayPosition);\n\n    // \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    gl_FragColor = vec4(color, 1.0);\n}"}], [{"generated_text": "\n    float flameDistance = abs(scene(currentRayPosition));\n    // \u0435\u0441\u043b\u0438 \u043f\u043b\u0430\u043c\u044f \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u043f\u0440\u0435\u0434\u0435\u043b\u0430\u0445 \u0441\u0446\u0435\u043d\u044b, \u0442\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442\n    if (flameDistance < 0.001)\n    {\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442\n        vec3 color = vec3(0.0, 0.0, 0.0);\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0441\u0432\u0435\u0442\u043b\u0435\u043d\u0438\u044f\n        float lightIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float shadowIntensity = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float specularIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio2 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio3 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio4 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio5 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio6 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio7 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio8 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c"}], [{"generated_text": "\n    float s = sm;\n    \n    // The fractal function.\n    float f = fract(x);\n    \n    // The fractal function.\n    float f2 = f * f;\n    \n    // The fractal function.\n    float f3 = f2 * f;\n    \n    // The fractal function.\n    float f4 = f3 * f;\n    \n    // The fractal function.\n    float f5 = f4 * f;\n    \n    // The fractal function.\n    float f6 = f5 * f;\n    \n    // The fractal function.\n    float f7 = f6 * f;\n    \n    // The fractal function.\n    float f8 = f7 * f;\n    \n    // The fractal function.\n    float f9 = f8 * f;\n    \n    // The fractal function.\n    float f10 = f9 * f;\n    \n    // The fractal function.\n    float f11 = f10 * f;\n    \n    // The fractal function.\n    float f12 = f11 * f;\n    \n    // The fractal function.\n    float f13 = f12 * f;\n    \n    // The fractal function.\n    float f14 = f13 * f;\n    \n    // The fractal function.\n    float f15 = f14 * f;\n    \n    // The fractal function.\n    float f16 = f15 * f;\n    \n    // The fractal function.\n    float f17 = f16 * f;\n    \n    // The fractal function.\n    float f18 = f17 * f;\n    \n    // The fractal function.\n    float f19 = f18 * f;\n    \n    // The fractal function.\n    float f20 = f19 * f;\n    \n    // The fractal function.\n    float f21 = f20 * f;\n    \n    // The fractal function.\n    float f22 = f21 * f;\n    \n    // The fractal function.\n    float f23 = f22 *"}], [{"generated_text": "\n\n    // p = p * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    // Determine the first vertice.\n    vec3 q = p - f;\n\n    // Determine the first vertice.\n    vec4 w = mix(mix(mix(dot(q, vec3(1.0, 57.0, 113.0)),\n                        dot(q, vec3(57.0, 113.0, 17.0)),\n                        f.y),\n                    mix(dot(q, vec3(113.0, 57.0, 17.0)),\n                        dot(q, vec3(17.0, 113.0, 57.0)),\n                        f.y),\n                    f.z),\n               mix(mix(dot(q, vec3(57.0, 17.0, 113.0)),\n                        dot(q, vec3(17.0, 57.0, 113.0)),\n                        f.z),\n                   mix(dot(q, vec3(113.0, 17.0, 57.0)),\n                       dot(q, vec3(17.0, 113.0, 57.0)),\n                       f.z),\n                   f.x),\n               f.x);\n\n    // Determine the first vertice.\n    return mix(mix(mix(w.x, w.y, f.x), w.z, f.y), w.w, f.z);\n}\n\nfloat"}], [{"generated_text": "\n    float n = 0.0;\n    \n    // The frequency.\n    float f = 1.0;\n    \n    // The amplitude.\n    float a = 1.0;\n    \n    // The number of octaves.\n    int o = 1;\n    \n    // The persistence.\n    float p = 0.5;\n    \n    // The offset.\n    float of = 0.0;\n    \n    // The scale.\n    float s = 1.0;\n    \n    // The number of iterations.\n    int i = 0;\n    \n    // The total value.\n    float t = 0.0;\n    \n    // The total value.\n    float t2 = 0.0;\n    \n    // The total value.\n    float t3 = 0.0;\n    \n    // The total value.\n    float t4 = 0.0;\n    \n    // The total value.\n    float t5 = 0.0;\n    \n    // The total value.\n    float t6 = 0.0;\n    \n    // The total value.\n    float t7 = 0.0;\n    \n    // The total value.\n    float t8 = 0.0;\n    \n    // The total value.\n    float t9 = 0.0;\n    \n    // The total value.\n    float t10 = 0.0;\n    \n    // The total value.\n    float t11 = 0.0;\n    \n    // The total value.\n    float t12 = 0.0;\n    \n    // The total value.\n    float t13 = 0.0;\n    \n    // The total value.\n    float t14 = 0.0;\n    \n    // The total value.\n    float t15 = 0.0;\n    \n    // The total value.\n    float t16 = 0.0;\n    \n    // The total value.\n    float t17 = 0.0;\n    \n    // The total value.\n    float t18 = 0.0;\n    \n    // The total value.\n    float t19 = 0.0;\n    \n    // The total value.\n    float"}], [{"generated_text": "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // Then we define our balloon height\n  float balloonHeight = 0.05;\n  \n  // Then we define our balloon width\n  float balloonWidth = 0.05;\n  \n  // Then we define our balloon depth\n  float balloonDepth = 0.05;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0."}], [{"generated_text": "\n\tvec3 tmin = (rad - ro) / rd;\n\tvec3 tmax = (rad + ro) / rd;\n\n\t// find the largest entering t value first\n\tvec3 t1 = max(tmin, tmax);\n\tvec3 t2 = min(tmin, tmax);\n\n\t// find the smallest exiting t value\n\tvec3 tmin2 = max(t2, t1);\n\tvec3 tmax2 = min(t2, t1);\n\n\t// find the largest entering t value first\n\tvec3 t3 = max(tmin2, tmax2);\n\tvec3 t4 = min(tmin2, tmax2);\n\n\t// find the smallest exiting t value\n\tvec3 tmin3 = max(t4, t3);\n\tvec3 tmax3 = min(t4, t3);\n\n\t// find the largest entering t value first\n\tvec3 t5 = max(tmin3, tmax3);\n\tvec3 t6 = min(tmin3, tmax3);\n\n\t// find the smallest exiting t value\n\tvec3 tmin4 = max(t6, t5);\n\tvec3 tmax4 = min(t6, t5);\n\n\t// find the largest entering t value first\n\tvec3 t7 = max(tmin4, tmax4);\n\tvec3 t8 = min(tmin4, tmax4);\n\n\t// find the smallest exiting t value\n\tvec3 tmin5 = max(t8, t7);\n\tvec3 tmax5 = min(t8, t7);\n\n\t// find the largest entering t value first\n\tvec3 t9 = max(tmin5, tmax5);\n\tvec3 t10 = min(tmin5, tmax5);\n\n\t// find the smallest exiting t value\n\tvec3 tmin6 = max(t10, t9);\n\tvec3 tmax6 = min(t10, t9);\n\n\t// find the largest entering t value first\n\tvec3 t11 = max(tmin6, tmax6);\n\tvec3 t12 = min(tmin6, tmax6);\n\n\t// find the"}], [{"generated_text": "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    \n    // Determining the first vertice.\n    vec3 q = p - f;\n    \n    // Determining the first vertice.\n    vec4 w = mix(mix(mix(dot(q, vec3(1.0, 57.0, 21.0)),\n                        dot(q, vec3(57.0, 159.0, 23.0)),\n                        f.y),\n                    mix(dot(q, vec3(73.0, 91.0, 3.0)),\n                        dot(q, vec3(27.0, 19.0, 153.0)),\n                        f.y),\n                    f.z),\n               mix(mix(dot(q, vec3(17.0, 103.0, 7.0)),\n                        dot(q, vec3(13.0, 99.0, 15.0)),\n                        f.y),\n                   dot(q, vec3(83.0, 11.0, 89.0)),\n                   f.z),\n               f.x);\n    \n    // Determining the first vertice.\n    return mix(w.x, w.y, w.z);\n}\n\nfloat"}], [{"generated_text": "\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monoch"}], [{"generated_text": "\n    //Use a for loop to make sure the loop is executed at least once.\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return vec4(i, 0.0, 0.0, 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid main(){\n    vec2 c = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec4 color = mandelbrot(c, c);\n    gl_FragColor = vec4(color.xyz, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    //we need to create the matrix\n    mat4 mat = mat4(x.x, x.y, x.z, 0.0,\n                    y.x, y.y, y.z, 0.0,\n                    z.x, z.y, z.z, 0.0,\n                    0.0, 0.0, 0.0, 1.0);\n\n    return mat;\n}\n\nvec"}], [{"generated_text": "\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),clamp(rgb+vec3(0.0,1.0,1.0),0.0,1.0),c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / resolution.xy);\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= resolution.x / resolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = time * 0.005;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float h = atan(p.y, p.x) / (2.0 * 3.1415926535897932384626433832795);\n    vec3 hsv = vec3(h, s, c);\n    vec3 rgb = hsv2rgb(hsv);\n\n    col = mix(col, rgb, 0.5);\n\n    gl_FragColor = vec4(col, 1.0);\n}"}], [{"generated_text": "\n    float d = w / 2.0;\n    float x = floor(p.x / d);\n    float y = floor(p.y / d);\n    float xf = fract(p.x / d);\n    float yf = fract(p.y / d);\n    float xd = x + xf;\n    float yd = y + yf;\n    float xd2 = xd + xf;\n    float yd2 = yd + yf;\n    float xd3 = xd + xf + xf;\n    float yd3 = yd + yf + yf;\n    float xd4 = xd + xf + xf + xf;\n    float yd4 = yd + yf + yf + yf;\n    float xd5 = xd + xf + xf + xf + xf;\n    float yd5 = yd + yf + yf + yf + yf;\n    float xd6 = xd + xf + xf + xf + xf + xf;\n    float yd6 = yd + yf + yf + yf + yf + yf;\n    float xd7 = xd + xf + xf + xf + xf + xf + xf;\n    float yd7 = yd + yf + yf + yf + yf + yf + yf;\n    float xd8 = xd + xf + xf + xf + xf + xf + xf + xf;\n    float yd8 = yd + yf + yf + yf + yf + yf + yf + yf;\n    float xd9 = xd + xf + xf + xf + xf + xf + xf + xf + xf;\n    float yd9 = yd + yf + yf + yf + yf + yf + yf + yf + yf;\n    float xd10 = xd + xf + xf + xf + xf + xf + xf + xf + xf + xf;\n    float yd10 = yd"}], [{"generated_text": "\n    if (a == b)\n        return 0.0f;\n\n    // clamp x to be between a and b\n    if (x < a)\n        x = a;\n    else if (x > b)\n        x = b;\n\n    // calculate the step\n    float step = (x - a) / (b - a);\n\n    // return the step\n    return step;\n}\n\n//src/math/vec2.h\n#pragma once\n\n#include <math.h>\n\nstruct vec2\n{\n    float x, y;\n\n    vec2() : x(0.0f), y(0.0f) {}\n    vec2(float x, float y) : x(x), y(y) {}\n\n    vec2 operator+(const vec2& v) const\n    {\n        return vec2(x + v.x, y + v.y);\n    }\n\n    vec2 operator-(const vec2& v) const\n    {\n        return vec2(x - v.x, y - v.y);\n    }\n\n    vec2 operator*(const vec2& v) const\n    {\n        return vec2(x * v.x, y * v.y);\n    }\n\n    vec2 operator/(const vec2& v) const\n    {\n        return vec2(x / v.x, y / v.y);\n    }\n\n    vec2 operator*(float s) const\n    {\n        return vec2(x * s, y * s);\n    }\n\n    vec2 operator/(float s) const\n    {\n        return vec2(x / s, y / s);\n    }\n\n    vec2 operator-() const\n    {\n        return vec2(-x, -y);\n    }\n\n    vec2& operator+=(const vec2& v)\n    {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n\n    vec2& operator-=(const vec2& v)\n    {\n        x -= v"}], [{"generated_text": "\n    float dist = sampleFunc(xy);\n\n    // if the distance is less than the curve, then the pixel is on the curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\nvoid main()\n{\n    // get the xy coordinates of the pixel\n    vec2 xy = gl_FragCoord.xy / resolution;\n\n    // get the color of the pixel\n    vec4 baseCol = texture(tex, xy);\n\n    // draw the curve\n    drawFunc(baseCol, xy, curveCol);\n\n    // write the color to the framebuffer\n    gl_FragColor = baseCol;\n}\n"}], [{"generated_text": "\n float x = p.x + cos(j*2.0*3.1415926535897932384626433832795)*0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.w*5.);\n //return f;\n //return f*f;\n //return f*f*f;\n //return f*f*f*f;\n //return f*f*f*f*f;\n //return f*f*f*f*f*f;\n //return f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*"}], [{"generated_text": "\n    return vec3(c.r, c.g, c.b);\n}\n\nvec"}], [{"generated_text": "\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox"}], [{"generated_text": "\n //return sdSuperprim(p,s,r);\n //}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}], [{"generated_text": "\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod("}], [{"generated_text": "\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    return clamp(x * (2.51 * x + 0.04), vec3(0.0), vec3(1.0));\n}\n\nvec"}], [{"generated_text": "\n    p.z -= 10.0;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 v = normalize(p - cameraPos);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), v));\n    vec3 u = cross(v, r);\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 c = cameraPos + v;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 rd = normalize(p - c);\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    float t = 0.0;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    for (int i = 0; i < 100; i++) {\n        vec3 p = c + rd * t;\n        float d = map(p);\n        t += d;\n    }\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    return t;\n}\n\n// The camera is at (0,0,0) and looks at (0,0,1)\nfloat"}], [{"generated_text": "\n    float r = 0.5;\n    vec3 p2 = p - vec3(0.0, 0.0, 0.0);\n    float d = length(p2);\n    if (d < r) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    //plane\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float t = dot(p2, n) / dot(p2, n);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return p2 - n * t;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 l = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3"}], [{"generated_text": "\n    mat2 m = mat2( 0.8, -0.6, 0.6, 0.8 );\n    // scale and bias the point\n    p = p * 2.0 - 1.0;\n    p.x *= m.x;\n    p.y *= m.y;\n    // add in the axial bias\n    p.x += fbm( p + vec2( 0.0, 0.0 ) );\n    p.y += fbm( p + vec2( 0.0, 0.0 ) );\n    // return the noise value\n    return fbm( p );\n}\n\nfloat"}], [{"generated_text": "\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point"}], [{"generated_text": "\n return dot(u,m);\n}\n\nfloat"}], [{"generated_text": "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n}\n\nfloat"}], [{"generated_text": ".\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2"}], [{"generated_text": "\n /*O*/\n return v1;\n}\n\nint"}], [{"generated_text": "\n /*O*/\n return v1;\n}\n\nint"}], [{"generated_text": "\n    return cross(a, b);\n}\n\nvec"}], [{"generated_text": "\n\tfloat alpha = acos(dot(normalize(A), normalize(B)));\n\tfloat beta = acos(dot(normalize(B), normalize(C)));\n\tfloat gamma = acos(dot(normalize(C), normalize(A)));\n\n\t//calculate the coordinates of the point on the sphere\n\tvec3 p = vec3(cos(alpha) * cos(beta) * cos(gamma) + Xi1, cos(alpha) * cos(beta) * sin(gamma) + Xi2, sin(alpha) * cos(beta) + sin(gamma));\n\n\t//calculate the pdf of the point on the sphere\n\twPdf = (1.0 / (4.0 * PI)) * (1.0 - cos(alpha) * cos(beta) * cos(gamma)) / (p.x * p.x + p.y * p.y + p.z * p.z);\n\n\t//calculate the direction of the point on the sphere\n\tw = normalize(p);\n}\n\nvoid main() {\n\t//calculate the coordinates of the point on the sphere\n\tvec3 w;\n\tfloat wPdf;\n\tsampleSphericalTriangle(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), uv.x, uv.y, w, wPdf);\n\n\t//calculate the pdf of the point on the sphere\n\tfloat pdf = (1.0 / (4.0 * PI)) * (1.0 - w.x * w.x - w.y * w.y - w.z * w.z) / (w.x * w.x + w.y * w.y + w.z * w.z);\n\n\t//calculate the cosine of the angle between the normal and the direction of the point on the sphere\n\tfloat cosTheta = dot(w, normalize(normal));\n\n\t//calculate the cosine of the angle between the normal and the direction of the point on the sphere\n\tfloat cosPhi = dot(w, normalize(vec3(0.0"}], [{"generated_text": "\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n"}], [{"generated_text": "\n    \n    // The tube is a 1D function, so we can use the \"fract\" function to get the fractional part of the x coordinate.\n    float t = fract(p.x);\n    \n    // The tube is a 2D function, so we can use the \"fract\" function to get the fractional part of the y coordinate.\n    float t2 = fract(p.y);\n    \n    // The tube is a 3D function, so we can use the \"fract\" function to get the fractional part of the z coordinate.\n    float t3 = fract(p.z);\n    \n    // The tube is a 4D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t4 = fract(p.w);\n    \n    // The tube is a 5D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t5 = fract(p.w);\n    \n    // The tube is a 6D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t6 = fract(p.w);\n    \n    // The tube is a 7D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t7 = fract(p.w);\n    \n    // The tube is a 8D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t8 = fract(p.w);\n    \n    // The tube is a 9D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t9 = fract(p.w);\n    \n    // The tube is a 10D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t10 = fract(p.w);\n    \n    // The tube is a 11D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t1"}], [{"generated_text": "\n    float tubeWidth = 0.005;\n\n    // Tube height.\n    float tubeHeight = 0.005;\n\n    // Tube radius.\n    float tubeRadius = 0.005;\n\n    // Tube thickness.\n    float tubeThickness = 0.005;\n\n    // Tube offset.\n    float tubeOffset = 0.005;\n\n    // Tube offset.\n    float tubeOffset2 = 0.005;\n\n    // Tube offset.\n    float tubeOffset3 = 0.005;\n\n    // Tube offset.\n    float tubeOffset4 = 0.005;\n\n    // Tube offset.\n    float tubeOffset5 = 0.005;\n\n    // Tube offset.\n    float tubeOffset6 = 0.005;\n\n    // Tube offset.\n    float tubeOffset7 = 0.005;\n\n    // Tube offset.\n    float tubeOffset8 = 0.005;\n\n    // Tube offset.\n    float tubeOffset9 = 0.005;\n\n    // Tube offset.\n    float tubeOffset10 = 0.005;\n\n    // Tube offset.\n    float tubeOffset11 = 0.005;\n\n    // Tube offset.\n    float tubeOffset12 = 0.005;\n\n    // Tube offset.\n    float tubeOffset13 = 0.005;\n\n    // Tube offset.\n    float tubeOffset14 = 0.005;\n\n    // Tube offset.\n    float tubeOffset15 = 0.005;\n\n    // Tube offset.\n    float tubeOffset16 = 0.005;\n\n    // Tube offset.\n    float tubeOffset17 = 0.005;\n\n    // Tube offset.\n    float tubeOffset18 = 0.005;\n\n    // Tube offset.\n    float tubeOffset19 = 0.005;\n\n    // Tube offset.\n    float tubeOffset20 = 0.005;\n\n    // Tube offset"}], [{"generated_text": "\n    int gID_int = int(gID);\n    \n    // The cubic grid cell is a 3x3x3 cube.\n    // The grid cell is divided into 8 sub-cells.\n    // The sub-cells are divided into 8 sub-sub-cells.\n    // The sub-sub-cells are divided into 8 sub-sub-sub-cells.\n    // The sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub"}], [{"generated_text": "\n    float t = 0., tmin = 1e10;\n    \n    // Ray position\n    vec3 p = o;\n    \n    // Ray direction\n    vec3 d = r;\n    \n    // Ray step size\n    float dt = 0.001;\n    \n    // Ray step size\n    float dp = 0.001;\n    \n    // Ray step size\n    float ddt = 0.001;\n    \n    // Ray step size\n    float ddp = 0.001;\n    \n    // Ray step size\n    float dddt = 0.001;\n    \n    // Ray step size\n    float ddddp = 0.001;\n    \n    // Ray step size\n    float ddddt = 0.001;\n    \n    // Ray step size\n    float dddddp = 0.001;\n    \n    // Ray step size\n    float ddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddddddp = 0.001;\n"}], [{"generated_text": "\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm"}], [{"generated_text": "\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting"}], [{"generated_text": "\n    vec3 w = m * p3;\n    vec3 w2 = w * w;\n    vec3 w3 = w2 * w;\n    vec3 w4 = w3 * w;\n    vec3 w5 = w4 * w;\n    vec3 w6 = w5 * w;\n    vec3 w7 = w6 * w;\n    vec3 w8 = w7 * w;\n    vec3 w9 = w8 * w;\n    vec3 w10 = w9 * w;\n    vec3 w11 = w10 * w;\n    vec3 w12 = w11 * w;\n    vec3 w13 = w12 * w;\n    vec3 w14 = w13 * w;\n    vec3 w15 = w14 * w;\n    vec3 w16 = w15 * w;\n    vec3 w17 = w16 * w;\n    vec3 w18 = w17 * w;\n    vec3 w19 = w18 * w;\n    vec3 w20 = w19 * w;\n    vec3 w21 = w20 * w;\n    vec3 w22 = w21 * w;\n    vec3 w23 = w22 * w;\n    vec3 w24 = w23 * w;\n    vec3 w25 = w24 * w;\n    vec3 w26 = w25 * w;\n    vec3 w27 = w26 * w;\n    vec3 w28 = w27 * w;\n    vec3 w29 = w28 * w;\n    vec3 w30 = w29 * w;\n    vec3 w31 = w30 * w;\n    vec3 w32 = w31 * w;\n    vec3 w33 = w32 * w;\n    vec3 w34 = w33 * w;\n    vec3 w35 = w34 * w;\n    vec3 w36"}], [{"generated_text": "\n    vec4 hex1 = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 hex2 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints2 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints3 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints4 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints5 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints6 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints7 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some"}], [{"generated_text": "\n    return df_truchet(p, dir) +.1;\n}\n\n// This is the main function that does the actual rendering.\n// It's a bit of a mess, but it's basically a loop over all pixels,\n// and for each pixel, it calls the raytracing function to get the color.\n// The raytracing function is a bit more complicated than I'd like, but it's\n// basically just a raytracing function that takes a ray, and returns the color\n// of the ray.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system."}], [{"generated_text": "\n    float t = (q.x + q.y) * 0.5;\n    float r = (q.x - q.y) * 0.5;\n    \n    // Polar conversion.\n    float theta = atan2(r, t);\n    float phi = dir * theta;\n    \n    // Return the polar coordinates.\n    return vec2(phi, r);\n}\n\nvoid main()\n{\n    // Get the polar coordinates.\n    vec2 q = getPolarCoord(vUV, vDir);\n    \n    // Get the distance from the center.\n    float d = length(q);\n    \n    // Get the angle from the center.\n    float a = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a2 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a3 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a4 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a5 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a6 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a7 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a8 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a9 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a10 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a11 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a12 = atan(q.y, q.x);\n    \n    // Get the angle from the"}], [{"generated_text": "\n    vec3 w = p3 - n[0];\n    float d00 = dot(w, n[0]);\n    float d01 = dot(w, n[1]);\n    float d02 = dot(w, n[2]);\n    float d11 = dot(w, n[1] - n[0]);\n    float d22 = dot(w, n[2] - n[0]);\n    float d33 = dot(w, n[2] - n[1]);\n    float inv_denom = 1.0 / (d00 * d11 * d22 + d01 * d12 * d20 + d02 * d10 * d21 - d00 * d12 * d21 - d01 * d10 * d22 - d02 * d11 * d20);\n    vec3 v = vec3(\n        (d11 * d33 - d01 * d23) * inv_denom,\n        (d02 * d23 - d03 * d12) * inv_denom,\n        (d01 * d13 - d03 * d11) * inv_denom\n    );\n    return v;\n}\n\nvec"}], [{"generated_text": ".\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |p.w| and |r.w| >= |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |q.w| and |r.w| < |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |p.w| and |r.w| < |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |p.w| and |r.w| < |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |p."}], [{"generated_text": "\n    // The only difference is that the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n   "}], [{"generated_text": "\n\tfloat k00 = -0.25;\n\tfloat k10 =  0.25;\n\tfloat k01 = -0.25;\n\tfloat k11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat dk00 = -0.25;\n\tfloat dk10 =  0.25;\n\tfloat dk01 = -0.25;\n\tfloat dk11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat ddx0 = dk00 * ddx.x + dk10 * ddx.y;\n\tfloat ddx1 = dk01 * ddx.x + dk11 * ddx.y;\n\tfloat ddy0 = dk00 * ddy.x + dk10 * ddy.y;\n\tfloat ddy1 = dk01 * ddy.x + dk11 * ddy.y;\n\n\t// filter kernel derivatives\n\tfloat ddx2 = ddx0 * ddx0 + ddx1 * ddx1;\n\tfloat ddy2 = ddy0 * ddy0 + ddy1 * ddy1;\n\n\t// filter kernel derivatives\n\tfloat ddx3 = ddx2 * ddx2;\n\tfloat ddy3 = ddy2 * ddy2;\n\n\t// filter kernel derivatives\n\tfloat ddx4 = ddx3 * ddx3;\n\tfloat ddy4 = ddy3 * ddy3;\n\n\t// filter kernel derivatives\n\tfloat ddx5 = ddx4 * ddx4;\n\tfloat ddy5 = ddy4 * ddy4;\n\n\t// filter kernel derivatives\n\tfloat ddx6 = ddx5 * ddx5;\n\tfloat ddy6 = ddy5 * ddy5;\n\n\t// filter kernel derivatives\n\tfloat ddx7 = ddx6 * ddx6;\n\tfloat ddy7 = ddy6 * ddy6;\n\n\t// filter kernel derivatives\n\tfloat ddx8 = ddx7 * ddx7;\n\tfloat ddy8 = ddy7 * ddy7;\n\n\t// filter kernel derivatives\n\tfloat ddx9 = ddx8"}], [{"generated_text": "\n    vec2 p = floor( n );\n\n    // get the fractional part of the cell position\n    vec2 fp = fract( n );\n\n    // get the distance to the closest point\n    float d = distance( f, fp );\n\n    // get the distance to the farthest point\n    float d2 = distance( fp, vec2( 1.0 ) );\n\n    // get the distance to the closest point in the x direction\n    float dx = abs( fp.x - f.x );\n\n    // get the distance to the farthest point in the x direction\n    float dx2 = abs( fp.x - 1.0 );\n\n    // get the distance to the closest point in the y direction\n    float dy = abs( fp.y - f.y );\n\n    // get the distance to the farthest point in the y direction\n    float dy2 = abs( fp.y - 1.0 );\n\n    // get the distance to the closest point in the x direction\n    float dz = abs( fp.z - f.z );\n\n    // get the distance to the farthest point in the x direction\n    float dz2 = abs( fp.z - 1.0 );\n\n    // get the distance to the closest point in the y direction\n    float dw = abs( fp.w - f.w );\n\n    // get the distance to the farthest point in the y direction\n    float dw2 = abs( fp.w - 1.0 );\n\n    // get the distance to the closest point in the x direction\n    float dxy = abs( fp.xy - f.xy );\n\n    // get the distance to the farthest point in the x direction\n    float dxy2 = abs( fp.xy - vec2( 1.0 ) );\n\n    // get the distance to the closest point in the y direction\n    float dxyz = abs( fp.xyz - f.xyz );\n\n    // get the distance to the farthest point in the y direction\n    float dxyz2 = abs( fp.xyz - vec3( 1.0 ) );\n\n    // get the distance"}], [{"generated_text": "\n    return (1.0f - t) * p1 + t * p2;\n}\n\nvoid main()\n{\n    vec2 pos = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_2 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_3 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_4 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_5 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_6 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_7 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_8 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_9 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_10 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_11 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_12 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_13 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_14 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_15 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_16 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_17 ="}], [{"generated_text": "\n\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0"}], [{"generated_text": "\n\n    // This is a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's"}], [{"generated_text": "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n    \n    // Centroid.\n    vec2 cent = (p0 + p1 + p2) / 3.0;\n    \n    // Return.\n    return vec4(cent, alpha, beta, gamma);\n}\n\n// Compute the area of a triangle.\nfloat"}], [{"generated_text": "\n    float a = distance(p0, p1);\n    float b = distance(p1, p2);\n    float c = distance(p2, p0);\n\n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n\n    // Radii.\n    float r1 = a * sin(alpha);\n    float r2 = b * sin(beta);\n    float r3 = c * sin(gamma);\n\n    // Area.\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Circumference.\n    float c1 = r1 + r2 + r3;\n\n    // Return the area and circumference.\n    return vec2(area, c1);\n}\n\n// Returns the area and circumference of a triangle.\nvec"}], [{"generated_text": "\n   // Returns distance to paraboloid.\n   // h1, h2, h3 are the vertices of the triangle.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2"}], [{"generated_text": "\n    vec2 v0 = vec2(0.0, 0.0);\n    vec2 v1 = vec2(1.0, 0.0);\n    vec2 v2 = vec2(0.0, 1.0);\n    \n    vec2 v3 = vec2(0.0, 0.0);\n    vec2 v4 = vec2(1.0, 0.0);\n    vec2 v5 = vec2(0.0, 1.0);\n    \n    vec2 v6 = vec2(0.0, 0.0);\n    vec2 v7 = vec2(1.0, 0.0);\n    vec2 v8 = vec2(0.0, 1.0);\n    \n    vec2 v9 = vec2(0.0, 0.0);\n    vec2 v10 = vec2(1.0, 0.0);\n    vec2 v11 = vec2(0.0, 1.0);\n    \n    vec2 v12 = vec2(0.0, 0.0);\n    vec2 v13 = vec2(1.0, 0.0);\n    vec2 v14 = vec2(0.0, 1.0);\n    \n    vec2 v15 = vec2(0.0, 0.0);\n    vec2 v16 = vec2(1.0, 0.0);\n    vec2 v17 = vec2(0.0, 1.0);\n    \n    vec2 v18 = vec2(0.0, 0.0);\n    vec2 v19 = vec2(1.0, 0.0);\n    vec2 v20 = vec2(0.0, 1.0);\n    \n    vec2 v21 = vec2(0.0, 0.0);\n    vec2 v22 = vec2(1.0, 0.0);\n   "}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x *= iResolution.x / iResolution.y;\n\n    //get the color of the pixel\n    vec3 color = vec3(0.0);\n    vec2 p = uv;\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0"}], [{"generated_text": "\n    //return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This is the original method.\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat"}], [{"generated_text": "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n"}], [{"generated_text": "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n"}], [{"generated_text": "\n    // Return the hit point, normal, and color.\n    // If no hit, return black.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the"}], [{"generated_text": "\n    vec2 p01 = p0 - p1;\n    vec2 p12 = p1 - p2;\n    vec2 p20 = p2 - p0;\n\n    // midpoints\n    vec2 p012 = p01 + p12;\n    vec2 p120 = p12 + p20;\n    vec2 p201 = p20 + p01;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // distances to midpoints\n    float d012 = length(p012);\n    float d120 = length(p120);\n    float d201 = length(p201);\n\n    // distances to extremes\n    float d012_ = d012 / d01;\n    float d120_ = d120 / d12;\n    float d201_ = d201 / d20;\n\n    // distances to midpoints\n    float d012_1 = d012_ * d012_;\n    float d120_1 = d120_ * d120_;\n    float d201_1 = d201_ * d201_;\n\n    // distances to extremes\n    float d012_2 = d012_1 * d012_;\n    float d120_2 = d120_1 * d120_;\n    float d201_2 = d201_1 * d201_;\n\n    // distances to midpoints\n    float d012_3 = d012_2 * d012_;\n    float d120_3 = d120_2 * d120_;\n    float d201_3 = d201_2 * d201_;\n\n    // distances to midpoints\n    float d012_4 = d012_3 * d012"}], [{"generated_text": "\n    vec3 min = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 max = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 center = ( min + max ) * 0.5;\n\n    // radius\n    vec3 radius = max( abs( p0 - center ), abs( p1 - center ) );\n    radius = max( radius, abs( p2 - center ) );\n    radius = max( radius, abs( p3 - center ) );\n\n    return BezierAABB( center, radius );\n}\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\nBezierAABB BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6, in vec3 p7, in vec3 p8, in vec3 p9, in vec3 p10, in vec3 p11, in vec3 p12, in vec3 p13, in vec3 p14, in vec3 p15, in vec3 p16, in vec3 p17, in vec3 p18, in vec3 p19, in vec3 p20, in vec3 p21, in vec3 p22, in vec3 p23, in vec3 p24, in vec3 p25, in vec3 p26, in vec3 p27, in vec3 p28, in vec3 p29, in vec3 p30, in vec3 p31, in vec3 p32, in vec3 p33, in vec3 p34, in vec3 p35, in vec3 p36, in vec3 p37, in vec3 p38, in vec3 p39, in vec3 p40, in vec3 p41, in vec"}], [{"generated_text": "\n    const vec2 iResolution = vec2( 1280.0, 720.0 );\n    const float iTime = TIME;\n    const float iTimeDelta = TIME_DELTA;\n    const float iFrame = FRAME;\n    const float iFrameDelta = FRAME_DELTA;\n    const float iFrameCount = FRAME_COUNT;\n    const float iFrameCountDelta = FRAME_COUNT_DELTA;\n    const float iFrameCountMax = FRAME_COUNT_MAX;\n    const float iFrameCountMaxDelta = FRAME_COUNT_MAX_DELTA;\n    const float iFrameCountMaxMax = FRAME_COUNT_MAX_MAX;\n    const float iFrameCountMaxMaxDelta = FRAME_COUNT_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMaxMax = FR"}], [{"generated_text": "\n    return k * k * ( 3.0 - 2.0 * k ); // EaseInOut\n}\n\nfloat"}], [{"generated_text": "\n    vec2 F2 = vec2(1.0 / 3.0, 1.0 / 3.0) - v;\n\n    // Compute first coordinate\n    vec4 H = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute second coordinate\n    vec4 G = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute final noise\n    return mix(\n        mix(dot(H, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(H, vec2(2.0 / 3.0, 1.0 / 3.0)), step"}], [{"generated_text": "\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates ("}], [{"generated_text": "\n    coord -= vec2(0.5, 0.5);\n\n    // Scale the coordinate to the screen size.\n    coord *= res;\n\n    // Translate the coordinate to the center of the screen.\n    coord += vec2(0.5, 0.5);\n\n    return coord;\n}\n\nvec"}], [{"generated_text": "\n    vec2 f = vec2( 0.0 );\n    f.x = ( 1.0 - abs( p.x ) ) * 0.5;\n    f.y = ( 1.0 - abs( p.y ) ) * 0.5;\n    return f.x * f.y;\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y );\n    vec2 q = p;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tinc = 0.001;\n    float tinc2 = 0.0001;\n    float tinc3 = 0.00001;\n    float tinc4 = 0.000001;\n    float tinc5 = 0.0000001;\n    float tinc6 = 0.00000001;\n    float tinc7 = 0.000000001;\n    float tinc8 = 0.0000000001;\n    float tinc9 = 0.00000000001;\n    float tinc10 = 0.000000000001;\n    float tinc11 = 0.0000000000001;\n    float tinc12 = 0.00000000000001;\n    float tinc13 = 0.000000000000001;\n    float tinc14 = 0.0000000000000001;\n    float tinc15 = 0.00000000000000001;\n    float tinc16 = 0.000000000000000001;\n    float tinc1"}], [{"generated_text": "\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 rgb2hcv = rgb * 0.01f;\n    rgb2hcv = rgb2hcv * (1.0f / 12.92f) + vec3(0.055f);\n    rgb2hcv = pow(rgb2hcv, vec3(1.0f / 2.4f));\n    return rgb2hcv;\n}\n\nvec"}], [{"generated_text": "\n    //return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // Better, but doesn't disperse things quite as nicely.\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat"}], [{"generated_text": "\n    vec3 n = texture( iChannel0, p.yzx, 0.001 ).xyz;\n    n.xy *= 2.0;\n    return normalize( n - vec3( 0.5, 0.5, 0.5 ) );\n}\n\nvoid main()\n{\n    vec3 p = vec3( iResolution.xy * ( gl_FragCoord.xy / iResolution.xy ), 0.0 );\n    vec3 col = vec3( 0.0 );\n\n    vec3 ro = vec3( 0.0, 0.0, 0.0 );\n    vec3 ta = vec3( 0.0, 0.0, -1.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    float dist = length( ta - ro );\n    ta = normalize( ta - ro ) * dist;\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( ww, up ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n\n    vec3 rd = normalize( p.x * uu + p.y * vv + dist * ww );\n\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = normal( pos );\n        float h = texture( iChannel0, pos.yzx, 0.0 ).x;\n        float dif = max( 0.0, dot( nor, normalize( vec3( 0.0, 1.0, 0.0 ) ) ) );\n        float amb = max( 0.0, dot( nor, uv_light ) ) * 0.5 + 0.5;\n        float spe = pow( max( 0."}], [{"generated_text": "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\n// This is a simple hash function that is used to generate a random number.\n// It is not a good hash function, but it is good enough for our purposes.\n// You SHOULD replace this by something better. Again, Do Not Use in production.\nfloat"}], [{"generated_text": "\n    // width = 0.5 -> angle = PI\n    // width = 0.25 -> angle = PI/4\n    // width = 0.125 -> angle = PI/16\n    // width = 0.0625 -> angle = PI/32\n    // width = 0.03125 -> angle = PI/64\n    // width = 0.015625 -> angle = PI/128\n    // width = 0.0078125 -> angle = PI/256\n    // width = 0.00390625 -> angle = PI/512\n    // width = 0.001953125 -> angle = PI/1024\n    // width = 0.0009765625 -> angle = PI/2048\n    // width = 0.00048828125 -> angle = PI/4096\n    // width = 0.000244140625 -> angle = PI/8192\n    // width = 0.0001220703125 -> angle = PI/16384\n    // width = 0.00006103515625 -> angle = PI/32768\n    // width = 0.000030517578125 -> angle = PI/65536\n    // width = 0.0000152587890625 -> angle = PI/131072\n    // width = 0.00000762939453125 -> angle = PI/262144\n    // width = 0.000003814697265625 -> angle = PI/524288\n    // width = 0.000001907348632812"}], [{"generated_text": "\n    vec2 F2 = vec2(1.0 / 3.0, 1.0 / 3.0) - v;\n\n    // Compute first coordinate\n    vec4 H = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute second coordinate\n    vec4 G = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute final noise\n    return mix(\n        mix(dot(H, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(H, vec2(2.0 / 3.0, 1.0 / 3.0)), step"}], [{"generated_text": "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// get the color of the pixel\n\tvec4 color = texture(iChannel0, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color2 = texture(iChannel1, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color3 = texture(iChannel2, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color4 = texture(iChannel3, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color5 = texture(iChannel4, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color6 = texture(iChannel5, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color7 = texture(iChannel6, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color8 = texture(iChannel7, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color9 = texture(iChannel8, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color10 = texture(iChannel9, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color11 = texture(iChannel10, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color12 = texture(iChannel11, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color13 = texture(iChannel12, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color14 = texture(iChannel13, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color15 = texture(iChannel14, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color16 = texture(iChannel15, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color17 = texture(iChannel16, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color18 ="}], [{"generated_text": "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nfloat"}], [{"generated_text": " to the position\n\tvec3 q = log(p);\n\t\n\t// Compute the spherical coordinates\n\tfloat r = length(q);\n\tfloat theta = atan(q.y, q.x);\n\tfloat phi = atan(q.z, length(q.xy));\n\t\n\t// Compute the cartesian coordinates\n\tvec3 s = vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n\t\n\t// Compute the tangent and bitangent vectors\n\tvec3 t = normalize(cross(vec3(0.0, 1.0, 0.0), s));\n\tvec3 b = cross(s, t);\n\t\n\t// Compute the scale factor\n\tmul = exp(r);\n\t\n\t// Compute the texture coordinates\n\tsp = (q.xy + 1.0) * 0.5;\n\ttp = (q.z + 1.0) * 0.5;\n\trp = (q.xy + 1.0) * 0.5;\n\t\n\t// Compute the tangent space basis\n\tsp = sp * 2.0 - 1.0;\n\ttp = tp * 2.0 - 1.0;\n\trp = rp * 2.0 - 1.0;\n\t\n\t// Compute the tangent space basis\n\tsp = sp * mul;\n\ttp = tp * mul;\n\trp = rp * mul;\n}\n\n// Compute the normal at a given position\nvec"}], [{"generated_text": "\n    float y = sin(p.x) * cos(p.z);\n    float r = cos(p.x) * cos(p.z);\n    return vec2(length(p.xy - vec2(0.0, y)) - r, 0.0);\n}\n\nvec"}], [{"generated_text": "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec"}], [{"generated_text": "\n\tvec2 p1 = p + vec2(aaSize, 0.0);\n\tvec2 p2 = p + vec2(aaSize, aaSize);\n\tvec2 p3 = p + vec2(0.0, aaSize);\n\tvec2 p4 = p + vec2(0.0, 0.0);\n\tvec2 p5 = p + vec2(-aaSize, 0.0);\n\tvec2 p6 = p + vec2(-aaSize, aaSize);\n\tvec2 p7 = p + vec2(-aaSize, -aaSize);\n\tvec2 p8 = p + vec2(0.0, -aaSize);\n\tvec2 p9 = p + vec2(aaSize, -aaSize);\n\tvec2 p10 = p + vec2(aaSize, -aaSize);\n\tvec2 p11 = p + vec2(aaSize, 0.0);\n\tvec2 p12 = p + vec2(aaSize, aaSize);\n\tvec2 p13 = p + vec2(0.0, aaSize);\n\tvec2 p14 = p + vec2(0.0, 0.0);\n\tvec2 p15 = p + vec2(-aaSize, 0.0);\n\tvec2 p16 = p + vec2(-aaSize, aaSize);\n\tvec2 p17 = p + vec2(-aaSize, -aaSize);\n\tvec2 p18 = p + vec2(0.0, -aaSize);\n\tvec2 p19 = p + vec2(aaSize, -aaSize);\n\tvec2 p20 = p + vec2(aaSize, -aaSize);\n\tvec2 p21 = p + vec2(aaSize, 0.0);\n\tvec2 p22 = p + vec2(aaSize, aaSize);\n\tvec2 p23 = p + vec2(0.0, aaSize);\n\tvec2 p24 = p + vec2(0.0, 0.0);\n"}], [{"generated_text": "\n    mat4 rot = mat4(1.0);\n    rot = rotate(rot, 0.0f, vec3(0.0f, 1.0f, 0.0f));\n    rot = rotate(rot, 0.0f, vec3(1.0f, 0.0f, 0.0f));\n\n    // get a translation matrix for our box's position\n    mat4 trans = mat4(1.0);\n    trans = translate(trans, pos);\n\n    // get the box's vertices\n    vec3 vertices[] = {\n        vec3(0.0f, 0.0f, 0.0f),\n        vec3(1.0f, 0.0f, 0.0f),\n        vec3(1.0f, 1.0f, 0.0f),\n        vec3(0.0f, 1.0f, 0.0f)\n    };\n\n    // get the box's normals\n    vec3 normals[] = {\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f)\n    };\n\n    // get the box's texture coordinates\n    vec2 texCoords[] = {\n        vec2(0.0f, 0.0f),\n        vec2(1.0f, 0.0f),\n        vec2(1.0f, 1.0f),\n        vec2(0.0f, 1.0f)\n    };\n\n    // get the box's indices\n    int indices[] = {\n        0, 1, 2,\n        2, 3, 0\n    };\n\n    // get the box's vertices\n    vec3 boxVertices[] = {\n        vec3(0."}], [{"generated_text": "\n    float y = sin(pos.x) * 0.5 + 0.5;\n\n    // rotate the sphere around the x-axis\n    float x = pos.y * 0.5 + 0.5;\n\n    // rotate the sphere around the z-axis\n    float z = pos.z * 0.5 + 0.5;\n\n    return vec2(x, y);\n}\n\nvoid main() {\n\n    // get the position of the vertex\n    vec3 pos = position;\n\n    // get the position of the vertex in the sphere\n    vec2 spherePos = ourSphere(pos);\n\n    // get the position of the vertex in the cube\n    vec3 cubePos = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos2 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos3 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos4 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos5 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos6 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos7 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos8 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos9 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos10 = pos * 2.0 - 1.0;\n\n    // get"}], [{"generated_text": "\n    vec3 p = pos;\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 0.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 0.0);\n\n    // test our shapes\n    if (p.x < -1.0) {\n        p.x = -1.0;\n    }\n    if (p.x > 1.0) {\n        p.x = 1.0;\n    }\n    if (p.y < -1.0) {\n        p.y = -1.0;\n    }\n    if (p.y > 1.0) {\n        p.y = 1.0;\n    }\n    if (p.z < -1.0) {\n        p.z = -1.0;\n    }\n    if (p.z > 1.0) {\n        p.z = 1.0;\n    }\n\n    // test our shapes\n    if (q.x < -1.0) {\n        q.x = -1.0;\n    }\n    if (q.x > 1.0) {\n        q.x = 1.0;\n    }\n    if (q.y < -1.0) {\n        q.y = -1."}], [{"generated_text": "\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // march along the ray until we hit something\n    vec3 rayPos = camPos;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = rayPos + rayDir * t;\n        float d = scene(p);\n        if (d < 0.001) {\n            break;\n        }\n        t += d;\n    }\n    \n    // calculate the color at the point of intersection\n    vec3 color = vec3(0.0);\n    if (t < 100.0) {\n        vec3 p = rayPos + rayDir * t;\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    return color;\n}\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 color = marchScene(fragCoord, camPos, camDir, lightDir);\n    gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n\tvec3 bmin = rad - ro;\n\tvec3 bmax = rad + ro;\n\tvec3 tmin = (bmin - rd) / rd;\n\tvec3 tmax = (bmax - rd) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat t = max(t0, t3);\n\tif (t < 0.0) return vec2(-1.0);\n\treturn vec2(t, t0);\n}\n\n// ray-sphere intersection\nvec"}], [{"generated_text": "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// sample the texture\n\tvec4 texColor = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor2 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor3 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor4 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor5 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor6 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor7 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor8 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor9 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor10 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor11 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor12 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor13 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor14 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor15 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor16 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor17 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor18 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor19 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec"}], [{"generated_text": "\n    return dot(plane.normal, pos - plane.position) / dot(plane.normal, plane.normal);\n}\n\nfloat"}], [{"generated_text": "Density = 0.0001;\n    // float n = perlin(ix, fx);\n    // return n;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return "}], [{"generated_text": "\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors"}], [{"generated_text": "\n    float s = p.y - h;\n    float d = length(p.xz) - r;\n    return max(s, d);\n}\n\nfloat"}], [{"generated_text": "\n     p.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5"}], [{"generated_text": "\n  // eps.yxy <=> vec3(0.  , 0.001, 0.   )\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n "}], [{"generated_text": "\n                                      //      v\n                                      //     /\n                                      //    /\n                                      //   /\n                                      //  /\n                                      // /\n                                      ///\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                     "}], [{"generated_text": "\n    vec3 b = rd * ra - ro;\n    vec3 c = b * b - vec3( 1.0 );\n    vec3 d = sqrt( c );\n    vec3 t = -b - d;\n    vec3 t1 = -b + d;\n    float t0 = max( t.x, max( t.y, t.z ) );\n    float t1 = min( t.x, min( t.y, t.z ) );\n    float t2 = max( t1.x, t1.y );\n    float t3 = min( t1.x, t1.y );\n    float t4 = max( t2, t3 );\n    float t5 = min( t2, t3 );\n    float t6 = max( t4, t5 );\n    float t7 = min( t4, t5 );\n    float t8 = max( t6, t7 );\n    float t9 = min( t6, t7 );\n    float t10 = max( t8, t9 );\n    float t11 = min( t8, t9 );\n    float t12 = max( t10, t11 );\n    float t13 = min( t10, t11 );\n    float t14 = max( t12, t13 );\n    float t15 = min( t12, t13 );\n    float t16 = max( t14, t15 );\n    float t17 = min( t14, t15 );\n    float t18 = max( t16, t17 );\n    float t19 = min( t16, t17 );\n    float t20 = max( t18, t19 );\n    float t21 = min( t18, t19 );\n    float t22 = max( t20, t21 );\n    float t23 = min( t20, t21 );\n    float t24 = max( t22, t23 );\n    float t25 = min( t22, t23 );\n    float t26 ="}], [{"generated_text": "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat"}], [{"generated_text": "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -1.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 1.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 1.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -1.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].center.x = 0.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = -1.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].center.x = 0.0;\n    Sphere[6].center.y = 0.0;\n    Sphere"}], [{"generated_text": "\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n"}], [{"generated_text": "\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n"}], [{"generated_text": "\n    // Return the hit point, normal, and color.\n    // If no hit, return black.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the"}], [{"generated_text": "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // clamp intersection times\n    tmin = max( tmin, 0.0 );\n    tmax = min( tmax, tmax.x );\n\n    // ray-sphere intersection\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - 1.0;\n    float h = b*b - c;\n    if( h < 0.0 ) return 0.0;\n    h = sqrt( h );\n    float t = -b - h;\n    if( t < tmin.x ) t = -b + h;\n    if( t > tmax.x ) return 0.0;\n\n    // shadow\n    float shadow = 0.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float ht = t + float( i ) * 0.1;\n        vec3 p = ro + ht * rd;\n        float d = texture( shadowMap, p.xy ).x;\n        shadow += max( 0.0, ht - d );\n    }\n    shadow /= 10.0;\n\n    // soft shadow\n    float attenuation = 1.0 - exp( -shadow * 0.001 );\n    return attenuation;\n}\n\nvoid main()\n{\n    // camera\n    vec3 ro = vec3( 0.0, 0.0, 10.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n"}], [{"generated_text": "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0f - c;\n\n    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec"}], [{"generated_text": "\n    vec3 offset = vec3(0.0, 0.0, 0.0);\n    offset.x = planet_position.x - start.x;\n    offset.y = planet_position.y - start.y;\n    offset.z = planet_position.z - start.z;\n\n    // the rayleigh scattering\n    vec3 rayleigh_scat = vec3(0.0, 0.0, 0.0);\n\n    // the mie scattering\n    vec3 mie_scat = vec3(0.0, 0.0, 0.0);\n\n    // the absorption\n    vec3 absorption = vec3(0.0, 0.0, 0.0);\n\n    // the ambient\n    vec3 ambient = vec3(0.0, 0.0, 0.0);\n\n    // the color of the ray\n    vec3 ray_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the atmosphere\n    vec3 atmo_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the planet\n    vec3 planet_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the sun\n    vec3 sun_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the background\n    vec3 background_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the sky\n    vec3 sky_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the moon\n    vec3 moon_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the moon\n    ve"}], [{"generated_text": "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // calculate the cosine of the angle between the surface normal and the light direction\n    float cos_theta = dot(surface_normal, light_dir_bend);\n\n    // calculate the cosine of the angle between the surface normal and the view direction\n    float cos_alpha = dot(surface_normal, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_beta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_gamma = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_delta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_epsilon = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_zeta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_prime = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_double = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_triple = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_quadruple = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction"}], [{"generated_text": "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 ray_dir = normalize(dir);\n    \n    // the ray origin\n    vec3 ray_origin = pos;\n    \n    // the ray origin\n    vec3 light_origin = vec3(0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 light_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // get the ray direction\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(p.xy, 2.0));\n    \n    // get the raymarching parameters\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tinc = 0.001;\n    float tdec = 0.001;\n    float tmin_inc = 0.001;\n    float tmin_dec = 0.001;\n    float tmax_inc = 0.001;\n    float tmax_dec = 0.001;\n    float tmin_inc_dec = 0.001;\n    float tmax_inc_dec = 0.001;\n    float tmin_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec = 0.001;\n    float tmax_inc_dec_inc_dec = 0.001;\n    float tmin_inc_dec_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec = 0.001;\n    float tmax_inc_dec_inc_dec_inc_dec = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc_dec_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec_inc_"}], [{"generated_text": "\n\n    // Compute a\n    vec3 a = r0 - s0;\n\n    // Compute b\n    float b = dot(a, rd);\n\n    // Compute c\n    float c = dot(a, a) - sr * sr;\n\n    // Compute discriminant\n    float discriminant = b * b - c;\n\n    // If discriminant is negative, there are no real roots, so return -1.0\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n\n    // Compute the square root of the discriminant\n    float sqrtDiscriminant = sqrt(discriminant);\n\n    // Compute the smaller and larger root\n    float root1 = -b - sqrtDiscriminant;\n    float root2 = -b + sqrtDiscriminant;\n\n    // If root1 is negative, use root2 instead\n    if (root1 < 0.0) {\n        root1 = root2;\n    }\n\n    // Return the smaller root\n    return root1;\n}\n\n// Compute the intersection point of a ray and a sphere\nvec"}], [{"generated_text": "ialize variables\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAmbient = vec3(0.0);\n    vec3 lightDiffuse = vec3(0.0);\n    vec3 lightSpecular = vec3(0.0);\n    vec3 lightSpotDir = vec3(0.0);\n    vec3 lightSpotColor = vec3(0.0);\n    vec3 lightSpotIntensity = vec3(0.0);\n    vec3 lightSpotAttenuation = vec3(0.0);\n    vec3 lightSpotAmbient = vec3(0.0);\n    vec3 lightSpotDiffuse = vec3(0.0);\n    vec3 lightSpotSpecular = vec3(0.0);\n    vec3 lightSpotSpotDir = vec3(0.0);\n    vec3 lightSpotSpotColor = vec3(0.0);\n    vec3 lightSpotSpotIntensity = vec3(0.0);\n    vec3 lightSpotSpotAttenuation = vec3(0.0);\n    vec3 lightSpotSpotAmbient = vec3(0.0);\n    vec3 lightSpotSpotDiffuse = vec3(0.0);\n    vec3 lightSpotSpotSpecular = vec3(0.0);\n    vec3 lightSpotSpotSpotDir = vec3(0.0);\n    vec3 lightSpotSpotSpotColor = vec3(0.0);\n    vec3 lightSpotSpotSpotIntensity = vec3(0.0);\n    vec3 lightSpotSpotSpotAttenuation ="}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"}], [{"generated_text": " ray\n    ray_queue.push_back(ray_origin);\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to"}], [{"generated_text": "\n    vec2 cell = floor(p);\n    vec2 f = fract(p);\n    \n    // Local cell coordinates.\n    vec2 c = cell;\n    \n    // Local cell ID.\n    float cellID = cell.x + cell.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c2 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID2 = c2.x + c2.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c3 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID3 = c3.x + c3.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c4 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID4 = c4.x + c4.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c5 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID5 = c5.x + c5.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c6 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID6 = c6.x + c6.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c7 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID7 = c7.x + c7.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c8 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID8 = c8.x + c8.y * 57.0;\n    "}], [{"generated_text": "\n    vec3 sphere_center = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance from sphere center\n    float dist = length(p - sphere_center) - sphere_radius;\n\n    return dist;\n}\n\n// calculate the color of the sphere\nvec"}], [{"generated_text": "\n    vec3 Pi = floor( P );\n    vec3 Pf = P - Pi;\n\n    // establish our 4 corners of the grid cell\n    vec3 P0 = Pi;\n    vec3 P1 = Pi + vec3( 1.0 );\n    vec3 P2 = Pi + vec3( 1.0, 1.0 );\n    vec3 P3 = Pi + vec3( 1.0, 1.0, 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P000 = P0;\n    vec3 P100 = P1;\n    vec3 P010 = P2;\n    vec3 P110 = P3;\n\n    // establish our 4 values of the corners\n    vec3 P001 = P0 + vec3( 1.0 );\n    vec3 P101 = P1 + vec3( 1.0 );\n    vec3 P011 = P2 + vec3( 1.0 );\n    vec3 P111 = P3 + vec3( 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P002 = P0 + vec3( 1.0, 1.0 );\n    vec3 P102 = P1 + vec3( 1.0, 1.0 );\n    vec3 P012 = P2 + vec3( 1.0, 1.0 );\n    vec3 P112 = P3 + vec3( 1.0, 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P003 = P0 + vec3( 1.0, 1.0, 1.0 );\n    vec3 P103 = P1 + vec3( 1.0, 1.0, 1.0 );\n    vec3 P013 = P2 + vec3( 1.0, 1.0, 1.0 );\n   "}], [{"generated_text": "\n    float t = x * 10.0;\n    float s = sin(t);\n    float r = cos(t);\n    float b = sin(t*2.0);\n    float g = cos(t*2.0);\n    float a = sin(t*3.0);\n    float n = cos(t*3.0);\n    \n    // return\n    return (s+r+b+g+a+n)/6.0;\n}\n\nfloat"}], [{"generated_text": "\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float t = (x + y + z) / 3.0;\n    float ground = (sin(t) + 1.0) / 2.0;\n    p.y -= ground;\n\n    // water\n    t = (x + y + z) / 3.0;\n    float water = (sin(t) + 1.0) / 2.0;\n    p.y += water;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // snow\n    t = (x + y + z) / 3.0;\n    float snow = (sin(t) + 1.0) / 2.0;\n    p.y += snow;\n\n    // rock\n    t = (x + y + z) / 3.0;\n    float rock = (sin(t) + 1.0) / 2.0;\n    p.y += rock;\n\n    // sand\n    t = (x + y + z) / 3.0;\n    float sand = (sin(t) + 1.0) / 2.0;\n    p.y += sand;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin"}], [{"generated_text": " space to screen space\n    vec2 p2 = (p.xy / p.z) * 0.5 + 0.5;\n    // map to [-1, 1]\n    p2 = p2 * 2.0 - 1.0;\n    // map to [-0.5, 0.5]\n    p2 = p2 * 0.5 + 0.5;\n    return p2;\n}\n\nvoid main()\n{\n    vec2 p = map(gl_FragCoord.xy);\n    vec2 q = map(gl_FragCoord.xy + vec2(0.0, 1.0));\n    vec2 r = map(gl_FragCoord.xy + vec2(1.0, 0.0));\n    vec2 s = map(gl_FragCoord.xy + vec2(0.0, -1.0));\n    vec2 t = map(gl_FragCoord.xy + vec2(-1.0, 0.0));\n\n    vec2 d = fwidth(p);\n    vec2 e = fwidth(q);\n    vec2 f = fwidth(r);\n    vec2 g = fwidth(s);\n    vec2 h = fwidth(t);\n\n    vec2 i = smoothstep(d, d + e, p);\n    vec2 j = smoothstep(f, f + g, q);\n    vec2 k = smoothstep(h, h + i, r);\n    vec2 l = smoothstep(j, j + k, s);\n    vec2 m = smoothstep(l, l + m, t);\n\n    float n = max(max(m.x, m.y), max(l.x, l.y));\n    gl_FragColor = vec4(n);\n}\n"}], [{"generated_text": " from a to b\n    float t = (p.x - a.x) / (b.x - a.x);\n    if (t < 0.0) return 0.0;\n    if (t > 1.0) return 0.0;\n    float y = a.y + t * (b.y - a.y);\n    if (y < pix) return 0.0;\n    if (y > d - pix) return 0.0;\n    return 1.0;\n}\n\nfloat"}], [{"generated_text": "\n\t//st.x *= iResolution.x/iResolution.y;\n\tvec2 st = fragCoord/iResolution.xy;\n\tst.x *= iResolution.x/iResolution.y;\n\tvec2 p = st;\n\tfloat t = iGlobalTime;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat"}], [{"generated_text": "\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat bottom and pointed bottom hexagons.\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat left and pointed left hexagons.\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    \n    // Flat right and pointed right hexagons.\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat center and pointed center hexagons.\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat center and pointed center hexagons.\n    if(p.x < "}], [{"generated_text": "\n    return (sin(ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n}\n\nfloat"}], [{"generated_text": "\n    vec3 p2 = rotate( p, vec3( 0.0, 0.0, 0.0 ) );\n\n    // map the solution space to the unit sphere\n    vec3 p3 = p2 / length( p2 );\n\n    // map the solution space to the unit cube\n    vec3 p4 = p3 * 0.5 + 0.5;\n\n    // map the solution space to the unit cube\n    vec3 p5 = p4 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p6 = p5 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p7 = p6 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p8 = p7 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p9 = p8 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p10 = p9 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p11 = p10 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p12 = p11 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p13 = p12 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p14 = p13 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p15 = p14 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p16 = p15 * 2.0 - 1."}], [{"generated_text": "\n    return (p - 0.5) * 2.0;\n}\n\nfloat"}], [{"generated_text": "\n    return vec2(atan2(z.y,z.x),length(z));\n}\n\nvec"}], [{"generated_text": "\n    return (vec2){z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x};\n}\n\nvec"}], [{"generated_text": "\n\t vec3 s = p - vec3(floor(p));\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, and 1.0 - x */\n\t vec3 i1 = step(vec3(0.0), x);\n\t vec3 i2 = step(vec3(1.0), x);\n\t vec3 x3 = 1.0 - x;\n\t \n\t /* calculate T and four vertices of T */\n\t vec4 T = vec4(s, i1.x) + vec4(s, i2.x) + vec4(s, 1.0, i1.y) + vec4(s, 1.0, i2.y);\n\t vec3 v0 = vec3(T) / 4.0;\n\t vec3 v1 = v0 + vec3(i1.xyy, 0.0);\n\t vec3 v2 = v0 + vec3(i2.xyy, 0.0);\n\t vec3 v3 = v0 + vec3(1.0, i1.xyy);\n\t \n\t /* calculate w, the barycentric coordinates of p relative to T */\n\t vec3 w = x3 * (x3 * (x3 * v0) + i1.z * (x2 * v1 + x * v2)) + i2.z * (x3 * v3 + x * v0);\n\t \n\t /* return the dot product of w and n */\n\t return dot(w, vec3(0.57735026918962576450914878050195745564887086954052300113832952210791614262294101264442748062243388305015030054794086342643848110487108"}], [{"generated_text": " wave\n    float wave = sin( p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z *"}], [{"generated_text": " in the final image\n    p.xz *= 0.5;\n    p.y *= 0.5;\n\n    // rotate the space\n    p = rotate( p, 0.01 );\n\n    // scale the space\n    p *= 0.5;\n\n    // add some noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0"}], [{"generated_text": "\n    //float k = floor(rp.y*.75)*.25;\n    //float k = floor(rp.z*.75)*.25;\n    //return k;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;"}], [{"generated_text": "\n\tfloat t = (end - d) / (end - start);\n\treturn clamp(t, 0.0, 1.0);\n}\n\n// \u30b9\u30af\u30ea\u30fc\u30f3\u5ea7\u6a19\u304b\u3089\u30ef\u30fc\u30eb\u30c9\u5ea7\u6a19\u306b\u5909\u63db\u3059\u308b\u3002\nvec"}], [{"generated_text": "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon center is the point that is closest to the current point.\n    if (p.x < p.y)\n    {\n        hex = vec4(p.x, p.y, 0.0, 0.0);\n    }\n    else\n    {\n        hex = vec4(p.y, p.x, 0.0, 1.0);\n    }\n    \n    // The hexagon center is unique, so we can use it to index into the hexagon array.\n    return hex;\n}\n\n// This function returns the hexagon center that is closest to the current point.\nvec"}], [{"generated_text": "\n    float x = fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n    float y = fract(sin(dot(p,vec2(269.5,183.3)))*23325.4236);\n    \n    // Four by four cell random value.\n    x += fract(sin(dot(p,vec2(113.1,325.4)))*43758.5453);\n    y += fract(sin(dot(p,vec2(271.5,181.3)))*23325.4236);\n    \n    // Eight by eight cell random value.\n    x += fract(sin(dot(p,vec2(137.1,321.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(281.5,189.3)))*23325.4236);\n    \n    // Sixteen by sixteen cell random value.\n    x += fract(sin(dot(p,vec2(117.1,311.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(269.5,183.3)))*23325.4236);\n    \n    // Thirty-two by thirty-two cell random value.\n    x += fract(sin(dot(p,vec2(137.1,321.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(281.5,189.3)))*23325.4236);\n    \n    // Sixty-four by sixty-four cell random value.\n    x += fract(sin(dot(p,vec2(117.1,311.7)))*43758.5453);\n    y += fract(sin("}], [{"generated_text": "\n    float scale = (mouse.x - 0.5) / 0.5;\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    else if (scale < 0.0) {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color2 = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color2 = vec3(0.0, 0.0, 1.0);\n    }\n    else if (scale < 0.0) {\n        color2 = vec3(0.0, 0.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color3 = vec3(0.0, 1.0, 1.0);\n    }\n    else if (scale < 0.0) {\n        color3 = vec3(0.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse"}], [{"generated_text": " from the center\n    //of the spiral\n    float theta = acos(a/b);\n    \n    //Solve for the polar coordinate (r, theta)\n    //of the point pc\n    vec2 pcPolar = vec2(length(pc), theta);\n    \n    //Check if the point pc is on the spiral\n    if(pcPolar.x <= a && pcPolar.y <= b){\n        return 1.0;\n    }\n    else{\n        return 0.0;\n    }\n}\n\n//Check if the point pc is on the spiral\n//(a,b) = (a+b*theta, theta)\n//where theta is the angle between the x-axis and the\n//line from the center of the spiral to the point pc\nfloat"}], [{"generated_text": "\n    return smoothstep(0.0, 1.0, pct);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float pct = plot(st, u_time);\n    color = mix(vec3(0.0), vec3(1.0), pct);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n    //\n    // I'm not going to go into the details of the math here, but I'll say that\n    // the following is the formula for the distance from the center of the \n    // initial circle to the center of the circle that runs adjacent to the \n    // current domain edges.\n    //\n    // d = (r * sin(theta)) / sin(theta + pi/2)\n    //\n    // The following is the formula for the radius of the initial circle.\n    //\n    // r = (1 - cos(theta)) / sin(theta + pi/2)\n    //\n    // The following is the formula for the angle theta.\n    //\n    // theta = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2."}], [{"generated_text": "\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't"}], [{"generated_text": "\n    vec2 mouse = vec2(mousePos.x, mousePos.y);\n    \n    // Mouse inversion.\n    vec2 mouseInversion = (p - mouse) * -1.0;\n    \n    // Return mouse inversion.\n    return mouseInversion;\n}\n\n// Mouse inversion.\nvec"}], [{"generated_text": "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 ="}], [{"generated_text": "\n\tvec3 cameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraRight = vec3(1.0, 0.0, 0.0);\n\tfloat cameraFov = 45.0;\n\tfloat cameraNear = 0.1;\n\tfloat cameraFar = 100.0;\n\n\t// Light Orientation\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 lightUp = vec3(0.0, 1.0, 0.0);\n\tvec3 lightRight = vec3(1.0, 0.0, 0.0);\n\tfloat lightFov = 45.0;\n\tfloat lightNear = 0.1;\n\tfloat lightFar = 100.0;\n\n\t// Lighting\n\tvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\tvec3 lightAmbient = vec3(0.1, 0.1, 0.1);\n\tvec3 lightDiffuse = vec3(0.5, 0.5, 0.5);\n\tvec3 lightSpecular = vec3(0.5, 0.5, 0.5);\n\tfloat lightShininess = 10.0;\n\n\t// Material\n\tvec3 materialAmbient = vec3(0.1, 0.1, 0.1);\n\tvec3 materialDiffuse = vec3(0.5, 0.5, 0.5);\n\tvec3 materialSpecular = vec3(0.5, 0.5, 0.5);\n\tfloat materialShininess = 10.0;\n\n\t// Texture\n\tvec3 textureColor = vec3(0"}], [{"generated_text": "\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position"}], [{"generated_text": " axis\n    float x = (hash - 0.5) * 2.0;\n    float y = (hash - 0.5) * 2.0;\n    float z = (hash - 0.5) * 2.0;\n    \n    // Random gradient of a cube, +/- 1 each axis\n    float gx = (hash - 0.5) * 2.0;\n    float gy = (hash - 0.5) * 2.0;\n    float gz = (hash - 0.5) * 2.0;\n    \n    // Return the gradient\n    return vec3(gx, gy, gz);\n}\n\n// Compute the dot product of a normal and a gradient\nfloat"}], [{"generated_text": "\n    vec3 Y = normalize(cross(X, vec3(0.0, 1.0, 0.0)));\n    vec3 Z = cross(Y, X);\n    \n    // Rotation matrix.\n    mat3 rot = mat3(\n        Y,\n        Z,\n        X\n    );\n    \n    // Skew transform.\n    mat3 skew = mat3(\n        0.0, 1.0, 0.0,\n        -1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot = skew * rot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot2 = skewRot * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot3 = skewRot2 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot4 = skewRot3 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot5 = skewRot4 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot6 = skewRot5 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot7 = skewRot6 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot8 = skewRot7 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot9 = skewRot8 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot10 = skewRot9 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot11 = skewRot10 * skewRot;\n    \n   "}], [{"generated_text": "\n  float d = p.y;\n  // distance from the point `p` to the center of the Y plane\n  float d2 = p.x * p.x + p.z * p.z;\n  // distance from the point `p` to the center of the Y plane\n  float d3 = p.y * p.y;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = p.x * p.x + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d5 = p.x * p.x + p.y * p.y;\n  // distance from the point `p` to the center of the XZ plane\n  float d6 = p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d8 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d9 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d11 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d12 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d"}], [{"generated_text": "\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub41c\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub41c\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ufffd"}], [{"generated_text": "\n\tmat2 rot = mat2(cos(time), -sin(time), sin(time), cos(time));\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv = rot * uv;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat d = length(uv);\n\t\n\tfloat a = atan(uv.y, uv.x);\n\t\n\tfloat r = (d - 0.5) * 2.0;\n\t\n\tfloat t = time * 0.5;\n\t\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\t\n\tfloat x = r * c;\n\tfloat y = r * s;\n\t\n\tfloat x2 = x * x;\n\tfloat y2 = y * y;\n\t\n\tfloat x3 = x2 * x;\n\tfloat y3 = y2 * y;\n\t\n\tfloat x4 = x3 * x;\n\tfloat y4 = y3 * y;\n\t\n\tfloat x5 = x4 * x;\n\tfloat y5 = y4 * y;\n\t\n\tfloat x6 = x5 * x;\n\tfloat y6 = y5 * y;\n\t\n\tfloat x7 = x6 * x;\n\tfloat y7 = y6 * y;\n\t\n\tfloat x8 = x7 * x;\n\tfloat y8 = y7 * y;\n\t\n\tfloat x9 = x8 * x;\n\tfloat y9 = y8 * y;\n\t\n\tfloat x10 = x9 * x;\n\tfloat y10 = y9 * y;\n\t\n\tfloat x11 = x10 * x;\n\tfloat y11 = y10 * y;\n\t\n\tfloat x12 = x11 * x;\n\tfloat y12 = y11 * y;\n\t\n\tfloat x13 = x12 * x;\n\tfloat y13 = y12 * y;\n\t\n\tfloat x"}], [{"generated_text": "-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos"}], [{"generated_text": "\n    vec3 lightPos = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 lightDir = normalize( lightPos - targetPos );\n    vec3 viewDir = normalize( ray.origin - targetPos );\n    vec3 halfDir = normalize( lightDir + viewDir );\n    \n    float NdotL = max( 0.0f, dot( lightDir, halfDir ) );\n    float NdotV = max( 0.0f, dot( lightDir, viewDir ) );\n    float NdotH = max( 0.0f, dot( lightDir, normalize( vec3( 0.0f, 1.0f, 0.0f ) ) ) );\n    \n    float NdotH2 = NdotH * NdotH;\n    float NdotH4 = NdotH2 * NdotH2;\n    float NdotH6 = NdotH4 * NdotH2;\n    float NdotH8 = NdotH6 * NdotH2;\n    \n    float NdotH10 = NdotH8 * NdotH2;\n    float NdotH12 = NdotH10 * NdotH2;\n    float NdotH14 = NdotH12 * NdotH2;\n    float NdotH16 = NdotH14 * NdotH2;\n    \n    float NdotH18 = NdotH16 * NdotH2;\n    float NdotH20 = NdotH18 * NdotH2;\n    float NdotH22 = NdotH20 * NdotH2;\n    float NdotH24 = NdotH22 * NdotH2;\n    \n    float NdotH26 = NdotH24 * NdotH2;\n    float NdotH28 = NdotH26 * NdotH2;\n    float NdotH30 = NdotH28 * NdotH2;\n    float NdotH32 = NdotH30 * NdotH2;\n    \n    float NdotH34 = NdotH3"}], [{"generated_text": "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / "}], [{"generated_text": "\n    float t = x * PI;\n    float s = sin(t);\n    float c = cos(t);\n    float r = fract(x);\n\n    // first octave\n    r = r * (1.0 + s * 0.5);\n\n    // second octave\n    r = r * (1.0 + s * 0.25);\n\n    // third octave\n    r = r * (1.0 + s * 0.125);\n\n    // fourth octave\n    r = r * (1.0 + s * 0.0625);\n\n    // fifth octave\n    r = r * (1.0 + s * 0.03125);\n\n    // sixth octave\n    r = r * (1.0 + s * 0.015625);\n\n    // seventh octave\n    r = r * (1.0 + s * 0.0078125);\n\n    // eighth octave\n    r = r * (1.0 + s * 0.00390625);\n\n    // ninth octave\n    r = r * (1.0 + s * 0.001953125);\n\n    // tenth octave\n    r = r * (1.0 + s * 0.0009765625);\n\n    // finaly\n    return r;\n}\n\nfloat"}], [{"generated_text": " to find the area of the triangle\n    float area = abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_uv = abs(uv.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p1 = abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p2 = abs(p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y) + p1.x * (p2.y - p3.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p3 = abs(p3.x * (p1.y - p2.y) + p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y)) / 2.0;\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_uv){\n        \n        //Return true\n        return true;\n    }\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_p1){\n        \n        //Return true\n        return true;\n    }\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_p2){\n        \n        //Return true\n        return true;\n    }\n    "}], [{"generated_text": "\n    float n = log(start_radius) / log(1.5);\n    \n    //Find the closest hexagon to the given uv\n    //https://math.stackexchange.com/a/1001000\n    float closest_hex_radius = pow(1.5, n);\n    float closest_hex_angle = atan2(uv.y, uv.x) + (2.0 * M_PI) / 6.0;\n    vec2 closest_hex_uv = vec2(closest_hex_radius * cos(closest_hex_angle), closest_hex_radius * sin(closest_hex_angle));\n    \n    return closest_hex_uv;\n}\n\n//https://www.shadertoy.com/view/4djSRW\nvec"}], [{"generated_text": ".\n    //\n    //The rotation of the hexagon is determined by the\n    //rotation of the equilateral.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hex"}], [{"generated_text": ".\n    //\n    //The circumradius of the isosceles is the distance\n    //between the two points of the isosceles.\n    //\n    //The rotation of the isosceles is the angle between\n    //the two points of the isosceles.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that"}], [{"generated_text": "\n    return exp(-d*d*U.x*U.x - d*d*U.y*U.y);\n}\n\nfloat"}], [{"generated_text": "'s implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 72) ^ (n >> 27);\n    n = n + (n << 3);\n    n = n ^ (n >> 11);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 150) ^ (n >> 10);\n    n = n + (n << 3);\n    n = n ^ (n >> 21);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 28) ^ (n >> 8);\n    n = n + (n << 3);\n    n = n ^ (n >> 14);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 18);\n    return n;\n}\n\nuint hash5(uint n)\n{"}], [{"generated_text": "\n    vec2 center = vec2(0.5);\n    // distance from center\n    vec2 dist = fragCoord - center;\n    // distance from center squared\n    float distSq = dot(dist, dist);\n    // distance from center cubed\n    float distCubed = dot(dist, distSq);\n    // distance from center cubed squared\n    float distCubedSq = dot(dist, distCubed);\n    // distance from center cubed cubed\n    float distCubedCubed = dot(dist, distCubedSq);\n    // distance from center cubed cubed squared\n    float distCubedCubedSq = dot(dist, distCubedCubed);\n    // distance from center cubed cubed cubed\n    float distCubedCubedCubed = dot(dist, distCubedCubedSq);\n    // distance from center cubed cubed cubed squared\n    float distCubedCubedCubedSq = dot(dist, distCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed\n    float distCubedCubedCubedCubed = dot(dist, distCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed\n    float distCubedCubedCubedCubedCubed = dot(dist, distCubedCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed cubed\n    float distCubedCubedCubedC"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"}], [{"generated_text": " to avoid division by zero\n  vec3 epsilon = vec3(0.0001, 0.0001, 0.0001);\n  return normalize(\n      vec3(\n          f(pos + epsilon.xyy) - f(pos - epsilon.xyy),\n          f(pos + epsilon.yxy) - f(pos - epsilon.yxy),\n          f(pos + epsilon.yyx) - f(pos - epsilon.yyx)));\n}\n\nvoid main() {\n  vec3 pos = (gl_FragCoord.xyz / resolution.xyz) * 2.0 - 1.0;\n  vec3 dir = normalize(pos);\n  vec3 color = vec3(0.0);\n  float t = 0.0;\n  for (int i = 0; i < 100; i++) {\n    t += f(pos) * 0.5;\n    pos += dir * f(pos) * 0.5;\n  }\n  color = vec3(t);\n  gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n  vec3 p = ro;\n  float t = 0.0;\n  float tmin = 0.001;\n  float tmax = 1000.0;\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = p;\n    vec3 nor = vec3(0.0);\n    float dis = 0.0;\n    for (int j = 0; j < 10; j++) {\n      vec3 dp = p - pos;\n      float d = length(dp);\n      if (d < tmin) {\n        break;\n      }\n      if (d > tmax) {\n        break;\n      }\n      dis += d;\n      p = pos + dp;\n      nor = normalize(p);\n    }\n    if (dis < tmax) {\n      t = dis;\n    }\n    if (t < tmin) {\n      break;\n    }\n    p = pos + nor * 0.01;\n  }\n  // get color at hit point\n  vec3 col = vec3(0.0);\n  if (t < tmax) {\n    vec3 pos = p;\n    vec3 nor = normalize(pos);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 view = normalize(rd);\n    vec3 halfv = normalize(light + view);\n    float ndotl = max(0.0, dot(nor, light));\n    float ndoth = max(0.0, dot(nor, halfv));\n    float spec = pow(ndoth, 16.0);\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, "}], [{"generated_text": " to avoid division by zero\n    vec3 epsilon = vec3(0.0001, 0.0001, 0.0001);\n    return normalize(vec3(\n        f(pos + epsilon.xyy) - f(pos - epsilon.xyy),\n        f(pos + epsilon.yxy) - f(pos - epsilon.yxy),\n        f(pos + epsilon.yyx) - f(pos - epsilon.yyx)\n    ));\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, 0.0);\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 diffuse = max(0.0, dot(normal, lightDir)) * vec3(1.0, 1.0, 1.0);\n    vec3 specular = pow(max(0.0, dot(reflect(-lightDir, normal), viewDir)), 16.0) * vec3(1.0, 1.0, 1.0);\n    vec3 color = (diffuse + specular) * vec3(1.0, 1.0, 1.0);\n    gl_FragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 p = castRay(ro, rd);\n    // get normal at hit point\n    vec3 n = getNormal(p);\n    // get color at hit point\n    vec3 c = getColor(p);\n    // get light at hit point\n    vec3 l = getLight(p);\n    // get ambient color\n    vec3 a = getAmbient(p);\n    // get diffuse color\n    vec3 d = getDiffuse(p, l);\n    // get specular color\n    vec3 s = getSpecular(p, l, n);\n    // get final color\n    vec3 col = a + d + s;\n    // return final color\n    return col;\n}\n\nvoid main() {\n    // get ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n    // get ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    // get color at ray origin\n    vec3 col = render(ro, rd);\n    // set color\n    gl_FragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 color = texture(texture_diffuse1, p).rgb;\n    //surface normal for bump mapping\n    vec3 normal = texture(texture_normal1, p).rgb;\n    normal = normalize(normal * 2.0 - 1.0);\n    return normal;\n}\n\nvoid main()\n{\n    vec3 viewDir = normalize(viewPos - fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 normal = estimateNormal(fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n    vec3 specular = spec * lightColor;\n    vec3 ambient = lightColor * 0.1;\n    vec3 diffuse = lightColor * max(dot(normal, lightDir), 0.0);\n    vec3 result = (ambient + diffuse + specular) * color;\n    FragColor = vec4(result, 1.0);\n}"}], [{"generated_text": "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\n// This is a simple hash function that is used to generate a random number.\n// It is not a good hash function, but it is good enough for our purposes.\n// You SHOULD replace this by something better. Again, Do Not Use in production.\nfloat"}], [{"generated_text": "el grid\n\tvec2 texel = coord * 16.0;\n\tvec2 texel_floor = floor( texel );\n\tvec2 texel_frac = texel - texel_floor;\n\n\tvec2 texel_offset = vec2( 0.0, 0.0 );\n\ttexel_offset.x = texel_frac.x * 16.0;\n\ttexel_offset.y = texel_frac.y * 16.0;\n\n\tvec2 texel_offset_floor = floor( texel_offset );\n\tvec2 texel_offset_frac = texel_offset - texel_offset_floor;\n\n\tvec2 texel_offset_floor_texel = texel_offset_floor / 16.0;\n\tvec2 texel_offset_frac_texel = texel_offset_frac / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel = texel_offset_floor_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel = texel_offset_frac_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel = texel_offset_floor_texel_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel_texel = texel_offset_frac_texel_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel_texel = texel_offset_floor_texel_texel_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel_texel_texel = texel_offset_frac_texel_texel_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel_texel_texel = texel_"}], [{"generated_text": "\n    p.x = abs(p.x);\n\n    // rotate\n    p.x = cos(p.y) * p.x + sin(p.y) * p.y;\n    p.y = -sin(p.y) * p.x + cos(p.y) * p.y;\n\n    // scale\n    p.x *= ab.x;\n    p.y *= ab.y;\n\n    // translate\n    p.x += ab.x * 0.5;\n    p.y += ab.y * 0.5;\n\n    return p;\n}\n\nvec"}], [{"generated_text": "\n    p = fmod(p, 1.0);\n    if (p < 0.0)\n        p += 1.0;\n    p *= 10000.0;\n    return vec3(p, p + 1.0, p + 2.0);\n}\n\nvec"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n\n    // Get the position of the fragment\n    vec2 position = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the fragment in the screen\n    vec2 positionScreen = (position * 2.0) - 1.0;\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    //"}], [{"generated_text": "\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p17 ="}], [{"generated_text": "\n    float s = sin(rotation.x);\n    float c = cos(rotation.x);\n    float t = sin(rotation.y);\n    float ct = cos(rotation.y);\n    float n = sin(rotation.z);\n    float cn = cos(rotation.z);\n\n    // Create the Rotation Matrix\n    return mat3(\n        vec3(cn*ct, cn*s, -sn),\n        vec3(cn*t, cn*ct*t, -sn*s),\n        vec3(s*ct, s*t, cn)\n    );\n}\n\n//src/main.cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cct"}], [{"generated_text": "\n    vec4 raypos = vec4(0.0, 0.0, 0.0, 1.0);\n    // raypos = vec4(raydir.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1."}], [{"generated_text": "\n    vec3 rayDir = normalize(cameraPos - uv);\n\n    // Calculate the distance to the plane\n    float dist = dot(uv - cameraPos, planeNormal);\n\n    // Calculate the distance to the plane\n    float distToPlane = dist / length(planeNormal);\n\n    // Calculate the distance to the plane\n    float distToCamera = length(uv - cameraPos);\n\n    // Calculate the distance to the plane\n    float distToCameraSquared = distToCamera * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraCubed = distToCameraSquared * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraFourth = distToCameraCubed * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraFifth = distToCameraFourth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraSixth = distToCameraFifth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraSeventh = distToCameraSixth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraEighth = distToCameraSeventh * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraNinth = distToCameraEighth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraTenth = distToCameraNinth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraEleventh = distToCameraTenth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraTwelfth = distToCameraEleventh * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraThirteenth = distToCameraTwelfth * distToCamera;\n\n    // Calcul"}], [{"generated_text": "\n    vec3 raypos = vec3(0.0, 0.0, 0.0);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set"}], [{"generated_text": "\n    float seed = float(gl_FragCoord.x + gl_FragCoord.y);\n    float rng = rand(seed);\n\n    // Initialize variables\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    vec2 c = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 10.0;\n    float tmin = 0.0;\n    float tstep = 0.001;\n    float tstep2 = 0.0001;\n    float tstep3 = 0.00001;\n    float tstep4 = 0.000001;\n    float tstep5 = 0.0000001;\n    float tstep6 = 0.00000001;\n    float tstep7 = 0.000000001;\n    float tstep8 = 0.0000000001;\n    float tstep9 = 0.00000000001;\n    float tstep10 = 0.000000000001;\n    float tstep11 = 0.0000000000001;\n    float tstep12 = 0.00000000000001;\n    float tstep13 = 0.000000000000001;\n    float tstep14 = 0.0000000000000001;\n    float tstep15 = 0.00000000000000001;\n    float tstep16 = 0.000000000000000001;\n    float tstep17 = 0.0000000000000000001;\n    float tstep18 = 0."}], [{"generated_text": "\n    float fade = fadeOut(coord, frequency, travelRate);\n\n    // Get the distance from the center of the fragment\n    float dist = distance(coord, vec2(0.5));\n\n    // Get the strength of the fragment\n    float strength = maxStrength * fade;\n\n    // Return the strength of the fragment\n    return strength;\n}\n\nvoid main()\n{\n    // Get the coordinates of the fragment\n    vec2 coord = gl_FragCoord.xy;\n\n    // Get the strength of the fragment\n    float strength = rayValue(coord, 1.0, 0.001, 1.0);\n\n    // Set the color of the fragment\n    gl_FragColor = vec4(strength, strength, strength, 1.0);\n}\n"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"}], [{"generated_text": "\n\tvec2 e12 = e1 - p;\n\tvec2 e23 = e2 - p;\n\tvec2 e34 = e3 - p;\n\tvec2 e41 = e4 - p;\n\tfloat d12 = dot(e12, e12);\n\tfloat d23 = dot(e23, e23);\n\tfloat d34 = dot(e34, e34);\n\tfloat d41 = dot(e41, e41);\n\tfloat d123 = dot(e12, e23);\n\tfloat d124 = dot(e12, e34);\n\tfloat d234 = dot(e23, e34);\n\tfloat d134 = dot(e13, e34);\n\tfloat d1234 = dot(e12, e34);\n\tfloat d12341 = dot(e12, e41);\n\tfloat d123412 = dot(e12, e23);\n\tfloat d1234123 = dot(e12, e34);\n\tfloat d12341234 = dot(e12, e41);\n\tfloat d2341234 = dot(e23, e34);\n\tfloat d23412341 = dot(e23, e41);\n\tfloat d34123412 = dot(e34, e41);\n\tfloat d341234123 = dot(e34, e23);\n\tfloat d3412341234 = dot(e34, e41);\n\tfloat d412341234 = dot(e41, e23);\n\tfloat d4123412341 = dot(e41, e34);\n\tfloat d41234123412 = dot(e41, e23);\n\tfloat d412341234123 = dot(e41,"}], [{"generated_text": "\n    return pow(color, vec3(2.2));\n}\n\nvec"}], [{"generated_text": "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    float d = length(p-mix(a,b,h));\n\n    // return min(d,w1);\n    return min(d,w1);\n}\n\nfloat"}], [{"generated_text": "\n    uv = uv * 2.0 - 1.0;\n    uv.x *= TAU;\n    uv.y *= TAU;\n\n    //get the distance from the center\n    float d = length(uv);\n\n    //get the angle from the center\n    float a = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a2 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a3 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a4 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a5 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a6 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a7 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a8 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a9 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a10 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a11 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a12 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a13 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a14 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a15 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a16 = atan(uv.y, uv.x"}], [{"generated_text": "\n    //vec3 colC = vec3(0.0,0.0,0.0);\n    //vec3 colD = vec3(0.0,0.0,0.0);\n    //vec3 colE = vec3(0.0,0.0,0.0);\n    //vec3 colF = vec3(0.0,0.0,0.0);\n    //vec3 colG = vec3(0.0,0.0,0.0);\n    //vec3 colH = vec3(0.0,0.0,0.0);\n    //vec3 colI = vec3(0.0,0.0,0.0);\n    //vec3 colJ = vec3(0.0,0.0,0.0);\n    //vec3 colK = vec3(0.0,0.0,0.0);\n    //vec3 colL = vec3(0.0,0.0,0.0);\n    //vec3 colM = vec3(0.0,0.0,0.0);\n    //vec3 colN = vec3(0.0,0.0,0.0);\n    //vec3 colO = vec3(0.0,0.0,0.0);\n    //vec3 colP = vec3(0.0,0.0,0.0);\n    //vec3 colQ = vec3(0.0,0.0,0.0);\n    //vec3 colR = vec3(0.0,0.0,0.0);\n    //vec3 colS = vec3(0.0,0.0,0.0);\n    //vec3 colT = vec3(0.0,0.0,0.0);\n    //vec3 colU = vec3(0.0,0.0,0.0);\n    //vec3 colV = vec3(0.0,0.0,0.0);\n    //vec3 colW = vec3(0.0,0.0,0.0);\n    //vec3 colX ="}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n"}], [{"generated_text": "\n   p = fmod(p, 1.0);\n   if (p < 0.0) p += 1.0;\n   return vec3(p * 127.1, p * 311.7, p * 163.1);\n}\n\nfloat"}], [{"generated_text": "\n  //  return 1.0 - (pow(tanh(x), 2.0));\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0 + (pow(tanh(x), 2.0)) / 32.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0 + (pow(tanh(x), 2.0)) / 32.0 - (pow(tanh(x), 2.0)) / 64.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) /"}], [{"generated_text": ".\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n"}], [{"generated_text": "\n    return length(max(abs(p) - 1.0, 0.0));\n}\n\n// Compute the signed distance field of the sphere\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"}]]}