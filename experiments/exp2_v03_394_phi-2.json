{"generations": ["\n    float x = s.x;\n    float y = s.y;\n    float z = s.z;\n    float a = x*x + y*y + z*z;\n    float b = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z;\n    float c = x*x + y*y + z*z - 1.0f;\n    float d = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 1.0f;\n    float e = x*x + y*y + z*z - 2.0f;\n    float f = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 2.0f;\n    float g = x*x + y*y + z*z - 3.0f;\n    float h = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 3.0f;\n    float i = x*x + y*y + z*z - 4.0f;\n    float j = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 4.0f;\n    float k = x*x + y*y + z*z - 5.0f;\n    float l = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 5.0f;\n    float m = x*x + y*y + z*z - 6.0f;\n    float n = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 6.0f;\n    float o = x*x + y*y + z*z - 7.0f;\n    float p = 2.0f*x*y + 2.0f*x*z + 2.0f*y*z - 7.0f;\n    float q = x*x + y*y + z*z - 8.0f;\n", "\n    float x = (b.x - a.x) * (p.x - a.x) + (b.y - a.y) * (p.y - a.y);\n    float y = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    return sqrt(x * x + y * y);\n}\n\n// distance to a circle (can't get simpler than this)\nfloat", "\n    vec2 w = v - r;\n    return vec2( -w.x, -w.y );\n}\n\n// Compute the distance from the origin to the point\nvec", "\n    return vec2( -v.x, -v.y );\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    return vec2( max( 0.0f, v.x ), max( 0.0f, v.y ) );\n}\n\n// Normalize a vector\nvec", "\n    float x = p.x - a.x;\n    float y = p.y - a.y;\n    float dx = b.x - a.x;\n    float dy = b.y - a.y;\n    float d = sqrt(dx*dx + dy*dy);\n    float d1 = sqrt(x*x + y*y);\n    float d2 = sqrt(dx*dx + dy*dy);\n    float d3 = sqrt(x*x + y*y);\n    float d4 = sqrt(dx*dx + dy*dy);\n    float d5 = sqrt(x*x + y*y);\n    float d6 = sqrt(dx*dx + dy*dy);\n    float d7 = sqrt(x*x + y*y);\n    float d8 = sqrt(dx*dx + dy*dy);\n    float d9 = sqrt(x*x + y*y);\n    float d10 = sqrt(dx*dx + dy*dy);\n    float d11 = sqrt(x*x + y*y);\n    float d12 = sqrt(dx*dx + dy*dy);\n    float d13 = sqrt(x*x + y*y);\n    float d14 = sqrt(dx*dx + dy*dy);\n    float d15 = sqrt(x*x + y*y);\n    float d16 = sqrt(dx*dx + dy*dy);\n    float d17 = sqrt(x*x + y*y);\n    float d18 = sqrt(dx*dx + dy*dy);\n    float d19 = sqrt(x*x + y*y);\n    float d20 = sqrt(dx*dx + dy*dy);\n    float d21 = sqrt(x*x + y*y);\n    float d22 = sqrt(dx*dx + dy*dy);\n    float d23 = sqrt(x*x + y*y);\n    float d24 = sqrt(dx*dx + dy*dy);\n    float d25 = sqrt(x*x + y*y);\n    float d26 = sqrt(dx*dx + dy*dy);\n    ", "\n    vec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\n    vec3 sunColRef = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef2 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef3 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef4 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef5 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef6 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef7 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef8 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef9 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef10 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef11 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef12 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef13 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef14 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef15 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef16 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef17 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef18 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef19 = vec3(0.0,", "\n    vec4 p = p0 + t * (p1 - p0) + t * t * (p2 - 2 * p0 + p1) + t * t * t * (p3 - 3 * p0 + 3 * p1 - p2);\n    return p;\n}\n\n// This is a spline used for the camera path\nvec", "\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat r = sqrt(x*x + y*y + z*z);\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31*r;\n\tfloat r33 = r32*r;\n\tfloat r34 = r33*r;\n\tfloat r35 = r34*r;\n\tfloat r36 = r35*r;\n\tfloat r37 = r36*r;\n\tfloat r38 = r37*r;\n\tfloat r39 = r38*r;\n\tfloat r40 = r39*r;\n\tfloat r41 = r40*r;\n\tfloat r42 = r41*r;\n\tfloat r43 = r42*r;\n\tfloat r", "\n    vec4 p0 = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 p1 = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 p2 = vec4(0.0, 1.0, 0.0, 0.0);\n    vec4 p3 = vec4(0.0, 0.0, 1.0, 0.0);\n\n    vec4 p = p0 + (p1 - p0) * t + (p2 - p1) * t * t + (p3 - p2) * t * t * t;\n\n    return p;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec", "\n    return u * 0x5f3759df - 0xB5CD1D6;\n}\n\nfloat", "\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat r = sqrt(x*x + y*y + z*z);\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31*r;\n\tfloat r33 = r32*r;\n\tfloat r34 = r33*r;\n\tfloat r35 = r34*r;\n\tfloat r36 = r35*r;\n\tfloat r37 = r36*r;\n\tfloat r38 = r37*r;\n\tfloat r39 = r38*r;\n\tfloat r40 = r39*r;\n\tfloat r41 = r40*r;\n\tfloat r42 = r41*r;\n\tfloat r43 = r42*r;\n\tfloat r", "\n    // This is the distance function that calculates the distance between two points\n    float d = sqrt(pow(p.x - this->pos.x, 2) + pow(p.y - this->pos.y, 2) + pow(p.z - this->pos.z, 2));\n    return d;\n}\n\n// This is the function that draws the fractal\nvoid DrawFractal()\n{\n    // This is the function that draws the fractal\n    glBegin(GL_LINES);\n    for (int i = 0; i < 100; i++)\n    {\n        glVertex3f(this->pos.x + (i * 0.1), this->pos.y + (i * 0.1), this->pos.z + (i * 0.1));\n        glVertex3f(this->pos.x + (i * 0.1), this->pos.y + (i * 0.1), this->pos.z - (i * 0.1));\n    }\n    glEnd();\n}\n\n// This is the function that updates the position of the fractal\nvoid Update()\n{\n    // This is the function that updates the position of the fractal\n    this->pos.x += 0.1;\n    this->pos.y += 0.1;\n    this->pos.z += 0.1;\n}\n\n// This is the function that moves the fractal away from the object\nvoid MoveFractal(vec3 p)\n{\n    // This is the function that moves the fractal away from the object\n    this->pos.x -= p.x;\n    this->pos.y -= p.y;\n    this->pos.z -= p.z;\n}\n\n// This is the function that moves the fractal towards the object\nvoid MoveFractal(vec3 p)\n{\n    // This is the function that moves the fractal towards the object\n    this->pos.x += p.x;\n    this->pos.y += p.y;\n    this->pos.z += p.z;\n}\n\n// This is the function that moves the fractal away from the object\nvoid MoveFractal(vec3 p)\n{\n    // This is", "\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\n    vec3 lightDir2 = vec3(0.0, -1.0, 0.0);\n    vec3 lightDir3 = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir4 = vec3(0.0, 0.0, 1.0);\n\n    vec3 lightDir5 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir6 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir7 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir8 = vec3(0.0, 0.0, 0.0);\n\n    vec3 lightDir9 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir10 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir11 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir12 = vec3(0.0, 0.0, 0.0);\n\n    vec3 lightDir13 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir14 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir15 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir16 = vec3(0.0, 0.0, 0.0);\n\n    vec3 lightDir17 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir18 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir19 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir20 = vec3(0.0, 0.0, 0.0);\n\n    vec3 lightDir21 = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir22 = vec3(0.0, 0.0, 0.0);\n    vec3 light", "\n    return a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a", "\n    // dirVec MUST BE NORMALIZED FIRST!!!!\n    float d = dot(dirVecPLZNormalizeMeFirst, pos - spherePos);\n    if (d > rad)\n        return 0.0;\n    float t = d / rad;\n    vec3 tVec = pos + t * dirVecPLZNormalizeMeFirst;\n    return t;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat", "\n    vec3 p0 = vec3(0, 0, 0);\n    vec3 p1 = vec3(1, 0, 0);\n    vec3 p2 = vec3(0, 1, 0);\n    vec3 p3 = vec3(0, 0, 1);\n\n    vec3 p4 = p - p0;\n    vec3 p5 = p - p1;\n    vec3 p6 = p - p2;\n    vec3 p7 = p - p3;\n\n    vec3 d1 = p4.cross(p5);\n    vec3 d2 = p6.cross(p7);\n\n    vec3 d3 = p4.cross(p6);\n    vec3 d4 = p5.cross(p7);\n\n    vec3 d = d1.cross(d2);\n    vec3 d = d.cross(d3);\n    vec3 d = d.cross(d4);\n\n    return d;\n}\n\n// Calculate the distance from the object to the camera.\nvec", "\n    vec3 d0 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d1 = vec3(1.0f, 0.0f, 0.0f);\n    vec3 d2 = vec3(0.0f, 1.0f, 0.0f);\n    vec3 d3 = vec3(0.0f, 0.0f, 1.0f);\n    vec3 d4 = vec3(1.0f, 1.0f, 0.0f);\n    vec3 d5 = vec3(0.0f, 1.0f, 1.0f);\n    vec3 d6 = vec3(1.0f, 0.0f, 1.0f);\n    vec3 d7 = vec3(0.0f, 0.0f, 1.0f);\n\n    vec3 t0 = vec3(t, 0.0f, 0.0f);\n    vec3 t1 = vec3(t, 1.0f, 0.0f);\n    vec3 t2 = vec3(t, 1.0f, 1.0f);\n    vec3 t3 = vec3(t, 0.0f, 1.0f);\n    vec3 t4 = vec3(t, 0.0f, 0.0f);\n    vec3 t5 = vec3(t, 1.0f, 0.0f);\n    vec3 t6 = vec3(t, 1.0f, 1.0f);\n    vec3 t7 = vec3(t, 0.0f, 1.0f);\n\n    vec3 t0t = t0 * t0;\n    vec3 t1t = t1 * t1;\n    vec3 t2t = t2 * t2;\n    vec3 t3t = t3 * t3;\n    vec3 t4t = t4 * t4;\n    vec3 t5t = t5 * t5;\n    vec3 t6t = t6 * t6;\n    vec3 t7t = t7 * t7;\n\n    vec3 t0t1 = t0t * t1;\n    vec3 t0t2", "\n    return vec3(t, 0, 0);\n}\n\n// curve derivative (acceleration)\nvec", "\n    vec3 d2 = vec3(0.0, 0.0, 0.0);\n    if (t < 0.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 1.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 2.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 3.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 4.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 5.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 6.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 7.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 8.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 9.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 10.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 11.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 12.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 13.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 14.0)\n        d2 = vec3(0.0, 0.0, 0.0);\n    else if (t < 15.0)\n        d2 = vec3(0.0, 0.0", "\n    vec3 p1 = a - p;\n    vec3 p2 = b - p;\n    vec3 p3 = p1 + p2;\n    vec3 p4 = p1 - p2;\n    vec3 p5 = p3 - p4;\n    vec3 p6 = p3 + p4;\n    vec3 p7 = p3 - p5;\n    vec3 p8 = p3 + p5;\n    vec3 p9 = p3 - p7;\n    vec3 p10 = p3 + p7;\n    vec3 p11 = p3 - p8;\n    vec3 p12 = p3 + p8;\n    vec3 p13 = p3 - p9;\n    vec3 p14 = p3 + p9;\n    vec3 p15 = p3 - p10;\n    vec3 p16 = p3 + p10;\n    vec3 p17 = p3 - p11;\n    vec3 p18 = p3 + p11;\n    vec3 p19 = p3 - p12;\n    vec3 p20 = p3 + p12;\n    vec3 p21 = p3 - p13;\n    vec3 p22 = p3 + p13;\n    vec3 p23 = p3 - p14;\n    vec3 p24 = p3 + p14;\n    vec3 p25 = p3 - p15;\n    vec3 p26 = p3 + p15;\n    vec3 p27 = p3 - p16;\n    vec3 p28 = p3 + p16;\n    vec3 p29 = p3 - p17;\n    vec3 p30 = p3 + p17;\n    vec3 p31 = p3 - p18;\n    vec3 p32 = p3 + p18;\n    vec3 p33 = p3 - p19;\n    vec3 p34 = p3 + p19;\n    vec3 p35 = p3 - p20;\n    vec3 p36 = p3 + p20;\n    vec3 p37 = p3 - p21;\n    vec3 p38 = p3 + p21;\n    vec3 p39 = p3 - p22;\n    vec3 p40 = p3", "\n    vec3 p = o - a;\n    vec3 q = b - a;\n    vec3 r = d - a;\n    vec3 s = q.cross(r);\n    vec3 t = s.cross(p);\n    return (s.dot(r) > 0)? (t.dot(p) > 0) : (t.dot(r) < 0);\n}\n\n// ray-triangle intersection\nvec", "\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float rx = r.x;\n    float ry = r.y;\n    float rz = r.z;\n    float rw = r.w;\n    float sx = x * x;\n    float sy = y * y;\n    float sxr = sx * rx;\n    float syr = sy * ry;\n    float sxrz = sxr * rz;\n    float sxry = sxr * ry;\n    float sxryz = sxry * rz;\n    float sxryrw = sxry * rw;\n    float sxryrwz = sxryrw * rz;\n    float sxryrwry = sxryrw * ry;\n    float sxryrwryz = sxryrwry * rz;\n    float sxryrwryrw = sxryrwry * rw;\n    float sxryrwryrwz = sxryrwryrw * rz;\n    float sxryrwryrwry = sxryrwryrw * ry;\n    float sxryrwryrwryz = sxryrwryrwry * rz;\n    float sxryrwryrwryrw = sxryrwryrwry * rw;\n    float sxryrwryrwryrwz = sxryrwryrwryrw * rz;\n    float sxryrwryrwryrwry = sxryrwryrwryrw * ry;\n    float sxryrwryrwryrwryz = sxryrwryrwryrwry * rz;\n    float sxryrwryrwryrwryrw = sxryrwryrwryrwry * rw;\n    float sxryrwryrwryrwryrwz = sxryrwryrwryrwry * rz;\n    float sxryrwryrwryrwryrwry = sxryrwryrwryrwry * ry;\n    float sxryrwryrwryrwryrwryrw = sxryrwryrwryrw", "\n    vec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\n    vec3 sunColRef = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef2 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef3 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef4 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef5 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef6 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef7 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef8 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef9 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef10 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef11 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef12 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef13 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef14 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef15 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef16 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef17 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef18 = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirRef19 = vec3(0.0,", "\n    // This is the matrix that transforms the rays coming out of our eyes and going through the window.\n    // It basically gives us a way to position our window.\n    // If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n    // Whats important to remember is that this basically gives us a way to position\n    // our window. We could you it to make the window look north, south, east, west, up, down\n    // or ANYWHERE in between!\n    mat3 eyeRayTransformationMatrix;\n\n    // This is the matrix that transforms the rays coming out of our eyes and going through the window.\n    // It basically gives us a way to position our window.\n    // If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n    // Whats important to remember is that this basically gives us a way to position\n    // our window. We could you it to make the window look north, south, east, west, up, down\n    // or ANYWHERE in between!\n    mat3 eyeRayTransformationMatrix = mat3(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);\n\n    // This is the matrix that transforms the rays coming out of our eyes and going through the window.\n    // It basically gives us a way to position our window.\n    // If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n    // Whats important to remember is that this basically gives us a way to position\n    // our window. We could you it to make the window look north, south, east, west, up, down\n    // or ANYWHERE in between!\n    mat3 eyeRayTransformationMatrix = mat3(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);\n\n    // This is the matrix that transforms the rays coming out of our eyes", "\n    vec3 currentRayPosition = currentRayPosition;\n    vec3 currentRayPosition = currentRayPosition - vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);", "\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the distance to the first thing\n    // This is the distance to the second thing\n    // This is the", "\n    vec3 currentRayPosition = currentRayPosition;\n    vec3 rayDir = currentRayPosition - rayOrigin;\n    vec3 rayDirNormal = normalize( rayDir );\n    vec3 rayDirNormalized = rayDirNormal;\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized = normalize( rayDir );\n    vec3 rayDirNormalized =", "\n    vec3 normal = vec3(0,0,0);\n    vec3 normal2 = vec3(0,0,0);\n    vec3 normal3 = vec3(0,0,0);\n    vec3 normal4 = vec3(0,0,0);\n    vec3 normal5 = vec3(0,0,0);\n    vec3 normal6 = vec3(0,0,0);\n    vec3 normal7 = vec3(0,0,0);\n    vec3 normal8 = vec3(0,0,0);\n    vec3 normal9 = vec3(0,0,0);\n    vec3 normal10 = vec3(0,0,0);\n    vec3 normal11 = vec3(0,0,0);\n    vec3 normal12 = vec3(0,0,0);\n    vec3 normal13 = vec3(0,0,0);\n    vec3 normal14 = vec3(0,0,0);\n    vec3 normal15 = vec3(0,0,0);\n    vec3 normal16 = vec3(0,0,0);\n    vec3 normal17 = vec3(0,0,0);\n    vec3 normal18 = vec3(0,0,0);\n    vec3 normal19 = vec3(0,0,0);\n    vec3 normal20 = vec3(0,0,0);\n    vec3 normal21 = vec3(0,0,0);\n    vec3 normal22 = vec3(0,0,0);\n    vec3 normal23 = vec3(0,0,0);\n    vec3 normal24 = vec3(0,0,0);\n    vec3 normal25 = vec3(0,0,0);\n    vec3 normal26 = vec3(0,0,0);\n    vec3 normal27 = vec3(0,0,0);\n    vec3 normal28 = vec3(0,0,0);\n    vec3 normal29 = vec3(0,0,0);\n    vec3 normal30 = vec3(0,0,0);\n    vec3 normal31 = vec3(0,0,0);\n    vec3 normal32 = vec3(0,0,0);\n", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// this is the function that will be called by the\n// main function.\nvoid main(){\n    // we need to know the size of the screen.\n    vec2 screenSize = vec2(width, height);\n\n    // we need to know the size of the object.\n    vec2 objectSize = vec2(objectWidth, objectHeight);\n\n    // we need to know the size of the object in the\n    // screen.\n    vec2 objectSizeInScreen = objectSize / screenSize;\n\n    // we need to know the position of the object.\n    vec2 objectPosition = vec2(objectX, objectY);\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the object in the\n    // screen.\n    vec2 objectPositionInScreen = objectPosition / screenSize;\n\n    // we need to know the position of the", "\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 normal = normalize(normalOfSurface);\n    vec3 normalColor = normalize(normal*0.5);\n    color = color + normalColor;\n    return color;\n}\n\n// This is the main function that will be called by the\n// raytracer. It will be called for every ray that is\n// fired from the camera.\nvoid main() {\n    // This is the ray that we are going to fire from the\n    // camera.\n    vec3 ray = vec3(0.0,0.0,1.0);\n    // This is the position of the camera.\n    vec3 cameraPos = vec3(0.0,0.0,0.0);\n    // This is the position of the object that we are\n    // going to hit.\n    vec3 objectPos = vec3(0.0,0.0,0.0);\n    // This is the normal of the surface that the object\n    // is on.\n    vec3 objectNormal = vec3(0.0,0.0,1.0);\n    // This is the color of the object.\n    vec3 objectColor = vec3(1.0,0.0,0.0);\n    // This is the color of the surface.\n    vec3 surfaceColor = vec3(0.0,1.0,0.0);\n    // This is the color of the light.\n    vec3 lightColor = vec3(1.0,1.0,1.0);\n    // This is the distance from the camera to the object.\n    float distance = 0.0;\n    // This is the distance from the camera to the light.\n    float lightDistance = 0.0;\n    // This is the distance from the camera to the surface.\n    float surfaceDistance = 0.0;\n    // This is the distance from the camera to the object.\n    float objectDistance = 0.0;\n    // This is the distance from the camera to the light.\n    float lightDistanceFromCamera = 0.0;\n    // This is the distance from the camera to the surface.\n    float surfaceDistanceFromCamera = 0.0;\n", "\n    // This is where we decide what color the world will be!\n    // and what marvelous colors it will be!\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 rayDirectionNormalized = normalize( rayDirection );\n    vec3 rayDirectionNormalizedUnit = normalize( rayDirectionNormalized );\n    vec3 rayDirectionNormalizedUnitUnit = normalize( rayDirectionNormalizedUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize( rayDirectionNormalizedUnitUnitUnitUnitUnitUnit );\n    vec3 rayDirectionNormalizedUnitUnitUnitUnitUnitUnit = normalize(", "\n    return (x < 0.5)? (b * x) : (1.0 - (b * x));\n}\n\n// returns a value between 0 and 1\n// if x is near 0.5 then values near x are returned\n// if x is near 0.0 then values near 0.0 are returned\n// if x is near 1.0 then values near 1.0 are returned\nfloat", "\n    return rand() / (float)RAND_MAX;\n}\n\n// returns a random number in the range 0..1 including 0 excluding 1\nfloat", "\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// returns a random number in the range 0..1 excluding 0\nfloat", "\n    float dist = p.x*p.x + p.y*p.y + p.z*p.z;\n    if (dist > r*r)\n        return 1.0;\n    else\n        return 0.0;\n}\n\n// ~~~~~~~ signed fistance fuction for line\n// input p1, p2 --> are two points on line\n// pretty simple, just compare point to line\nfloat", "\n\tfloat x = p.xz.y;\n\tfloat y = p.xz.x;\n\tfloat z = p.xz.z;\n\tfloat r = t.x;\n\tfloat t = t.y;\n\treturn sqrt(pow(x,2) + pow(y,2) + pow(z,2) - pow(r,2) - pow(t,2));\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> sphere specs where:\n// \tp.x = sphere radius\n// \tp.y = sphere radius\n// \tp.z = sphere radius\n// \n// think of the sphere as a circle\n// \nfloat", "\n    float d = d1 - d2;\n    if (d < 0)\n        d = -d;\n    if (d > 0.5)\n        d = 1.0 - d;\n    return d * d * d * (d * (d * 6.0 - 15.0) + 10.0);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat", "\n    return (d1 + d2) / 2;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat", "\n    vec3 p1 = vec3(p.x, p.y, p.z);\n    vec3 p2 = vec3(p.x*cos(yaw) - p.y*sin(yaw), p.x*sin(yaw) + p.y*cos(yaw), p.z);\n    vec3 p3 = vec3(p.x*cos(yaw) + p.y*sin(yaw), p.x*sin(yaw) - p.y*cos(yaw), p.z);\n    vec3 p4 = vec3(p.x*cos(yaw) - p.y*sin(yaw), p.x*sin(yaw) + p.y*cos(yaw), p.z);\n    vec3 p5 = vec3(p.x*cos(yaw) + p.y*sin(yaw), p.x*sin(yaw) - p.y*cos(yaw), p.z);\n    vec3 p6 = vec3(p.x*cos(yaw) - p.y*sin(yaw), p.x*sin(yaw) + p.y*cos(yaw), p.z);\n    vec3 p7 = vec3(p.x*cos(yaw) + p.y*sin(yaw), p.x*sin(yaw) - p.y*cos(yaw), p.z);\n    vec3 p8 = vec3(p.x*cos(yaw) - p.y*sin(yaw), p.x*sin(yaw) + p.y*cos(yaw), p.z);\n    vec3 p9 = vec3(p.x*cos(yaw) + p.y*sin(yaw), p.x*sin(yaw) - p.y*cos(yaw), p.z);\n    vec3 p10 = vec3(p.x*cos(yaw) - p.y*sin(yaw), p.x*sin(yaw) + p.y*cos(yaw), p.z);\n    vec3 p11 = vec3(p.x*cos(yaw) + p.", "\n    if(o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n    vec2 p2;\n    vec2 p3;\n    vec2 p4;\n    vec2 p5;\n    vec2 p6;\n    vec2 p7;\n    vec2 p8;\n    vec2 p9;\n    vec2 p10;\n    vec2 p11;\n    vec2 p12;\n    vec2 p13;\n    vec2 p14;\n    vec2 p15;\n    vec2 p16;\n    vec2 p17;\n    vec2 p18;\n    vec2 p19;\n    vec2 p20;\n    vec2 p21;\n    vec2 p22;\n    vec2 p23;\n    vec2 p24;\n    vec2 p25;\n    vec2 p26;\n    vec2 p27;\n    vec2 p28;\n    vec2 p29;\n    vec2 p30;\n    vec2 p31;\n    vec2 p32;\n    vec2 p33;\n    vec2 p34;\n    vec2 p35;\n    vec2 p36;\n    vec2 p37;\n    vec2 p38;\n    vec2 p39;\n    vec2 p40;\n    vec2 p41;\n    vec2 p42;\n    vec2 p43;\n    vec2 p44;\n    vec2 p45;\n    vec2 p46;\n    vec2 p47;\n    vec2 p48;\n    vec2 p49;\n    vec2 p50;\n    vec2 p51;\n    vec2 p52;\n    vec2 p53;\n    vec2 p54;\n    vec2 p55;\n    vec2 p56;\n    vec2 p57;\n    vec2 p58;\n    vec2 p59;\n    vec2 p60;\n    vec2 p61;\n    vec2 p62;\n    vec2 p63;\n    vec2 p64;\n    vec2 p65;\n    vec2 p66;\n    vec2 p67;\n    vec2 p68;\n    vec2 p69;\n    vec2 p70;\n    vec2 p71;\n    vec2 p72;\n    vec2 p73;\n    vec2 p74;\n", "\n    vec2 ret;\n    for(int i = 0; i < word.size(); i++)\n    {\n        vec3 p = word[i];\n        vec3 d = p - ro;\n        float d2 = d.dot(rd);\n        if(d2 > 0)\n        {\n            ret.x = d2;\n            ret.y = i;\n            return ret;\n        }\n    }\n    return ret;\n}\n\n// ~~~~~~~ check if the ray hits an object\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input obj --> object to check\n// output is bool\n//\nbool checkHit( vec3 ro, vec3 rd, const obj& obj)\n{\n    vec2 ret;\n    ret = castRay(ro, rd)!= ret;\n    return ret;\n}\n\n// ~~~~~~~ check if the ray hits the wall\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input wall --> wall to check\n// output is bool\n//\nbool checkHitWall( vec3 ro, vec3 rd, const wall& wall)\n{\n    vec2 ret;\n    ret = castRay(ro, rd)!= ret;\n    return ret;\n}\n\n// ~~~~~~~ check if the ray hits the floor\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input floor --> floor to check\n// output is bool\n//\nbool checkHitFloor( vec3 ro, vec3 rd, const floor& floor)\n{\n    vec2 ret;\n    ret = castRay(ro, rd)!= ret;\n    return ret;\n}\n\n// ~~~~~~~ check if the ray hits the ceiling\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input ceiling --> ceiling to check\n// output is bool\n//\nbool checkHitCeiling( vec3 ro, vec3 rd, const ceiling& ceiling)\n{\n    vec2 ret;\n    ret = castRay(ro, rd)!= ret;\n    return ret;\n}\n\n// ~~~~~~~ check if the ray hits the door\n// input", "\n    vec3 r = ro + rd;\n    vec3 s = surface(r);\n    vec3 c = color(s);\n    return c;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec", "\n    // create camera matrix\n    mat3 camMat;\n    // set up camera matrix\n    camMat.set(\n        vec3(\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0,", "\n    float i = id;\n    float j = i;\n    float k = i;\n    float l = i;\n    float m = i;\n    float n = i;\n    float o = i;\n    float p = i;\n    float q = i;\n    float r = i;\n    float s = i;\n    float t = i;\n    float u = i;\n    float v = i;\n    float w = i;\n    float x = i;\n    float y = i;\n    float z = i;\n    float a = i;\n    float b = i;\n    float c = i;\n    float d = i;\n    float e = i;\n    float f = i;\n    float g = i;\n    float h = i;\n    float i = i;\n    float j = i;\n    float k = i;\n    float l = i;\n    float m = i;\n    float n = i;\n    float o = i;\n    float p = i;\n    float q = i;\n    float r = i;\n    float s = i;\n    float t = i;\n    float u = i;\n    float v = i;\n    float w = i;\n    float x = i;\n    float y = i;\n    float z = i;\n    float a = i;\n    float b = i;\n    float c = i;\n    float d = i;\n    float e = i;\n    float f = i;\n    float g = i;\n    float h = i;\n    float i = i;\n    float j = i;\n    float k = i;\n    float l = i;\n    float m = i;\n    float n = i;\n    float o = i;\n    float p = i;\n    float q = i;\n    float r = i;\n    float s = i;\n    float t = i;\n    float u = i;\n    float v = i;\n    float w = i;\n    float x = i;\n    float y = i;\n    float z = i;\n    float a = i;\n    float b = i;\n    float c = i;\n", "\n    float x = p.xz.y;\n    float y = p.xz.x;\n    float z = p.xz.z;\n    float r = t.x;\n    float t = t.y;\n    return sqrt(x*x + y*y + z*z) - t;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input p --> specs of sphere\n//        p.x --> size x\n//        p.y --> size y\n//        p.z --> size z\n// sphere extends indefinately in x, y and z, \n// so just return height from floor (y)\nfloat", "\n    float d = d1 - d2;\n    if (d < 0)\n        d = -d;\n    return k*d + (1-k)*d1;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n    vec4 o1_color = o1.rgba;\n    vec4 o2_color = o2.rgba;\n    vec4 blended_color = o1_color * bf + o2_color * (1.0 - bf);\n    return blended_color;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec", "\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d1 out of d2\n// by using  the negative of d2, where d2 is the internal distance\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat", "\n    vec3 worldPos;\n    worldPos = vec3(0.0, 0.0, 0.0);\n    return worldPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec", "\n    vec3 p0 = p;\n    vec3 p1 = p + vec3(1, 0, 0);\n    vec3 p2 = p + vec3(0, 1, 0);\n    vec3 p3 = p + vec3(0, 0, 1);\n\n    vec3 p0p1 = p1 - p0;\n    vec3 p1p2 = p2 - p1;\n    vec3 p2p3 = p3 - p2;\n\n    vec3 p0p2 = p2 - p0;\n    vec3 p1p3 = p3 - p1;\n\n    vec3 p0p3 = p3 - p0;\n    vec3 p1p2 = p2 - p1;\n\n    vec3 p0p1p2 = p1p2 - p0p1;\n    vec3 p0p1p3 = p1p3 - p0p1;\n    vec3 p0p2p3 = p2p3 - p0p2;\n\n    vec3 p0p1p2p3 = p1p2p3 - p0p1p2;\n\n    vec3 p0p1p2p3p0 = p0p1p2p3p0 - p0p1p2;\n    vec3 p0p1p2p3p1 = p0p1p2p3p1 - p0p1p2;\n    vec3 p0p1p2p3p2 = p0p1p2p3p2 - p0p1p2;\n    vec3 p0p1p2p3p3 = p0p1p2p3p3 - p0p1p2;\n\n    vec3 p0p1p2p3p4 = p1p2p3p4 - p1p2p3;\n    vec3 p0p1p2p3p5 = p1p2p3p5 - p1p2p3;\n    vec3 p0p1p2p3p6 = p1p2p3p6 - p1p2p3;\n    vec3 p0p1p2p3p7 = p1p2p3p7 - p1p2p", "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 v = vec3(0,0,0);\n    float dt = 0;\n    float dz = 0;\n    float dz_max = 0;\n    float dz_min = 0;\n    float dz_max_idx = 0;\n    float dz_min_idx = 0;\n    float dz_max_dist = 0;\n    float dz_min_dist = 0;\n    float dz_max_dist_idx = 0;\n    float dz_min_dist_idx = 0;\n    float dz_max_dist_idx_2 = 0;\n    float dz_min_dist_idx_2 = 0;\n    float dz_max_dist_idx_3 = 0;\n    float dz_min_dist_idx_3 = 0;\n    float dz_max_dist_idx_4 = 0;\n    float dz_min_dist_idx_4 = 0;\n    float dz_max_dist_idx_5 = 0;\n    float dz_min_dist_idx_5 = 0;\n    float dz_max_dist_idx_6 = 0;\n    float dz_min_dist_idx_6 = 0;\n    float dz_max_dist_idx_7 = 0;\n    float dz_min_dist_idx_7 = 0;\n    float dz_max_dist_idx_8 = 0;\n    float dz_min_dist_idx_8 = 0;\n    float dz_max_dist_idx_9 = 0;\n    float dz_min_dist_idx_9 = 0;\n    float dz_max_dist_idx_10 = 0;\n    float dz_min_dist_idx_10 = 0;\n    float dz_max_dist_idx_11 = 0;\n    float dz_min_dist_idx_11 = 0;\n    float dz_max_dist_idx_12 = 0;\n    float dz_min", "\n    // compute the distance from the surface to the light\n    float d = sp.x - lp.x;\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n    float d31 = d30 * d;\n    float d32 = d31 * d;\n    float d33 = d32 * d;\n    float d34 = d33 * d;\n    float d35 = d34 * d;\n    float d36 = d35 * d;\n    float d37 = d36 * d;\n    float d38 = d37 * d;\n    float d39 = d38 * d;\n    float d40 = d39 * d;\n    float d41 = d40 * d;\n    float d42 = d41 * d;\n    float d43 = d42 * d;\n    float d44 = d43 * d;\n    float d45 = d44 * d;\n    float", "\n    float t = 0.0f;\n    float tMin = 0.0f;\n    float tMax = 1.0f;\n    float tMin2 = 0.0f;\n    float tMax2 = 1.0f;\n    float tMin3 = 0.0f;\n    float tMax3 = 1.0f;\n    float tMin4 = 0.0f;\n    float tMax4 = 1.0f;\n    float tMin5 = 0.0f;\n    float tMax5 = 1.0f;\n    float tMin6 = 0.0f;\n    float tMax6 = 1.0f;\n    float tMin7 = 0.0f;\n    float tMax7 = 1.0f;\n    float tMin8 = 0.0f;\n    float tMax8 = 1.0f;\n    float tMin9 = 0.0f;\n    float tMax9 = 1.0f;\n    float tMin10 = 0.0f;\n    float tMax10 = 1.0f;\n    float tMin11 = 0.0f;\n    float tMax11 = 1.0f;\n    float tMin12 = 0.0f;\n    float tMax12 = 1.0f;\n    float tMin13 = 0.0f;\n    float tMax13 = 1.0f;\n    float tMin14 = 0.0f;\n    float tMax14 = 1.0f;\n    float tMin15 = 0.0f;\n    float tMax15 = 1.0f;\n    float tMin16 = 0.0f;\n    float tMax16 = 1.0f;\n    float tMin17 = 0.0f;\n    float tMax17 = 1.0f;\n    float tMin18 = 0.0f;\n    float tMax18 = 1.0f;\n    float tMin19 = 0.0f;\n    float tMax19 = 1.0f;\n    float tMin20 = 0.0f;\n    float tMax20 = 1.0f;\n    float tMin21 = 0.0f;\n    float tMax21 = 1.0f;", "\n    vec3 pN = normalize(p - oN);\n    vec3 pN2 = normalize(pN);\n    vec3 pN3 = normalize(pN2);\n    vec3 pN4 = normalize(pN3);\n    vec3 pN5 = normalize(pN4);\n    vec3 pN6 = normalize(pN5);\n    vec3 pN7 = normalize(pN6);\n    vec3 pN8 = normalize(pN7);\n    vec3 pN9 = normalize(pN8);\n    vec3 pN10 = normalize(pN9);\n    vec3 pN11 = normalize(pN10);\n    vec3 pN12 = normalize(pN11);\n    vec3 pN13 = normalize(pN12);\n    vec3 pN14 = normalize(pN13);\n    vec3 pN15 = normalize(pN14);\n    vec3 pN16 = normalize(pN15);\n    vec3 pN17 = normalize(pN16);\n    vec3 pN18 = normalize(pN17);\n    vec3 pN19 = normalize(pN18);\n    vec3 pN20 = normalize(pN19);\n    vec3 pN21 = normalize(pN20);\n    vec3 pN22 = normalize(pN21);\n    vec3 pN23 = normalize(pN22);\n    vec3 pN24 = normalize(pN23);\n    vec3 pN25 = normalize(pN24);\n    vec3 pN26 = normalize(pN25);\n    vec3 pN27 = normalize(pN26);\n    vec3 pN28 = normalize(pN27);\n    vec3 pN29 = normalize(pN28);\n    vec3 pN30 = normalize(pN29);\n    vec3 pN31 = normalize(pN30);\n    vec3 pN32 = normalize(pN31);\n    vec3 pN33 = normalize(pN32);\n    vec3 pN34 = normalize(pN33);\n    vec", "\n    // gamma correction\n    vec3 g = vec3(0.0031308, 0.0, 0.0);\n    vec3 gc = vec3(1.0, 1.0, 1.0);\n    vec3 gc2 = vec3(1.0, 1.0, 1.0);\n    vec3 gc3 = vec3(1.0, 1.0, 1.0);\n    vec3 gc4 = vec3(1.0, 1.0, 1.0);\n    vec3 gc5 = vec3(1.0, 1.0, 1.0);\n    vec3 gc6 = vec3(1.0, 1.0, 1.0);\n    vec3 gc7 = vec3(1.0, 1.0, 1.0);\n    vec3 gc8 = vec3(1.0, 1.0, 1.0);\n    vec3 gc9 = vec3(1.0, 1.0, 1.0);\n    vec3 gc10 = vec3(1.0, 1.0, 1.0);\n    vec3 gc11 = vec3(1.0, 1.0, 1.0);\n    vec3 gc12 = vec3(1.0, 1.0, 1.0);\n    vec3 gc13 = vec3(1.0, 1.0, 1.0);\n    vec3 gc14 = vec3(1.0, 1.0, 1.0);\n    vec3 gc15 = vec3(1.0, 1.0, 1.0);\n    vec3 gc16 = vec3(1.0, 1.0, 1.0);\n    vec3 gc17 = vec3(1.0, 1.0, 1.0);\n    vec3 gc18 = vec3(1.0, 1.0, 1.0);\n    vec3 gc19 = vec3(1.0, 1.0, 1.0);\n    vec3 gc20 = vec3(1.0, 1.0, 1.0);\n    vec3 gc21 = vec3(1.0, 1.0, 1.0);\n    ", "\n    vec3 cf = fog(d,fs.x,fs.y);\n    vec3 cf1 = fog(d,fs.x,fs.y);\n    vec3 cf2 = fog(d,fs.x,fs.y);\n    vec3 cf1 = cf1 * (1.0f - cf.x);\n    vec3 cf2 = cf2 * (1.0f - cf.x);\n    vec3 cf1 = cf1 * (1.0f - cf.y);\n    vec3 cf2 = cf2 * (1.0f - cf.y);\n    vec3 cf1 = cf1 * (1.0f - cf.z);\n    vec3 cf2 = cf2 * (1.0f - cf.z);\n    vec3 cf1 = cf1 * (1.0f - cf.w);\n    vec3 cf2 = cf2 * (1.0f - cf.w);\n    vec3 cf1 = cf1 * (1.0f - cf.x);\n    vec3 cf2 = cf2 * (1.0f - cf.x);\n    vec3 cf1 = cf1 * (1.0f - cf.y);\n    vec3 cf2 = cf2 * (1.0f - cf.y);\n    vec3 cf1 = cf1 * (1.0f - cf.z);\n    vec3 cf2 = cf2 * (1.0f - cf.z);\n    vec3 cf1 = cf1 * (1.0f - cf.w);\n    vec3 cf2 = cf2 * (1.0f - cf.w);\n    vec3 cf1 = cf1 * (1.0f - cf.x);\n    vec3 cf2 = cf2 * (1.0f - cf.x);\n    vec3 cf1 = cf1 * (1.0f - cf.y);\n    vec3 cf2 = cf2 * (1.0", "\n    return cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadratic, so cF=0,lF=0,qF=1\nfloat", "\n    vec3 rayDir;\n    vec3 cCoord;\n    vec3 cMatCoord;\n    vec3 cMatInv;\n    vec3 cMatInvCoord;\n    vec3 cMatInvCoord2;\n    vec3 cMatInvCoord3;\n    vec3 cMatInvCoord4;\n    vec3 cMatInvCoord5;\n    vec3 cMatInvCoord6;\n    vec3 cMatInvCoord7;\n    vec3 cMatInvCoord8;\n    vec3 cMatInvCoord9;\n    vec3 cMatInvCoord10;\n    vec3 cMatInvCoord11;\n    vec3 cMatInvCoord12;\n    vec3 cMatInvCoord13;\n    vec3 cMatInvCoord14;\n    vec3 cMatInvCoord15;\n    vec3 cMatInvCoord16;\n    vec3 cMatInvCoord17;\n    vec3 cMatInvCoord18;\n    vec3 cMatInvCoord19;\n    vec3 cMatInvCoord20;\n    vec3 cMatInvCoord21;\n    vec3 cMatInvCoord22;\n    vec3 cMatInvCoord23;\n    vec3 cMatInvCoord24;\n    vec3 cMatInvCoord25;\n    vec3 cMatInvCoord26;\n    vec3 cMatInvCoord27;\n    vec3 cMatInvCoord28;\n    vec3 cMatInvCoord29;\n    vec3 cMatInvCoord30;\n    vec3 cMatInvCoord31;\n    vec3 cMatInvCoord32;\n    vec3 cMatInvCoord33;\n    vec3 cMatInvCoord34;\n    vec3 cMatInvCoord35;\n    vec3 cMatInvCoord36;\n    vec3 cMatInvCoord37;\n    vec3 cMatInvCoord38;\n    vec3 cMatInvCoord39;\n    vec3 cMatInvCoord40;\n    vec3 cMatInvCoord41;\n    vec3 cMatInvCoord42;\n    vec3 cMatInvCoord43;\n    vec3 cMatInvCo", "\n    vec3 cPos_inv = invert_mat3(cPos);\n    vec3 cPos_inv_f = fCoord*cPos_inv;\n    vec3 cPos_inv_f_c = cPos_inv_f*cMat;\n    vec3 cPos_inv_f_c_c = cPos_inv_f_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c = cPos_inv_f_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c = cPos_inv_f_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c = cPos_inv_f_c_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c_c = cPos_inv_f_c_c_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c_c_c = cPos_inv_f_c_c_c_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c_c_c_c = cPos_inv_f_c_c_c_c_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c_c_c_c_c = cPos_inv_f_c_c_c_c_c_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c_c_c_c_c_c = cPos_inv_f_c_c_c_c_c_c_c_c_c*cPos_inv;\n    vec3 cPos_inv_f_c_c_c_c_c_c_c_c_c_c_c = cPos_inv_f_c_c_c_", "\n    // Calculate the x and y coordinates of the pixel\n    vec2 x = fragCoord.x - 2.0;\n    vec2 y = fragCoord.y - 1.5;\n    \n    // Calculate the real and imaginary parts of the complex number\n    vec2 z = vec2(x, y);\n    \n    // Initialize the complex number\n    complex c(0.0, 0.0);\n    \n    // Iterate the Mandelbrot set\n    int maxIterations = 100;\n    for (int i = 0; i < maxIterations; i++)\n    {\n        // Calculate the complex number\n        c = z * z + c;\n        \n        // Check if the complex number is outside the Mandelbrot set\n        if (c.real * c.real + c.imag * c.imag > 4.0)\n        {\n            // Set the color of the pixel\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            break;\n        }\n    }\n}\n```\n\nThis code defines a `mainImage` function that takes in a `fragColor` and a `fragCoord` as input. The `fragCoord` is the position of the pixel in the image, and the `fragColor` is the color of the pixel.\n\nThe function first calculates the x and y coordinates of the pixel, and then calculates the real and imaginary parts of the complex number. It then initializes the complex number to 0.0 and iterates the Mandelbrot set.\n\nIf the complex number is outside the Mandelbrot set, the function sets the color of the pixel to black. Otherwise, it continues iterating until the complex number is outside the set.\n\nThis code can be used to create a Mandelbrot set image in PyOpenGL.\n", "\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z) - radius;\n}\n\n// sphere distance field\nfloat", "\n    float x = p.x - r;\n    float y = p.y - r;\n    return x*x + y*y;\n}\n\n// simple sphere distance field\nfloat", "\n    vec3 p0 = vec3(0, 0, 0);\n    vec3 p1 = vec3(1, 0, 0);\n    vec3 p2 = vec3(0, 1, 0);\n    vec3 p3 = vec3(0, 0, 1);\n\n    vec3 p4 = vec3(p.x, p.y, p.z);\n    vec3 p5 = vec3(p.x, p.y, -p.z);\n    vec3 p6 = vec3(p.x, -p.y, p.z);\n    vec3 p7 = vec3(p.x, -p.y, -p.z);\n\n    vec3 p8 = vec3(p.x, p.y, p.z);\n    vec3 p9 = vec3(p.x, p.y, -p.z);\n    vec3 p10 = vec3(p.x, -p.y, p.z);\n    vec3 p11 = vec3(p.x, -p.y, -p.z);\n\n    vec3 p12 = vec3(p.x, p.y, p.z);\n    vec3 p13 = vec3(p.x, p.y, -p.z);\n    vec3 p14 = vec3(p.x, -p.y, p.z);\n    vec3 p15 = vec3(p.x, -p.y, -p.z);\n\n    vec3 p16 = vec3(p.x, p.y, p.z);\n    vec3 p17 = vec3(p.x, p.y, -p.z);\n    vec3 p18 = vec3(p.x, -p.y, p.z);\n    vec3 p19 = vec3(p.x, -p.y, -p.z);\n\n    vec3 p20 = vec3(p.x, p.y, p.z);\n    vec3 p21 = vec3(p.x, p.y, -p.z);\n    vec3 p22 = vec3(p.x, -p.y, p.z);\n    vec3 p23 = vec3(p.", "\n    vec2 result;\n    result.x = c.x * c.x * c.x * c.x * c.x;\n    result.y = c.y * c.y * c.x * c.x * c.x;\n    return result;\n}\n\n//Function that returns a complex number to power of 6\nvec", "\n    vec2 morphCoord = morphConstant * coord;\n    vec2 morphCoord2 = morphCoord * morphCoord;\n    vec2 morphCoord3 = morphCoord2 * morphCoord;\n    vec2 morphCoord4 = morphCoord3 * morphCoord;\n    vec2 morphCoord5 = morphCoord4 * morphCoord;\n    vec2 morphCoord6 = morphCoord5 * morphCoord;\n    vec2 morphCoord7 = morphCoord6 * morphCoord;\n    vec2 morphCoord8 = morphCoord7 * morphCoord;\n    vec2 morphCoord9 = morphCoord8 * morphCoord;\n    vec2 morphCoord10 = morphCoord9 * morphCoord;\n    vec2 morphCoord11 = morphCoord10 * morphCoord;\n    vec2 morphCoord12 = morphCoord11 * morphCoord;\n    vec2 morphCoord13 = morphCoord12 * morphCoord;\n    vec2 morphCoord14 = morphCoord13 * morphCoord;\n    vec2 morphCoord15 = morphCoord14 * morphCoord;\n    vec2 morphCoord16 = morphCoord15 * morphCoord;\n    vec2 morphCoord17 = morphCoord16 * morphCoord;\n    vec2 morphCoord18 = morphCoord17 * morphCoord;\n    vec2 morphCoord19 = morphCoord18 * morphCoord;\n    vec2 morphCoord20 = morphCoord19 * morphCoord;\n    vec2 morphCoord21 = morphCoord20 * morphCoord;\n    vec2 morphCoord22 = morphCoord21 * morphCoord;\n    vec2 morphCoord23 = morphCoord22 * morphCoord;\n    vec2 morphCoord24 = morphCoord23 * morphCoord;\n    vec2 morphCoord25 = morphCoord24 * morphCoord;\n    vec2 morphCoord26 = morphCoord25 * morphCoord;\n    vec2 morphCoord27 = morphCoord26 * morphCoord;\n    vec2 morphCoord28 = morphCoord27 * morphCoord;\n    vec2 morphCoord29 = morphCoord28", "\n    //Get the pixel coordinates\n    vec2 p = uv * constant;\n    //Get the pixel color\n    vec4 color = texture2D(tex, p);\n    //Get the color of the surrounding pixels\n    vec4 surroundingColor = texture2D(tex, p + vec2(1, 0));\n    vec4 surroundingColor2 = texture2D(tex, p + vec2(0, 1));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor2 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor3 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor4 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor5 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor6 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor7 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor8 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor9 = texture2D(tex, p + vec2(0.5, 0.5));\n    //Get the color of the pixel in the middle of the surrounding pixels\n    vec4 middleColor10 = texture2D(tex, p +", "\n    return x < 0.5? -x : x;\n}\n\nfloat", "\n    // This is the distance from the line to the point\n    float d = 0.0;\n    // This is the distance from the point to the line\n    float dp = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the line to the point at the last point\n    float dpPrevPrevPrev", "\n    // Get the vector from pA to pB.\n    vec2 v = pB - pA;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 u = uv - pA;\n    // Get the unit vector from pA to the point on the line at uv.\n    vec2 uu = u / dot(u, v);\n    // Get the vector from pA to the point on the line at uv.\n    vec2 vv = v * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 w = pA + vv;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 x = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 y = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 z = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 ww = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 xx = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 yy = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 zz = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 www = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 xy = pA + vv + thick * uu;\n    // Get the vector from pA to the point on the line at uv.\n    vec2 yz = pA +", "\n    // Get the pixel coordinates of the line.\n    vec2 p1 = uv * pA;\n    vec2 p2 = uv * pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1e = p1 + pA;\n    vec2 p2e = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1n = p1 - pA;\n    vec2 p2n = p2 - pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1m = p1 - pA;\n    vec2 p2m = p2 - pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p = p1 + pA;\n    vec2 p2p = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p1 = p1 + pA;\n    vec2 p2p1 = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p2 = p1 + pA;\n    vec2 p2p2 = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p3 = p1 + pA;\n    vec2 p2p3 = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p4 = p1 + pA;\n    vec2 p2p4 = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p5 = p1 + pA;\n    vec2 p2p5 = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p6 = p1 + pA;\n    vec2 p2p6 = p2 + pB;\n    // Get the pixel coordinates of the endpoints of the line.\n    vec2 p1p7 = p1 + pA;\n    vec", "\n    float u = uv.x;\n    float v = uv.y;\n    float u1 = uv.x + thick;\n    float v1 = uv.y + thick;\n    float u2 = uv.x - thick;\n    float v2 = uv.y - thick;\n    float u3 = uv.x + thick;\n    float v3 = uv.y - thick;\n    float u4 = uv.x - thick;\n    float v4 = uv.y + thick;\n    float u5 = uv.x + thick;\n    float v5 = uv.y + thick;\n    float u6 = uv.x - thick;\n    float v6 = uv.y - thick;\n    float u7 = uv.x + thick;\n    float v7 = uv.y - thick;\n    float u8 = uv.x - thick;\n    float v8 = uv.y + thick;\n    float u9 = uv.x + thick;\n    float v9 = uv.y + thick;\n    float u10 = uv.x - thick;\n    float v10 = uv.y - thick;\n    float u11 = uv.x + thick;\n    float v11 = uv.y - thick;\n    float u12 = uv.x - thick;\n    float v12 = uv.y + thick;\n    float u13 = uv.x + thick;\n    float v13 = uv.y + thick;\n    float u14 = uv.x - thick;\n    float v14 = uv.y - thick;\n    float u15 = uv.x + thick;\n    float v15 = uv.y - thick;\n    float u16 = uv.x - thick;\n    float v16 = uv.y + thick;\n    float u17 = uv.x + thick;\n    float v17 = uv.y + thick;\n    float u18 = uv.x - thick;\n    float v18 = uv.y - thick;\n    float u19 = uv.x + thick;\n    float v19 = uv.y -", "\n    float u = uv.x;\n    float v = uv.y;\n    float u1 = uv.x + thick;\n    float v1 = uv.y + thick;\n    float u2 = uv.x - thick;\n    float v2 = uv.y - thick;\n    float u3 = uv.x - thick;\n    float v3 = uv.y + thick;\n    float u4 = uv.x + thick;\n    float v4 = uv.y - thick;\n    float u5 = uv.x + thick;\n    float v5 = uv.y + thick;\n    float u6 = uv.x - thick;\n    float v6 = uv.y - thick;\n    float u7 = uv.x - thick;\n    float v7 = uv.y + thick;\n    float u8 = uv.x + thick;\n    float v8 = uv.y + thick;\n    float u9 = uv.x + thick;\n    float v9 = uv.y - thick;\n    float u10 = uv.x - thick;\n    float v10 = uv.y - thick;\n    float u11 = uv.x - thick;\n    float v11 = uv.y + thick;\n    float u12 = uv.x + thick;\n    float v12 = uv.y + thick;\n    float u13 = uv.x + thick;\n    float v13 = uv.y - thick;\n    float u14 = uv.x - thick;\n    float v14 = uv.y - thick;\n    float u15 = uv.x - thick;\n    float v15 = uv.y + thick;\n    float u16 = uv.x + thick;\n    float v16 = uv.y + thick;\n    float u17 = uv.x + thick;\n    float v17 = uv.y - thick;\n    float u18 = uv.x - thick;\n    float v18 = uv.y - thick;\n    float u19 = uv.x - thick;\n    float v19 = uv.y +", "\n    float u = uv.x;\n    float v = uv.y;\n    float uv_thick = uv.x * outlineThick;\n    float uv_rounded = uv.x * rounded;\n    float uv_rounded_thick = uv.x * outlineThick * rounded;\n    float uv_rounded_thick_thick = uv.x * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick_thick_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick_thick_thick_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_thick_thick_thick_thick_thick_thick_thick_thick_thick = uv.x * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * outlineThick * rounded;\n\n    float uv_rounded_th", "\n    vec3 u = uv.xy;\n    vec3 v = p.xy;\n    vec3 w = u - v;\n    vec3 uvw = uv * w;\n    vec3 uvw2 = uvw * uvw;\n    vec3 uvw3 = uvw * uvw2;\n    vec3 uvw4 = uvw * uvw3;\n    vec3 uvw5 = uvw * uvw4;\n    vec3 uvw6 = uvw * uvw5;\n    vec3 uvw7 = uvw * uvw6;\n    vec3 uvw8 = uvw * uvw7;\n    vec3 uvw9 = uvw * uvw8;\n    vec3 uvw10 = uvw * uvw9;\n    vec3 uvw11 = uvw * uvw10;\n    vec3 uvw12 = uvw * uvw11;\n    vec3 uvw13 = uvw * uvw12;\n    vec3 uvw14 = uvw * uvw13;\n    vec3 uvw15 = uvw * uvw14;\n    vec3 uvw16 = uvw * uvw15;\n    vec3 uvw17 = uvw * uvw16;\n    vec3 uvw18 = uvw * uvw17;\n    vec3 uvw19 = uvw * uvw18;\n    vec3 uvw20 = uvw * uvw19;\n    vec3 uvw21 = uvw * uvw20;\n    vec3 uvw22 = uvw * uvw21;\n    vec3 uvw23 = uvw * uvw22;\n    vec3 uvw24 = uvw * uvw23;\n    vec3 uvw25 = uvw * uvw24;\n    vec3 uvw26 = uvw * uvw25;\n    vec3 uvw27 = uvw * uvw26;\n", "\n    float d = dot( nor, rd );\n    if( d < 0.0 ) return 0.0;\n    float t = ( d + rad ) / d;\n    if( t < 0.0 ) return 0.0;\n    float u = ( ro - cen ) / rd;\n    if( u < 0.0 || u > 1.0 ) return 0.0;\n    return t;\n}\n\n// ray-disk intersection\nvec", "\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 v = rd - ro;\n    vec3 w = v.cross(d);\n    vec3 u = v.cross(w);\n    vec3 v = v.cross(w);\n    vec3 s = v.cross(u);\n    vec3 t = v.cross(s);\n    vec3 x = s.cross(w);\n    vec3 y = t.cross(w);\n    vec3 z = t.cross(x);\n    vec3 r = r.cross(w);\n    vec3 d = d.cross(w);\n    vec3 u = u.cross(w);\n    vec3 v = v.cross(w);\n    vec3 w = w.cross(v);\n    vec3 s = s.cross(v);\n    vec3 t = t.cross(v);\n    vec3 x = x.cross(v);\n    vec3 y = y.cross(v);\n    vec3 z = z.cross(v);\n    vec3 r = r.cross(w);\n    vec3 d = d.cross(w);\n    vec3 u = u.cross(w);\n    vec3 v = v.cross(w);\n    vec3 w = w.cross(v);\n    vec3 s = s.cross(v);\n    vec3 t = t.cross(v);\n    vec3 x = x.cross(v);\n    vec3 y = y.cross(v);\n    vec3 z = z.cross(v);\n    vec3 r = r.cross(w);\n    vec3 d = d.cross(w);\n    vec3 u = u.cross(w);\n    vec3 v = v.cross(w);\n    vec3 w = w.cross(v);\n    vec3 s = s.cross(v);\n    vec3 t = t.cross(v);\n    vec3 x = x.cross(v);\n    vec3 y = y.cross(v);\n    vec3 z = z.cross(v);\n    vec3 r = r.cross(w);\n    vec3 d = d.cross(", "\n    vec3 a = pb - pa;\n    vec3 b = vec3( 0.0f, 0.0f, 1.0f );\n    vec3 c = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 d = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 e = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 f = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 g = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 h = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 i = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 j = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 k = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 l = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 m = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 n = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 o = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 p = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 q = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 r = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 s = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 t = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 u = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 v = vec3( 0.0f, 0.0f, 0.", "\n    vec3 r = ro - pa;\n    vec3 d = pb - pa;\n    float t = dot( r, d ) / ( ra * ra + dot( d, d ) );\n    if( t > 1.0 )\n        t = 1.0;\n    if( t < 0.0 )\n        t = 0.0;\n    vec3 n = ( r * ( 1.0 - t ) + d * t );\n    return vec4( t, n, 0.0, 1.0 );\n}\n\n// ray-plane intersection (returns t and normal)\nvec", "\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 s = rd - ro;\n    vec3 t = r - s;\n    vec3 u = t * t - s * s;\n    vec3 v = 2 * (r * t - d * s);\n    vec3 w = 2 * (r * s - d * t);\n    vec3 x = u * v - w * u;\n    vec3 y = u * w - v * w;\n    vec3 z = u * v + w * u;\n    return vec3( x, y, z );\n}\n\n// ray-box intersection\nvec", "\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.", "\n    vec3 n = (a-b).normalize();\n    vec3 v = (pos-a).normalize();\n    float d = dot(n,v);\n    if (d < 0.0)\n        return n;\n    else\n    {\n        vec3 n2 = (n*d).normalize();\n        vec3 v2 = (v*d).normalize();\n        return (n2+v2).normalize();\n    }\n}\n\n// compute the distance from a point to a plane\nfloat", "\n    vec3 r = ro - rd;\n    vec3 d = rd - rad;\n    vec3 s = r - d;\n    return (r.dot(s) > 0)? (r.dot(d) < 0)? (s.dot(d) > 0)? (s.dot(r) < 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) > 0) : (s.dot(r) < 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot(r) > 0) : (s.dot(d) < 0) : (s.dot", "\n    vec3 v = rd - ro;\n    vec3 vn = normalize( v );\n    vec3 vn2 = normalize( vn * -1.0 );\n    vec3 vn3 = normalize( vn * -2.0 );\n    vec3 vn4 = normalize( vn * -3.0 );\n    vec3 vn5 = normalize( vn * -4.0 );\n    vec3 vn6 = normalize( vn * -5.0 );\n    vec3 vn7 = normalize( vn * -6.0 );\n    vec3 vn8 = normalize( vn * -7.0 );\n    vec3 vn9 = normalize( vn * -8.0 );\n    vec3 vn10 = normalize( vn * -9.0 );\n    vec3 vn11 = normalize( vn * -10.0 );\n    vec3 vn12 = normalize( vn * -11.0 );\n    vec3 vn13 = normalize( vn * -12.0 );\n    vec3 vn14 = normalize( vn * -13.0 );\n    vec3 vn15 = normalize( vn * -14.0 );\n    vec3 vn16 = normalize( vn * -15.0 );\n    vec3 vn17 = normalize( vn * -16.0 );\n    vec3 vn18 = normalize( vn * -17.0 );\n    vec3 vn19 = normalize( vn * -18.0 );\n    vec3 vn20 = normalize( vn * -19.0 );\n    vec3 vn21 = normalize( vn * -20.0 );\n    vec3 vn22 = normalize( vn * -21.0 );\n    vec3 vn23 = normalize( vn * -22.0 );\n    vec3 vn24 = normalize( vn * -23.0 );\n    vec3 vn25 = normalize( vn * -24.0 );\n    vec3 vn26 = normalize( vn * -25.0 );\n    vec3 vn27 = normalize( vn *", "\n    vec3 a = (1.0f/sqrt(5.0f))*(1.0f - sqrt(5.0f));\n    vec3 b = (1.0f/sqrt(5.0f))*(1.0f + sqrt(5.0f));\n    vec3 c = (1.0f/sqrt(5.0f))*(1.0f + 2.0f*sqrt(5.0f));\n    vec3 d = (1.0f/sqrt(5.0f))*(1.0f - 2.0f*sqrt(5.0f));\n\n    float x = (i/n)*a;\n    float y = (i/n)*b;\n    float z = (i/n)*c;\n\n    vec3 f = (1.0f/sqrt(3.0f))*(x*x + y*y - z*z);\n    vec3 g = (1.0f/sqrt(3.0f))*(2.0f*x*y + 2.0f*y*z - 2.0f*x*z);\n    vec3 h = (1.0f/sqrt(3.0f))*(2.0f*x*x - 2.0f*y*y + 2.0f*z*z);\n\n    vec3 f1 = (1.0f/sqrt(3.0f))*(x*x + y*y - z*z);\n    vec3 g1 = (1.0f/sqrt(3.0f))*(2.0f*x*y + 2.0f*y*z - 2.0f*x*z);\n    vec3 h1 = (1.0f/sqrt(3.0f))*(2.0f*x*x - 2.0f*y*y + 2.0f*z*z);\n\n    vec3 f2 = (1.0f/sqrt(3.0f))*(x*x + y*y - z*z);\n    vec3 g2 = (1.0f/sqrt(3.0f))*(2", "\n    vec3 v = rd - ro;\n    mat3 res = mat3( 1, 0, 0, 0, 0, 1, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 1, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 1 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n    resS = res;\n    res = mat3( 0, 0, 0, 0, 0, 0,", "\n    vec3 x = p.x;\n    vec3 y = p.y;\n    vec3 z = p.z;\n    vec3 dx = x - x_mean;\n    vec3 dy = y - y_mean;\n    vec3 dz = z - z_mean;\n    vec3 ddx = ddx_mean * dx;\n    vec3 ddy = ddy_mean * dy;\n    vec3 ddz = ddz_mean * dz;\n    return vec3(dx, dy, dz);\n}\n\n// return the mean of the noise (in x) and its derivatives (in yz)\nvec", "\n    float dx = p.x - size.x / 2;\n    float dy = p.y - size.y / 2;\n    return std::sqrt(dx * dx + dy * dy) - radius;\n}\n\nfloat", "\n    vec2 u = uv - orient;\n    vec2 v = uv - orient.rotate(u.angle);\n    return uv - (u.length() + v.length()) * orient.rotate(atan2(v.y, v.x));\n}\n\n// Pattern 2\nvec", "\n    vec2 u = uv - orient;\n    vec2 v = uv + orient;\n    return vec3(u, v, uv);\n}\n\n// Pattern 3\nvec", "\n    float x = p.x;\n    float y = p.y;\n    float dx = ddx.x;\n    float dy = ddy.y;\n    float dx2 = dx*dx;\n    float dy2 = dy*dy;\n    float dxdy = dx*dy;\n    float dxdy2 = dxdy*dxdy;\n    float dxdy3 = dxdy*dxdy;\n    float dxdy4 = dxdy*dxdy;\n    float dxdy5 = dxdy*dxdy;\n    float dxdy6 = dxdy*dxdy;\n    float dxdy7 = dxdy*dxdy;\n    float dxdy8 = dxdy*dxdy;\n    float dxdy9 = dxdy*dxdy;\n    float dxdy10 = dxdy*dxdy;\n    float dxdy11 = dxdy*dxdy;\n    float dxdy12 = dxdy*dxdy;\n    float dxdy13 = dxdy*dxdy;\n    float dxdy14 = dxdy*dxdy;\n    float dxdy15 = dxdy*dxdy;\n    float dxdy16 = dxdy*dxdy;\n    float dxdy17 = dxdy*dxdy;\n    float dxdy18 = dxdy*dxdy;\n    float dxdy19 = dxdy*dxdy;\n    float dxdy20 = dxdy*dxdy;\n    float dxdy21 = dxdy*dxdy;\n    float dxdy22 = dxdy*dxdy;\n    float dxdy23 = dxdy*dxdy;\n    float dxdy24 = dxdy*dxdy;\n    float dxdy25 = dxdy*dxdy;\n    float dxdy26 = dxdy*dxdy;\n    float dxdy27 = dxdy*dxdy;\n    float dxdy28 = dxdy*dxdy;\n    float dxdy29 = dxdy*dxdy;\n    float dxdy30 = dxdy*dxdy;\n    float dxdy31 = dxdy*dxdy;\n    float dxdy32 = dxdy*dxdy;\n    float dxdy33 = dxdy*dxdy;\n    float dxdy34 = dxdy*dxdy;\n    float dxdy35 = dxdy*dxdy;\n    ", "\n    vec3 d = vec3(0,0,0);\n    d[0] = -p[1]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2] + p[0]*p[1] + p[0]*p[2] - p[0]*p[1] - p[0]*p[2]", "\n    v33 c = a;\n    c.x = b.x;\n    c.y = b.y;\n    c.z = b.z;\n}\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think", "\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nvec", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//compute the dot product of two vectors\n//this is the same as the dot product of two vectors in 3d space\n//this is the same as the cosine of the angle between the two vectors\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n//this is the same as the projection of one vector onto another\n", "\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BB\nvec", "\n    return a.x*b.x + a.y*b.y;\n}\n\n//dotprodiect on v33s\nvec", "\n    return vec2(a.x*b.x,a.y*b.y);\n}\n\n//dual mult\nv33 mul(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec4 b){\n    return vec4(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec5 b){\n    return vec5(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec6 b){\n    return vec6(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w,a.y*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec7 b){\n    return vec7(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w,a.y*b.w,a.z*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec8 b){\n    return vec8(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w,a.y*b.w,a.z*b.w,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec9 b){\n    return vec9(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b", "\n    float a=dot(p,w);\n    if(a<0.0f){\n        return 0.0f;\n    }\n    return 1.0f;\n}\n\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2", "\n    float a=0.0f,b=0.0f,c=0.0f,d=0.0f,e=0.0f,f=0.0f,g=0.0f,h=0.0f,i=0.0f,j=0.0f,k=0.0f,l=0.0f,m=0.0f,n=0.0f,o=0.0f,p=0.0f,q=0.0f,r=0.0f,s=0.0f,t=0.0f,u=0.0f,v=0.0f,w=0.0f,x=0.0f,y=0.0f,z=0.0f;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            a+=p[i]*w[j];\n            b+=p[i+1]*w[j];\n            c+=p[i+2]*w[j];\n            d+=p[i]*w[j+1];\n            e+=p[i+1]*w[j+1];\n            f+=p[i+2]*w[j+1];\n            g+=p[i]*w[j+2];\n            h+=p[i+1]*w[j+2];\n            i+=3;\n            j+=3;\n        }\n        for(int k=0;k<3;k++){\n            for(int l=0;l<3;l++){\n                a+=p[k]*w[l];\n                b+=p[k+1]*w[l];\n                c+=p[k+2]*w[l];\n                d+=p[k]*w[l+1];\n                e+=p[k+1]*w[l+1];\n                f+=p[k+2]*w[l+1];\n                g+=p[k]*w[l+2];\n                h+=p[k+1]*w[l+2];", "\n    vec4 sf = s.xyzw;\n    vec4 sf2 = sf.xyzw;\n    vec4 sf3 = sf.xyzw;\n    vec4 sf4 = sf.xyzw;\n    vec4 sf5 = sf.xyzw;\n    vec4 sf6 = sf.xyzw;\n    vec4 sf7 = sf.xyzw;\n    vec4 sf8 = sf.xyzw;\n    vec4 sf9 = sf.xyzw;\n    vec4 sf10 = sf.xyzw;\n    vec4 sf11 = sf.xyzw;\n    vec4 sf12 = sf.xyzw;\n    vec4 sf13 = sf.xyzw;\n    vec4 sf14 = sf.xyzw;\n    vec4 sf15 = sf.xyzw;\n    vec4 sf16 = sf.xyzw;\n    vec4 sf17 = sf.xyzw;\n    vec4 sf18 = sf.xyzw;\n    vec4 sf19 = sf.xyzw;\n    vec4 sf20 = sf.xyzw;\n    vec4 sf21 = sf.xyzw;\n    vec4 sf22 = sf.xyzw;\n    vec4 sf23 = sf.xyzw;\n    vec4 sf24 = sf.xyzw;\n    vec4 sf25 = sf.xyzw;\n    vec4 sf26 = sf.xyzw;\n    vec4 sf27 = sf.xyzw;\n    vec4 sf28 = sf.xyzw;\n    vec4 sf29 = sf.xyzw;\n    vec4 sf30 = sf.xyzw;\n    vec4 sf31 = sf.xyzw;\n    vec4 sf32 = sf.xyzw;\n    vec4 sf33 = sf.xyzw;\n    vec4 sf34 = sf.xyzw;\n    vec4", "\n    vec3 n2 = n.normalize();\n    vec3 n3 = n2.cross(n);\n    vec3 n4 = n2.cross(n3);\n    vec3 n5 = n3.cross(n4);\n    vec3 n6 = n4.cross(n5);\n    vec3 n7 = n5.cross(n6);\n    vec3 n8 = n6.cross(n7);\n    vec3 n9 = n7.cross(n8);\n    vec3 n10 = n8.cross(n9);\n    vec3 n11 = n9.cross(n10);\n    vec3 n12 = n10.cross(n11);\n    vec3 n13 = n11.cross(n12);\n    vec3 n14 = n12.cross(n13);\n    vec3 n15 = n13.cross(n14);\n    vec3 n16 = n14.cross(n15);\n    vec3 n17 = n15.cross(n16);\n    vec3 n18 = n16.cross(n17);\n    vec3 n19 = n17.cross(n18);\n    vec3 n20 = n18.cross(n19);\n    vec3 n21 = n19.cross(n20);\n    vec3 n22 = n20.cross(n21);\n    vec3 n23 = n21.cross(n22);\n    vec3 n24 = n22.cross(n23);\n    vec3 n25 = n23.cross(n24);\n    vec3 n26 = n24.cross(n25);\n    vec3 n27 = n25.cross(n26);\n    vec3 n28 = n26.cross(n27);\n    vec3 n29 = n27.cross(n28);\n    vec3 n30 = n28.cross(n29);\n    vec3 n31 = n29.cross(n30);\n    vec3 n32 = n30.cross(n31);\n    vec3 n33 = n31.cross(n32);\n    vec3 n34 = n32.cross(n33);\n    vec3 n35 = n33.cross(n34);\n    vec3 n36", "\n    // Get the bounding box of the quadratic bezier\n    vec2 p0b = p0;\n    vec2 p1b = p1;\n    vec2 p2b = p2;\n\n    // Get the bounding box of the quadratic bezier\n    p0b.x = min(p0.x, p1.x, p2.x);\n    p0b.y = min(p0.y, p1.y, p2.y);\n    p1b.x = max(p0.x, p1.x, p2.x);\n    p1b.y = max(p0.y, p1.y, p2.y);\n    p2b.x = max(p0.x, p1.x, p2.x);\n    p2b.y = max(p0.y, p1.y, p2.y);\n\n    // Get the bounding box of the quadratic bezier\n    vec2 p0b2 = p0b;\n    vec2 p1b2 = p1b;\n    vec2 p2b2 = p2b;\n\n    // Get the bounding box of the quadratic bezier\n    p0b2.x = min(p0b.x, p1b.x, p2b.x);\n    p0b2.y = min(p0b.y, p1b.y, p2b.y);\n    p1b2.x = max(p0b.x, p1b.x, p2b.x);\n    p1b2.y = max(p0b.y, p1b.y, p2b.y);\n    p2b2.x = max(p0b.x, p1b.x, p2b.x);\n    p2b2.y = max(p0b.y, p1b.y, p2b.y);\n\n    // Get the bounding box of the quadratic bezier\n    vec2 p0b3 = p0b;\n    vec2 p1b3 = p1b;\n    vec2 p2b3 = p", "\n    vec2 p3 = p0 + (p1 - p0) * 0.5;\n    vec2 p4 = p2 + (p1 - p2) * 0.5;\n    return vec2(p3, p4);\n}\n\n// Approximated BBox to a cubic bezier\nvec", "\n    //---------------------------------------------------------------------------------------\n    // compute the bounding box for the bezier curve\n    //---------------------------------------------------------------------------------------\n    vec3 p0p1 = p1 - p0;\n    vec3 p1p2 = p2 - p1;\n    vec3 p2p3 = p3 - p2;\n    vec3 p0p2 = p2 - p0;\n    vec3 p0p3 = p3 - p0;\n    vec3 p1p3 = p3 - p1;\n\n    vec3 a = p0p1 + p0p2 + p0p3;\n    vec3 b = p1p2 + p1p3 + p1p3;\n    vec3 c = p2p3 + p2p3 + p2p3;\n    vec3 d = p0p1 + p1p2 + p2p3;\n\n    vec3 e = p0p1 + p1p2 + p0p3;\n    vec3 f = p1p2 + p2p3 + p1p3;\n    vec3 g = p2p3 + p0p3 + p2p3;\n    vec3 h = p0p1 + p1p2 + p2p3;\n\n    vec3 i = p0p1 + p1p2 + p0p3;\n    vec3 j = p1p2 + p2p3 + p1p3;\n    vec3 k = p2p3 + p0p3 + p2p3;\n    vec3 l = p0p1 + p1p2 + p2p3;\n\n    vec3 m = p0p1 + p1p2 + p0p3;\n    vec3 n = p1p2 + p2p3 + p1p3;\n    vec3 o = p2p3 + p0p3 + p2p3;\n    vec3 p = p0p1 + p1p2 + p2p3;\n\n    vec3 q = p0p1 + p1p2 + p0p3;\n    vec3 r = p1p2 + p2p3 + p1p3;\n    vec3 s = p2p3 + p0p3 + p2", "\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box of the cubic bezier\n    vec2 bbox = bbox(p0, p1, p2, p3);\n\n    // Get the bounding box", "\n    vec2 u = p1 - p0;\n    vec2 v = p2 - p1;\n    vec2 w = p3 - p2;\n    vec2 uv = u * v;\n    vec2 uw = u * w;\n    vec2 vw = v * w;\n    vec2 uvw = uv * w;\n    vec2 uvuv = uv * uv;\n    vec2 uvuvw = uv * uvw;\n    vec2 uvuvuv = uvuv * uvuv;\n    vec2 uvuvuvw = uvuv * uvuvw;\n    vec2 uvuvuvuv = uvuv * uvuvuv;\n    vec2 uvuvuvuvw = uvuv * uvuvuvw;\n    vec2 uvuvuvuvuv = uvuv * uvuvuvuv;\n    vec2 uvuvuvuvuvw = uvuv * uvuvuvuvw;\n    vec2 uvuvuvuvuvuv = uvuv * uvuvuvuvuv;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuvuvuvuvuvw = uvuv * uvuvuvuvuvw;\n    vec2 uvuv", "\n    // Find the intersection of the ray with the triangle.\n    // Returns { t, u, v }\n    vec3 t0, t1, t2;\n    vec3 u0, u1, u2;\n    vec3 v0, v1, v2;\n    vec3 t, u, v;\n\n    // Find the intersection of the ray with the triangle.\n    // Returns { t, u, v }\n    t0 = rayIntersect( ro, rd, v0, v1, v2 );\n    t1 = rayIntersect( ro, rd, v1, v2, v0 );\n    t2 = rayIntersect( ro, rd, v2, v0, v1 );\n\n    // Find the intersection of the triangle with the ray.\n    // Returns { t, u, v }\n    u0 = triangleIntersect( v0, v1, v2, ro, rd );\n    u1 = triangleIntersect( v1, v2, v0, ro, rd );\n    u2 = triangleIntersect( v2, v0, v1, ro, rd );\n\n    // Find the intersection of the triangle with the ray.\n    // Returns { t, u, v }\n    v0 = triangleIntersect( v0, v1, v2, v0, v1, v2 );\n    v1 = triangleIntersect( v1, v2, v0, v0, v1, v2 );\n    v2 = triangleIntersect( v2, v0, v1, v0, v1, v2 );\n\n    // Find the intersection of the triangle with the ray.\n    // Returns { t, u, v }\n    t = max( min( t0, t1, t2 ), 0.0 );\n    u = max( min( u0, u1, u2 ), 0.0 );\n    v = max( min( v0, v1, v2 ), 0.0 );\n\n    // Find the intersection of the triangle with the ray.\n    // Returns { t, u, v }\n    t = max( min( t, 1.0 ), 0.0 );\n    u = max( min( u, 1.0 ), 0.0 );\n", "\n    float t0 = (v0.x*(nor.y*v1.z - nor.z*v1.y) + v0.y*(nor.z*v1.x - nor.x*v1.z) + v0.z*(nor.x*v1.y - nor.y*v1.x)) / (v0.x*v1.y*v2.z - v0.y*v1.z*v2.x - v0.z*v1.x*v2.y + v0.x*v1.y*v2.x + v0.y*v1.z*v2.x + v0.z*v1.x*v2.y);\n    float t1 = (v0.x*(nor.y*v2.z - nor.z*v2.y) + v0.y*(nor.z*v2.x - nor.x*v2.z) + v0.z*(nor.x*v2.y - nor.y*v2.x)) / (v0.x*v1.y*v2.z - v0.y*v1.z*v2.x - v0.z*v1.x*v2.y + v0.x*v1.y*v2.x + v0.y*v1.z*v2.x + v0.z*v1.x*v2.y);\n    float t2 = (v0.x*(nor.y*v1.z - nor.z*v1.y) + v0.y*(nor.z*v1.x - nor.x*v1.z) + v0.z*(nor.x*v1.y - nor.y*v1.x)) / (v0.x*v1.y*v2.z - v0.y*v1.z*v2.x - v0.z*v1.x*v2.y + v0.x*v1.y*v2.x + v0.y*v1.z*v2.x + v0.z*v1.", "\n    float a = A.x*A.x + A.y*A.y;\n    float b = 2*A.x*B.x + 2*A.y*B.y;\n    float c = B.x*B.x + B.y*B.y;\n    float d = 2*B.x*C.x + 2*B.y*C.y;\n    float e = C.x*C.x + C.y*C.y;\n    float f = A.x*C.x + A.y*C.y;\n    float g = B.x*C.x + B.y*C.y;\n    float h = pos.x*pos.x + pos.y*pos.y;\n    float i = 2*pos.x*A.x + 2*pos.y*A.y;\n    float j = A.x*pos.x + A.y*pos.y;\n    float k = 2*pos.x*B.x + 2*pos.y*B.y;\n    float l = B.x*pos.x + B.y*pos.y;\n    float m = pos.x*pos.x + pos.y*pos.y;\n    float n = 2*pos.x*C.x + 2*pos.y*C.y;\n    float o = C.x*pos.x + C.y*pos.y;\n    float p = 2*pos.x*A.x + 2*pos.y*A.y;\n    float q = A.x*pos.x + A.y*pos.y;\n    float r = 2*pos.x*B.x + 2*pos.y*B.y;\n    float s = B.x*pos.x + B.y*pos.y;\n    float t = pos.x*pos.x + pos.y*pos.y;\n    float u = 2*pos.x*C.x + 2*pos.y*C.y;\n    float v = C.x*pos.x + C.y*pos.y;\n    float w = 2*pos.x*A.x + 2*pos", "\n    float x = p.x;\n    float y = p.y;\n    float h = he;\n    float r1 = r1;\n    float r2 = r2;\n    float h1 = r1;\n    float h2 = r2;\n    float h3 = h - h1 - h2;\n    float h4 = h - h1;\n    float h5 = h - h2;\n    float h6 = h - h3;\n    float h7 = h - h4;\n    float h8 = h - h5;\n    float h9 = h - h6;\n    float h10 = h - h7;\n    float h11 = h - h8;\n    float h12 = h - h9;\n    float h13 = h - h10;\n    float h14 = h - h11;\n    float h15 = h - h12;\n    float h16 = h - h13;\n    float h17 = h - h14;\n    float h18 = h - h15;\n    float h19 = h - h16;\n    float h20 = h - h17;\n    float h21 = h - h18;\n    float h22 = h - h19;\n    float h23 = h - h20;\n    float h24 = h - h21;\n    float h25 = h - h22;\n    float h26 = h - h23;\n    float h27 = h - h24;\n    float h28 = h - h25;\n    float h29 = h - h26;\n    float h30 = h - h27;\n    float h31 = h - h28;\n    float h32 = h - h29;\n    float h33 = h - h30;\n    float h34 = h - h31;\n    float h35 = h - h32;\n    float h36 = h - h33;\n    float h37 = h - h34;\n    float h38 = h - h35;\n    float h39 = h - h36;\n    float h40 = h - h37;\n    float h41 = h - h38;\n    float h42 = h - h39;\n    float h43 = h -", "\n    float s = 0.0;\n    float s1 = 0.0;\n    float s2 = 0.0;\n    float s3 = 0.0;\n    float s4 = 0.0;\n    float s5 = 0.0;\n    float s6 = 0.0;\n    float s7 = 0.0;\n    float s8 = 0.0;\n    float s9 = 0.0;\n    float s10 = 0.0;\n    float s11 = 0.0;\n    float s12 = 0.0;\n    float s13 = 0.0;\n    float s14 = 0.0;\n    float s15 = 0.0;\n    float s16 = 0.0;\n    float s17 = 0.0;\n    float s18 = 0.0;\n    float s19 = 0.0;\n    float s20 = 0.0;\n    float s21 = 0.0;\n    float s22 = 0.0;\n    float s23 = 0.0;\n    float s24 = 0.0;\n    float s25 = 0.0;\n    float s26 = 0.0;\n    float s27 = 0.0;\n    float s28 = 0.0;\n    float s29 = 0.0;\n    float s30 = 0.0;\n    float s31 = 0.0;\n    float s32 = 0.0;\n    float s33 = 0.0;\n    float s34 = 0.0;\n    float s35 = 0.0;\n    float s36 = 0.0;\n    float s37 = 0.0;\n    float s38 = 0.0;\n    float s39 = 0.0;\n    float s40 = 0.0;\n    float s41 = 0.0;\n    float s42 = 0.0;\n    float s43 = 0.0;\n    float s44 = 0.0;\n    float s45 = 0.0;\n    float s46 = 0.0;\n    float s47 = 0.0;\n    float s48 = 0.0;\n    float s49 = 0.0;\n    float s50 = 0.0;\n    float", "\n    vec3 n = vec3(0,0,0);\n    vec3 v1 = vec3(pos.x,pos.y,pos.z);\n    vec3 v2 = vec3(pos.x+1,pos.y,pos.z);\n    vec3 v3 = vec3(pos.x,pos.y+1,pos.z);\n    vec3 v4 = vec3(pos.x+1,pos.y+1,pos.z);\n    vec3 v5 = vec3(pos.x,pos.y,pos.z+1);\n    vec3 v6 = vec3(pos.x+1,pos.y,pos.z+1);\n    vec3 v7 = vec3(pos.x,pos.y+1,pos.z+1);\n    vec3 v8 = vec3(pos.x+1,pos.y+1,pos.z+1);\n    vec3 v9 = vec3(pos.x,pos.y,pos.z+1);\n    vec3 v10 = vec3(pos.x+1,pos.y,pos.z+1);\n    vec3 v11 = vec3(pos.x,pos.y+1,pos.z+1);\n    vec3 v12 = vec3(pos.x+1,pos.y+1,pos.z+1);\n    vec3 v13 = vec3(pos.x,pos.y,pos.z+1);\n    vec3 v14 = vec3(pos.x+1,pos.y,pos.z+1);\n    vec3 v15 = vec3(pos.x,pos.y+1,pos.z+1);\n    vec3 v16 = vec3(pos.x+1,pos.y+1,pos.z+1);\n    vec3 v17 = vec3(pos.x,pos.y,pos.z+1);\n    vec3 v18 = vec3(pos.x+1,pos.y,pos.z+1);\n    vec3 v19 = vec3(pos.x,pos.y+1,pos.z+1);\n    vec3 v20 = vec3(pos.x", "\n    float t = (tmin + tmax) / 2.0f;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41 * t;\n    float t43 = t42 * t;\n    float t44 = t43 * t;\n    float t45 = t44 * t;\n    float t46 = t45 * t;", "\n    float h = 0.0f;\n    for( int i = 0; i < q.x; i++ )\n        h += q.x[i] * q.x[i];\n    for( int i = 0; i < q.y; i++ )\n        h += q.y[i] * q.y[i];\n    return h;\n}\n\n// random hash\nfloat", "\n    float x_norm = x.x / x.x + x.y / x.y;\n    float x_norm_sq = x_norm * x_norm;\n    float x_norm_sq_sq = x_norm_sq * x_norm_sq;\n    float x_norm_sq_sq_sq = x_norm_sq_sq * x_norm_sq_sq;\n    float x_norm_sq_sq_sq_sq = x_norm_sq_sq_sq * x_norm_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq * x_norm_sq_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq_sq * x_norm_sq_sq_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq_sq_sq_sq * x_norm_sq_sq_sq_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq * x_norm_sq_sq_sq_sq_sq_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq * x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n    float x_norm_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = x_norm_sq_sq_sq_sq_sq_", "\n    float x0 = x.x;\n    float x1 = x.y;\n    float x2 = x.x*x.x + x.y*x.y;\n    float x3 = x.x*x.x*x.x + x.y*x.y*x.y;\n    float x4 = x.x*x.x*x.x*x.x + x.y*x.y*x.y*x.y;\n    float x5 = x.x*x.x*x.x*x.x*x.x + x.y*x.y*x.y*x.y*x.y;\n    float x6 = x.x*x.x*x.x*x.x*x.x*x.x;\n    float x7 = x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x8 = x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x9 = x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x10 = x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x11 = x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x12 = x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x13 = x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x*x.x;\n    float x", "\n    float a = r.x;\n    float b = r.y;\n    float c = r.z;\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float e = sqrt(a*a + b*b + c*c);\n    float f = sqrt(a*a + b*b + c*c);\n    float g = sqrt(a*a + b*b + c*c);\n    float h = sqrt(a*a + b*b + c*c);\n    float i = sqrt(a*a + b*b + c*c);\n    float j = sqrt(a*a + b*b + c*c);\n    float k = sqrt(a*a + b*b + c*c);\n    float l = sqrt(a*a + b*b + c*c);\n    float m = sqrt(a*a + b*b + c*c);\n    float n = sqrt(a*a + b*b + c*c);\n    float o = sqrt(a*a + b*b + c*c);\n    float p = sqrt(a*a + b*b + c*c);\n    float q = sqrt(a*a + b*b + c*c);\n    float r = sqrt(a*a + b*b + c*c);\n    float s = sqrt(a*a + b*b + c*c);\n    float t = sqrt(a*a + b*b + c*c);\n    float u = sqrt(a*a + b*b + c*c);\n    float v = sqrt(a*a + b*b + c*c);\n    float w = sqrt(a*a + b*b + c*c);\n    float x = sqrt(a*a + b*b + c*c);\n    float y = sqrt(a*a + b*b + c*c);\n    float z = sqrt(a*a + b*b + c*c);\n    float a1 = sqrt(a*a +", "\n    float x = p.x - r.x;\n    float y = p.y - r.y;\n    float z = p.z - r.z;\n    float a = sqrt(x*x + y*y);\n    float b = sqrt(x*x + z*z);\n    float c = sqrt(y*y + z*z);\n    float d = sqrt(a*a + b*b + c*c);\n    return d;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat", "\n    float d = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        d += (p[i] - r[i]) * (p[i] - r[i]);\n    }\n    return sqrt(d);\n}\n\n// generic ellipsoid - good approximated distance\nfloat", "\n    float a = r.x;\n    float b = r.y;\n    float c = r.z;\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float e = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float f = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float g = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float h = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float i = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float j = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float k = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float l = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float m = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float n = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float o = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float p = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float q = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float r = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float s =", "\n    float x, y;\n    float gradBox[4][4] = {\n        {-1, -1, -1, -1},\n        {-1,  0,  0, -1},\n        {-1,  0,  1, -1},\n        {-1, -1, -1, -1}\n    };\n    x = p.x;\n    y = p.y;\n    float sum = 0;\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            sum += gradBox[i][j] * p.x + gradBox[i][j] * p.y;\n        }\n    }\n    return sum;\n}\n\nfloat", "\n    return (a*x) / (1.0 + a*x);\n}\n\n// Compute the integral of the bias function from 0 to x\nfloat", "\n    return (x < p)? (x - p) / (p - x) : (2 * p - x) / (2 * p - x - 1);\n}\n\n// biased sawtooth\nfloat", "\n    vec3 r = vec3( h, h, h );\n    vec3 g = vec3( h, h, h );\n    vec3 b = vec3( h, h, h );\n\n    vec3 r_prime = vec3( h, h, h );\n    vec3 g_prime = vec3( h, h, h );\n    vec3 b_prime = vec3( h, h, h );\n\n    vec3 r_prime_prime = vec3( h, h, h );\n    vec3 g_prime_prime = vec3( h, h, h );\n    vec3 b_prime_prime = vec3( h, h, h );\n\n    vec3 r_prime_prime_prime = vec3( h, h, h );\n    vec3 g_prime_prime_prime = vec3( h, h, h );\n    vec3 b_prime_prime_prime = vec3( h, h, h );\n\n    vec3 r_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 g_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 b_prime_prime_prime_prime = vec3( h, h, h );\n\n    vec3 r_prime_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 g_prime_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 b_prime_prime_prime_prime_prime = vec3( h, h, h );\n\n    vec3 r_prime_prime_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 g_prime_prime_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 b_prime_prime_prime_prime_prime_prime = vec3( h, h, h );\n\n    vec3 r_prime_prime_prime_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 g_prime_prime_prime_prime_prime_prime_prime = vec3( h, h, h );\n    vec3 b_prime_prime_prime_prime", "\n    vec3 rp = rd - pa;\n    vec3 rp2 = rp * rp;\n    vec3 rp3 = rp2 * rp;\n    vec3 rp4 = rp3 * rp;\n    vec3 rp5 = rp4 * rp;\n    vec3 rp6 = rp5 * rp;\n    vec3 rp7 = rp6 * rp;\n    vec3 rp8 = rp7 * rp;\n    vec3 rp9 = rp8 * rp;\n    vec3 rp10 = rp9 * rp;\n    vec3 rp11 = rp10 * rp;\n    vec3 rp12 = rp11 * rp;\n    vec3 rp13 = rp12 * rp;\n    vec3 rp14 = rp13 * rp;\n    vec3 rp15 = rp14 * rp;\n    vec3 rp16 = rp15 * rp;\n    vec3 rp17 = rp16 * rp;\n    vec3 rp18 = rp17 * rp;\n    vec3 rp19 = rp18 * rp;\n    vec3 rp20 = rp19 * rp;\n    vec3 rp21 = rp20 * rp;\n    vec3 rp22 = rp21 * rp;\n    vec3 rp23 = rp22 * rp;\n    vec3 rp24 = rp23 * rp;\n    vec3 rp25 = rp24 * rp;\n    vec3 rp26 = rp25 * rp;\n    vec3 rp27 = rp26 * rp;\n    vec3 rp28 = rp27 * rp;\n    vec3 rp29 = rp28 * rp;\n    vec3 rp30 = rp29 * rp;\n    vec3 rp31 = rp30 * rp;\n    vec3 rp32 = rp31 * rp;\n    vec3 rp33 = rp32 * rp;\n    vec3 rp34 = rp33 * rp;\n    vec3 rp", "\n    float d = dot(a-b, p-b);\n    float d2 = d*d;\n    float d3 = d2*d;\n    float d4 = d3*d;\n    float d5 = d4*d;\n    float d6 = d5*d;\n    float d7 = d6*d;\n    float d8 = d7*d;\n    float d9 = d8*d;\n    float d10 = d9*d;\n    float d11 = d10*d;\n    float d12 = d11*d;\n    float d13 = d12*d;\n    float d14 = d13*d;\n    float d15 = d14*d;\n    float d16 = d15*d;\n    float d17 = d16*d;\n    float d18 = d17*d;\n    float d19 = d18*d;\n    float d20 = d19*d;\n    float d21 = d20*d;\n    float d22 = d21*d;\n    float d23 = d22*d;\n    float d24 = d23*d;\n    float d25 = d24*d;\n    float d26 = d25*d;\n    float d27 = d26*d;\n    float d28 = d27*d;\n    float d29 = d28*d;\n    float d30 = d29*d;\n    float d31 = d30*d;\n    float d32 = d31*d;\n    float d33 = d32*d;\n    float d34 = d33*d;\n    float d35 = d34*d;\n    float d36 = d35*d;\n    float d37 = d36*d;\n    float d38 = d37*d;\n    float d39 = d38*d;\n    float d40 = d39*d;\n    float d41 = d40*d;\n    float d42 = d41*d;\n    float d43 = d42*d;\n    float d44 = d43*d;\n    float d45 = d44*d;\n    float d46 = d45*d;\n    float", "\n    vec3 rdShadow = rd - r;\n    vec3 aShadow = a - r;\n    vec3 bShadow = b - r;\n    vec3 rdShadow2 = rdShadow * rdShadow;\n    vec3 aShadow2 = aShadow * aShadow;\n    vec3 bShadow2 = bShadow * bShadow;\n    vec3 rdShadow3 = rdShadow2 * rdShadow;\n    vec3 aShadow3 = aShadow2 * aShadow;\n    vec3 bShadow3 = bShadow2 * bShadow;\n    vec3 rdShadow4 = rdShadow3 * rdShadow;\n    vec3 aShadow4 = aShadow3 * aShadow;\n    vec3 bShadow4 = bShadow3 * bShadow;\n    vec3 rdShadow5 = rdShadow4 * rdShadow;\n    vec3 aShadow5 = aShadow4 * aShadow;\n    vec3 bShadow5 = bShadow4 * bShadow;\n    vec3 rdShadow6 = rdShadow5 * rdShadow;\n    vec3 aShadow6 = aShadow5 * aShadow;\n    vec3 bShadow6 = bShadow5 * bShadow;\n    vec3 rdShadow7 = rdShadow6 * rdShadow;\n    vec3 aShadow7 = aShadow6 * aShadow;\n    vec3 bShadow7 = bShadow6 * bShadow;\n    vec3 rdShadow8 = rdShadow7 * rdShadow;\n    vec3 aShadow8 = aShadow7 * aShadow;\n    vec3 bShadow8 = bShadow7 * bShadow;\n    vec3 rdShadow9 = rdShadow8 * rdShadow;\n    vec3 aShadow9 = aShadow8 * aShadow;\n    vec3 bShadow9 = bShadow8 * bShadow;\n    vec3 rdShadow10 = rdShadow9 * rdShadow;\n    vec3 aShadow10 = aShadow9 * aShadow;\n    vec3 bShadow10 = bShadow9 * bShadow;\n    vec3 rdShadow11 = rdShadow10 * rdShadow;\n    vec3 aShadow11 = aShadow10 * aShadow;\n    vec3 bShadow11 = bShadow10 * bShadow;", "\n    vec2 r1 = vec2(rad1, 0);\n    vec2 r2 = vec2(rad2, 0);\n    vec2 th = vec2(th, 0);\n\n    vec2 r = r1 + r2;\n    vec2 th = th + r2;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    vec2 r2 = r2 + th;\n\n    vec2 r1 = r1 + th;\n    ", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float s = x*x + y*y;\n    float c = sqrt(s);\n    float d = c*c - r*r;\n    float a = 2*r*c;\n    float b = -2*r*r*s;\n    float c = -2*r*r*d;\n    float d = 2*r*r*s*s;\n    float e = 2*r*r*s*s*s;\n    float f = 2*r*r*s*s*s*s;\n    float g = 2*r*r*s*s*s*s*s;\n    float h = 2*r*r*s*s*s*s*s*s;\n    float i = 2*r*r*s*s*s*s*s*s*s;\n    float j = 2*r*r*s*s*s*s*s*s*s*s*s;\n    float k = 2*r*r*s*s*s*s*s*s*s*s*s*s*s;\n    float l = 2*r*r*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*s*", "\n    vec3 n = vec3(0,0,0);\n    vec3 r = vec3(pos.x,pos.y,pos.z);\n    vec3 r2 = r*r;\n    vec3 r3 = r2*r;\n    vec3 r4 = r3*r;\n    n.x = 4*r.x*r2 - r4;\n    n.y = 4*r.y*r2 - r4;\n    n.z = 4*r.z*r2 - r4;\n    return n;\n}\n\nA:\n\nI think you are looking for the cross product.\nvec", "\n    float x = p.x * sca.x + p.y * sca.y;\n    float y = p.x * scb.x + p.y * scb.y;\n    float r = sqrt(x*x + y*y);\n    float theta = atan2(y,x);\n    float theta_a = theta + ra;\n    float theta_b = theta + rb;\n    float theta_a_b = theta_a - theta_b;\n    float theta_a_b_2 = theta_a_b * theta_a_b;\n    float theta_a_b_2_2 = theta_a_b_2 * theta_a_b_2;\n    float theta_a_b_2_2_2 = theta_a_b_2_2 * theta_a_b_2_2;\n    float theta_a_b_2_2_2_2 = theta_a_b_2_2_2 * theta_a_b_2_2_2;\n    float theta_a_b_2_2_2_2_2 = theta_a_b_2_2_2_2 * theta_a_b_2_2_2_2;\n    float theta_a_b_2_2_2_2_2_2 = theta_a_b_2_2_2_2_2_2 * theta_a_b_2_2_2_2_2;\n    float theta_a_b_2_2_2_2_2_2_2 = theta_a_b_2_2_2_2_2_2_2 * theta_a_b_2_2_2_2_2_2;\n    float theta_a_b_2_2_2_2_2_2_2_2 = theta_a_b_2_2_2_2_2_2_2_2 * theta_a_b_2_2_2_2_2_2_2;\n    float theta_a", "\n    float t = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    float t43 = 0.0;\n    float t44 = 0.0;\n    float t45 = 0.0;\n    float t46 = 0.0;\n    float t47 = 0.0;\n    float t48 = 0.0;\n    float t49 = 0.0;\n    float t50 = 0.0;\n    float", "\n    vec3 normal;\n    vec3 normal2;\n    vec3 normal3;\n    vec3 normal4;\n    vec3 normal5;\n    vec3 normal6;\n    vec3 normal7;\n    vec3 normal8;\n    vec3 normal9;\n    vec3 normal10;\n    vec3 normal11;\n    vec3 normal12;\n    vec3 normal13;\n    vec3 normal14;\n    vec3 normal15;\n    vec3 normal16;\n    vec3 normal17;\n    vec3 normal18;\n    vec3 normal19;\n    vec3 normal20;\n    vec3 normal21;\n    vec3 normal22;\n    vec3 normal23;\n    vec3 normal24;\n    vec3 normal25;\n    vec3 normal26;\n    vec3 normal27;\n    vec3 normal28;\n    vec3 normal29;\n    vec3 normal30;\n    vec3 normal31;\n    vec3 normal32;\n    vec3 normal33;\n    vec3 normal34;\n    vec3 normal35;\n    vec3 normal36;\n    vec3 normal37;\n    vec3 normal38;\n    vec3 normal39;\n    vec3 normal40;\n    vec3 normal41;\n    vec3 normal42;\n    vec3 normal43;\n    vec3 normal44;\n    vec3 normal45;\n    vec3 normal46;\n    vec3 normal47;\n    vec3 normal48;\n    vec3 normal49;\n    vec3 normal50;\n    vec3 normal51;\n    vec3 normal52;\n    vec3 normal53;\n    vec3 normal54;\n    vec3 normal55;\n    vec3 normal56;\n    vec3 normal57;\n    vec3 normal58;\n    vec3 normal59;\n    vec3 normal60;\n    vec3 normal61;\n    vec3 normal62;\n    vec3 normal63;\n    vec3 normal64;\n    vec3 normal65;\n    vec3 normal66;\n    vec3 normal67;\n    vec3 normal68;\n    vec3 normal69;\n    vec3 normal70;\n    vec3 normal71;\n    vec3 normal72;\n    vec3 normal73;\n    ", "\n    float t = time;\n    float tmin = tmax * mint;\n    float tmax = tmax * (1.0f - mint);\n    float t1 = tmin + t * (tmax - tmin);\n    float t2 = tmin + (t - tmin) * (tmax - tmin);\n    float t3 = tmin + (t - tmin) * (tmax - tmin);\n    float t4 = tmin + (t - tmin) * (tmax - tmin);\n    float t5 = tmin + (t - tmin) * (tmax - tmin);\n    float t6 = tmin + (t - tmin) * (tmax - tmin);\n    float t7 = tmin + (t - tmin) * (tmax - tmin);\n    float t8 = tmin + (t - tmin) * (tmax - tmin);\n    float t9 = tmin + (t - tmin) * (tmax - tmin);\n    float t10 = tmin + (t - tmin) * (tmax - tmin);\n    float t11 = tmin + (t - tmin) * (tmax - tmin);\n    float t12 = tmin + (t - tmin) * (tmax - tmin);\n    float t13 = tmin + (t - tmin) * (tmax - tmin);\n    float t14 = tmin + (t - tmin) * (tmax - tmin);\n    float t15 = tmin + (t - tmin) * (tmax - tmin);\n    float t16 = tmin + (t - tmin) * (tmax - tmin);\n    float t17 = tmin + (t - tmin) * (tmax - tmin);\n    float t18 = tmin + (t - tmin) * (tmax - tmin);\n    float t19 = tmin + (t - tmin) * (tmax - tmin);\n    float t20 = tmin + (t - tmin) * (tmax - tmin);\n    float t21 = tmin + (t - tmin) * (tmax - tmin", "\n    float x, y;\n    x = p.x;\n    y = p.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += p.x;\n    y += p.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += p.x;\n    y += p.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += p.x;\n    y += p.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += p.x;\n    y += p.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n", "\n    float y;\n    if( k>1 )\n    {\n        y=x*(k-1);\n    }\n    else\n    {\n        y=x;\n    }\n    return y;\n}\n\nA:\n\nYou can use the following function:\nfloat", "\n    vec3 sample_dir = normalize(sample_pos - surface_normal);\n    vec3 sample_color = sample_pos.xyz * background_col;\n    vec3 light_dir = normalize(light_dir);\n    vec3 light_color = light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir.xyz * light_dir", "\n    vec3 color = vec3(0, 1, 0);\n    vec3 distance = vec3(0, 0, 0);\n    vec3 light_dir_normalized = normalize(light_dir);\n    vec3 light_dir_perp = cross(light_dir_normalized, dir);\n    vec3 light_dir_parallel = dot(light_dir_normalized, dir);\n    vec3 light_dir_perp_parallel = light_dir_perp * light_dir_parallel;\n    vec3 light_dir_perp_perp = light_dir_perp * light_dir_perp;\n    vec3 light_dir_parallel_perp = light_dir_parallel * light_dir_perp;\n    vec3 light_dir_perp_perp_parallel = light_dir_perp_perp * light_dir_parallel;\n    vec3 light_dir_perp_perp_perp = light_dir_perp_perp * light_dir_perp;\n    vec3 light_dir_parallel_perp_perp = light_dir_parallel_perp * light_dir_perp;\n    vec3 light_dir_perp_perp_perp_parallel = light_dir_perp_perp_perp * light_dir_parallel;\n    vec3 light_dir_perp_perp_perp_perp = light_dir_perp_perp_perp * light_dir_perp;\n    vec3 light_dir_parallel_perp_perp_perp = light_dir_parallel_perp * light_dir_perp;\n    vec3 light_dir_perp_perp_perp_perp_parallel = light_dir_perp_perp_perp * light_dir_parallel;\n    vec3 light_dir_perp_perp_perp_perp_perp = light_dir_perp_perp_perp * light_dir_perp;\n    vec3 light_dir_parallel_perp_perp_perp_perp = light_dir_parallel_per", "\n    vec3 camera_vector;\n    vec3 normal;\n    vec3 ray_direction;\n    vec3 ray_origin;\n    vec3 ray_direction_normalized;\n    vec3 ray_origin_normalized;\n\n    //calculate the ray direction\n    ray_direction = coord - resolution.xy;\n    ray_direction_normalized = ray_direction / ray_direction.length();\n\n    //calculate the ray origin\n    ray_origin = resolution.xy;\n\n    //calculate the normal\n    normal = vec3(ray_direction_normalized.y, -ray_direction_normalized.x, 0);\n\n    //calculate the camera vector\n    camera_vector = normal * -1;\n\n    return camera_vector;\n}\n\n//this function calculates the scattering function\n//it takes the camera vector, the scattering function, and the pixel coordinates\n//and returns the scattering function at the pixel coordinates\nfloat", "\n    float s = 0.0;\n    float c2 = c.x*c.x + c.y*c.y;\n    float r = sqrt(p.x*p.x + p.y*p.y);\n    float theta = acos(c.x/r);\n    float phi = acos(c.y/r);\n    float phi2 = acos(c2/r*r);\n    float phi3 = acos(c2/r*r*r);\n    float phi4 = acos(c2/r*r*r*r);\n    float phi5 = acos(c2/r*r*r*r*r);\n    float phi6 = acos(c2/r*r*r*r*r*r);\n    float phi7 = acos(c2/r*r*r*r*r*r*r);\n    float phi8 = acos(c2/r*r*r*r*r*r*r*r);\n    float phi9 = acos(c2/r*r*r*r*r*r*r*r*r);\n    float phi10 = acos(c2/r*r*r*r*r*r*r*r*r*r);\n    float phi11 = acos(c2/r*r*r*r*r*r*r*r*r*r*r);\n    float phi12 = acos(c2/r*r*r*r*r*r*r*r*r*r*r*r);\n    float phi13 = acos(c2/r*r*r*r*r*r*r*r*r*r*r*r*r);\n    float phi14 = acos(c2/r*r*r*r*r*r*r*r*r*r*r*r*r*r);\n    float phi15 = acos(c2/r*r*r*r*r*r*r*r*r*r*r*r*r*r*r);\n    float phi16 =", "\n    // Get the material's color.\n    vec3 color = material_colors[material];\n\n    // Get the material's ambient, diffuse, and specular\n    // reflection coefficients.\n    float ambient = material_ambient[material];\n    float diffuse = material_diffuse[material];\n    float specular = material_specular[material];\n\n    // Get the material's normal.\n    vec3 normal = material_normals[material];\n\n    // Get the material's view vector.\n    vec3 view = view_vectors[material];\n\n    // Get the material's light vector.\n    vec3 light = light_vectors[material];\n\n    // Get the material's position.\n    vec3 position = material_positions[material];\n\n    // Get the material's view direction.\n    vec3 view_direction = view - position;\n\n    // Get the material's light direction.\n    vec3 light_direction = light - position;\n\n    // Get the material's surface normal.\n    vec3 surface_normal = normalize(cross(view_direction, light_direction));\n\n    // Get the material's surface normal dot product with the\n    // surface normal.\n    float dot = dot_product(surface_normal, normal);\n\n    // Get the material's surface normal dot product with the\n    // view direction.\n    float dot_view = dot_product(surface_normal, view_direction);\n\n    // Get the material's surface normal dot product with the\n    // light direction.\n    float dot_light = dot_product(surface_normal, light_direction);\n\n    // Get the material's surface normal dot product with the\n    // surface normal.\n    float dot_surface = dot_product(surface_normal, surface_normal);\n\n    // Get the material's surface normal dot product with the\n    // view direction.\n    float dot_view_surface = dot_product(surface_normal, view_direction\n                                        + surface_normal * dot_view);\n\n    // Get the material's surface normal dot product with the\n    // light direction.\n    float dot_light_surface = dot_product(surface_normal, light_direction\n                                        + surface_normal * dot_light);\n\n    // Get the material's surface normal dot product with the\n    // surface normal", "\n    switch (material) {\n        case 0:\n            return 0.0;\n        case 1:\n            return 1.0;\n        default:\n            return 0.5;\n    }\n}\n\n// Get the color of a material.\n// 0.0 is black, 1.0 is white.\nfloat", "\n    switch (material) {\n        case 1:\n            return 1.0f;\n        case 2:\n            return 1.5f;\n        case 3:\n            return 1.7f;\n        case 4:\n            return 1.9f;\n        default:\n            return 0.0f;\n    }\n}\n\n// Get index of refraction of a material.\nfloat", "\n    switch (material) {\n        case 0:\n            return 0.0;\n        case 1:\n            return 1.0;\n        case 2:\n            return 0.5;\n        case 3:\n            return 0.75;\n        case 4:\n            return 0.9;\n        case 5:\n            return 0.95;\n        case 6:\n            return 0.99;\n        case 7:\n            return 1.0;\n        default:\n            return 0.0;\n    }\n}\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nfloat", "\n    // Find the intersection of the line with the triangle.\n    // Returns a vector whose components are: (intersected?, U, V)\n    // https://www.shadertoy.com/view/MlGcDz\n    vec3 line_a_u = line_a - tri_a;\n    vec3 line_b_u = line_b - tri_a;\n    vec3 line_a_v = line_a - tri_b;\n    vec3 line_b_v = line_b - tri_b;\n    vec3 line_a_n = line_a_u.cross(line_a_v);\n    vec3 line_b_n = line_b_u.cross(line_b_v);\n    vec3 line_a_n_u = line_a_n.cross(line_a_u);\n    vec3 line_b_n_u = line_b_n.cross(line_b_u);\n    vec3 line_a_n_v = line_a_n.cross(line_a_v);\n    vec3 line_b_n_v = line_b_n.cross(line_b_v);\n    vec3 line_a_n_u_v = line_a_n_u.cross(line_a_n_v);\n    vec3 line_b_n_u_v = line_b_n_u.cross(line_b_n_v);\n    vec3 line_a_n_u_v_n = line_a_n_u_v.cross(line_a_n_n);\n    vec3 line_b_n_u_v_n = line_b_n_u_v.cross(line_b_n_n);\n    vec3 line_a_n_u_v_n_u = line_a_n_u_v_n.cross(line_a_n_u);\n    vec3 line_b_n_u_v_n_u = line_b_n_u_v_n.cross(line_b_n_u);\n    vec3 line_a_n_u_v_n_u_", "\n    vec3 normal = (tri_b - tri_a) * (tri_c - tri_a);\n    normal.normalize();\n    return normal;\n}\n\n// Given a triangle and a point, compute the signed distance from the point to the triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Point_On_A_Triangle#targetText=A%20signed%20distance%20is%20a%20value,the%20triangle%20is%20defined%20by).\nfloat", "\n    vec3 up = normalize(cross(camera_target - camera_position, vec3(0, 1, 0)));\n    vec3 right = normalize(cross(up, camera_target - camera_position));\n    vec3 forward = cross(right, up);\n\n    // Create a rotation matrix from the three vectors\n    mat3 rotation_matrix = mat3(right, forward, -up);\n\n    // Create a translation matrix from the camera position\n    vec3 translation_matrix = mat3(1, 0, 0, camera_position.x,\n                                  0, 1, 0, camera_position.y,\n                                  0, 0, 1, camera_position.z);\n\n    // Combine the two matrices to get the final look-at matrix\n    mat3 look_at_matrix = translation_matrix * rotation_matrix;\n\n    return look_at_matrix;\n}\n\n// Create a matrix that rotates a vector around the z-axis\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/rotation-matrix-z-axis\nmat", "\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin", "\n    float distance = ray_target.x - ray_origin.x;\n    float angle = acos(distance / ray_origin.z);\n    float shadow_distance = ray_origin.z * (1 - ray_origin.y);\n    float shadow_angle = acos(shadow_distance / ray_origin.z);\n    float shadow_distance_ratio = shadow_distance / distance;\n    float shadow_angle_ratio = shadow_angle / angle;\n    float shadow_distance_ratio_sq = shadow_distance_ratio * shadow_distance_ratio;\n    float shadow_angle_ratio_sq = shadow_angle_ratio * shadow_angle_ratio;\n    float shadow_distance_ratio_sq_sq = shadow_distance_ratio_sq * shadow_distance_ratio_sq;\n    float shadow_angle_ratio_sq_sq = shadow_angle_ratio_sq * shadow_angle_ratio_sq;\n    float shadow_distance_ratio_sq_sq_sq = shadow_distance_ratio_sq_sq * shadow_distance_ratio_sq_sq;\n    float shadow_distance_ratio_sq_sq_sq_sq = shadow_distance_ratio_sq_sq_sq * shadow_distance_ratio_sq_sq_sq;\n    float shadow_distance_ratio_sq_sq_sq_sq_sq = shadow_distance_ratio_sq_sq_sq_sq * shadow_distance_ratio_sq_sq_sq_sq;\n    float shadow_distance_ratio_sq_sq_sq_sq_sq_sq = shadow_distance_ratio_sq_sq_sq_sq_sq_sq * shadow_distance_ratio_sq_sq_sq_sq_sq;\n    float shadow_distance_ratio_sq_sq_sq_sq_sq_sq_sq = shadow_distance_ratio_sq_sq_sq_sq_sq_sq_sq * shadow_distance_ratio_sq_sq_sq_sq_sq_sq;\n    float shadow_distance_ratio_sq_sq_sq_sq_sq_sq_sq_sq = shadow_distance_ratio_sq_", "\n    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n}\n\n// Basic noise\nfloat", "\n    return (p - 0.5) * 2.0f;\n}\n\n// Gaussian noise\nfloat", "\n    int hash = n;\n    for( int i = 0; i < sizeof( n ); i++ )\n    {\n        hash = ( hash * 31 ) + n % 31;\n    }\n    return hash;\n}\n\nint", "\n    return (float)rand()/RAND_MAX;\n}\n\n// generate a random number between 0 and 1\nfloat", "\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float x2 = 0.0;\n    float x3 = 0.0;\n    float x4 = 0.0;\n    float x5 = 0.0;\n    float x6 = 0.0;\n    float x7 = 0.0;\n    float x8 = 0.0;\n    float x9 = 0.0;\n    float x10 = 0.0;\n    float x11 = 0.0;\n    float x12 = 0.0;\n    float x13 = 0.0;\n    float x14 = 0.0;\n    float x15 = 0.0;\n    float x16 = 0.0;\n    float x17 = 0.0;\n    float x18 = 0.0;\n    float x19 = 0.0;\n    float x20 = 0.0;\n    float x21 = 0.0;\n    float x22 = 0.0;\n    float x23 = 0.0;\n    float x24 = 0.0;\n    float x25 = 0.0;\n    float x26 = 0.0;\n    float x27 = 0.0;\n    float x28 = 0.0;\n    float x29 = 0", "\n    vec3 q = p - center;\n    vec3 r = q.norm();\n    vec3 s = q / r;\n    vec3 t = s.x * s.x + s.y * s.y + s.z * s.z;\n    vec3 u = sqrt(t);\n    vec3 v = sqrt(t - 1);\n    vec3 w = sqrt(t + 1);\n    vec3 x = (u * u * u) / (u * u * u + v * v * v + w * w * w);\n    vec3 y = (u * u * u) / (u * u * u + v * v * v + w * w * w);\n    vec3 z = (u * u * u) / (u * u * u + v * v * v + w * w * w);\n    vec3 c = vec3(x, y, z);\n    return c;\n}\n\n// For a point in the sphere's surface p, return a color based on\n// the solutions of the associate quadratic polynomial\nvec", "\n    vec3 p = pb*2-1;\n    vec3 a = p*p*p*p;\n    vec3 b = 2*p*p*p;\n    vec3 c = 3*p*p;\n    vec3 d = p;\n    return vec3(\n        a*(1-b)*(1-c)*(1-d) +\n        a*(1-b)*(1+c)*(1-d) +\n        a*(1+b)*(1-c)*(1-d) +\n        a*(1+b)*(1+c)*(1-d) +\n        b*(1-c)*(1-d)*(1-d) +\n        b*(1-c)*(1+d)*(1-d) +\n        b*(1+c)*(1-d)*(1-d) +\n        b*(1+c)*(1+d)*(1-d) +\n        c*(1-d)*(1-d)*(1-d) +\n        c*(1-d)*(1+d)*(1-d) +\n        c*(1+d)*(1-d)*(1-d) +\n        c*(1+d)*(1+d)*(1-d) +\n        d*(1-d)*(1-d)*(1-d) +\n        d*(1-d)*(1+d)*(1-d) +\n        d*(1+d)*(1-d)*(1-d) +\n        d*(1+d)*(1+d)*(1-d)\n    );\n}\n\n// For a point p in the unit box, return a color\n// based on the solutions of the associated cubic\n// polynomial. The point p is interprested as the \n// 3 polar angles of a 4D point in a unit sphere,\n// and that 4D point maps to a unique cubic\n// polynomials a,b,c,d coefficients.\nvec", "\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 n = cross(r, d);\n    vec3 nmag = length(n);\n    if( nmag == 0 ) return vec4(0,0,0,0);\n    vec3 nhat = n / nmag;\n    vec3 nhat2 = nhat * nhat;\n    vec3 nhat3 = nhat * nhat2;\n    vec3 nhat4 = nhat * nhat3;\n    vec3 nhat5 = nhat * nhat4;\n    vec3 nhat6 = nhat * nhat5;\n    vec3 nhat7 = nhat * nhat6;\n    vec3 nhat8 = nhat * nhat7;\n    vec3 nhat9 = nhat * nhat8;\n    vec3 nhat10 = nhat * nhat9;\n    vec3 nhat11 = nhat * nhat10;\n    vec3 nhat12 = nhat * nhat11;\n    vec3 nhat13 = nhat * nhat12;\n    vec3 nhat14 = nhat * nhat13;\n    vec3 nhat15 = nhat * nhat14;\n    vec3 nhat16 = nhat * nhat15;\n    vec3 nhat17 = nhat * nhat16;\n    vec3 nhat18 = nhat * nhat17;\n    vec3 nhat19 = nhat * nhat18;\n    vec3 nhat20 = nhat * nhat19;\n    vec3 nhat21 = nhat * nhat20;\n    vec3 nhat22 = nhat * nhat21;\n    vec3 nhat23 = nhat * nhat22;\n    vec3 nhat24 = nhat * nhat23;\n    vec3 nhat25 = nhat * nhat24;\n    vec3 nhat26 = nhat * nhat25;\n    vec3 nhat27 = nhat * nhat26;\n    vec3 nhat28 = nhat * nhat27;\n    vec3 nhat29 = nhat * nhat28;\n    vec3 nhat30 = nhat * nhat29", "\n    float x, y, z;\n    x = (ro.x - cen.x) * (rad.x / cen.x);\n    y = (ro.y - cen.y) * (rad.y / cen.y);\n    z = (ro.z - cen.z) * (rad.z / cen.z);\n    return (x + y + z);\n}\n\nfloat", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float tmin2 = 0.0;\n    float tmax2 = 0.0;\n    float tmin3 = 0.0;\n    float tmax3 = 0.0;\n    float tmin4 = 0.0;\n    float tmax4 = 0.0;\n    float tmin5 = 0.0;\n    float tmax5 = 0.0;\n    float tmin6 = 0.0;\n    float tmax6 = 0.0;\n    float tmin7 = 0.0;\n    float tmax7 = 0.0;\n    float tmin8 = 0.0;\n    float tmax8 = 0.0;\n    float tmin9 = 0.0;\n    float tmax9 = 0.0;\n    float tmin10 = 0.0;\n    float tmax10 = 0.0;\n    float tmin11 = 0.0;\n    float tmax11 = 0.0;\n    float tmin12 = 0.0;\n    float tmax12 = 0.0;\n    float tmin13 = 0.0;\n    float tmax13 = 0.0;\n    float tmin14 = 0.0;\n    float tmax14 = 0.0;\n    float tmin15 = 0.0;\n    float tmax15 = 0.0;\n    float tmin16 = 0.0;\n    float tmax16 = 0.0;\n    float tmin17 = 0.0;\n    float tmax17 = 0.0;\n    float tmin18 = 0.0;\n    float tmax18 = 0.0;\n    float tmin19 = 0.0;\n    float tmax19 = 0.0;\n    float tmin20 = 0.0;\n    float tmax20 = 0.0;\n    float tmin21 = 0.0;\n    float tmax21 = 0.0;\n    float tmin22 = 0.0;\n    float tmax22 = 0.0;\n    float tmin23 = 0.0;\n    float tmax23 = 0.0", "\n    static seed = time(NULL);\n    return static_cast<float>(rand() % (1.0f * RAND_MAX) + 1.0f) / (1.0f * RAND_MAX);\n}\n\n// shadow\nfloat", "\n    vec3 p = a + t * (b - a);\n    vec3 q = c + t * (d - c);\n    return p + t * (q - p);\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec", "\n    vec3 p1 = p + vec3(la,0,0);\n    vec3 p2 = p + vec3(0,lb,0);\n    vec3 p3 = p + vec3(0,0,h);\n    vec3 p4 = p + vec3(ra,0,0);\n    vec3 p5 = p + vec3(0,0,h);\n    vec3 p6 = p + vec3(0,0,0);\n    vec3 p7 = p + vec3(ra,0,0);\n    vec3 p8 = p + vec3(0,lb,0);\n    vec3 p9 = p + vec3(0,0,h);\n    vec3 p10 = p + vec3(0,0,0);\n    vec3 p11 = p + vec3(ra,0,0);\n    vec3 p12 = p + vec3(0,lb,0);\n    vec3 p13 = p + vec3(0,0,h);\n    vec3 p14 = p + vec3(0,0,0);\n    vec3 p15 = p + vec3(ra,0,0);\n    vec3 p16 = p + vec3(0,lb,0);\n    vec3 p17 = p + vec3(0,0,h);\n    vec3 p18 = p + vec3(0,0,0);\n    vec3 p19 = p + vec3(ra,0,0);\n    vec3 p20 = p + vec3(0,lb,0);\n    vec3 p21 = p + vec3(0,0,h);\n    vec3 p22 = p + vec3(0,0,0);\n    vec3 p23 = p + vec3(ra,0,0);\n    vec3 p24 = p + vec3(0,lb,0);\n    vec3 p25 = p + vec3(0,0,h);\n    vec3 p26 = p + vec3(0,0,0);\n    vec3 p27 = p + vec3(ra,0,0);\n    vec3 p28 = p + vec3(0,lb,0);\n    vec3 p29 = p", "\n    vec2 p0 = a - p;\n    vec2 p1 = b - p;\n    float d = p0.length();\n    float d0 = p0.length();\n    float d1 = p1.length();\n    float d2 = d0 + d1;\n    float d3 = d0 * d1;\n    float d4 = d0 * d0;\n    float d5 = d1 * d1;\n    float d6 = d0 * d1;\n    float d7 = d0 * d0;\n    float d8 = d1 * d1;\n    float d9 = d0 * d0;\n    float d10 = d1 * d1;\n    float d11 = d0 * d0;\n    float d12 = d1 * d1;\n    float d13 = d0 * d0;\n    float d14 = d1 * d1;\n    float d15 = d0 * d0;\n    float d16 = d1 * d1;\n    float d17 = d0 * d0;\n    float d18 = d1 * d1;\n    float d19 = d0 * d0;\n    float d20 = d1 * d1;\n    float d21 = d0 * d0;\n    float d22 = d1 * d1;\n    float d23 = d0 * d0;\n    float d24 = d1 * d1;\n    float d25 = d0 * d0;\n    float d26 = d1 * d1;\n    float d27 = d0 * d0;\n    float d28 = d1 * d1;\n    float d29 = d0 * d0;\n    float d30 = d1 * d1;\n    float d31 = d0 * d0;\n    float d32 = d1 * d1;\n    float d33 = d0 * d0;\n    float d34 = d1 * d1;\n    float d35 = d0 * d0;\n    float d36 = d1 * d1;\n    float d37 = d0 * d0;\n    float d38 = d1 * d1;\n    float d39 = d0 * d0;\n    ", "\n    vec2 pb = b - p;\n    vec2 pb2 = pb * pb;\n    vec2 pb3 = pb2 * pb2;\n    vec2 pb4 = pb3 * pb2;\n    vec2 pb5 = pb4 * pb2;\n    vec2 pb6 = pb5 * pb2;\n    vec2 pb7 = pb6 * pb2;\n    vec2 pb8 = pb7 * pb2;\n    vec2 pb9 = pb8 * pb2;\n    vec2 pb10 = pb9 * pb2;\n    vec2 pb11 = pb10 * pb2;\n    vec2 pb12 = pb11 * pb2;\n    vec2 pb13 = pb12 * pb2;\n    vec2 pb14 = pb13 * pb2;\n    vec2 pb15 = pb14 * pb2;\n    vec2 pb16 = pb15 * pb2;\n    vec2 pb17 = pb16 * pb2;\n    vec2 pb18 = pb17 * pb2;\n    vec2 pb19 = pb18 * pb2;\n    vec2 pb20 = pb19 * pb2;\n    vec2 pb21 = pb20 * pb2;\n    vec2 pb22 = pb21 * pb2;\n    vec2 pb23 = pb22 * pb2;\n    vec2 pb24 = pb23 * pb2;\n    vec2 pb25 = pb24 * pb2;\n    vec2 pb26 = pb25 * pb2;\n    vec2 pb27 = pb26 * pb2;\n    vec2 pb28 = pb27 * pb2;\n    vec2 pb29 = pb28 * pb2;\n    vec2 pb30 = pb29 * pb2;\n    vec2 pb31 = pb30 * pb2;\n    vec2 pb32 = pb31 * pb2;\n    vec2 pb33", "\n    vec3 x = p.x - b.x;\n    vec3 y = p.y - b.y;\n    vec3 z = p.z - b.z;\n    vec3 xy = x.y;\n    vec3 yz = y.z;\n    vec3 zx = z.x;\n    vec3 xyz = x.y * z.z - x.z * z.y;\n    vec3 xyz2 = xyz * xyz;\n    vec3 xyz3 = xyz2 * xyz;\n    vec3 xyz4 = xyz3 * xyz;\n    vec3 xyz5 = xyz4 * xyz;\n    vec3 xyz6 = xyz5 * xyz;\n    vec3 xyz7 = xyz6 * xyz;\n    vec3 xyz8 = xyz7 * xyz;\n    vec3 xyz9 = xyz8 * xyz;\n    vec3 xyz10 = xyz9 * xyz;\n    vec3 xyz11 = xyz10 * xyz;\n    vec3 xyz12 = xyz11 * xyz;\n    vec3 xyz13 = xyz12 * xyz;\n    vec3 xyz14 = xyz13 * xyz;\n    vec3 xyz15 = xyz14 * xyz;\n    vec3 xyz16 = xyz15 * xyz;\n    vec3 xyz17 = xyz16 * xyz;\n    vec3 xyz18 = xyz17 * xyz;\n    vec3 xyz19 = xyz18 * xyz;\n    vec3 xyz20 = xyz19 * xyz;\n    vec3 xyz21 = xyz20 * xyz;\n    vec3 xyz22 = xyz21 * xyz;\n    vec3 xyz23 = xyz22 * xyz;\n    vec3 xyz24 = xyz23 * xyz;\n    vec3 xyz25 = xyz24 * xyz;\n    vec3 xyz26 = xyz25 * xyz;\n    vec3 xyz27 = xyz26 * xyz;\n    vec3 xyz28 = xyz27 * xyz;\n    vec3 xyz29 = xyz", "\n    vec2 x, y;\n    float xdist, ydist;\n    float xdist2, ydist2;\n    float xdist3, ydist3;\n    float xdist4, ydist4;\n    float xdist5, ydist5;\n    float xdist6, ydist6;\n    float xdist7, ydist7;\n    float xdist8, ydist8;\n    float xdist9, ydist9;\n    float xdist10, ydist10;\n    float xdist11, ydist11;\n    float xdist12, ydist12;\n    float xdist13, ydist13;\n    float xdist14, ydist14;\n    float xdist15, ydist15;\n    float xdist16, ydist16;\n    float xdist17, ydist17;\n    float xdist18, ydist18;\n    float xdist19, ydist19;\n    float xdist20, ydist20;\n    float xdist21, ydist21;\n    float xdist22, ydist22;\n    float xdist23, ydist23;\n    float xdist24, ydist24;\n    float xdist25, ydist25;\n    float xdist26, ydist26;\n    float xdist27, ydist27;\n    float xdist28, ydist28;\n    float xdist29, ydist29;\n    float xdist30, ydist30;\n    float xdist31, ydist31;\n    float xdist32, ydist32;\n    float xdist33, ydist33;\n    float xdist34, ydist34;\n    float xdist35, ydist35;\n    float xdist36, ydist36;\n    float xdist37, ydist37;\n    float xdist38, ydist38;\n    float xdist39, ydist39;\n    float xdist40, ydist40;\n    float xdist41, ydist41;\n    float xdist42, ydist42;\n    float xdist43, ydist43;\n    float xdist44, ydist44;\n    float xdist45, ydist45;\n    float xdist46, ydist46;", "\n    float s = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float v = ( verts[i].x - p.x ) * ( verts[i].x - p.x ) + ( verts[i].y - p.y ) * ( verts[i].y - p.y );\n        if ( v > r * r )\n        {\n            s += ( r - sqrt( v ) ) * ( r - sqrt( v ) );\n        }\n    }\n    return s;\n}\n\nA:\n\nI think you are looking for the distance between a point and a polygon.\nThe distance between a point and a polygon is the minimum distance between the point and any of the polygon's edges.\nThe distance between a point and a polygon can be calculated by finding the minimum distance between the point and each edge of the polygon.\nThe minimum distance between a point and an edge of a polygon can be calculated by finding the perpendicular distance between the point and the line segment that represents the edge.\nThe perpendicular distance between a point and a line segment can be calculated by finding the intersection point of the line segment and the perpendicular bisector of the line segment, and then finding the distance between the point and the intersection point.\nThe perpendicular bisector of a line segment can be found by finding the midpoint of the line segment and then finding the line that is perpendicular to the line segment and passes through the midpoint.\nThe intersection point of two lines can be found by solving the system of equations that represents the two lines.\nThe distance between a point and a line can be calculated by finding the perpendicular distance between the point and the line.\nThe distance between a point and a line can be calculated by finding the perpendicular distance between the point and the line, and then multiplying the perpendicular distance by the slope of the line.\nThe slope of a line can be calculated by finding the change in y divided by the change in x between two points on the line.\nThe change in y can be calculated by subtracting the y-coordinate of one point from the y-coordinate of the other point.\nThe change in x can be calculated by subtracting the x-coordinate of one point from the x-coordinate of the other point.\nThe distance between a point and a line can be", "\n    vec4 p0 = p;\n    vec4 p1 = verts[0];\n    vec4 p2 = verts[1];\n    vec4 p3 = verts[2];\n    vec4 p4 = verts[3];\n    vec4 p5 = verts[4];\n\n    vec4 p0a = p0 - p;\n    vec4 p1a = p1 - p;\n    vec4 p2a = p2 - p;\n    vec4 p3a = p3 - p;\n    vec4 p4a = p4 - p;\n    vec4 p5a = p5 - p;\n\n    vec4 p0b = p0a * r;\n    vec4 p1b = p1a * r;\n    vec4 p2b = p2a * r;\n    vec4 p3b = p3a * r;\n    vec4 p4b = p4a * r;\n    vec4 p5b = p5a * r;\n\n    vec4 p0c = p0a * band;\n    vec4 p1c = p1a * band;\n    vec4 p2c = p2a * band;\n    vec4 p3c = p3a * band;\n    vec4 p4c = p4a * band;\n    vec4 p5c = p5a * band;\n\n    vec4 p0d = p0a * (1.0f - band);\n    vec4 p1d = p1a * (1.0f - band);\n    vec4 p2d = p2a * (1.0f - band);\n    vec4 p3d = p3a * (1.0f - band);\n    vec4 p4d = p4a * (1.0f - band);\n    vec4 p5d = p5a * (1.0f - band);\n\n    vec4 p0 = p0a + p0b + p0c + p0d;\n    vec4 p1 = p1a + p1b + p1c + p1d;\n    vec4 p2 = p2a + p2b + p2c + p2d;\n    vec4 p3 = p", "\n    vec3 p0 = a;\n    vec3 p1 = b;\n    vec3 p2 = p;\n\n    vec3 p0p1 = p1 - p0;\n    vec3 p1p2 = p2 - p1;\n\n    vec3 p0p1p2 = p0p1 + p1p2;\n\n    vec3 p0p1p2p0 = p0p1p2 - p0;\n\n    vec3 p0p1p2p0p1 = p0p1p2p0 - p1;\n\n    vec3 p0p1p2p0p1p2 = p0p1p2p0p1 - p2;\n\n    vec3 p0p1p2p0p1p2p0 = p0p1p2p0p1p2 - p0;\n\n    vec3 p0p1p2p0p1p2p0p1 = p0p1p2p0p1p2p0 - p1;\n\n    vec3 p0p1p2p0p1p2p0p1p2 = p0p1p2p0p1p2p0p1 - p2;\n\n    vec3 p0p1p2p0p1p2p0p1p2p0 = p0p1p2p0p1p2p0p1p2 - p0;\n\n    vec3 p0p1p2p0p1p2p0p1p2p0p1 = p0p1p2p0p1p2p0p1p2 - p1;\n\n    vec3 p0p1p2p0p1p2p0p1p2p0p1p2 = p0p1p2p0p1p2p0p1p2 - p2;\n\n    vec3 p0p1p2p0p1p2p0p1p2p0p1p2p0 = p0p1p2p0p1p2p0p1p2 - p0;\n\n    vec3 p0p1p2p0p1p2p0p1p2p0p1p2p0 = p0p1p", "\n    vec3 x, y, z;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 yy;\n    vec3 xy;\n    vec3 xz;\n    vec3 yx;\n    vec3 yz;\n    vec3 y", "\n    vec3 x = X * p;\n    tan1 = x.y / x.z;\n    tan2 = x.x / x.z;\n    if (tan1 == tan2) {\n        return false;\n    }\n    return true;\n}\n\n// Find the two tangents to conic X from point p.\nvec", "\n    if (b.x == 0) {\n        b.x += 1e-6;\n    }\n    return a / b;\n}\n\nvec", "\n    vec3 r = vec3(cos(a), 0, sin(a));\n    return p * r;\n}\n\n// Transforms\nvec", "\n    return pow(x, 3) / pow(R, 3);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat", "\n    return 1.0 / (1.0 + e / R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat", "\n    return (b - a) / (R * e);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float z = p.z - c.z;\n    float r = sqrt(x*x + y*y + z*z);\n    float e = e;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n    float r35 = r34*r;\n    float r36 = r35*r;\n    float r37 = r36*r;\n    float r38 = r37*r;\n    float r39 = r38*r;\n    float r40 = r39*r;\n    float r41 = r40*r;\n    float r42 = r", "\n    float x = b.x - a.x;\n    float y = b.y - a.y;\n    float z = b.z - a.z;\n    float r = sqrt(x*x + y*y + z*z);\n    float r2 = R*R;\n    float r3 = r*r;\n    float r4 = r2*r;\n    float r5 = r3*r;\n    float r6 = r4*r;\n    float r7 = r5*r;\n    float r8 = r6*r;\n    float r9 = r7*r;\n    float r10 = r8*r;\n    float r11 = r9*r;\n    float r12 = r10*r;\n    float r13 = r11*r;\n    float r14 = r12*r;\n    float r15 = r13*r;\n    float r16 = r14*r;\n    float r17 = r15*r;\n    float r18 = r16*r;\n    float r19 = r17*r;\n    float r20 = r18*r;\n    float r21 = r19*r;\n    float r22 = r20*r;\n    float r23 = r21*r;\n    float r24 = r22*r;\n    float r25 = r23*r;\n    float r26 = r24*r;\n    float r27 = r25*r;\n    float r28 = r26*r;\n    float r29 = r27*r;\n    float r30 = r28*r;\n    float r31 = r29*r;\n    float r32 = r30*r;\n    float r33 = r31*r;\n    float r34 = r32*r;\n    float r35 = r33*r;\n    float r36 = r34*r;\n    float r37 = r35*r;\n    float r38 = r36*r;\n    float r39 = r37*r;\n    float r40 = r38*r;\n    float r41 = r39*r;\n    float r42 = r40*r;\n    float r", "\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\n// Find the closest point to the given point\nvec", "\n    float x = a.x;\n    float y = a.y;\n    float z = a.z;\n    float x1 = b.x;\n    float y1 = b.y;\n    float z1 = b.z;\n    float x2 = x1 + (x1 - x) * (z1 - z);\n    float y2 = y1 + (y1 - y) * (z1 - z);\n    float z2 = z1 + (z1 - z) * (x1 - x);\n    return vec3(x2, y2, z2);\n}\n\n// K root\nfloat", "\n    vec3 n = normalize(p);\n    vec3 o = normalize(vec3(0,0,1));\n    return (n - o) * 0.5;\n}\n\n// Normalized vector\nvec", "\n    // Initialize ray\n    vec3 r = o + u * 0.001;\n    vec3 v = o - r;\n    float d = dot(r, r);\n    float dv = dot(v, v);\n    float dv2 = dv * dv;\n    float d2 = d * d;\n    float d2v = d2 * dv;\n    float d2v2 = d2v * dv2;\n    float d2v3 = d2v2 * dv;\n    float d2v4 = d2v3 * dv2;\n    float d2v5 = d2v4 * dv;\n    float d2v6 = d2v5 * dv2;\n    float d2v7 = d2v6 * dv;\n    float d2v8 = d2v7 * dv2;\n    float d2v9 = d2v8 * dv;\n    float d2v10 = d2v9 * dv2;\n    float d2v11 = d2v10 * dv;\n    float d2v12 = d2v11 * dv2;\n    float d2v13 = d2v12 * dv;\n    float d2v14 = d2v13 * dv2;\n    float d2v15 = d2v14 * dv;\n    float d2v16 = d2v15 * dv2;\n    float d2v17 = d2v16 * dv;\n    float d2v18 = d2v17 * dv2;\n    float d2v19 = d2v18 * dv;\n    float d2v20 = d2v19 * dv2;\n    float d2v21 = d2v20 * dv;\n    float d2v22 = d2v21 * dv2;\n    float d2v23 = d2v22 * dv;\n    float d2v24 = d2v23 * dv2;\n    float d2v25 = d2v24 * dv;\n    float d2v26 = d2v25 * dv2;\n    float d2v27 = d2v", "\n    // Initialize\n    h = false;\n    s = 0;\n\n    // Loop until hit\n    while (!h)\n    {\n        // Increment step\n        s++;\n\n        // Check if hit\n        h = (o + u * s) == v;\n    }\n\n    return s;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n    vec3 p0 = a + r * (b - a);\n    vec3 p1 = a + r * (b + a);\n    vec3 p2 = a - r * (b - a);\n    vec3 p3 = a - r * (b + a);\n    vec3 p4 = a + r * (b - a);\n    vec3 p5 = a + r * (b + a);\n    vec3 p6 = a - r * (b - a);\n    vec3 p7 = a - r * (b + a);\n\n    vec3 v0 = p0 - p;\n    vec3 v1 = p1 - p;\n    vec3 v2 = p2 - p;\n    vec3 v3 = p3 - p;\n    vec3 v4 = p4 - p;\n    vec3 v5 = p5 - p;\n    vec3 v6 = p6 - p;\n    vec3 v7 = p7 - p;\n\n    float s0 = dot(v0, v0);\n    float s1 = dot(v1, v1);\n    float s2 = dot(v2, v2);\n    float s3 = dot(v3, v3);\n    float s4 = dot(v4, v4);\n    float s5 = dot(v5, v5);\n    float s6 = dot(v6, v6);\n    float s7 = dot(v7, v7);\n\n    float s0a = dot(v0, v1);\n    float s1a = dot(v1, v2);\n    float s2a = dot(v2, v3);\n    float s3a = dot(v3, v4);\n    float s4a = dot(v4, v5);\n    float s5a = dot(v5, v6);\n    float s6a = dot(v6, v7);\n    float s7a = dot(v7, v0);\n\n    float s0b = dot(v0, v2);\n    float s1b = dot(v1, v3);\n    float s2b = dot(v2, v4);\n    float s3b = dot(v3", "\n    vec3 r = ro - rd;\n    vec3 r2 = r * r;\n    vec3 r3 = r2 * r;\n    vec3 r4 = r3 * r;\n    vec3 r5 = r4 * r;\n    vec3 r6 = r5 * r;\n    vec3 r7 = r6 * r;\n    vec3 r8 = r7 * r;\n    vec3 r9 = r8 * r;\n    vec3 r10 = r9 * r;\n    vec3 r11 = r10 * r;\n    vec3 r12 = r11 * r;\n    vec3 r13 = r12 * r;\n    vec3 r14 = r13 * r;\n    vec3 r15 = r14 * r;\n    vec3 r16 = r15 * r;\n    vec3 r17 = r16 * r;\n    vec3 r18 = r17 * r;\n    vec3 r19 = r18 * r;\n    vec3 r20 = r19 * r;\n    vec3 r21 = r20 * r;\n    vec3 r22 = r21 * r;\n    vec3 r23 = r22 * r;\n    vec3 r24 = r23 * r;\n    vec3 r25 = r24 * r;\n    vec3 r26 = r25 * r;\n    vec3 r27 = r26 * r;\n    vec3 r28 = r27 * r;\n    vec3 r29 = r28 * r;\n    vec3 r30 = r29 * r;\n    vec3 r31 = r30 * r;\n    vec3 r32 = r31 * r;\n    vec3 r33 = r32 * r;\n    vec3 r34 = r33 * r;\n    vec3 r35 = r34 * r;\n    vec3 r36 = r35 * r;\n    vec3 r37 = r36 * r;\n    vec3 r38 = r37 * r;\n    vec3 r39 = r38 * r;\n    vec3 r40 = r39 * r;\n    vec3 r41 = r40 * r;\n    vec3 r42 = r41 * r;\n    vec3 r43 = r42 *", "\n    return vec2(coord.x / width, coord.y / height);\n}\n\n// normalized fragment coordinate\nvec", "\n    vec3 p1 = p;\n    vec3 p2 = q;\n    vec3 p3 = p + q;\n    vec3 p4 = p - q;\n    vec3 p5 = p - p1;\n    vec3 p6 = p - p2;\n    vec3 p7 = p - p3;\n    vec3 p8 = p - p4;\n    vec3 p9 = p - p5;\n    vec3 p10 = p - p6;\n    vec3 p11 = p - p7;\n    vec3 p12 = p - p8;\n    vec3 p13 = p - p9;\n    vec3 p14 = p - p10;\n    vec3 p15 = p - p11;\n    vec3 p16 = p - p12;\n    vec3 p17 = p - p13;\n    vec3 p18 = p - p14;\n    vec3 p19 = p - p15;\n    vec3 p20 = p - p16;\n    vec3 p21 = p - p17;\n    vec3 p22 = p - p18;\n    vec3 p23 = p - p19;\n    vec3 p24 = p - p20;\n    vec3 p25 = p - p21;\n    vec3 p26 = p - p22;\n    vec3 p27 = p - p23;\n    vec3 p28 = p - p24;\n    vec3 p29 = p - p25;\n    vec3 p30 = p - p26;\n    vec3 p31 = p - p27;\n    vec3 p32 = p - p28;\n    vec3 p33 = p - p29;\n    vec3 p34 = p - p30;\n    vec3 p35 = p - p31;\n    vec3 p36 = p - p32;\n    vec3 p37 = p - p33;\n    vec3 p38 = p - p34;\n    vec3 p39 = p - p35;\n    vec3 p40 = p - p36;\n    vec3 p41 = p - p37;\n    vec3 p42 = p - p38;\n    vec3 p43 = p - p39;\n    vec3", "\n    vec3 v = vec3(p);\n    vec3 dv = vec3(d);\n    vec3 d2v = vec3(d*d);\n    vec3 d2dv = vec3(d*dv);\n    vec3 d2d2v = vec3(d*d2v);\n    vec3 d2d2dv = vec3(d2dv*d2v);\n    vec3 d2d2d2dv = vec3(d2d2dv*d2d2v);\n    vec3 d2d2d2d2dv = vec3(d2d2d2dv*d2d2d2v);\n    vec3 d2d2d2d2d2dv = vec3(d2d2d2d2d2dv*d2d2d2d2v);\n    vec3 d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2dv*d2d2d2d2d2v);\n    vec3 d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2dv*d2d2d2d2d2v);\n    vec3 d2d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2d2dv*d2d2d2d2d2v);\n    vec3 d2d2d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2d2d2dv*d2d2d2d2d2v);\n    vec3 d2d2d2d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2d2d2d2dv*d2d2d2d2d2v);\n    vec3 d2d2d2d2d", "\n    vec3 x = p.x * c.x - p.y * c.y;\n    vec3 y = p.x * c.y + p.y * c.x;\n    vec3 z = p.z * c.z - p.y * c.z;\n    vec3 yz = p.y * c.z + p.z * c.y;\n    vec3 r = sqrt(x*x + y*y + z*z);\n    vec3 r2 = r * r;\n    vec3 r3 = r2 * r;\n    vec3 r4 = r3 * r;\n    vec3 r5 = r4 * r;\n    vec3 r6 = r5 * r;\n    vec3 r7 = r6 * r;\n    vec3 r8 = r7 * r;\n    vec3 r9 = r8 * r;\n    vec3 r10 = r9 * r;\n    vec3 r11 = r10 * r;\n    vec3 r12 = r11 * r;\n    vec3 r13 = r12 * r;\n    vec3 r14 = r13 * r;\n    vec3 r15 = r14 * r;\n    vec3 r16 = r15 * r;\n    vec3 r17 = r16 * r;\n    vec3 r18 = r17 * r;\n    vec3 r19 = r18 * r;\n    vec3 r20 = r19 * r;\n    vec3 r21 = r20 * r;\n    vec3 r22 = r21 * r;\n    vec3 r23 = r22 * r;\n    vec3 r24 = r23 * r;\n    vec3 r25 = r24 * r;\n    vec3 r26 = r25 * r;\n    vec3 r27 = r26 * r;\n    vec3 r28 = r27 * r;\n    vec3 r29 = r28 * r;\n    vec3 r30 = r29 * r;\n    vec3 r31 = r30 * r;\n    vec3 r32 = r31 * r;\n    vec3 r33 = r32 * r;\n    vec3 r34 = r33 * r;\n    vec3 r35 =", "\n    vec3 d = v[0] - p;\n    vec3 d2 = v[1] - p;\n    vec3 d3 = v[2] - p;\n    vec3 d4 = v[3] - p;\n    vec3 d5 = v[4] - p;\n    vec3 d6 = v[5] - p;\n    vec3 d7 = v[6] - p;\n    vec3 d8 = v[7] - p;\n    vec3 d9 = v[8] - p;\n    vec3 d10 = v[9] - p;\n    vec3 d11 = v[10] - p;\n    vec3 d12 = v[11] - p;\n    vec3 d13 = v[12] - p;\n    vec3 d14 = v[13] - p;\n    vec3 d15 = v[14] - p;\n    vec3 d16 = v[15] - p;\n    vec3 d17 = v[16] - p;\n    vec3 d18 = v[17] - p;\n    vec3 d19 = v[18] - p;\n    vec3 d20 = v[19] - p;\n    vec3 d21 = v[20] - p;\n    vec3 d22 = v[21] - p;\n    vec3 d23 = v[22] - p;\n    vec3 d24 = v[23] - p;\n    vec3 d25 = v[24] - p;\n    vec3 d26 = v[25] - p;\n    vec3 d27 = v[26] - p;\n    vec3 d28 = v[27] - p;\n    vec3 d29 = v[28] - p;\n    vec3 d30 = v[29] - p;\n    vec3 d31 = v[30] - p;\n    vec3 d32 = v[31] - p;\n    vec3 d33 = v[32] - p;\n    vec3 d34 = v[33] - p;\n    vec3 d35 = v[34] - p;\n    vec3 d36 = v[35] - p;\n    vec3 d37 = v[", "\n    vec3 r = p - center;\n    vec3 s = r.normalize();\n    vec3 t = s.cross(normal);\n    vec3 u = s.cross(t);\n    vec3 v = t.cross(s);\n    vec3 w = s.cross(u);\n    vec3 x = r.dot(normal);\n    vec3 y = r.dot(t);\n    vec3 z = r.dot(s);\n    vec3 a = (x*x + y*y + z*z - ra*ra - rb*rb) / (2*ra*rb);\n    vec3 b = (x*x + y*y - z*z + ra*ra - rb*rb) / (2*ra*rb);\n    vec3 c = (x*x - y*y + z*z + ra*ra - rb*rb) / (2*ra*rb);\n    vec3 d = (x*x - y*y - z*z + ra*ra - rb*rb) / (2*ra*rb);\n    vec3 e = (x*x - y*y + z*z - ra*ra + rb*rb) / (2*ra*rb);\n    vec3 f = (x*x - y*y - z*z - ra*ra + rb*rb) / (2*ra*rb);\n    vec3 g = (x*x - y*y + z*z - ra*ra - rb*rb) / (2*ra*rb);\n    vec3 h = (x*x - y*y - z*z - ra*ra + rb*rb) / (2*ra*rb);\n    vec3 i = (x*x - y*y - z*z - ra*ra - rb*rb) / (2*ra*rb);\n    vec3 j = (x*x + y*y + z*z - ra*ra - rb*rb) / (2*ra*rb);\n    vec3 k = (x*x + y*y - z*z + ra*ra - rb*rb) / (2*ra*rb);\n    vec3 l = (x*x +", "\n    float x = a.x - b.x;\n    float y = a.y - b.y;\n    float z = a.z - b.z;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz", "\n    vec3 x, y, z, yz;\n    vec3 ab2;\n    vec3 ab2x, ab2y;\n    vec3 ab2z;\n    vec3 ab2yz;\n    vec3 ab2xy;\n    vec3 ab2xz;\n    vec3 ab2yz2;\n    vec3 ab2xy2;\n    vec3 ab2x2;\n    vec3 ab2y2;\n    vec3 ab2z2;\n    vec3 ab2xy2x;\n    vec3 ab2xy2y;\n    vec3 ab2xy2z;\n    vec3 ab2xy2yz;\n    vec3 ab2xy2x2;\n    vec3 ab2xy2y2;\n    vec3 ab2xy2z2;\n    vec3 ab2xy2yz2;\n    vec3 ab2xy2x2y;\n    vec3 ab2xy2x2z;\n    vec3 ab2xy2y2z;\n    vec3 ab2xy2x2yz;\n    vec3 ab2xy2x2y2;\n    vec3 ab2xy2x2z2;\n    vec3 ab2xy2y2z2;\n    vec3 ab2xy2x2yz2;\n    vec3 ab2xy2x2y2z2;\n    vec3 ab2xy2x2yz2x;\n    vec3 ab2xy2x2yz2y;\n    vec3 ab2xy2x2yz2z;\n    vec3 ab2xy2x2yz2xy;\n    vec3 ab2xy2x2yz2y2;\n    vec3 ab2xy2x2yz2z2;\n    vec3 ab2xy2x2yz2xy2;\n    vec3 ab2xy2x2yz2y2z2;\n    vec3 ab2xy2x2yz2xy2yz;\n    vec3 ab2xy2x2yz2y2yz2;\n    vec3 ab2xy2x2yz2xy2yz2x;\n    vec3 ab2xy2x2yz2y2yz2xy;\n    vec3 ab2xy2x2yz2y2yz2", "\n    vec3 p0 = vec3(0.0, 0.0, 0.0);\n    vec3 p1 = vec3(1.0, 0.0, 0.0);\n    vec3 p2 = vec3(0.0, 1.0, 0.0);\n    vec3 p3 = vec3(0.0, 0.0, 1.0);\n    vec3 p4 = vec3(1.0, 1.0, 0.0);\n    vec3 p5 = vec3(1.0, 0.0, 1.0);\n    vec3 p6 = vec3(0.0, 1.0, 1.0);\n    vec3 p7 = vec3(1.0, 1.0, 1.0);\n\n    vec3 p0p1 = p1 - p0;\n    vec3 p0p2 = p2 - p0;\n    vec3 p0p3 = p3 - p0;\n    vec3 p0p4 = p4 - p0;\n    vec3 p0p5 = p5 - p0;\n    vec3 p0p6 = p6 - p0;\n    vec3 p0p7 = p7 - p0;\n\n    vec3 p1p2 = p2 - p1;\n    vec3 p1p3 = p3 - p1;\n    vec3 p1p4 = p4 - p1;\n    vec3 p1p5 = p5 - p1;\n    vec3 p1p6 = p6 - p1;\n    vec3 p1p7 = p7 - p1;\n\n    vec3 p2p3 = p3 - p2;\n    vec3 p2p4 = p4 - p2;\n    vec3 p2p5 = p5 - p2;\n    vec3 p2p6 = p6 - p2;\n    vec3 p2p7 = p7 - p2;\n\n    vec3 p3p4 = p4 - p3;\n    vec3 p3p5 = p5 - p3;\n    vec3 p3p6 = p6 - p3;\n    vec3 p3p7 = p7 - p3;\n\n    vec3 p4", "\n    vec3 p0 = a;\n    vec3 p1 = b;\n    vec3 p2 = p;\n    vec3 p3 = p + r * (p1 - p0);\n    vec3 p4 = p + r * (p2 - p0);\n    vec3 p5 = p + r * (p3 - p0);\n    vec3 p6 = p + r * (p4 - p0);\n    vec3 p7 = p + r * (p5 - p0);\n    vec3 p8 = p + r * (p6 - p0);\n    vec3 p9 = p + r * (p7 - p0);\n    vec3 p10 = p + r * (p8 - p0);\n    vec3 p11 = p + r * (p9 - p0);\n    vec3 p12 = p + r * (p10 - p0);\n    vec3 p13 = p + r * (p11 - p0);\n    vec3 p14 = p + r * (p12 - p0);\n    vec3 p15 = p + r * (p13 - p0);\n    vec3 p16 = p + r * (p14 - p0);\n    vec3 p17 = p + r * (p15 - p0);\n    vec3 p18 = p + r * (p16 - p0);\n    vec3 p19 = p + r * (p17 - p0);\n    vec3 p20 = p + r * (p18 - p0);\n    vec3 p21 = p + r * (p19 - p0);\n    vec3 p22 = p + r * (p20 - p0);\n    vec3 p23 = p + r * (p21 - p0);\n    vec3 p24 = p + r * (p22 - p0);\n    vec3 p25 = p + r * (p23 - p0);\n    vec3 p26 = p + r * (p24 - p0);\n    vec3 p27 = p + r * (p25 - p0);\n    vec3 p28 = p + r * (p26 - p0);\n    vec3 p29 = p + r * (p27 - p0", "\n    float x = p.x - wi;\n    float y = p.y - he;\n    float z = p.z - sk;\n    float w = wi + sk;\n    float h = he + w;\n    float s = sk - w;\n    float d = (x*x + y*y + z*z) / (w*w + h*h + s*s);\n    return d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat", "\n    vec3 p1 = p + vec2(wi, 0.0);\n    vec3 p2 = p + vec2(0.0, he);\n    vec3 p3 = p + vec2(0.0, 0.0);\n    vec3 p4 = p + vec2(wi, 0.0);\n\n    vec3 p1p2 = p1 - p2;\n    vec3 p2p3 = p2 - p3;\n    vec3 p3p4 = p3 - p4;\n    vec3 p4p1 = p4 - p1;\n\n    vec3 p1p2p3 = p1p2 - p3p4;\n    vec3 p2p3p4 = p2p3 - p4p1;\n    vec3 p3p4p1 = p3p4 - p1p2;\n    vec3 p4p1p2 = p4p1 - p2p3;\n\n    vec3 p1p2p3p4 = p1p2p3 - p4p1p2;\n    vec3 p2p3p4p1 = p2p3p4 - p1p2p3;\n    vec3 p3p4p1p2 = p3p4p1 - p2p3p4;\n    vec3 p4p1p2p3 = p4p1p2 - p3p4p1;\n\n    vec3 p1p2p3p4p1 = p1p2p3p4 - p1p2p3p4;\n    vec3 p2p3p4p1p2 = p2p3p4p1 - p2p3p4p1;\n    vec3 p3p4p1p2p3 = p3p4p1p2 - p3p4p1p2;\n    vec3 p4p1p2p3p4 = p4p1p2p3 - p4p1p2p3;\n\n    vec3 p1p2p3p4p1p2 = p1p2p3p4p1p2 - p1p2p3p4p1;\n    vec3 p2p3p4p1p", "\n\t\treturn p*c;\n\t}\n\n//----------oPeraciones de Repeticiones\nfloat", "\n    return (a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", "\n    vec2 res = p;\n    res.x = (res.x % size.x) + size.x;\n    res.y = (res.y % size.y) + size.y;\n    return res;\n}\n\n// http://mercury.sexy/hg_sdf/vec2_add\nvec", "\n    vec3 h = c.x;\n    vec3 s = c.y;\n    vec3 v = c.z;\n\n    float h_r = h / 6.0;\n    float h_g = (h / 2.0) % 2.0;\n    float h_b = (h / 2.0 + 1.0) % 2.0;\n\n    float s_r = s / 2.0;\n    float s_g = s / 2.0;\n    float s_b = s / 2.0;\n\n    float v_r = v;\n    float v_g = v;\n    float v_b = v;\n\n    float h_r_prime = h_r;\n    float h_g_prime = h_g;\n    float h_b_prime = h_b;\n\n    float s_r_prime = s_r;\n    float s_g_prime = s_g;\n    float s_b_prime = s_b;\n\n    float v_r_prime = v_r;\n    float v_g_prime = v_g;\n    float v_b_prime = v_b;\n\n    float h_r_prime_prime = h_r_prime;\n    float h_g_prime_prime = h_g_prime;\n    float h_b_prime_prime = h_b_prime;\n\n    float h_r_prime_prime_prime = h_r_prime_prime;\n    float h_g_prime_prime_prime = h_g_prime_prime;\n    float h_b_prime_prime_prime = h_b_prime_prime;\n\n    float h_r_prime_prime_prime_prime = h_r_prime_prime_prime;\n    float h_g_prime_prime_prime_prime = h_g_prime_prime_prime;\n    float h_b_prime_prime_prime_prime = h_b_prime_prime_prime;\n\n    float h_r_prime_prime_prime_prime_prime = h_r_prime_prime_prime_prime;\n    float h_g_prime_prime_prime_prime_prime = h_g_prime_prime_prime", "\n    vec3 r = ro - s.xyz;\n    vec3 d = rd - s.xyz;\n    vec3 n = normalize(cross(r, d));\n    vec3 t = dot(r, n);\n    if (t < 0) return vec3(0, 0, 0);\n    vec3 p = s.xyz + t * d;\n    return p;\n}\n\n// Ray-plane intersection\nvec", "\n    vec3 ray = ro - rd;\n    vec3 rayDir = normalize(ray);\n    vec3 boxMin = boxSize - rd;\n    vec3 boxMax = boxSize + rd;\n    vec3 boxMinRay = boxMin - ray;\n    vec3 boxMaxRay = boxMax - ray;\n    vec3 boxMinRayDir = normalize(boxMinRay);\n    vec3 boxMaxRayDir = normalize(boxMaxRay);\n    vec3 boxMinRayDirOut = boxMinRayDir * outNormal;\n    vec3 boxMaxRayDirOut = boxMaxRayDir * outNormal;\n    vec3 boxMinRayDirOutRay = boxMinRayDirOut * rayDir;\n    vec3 boxMaxRayDirOutRay = boxMaxRayDirOut * rayDir;\n    vec3 boxMinRayDirOutRayDir = boxMinRayDirOutRay * boxMinRayDir;\n    vec3 boxMaxRayDirOutRayDir = boxMaxRayDirOutRay * boxMaxRayDir;\n    vec3 boxMinRayDirOutRayDirOut = boxMinRayDirOutRayDir * boxMinRayDirOut;\n    vec3 boxMaxRayDirOutRayDirOut = boxMaxRayDirOutRayDir * boxMaxRayDirOut;\n    vec3 boxMinRayDirOutRayDirOutRay = boxMinRayDirOutRayDirOut * boxMinRayDirOutRay;\n    vec3 boxMaxRayDirOutRayDirOutRay = boxMaxRayDirOutRayDirOut * boxMaxRayDirOutRay;\n    vec3 boxMinRayDirOutRayDirOutRayDir = boxMinRayDirOutRayDirOut * boxMinRayDirOutRayDir;\n    vec3 boxMaxRayDirOutRayDirOutRayDir = boxMaxRayDirOutRayDirOut * boxMaxRayDirOutRayDir;\n    vec3 boxMinRayDirOutRayDirOutRayDirOut = boxMinRayDirOutRayDirOut * boxMinRayDirOutRayDirOut;\n    vec3 boxMaxRayDirOutRayDirOutRayDirOut = boxMaxRayDirOutRayDirOut * boxMaxRayDirOutRayDirOut;\n    vec3 boxMinRayDirOutRayDirOutRayDirOutRay = boxMinRayDirOutRayDirOut * boxMinRayDirOutRayDirOutRay", "\n    vec2 e1 = p + d;\n    vec2 e2 = p - d;\n    vec2 e3 = p + d;\n    vec2 e4 = p - d;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvec", "\n    float d = 0;\n    if (a.x == b.x) {\n        d = fabs(a.y - p.y);\n    } else {\n        d = fabs((a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x));\n    }\n    return d;\n}\n\nfloat", "\n    float dx = b.x - a.x;\n    float dy = b.y - a.y;\n    float d = sqrt( dx*dx + dy*dy );\n    float theta = atan2( dy, dx );\n    float theta1 = theta + w1;\n    float theta2 = theta - w2;\n    float theta3 = theta;\n    float theta4 = theta + w2;\n    float theta5 = theta - w1;\n    float theta6 = theta;\n    float theta7 = theta + w1;\n    float theta8 = theta - w2;\n    float theta9 = theta;\n    float theta10 = theta + w2;\n    float theta11 = theta - w1;\n    float theta12 = theta;\n    float theta13 = theta + w1;\n    float theta14 = theta - w2;\n    float theta15 = theta;\n    float theta16 = theta + w2;\n    float theta17 = theta - w1;\n    float theta18 = theta;\n    float theta19 = theta + w1;\n    float theta20 = theta - w2;\n    float theta21 = theta;\n    float theta22 = theta + w2;\n    float theta23 = theta - w1;\n    float theta24 = theta;\n    float theta25 = theta + w1;\n    float theta26 = theta - w2;\n    float theta27 = theta;\n    float theta28 = theta + w2;\n    float theta29 = theta - w1;\n    float theta30 = theta;\n    float theta31 = theta + w1;\n    float theta32 = theta - w2;\n    float theta33 = theta;\n    float theta34 = theta + w1;\n    float theta35 = theta - w2;\n    float theta36 = theta;\n    float theta37 = theta + w1;\n    float theta38 = theta - w", "\n    vec3 r = rd - ro;\n    vec3 r2 = r.norm2();\n    vec3 r3 = r.norm3();\n    vec3 r4 = r.norm4();\n    vec3 r5 = r.norm5();\n    vec3 r6 = r.norm6();\n    vec3 r7 = r.norm7();\n    vec3 r8 = r.norm8();\n    vec3 r9 = r.norm9();\n    vec3 r10 = r.norm10();\n    vec3 r11 = r.norm11();\n    vec3 r12 = r.norm12();\n    vec3 r13 = r.norm13();\n    vec3 r14 = r.norm14();\n    vec3 r15 = r.norm15();\n    vec3 r16 = r.norm16();\n    vec3 r17 = r.norm17();\n    vec3 r18 = r.norm18();\n    vec3 r19 = r.norm19();\n    vec3 r20 = r.norm20();\n    vec3 r21 = r.norm21();\n    vec3 r22 = r.norm22();\n    vec3 r23 = r.norm23();\n    vec3 r24 = r.norm24();\n    vec3 r25 = r.norm25();\n    vec3 r26 = r.norm26();\n    vec3 r27 = r.norm27();\n    vec3 r28 = r.norm28();\n    vec3 r29 = r.norm29();\n    vec3 r30 = r.norm30();\n    vec3 r31 = r.norm31();\n    vec3 r32 = r.norm32();\n    vec3 r33 = r.norm33();\n    vec3 r34 = r.norm34();\n    vec3 r35 = r.norm35();\n    vec3 r36 = r.norm36();\n    vec3 r37 = r.norm37();\n    vec3 r38 = r.norm38();\n    vec3 r39 = r.norm39();\n    vec3 r40 = r.norm40();\n    vec3 r41 = r.norm41();\n    vec3 r42 = r.norm42();\n    vec3 r43 = r.", "\n    vec3 normal;\n    vec3 normal2;\n    vec3 normal3;\n    vec3 normal4;\n    vec3 normal5;\n    vec3 normal6;\n    vec3 normal7;\n    vec3 normal8;\n    vec3 normal9;\n    vec3 normal10;\n    vec3 normal11;\n    vec3 normal12;\n    vec3 normal13;\n    vec3 normal14;\n    vec3 normal15;\n    vec3 normal16;\n    vec3 normal17;\n    vec3 normal18;\n    vec3 normal19;\n    vec3 normal20;\n    vec3 normal21;\n    vec3 normal22;\n    vec3 normal23;\n    vec3 normal24;\n    vec3 normal25;\n    vec3 normal26;\n    vec3 normal27;\n    vec3 normal28;\n    vec3 normal29;\n    vec3 normal30;\n    vec3 normal31;\n    vec3 normal32;\n    vec3 normal33;\n    vec3 normal34;\n    vec3 normal35;\n    vec3 normal36;\n    vec3 normal37;\n    vec3 normal38;\n    vec3 normal39;\n    vec3 normal40;\n    vec3 normal41;\n    vec3 normal42;\n    vec3 normal43;\n    vec3 normal44;\n    vec3 normal45;\n    vec3 normal46;\n    vec3 normal47;\n    vec3 normal48;\n    vec3 normal49;\n    vec3 normal50;\n    vec3 normal51;\n    vec3 normal52;\n    vec3 normal53;\n    vec3 normal54;\n    vec3 normal55;\n    vec3 normal56;\n    vec3 normal57;\n    vec3 normal58;\n    vec3 normal59;\n    vec3 normal60;\n    vec3 normal61;\n    vec3 normal62;\n    vec3 normal63;\n    vec3 normal64;\n    vec3 normal65;\n    vec3 normal66;\n    vec3 normal67;\n    vec3 normal68;\n    vec3 normal69;\n    vec3 normal70;\n    vec3 normal71;\n    vec3 normal72;\n    vec3 normal73;\n    ", "\n    return (1.0f - exp(-x)) / (1.0f + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec3 r = col;\n    r.x = (r.x - q.x) * (r.x - q.x) * (r.x - q.x) + (r.y - q.y) * (r.y - q.y) * (r.y - q.y) + (r.z - q.z) * (r.z - q.z) * (r.z - q.z);\n    r.x = r.x / (q.x * q.x + q.y * q.y + q.z * q.z);\n    r.y = r.y / (q.x * q.x + q.y * q.y + q.z * q.z);\n    r.z = r.z / (q.x * q.x + q.y * q.y + q.z * q.z);\n    return r;\n}\n\n// This function is used to calculate the distance between two points\nfloat", "\n    vec2 res;\n    res.x = p.x % size.x;\n    res.y = p.y % size.y;\n    return res;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf\nvec", "\n    float h = 0.0f;\n    float x = uv.x;\n    float y = uv.y;\n    h = (x + y) * (x + y) * (x + y) * (x + y);\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y)) >> 16;\n    h = (h * (x + y) * (x + y) * (x + y", "\n    float d = sqrt( (p.x - c.x) * (p.x - c.x) + (p.y - c.y) * (p.y - c.y) );\n    if( d > r )\n        return 0.f;\n    else\n        return d;\n}\n\n// signed distance to a line\nfloat", "\n    float u = (p - a).dot(b - a);\n    float v = (b - a).dot(b - a);\n    float w = (p - a).dot(p - a);\n    float d = (u > v)? u : v;\n    float e = (u > w)? u : w;\n    float f = (v > w)? v : w;\n    float s = (d > e)? d : e;\n    float t = (d > f)? d : f;\n    return (s > t)? s : t;\n}\n\n// distance to a line segment\nfloat", "\n    float x = a.x - b.x;\n    float y = a.y - b.y;\n    float d = x*x + y*y;\n    return sqrt(d);\n}\n\n// signed distance to a 2D triangle\nfloat", "\n    float x = p.x - s/2;\n    float y = p.y - s/2;\n    float dx = x*x;\n    float dy = y*y;\n    float d = sqrt(dx + dy);\n    float r2 = r*r;\n    float s2 = s*s;\n    float s3 = s2*s;\n    float s4 = s2*s2;\n    float s5 = s2*s2*s;\n    float s6 = s2*s2*s2;\n    float s7 = s2*s2*s2*s;\n    float s8 = s2*s2*s2*s2;\n    float s9 = s2*s2*s2*s2*s;\n    float s10 = s2*s2*s2*s2*s2*s;\n    float s11 = s2*s2*s2*s2*s2*s2*s;\n    float s12 = s2*s2*s2*s2*s2*s2*s2*s;\n    float s13 = s2*s2*s2*s2*s2*s2*s2*s2*s;\n    float s14 = s2*s2*s2*s2*s2*s2*s2*s2*s2*s;\n    float s15 = s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s;\n    float s16 = s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s;\n    float s17 = s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s;\n    float s18 = s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s2*s;\n    float s19 = s2*s2*s2", "\n    vec3 y = x;\n    vec3 z = x;\n    vec3 w = x;\n    vec3 u = x;\n    vec3 v = x;\n    vec3 t = x;\n    vec3 s = x;\n    vec3 a = x;\n    vec3 b = x;\n    vec3 c = x;\n    vec3 d = x;\n    vec3 e = x;\n    vec3 f = x;\n    vec3 g = x;\n    vec3 h = x;\n    vec3 i = x;\n    vec3 j = x;\n    vec3 k = x;\n    vec3 l = x;\n    vec3 m = x;\n    vec3 n = x;\n    vec3 o = x;\n    vec3 p = x;\n    vec3 q = x;\n    vec3 r = x;\n    vec3 s1 = x;\n    vec3 s2 = x;\n    vec3 s3 = x;\n    vec3 s4 = x;\n    vec3 s5 = x;\n    vec3 s6 = x;\n    vec3 s7 = x;\n    vec3 s8 = x;\n    vec3 s9 = x;\n    vec3 s10 = x;\n    vec3 s11 = x;\n    vec3 s12 = x;\n    vec3 s13 = x;\n    vec3 s14 = x;\n    vec3 s15 = x;\n    vec3 s16 = x;\n    vec3 s17 = x;\n    vec3 s18 = x;\n    vec3 s19 = x;\n    vec3 s20 = x;\n    vec3 s21 = x;\n    vec3 s22 = x;\n    vec3 s23 = x;\n    vec3 s24 = x;\n    vec3 s25 = x;\n    vec3 s26 = x;\n    vec3 s27 = x;\n    vec3 s28 = x;\n    vec3 s29 = x;\n    vec3 s30 = x;\n    vec3 s31 = x;\n    vec3 s32 = x;\n    vec3 s33 = x;\n    vec3 s34 = x;\n    vec3 s35", "\n    vec3 d_s_curve_x = vec3(1, 0, 0);\n    vec3 d_s_curve_y = vec3(0, 1, 0);\n    vec3 d_s_curve_z = vec3(0, 0, 1);\n    return (d_s_curve_x * x) + (d_s_curve_y * x) + (d_s_curve_z * x);\n}\n\n// derivative of s-curve\nvec", "\n    float x = p.x - w / 2;\n    float y = p.y - w / 2;\n    float r = sqrt( x * x + y * y );\n    float theta = atan2( y, x );\n    float theta_k = theta + k * 2 * M_PI / k;\n    float r_k = r * cos( theta_k );\n    float x_k = r_k * cos( theta_k );\n    float y_k = r_k * sin( theta_k );\n    return vec2( x_k, y_k );\n}\n\nA:\n\nI think you are looking for the following:\nfloat", "\n    vec3 l = vec3(1.0);\n    vec3 t = vec3(0.0);\n    vec3 r = vec3(0.0);\n    vec3 s = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y", "\n    // Ray is not parallel to the light direction\n    if (dot(rayDir, lightDir)!= 0.0)\n    {\n        // Ray is not parallel to the surface normal\n        if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n        {\n            // Ray is not parallel to the surface normal\n            if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n            {\n                // Ray is not parallel to the surface normal\n                if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                {\n                    // Ray is not parallel to the surface normal\n                    if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                    {\n                        // Ray is not parallel to the surface normal\n                        if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                        {\n                            // Ray is not parallel to the surface normal\n                            if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                            {\n                                // Ray is not parallel to the surface normal\n                                if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                                {\n                                    // Ray is not parallel to the surface normal\n                                    if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                                    {\n                                        // Ray is not parallel to the surface normal\n                                        if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                                        {\n                                            // Ray is not parallel to the surface normal\n                                            if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                                            {\n                                                // Ray is not parallel to the surface normal\n                                                if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                                                {\n                                                    // Ray is not parallel to the surface normal\n                                                    if (dot(rayDir, normalize(rayStart - lightDir))!= 0.0)\n                                                    {\n                                                        // Ray is not parallel to the surface normal\n                                                        if (dot(rayDir,", "\n    float r = sqrt(pow(p2.x,2) + pow(p2.y,2) + pow(p2.z,2));\n    if( r < rb )\n    {\n        return 1.0;\n    }\n    else if( r < ra )\n    {\n        return 0.0;\n    }\n    else\n    {\n        return (d/ra) * (1.0 - (d/rb));\n    }\n}\n\nA:\n\nI think you are looking for the following:\nfloat", "\n    float x = p.x - r;\n    float y = p.y - r;\n    float z = p.z - r;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float z3 = z2 * z;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float z4 = z3 * z;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float z5 = z4 * z;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float z6 = z5 * z;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float z7 = z6 * z;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float z8 = z7 * z;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float z9 = z8 * z;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float z10 = z9 * z;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float z11 = z10 * z;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float z12 = z11 * z;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float z13 = z12 * z;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float z14 = z13 * z;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float z15 = z14 * z;\n    float x16 = x15 * x;\n    float y16 = y15 *", "\n    vec3 r = rd - ro;\n    float d = dot( r, r );\n    if( d == 0 ) return 0.0f;\n    float t = ( tmax - tmin ) * ( d / ( 1.0f - d ) );\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41 * t;\n", "\n    float x = p.x - r;\n    float y = p.y - r;\n    float z = p.z - r;\n    float s = sqrt( x*x + y*y + z*z );\n    float t = sqrt( x*x + y*y + z*z - h*h );\n    return (s < t)? 1.0 : 0.0;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat", "\n    vec3 normal;\n    normal = normalize( cross( pos - vec3(0.5,0.5,0.5), vec3(0,1,0) ) );\n    return normal;\n}\n\n// https://www.cs.cmu.edu/~dick/courses/cs36c/lectures/lecture3.pdf\nvec", "\n    float x, y;\n    float r2 = r*r;\n    float h2 = h*h;\n    float h3 = h*h*h;\n    float h4 = h*h*h*h;\n    float h5 = h*h*h*h*h;\n    float h6 = h*h*h*h*h*h;\n    float h7 = h*h*h*h*h*h*h;\n    float h8 = h*h*h*h*h*h*h*h;\n    float h9 = h*h*h*h*h*h*h*h*h;\n    float h10 = h*h*h*h*h*h*h*h*h*h;\n    float h11 = h*h*h*h*h*h*h*h*h*h*h;\n    float h12 = h*h*h*h*h*h*h*h*h*h*h*h;\n    float h13 = h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h14 = h*h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h15 = h*h*h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h16 = h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h17 = h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h18 = h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h19 = h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h*h;\n    float h20", "\n    vec3 u = x - vec3(0.5, 0.5, 0.5);\n    vec3 v = u * u;\n    vec3 w = v * v;\n    vec3 xy = u * v;\n    vec3 xz = u * w;\n    vec3 yz = v * w;\n    vec3 xyz = xy + xz + yz;\n    vec3 xyz2 = xyz * xyz;\n    vec3 xyz3 = xyz2 * xyz;\n    vec3 xyz4 = xyz3 * xyz;\n    vec3 xyz5 = xyz4 * xyz;\n    vec3 xyz6 = xyz5 * xyz;\n    vec3 xyz7 = xyz6 * xyz;\n    vec3 xyz8 = xyz7 * xyz;\n    vec3 xyz9 = xyz8 * xyz;\n    vec3 xyz10 = xyz9 * xyz;\n    vec3 xyz11 = xyz10 * xyz;\n    vec3 xyz12 = xyz11 * xyz;\n    vec3 xyz13 = xyz12 * xyz;\n    vec3 xyz14 = xyz13 * xyz;\n    vec3 xyz15 = xyz14 * xyz;\n    vec3 xyz16 = xyz15 * xyz;\n    vec3 xyz17 = xyz16 * xyz;\n    vec3 xyz18 = xyz17 * xyz;\n    vec3 xyz19 = xyz18 * xyz;\n    vec3 xyz20 = xyz19 * xyz;\n    vec3 xyz21 = xyz20 * xyz;\n    vec3 xyz22 = xyz21 * xyz;\n    vec3 xyz23 = xyz22 * xyz;\n    vec3 xyz24 = xyz23 * xyz;\n    vec3 xyz25 = xyz24 * xyz;\n    vec3 xyz26 = xyz25 * xyz;\n    vec3 xyz27 = xyz26 * xyz;\n    vec3 xyz28 = xyz27 * xyz;\n    vec3 xyz29 = xyz28 * xyz;\n", "\n    float x,y,z;\n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    float s = r*r*r;\n    float t = r*r*r*r;\n    float u = r*r*r*r*r;\n    float v = r*r*r*r*r*r;\n    float w = r*r*r*r*r*r*r;\n    float x0 = 0.0;\n    float y0 = 0.0;\n    float z0 = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float z2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float z3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float z4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float z5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float z6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float z7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float z8 = 0.0;\n    float x9 = 0.0;\n    float y9 = 0.0;\n    float z9 = 0.0;\n    float x10 = 0.0;\n    float y10 = 0.0;\n    float z10 = 0.0;\n    float x11 = 0.0;\n    float y11 = 0.0;\n    float z11 = 0.0;\n    float x12 = 0.0;\n    float y12 = 0.0;\n    float z12 = 0.0;\n    float x13 = 0.0", "\n    float h = 0.0f;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.y;\n    h += p3.x * p3.z;\n    h += p3.y * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.y;\n    h += p3.x * p3.z;\n    h += p3.y * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.", "\n    vec2 coord = vec2(fragCoord.x, fragCoord.y);\n    vec2 center = vec2(0.5, 0.5);\n    vec2 distance = vec2(coord.x - center.x, coord.y - center.y);\n    vec2 normal = vec2(distance.y, -distance.x);\n    vec2 normalize = normal.normalize();\n    vec2 u = normalize.xy;\n    vec2 v = normalize.yx;\n    vec2 w = vec2(0, 1);\n    vec2 uv = u.xy;\n    vec2 vv = v.yx;\n    vec2 uvw = uv.xyw;\n    vec2 vvw = vv.yxw;\n    vec2 uvwv = uvw.xyv;\n    vec2 vvwv = vvw.yxv;\n    vec2 uvwvw = uvwv.xyvw;\n    vec2 vvwvw = vvwv.yxvw;\n    vec2 uvwvwv = uvwvw.xyvwv;\n    vec2 vvwvwv = vvwvw.yxvwv;\n    vec2 uvwvwvw = uvwvwv.xyvwvw;\n    vec2 vvwvwvw = vvwvwv.yxvwvw;\n    vec2 uvwvwvwv = uvwvwvw.xyvwvwv;\n    vec2 vvwvwvwv = vvwvwvw.yxvwvwv;\n    vec2 uvwvwvwvw = uvwvwvwv.xyvwvwvw;\n    vec2 vvwvwvwvw = vvwvwvwv.yxvwvwvw;\n    vec2 uvwvwvwvww = uvwvwvwvw.xyvwvwvww;\n    vec2 vvwvwvwvww = vv", "\n    float h = c.x;\n    float s = c.y;\n    float v = c.z;\n\n    float i = (h * 6.0f) + 1.0f;\n    float f = (h * 6.0f) / 6.0f;\n\n    float q = f + (i * (v * 2.0f - 1.0f));\n    float p = f + (i * (v * 2.0f + 1.0f));\n    float t = f + (i * (v * 2.0f - 1.0f));\n\n    if (i < 1.0f) {\n        return vec3(v, t, p);\n    } else if (i < 2.0f) {\n        return vec3(q, v, p);\n    } else if (i < 3.0f) {\n        return vec3(p, v, t);\n    } else if (i < 4.0f) {\n        return vec3(p, q, v);\n    } else if (i < 5.0f) {\n        return vec3(t, p, v);\n    } else {\n        return vec3(v, p, q);\n    }\n}\n\nA:\n\nI think you can use the following code:\nvec", "\n    float r = p % size;\n    if (r < 0) {\n        r += size;\n    }\n    return r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf\nfloat", "\n    float h = 0;\n    for (int i = 0; i < co.size(); i++) {\n        h += co[i];\n    }\n    return h;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    // https://en.wikipedia.org/wiki/SRGB\n    // https://en.wikipedia.org/wiki/Gamma_correction#Gamma_correction_for_RGB_color_space\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_linear_to_srgb_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_srgb_to_linear_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_linear_to_srgb_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_srgb_to_linear_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_linear_to_srgb_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_srgb_to_linear_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_linear_to_srgb_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_srgb_to_linear_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_the_linear_to_srgb_conversion\n    // https://en.wikipedia.org/wiki/SRGB#The_gamma_correction_formula#The_formula_for_", "\n    vec3 v = vec3(c);\n    v = v * vec3(0.412453, 0.357580, 0.180423);\n    v = v + vec3(0.212671, 0.715160, 0.072169);\n    v = v + vec3(0.019334, 0.119193, 0.950227);\n    return v;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return (a < b)? a : (a < k? a : k);\n}\n\nfloat", "\n    vec3 r = ro - rd;\n    float d = dot(r, r);\n    float t = d / (d + sph.r2);\n    vec3 rt = r * t;\n    vec3 rt2 = rt * t;\n    vec3 rt3 = rt * t;\n    vec3 rt4 = rt * t;\n    vec3 rt5 = rt * t;\n    vec3 rt6 = rt * t;\n    vec3 rt7 = rt * t;\n    vec3 rt8 = rt * t;\n    vec3 rt9 = rt * t;\n    vec3 rt10 = rt * t;\n    vec3 rt11 = rt * t;\n    vec3 rt12 = rt * t;\n    vec3 rt13 = rt * t;\n    vec3 rt14 = rt * t;\n    vec3 rt15 = rt * t;\n    vec3 rt16 = rt * t;\n    vec3 rt17 = rt * t;\n    vec3 rt18 = rt * t;\n    vec3 rt19 = rt * t;\n    vec3 rt20 = rt * t;\n    vec3 rt21 = rt * t;\n    vec3 rt22 = rt * t;\n    vec3 rt23 = rt * t;\n    vec3 rt24 = rt * t;\n    vec3 rt25 = rt * t;\n    vec3 rt26 = rt * t;\n    vec3 rt27 = rt * t;\n    vec3 rt28 = rt * t;\n    vec3 rt29 = rt * t;\n    vec3 rt30 = rt * t;\n    vec3 rt31 = rt * t;\n    vec3 rt32 = rt * t;\n    vec3 rt33 = rt * t;\n    vec3 rt34 = rt * t;\n    vec3 rt35 = rt * t;\n    vec3 rt36 = rt * t;\n    vec3 rt37 =", "\n    vec4 q = p;\n    q.x = p.x * p.x;\n    q.y = p.y * p.y;\n    q.z = p.z * p.z;\n    q.w = p.w * p.w;\n    return q;\n}\n\nvec", "\n    vec3 x = p.x;\n    vec3 y = p.y;\n    vec3 z = p.z;\n    vec3 w = vec3(0,0,0,1);\n    vec3 xyw = vec3(x,y,w);\n    vec3 xyzw = vec3(x,y,z,w);\n    vec3 xyzwxy = vec3(x,y,z,w);\n    vec3 xyzwxyz = vec3(x,y,z,w);\n    vec3 xyzwxyzw = vec3(x,y,z,w);\n    vec3 xyzwxyzwxy = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyz = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzw = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxy = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyz = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzw = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxy = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxyz = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxyzw = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxyzwxy = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxyzwxyz = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxyzwxyzw = vec3(x,y,z,w);\n    vec3 xyzwxyzwxyzwxyzwxyzwxyzwxy =", "\n    return vec4(front.a * back.a + back.a * front.a,\n                front.a * back.a + back.a * front.a,\n                front.a * back.a + back.a * front.a,\n                front.a * back.a + back.a * front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    vec4 color = front.rgba;\n    vec4 color_back = back.rgba;\n    vec4 color_back_alpha = color_back.a;\n    vec4 color_front_alpha = color.a;\n    vec4 color_front_back = color_front.rgba;\n    vec4 color_front_back_alpha = color_front_back.a;\n    vec4 color_back_front = color_back.rgba;\n    vec4 color_back_front_alpha = color_back_front.a;\n    vec4 color_front_back_front = color_front_back.rgba;\n    vec4 color_front_back_front_alpha = color_front_back_front.a;\n    vec4 color_back_front_front_alpha = color_back_front_alpha;\n    vec4 color_front_back_front_alpha_back = color_front_back_front_alpha;\n    vec4 color_front_back_front_alpha_front = color_front_back_front_alpha;\n    vec4 color_back_front_front_alpha_front = color_back_front_front_alpha;\n    vec4 color_back_front_front_alpha_back = color_back_front_front_alpha;\n    vec4 color_front_back_front_alpha_back_front = color_front_back_front_alpha_back;\n    vec4 color_front_back_front_alpha_back_front_front = color_front_back_front_alpha_back_front;\n    vec4 color_front_back_front_alpha_back_front_front = color_front_back_front_alpha_back_front_front;\n    vec4 color_front_back_front_alpha_back_front_front_front = color_front_back_front_alpha_back_front_front_front;\n    vec4 color_front_back_front_alpha_back_front_front_front_front = color_front_back_front_alpha_back_front_front_front_front;\n    vec4 color_front_back_front_alpha_back_front_front_front_front_front = color_front", "\n    float x, y;\n    x = p.x;\n    y = p.y;\n    x = x / r;\n    y = y / r;\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.0f);\n    x = x * (1.0f / 3.0f);\n    y = y * (1.0f / 3.", "\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    vec3 a = vec3(0.0, 0.0, 1.0);\n    vec3 b = vec3(0.0, 1.0, 0.0);\n    vec3 c = vec3(1.0, 0.0, 0.0);\n    vec3 d = vec3(1.0, 1.0, 0.0);\n    vec3 e = vec3(1.0, 0.0, 1.0);\n    vec3 f = vec3(0.0, 1.0, 1.0);\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    vec3 h = vec3(0.0, 0.0, 1.0);\n    vec3 i = vec3(1.0, 1.0, 1.0);\n    vec3 j = vec3(1.0, 0.0, 1.0);\n    vec3 k = vec3(1.0, 1.0, 0.0);\n    vec3 l = vec3(0.0, 1.0, 1.0);\n    vec3 m = vec3(0.0, 0.0, 1.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 o = vec3(1.0, 0.0, 1.0);\n    vec3 p = vec3(1.0, 1.0, 1.0);\n    vec3 q = vec3(1.0, 0.0, 0.0);\n    vec3 r = vec3(1.0, 1.0, 0.0);\n    vec3 s = vec3(0.0, 1.0, 1.0);\n    vec3 t = vec3(0.0, 0.0, 1.0);\n    vec3 u = vec3(1.0, 1.0, 1.0);\n    vec3 v = vec3(1.0, 0.0, 1.0);\n    vec3 w = vec3(1.0, 1.0, 0.0);\n    vec3 x = vec3", "\n    return p.x * p.x + p.y * p.y;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    vec3 r = vec3(0.0, 0.0, 1.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 r_c = vec3(0.0, 0.0, 0.0);\n    vec3 r_s = vec3(0.0, 0.0, 0.0);\n    vec3 r_w = vec3(0.0, 0.0, 0.0);\n    vec3 r_r = vec3(0.0, 0.0, 0.0);\n    vec3 r_c_r = vec3(0.0, 0.0, 0.0);\n    vec3 r_s_r = vec3(0.0, 0.0, 0.0);\n    vec3 r_w_r = vec3(0.0, 0.0, 0.0);\n    vec3 r_r_r = vec3(0.0, 0.0, 0.0);\n    vec3 r_c_c = vec3(0.0, 0.0, 0.0);\n    vec3 r_s_c = vec3(0.0, 0.0, 0.0);\n    vec3 r_w_c = vec3(0.0, 0.0, 0.0);\n    vec3 r_r_c = vec3(0.0, 0.0, 0.0);\n    vec3 r_c_s = vec3(0.0, 0.0, 0.0);\n    vec3 r_s_s = vec3(0.0, 0.0, 0.0);\n    vec3 r_w_s = vec3(0.0, 0.0, 0.0);\n    vec3 r_r_s = vec3(0.0, 0.0, 0.0);\n    vec3 r_c_w = vec3(0.0, 0.0, 0.0);\n    vec3 r_s_w = vec", "\n    float x = p.x;\n    float y = p.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float x4 = x3 * x;\n    float x5 = x4 * x;\n    float x6 = x5 * x;\n    float x7 = x6 * x;\n    float x8 = x7 * x;\n    float x9 = x8 * x;\n    float x10 = x9 * x;\n    float x11 = x10 * x;\n    float x12 = x11 * x;\n    float x13 = x12 * x;\n    float x14 = x13 * x;\n    float x15 = x14 * x;\n    float x16 = x15 * x;\n    float x17 = x16 * x;\n    float x18 = x17 * x;\n    float x19 = x18 * x;\n    float x20 = x19 * x;\n    float x21 = x20 * x;\n    float x22 = x21 * x;\n    float x23 = x22 * x;\n    float x24 = x23 * x;\n    float x25 = x24 * x;\n    float x26 = x25 * x;\n    float x27 = x26 * x;\n    float x28 = x27 * x;\n    float x29 = x28 * x;\n    float x30 = x29 * x;\n    float x31 = x30 * x;\n    float x32 = x31 * x;\n    float x33 = x32 * x;\n    float x34 = x33 * x;\n    float x35 = x34 * x;\n    float x36 = x35 * x;\n    float x37 = x36 * x;\n    float x38 = x37 * x;\n    float x39 = x38 * x;\n    float x40 = x39 * x;\n    float x41 = x40 * x;\n    float x42 = x41 * x;\n    float x43 = x42 * x;\n    float x44 = x43 * x;\n    float x45 = x44 * x;\n", "\n    vec3 r = ro - rd;\n    vec3 n = normalize(r);\n    vec3 u = normalize(sph.xyz - ro);\n    vec3 v = cross(n, u);\n    vec3 w = cross(u, v);\n    vec3 t = dot(n, w);\n    if (t < 0) {\n        return vec3(0, 0, 0);\n    }\n    vec3 t1 = dot(n, u);\n    vec3 t2 = dot(n, v);\n    vec3 t3 = dot(n, w);\n    vec3 t4 = dot(n, u) + dot(n, v) + dot(n, w);\n    vec3 t5 = dot(n, u) + dot(n, v) - dot(n, w);\n    vec3 t6 = dot(n, u) - dot(n, v) + dot(n, w);\n    vec3 t7 = dot(n, u) - dot(n, v) - dot(n, w);\n    vec3 t8 = dot(n, u) - dot(n, v) + dot(n, w);\n    vec3 t9 = dot(n, u) + dot(n, v) + dot(n, w);\n    vec3 t10 = dot(n, u) + dot(n, v) - dot(n, w);\n    vec3 t11 = dot(n, u) - dot(n, v) + dot(n, w);\n    vec3 t12 = dot(n, u) - dot(n, v) - dot(n, w);\n    vec3 t13 = dot(n, u) - dot(n, v) + dot(n, w);\n    vec3 t14 = dot(n, u) + dot(n, v) - dot(n, w);\n    vec3 t15 = dot(n, u) + dot(n, v) + dot(n, w);\n    vec3 t16 = dot(n, u) + dot(n, v) - dot(n, w);\n    vec3 t17 = dot(n, u) - dot(n, v) - dot(", "\n    vec3 r = p - vec2(0.5, 0.5);\n    vec3 s = r.normalize();\n    vec3 t = s.cross(vec2(0, 1));\n    vec3 u = t.cross(s);\n    vec3 v = s.cross(u);\n    vec3 w = s.cross(v);\n    vec3 x = n * s;\n    vec3 y = n * t;\n    vec3 z = n * u;\n    vec3 yz = n * v;\n    vec3 yzw = n * w;\n    vec3 xyz = n * x;\n    vec3 xyzw = n * yz;\n    vec3 xyzwz = n * yzw;\n    vec3 xyzwzw = n * xyzwz;\n    vec3 xyzwzwz = n * xyzwzw;\n    vec3 xyzwzwzw = n * xyzwzwz;\n    vec3 xyzwzwzwz = n * xyzwzwzw;\n    vec3 xyzwzwzwzw = n * xyzwzwzwz;\n    vec3 xyzwzwzwzwz = n * xyzwzwzwzw;\n    vec3 xyzwzwzwzwzw = n * xyzwzwzwzwz;\n    vec3 xyzwzwzwzwzwz = n * xyzwzwzwzwzw;\n    vec3 xyzwzwzwzwzwzw = n * xyzwzwzwzwzwz;\n    vec3 xyzwzwzwzwzwzww = n * xyzwzwzwzwzwzw;\n    vec3 xyzwzwzwzwzwzwww = n * xyzwzwzwzwzwzww;\n    vec3 xyzwzwzwzwzwzwwww = n * xyzwzwzwzwzwzwww;\n    vec3", "\n    if( t == 0 )\n        return x;\n    else\n        return cantor( x + 1/t, t/2 ) + 1/t * cantor( x - 1/t, t/2 );\n}\n\nA:\n\nI think you are looking for the following:\nfloat", "\n    float x = p.x - a.x;\n    float y = p.y - a.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x", "\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float x1 = x * (1.0 / 2.0);\n    float y1 = y * (1.0 / 2.0);\n    float z1 = z * (1.0 / 2.0);\n    float x2 = x1 * (1.0 / 2.0);\n    float y2 = y1 * (1.0 / 2.0);\n    float z2 = z1 * (1.0 / 2.0);\n    float x3 = x1 * (1.0 / 2.0);\n    float y3 = y1 * (1.0 / 2.0);\n    float z3 = z1 * (1.0 / 2.0);\n    float x4 = x1 * (1.0 / 2.0);\n    float y4 = y1 * (1.0 / 2.0);\n    float z4 = z1 * (1.0 / 2.0);\n    float x5 = x1 * (1.0 / 2.0);\n    float y5 = y1 * (1.0 / 2.0);\n    float z5 = z1 * (1.0 / 2.0);\n    float x6 = x1 * (1.0 / 2.0);\n    float y6 = y1 * (1.0 / 2.0);\n    float z6 = z1 * (1.0 / 2.0);\n    float x7 = x1 * (1.0 / 2.0);\n    float y7 = y1 * (1.0 / 2.0);\n    float z7 = z1 * (1.0 / 2.0);\n    float x8 = x1 * (1.0 / 2.0);\n    float y8 = y1 * (1.0 / 2.0);\n    float z8 = z1 * (1.0 / 2.0);\n    float x9 = x1 * (1.0 / 2.0);\n    float y9 = y1 * (1.0 / 2.0);\n    float z9 = z1 * (1.0 / 2.0);\n    ", "\n    float a = 0.0f;\n    float b = 0.0f;\n    float c = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float s = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x1 = 0.0f;\n    float x2 = 0.0f;\n    float x3 = 0.0f;\n    float x4 = 0.0f;\n    float x5 = 0.0f;\n    float x6 = 0.0f;\n    float x7 = 0.0f;\n    float x8 = 0.0f;\n    float x9 = 0.0f;\n    float x10 = 0.0f;\n    float x11 = 0.0f;\n    float x12 = 0.0f;\n    float x13 = 0.0f;\n    float x14 = 0.0f;\n    float x15 = 0.0f;\n    float x16 = 0.0f;\n    float x17 = 0.0f;\n    float x18 = 0.0f;\n    float x19 = 0.0f;\n    float x20 = 0.0f;\n    float x21 = 0.0f;\n    float x22 = 0.0f;\n    float x23 = 0.0f;\n    float x24 = 0.0f;\n    float x25 = 0.0f;\n    float x26 = 0", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    vec2 x = z.x / (1.0 + z.y * z.y);\n    vec2 y = z.y / (1.0 + z.x * z.x);\n    return vec2(x, y);\n}\n\n// Inverse hyperbolic cosine \nvec", "\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x);\n    res.y = z.y * exp(z.y);\n    return res;\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x);\n    res.y = z.y * exp(z.y);\n    return res;\n}\n\nvec", "\n    vec4 result = alpha;\n    result.a = alpha.a * contrast;\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with the alpha value\n// set to 0.0\nvec", "\n    float r = 1.0;\n    vec3 v = p - center;\n    vec3 v1 = v.cross(vec3(0,1,0));\n    vec3 v2 = v.cross(vec3(0,0,1));\n    vec3 v3 = v.cross(vec3(1,0,0));\n    vec3 v4 = v.cross(vec3(0,0,1));\n    vec3 v5 = v.cross(vec3(1,0,0));\n    vec3 v6 = v.cross(vec3(0,1,0));\n    vec3 v7 = v.cross(vec3(1,0,0));\n    vec3 v8 = v.cross(vec3(0,0,1));\n    vec3 v9 = v.cross(vec3(1,0,0));\n    vec3 v10 = v.cross(vec3(0,1,0));\n    vec3 v11 = v.cross(vec3(1,0,0));\n    vec3 v12 = v.cross(vec3(0,0,1));\n    vec3 v13 = v.cross(vec3(1,0,0));\n    vec3 v14 = v.cross(vec3(0,1,0));\n    vec3 v15 = v.cross(vec3(1,0,0));\n    vec3 v16 = v.cross(vec3(0,0,1));\n    vec3 v17 = v.cross(vec3(1,0,0));\n    vec3 v18 = v.cross(vec3(0,1,0));\n    vec3 v19 = v.cross(vec3(1,0,0));\n    vec3 v20 = v.cross(vec3(0,0,1));\n    vec3 v21 = v.cross(vec3(1,0,0));\n    vec3 v22 = v.cross(vec3(0,1,0));\n    vec3 v23 = v.cross(vec3(1,0,0));\n    vec3 v24 = v.cross(vec3(0,0,1));\n    vec3 v25 = v.cross(vec3", "\n    vec3 u, v, w;\n    u = uvw.x;\n    v = uvw.y;\n    w = uvw.z;\n    if (u == 0 && v == 0 && w == 0) return 1;\n    if (u == 0 && v == 0 && w == 1) return 2;\n    if (u == 0 && v == 1 && w == 0) return 3;\n    if (u == 0 && v == 1 && w == 1) return 4;\n    if (u == 1 && v == 0 && w == 0) return 5;\n    if (u == 1 && v == 0 && w == 1) return 6;\n    if (u == 1 && v == 1 && w == 0) return 7;\n    if (u == 1 && v == 1 && w == 1) return 8;\n    return 0;\n}\n\n//Tetrahedron Tiling\ntilingVal3D tetTile(vec3 uvw) {\n    vec3 u, v, w;\n    u = uvw.x;\n    v = uvw.y;\n    w = uvw.z;\n    if (u == 0 && v == 0 && w == 0) return 1;\n    if (u == 0 && v == 0 && w == 1) return 2;\n    if (u == 0 && v == 1 && w == 0) return 3;\n    if (u == 0 && v == 1 && w == 1) return 4;\n    if (u == 1 && v == 0 && w == 0) return 5;\n    if (u == 1 && v == 0 && w == 1) return 6;\n    if (u == 1 && v == 1 && w == 0) return 7;\n    if (u == 1 && v == 1 && w == 1) return 8;\n    return 0;\n}\n\n//Triangle Tiling\ntilingVal3D triTile(vec3 uvw) {\n    vec3 u, v, w;\n    u = uvw.x;\n    v = uvw.y;\n    w = uvw.z;\n    if (u == 0 && v == 0 && w == 0) return 1;\n    if (u ==", "\n    // scaled with offset Rhombic Dodecahedron tiling\n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec", "\n    vec3 uvw2 = uvw * gridRes;\n    vec3 uvw3 = uvw2 + vec3(0.5, 0.5, 0.5);\n    vec3 uvw4 = uvw2 + vec3(0.5, -0.5, 0.5);\n    vec3 uvw5 = uvw2 + vec3(-0.5, 0.5, 0.5);\n    vec3 uvw6 = uvw2 + vec3(-0.5, -0.5, 0.5);\n    vec3 uvw7 = uvw2 + vec3(0.5, -0.5, -0.5);\n    vec3 uvw8 = uvw2 + vec3(0.5, 0.5, -0.5);\n    vec3 uvw9 = uvw2 + vec3(-0.5, 0.5, -0.5);\n    vec3 uvw10 = uvw2 + vec3(-0.5, -0.5, -0.5);\n    vec3 uvw11 = uvw2 + vec3(0.5, -0.5, 0.5);\n    vec3 uvw12 = uvw2 + vec3(0.5, 0.5, 0.5);\n    vec3 uvw13 = uvw2 + vec3(-0.5, 0.5, 0.5);\n    vec3 uvw14 = uvw2 + vec3(-0.5, -0.5, 0.5);\n    vec3 uvw15 = uvw2 + vec3(0.5, -0.5, -0.5);\n    vec3 uvw16 = uvw2 + vec3(0.5, 0.5, -0.5);\n    vec3 uvw17 = uvw2 + vec3(-0.5, 0.5, -0.5);\n    vec3 uvw18 = uvw2 + vec3(-0.5, -0.5, -0.5);\n    vec3 uvw19 = uvw2 + vec3", "\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(1.0, 0.0, 0.0);\n    vec3 e = vec3(0.0, 1.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 1.0);\n    vec3 g = vec3(1.0, 1.0, 0.0);\n    vec3 h = vec3(1.0, -1.0, 0.0);\n    vec3 i = vec3(-1.0, 1.0, 0.0);\n    vec3 j = vec3(-1.0, -1.0, 0.0);\n    vec3 k = vec3(1.0, 1.0, 1.0);\n    vec3 l = vec3(1.0, -1.0, -1.0);\n    vec3 m = vec3(-1.0, 1.0, -1.0);\n    vec3 n = vec3(-1.0, -1.0, 1.0);\n    vec3 o = vec3(0.0, 0.0, 1.0);\n    vec3 p1 = vec3(p.x, p.y, p.z);\n    vec3 p2 = vec3(c.x, c.y, c.z);\n    vec3 p3 = vec3(d.x, d.y, d.z);\n    vec3 p4 = vec3(e.x, e.y, e.z);\n    vec3 p5 = vec3(f.x, f.y, f.z);\n    vec3 p6 = vec3(g.x, g.y, g.z);\n    vec3 p7 = vec3(h.x, h.y, h.z);\n    vec3 p8 = vec3(i.x, i.y, i.z);\n    vec3 p9 = vec3(j.x, j.y, j.z);\n    vec3 p10 = vec3(k.x, k.y, k.z);\n    vec3 p11 = vec3(l.x", "\n    float t0 = 0.0f;\n    float t1 = 0.0f;\n    float t2 = 0.0f;\n    float t3 = 0.0f;\n    float t4 = 0.0f;\n    float t5 = 0.0f;\n    float t6 = 0.0f;\n    float t7 = 0.0f;\n    float t8 = 0.0f;\n    float t9 = 0.0f;\n    float t10 = 0.0f;\n    float t11 = 0.0f;\n    float t12 = 0.0f;\n    float t13 = 0.0f;\n    float t14 = 0.0f;\n    float t15 = 0.0f;\n    float t16 = 0.0f;\n    float t17 = 0.0f;\n    float t18 = 0.0f;\n    float t19 = 0.0f;\n    float t20 = 0.0f;\n    float t21 = 0.0f;\n    float t22 = 0.0f;\n    float t23 = 0.0f;\n    float t24 = 0.0f;\n    float t25 = 0.0f;\n    float t26 = 0.0f;\n    float t27 = 0.0f;\n    float t28 = 0.0f;\n    float t29 = 0.0f;\n    float t30 = 0.0f;\n    float t31 = 0.0f;\n    float t32 = 0.0f;\n    float t33 = 0.0f;\n    float t34 = 0.0f;\n    float t35 = 0.0f;\n    float t36 = 0.0f;\n    float t37 = 0.0f;\n    float t38 = 0.0f;\n    float t39 = 0.0f;\n    float t40 = 0.0f;\n    float t41 = 0.0f;\n    float t42 = 0.0f;\n    float t43 = 0.0f;\n    float t44 = 0.0f;\n    float t45 = 0.0f;\n    float t46 =", "\n    vec3 r = vec3(0, 0, 0);\n    r.x = v.x * cos(a.x) - v.y * sin(a.x);\n    r.y = v.x * sin(a.x) + v.y * cos(a.x);\n    r.z = v.z * cos(a.z) - v.w * sin(a.z);\n    r.w = v.z * sin(a.z) + v.w * cos(a.z);\n    return r;\n}\n\nA:\n\nYou can use the following function to rotate a vector around a point:\nvec", "\n    float h = 0;\n    for (int i = 0; i < co.x; i++) {\n        h += co.x[i];\n    }\n    for (int i = 0; i < co.y; i++) {\n        h += co.y[i];\n    }\n    return h;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    float x = p.x;\n    float y = p.y;\n    return (sqrt(x*x + y*y) + sqrt(x*x + y*y + sqrt(3)*x*x))/2;\n}\n\n// Distance from the 0,0 coords\nfloat", "\n    vec2 u = uv.x, v = uv.y;\n    vec2 uv2 = uv + vec2(0.5, 0.5);\n    vec2 uv3 = uv + vec2(0.5, -0.5);\n    vec2 uv4 = uv + vec2(-0.5, -0.5);\n    vec2 uv5 = uv + vec2(-0.5, 0.5);\n    vec2 uv6 = uv + vec2(0.5, 0.5);\n\n    vec2 uv7 = uv + vec2(0.5, 0.5);\n    vec2 uv8 = uv + vec2(0.5, -0.5);\n    vec2 uv9 = uv + vec2(-0.5, -0.5);\n    vec2 uv10 = uv + vec2(-0.5, 0.5);\n\n    vec2 uv11 = uv + vec2(0.5, 0.5);\n    vec2 uv12 = uv + vec2(0.5, -0.5);\n    vec2 uv13 = uv + vec2(-0.5, -0.5);\n    vec2 uv14 = uv + vec2(-0.5, 0.5);\n\n    vec2 uv15 = uv + vec2(0.5, 0.5);\n    vec2 uv16 = uv + vec2(0.5, -0.5);\n    vec2 uv17 = uv + vec2(-0.5, -0.5);\n    vec2 uv18 = uv + vec2(-0.5, 0.5);\n\n    vec2 uv19 = uv + vec2(0.5, 0.5);\n    vec2 uv20 = uv + vec2(0.5, -0.5);\n    vec2 uv21 = uv + vec2(-0.5, -0.5);\n    vec2 uv22 = uv + vec2(-0.5, 0.5);\n\n    vec2 uv23 = uv + vec2(0.5, 0.5);", "\n    float r = t * t * t * (t * (t * 6 - 15) + 10);\n    float g = t * (t * (t * 6 - 15) + 10) * (t * (t * 6 - 15) + 10);\n    float b = t * (t * (t * 6 - 15) + 10) * (t * (t * 6 - 15) + 10);\n    return vec3(r, g, b);\n}\n\n// https://www.shadertoy.com/view/Nd3fR2\nvec", "\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat", "\n    float x = uv.x + offset.x;\n    float y = uv.y + offset.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float xy = x * y;\n    float xy2 = xy * xy;\n    float xy3 = xy * xy2;\n    float xy4 = xy * xy3;\n    float xy5 = xy * xy4;\n    float xy6 = xy * xy5;\n    float xy7 = xy * xy6;\n    float xy8 = xy * xy7;\n    float xy9 = xy * xy8;\n    float xy10 = xy * xy9;\n    float xy11 = xy * xy10;\n    float xy12 = xy * xy11;\n    float xy13 = xy * xy12;\n    float xy14 = xy * xy13;\n    float xy15 = xy * xy14;\n    float xy16 = xy * xy15;\n    float xy17 = xy * xy16;\n    float xy18 = xy * xy17;\n    float xy19 = xy * xy18;\n    float xy20 = xy * xy19;\n    float xy21 = xy * xy20;\n    float xy22 = xy * xy21;\n    float xy23 = xy * xy22;\n    float xy24 = xy * xy23;\n    float xy25 = xy * xy24;\n    float xy26 = xy * xy25;\n    float xy27 = xy * xy26;\n    float xy28 = xy * xy27;\n    float xy29 = xy * xy28;\n    float xy30 = xy * xy29;\n    float xy31 = xy * xy30;\n    float xy32 = xy * xy31;\n    float xy33 = xy * xy32;\n    float xy34 =", "\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float x1 = x + len * sin(time * 2 * pi);\n    float y1 = y + len * cos(time * 2 * pi);\n    float x2 = x + len * sin(time * 2 * pi + pi / 2);\n    float y2 = y + len * cos(time * 2 * pi + pi / 2);\n    float x3 = x + len * sin(time * 2 * pi + 3 * pi / 2);\n    float y3 = y + len * cos(time * 2 * pi + 3 * pi / 2);\n    float x4 = x + len * sin(time * 2 * pi + 5 * pi / 2);\n    float y4 = y + len * cos(time * 2 * pi + 5 * pi / 2);\n    float x5 = x + len * sin(time * 2 * pi + 7 * pi / 2);\n    float y5 = y + len * cos(time * 2 * pi + 7 * pi / 2);\n    float x6 = x + len * sin(time * 2 * pi + 9 * pi / 2);\n    float y6 = y + len * cos(time * 2 * pi + 9 * pi / 2);\n    float x7 = x + len * sin(time * 2 * pi + 11 * pi / 2);\n    float y7 = y + len * cos(time * 2 * pi + 11 * pi / 2);\n    float x8 = x + len * sin(time * 2 * pi + 13 * pi / 2);\n    float y8 = y + len * cos(time * 2 * pi + 13 * pi / 2);\n    float x9 = x + len * sin(time * 2 * pi + 15 * pi / 2);\n    float y9 = y + len * cos(time * 2 * pi + 15 * pi / 2);\n    float x10 = x + len * sin(time * 2 * pi + 17 * pi / 2);\n    float y10 = y + len * cos(time * 2 * pi + 17 * pi / 2);\n    float x11 = x + len * sin(time * 2 * pi + 19 * pi /", "\n    vec2 flow = vec2(0, 0);\n    vec2 center = vec2(radius, 0);\n    vec2 direction = vec2(0, -1);\n    vec2 speed = vec2(radius, 0);\n    vec2 time_step = vec2(0, 0);\n    vec2 time_step_vec = vec2(0, 0);\n    vec2 time_step_vec_2 = vec2(0, 0);\n    vec2 time_step_vec_3 = vec2(0, 0);\n    vec2 time_step_vec_4 = vec2(0, 0);\n    vec2 time_step_vec_5 = vec2(0, 0);\n    vec2 time_step_vec_6 = vec2(0, 0);\n    vec2 time_step_vec_7 = vec2(0, 0);\n    vec2 time_step_vec_8 = vec2(0, 0);\n    vec2 time_step_vec_9 = vec2(0, 0);\n    vec2 time_step_vec_10 = vec2(0, 0);\n    vec2 time_step_vec_11 = vec2(0, 0);\n    vec2 time_step_vec_12 = vec2(0, 0);\n    vec2 time_step_vec_13 = vec2(0, 0);\n    vec2 time_step_vec_14 = vec2(0, 0);\n    vec2 time_step_vec_15 = vec2(0, 0);\n    vec2 time_step_vec_16 = vec2(0, 0);\n    vec2 time_step_vec_17 = vec2(0, 0);\n    vec2 time_step_vec_18 = vec2(0, 0);\n    vec2 time_step_vec_19 = vec2(0, 0);\n    vec2 time_step_vec_20 = vec2(0, 0);\n    vec2 time_step_vec_21 = vec2(0, 0);\n    vec2 time_step_vec_22 = vec2(0, 0);\n    vec2 time_step_vec_23 = vec2(0, 0);\n    vec2 time_step_vec", "\n    vec2 tileCoord = pos / tileSize;\n    vec2 tileCenterCoord = tileCoord + 0.5;\n    return tileCenterCoord;\n}\n\n// Computes the tile containing pixel pos\nvec", "\n    float a = p1.y - p2.y;\n    float b = p2.x - p1.x;\n    float c = p1.x * p2.y - p2.x * p1.y;\n    return a * p.x + b * p.y + c;\n}\n\n// Computes the distance from a point to a line segment\nfloat", "\n    return (p.x - v.x) * (p.x - v.x) + (p.y - v.y) * (p.y - v.y);\n}\n\n// Returns the distance from the arrow to the arrow tile center\n// Returns a signed distance from the arrow\nfloat", "\n    return vec2(x.x / (x.x + 1), x.y / (x.y + 1));\n}\n\n//shifts value range from 0-1 to -1-1\nvec", "\n    vec2 center = point - offset;\n    vec2 radius = spread / 2;\n    vec2 x = center.x - radius;\n    vec2 y = center.y - radius;\n    vec2 r = sqrt(x*x + y*y);\n    vec2 r2 = r*r;\n    vec2 r3 = r2*r2;\n    vec2 r4 = r3*r2;\n    vec2 r5 = r4*r2;\n    vec2 r6 = r5*r2;\n    vec2 r7 = r6*r2;\n    vec2 r8 = r7*r2;\n    vec2 r9 = r8*r2;\n    vec2 r10 = r9*r2;\n    vec2 r11 = r10*r2;\n    vec2 r12 = r11*r2;\n    vec2 r13 = r12*r2;\n    vec2 r14 = r13*r2;\n    vec2 r15 = r14*r2;\n    vec2 r16 = r15*r2;\n    vec2 r17 = r16*r2;\n    vec2 r18 = r17*r2;\n    vec2 r19 = r18*r2;\n    vec2 r20 = r19*r2;\n    vec2 r21 = r20*r2;\n    vec2 r22 = r21*r2;\n    vec2 r23 = r22*r2;\n    vec2 r24 = r23*r2;\n    vec2 r25 = r24*r2;\n    vec2 r26 = r25*r2;\n    vec2 r27 = r26*r2;\n    vec2 r28 = r27*r2;\n    vec2 r29 = r28*r2;\n    vec2 r30 = r29*r2;\n    vec2 r31 = r30*r2;\n    vec2 r32 = r31*r2;\n    vec2 r33 = r32*r2;\n    vec2 r34 = r33*r2;\n    vec2 r35 = r34*r2;\n    vec2 r36 = r35*r", "\n    float s = 0.0;\n    for ( int i = 0; i < 3; i++ )\n    {\n        s += ( p[i] - b[i] ) * ( p[i] - b[i] );\n    }\n    return sqrt( s );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    float x = p.x - id.x;\n    float y = p.y - id.y;\n    float z = p.z - id.z;\n    float r = sqrt( x*x + y*y + z*z );\n    float theta = atan2( y, x );\n    float phi = atan2( z, sqrt( x*x + y*y ) );\n    float phi2 = phi + sp;\n    float phi3 = phi2 + sp;\n    float phi4 = phi3 + sp;\n    float phi5 = phi4 + sp;\n    float phi6 = phi5 + sp;\n    float phi7 = phi6 + sp;\n    float phi8 = phi7 + sp;\n    float phi9 = phi8 + sp;\n    float phi10 = phi9 + sp;\n    float phi11 = phi10 + sp;\n    float phi12 = phi11 + sp;\n    float phi13 = phi12 + sp;\n    float phi14 = phi13 + sp;\n    float phi15 = phi14 + sp;\n    float phi16 = phi15 + sp;\n    float phi17 = phi16 + sp;\n    float phi18 = phi17 + sp;\n    float phi19 = phi18 + sp;\n    float phi20 = phi19 + sp;\n    float phi21 = phi20 + sp;\n    float phi22 = phi21 + sp;\n    float phi23 = phi22 + sp;\n    float phi24 = phi23 + sp;\n    float phi25 = phi24 + sp;\n    float phi26 = phi25 + sp;\n    float phi27 = phi26 + sp;\n    float phi28 = phi27 + sp;\n    float phi29 = phi28 + sp;\n    float phi30 = phi29 + sp;\n    float phi31 = phi30 + sp;\n    float phi32 = phi31 + sp;\n    float phi33 = phi32 + sp;", "\n    float x = p.x - ra;\n    float y = p.y - sp;\n    float r = sqrt(x*x + y*y);\n    float theta = atan2(y, x);\n    float t = time * (1.0f - r/sp);\n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t3*t;\n    float t5 = t4*t;\n    float t6 = t5*t;\n    float t7 = t6*t;\n    float t8 = t7*t;\n    float t9 = t8*t;\n    float t10 = t9*t;\n    float t11 = t10*t;\n    float t12 = t11*t;\n    float t13 = t12*t;\n    float t14 = t13*t;\n    float t15 = t14*t;\n    float t16 = t15*t;\n    float t17 = t16*t;\n    float t18 = t17*t;\n    float t19 = t18*t;\n    float t20 = t19*t;\n    float t21 = t20*t;\n    float t22 = t21*t;\n    float t23 = t22*t;\n    float t24 = t23*t;\n    float t25 = t24*t;\n    float t26 = t25*t;\n    float t27 = t26*t;\n    float t28 = t27*t;\n    float t29 = t28*t;\n    float t30 = t29*t;\n    float t31 = t30*t;\n    float t32 = t31*t;\n    float t33 = t32*t;\n    float t34 = t33*t;\n    float t35 = t34*t;\n    float t36 = t35*t;\n    float t37 = t36*t;\n    float t38 = t37*t;\n    float t39 = t38*t;\n    float t40 = t39*t;\n    float t41 = t40*t;\n    float t", "\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Sphere\nfloat", "\n    vec3 uv = uvw.xyz;\n    vec3 v = uv.xyz;\n    vec3 w = uv.xyz;\n    vec3 u = uv.xyz;\n    vec3 vx = uv.xyz;\n    vec3 vy = uv.xyz;\n    vec3 vz = uv.xyz;\n    vec3 wx = uv.xyz;\n    vec3 wy = uv.xyz;\n    vec3 wz = uv.xyz;\n    vec3 uvw = uv.xyz;\n    vec3 uvw2 = uvw.xyz;\n    vec3 uvw3 = uvw.xyz;\n    vec3 uvw4 = uvw.xyz;\n    vec3 uvw5 = uvw.xyz;\n    vec3 uvw6 = uvw.xyz;\n    vec3 uvw7 = uvw.xyz;\n    vec3 uvw8 = uvw.xyz;\n    vec3 uvw9 = uvw.xyz;\n    vec3 uvw10 = uvw.xyz;\n    vec3 uvw11 = uvw.xyz;\n    vec3 uvw12 = uvw.xyz;\n    vec3 uvw13 = uvw.xyz;\n    vec3 uvw14 = uvw.xyz;\n    vec3 uvw15 = uvw.xyz;\n    vec3 uvw16 = uvw.xyz;\n    vec3 uvw17 = uvw.xyz;\n    vec3 uvw18 = uvw.xyz;\n    vec3 uvw19 = uvw.xyz;\n    vec3 uvw20 = uvw.xyz;\n    vec3 uvw21 = uvw.xyz;\n    vec3 uvw22 = uvw.xyz;\n    vec3 uvw23 = uvw.xyz;\n    vec3 uvw24 = uvw.xyz;\n    ", "\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_offset = uvw_scaled + offset;\n    return vec4(uvw_offset, 1.0);\n}\n\n// scaled with offset cube tiling\nvec", "\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 c2 = vec3(1.0, 1.0, 1.0);\n    vec3 c3 = vec3(1.0, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 1.0);\n    vec3 c5 = vec3(1.0, 1.0, 1.0);\n    vec3 c6 = vec3(1.0, 1.0, 1.0);\n    vec3 c7 = vec3(1.0, 1.0, 1.0);\n    vec3 c8 = vec3(1.0, 1.0, 1.0);\n    vec3 c9 = vec3(1.0, 1.0, 1.0);\n    vec3 c10 = vec3(1.0, 1.0, 1.0);\n    vec3 c11 = vec3(1.0, 1.0, 1.0);\n    vec3 c12 = vec3(1.0, 1.0, 1.0);\n    vec3 c13 = vec3(1.0, 1.0, 1.0);\n    vec3 c14 = vec3(1.0, 1.0, 1.0);\n    vec3 c15 = vec3(1.0, 1.0, 1.0);\n    vec3 c16 = vec3(1.0, 1.0, 1.0);\n    vec3 c17 = vec3(1.0, 1.0, 1.0);\n    vec3 c18 = vec3(1.0, 1.0, 1.0);\n    vec3 c19 = vec3(1.0, 1.0, 1.0);\n    vec3 c20 = vec3(1.0, 1.0, 1.0);\n    vec3 c21 = vec3(1.0, 1.0, 1.0);\n    vec3 c22 = vec3(1.0, 1.0, 1.0);\n    vec3 c23 = vec3(1.0, 1.0, 1.0);\n    vec3 c24 =", "\n    float d = 0.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d1 = 1.0;\n    float d2 = 1.0;\n    float d3 = 1.0;\n    float d4 = 1.0;\n    float d5 = 1.0;\n    float d6 = 1.0;\n    float d7 = 1.0;\n    float d8 = 1.0;\n    float d9 = 1.0;\n    float d10 = 1.0;\n    float d11 = 1.0;\n    float d12 = 1.0;\n    float d13 = 1.0;\n    float d14 = 1.0;\n    float d15 = 1.0;\n    float d16 = 1.0;\n    float d17 = 1.0;\n    float d18 = 1.0;\n    float d19 = 1.0;\n    float d20 = 1.0;\n    float d21 = 1.0;\n    float d22 = 1.0;\n    float d23 = 1.0;\n    float d24 = 1.0;\n    float d25 = 1.0;\n    float d26 = 1.0;\n    float d27 = 1.0;\n    float d28 = 1.0;\n    float d29 = 1.0;\n    float d30 = 1.0;\n    float d31 = 1.0;\n    float d32 = 1.0;\n    float d33 = 1.0;\n    float d34 = 1.0;\n    float d35 = 1.0;\n    float d36 = 1.0;\n    float d37 = 1.0;\n    float d38 = 1.0;\n    float d39 = 1.0;\n    float d40 = 1.0;\n    float d41 = 1.0;\n    float d42 = 1.0;\n    float d43 = 1.0;\n    float d44 = 1.0;\n    float d45 = 1.0;\n    float d46 = 1.0;\n    float d47 = 1.0;\n    float d48 =", "\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41 * t;\n    float t43 = t42 * t;\n    float t44 = t43 * t;\n    float t45 = t44 * t;\n    float t46 = t45 * t;\n    float t47 = t46 * t;\n    float t48 = t", "\n    vec2 u = uv.xy;\n    vec2 v = vec2(1.0, 0.0);\n    return vec2(u + v, u - v);\n}\n\n// simple square Tiling\nvec", "\n    vec2 u = uv.xy;\n    vec2 v = vec2(1.0f, -1.0f);\n    vec2 w = u + v;\n    return uv + w;\n}\n\n//square shape form Manhattan distance\nvec", "\n    vec2 uv2 = uv + offset;\n    vec2 uv3 = uv2 + vec2(gridRes, gridRes);\n    return vec2(uv3.x, uv3.y);\n}\n\n// nakes a square pixelized pattern\nvec", "\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0f / gridRes);\n}\n\n// nakes a pixelized pattern\nvec", "\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float xOffset = offset.x * gridRes;\n    float yOffset = offset.y * gridRes;\n    float xDiff = x - xOffset;\n    float yDiff = y - yOffset;\n    float xDiffSquared = xDiff * xDiff;\n    float yDiffSquared = yDiff * yDiff;\n    float xDiffSquaredYDiffSquared = xDiffSquared + yDiffSquared;\n    float xDiffSquaredYDiffSquaredSquared = xDiffSquaredYDiffSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;\n    float xDiffSquaredYDiffSquaredSquaredSquaredSquared = xDiffSquaredYDiffSquaredSquaredSquared * xDiffSquaredYDiffSquared;", "\n    float x = uv.x;\n    float y = uv.y;\n    float dx = x - gridRes / 2;\n    float dy = y - gridRes / 2;\n    float d = sqrt(dx * dx + dy * dy);\n    float dt = time / len;\n    float dt2 = dt * dt;\n    float dt3 = dt2 * dt;\n    float dt4 = dt3 * dt;\n    float dt5 = dt4 * dt;\n    float dt6 = dt5 * dt;\n    float dt7 = dt6 * dt;\n    float dt8 = dt7 * dt;\n    float dt9 = dt8 * dt;\n    float dt10 = dt9 * dt;\n    float dt11 = dt10 * dt;\n    float dt12 = dt11 * dt;\n    float dt13 = dt12 * dt;\n    float dt14 = dt13 * dt;\n    float dt15 = dt14 * dt;\n    float dt16 = dt15 * dt;\n    float dt17 = dt16 * dt;\n    float dt18 = dt17 * dt;\n    float dt19 = dt18 * dt;\n    float dt20 = dt19 * dt;\n    float dt21 = dt20 * dt;\n    float dt22 = dt21 * dt;\n    float dt23 = dt22 * dt;\n    float dt24 = dt23 * dt;\n    float dt25 = dt24 * dt;\n    float dt26 = dt25 * dt;\n    float dt27 = dt26 * dt;\n    float dt28 = dt27 * dt;\n    float dt29 = dt28 * dt;\n    float dt30 = dt29 * dt;\n    float dt31 = dt30 * dt;\n    float dt32 = dt31 * dt;\n    float dt33 = dt", "\n    float x = p.x;\n    float y = p.y;\n    float dx = ddx.x;\n    float dy = ddy.y;\n\n    float x1 = x + dx;\n    float y1 = y + dy;\n\n    float x2 = x - dx;\n    float y2 = y - dy;\n\n    float x3 = x1;\n    float y3 = y1;\n\n    float x4 = x2;\n    float y4 = y2;\n\n    float x5 = x3;\n    float y5 = y3;\n\n    float x6 = x4;\n    float y6 = y4;\n\n    float x7 = x5;\n    float y7 = y5;\n\n    float x8 = x6;\n    float y8 = y6;\n\n    float x9 = x7;\n    float y9 = y7;\n\n    float x10 = x8;\n    float y10 = y8;\n\n    float x11 = x9;\n    float y11 = y9;\n\n    float x12 = x10;\n    float y12 = y10;\n\n    float x13 = x11;\n    float y13 = y11;\n\n    float x14 = x12;\n    float y14 = y12;\n\n    float x15 = x13;\n    float y15 = y13;\n\n    float x16 = x14;\n    float y16 = y14;\n\n    float x17 = x15;\n    float y17 = y15;\n\n    float x18 = x16;\n    float y18 = y16;\n\n    float x19 = x17;\n    float y19 = y17;\n\n    float x20 = x18;\n    float y20 = y18;\n\n    float x21 = x19;\n    float y21 = y19;\n\n    float x22 = x20;\n    float y22 = y20;\n\n    float x23 = x21;\n    float y23 = y21;\n\n    float x24 = x22;\n    float y24 = y22;\n\n    float x25 = x23;\n    float y25 = y23;\n\n    float x26 = x24;\n    float y26 = y24;\n\n    ", "\n    float x = p.x;\n    float y = p.y;\n    float a = sqrt(3.0f) / 2.0f;\n    float b = sqrt(3.0f) / 2.0f;\n    float c = sqrt(3.0f) / 2.0f;\n    float d = sqrt(3.0f) / 2.0f;\n    float e = sqrt(3.0f) / 2.0f;\n    float f = sqrt(3.0f) / 2.0f;\n    float g = sqrt(3.0f) / 2.0f;\n    float h = sqrt(3.0f) / 2.0f;\n    float i = sqrt(3.0f) / 2.0f;\n    float j = sqrt(3.0f) / 2.0f;\n    float k = sqrt(3.0f) / 2.0f;\n    float l = sqrt(3.0f) / 2.0f;\n    float m = sqrt(3.0f) / 2.0f;\n    float n = sqrt(3.0f) / 2.0f;\n    float o = sqrt(3.0f) / 2.0f;\n    float p1 = sqrt(3.0f) / 2.0f;\n    float p2 = sqrt(3.0f) / 2.0f;\n    float p3 = sqrt(3.0f) / 2.0f;\n    float p4 = sqrt(3.0f) / 2.0f;\n    float p5 = sqrt(3.0f) / 2.0f;\n    float p6 = sqrt(3.0f) / 2.0f;\n    float p7 = sqrt(3.0f) / 2.0f;\n    float p8 = sqrt(3.0f) / 2.0f;\n    float p9 = sqrt(3.0f) / 2.0f;\n    float p10 = sqrt(3.0f) / 2.0f;\n    float p11 = sqrt(", "\n    vec2 x = p.x / TILE_SIZE;\n    vec2 y = p.y / TILE_SIZE;\n    vec2 x_floor = floor(x);\n    vec2 y_floor = floor(y);\n    vec2 x_ceil = ceil(x);\n    vec2 y_ceil = ceil(y);\n    vec2 x_diff = x - x_floor;\n    vec2 y_diff = y - y_floor;\n    vec2 x_diff_ceil = x_ceil - x_floor;\n    vec2 y_diff_ceil = y_ceil - y_floor;\n    vec2 x_diff_floor = x_floor - x_ceil;\n    vec2 y_diff_floor = y_floor - y_ceil;\n    vec2 x_diff_ceil_y_diff_floor = x_diff_ceil * y_diff_floor;\n    vec2 x_diff_floor_y_diff_ceil = x_diff_floor * y_diff_ceil;\n    vec2 x_diff_ceil_y_diff_ceil = x_diff_ceil * y_diff_ceil;\n    vec2 x_diff_floor_y_diff_ceil = x_diff_floor * y_diff_ceil;\n    vec2 x_diff_ceil_y_diff_ceil_y_diff_floor = x_diff_ceil * y_diff_ceil * y_diff_floor;\n    vec2 x_diff_floor_y_diff_ceil_y_diff_ceil = x_diff_floor * y_diff_ceil * y_diff_ceil;\n    vec2 x_diff_ceil_y_diff_ceil_y_diff_ceil_y_diff_floor = x_diff_ceil * y_diff_ceil * y_diff_ceil * y_diff_floor;\n    vec2 x_diff_floor_y_diff_ceil_y_diff_ceil_y_diff_ceil = x_diff_floor * y_diff_ceil * y_diff_ceil * y_diff_ce", "\n    return x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x", "\n    vec3 r = t * 0.412453 * (1.0 + 0.357580 * t.y + 0.180423 * t.z);\n    vec3 g = t * 0.212671 * (1.0 + 0.715160 * t.y + 0.072169 * t.z);\n    vec3 b = t * 0.019334 * (1.0 + 0.119193 * t.y + 0.950227 * t.z);\n    return vec3(r, g, b);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return p.x * p.x + p.y * p.y;\n}\n\nfloat", "\n    return (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y);\n}\n\n// Multiscale truchet\nfloat", "\n    float a = p0.x - p.x;\n    float b = p0.y - p.y;\n    float c = p1.x - p.x;\n    float d = p1.y - p.y;\n    float e = p2.x - p.x;\n    float f = p2.y - p.y;\n\n    float s = (a * (d - f) + b * (e - f) + c * (a - d)) / 2.0f;\n    float t = (a * (f - e) + b * (d - e) + c * (a - d)) / 2.0f;\n\n    float d1 = (a * (d - f) + b * (e - f) + c * (a - d)) / 2.0f;\n    float d2 = (a * (f - e) + b * (d - e) + c * (a - d)) / 2.0f;\n\n    float s1 = (a * (d - f) + b * (e - f) + c * (a - d)) / 2.0f;\n    float s2 = (a * (f - e) + b * (d - e) + c * (a - d)) / 2.0f;\n\n    float s3 = (a * (d - f) + b * (e - f) + c * (a - d)) / 2.0f;\n    float s4 = (a * (f - e) + b * (d - e) + c * (a - d)) / 2.0f;\n\n    float s5 = (a * (d - f) + b * (e - f) + c * (a - d)) / 2.0f;\n    float s6 = (a * (f - e) + b * (d - e) + c * (a - d)) / 2.0f;\n\n    float s7 = (a * (d - f) + b * (e - f) + c * (a - d)) / 2.0f;\n    float s8 = (a * (f - e) + b * (d - e) + c * (a - d)) / 2.0", "\n    vec3 r = ro - rd;\n    float d = dot(r, r);\n    float s = sqrt(1.0 - d);\n    float t = s * s;\n    float u = s * (1.0 - t);\n    float v = t * (1.0 - t);\n    float a = (1.0 - u) * (1.0 - v);\n    float b = u * (1.0 - v);\n    float c = v * (1.0 - u);\n    float d = u * v;\n    float e = 1.0 - u;\n    float f = 1.0 - v;\n    float g = 1.0 - u;\n    float h = 1.0 - v;\n    float i = 1.0 - u;\n    float j = 1.0 - v;\n    float k = 1.0 - u;\n    float l = 1.0 - v;\n    float m = 1.0 - u;\n    float n = 1.0 - v;\n    float o = 1.0 - u;\n    float p = 1.0 - v;\n    float q = 1.0 - u;\n    float r = 1.0 - v;\n    float s = 1.0 - u;\n    float t = 1.0 - v;\n    float u = 1.0 - u;\n    float v = 1.0 - v;\n    float w = 1.0 - u;\n    float x = 1.0 - v;\n    float y = 1.0 - u;\n    float z = 1.0 - v;\n    float aa = a * a;\n    float ab = a * b;\n    float ac = a * c;\n    float ad = a * d;\n    float ae = a * e;\n    float af = a * f;\n    float ag = a * g;\n    float ah = a * h;\n    float ai = a * i;\n    float aj = a * j;\n    float ak = a * k;\n    float al = a * l;\n    float am = a * m;\n    float an = a * n;\n    float ap = a * o;\n", "\n    float x = p.x;\n    float y = p.y;\n    float dx = x - w / 2;\n    float dy = y - r / 2;\n    float d = sqrt(dx * dx + dy * dy);\n    float rx = x + w / 2;\n    float ry = y + r / 2;\n    float rd = sqrt(rx * rx + ry * ry);\n    float f = (d - rd) / (d + rd);\n    return f * f * w + w / 2;\n}\n\nfloat", "\n    float x = p.x;\n    float y = p.y;\n    float x2 = x*x;\n    float y2 = y*y;\n    float x3 = x2*x2;\n    float y3 = y2*y2;\n    float x4 = x3*x3;\n    float y4 = y3*y3;\n    float x5 = x4*x4;\n    float y5 = y4*y4;\n    float x6 = x5*x5;\n    float y6 = y5*y5;\n    float x7 = x6*x6;\n    float y7 = y6*y6;\n    float x8 = x7*x7;\n    float y8 = y7*y7;\n    float x9 = x8*x8;\n    float y9 = y8*y8;\n    float x10 = x9*x9;\n    float y10 = y9*y9;\n    float x11 = x10*x10;\n    float y11 = y10*y10;\n    float x12 = x11*x11;\n    float y12 = y11*y11;\n    float x13 = x12*x12;\n    float y13 = y12*y12;\n    float x14 = x13*x13;\n    float y14 = y13*y13;\n    float x15 = x14*x14;\n    float y15 = y14*y14;\n    float x16 = x15*x15;\n    float y16 = y15*y15;\n    float x17 = x16*x16;\n    float y17 = y16*y16;\n    float x18 = x17*x17;\n    float y18 = y17*y17;\n    float x19 = x18*x18;\n    float y19 = y18*y18;\n    float x20 = x19*x19;\n    float y20 = y19*y19;\n    float x21 = x20*x20;\n    float y21 = y20*y20;\n    float x22 = x21*x21;\n    float y22 =", "\n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f / y;\n    float dy = y - x;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n\n// distance to y=1/x\nfloat", "\n    return (a < b)? a : (b < a)? b : (a < k)? a : (b < k)? b : k;\n}\n\nfloat", "\n    return a < 0? -k * a : k * a;\n}\n\nfloat", "\n    float x, y;\n    x = p.x - center.x;\n    y = p.y - center.y;\n    return (x * x + y * y) / (2 * radius * radius);\n}\n\n// This function is used to draw the heart.\nvoid drawHeart(vec2 p) {\n    vec2 x, y;\n    x = p.x - center.x;\n    y = p.y - center.y;\n    float r = sqrt(x * x + y * y);\n    if (r < radius) {\n        vec2 t = (r - radius) / (radius - r);\n        vec2 u = (1 - t) * (1 - t);\n        vec2 v = t * (1 - t);\n        vec2 w = t * t;\n        vec2 a = vec2(x * u + y * v, x * v - y * u);\n        vec2 b = vec2(x * w + y * t, x * t - y * w);\n        vec2 c = vec2(x * u - y * v, x * v + y * u);\n        vec2 d = vec2(x * w - y * t, x * t + y * w);\n        glColor3f(0.0, 0.0, 0.0);\n        glBegin(GL_QUADS);\n        glVertex2f(a.x + center.x, a.y + center.y);\n        glVertex2f(b.x + center.x, b.y + center.y);\n        glVertex2f(c.x + center.x, c.y + center.y);\n        glVertex2f(d.x + center.x, d.y + center.y);\n        glEnd();\n    }\n}\n\n// This function is used to draw the heart.\nvoid drawHeart(vec2 p) {\n    vec2 x, y;\n    x = p.x - center.x;\n    y = p.y - center.y;\n    float r = sqrt(x * x + y * y);\n    if (r < radius) {\n        vec2 t = (r -", "\n    float h = 0.0f;\n    float x = p.x;\n    float y = p.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x2;\n    float y3 = y2 * y2;\n    float x4 = x3 * x2;\n    float y4 = y3 * y2;\n    float x5 = x4 * x2;\n    float y5 = y4 * y2;\n    float x6 = x5 * x2;\n    float y6 = y5 * y2;\n    float x7 = x6 * x2;\n    float y7 = y6 * y2;\n    float x8 = x7 * x2;\n    float y8 = y7 * y2;\n    float x9 = x8 * x2;\n    float y9 = y8 * y2;\n    float x10 = x9 * x2;\n    float y10 = y9 * y2;\n    float x11 = x10 * x2;\n    float y11 = y10 * y2;\n    float x12 = x11 * x2;\n    float y12 = y11 * y2;\n    float x13 = x12 * x2;\n    float y13 = y12 * y2;\n    float x14 = x13 * x2;\n    float y14 = y13 * y2;\n    float x15 = x14 * x2;\n    float y15 = y14 * y2;\n    float x16 = x15 * x2;\n    float y16 = y15 * y2;\n    float x17 = x16 * x2;\n    float y17 = y16 * y2;\n    float x18 = x17 * x2;\n    float y18 = y17 * y2;\n    float x19 = x18 * x2;\n    float y19 = y18 * y2;\n    float x20 = x19 * x2;\n    float y20 = y19 * y2;\n    float x21 = x20 * x2;\n    float y21 = y20 * y2;\n    float x22 = x21", "\n    vec3 p = pos;\n    vec3 x = A;\n    vec3 y = B;\n    vec3 z = C;\n    vec3 xy = x - p;\n    vec3 yz = y - p;\n    vec3 xyz = xy * yz;\n    vec3 xyz2 = xyz * xyz;\n    vec3 xyz3 = xyz2 * xyz;\n    vec3 xyz4 = xyz3 * xyz;\n    vec3 xyz5 = xyz4 * xyz;\n    vec3 xyz6 = xyz5 * xyz;\n    vec3 xyz7 = xyz6 * xyz;\n    vec3 xyz8 = xyz7 * xyz;\n    vec3 xyz9 = xyz8 * xyz;\n    vec3 xyz10 = xyz9 * xyz;\n    vec3 xyz11 = xyz10 * xyz;\n    vec3 xyz12 = xyz11 * xyz;\n    vec3 xyz13 = xyz12 * xyz;\n    vec3 xyz14 = xyz13 * xyz;\n    vec3 xyz15 = xyz14 * xyz;\n    vec3 xyz16 = xyz15 * xyz;\n    vec3 xyz17 = xyz16 * xyz;\n    vec3 xyz18 = xyz17 * xyz;\n    vec3 xyz19 = xyz18 * xyz;\n    vec3 xyz20 = xyz19 * xyz;\n    vec3 xyz21 = xyz20 * xyz;\n    vec3 xyz22 = xyz21 * xyz;\n    vec3 xyz23 = xyz22 * xyz;\n    vec3 xyz24 = xyz23 * xyz;\n    vec3 xyz25 = xyz24 * xyz;\n    vec3 xyz26 = xyz25 * xyz;\n    vec3 xyz27 = xyz26 * xyz;\n    vec3 xyz28 = xyz27 * xyz;\n    vec3 xyz29 = xyz28 * xyz;\n    vec3 xyz30 = xyz29 * xyz;\n    vec3 xyz31 = xyz30", "\n    vec3 p = pos;\n    vec3 f = vec3(0,0,0);\n    vec3 d = vec3(0,0,0);\n    vec3 dp = vec3(0,0,0);\n    vec3 dp2 = vec3(0,0,0);\n    vec3 dp3 = vec3(0,0,0);\n    vec3 dp4 = vec3(0,0,0);\n    vec3 dp5 = vec3(0,0,0);\n    vec3 dp6 = vec3(0,0,0);\n    vec3 dp7 = vec3(0,0,0);\n    vec3 dp8 = vec3(0,0,0);\n    vec3 dp9 = vec3(0,0,0);\n    vec3 dp10 = vec3(0,0,0);\n    vec3 dp11 = vec3(0,0,0);\n    vec3 dp12 = vec3(0,0,0);\n    vec3 dp13 = vec3(0,0,0);\n    vec3 dp14 = vec3(0,0,0);\n    vec3 dp15 = vec3(0,0,0);\n    vec3 dp16 = vec3(0,0,0);\n    vec3 dp17 = vec3(0,0,0);\n    vec3 dp18 = vec3(0,0,0);\n    vec3 dp19 = vec3(0,0,0);\n    vec3 dp20 = vec3(0,0,0);\n    vec3 dp21 = vec3(0,0,0);\n    vec3 dp22 = vec3(0,0,0);\n    vec3 dp23 = vec3(0,0,0);\n    vec3 dp24 = vec3(0,0,0);\n    vec3 dp25 = vec3(0,0,0);\n    vec3 dp26 = vec3(0,0,0);\n    vec3 dp27 = vec3(0,0,0);\n    vec3 dp28 = vec3(0,0,0", "\n    vec3 p = vec3(pos.x, pos.y, 0.0f);\n    vec3 f = vec3(0.0f, 0.0f, 0.0f);\n    vec3 dp = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d2p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d3p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d4p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d5p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d6p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d7p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d8p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d9p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d10p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d11p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d12p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d13p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d14p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d15p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d16p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d17p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 d18p = vec3(0.0f, 0.0f, 0.0f", "\n    vec3 r = vec3(p.x, p.y, p.z);\n    vec3 rp = vec3(p.x + d*cos(ra), p.y + d*sin(ra), p.z);\n    vec3 rp2 = vec3(p.x + d*cos(ra + rb), p.y + d*sin(ra + rb), p.z);\n    vec3 rp3 = vec3(p.x + d*cos(ra + rb + pi), p.y + d*sin(ra + rb + pi), p.z);\n    vec3 rp4 = vec3(p.x + d*cos(ra + rb + 2*pi), p.y + d*sin(ra + rb + 2*pi), p.z);\n    vec3 rp5 = vec3(p.x + d*cos(ra + rb + 3*pi), p.y + d*sin(ra + rb + 3*pi), p.z);\n    vec3 rp6 = vec3(p.x + d*cos(ra + rb + 4*pi), p.y + d*sin(ra + rb + 4*pi), p.z);\n    vec3 rp7 = vec3(p.x + d*cos(ra + rb + 5*pi), p.y + d*sin(ra + rb + 5*pi), p.z);\n    vec3 rp8 = vec3(p.x + d*cos(ra + rb + 6*pi), p.y + d*sin(ra + rb + 6*pi), p.z);\n    vec3 rp9 = vec3(p.x + d*cos(ra + rb + 7*pi), p.y + d*sin(ra + rb + 7*pi), p.z);\n    vec3 rp10 = vec3(p.x + d*cos(ra + rb + 8*pi), p.y + d*sin(ra + rb + 8*pi), p.z);\n    vec3 rp11 = vec3(p.x + d*cos(ra + rb + 9*pi),", "\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2", "\n    ivec3 p = v;\n    p.x = (v.x * v.x) - (v.y * v.y) - (v.z * v.z);\n    p.y = (2 * v.x * v.y) - (2 * v.z * v.x);\n    p.z = (2 * v.x * v.z) + (2 * v.y * v.x);\n    return p;\n}\n\nivec3 Pcg2(ivec3 v)\n{\n    ivec3 p = v;\n    p.x = (v.x * v.x) - (v.y * v.y);\n    p.y = (2 * v.x * v.y);\n    return p;\n}\n\nivec3 Pcg1(ivec3 v)\n{\n    ivec3 p = v;\n    p.x = (v.x * v.x);\n    p.y = (2 * v.x * v.y);\n    p.z = (2 * v.x * v.z);\n    return p;\n}\n\nivec3 Pcg0(ivec3 v)\n{\n    ivec3 p = v;\n    p.x = (v.x * v.x);\n    p.y = (2 * v.x * v.y);\n    p.z = (2 * v.x * v.z);\n    return p;\n}\n\nivec3 Pcg(ivec3 v)\n{\n    ivec3 p = v;\n    p.x = (v.x * v.x) - (v.y * v.y) - (v.z * v.z);\n    p.y = (2 * v.x * v.y) - (2 * v.z * v.x);\n    p.z = (2 * v.x * v.z) + (2 * v.y * v.x);\n    return p;\n}\n\nivec3 Pcg2(ivec3 v)\n{\n    ivec3 p = v;\n    p.x = (v.x * v.", "\n    float x = pos.x;\n    float y = pos.y;\n    float a = A.x - x;\n    float b = A.y - y;\n    float c = B.x - x;\n    float d = B.y - y;\n    float e = C.x - x;\n    float f = C.y - y;\n    float g = a * a + b * b;\n    float h = 2 * a * c + 2 * b * d;\n    float i = c * c + d * d;\n    float j = 2 * c * e + 2 * d * f;\n    float k = e * e + f * f;\n    float l = a * a * i + b * b * j + c * c * k;\n    float m = a * a * j + b * b * k + c * c * l;\n    float n = a * a * k + b * b * l + c * c * m;\n    float o = a * a * l + b * b * m + c * c * n;\n    float p = a * a * m + b * b * n + c * c * o;\n    float q = a * a * n + b * b * o + c * c * p;\n    float r = a * a * o + b * b * p + c * c * q;\n    float s = a * a * p + b * b * q + c * c * r;\n    float t = a * a * q + b * b * r + c * c * s;\n    float u = a * a * r + b * b * s + c * c * t;\n    float v = a * a * s + b * b * t + c * c * u;\n    float w = a * a * t + b * b * u + c * c * v;\n    float x = a * a * u + b * b * v + c * c * w;\n    float y = a * a * v + b * b * w + c * c * x;\n    float z = a * a * w + b * b * x + c * c * y;\n    float d = sqrt(z);", "\n    float x = (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n    return x;\n}\n\n// Source: https://www.shadertoy.com/view/X2J7XW\nfloat", "\n  vec3 r = rd - ro;\n  vec3 n = normalize( r );\n  vec3 p = ro + s * n;\n  vec3 d = p - ro;\n  float t = dot( d, n );\n  if( t < 0 )\n    return vec4( 0.0, 0.0, 0.0, 0.0 );\n  float w = dot( r, n );\n  float h = dot( r, d );\n  float z = dot( d, d );\n  float wz = dot( w, z );\n  float wh = dot( w, h );\n  float wzw = dot( wz, wz );\n  float whw = dot( wh, wh );\n  float wzwz = dot( wzw, z );\n  float wzwzw = dot( wzwz, wzw );\n  float wzwzhh = dot( wzwz, h );\n  float wzwzhhh = dot( wzwzhh, wzwz );\n  float wzwzhhhh = dot( wzwzhhh, h );\n  float wzwzhhhhh = dot( wzwzhhhh, wzwz );\n  float wzwzhhhhhh = dot( wzwzhhhhhh, h );\n  float wzwzhhhhhhh = dot( wzwzhhhhhhh, wzwz );\n  float wzwzhhhhhhhh = dot( wzwzhhhhhhhh, h );\n  float wzwzhhhhhhhhh = dot( wzwzhhhhhhhhh, wzwz );\n  float wzwzhhhhhhhhhh = dot( wzwzhhhhhhhhhh, h );\n  float wzwzhhhhhhhhhhh = dot( wzwzhhhhhhhhhhh, wzwz );\n  float wzwzhhhhhhhhhhh = dot( wzwzhhhhhhhhhhh, h );\n  float wzwzhhhhhhhhhhhh = dot( wzwzhhhhhh", "\n    int a_abs = abs(a);\n    int b_abs = abs(b);\n    int x_abs = abs(x);\n    int a_sign = a_abs >> 23;\n    int b_sign = b_abs >> 23;\n    int x_sign = x_abs >> 23;\n    int a_exp = a_abs >> 12;\n    int b_exp = b_abs >> 12;\n    int x_exp = x_abs >> 12;\n    int a_mant = a_abs & 0x007fffff;\n    int b_mant = b_abs & 0x007fffff;\n    int x_mant = x_abs & 0x007fffff;\n    int a_mant_exp = a_mant >> 12;\n    int b_mant_exp = b_mant >> 12;\n    int x_mant_exp = x_mant >> 12;\n    int a_mant_sign = a_mant & 0x3f;\n    int b_mant_sign = b_mant & 0x3f;\n    int x_mant_sign = x_mant & 0x3f;\n    int a_mant_exp_sign = a_mant_exp & 0x3f;\n    int b_mant_exp_sign = b_mant_exp & 0x3f;\n    int x_mant_exp_sign = x_mant_exp & 0x3f;\n    int a_mant_exp_abs = a_mant_exp - a_mant_exp_sign;\n    int b_mant_exp_abs = b_mant_exp - b_mant_exp_sign;\n    int x_mant_exp_abs = x_mant_exp - x_mant_exp_sign;\n    int a_mant_exp_sign = a_mant_exp_sign & 0x3f;\n    int b_mant_exp_sign = b_mant_exp_sign & 0x3f;\n    int x_mant_exp_sign = x_mant_exp_sign & 0x3f;\n    ", "\n    vec3 s = a - b;\n    vec3 sMin = s.normalize();\n    vec3 sMin2 = sMin.normalize();\n    vec3 sMin3 = sMin2.normalize();\n    vec3 sMin4 = sMin3.normalize();\n    vec3 sMin5 = sMin4.normalize();\n    vec3 sMin6 = sMin5.normalize();\n    vec3 sMin7 = sMin6.normalize();\n    vec3 sMin8 = sMin7.normalize();\n    vec3 sMin9 = sMin8.normalize();\n    vec3 sMin10 = sMin9.normalize();\n    vec3 sMin11 = sMin10.normalize();\n    vec3 sMin12 = sMin11.normalize();\n    vec3 sMin13 = sMin12.normalize();\n    vec3 sMin14 = sMin13.normalize();\n    vec3 sMin15 = sMin14.normalize();\n    vec3 sMin16 = sMin15.normalize();\n    vec3 sMin17 = sMin16.normalize();\n    vec3 sMin18 = sMin17.normalize();\n    vec3 sMin19 = sMin18.normalize();\n    vec3 sMin20 = sMin19.normalize();\n    vec3 sMin21 = sMin20.normalize();\n    vec3 sMin22 = sMin21.normalize();\n    vec3 sMin23 = sMin22.normalize();\n    vec3 sMin24 = sMin23.normalize();\n    vec3 sMin25 = sMin24.normalize();\n    vec3 sMin26 = sMin25.normalize();\n    vec3 sMin27 = sMin26.normalize();\n    vec3 sMin28 = sMin27.normalize();\n    vec3 sMin29 = sMin28.normalize();\n    vec3 sMin30 = sMin29.normalize();\n    vec3 sMin31 = sMin30.normalize();\n    vec3 sMin32 = sMin31.normalize();\n    vec3 sMin33 = sMin32.normalize();\n    vec3 sMin34 = sMin33", "\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    float a = ab.x*ab.x - ab.y*ab.y;\n    float b = 2*ab.x*x + 2*ab.y*y;\n    float c = ab.x*ab.x + ab.y*ab.y - 1;\n    return (a*a*a + b*b*b - c*c*c) < 0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat", "\n    float c = a + b;\n    return c;\n}\n\nfloat", "\n    //p is the point on the hyperbola\n    //ab is the distance from the center to the foci\n    //s1 and s2 are the distances from the center to the vertices\n    //returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is not on the hyperbola, returns the two points on the hyperbola that are closest to p\n    //if p is on the hyperbola, returns the two points on the hyperbola that are closest to p", "\n    vec3 p0 = a + (b - a) * (p - a);\n    vec3 p1 = b + (a - b) * (p - b);\n    vec3 p2 = a + (b - a) * (p - a);\n    vec3 p3 = b + (a - b) * (p - b);\n\n    float d0 = dot(p0 - p, p0 - p);\n    float d1 = dot(p1 - p, p1 - p);\n    float d2 = dot(p2 - p, p2 - p);\n    float d3 = dot(p3 - p, p3 - p);\n\n    float d0a = dot(p0 - a, p0 - a);\n    float d1a = dot(p1 - a, p1 - a);\n    float d2a = dot(p2 - a, p2 - a);\n    float d3a = dot(p3 - a, p3 - a);\n\n    float d0b = dot(p0 - b, p0 - b);\n    float d1b = dot(p1 - b, p1 - b);\n    float d2b = dot(p2 - b, p2 - b);\n    float d3b = dot(p3 - b, p3 - b);\n\n    float d0 = max(d0, 0.0);\n    float d1 = max(d1, 0.0);\n    float d2 = max(d2, 0.0);\n    float d3 = max(d3, 0.0);\n\n    float d0a = max(d0a, 0.0);\n    float d1a = max(d1a, 0.0);\n    float d2a = max(d2a, 0.0);\n    float d3a = max(d3a, 0.0);\n\n    float d0b = max(d0b, 0.0);\n    float d1b = max(d1b, 0.0);\n    float d2b = max(d2b, 0.0);\n    float d3b = max(d3b, 0.0);\n\n    float d0 = min(d0, ra", "\n    vec3 p1 = p - a;\n    vec3 p2 = p - b;\n    float d1 = dot(p1, p1);\n    float d2 = dot(p2, p2);\n    float d3 = dot(p1, p2);\n    float d4 = dot(p1, p1);\n    float d5 = dot(p2, p2);\n    float d6 = dot(p1, p2);\n    float d7 = dot(p1, p1);\n    float d8 = dot(p2, p2);\n    float d9 = dot(p1, p2);\n    float d10 = dot(p1, p1);\n    float d11 = dot(p2, p2);\n    float d12 = dot(p1, p2);\n    float d13 = dot(p1, p1);\n    float d14 = dot(p2, p2);\n    float d15 = dot(p1, p2);\n    float d16 = dot(p1, p1);\n    float d17 = dot(p2, p2);\n    float d18 = dot(p1, p2);\n    float d19 = dot(p1, p1);\n    float d20 = dot(p2, p2);\n    float d21 = dot(p1, p2);\n    float d22 = dot(p1, p1);\n    float d23 = dot(p2, p2);\n    float d24 = dot(p1, p2);\n    float d25 = dot(p1, p1);\n    float d26 = dot(p2, p2);\n    float d27 = dot(p1, p2);\n    float d28 = dot(p1, p1);\n    float d29 = dot(p2, p2);\n    float d30 = dot(p1, p2);\n    float d31 = dot(p1, p1);\n    float d32 = dot(p2, p2);\n    float d33 = dot(p1, p2);\n    float d34 = dot(p1, p1);\n    float d35 = dot(p2, p2);", "\n    float r = sqrt( (p.x - cen.x) * (p.x - cen.x) + (p.y - cen.y) * (p.y - cen.y) + (p.z - cen.z) * (p.z - cen.z) );\n    return rad * (1.0 - r / rad);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec3 normal;\n    vec3 uv = normalize(samplePoint - pos);\n    vec3 v = normalize(cross(uv, vec3(0,0,1)));\n    if( showSurface )\n    {\n        normal = normalize(cross(uv, v));\n    }\n    return normal;\n}\n\n// https://www.cs.cmu.edu/~matt/courses/cs294/lectures/lecture5.pdf\nvec", "\n    // Calculate the distance between the light and the surface\n    float d = calcDistance( ro, rd );\n\n    // If the surface is not visible, return 0\n    if( d == 0 )\n        return 0;\n\n    // Calculate the direction vector from the light to the surface\n    vec3 dir = rd - ro;\n\n    // Calculate the normal vector to the surface\n    vec3 n = normalize( cross( dir, samplePoint - ro ) );\n\n    // Calculate the dot product of the normal and the direction\n    float dot = dot( n, dir );\n\n    // If the dot product is negative, the surface is not visible\n    if( dot < 0 )\n        return 0;\n\n    // Calculate the shadow distance\n    float shadowDistance = d - dot;\n\n    // If the shadow distance is negative, the surface is not visible\n    if( shadowDistance < 0 )\n        return 0;\n\n    // Calculate the shadow intensity\n    float intensity = 1.0f - ( shadowDistance / d );\n\n    // If the surface is not visible, return 0\n    if( showSurface )\n        return intensity;\n\n    // Calculate the shadow vector\n    vec3 shadow = normalize( samplePoint - ( shadowDistance * dir ) );\n\n    // Calculate the shadow point\n    vec3 shadowPoint = ro + ( shadow * shadowDistance );\n\n    // Calculate the shadow intensity\n    float shadowIntensity = calcIntensity( shadowPoint, samplePoint, ro, rd );\n\n    // If the shadow intensity is negative, the surface is not visible\n    if( shadowIntensity < 0 )\n        return 0;\n\n    // Return the shadow intensity\n    return shadowIntensity;\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat", "\n    vec3 d = p - ocl;\n    vec3 d1 = p + ocl;\n    vec3 d2 = p + ocl + vec2(ra, 0.0);\n    vec3 d3 = p + ocl + vec2(0.0, rb);\n    vec3 d4 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb);\n    vec3 d5 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb) + vec2(0.0, he);\n    vec3 d6 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb) + vec2(0.0, he) + vec2(0.0, he);\n    vec3 d7 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he);\n    vec3 d8 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he);\n    vec3 d9 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he);\n    vec3 d10 = p + ocl + vec2(ra, 0.0) + vec2(0.0, rb) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he) + vec2(0.0, he);\n    vec3 d11 = p + ocl +", "\n    vec3 p1 = p + vec3(0.5, 0.5, 0.5);\n    vec3 p2 = p - vec3(0.5, 0.5, 0.5);\n    vec3 p3 = p - vec3(0.5, -0.5, 0.5);\n    vec3 p4 = p - vec3(0.5, 0.5, -0.5);\n    vec3 p5 = p - vec3(-0.5, 0.5, 0.5);\n    vec3 p6 = p - vec3(-0.5, 0.5, -0.5);\n    vec3 p7 = p - vec3(-0.5, -0.5, 0.5);\n    vec3 p8 = p - vec3(-0.5, -0.5, -0.5);\n\n    vec3 a1 = p1 - p;\n    vec3 a2 = p2 - p;\n    vec3 a3 = p3 - p;\n    vec3 a4 = p4 - p;\n    vec3 a5 = p5 - p;\n    vec3 a6 = p6 - p;\n    vec3 a7 = p7 - p;\n    vec3 a8 = p8 - p;\n\n    vec3 b1 = a1 * a1;\n    vec3 b2 = a2 * a2;\n    vec3 b3 = a3 * a3;\n    vec3 b4 = a4 * a4;\n    vec3 b5 = a5 * a5;\n    vec3 b6 = a6 * a6;\n    vec3 b7 = a7 * a7;\n    vec3 b8 = a8 * a8;\n\n    vec3 c1 = b1 * b1;\n    vec3 c2 = b2 * b2;\n    vec3 c3 = b3 * b3;\n    vec3 c4 = b4 * b4;\n    vec3 c5 = b5 * b5;\n    vec3 c6 = b6 * b6;\n    vec3 c7 = b7 * b7;\n    vec3 c8 = b8 * b8;\n\n    vec3 d1 = c1 *", "\n    float u = (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n    if (u < 0.0f) return 0.0f;\n    if (u > 1.0f) return 1.0f;\n    return u;\n}\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by the formula:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by the formula:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by the formula:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by the formula:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by the formula:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by the formula:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nI think you are looking for the distance between two points.\n", "\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat", "\n    float dx = p.x - minCorner.x;\n    float dy = p.y - minCorner.y;\n    return (dx*dx + dy*dy);\n}\n\n// Find the closest point to the center of the bounding box\nfloat", "\n    // Calculate the distance from the camera to the water surface\n    float d = distance(camera, cdir);\n    // Calculate the fraction of the water surface that is visible\n    float f = clamp(d, 0, 1);\n    // Calculate the fraction of the water surface that is reflected\n    float r = clamp(f, 0, 1);\n    // Calculate the fraction of the water surface that is refracted\n    float n = refract(uv, cdir);\n    // Calculate the fraction of the water surface that is absorbed\n    float a = absorb(uv, cdir);\n    // Calculate the fraction of the water surface that is scattered\n    float s = scatter(uv, cdir);\n    // Calculate the fraction of the water surface that is transmitted\n    float t = transmit(uv, cdir);\n    // Calculate the fraction of the water surface that is reflected\n    float rr = reflect(uv, cdir);\n    // Calculate the fraction of the water surface that is refracted\n    float nn = refract(uv, cdir);\n    // Calculate the fraction of the water surface that is absorbed\n    float aa = absorb(uv, cdir);\n    // Calculate the fraction of the water surface that is scattered\n    float ss = scatter(uv, cdir);\n    // Calculate the fraction of the water surface that is transmitted\n    float tt = transmit(uv, cdir);\n    // Calculate the fraction of the water surface that is reflected\n    float rrr = reflect(uv, cdir);\n    // Calculate the fraction of the water surface that is refracted\n    float nnn = refract(uv, cdir);\n    // Calculate the fraction of the water surface that is absorbed\n    float aaa = absorb(uv, cdir);\n    // Calculate the fraction of the water surface that is scattered\n    float sss = scatter(uv, cdir);\n    // Calculate the fraction of the water surface that", "\n    vec2 p = vec2(uv.x, uv.y);\n    vec3 pout = vec3(p.x, p.y, 1.0);\n    return pout;\n}\n\n// Projection matrix\nvec", "\n    vec3 w = q.w * v.x + q.x * v.w + q.y * v.z + q.z * v.y;\n    vec3 x = q.w * v.y - q.x * v.z + q.y * v.w + q.z * v.x;\n    vec3 y = q.w * v.z + q.x * v.y - q.y * v.x + q.z * v.w;\n    vec3 z = q.w * v.x - q.x * v.y + q.y * v.z + q.z * v.w;\n    return vec3(w, x, y, z);\n}\n\n// Quaternion-quaternion multiplication\nvec", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt( x*x + y*y );\n    if( d > r )\n        return 0.0;\n    else\n        return 1.0 - (d/r);\n}\n\nfloat", "\n    float x = p.x - a.x;\n    float y = p.y - a.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x", "\n    vec2 res;\n    res.x = m.x + d*cos(a);\n    res.y = m.y + d*sin(a);\n    return res;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec", "\n    vec2 p = ro + rd;\n    vec2 p1 = ro - p;\n    vec2 p2 = p + p;\n    vec2 p3 = p - p;\n    vec2 p4 = p + p1;\n    vec2 p5 = p - p1;\n    vec2 p6 = p + p2;\n    vec2 p7 = p - p2;\n    vec2 p8 = p + p3;\n    vec2 p9 = p - p3;\n    vec2 p10 = p + p4;\n    vec2 p11 = p - p4;\n    vec2 p12 = p + p5;\n    vec2 p13 = p - p5;\n    vec2 p14 = p + p6;\n    vec2 p15 = p - p6;\n    vec2 p16 = p + p7;\n    vec2 p17 = p - p7;\n    vec2 p18 = p + p8;\n    vec2 p19 = p - p8;\n    vec2 p20 = p + p9;\n    vec2 p21 = p - p9;\n    vec2 p22 = p + p10;\n    vec2 p23 = p - p10;\n    vec2 p24 = p + p11;\n    vec2 p25 = p - p11;\n    vec2 p26 = p + p12;\n    vec2 p27 = p - p12;\n    vec2 p28 = p + p13;\n    vec2 p29 = p - p13;\n    vec2 p30 = p + p14;\n    vec2 p31 = p - p14;\n    vec2 p32 = p + p15;\n    vec2 p33 = p - p15;\n    vec2 p34 = p + p16;\n    vec2 p35 = p - p16;\n    vec2 p36 = p + p17;\n    vec2 p37 = p - p17;\n    vec2 p38 = p + p18;\n    vec2 p39 = p - p18;\n    vec2 p40 = p + p19;\n    vec2 p41 = p - p19;\n    vec2 p42 = p + p20;", "\n    vec3 d = p - c;\n    vec3 s = d.normalize();\n    vec3 ds = s.dot(d);\n    vec3 ds2 = ds * ds;\n    vec3 ds3 = ds2 * ds;\n    vec3 ds4 = ds3 * ds;\n    vec3 ds5 = ds4 * ds;\n    vec3 ds6 = ds5 * ds;\n    vec3 ds7 = ds6 * ds;\n    vec3 ds8 = ds7 * ds;\n    vec3 ds9 = ds8 * ds;\n    vec3 ds10 = ds9 * ds;\n    vec3 ds11 = ds10 * ds;\n    vec3 ds12 = ds11 * ds;\n    vec3 ds13 = ds12 * ds;\n    vec3 ds14 = ds13 * ds;\n    vec3 ds15 = ds14 * ds;\n    vec3 ds16 = ds15 * ds;\n    vec3 ds17 = ds16 * ds;\n    vec3 ds18 = ds17 * ds;\n    vec3 ds19 = ds18 * ds;\n    vec3 ds20 = ds19 * ds;\n    vec3 ds21 = ds20 * ds;\n    vec3 ds22 = ds21 * ds;\n    vec3 ds23 = ds22 * ds;\n    vec3 ds24 = ds23 * ds;\n    vec3 ds25 = ds24 * ds;\n    vec3 ds26 = ds25 * ds;\n    vec3 ds27 = ds26 * ds;\n    vec3 ds28 = ds27 * ds;\n    vec3 ds29 = ds28 * ds;\n    vec3 ds30 = ds29 * ds;\n    vec3 ds31 = ds30 * ds;\n    vec3 ds32 = ds31 * ds;\n    vec3 ds33 = ds32 * ds", "\n    vec3 sdf = vec3(0.0);\n    vec3 d = b - p;\n    vec3 dnorm = d / sqrt(d.x*d.x + d.y*d.y);\n    vec3 dnorm2 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm3 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm4 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm5 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm6 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm7 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm8 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm9 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm10 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm11 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm12 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm13 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm14 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm15 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm16 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm17 = dnorm.x*dnorm.x + dnorm.y*dnorm.y;\n    vec3 dnorm18 = dnorm.x", "\n    vec3 x = p.x;\n    vec3 y = p.y;\n    vec3 z = p.z;\n    vec3 yz = (vec3) (y,z);\n    vec3 xyz = (vec3) (x,y,z);\n    vec3 xyz2 = (vec3) (x*x,y*y,z*z);\n    vec3 xyz3 = (vec3) (x*x*x,y*y*y,z*z*z);\n    vec3 xyz4 = (vec3) (x*x*x*x,y*y*y*y,z*z*z*z);\n    vec3 xyz5 = (vec3) (x*x*x*x*x,y*y*y*y*y,z*z*z*z*z);\n    vec3 xyz6 = (vec3) (x*x*x*x*x*x,y*y*y*y*y*y,z*z*z*z*z*z);\n    vec3 xyz7 = (vec3) (x*x*x*x*x*x*x,y*y*y*y*y*y*y,z*z*z*z*z*z*z);\n    vec3 xyz8 = (vec3) (x*x*x*x*x*x*x*x,y*y*y*y*y*y*y*y,z*z*z*z*z*z*z*z);\n    vec3 xyz9 = (vec3) (x*x*x*x*x*x*x*x*x,y*y*y*y*y*y*y*y*y,z*z*z*z*z*z*z*z*z);\n    vec3 xyz10 = (vec3) (x*x*x*x*x*x*x*x*x*x,y*y*y*y*y*y*y*y*y*y,z*z*z*z*z*z*z*z*z*z);\n    vec3 xyz11", "\n    return a1 * x + b1;\n}\n\nfloat", "\n    return a * sin(n * x) + b;\n}\n\n// https://www.desmos.com/calculator/xjwqzcqzq8\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                float x = uv.x;\n                float y = uv.y;\n                float x2 = x*x;\n                float y2 = y*y;\n                float xy = x*y;\n                float xy2 = xy*xy;\n                float xy3 = xy*xy2;\n                float xy4 = xy*xy3;\n                float xy5 = xy*xy4;\n                float xy6 = xy*xy5;\n                float xy7 = xy*xy6;\n                float xy8 = xy*xy7;\n                float xy9 = xy*xy8;\n                float xy10 = xy*xy9;\n                float xy11 = xy*xy10;\n                float xy12 = xy*xy11;\n                float xy13 = xy*xy12;\n                float xy14 = xy*xy13;\n                float xy15 = xy*xy14;\n                float xy16 = xy*xy15;\n                float xy17 = xy*xy16;\n                float xy18 = xy*xy17;\n                float xy19 = xy*xy18;\n                float xy20 = xy*xy19;\n                float xy21 = xy*xy20;\n                float xy22 = xy*xy21;\n                float xy23 = xy*xy22;\n                float xy24 = xy*xy23;\n                float xy25 = xy*xy24;\n                float xy26 = xy*xy25;\n                float xy27 = xy*xy26;\n                float xy28 = xy*xy27;\n                float xy29 = xy*xy28;\n                float xy30 = xy*xy29;\n                float xy31 = xy*xy30;\n                float xy32 = xy*xy31;\n                float xy33 = xy*xy32;\n                float xy34 = xy*xy33;\n                float xy35 = xy*xy34;\n                float xy36 = xy*xy35;\n                float xy37 = x", "\n    vec3 result;\n    result.x = (x/14) * 6;\n    result.y = (y/13) * 6;\n    result.z = 0;\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec", "\n    float x, y;\n    x = p.x - c.x;\n    y = p.y - c.y;\n    return sqrt(x*x + y*y) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float s = sqrt(x*x + y*y);\n    float r = s/b.x;\n    return (r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r", "\n    return a - p;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n    vec2 p1 = p + a * h;\n    vec2 p2 = p + b * h;\n    vec2 p3 = p + a * (1.0f - h);\n    vec2 p4 = p + b * (1.0f - h);\n\n    vec2 p1p2 = p1 - p2;\n    vec2 p2p3 = p2 - p3;\n    vec2 p3p4 = p3 - p4;\n    vec2 p4p1 = p4 - p1;\n\n    vec2 p1p2p3p4 = p1p2 + p2p3 + p3p4;\n    vec2 p1p2p3p4p1 = p1p2 + p2p3 + p3p4 + p4p1;\n\n    vec2 p1p2p3p4p1p2 = p1p2 + p2p3 + p3p4 + p4p1 + p1p2;\n\n    vec2 p1p2p3p4p1p2p3 = p1p2 + p2p3 + p3p4 + p4p1 + p1p2 + p3p4;\n\n    vec2 p1p2p3p4p1p2p3p4 = p1p2 + p2p3 + p3p4 + p4p1 + p1p2 + p3p4 + p4p1;\n\n    vec2 p1p2p3p4p1p2p3p4p1 = p1p2 + p2p3 + p3p4 + p4p1 + p1p2 + p3p4 + p4p1 + p1p2;\n\n    vec2 p1p2p3p4p1p2p3p4p1p2 = p1p2 + p2p3 + p3p4 + p4p1 + p1p2 + p3p4 + p4p1 + p1p2 + p3p4;\n\n    vec2 p1p2p3p4p1p2p3p4p1p2p3 = p1p2 + p2p3 + p3p4 + p4p", "\n    float sdf = 0.0;\n    int i;\n    for( i = 0; i < 7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            sdf += sdLine( p, kPath[2*i], kPath[2*i+1] );\n        }\n        else if( kType[i] == 1 )\n        {\n            sdf += sdArc( p, kPath[2*i], kPath[2*i+1], kPath[2*i+2], kPath[2*i+3] );\n        }\n    }\n    return sdf;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat", "\n    float sum = 0.0f;\n    for( int i = 0; i < vec2.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / vec2.size() );\n}\n\nA:\n\nYou are using the wrong type for the sum.\nfloat", "\n    float s = 0.0f;\n    float s1 = 0.0f;\n    float s2 = 0.0f;\n    float s3 = 0.0f;\n    float s4 = 0.0f;\n    float s5 = 0.0f;\n    float s6 = 0.0f;\n    float s7 = 0.0f;\n    float s8 = 0.0f;\n    float s9 = 0.0f;\n    float s10 = 0.0f;\n    float s11 = 0.0f;\n    float s12 = 0.0f;\n    float s13 = 0.0f;\n    float s14 = 0.0f;\n    float s15 = 0.0f;\n    float s16 = 0.0f;\n    float s17 = 0.0f;\n    float s18 = 0.0f;\n    float s19 = 0.0f;\n    float s20 = 0.0f;\n    float s21 = 0.0f;\n    float s22 = 0.0f;\n    float s23 = 0.0f;\n    float s24 = 0.0f;\n    float s25 = 0.0f;\n    float s26 = 0.0f;\n    float s27 = 0.0f;\n    float s28 = 0.0f;\n    float s29 = 0.0f;\n    float s30 = 0.0f;\n    float s31 = 0.0f;\n    float s32 = 0.0f;\n    float s33 = 0.0f;\n    float s34 = 0.0f;\n    float s35 = 0.0f;\n    float s36 = 0.0f;\n    float s37 = 0.0f;\n    float s38 = 0.0f;\n    float s39 = 0.0f;\n    float s40 = 0.0f;\n    float s41 = 0.0f;\n    float s42 = 0.0f;\n    float s43 = 0.0f;\n    float s44 = 0.0f;\n    float s45 = 0.0f;\n    float s46 = 0", "\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = u + v;\n    vec2 y = u + w;\n    vec2 z = v + w;\n    vec2 a = u + v + w;\n    vec2 b = u + w + v;\n    vec2 c = v + w + u;\n    vec2 d = w + u + v;\n    vec2 e = w + v + u;\n    vec2 f = u + v + w;\n    vec2 g = u + w + v;\n    vec2 h = v + w + u;\n    vec2 i = w + u + v;\n    vec2 j = u + v + w;\n    vec2 k = u + w + v;\n    vec2 l = w + u + v;\n    vec2 m = u + v + w;\n    vec2 n = u + w + v;\n    vec2 o = w + u + v;\n    vec2 p = u + v + w;\n    vec2 q = u + w + v;\n    vec2 r = w + u + v;\n    vec2 s = u + v + w;\n    vec2 t = u + w + v;\n    vec2 uv = u + v;\n    vec2 vu = v + u;\n    vec2 wv = w + u;\n    vec2 xv = u + v + w;\n    vec2 yv = v + u + w;\n    vec2 zv = w + u + v;\n    vec2 av = u + v + w;\n    vec2 bv = u + w + v;\n    vec2 cv = v + w + u;\n    vec2 dv = w + u + v;\n    vec2 ev = u + v + w;\n    vec2 fv = u + w + v;\n    vec2 gv = v + w + u;\n    vec2 hv = w + u + v;\n    vec2 iv = u + v + w;\n    vec2 jv = u + w + v;\n    vec2 kv = v +", "\n    // Find the closest point on the line segment\n    vec2 p1 = a;\n    vec2 p2 = b;\n    vec2 p3 = p;\n    float d = p2 - p1;\n    float dp = p3 - p1;\n    float dp2 = dp * dp;\n    float t = (dp2 * (p1 - p3) + d * (p2 - p3) * (p1 - p3).dot(d)) / (d2 * dp2);\n    if (t < 0.0)\n        return p1;\n    if (t > 1.0)\n        return p2;\n    return p1 + t * d;\n}\n\n// Closest point on line\nvec", "\n    float d = p.x - a.x;\n    float e = p.y - a.y;\n    float f = b.x - a.x;\n    float g = b.y - a.y;\n    float h = d * d + e * e;\n    float i = f * f + g * g;\n    float j = 2 * f * d + 2 * g * e;\n    float k = d * d * (1 - (i / j));\n    float l = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float m = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float n = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float p = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float q = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float r = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float s = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float t = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float u = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float v = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float w = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float x = (f * f * (1 - (i / j)) + g * g * (1 - (i / j)));\n    float y = (f * f * (1 - (i /", "\n    vec2 p0 = b - r;\n    vec2 p1 = b + r;\n    vec2 p2 = p0 + p1;\n    vec2 p3 = p0 - p1;\n    vec2 p4 = p2 - p0;\n    vec2 p5 = p3 - p0;\n    vec2 p6 = p4 - p0;\n    vec2 p7 = p5 - p0;\n    vec2 p8 = p6 - p0;\n    vec2 p9 = p7 - p0;\n    vec2 p10 = p8 - p0;\n    vec2 p11 = p9 - p0;\n    vec2 p12 = p10 - p0;\n    vec2 p13 = p11 - p0;\n    vec2 p14 = p12 - p0;\n    vec2 p15 = p13 - p0;\n    vec2 p16 = p14 - p0;\n    vec2 p17 = p15 - p0;\n    vec2 p18 = p16 - p0;\n    vec2 p19 = p17 - p0;\n    vec2 p20 = p18 - p0;\n    vec2 p21 = p19 - p0;\n    vec2 p22 = p20 - p0;\n    vec2 p23 = p21 - p0;\n    vec2 p24 = p22 - p0;\n    vec2 p25 = p23 - p0;\n    vec2 p26 = p24 - p0;\n    vec2 p27 = p25 - p0;\n    vec2 p28 = p26 - p0;\n    vec2 p29 = p27 - p0;\n    vec2 p30 = p28 - p0;\n    vec2 p31 = p29 - p0;\n    vec2 p32 = p30 - p0;\n    vec2 p33 = p31 - p0;\n    vec2 p34 = p32 - p0;\n    vec2 p35 = p33 - p0;\n    vec2 p36 = p34 - p0;\n    vec2 p37 = p35 - p0;\n    vec2 p38 = p36 - p0;\n    vec2 p39 = p37", "\n    float dx = p.x - b.x;\n    float dy = p.y - b.y;\n    float d = sqrt(dx*dx + dy*dy);\n    float dRound = round(d*r);\n    float dxRound = dRound/r - dx;\n    float dyRound = dRound/r - dy;\n    return sqrt(dxRound*dxRound + dyRound*dyRound);\n}\n\nA:\n\nI think you can use the following code:\nfloat", "\n    float dx = p.x - b.x;\n    float dy = p.y - b.y;\n    return sqrt(dx*dx + dy*dy);\n}\n\n// distance to line\nfloat", "\n    float x = p.x;\n    float y = p.y;\n    float h = (x*x + y*y) * 0x5f3759df - (x*x*3 + y*y*3) * 0x919056cf;\n    return h;\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat", "\n    float x1 = x.x;\n    float x2 = x.y;\n    float x3 = x1 * x1;\n    float x4 = x2 * x2;\n    float x5 = x3 * x3;\n    float x6 = x4 * x4;\n    float x7 = x5 * x5;\n    float x8 = x6 * x6;\n    float x9 = x7 * x7;\n    float x10 = x8 * x8;\n    float x11 = x9 * x9;\n    float x12 = x10 * x10;\n    float x13 = x11 * x11;\n    float x14 = x12 * x12;\n    float x15 = x13 * x13;\n    float x16 = x14 * x14;\n    float x17 = x15 * x15;\n    float x18 = x16 * x16;\n    float x19 = x17 * x17;\n    float x20 = x18 * x18;\n    float x21 = x19 * x19;\n    float x22 = x20 * x20;\n    float x23 = x21 * x21;\n    float x24 = x22 * x22;\n    float x25 = x23 * x23;\n    float x26 = x24 * x24;\n    float x27 = x25 * x25;\n    float x28 = x26 * x26;\n    float x29 = x27 * x27;\n    float x30 = x28 * x28;\n    float x31 = x29 * x29;\n    float x32 = x30 * x30;\n    float x33 = x31 * x31;\n    float x34 = x32 * x32;\n    float x35 = x33 * x33;\n    float x36 = x34 * x34;\n    float x37 = x35 * x35;\n    float x38 = x36 * x36;\n    float x39 = x37 * x37;\n    float x40 = x38 * x38;\n    float x41 = x39 * x39;\n    float x42 = x40 * x40;\n    float x43 = x41 * x41;", "\n    return vec2(rand()%st.x, rand()%st.y);\n}\n\n// From iq\nvec", "\n    float x2 = x.x * x.x;\n    float y2 = x.y * x.y;\n    float z2 = x.z * x.z;\n    float x3 = x.x * x.x * x.x;\n    float y3 = x.y * x.y * x.y;\n    float z3 = x.z * x.z * x.z;\n    float x4 = x.x * x.x * x.x * x.x;\n    float y4 = x.y * x.y * x.y * x.y;\n    float z4 = x.z * x.z * x.z * x.z;\n    float x5 = x.x * x.x * x.x * x.x * x.x;\n    float y5 = x.y * x.y * x.y * x.y * x.y;\n    float z5 = x.z * x.z * x.z * x.z * x.z;\n    float x6 = x.x * x.x * x.x * x.x * x.x * x.x;\n    float y6 = x.y * x.y * x.y * x.y * x.y * x.y;\n    float z6 = x.z * x.z * x.z * x.z * x.z * x.z;\n    float x7 = x.x * x.x * x.x * x.x * x.x * x.x * x.x;\n    float y7 = x.y * x.y * x.y * x.y * x.y * x.y * x.y;\n    float z7 = x.z * x.z * x.z * x.z * x.z * x.z * x.z;\n    float x8 = x.x * x.x * x.x * x.x * x.x * x.x * x.x * x.x;\n    float y8 = x.y * x.y * x.y * x.y * x.y * x.y * x.y * x.y;\n    float z", "\n    float sigma = 0.1;\n    float t = x.x + x.y;\n    float tau = 0.1;\n    float tau2 = tau * tau;\n    float tau3 = tau2 * tau;\n    float tau4 = tau3 * tau;\n    float tau5 = tau4 * tau;\n    float tau6 = tau5 * tau;\n    float tau7 = tau6 * tau;\n    float tau8 = tau7 * tau;\n    float tau9 = tau8 * tau;\n    float tau10 = tau9 * tau;\n    float tau11 = tau10 * tau;\n    float tau12 = tau11 * tau;\n    float tau13 = tau12 * tau;\n    float tau14 = tau13 * tau;\n    float tau15 = tau14 * tau;\n    float tau16 = tau15 * tau;\n    float tau17 = tau16 * tau;\n    float tau18 = tau17 * tau;\n    float tau19 = tau18 * tau;\n    float tau20 = tau19 * tau;\n    float tau21 = tau20 * tau;\n    float tau22 = tau21 * tau;\n    float tau23 = tau22 * tau;\n    float tau24 = tau23 * tau;\n    float tau25 = tau24 * tau;\n    float tau26 = tau25 * tau;\n    float tau27 = tau26 * tau;\n    float tau28 = tau27 * tau;\n    float tau29 = tau28 * tau;\n    float tau30 = tau29 * tau;\n    float tau31 = tau30 * tau;\n    float tau32 = tau31 * tau;\n    float tau33 = tau32 * tau;\n    float tau34 = tau33 * tau;\n    float tau35 = tau34 * tau;\n    float t", "\n    float x2 = x.x * x.x + x.y * x.y;\n    float x3 = x2 * x2;\n    float x4 = x3 * x3;\n    float x5 = x4 * x3;\n    float x6 = x5 * x3;\n    float x7 = x6 * x3;\n    float x8 = x7 * x3;\n    float x9 = x8 * x3;\n    float x10 = x9 * x3;\n    float x11 = x10 * x3;\n    float x12 = x11 * x3;\n    float x13 = x12 * x3;\n    float x14 = x13 * x3;\n    float x15 = x14 * x3;\n    float x16 = x15 * x3;\n    float x17 = x16 * x3;\n    float x18 = x17 * x3;\n    float x19 = x18 * x3;\n    float x20 = x19 * x3;\n    float x21 = x20 * x3;\n    float x22 = x21 * x3;\n    float x23 = x22 * x3;\n    float x24 = x23 * x3;\n    float x25 = x24 * x3;\n    float x26 = x25 * x3;\n    float x27 = x26 * x3;\n    float x28 = x27 * x3;\n    float x29 = x28 * x3;\n    float x30 = x29 * x3;\n    float x31 = x30 * x3;\n    float x32 = x31 * x3;\n    float x33 = x32 * x3;\n    float x34 = x33 * x3;\n    float x35 = x34 * x3;\n    float x36 = x35 * x3;\n    float x37 = x36 * x3;\n    float x38 = x37 * x3;\n    float x39 = x38 * x3;\n    float x40 = x39 * x3;\n    float x41 = x40 * x3;\n    float x42 = x41 * x3;\n    float x43 = x42 * x", "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float x9 = 0.0;\n    float y9 = 0.0;\n    float x10 = 0.0;\n    float y10 = 0.0;\n    float x11 = 0.0;\n    float y11 = 0.0;\n    float x12 = 0.0;\n    float y12 = 0.0;\n    float x13 = 0.0;\n    float y13 = 0.0;\n    float x14 = 0.0;\n    float y14 = 0.0;\n    float x15 = 0.0;\n    float y15 = 0.0;\n    float x16", "\n    vec3 h = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 0.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 vv = vec3(0.0, 0.0, 0.0);\n    vec3 ww = vec3(0.0, 0.0, 0.0);\n    vec3 xx = vec3(0.0, 0.0, 0.0);\n    vec3 yy = vec3(0.0, 0.0, 0.0);\n    vec3 zz = vec3(0.0, 0.0, 0.0);\n    vec3 tt = vec3(0.0, 0.0, 0.0);\n    vec3 uu = vec3(0.0, 0.0, 0.0);\n    vec3 vvv = vec3(0.0, 0.0, 0.0);\n    vec3 wvv = vec3(0.0, 0.0, 0.0);\n    vec3 xxx = vec3(0.0, 0.0, 0.0);\n    vec3 yyy = vec3(0.0, 0.0, 0.0);\n    vec3 zzz = vec3(0.0, 0.0, 0.0);\n    vec3 ttt = vec3(0.0, 0.0, 0.0);\n    vec3 uuu = vec3(0.0, 0.0, 0.0);\n    vec3 vvvv = vec3(0.0, 0.0, 0.0);\n    vec3 wvvv = vec3(0", "\n    vec3 p1 = p + vec3(0.5, 0.5, 0.5);\n    vec3 p2 = p + vec3(0.5, 0.5, -0.5);\n    vec3 p3 = p + vec3(0.5, -0.5, 0.5);\n    vec3 p4 = p + vec3(0.5, -0.5, -0.5);\n    vec3 p5 = p + vec3(-0.5, 0.5, 0.5);\n    vec3 p6 = p + vec3(-0.5, 0.5, -0.5);\n    vec3 p7 = p + vec3(-0.5, -0.5, 0.5);\n    vec3 p8 = p + vec3(-0.5, -0.5, -0.5);\n    vec3 p9 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p10 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p11 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p12 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p13 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p14 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p15 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p16 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p17 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p18 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p19 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p20 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p21 = p + vec3(0.0, 0.0, 0.0);", "\n    vec2 h = vec2(0,0);\n    h.x = x.x * x.x;\n    h.y = x.y * x.y;\n    h.x += x.x * x.y;\n    h.y += x.x * x.y;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x * x.x;\n    h.x += x.x * x.x;\n    h.y += x.x", "\n    float x = p.x - a.x;\n    float y = p.y - a.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x", "\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float z = p.z - b.z;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float xy = x * y;\n    float xz = x * z;\n    float yz = y * z;\n    float xy2 = xy * xy;\n    float xyz = xz * yz;\n    float xyz2 = xyz * xyz;\n    float xyz3 = xyz2 * z;\n    float xyz4 = xyz2 * xyz;\n    float xyz5 = xyz2 * xy;\n    float xyz6 = xyz2 * xz;\n    float xyz7 = xyz2 * y;\n    float xyz8 = xyz2 * z;\n    float xyz9 = xyz2 * xy;\n    float xyz10 = xyz2 * xz;\n    float xyz11 = xyz2 * y;\n    float xyz12 = xyz2 * z;\n    float xyz13 = xyz2 * xy;\n    float xyz14 = xyz2 * xz;\n    float xyz15 = xyz2 * y;\n    float xyz16 = xyz2 * z;\n    float xyz17 = xyz2 * xy;\n    float xyz18 = xyz2 * xz;\n    float xyz19 = xyz2 * y;\n    float xyz20 = xyz2 * z;\n    float xyz21 = xyz2 * xy;\n    float xyz22 = xyz2 * xz;\n    float xyz23 = xyz2 * y;\n    float xyz24 = xyz2 * z;\n    float xyz25 = xyz2 * xy;\n    float xyz26 = xyz2 * xz;\n    float xyz27 = xyz2 * y;\n    float xyz28 = xyz2 * z;\n    float xyz29 = xyz2 * xy;\n    float xyz30 = xyz2", "\n    vec3 center_proj = proj_info * center;\n    vec3 normal_proj = proj_info * normal;\n    vec3 normal_proj_norm = normal_proj / length(normal_proj);\n    vec3 normal_proj_norm_cross = cross(normal_proj_norm, vec3(0, 1));\n    vec3 normal_proj_norm_cross_norm = normal_proj_norm_cross / length(normal_proj_norm_cross);\n    vec3 normal_proj_norm_cross_norm_cross = cross(normal_proj_norm_cross, normal_proj_norm_cross);\n    vec3 normal_proj_norm_cross_norm_cross_norm = normal_proj_norm_cross_norm_cross / length(normal_proj_norm_cross_norm_cross);\n    vec3 normal_proj_norm_cross_norm_cross_norm_cross_norm = normal_proj_norm_cross_norm_cross_norm / length(normal_proj_norm_cross_norm_cross_norm);\n    vec3 normal_proj_norm_cross_norm_cross_norm_cross_norm_cross = normal_proj_norm_cross_norm_cross_norm_cross / length(normal_proj_norm_cross_norm_cross_norm);\n    vec3 normal_proj_norm_cross_norm_cross_norm_cross_norm_cross_norm = normal_proj_norm_cross_norm_cross_norm_cross / length(normal_proj_norm_cross_norm_cross_norm);\n    vec3 normal_proj_norm_cross_norm_cross_norm_cross_norm_cross_norm = normal_proj_norm_cross_norm_cross_norm_cross / length(normal_proj_norm_cross_norm_cross_norm);\n    vec3 normal_proj_norm_cross_norm_cross_norm_cross_norm_cross_norm = normal_proj_norm_cross_norm_cross_norm_cross / length(normal_proj_norm_cross_norm_cross_norm);\n    vec3 normal_proj_norm_cross", "\n    float h = 0.0f;\n    h += p.x * p.x;\n    h += p.y * p.y;\n    h += p.x * p.y;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.x;\n    h += p.x * p.", "\n    float a = acs.x;\n    float b = acs.y;\n    float c = acs.x*a + acs.y*b;\n    float d = acs.x*a*a + acs.y*b*b;\n    float e = acs.x*a*a*a + acs.y*b*b*b;\n    float f = acs.x*a*a*a*a + acs.y*b*b*b*b;\n    float g = acs.x*a*a*a*a*a + acs.y*b*b*b*b*b;\n    float h = acs.x*a*a*a*a*a*a + acs.y*b*b*b*b*b*b*b;\n    float i = acs.x*a*a*a*a*a*a*a*a;\n    float j = acs.x*a*a*a*a*a*a*a*a*a;\n    float k = acs.x*a*a*a*a*a*a*a*a*a*a;\n    float l = acs.x*a*a*a*a*a*a*a*a*a*a*a;\n    float m1 = acs.x*a*a*a*a*a*a*a*a*a*a*a;\n    float n1 = acs.x*a*a*a*a*a*a*a*a*a*a*a*a;\n    float o1 = acs.x*a*a*a*a*a*a*a*a*a*a*a*a*a;\n    float p1 = acs.x*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n    float q1 = acs.x*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n    float r1 = acs.x*a*a*", "\n    vec3 n = vec3(0,0,0);\n    vec3 v = vec3(p[0],p[1],p[2]);\n    vec3 u = vec3(v[1],v[2],v[0]);\n    vec3 w = vec3(v[2],v[0],v[1]);\n    n = cross(u,w);\n    n = normalize(n);\n    return n;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec", "\n    float t = t0 + (t1 - t0) * (ray.direction.dot(ro - rd) / ray.direction.dot(rd - ro));\n    return t;\n}\n\n// NOTE: This function is only used for the shadow calculation.\n//       It is not used for the ray tracing.\n//       The ray tracing is done in the ray_trace function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The ray_trace function is called in the main function.\n//       The", "\n    float ao = 0.0;\n    float ao2 = 0.0;\n    float ao3 = 0.0;\n    float ao4 = 0.0;\n    float ao5 = 0.0;\n    float ao6 = 0.0;\n    float ao7 = 0.0;\n    float ao8 = 0.0;\n    float ao9 = 0.0;\n    float ao10 = 0.0;\n    float ao11 = 0.0;\n    float ao12 = 0.0;\n    float ao13 = 0.0;\n    float ao14 = 0.0;\n    float ao15 = 0.0;\n    float ao16 = 0.0;\n    float ao17 = 0.0;\n    float ao18 = 0.0;\n    float ao19 = 0.0;\n    float ao20 = 0.0;\n    float ao21 = 0.0;\n    float ao22 = 0.0;\n    float ao23 = 0.0;\n    float ao24 = 0.0;\n    float ao25 = 0.0;\n    float ao26 = 0.0;\n    float ao27 = 0.0;\n    float ao28 = 0.0;\n    float ao29 = 0.0;\n    float ao30 = 0.0;\n    float ao31 = 0.0;\n    float ao32 = 0.0;\n    float ao33 = 0.0;\n    float ao34 = 0.0;\n    float ao35 = 0.0;\n    float ao36 = 0.0;\n    float ao37 = 0.0;\n    float ao38 = 0.0;\n    float ao39 = 0.0;\n    float ao40 = 0.0;\n    float ao41 = 0.0;\n    float ao42 = 0.0;\n    float ao43 = 0.0;\n    float ao44 = 0.0;\n    float ao45 = 0.0;\n    float ao46 = 0.0;\n    float ao47 =", "\n    float cosA = cosf(angle);\n    float sinA = sinf(angle);\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    float a = cosA;\n    float b = sinA;\n    float c = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float s = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x1 = x * x;\n    float y1 = y * y;\n    float z1 = z * z;\n    float x2 = x * y;\n    float y2 = y * z;\n    float z2 = z * x;\n    float x3 = x * z;\n    float y3 = y * x;\n    float z3 = z * y;\n    float x4 = x * x1;\n    float y4 = y * y1;\n    float z4 = z * z1;\n    float x5 = x * x2;\n    float y5 = y * y2;\n    float z5 = z * z2;\n    float x6 = x * x3;\n    float y6 = y * y3;\n    float z6 = z * z3;\n    float x7 = x * x4;\n    float y7 = y * y4;\n    float z7 = z * z4;\n    float x8 = x * x5;\n    float y", "\n    vec2 uv = vec2(fragCoord.x, fragCoord.y);\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the camera to the mouse\nvec", "\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat", "\n    float r = rand() / (float)RAND_MAX;\n    vec3 r3d = vec3(r, r, r);\n    return p + r3d;\n}\n\n// Hash for 4d vectors\nfloat", "\n    float x2 = x.x*x.x;\n    float x3 = x.x*x2;\n    float x4 = x.x*x3;\n    float x5 = x.x*x4;\n    float x6 = x.x*x5;\n    float x7 = x.x*x6;\n    float x8 = x.x*x7;\n    float x9 = x.x*x8;\n    float x10 = x.x*x9;\n    float x11 = x.x*x10;\n    float x12 = x.x*x11;\n    float x13 = x.x*x12;\n    float x14 = x.x*x13;\n    float x15 = x.x*x14;\n    float x16 = x.x*x15;\n    float x17 = x.x*x16;\n    float x18 = x.x*x17;\n    float x19 = x.x*x18;\n    float x20 = x.x*x19;\n    float x21 = x.x*x20;\n    float x22 = x.x*x21;\n    float x23 = x.x*x22;\n    float x24 = x.x*x23;\n    float x25 = x.x*x24;\n    float x26 = x.x*x25;\n    float x27 = x.x*x26;\n    float x28 = x.x*x27;\n    float x29 = x.x*x28;\n    float x30 = x.x*x29;\n    float x31 = x.x*x30;\n    float x32 = x.x*x31;\n    float x33 = x.x*x32;\n    float x34 = x.x*x33;\n    float x35 = x.x*x34;\n    float x36 = x.x*x35;\n    float x37 = x.x*x36;\n    float x38 = x.x*x37;\n    float x39 = x.x*x38;\n    float x40 = x.x*x39;\n    float x", "\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n    float xy = x*y;\n    float xz = x*z;\n    float yz = y*z;\n    float x2y2 = x2*y2;\n    float x2z2 = x2*z2;\n    float y2z2 = y2*z2;\n    float xyz = xy*z;\n    float x2yz2 = x2y2*z;\n    float y2xz2 = y2z2*x;\n    float y2xy2 = y2xy*x;\n    float x2y2z = x2y2*z;\n    float x2yz2 = x2yz*z;\n    float x2y2x = x2y2*x;\n    float x2y2y = x2y2*y;\n    float x2y2z = x2y2*z;\n    float x2y2xz = x2y2*xz;\n    float x2y2xy = x2y2*xy;\n    float x2y2xz2 = x2y2*x2z2;\n    float x2y2xy2 = x2y2*x2xy2;\n    float x2y2x2z = x2y2*x2z2;\n    float x2y2xy2z = x2y2*x2xy2*z;\n    float x2y2x2xy = x2y2*x2xy*x;\n    float x2y2x2xz = x2y2*x2xz*x;\n    float x2y2x2xy2 = x2y2*x2xy2*x;\n    float x2y2x2x2z = x2y2*x2x2z*x;\n    float x2y2x2x2xy = x2y2*x2x2xy*x;\n    float x2y2x", "\n    vec3 r = p - vec3(0.5, 0.5, 0.5);\n    float r2 = r.x*r.x + r.y*r.y + r.z*r.z;\n    float r3 = r2*r2;\n    float r4 = r3*r2;\n    float r5 = r4*r2;\n    float r6 = r5*r2;\n    float r7 = r6*r2;\n    float r8 = r7*r2;\n    float r9 = r8*r2;\n    float r10 = r9*r2;\n    float r11 = r10*r2;\n    float r12 = r11*r2;\n    float r13 = r12*r2;\n    float r14 = r13*r2;\n    float r15 = r14*r2;\n    float r16 = r15*r2;\n    float r17 = r16*r2;\n    float r18 = r17*r2;\n    float r19 = r18*r2;\n    float r20 = r19*r2;\n    float r21 = r20*r2;\n    float r22 = r21*r2;\n    float r23 = r22*r2;\n    float r24 = r23*r2;\n    float r25 = r24*r2;\n    float r26 = r25*r2;\n    float r27 = r26*r2;\n    float r28 = r27*r2;\n    float r29 = r28*r2;\n    float r30 = r29*r2;\n    float r31 = r30*r2;\n    float r32 = r31*r2;\n    float r33 = r32*r2;\n    float r34 = r33*r2;\n    float r35 = r34*r2;\n    float r36 = r35*r2;\n    float r37 = r36*r2;\n    float r38 = r37*r2;\n    float r39 = r38*r2;\n    float r40 = r39*r2;\n    float", "\n    vec3 cloud = pos;\n    vec3 cloudColor = vec3(0.0,0.0,0.0);\n    vec3 cloudDensity = vec3(0.0,0.0,0.0);\n    for(int i=0;i<clouds.size();i++){\n        vec3 cloud2 = clouds[i];\n        float d = dot(cloud2-cloud,cloud2-cloud);\n        if(d<0.0){\n            float r = sqrt(d);\n            float c = (r-1.0)/r;\n            float c2 = c*c;\n            float c3 = c2*c;\n            float c4 = c3*c;\n            float c5 = c4*c;\n            float c6 = c5*c;\n            float c7 = c6*c;\n            float c8 = c7*c;\n            float c9 = c8*c;\n            float c10 = c9*c;\n            float c11 = c10*c;\n            float c12 = c11*c;\n            float c13 = c12*c;\n            float c14 = c13*c;\n            float c15 = c14*c;\n            float c16 = c15*c;\n            float c17 = c16*c;\n            float c18 = c17*c;\n            float c19 = c18*c;\n            float c20 = c19*c;\n            float c21 = c20*c;\n            float c22 = c21*c;\n            float c23 = c22*c;\n            float c24 = c23*c;\n            float c25 = c24*c;\n            float c26 = c25*c;\n            float c27 = c26*c;\n            float c28 = c27*c;\n            float c29 = c28*c;\n            float c30 = c29*c;\n            float c31 = c30*c;\n            float c32 = c31*c;\n            float c33 = c32*c;\n            float c34 = c33*c;\n            float c35 = c34*c;\n            float c36", "\n    vec3 ground = vec3(0.0, 0.0, 0.0);\n    vec3 shadow = vec3(0.0, 0.0, 0.0);\n    vec3 light = vec3(1.0, 1.0, 1.0);\n    vec3 sun = vec3(1.0, 1.0, 1.0);\n    vec3 sunDir = normalize(sun - point);\n    vec3 sunDir2 = normalize(sunDir);\n    vec3 sunDir3 = normalize(cross(sunDir, sunDir2));\n    vec3 sunDir4 = normalize(cross(sunDir, sunDir3));\n    vec3 sunDir5 = normalize(cross(sunDir, sunDir4));\n    vec3 sunDir6 = normalize(cross(sunDir, sunDir5));\n    vec3 sunDir7 = normalize(cross(sunDir, sunDir6));\n    vec3 sunDir8 = normalize(cross(sunDir, sunDir7));\n    vec3 sunDir9 = normalize(cross(sunDir, sunDir8));\n    vec3 sunDir10 = normalize(cross(sunDir, sunDir9));\n    vec3 sunDir11 = normalize(cross(sunDir, sunDir10));\n    vec3 sunDir12 = normalize(cross(sunDir, sunDir11));\n    vec3 sunDir13 = normalize(cross(sunDir, sunDir12));\n    vec3 sunDir14 = normalize(cross(sunDir, sunDir13));\n    vec3 sunDir15 = normalize(cross(sunDir, sunDir14));\n    vec3 sunDir16 = normalize(cross(sunDir, sunDir15));\n    vec3 sunDir17 = normalize(cross(sunDir, sunDir16));\n    vec3 sunDir18 = normalize(cross(sunDir, sunDir17));\n    vec3 sunDir19 = normalize(cross(sunDir, sunDir18));\n    vec3 sunDir20 = normalize(cross(sunDir, sunDir19));\n    vec3 sunDir21 = normalize(cross(sunDir, sunDir20));\n    vec3 sunDir22 = normalize(cross(sunDir, sunDir21));", "\n    vec3 point = pointStart + vec3(dist, 0, 0);\n    vec3 pointEnd = pointEnd + vec3(dist, 0, 0);\n    vec3 fog = fogLight(point, pointEnd, dist, random);\n    vec3 fogLight = vec3(0, 0, 0);\n    vec3 fogLight = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog = vec3(0, 0, 0);\n    vec3 fog", "\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    vec3 h = vec3(0.0, 0.0, 0.0);\n    vec3 i = vec3(0.0, 0.0, 0.0);\n    vec3 j = vec3(0.0, 0.0, 0.0);\n    vec3 k = vec3(0.0, 0.0, 0.0);\n    vec3 l = vec3(0.0, 0.0, 0.0);\n    vec3 m = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0);\n    vec3 y = vec3"]}