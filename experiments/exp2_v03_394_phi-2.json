{"generations": ["    // s = (x,y,z)\n    float x = s.x;\n    float y = s.y;\n    float z = s.z;\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n    float xy = x*y;\n    float xz = x*z;\n    float yz = y*z;\n    float xy2 = xy*xy;\n    float xyz = xy*z;\n    float yz2 = yz*yz;\n    float xyz2 = xyz*xy;\n    float xyz3 = xyz*z;\n    float xyz4 = xyz*xy;\n    float xyz5 = xyz*z2;\n    float xyz6 = xyz*xy2;\n    float xyz7 = xyz*xy3;\n    float xyz8 = xyz*xy4;\n    float xyz9 = xyz*xy5;\n    float xyz10 = xyz*xy6;\n    float xyz11 = xyz*xy7;\n    float xyz12 = xyz*xy8;\n    float xyz13 = xyz*xy9;\n    float xyz14 = xyz*xy10;\n    float xyz15 = xyz*xy11;\n    float xyz16 = xyz*xy12;\n    float xyz17 = xyz*xy13;\n    float xyz18 = xyz*xy14;\n    float xyz19 = xyz*xy15;\n    float xyz20 = xyz*xy16;\n    float xyz21 = xyz*xy17;\n    float xyz22 = xyz*xy18;\n    float xyz23 = xyz*xy19;\n    float xyz24 = xyz*xy20;\n    float xyz25 = xyz*xy21;\n    float xyz26 = xyz*xy22;\n    float xyz27 = xyz*xy23;\n    float xyz28 = xyz*xy24;\n    float xyz29 = xyz*xy25;\n    float xyz30 = xyz*xy26;\n    float xyz", "\n    return abs( (b.y - a.y) * p.x - (b.x - a.x) * p.y + b.x * a.y - b.y * a.x ) / ( (b.y - a.y) * (b.x - a.x) );\n}\n\n// distance to a point\nfloat point( in vec2 p )\n{\n    return sqrt( p.x * p.x + p.y * p.y );\n}\n\n// distance to a line segment\nfloat line_segment( in vec2 a, in vec2 b, in vec2 p )\n{\n    float d = line( a, b, p );\n    if( d < 0 )\n        return 0;\n    if( d > 1 )\n        return distance( p, b );\n    return distance( p, a );\n}\n\n// distance to a line\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    return abs( (b.y - a.y) * p.x - (b.x - a.x) * p.y + b.x * a.y - b.y * a.x ) / ( (b.y - a.y) * (b.x - a.x) );\n}\n\n// distance to a point\nfloat point( in vec2 p )\n{\n    return sqrt( p.x * p.x + p.y * p.y );\n}\n\n// distance to a line segment\nfloat line_segment( in vec2 a, in vec2 b, in vec2 p )\n{\n    float d = line( a, b, p );\n    if( d < 0 )\n        return 0;\n    if( d > 1 )\n        return distance( p, b );\n    return distance( p, a );\n}\n\n// distance to a line\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    return abs( (b.y - a.y) * p.x - (b.x - a.x) * p.y + b.x * a.y - b.y * a.x ) / ( (b.", "\n    vec2 w = v - r;\n    return w.x * w.x + w.y * w.y > 1.0? -w : w;\n}\n\n// Compute the distance from a point to a line\nfloat distanceToLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 d = p - a;\n    vec2 n = b - a;\n    return abs( dot( n, d ) / ( dot( n, n ) ) );\n}\n\n// Compute the distance from a point to a plane\nfloat distanceToPlane( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 d = p - a;\n    return abs( dot( d, c ) / ( dot( c, c ) ) );\n}\n\n// Compute the distance from a point to a sphere\nfloat distanceToSphere( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 d = p - a;\n    return abs( dot( d, c ) / ( dot( c, c ) ) );\n}\n\n// Compute the distance from a point to a line segment\nfloat distanceToLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = distanceToLine( p, a, b );\n    if( d < 0.0 )\n        return 0.0;\n    if( d > 1.0 )\n        return 1.0;\n    return d;\n}\n\n// Compute the distance from a point to a plane\nfloat distanceToPlane( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 d = p - a;\n    return abs( dot( d, c ) / ( dot( c, c ) ) );\n}\n\n// Compute the distance from a point to a sphere\nfloat distanceToSphere( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 d = p - a;\n    return abs( dot( d, c ) / ( dot( c, c ) ) );\n}", "    \n    vec2 r2 = r.xy;\n    vec2 r3 = r.xyz;\n    vec2 r4 = r.xyzw;\n    vec2 r5 = r.xyzw.xyzw;\n    vec2 r6 = r.xyzw.xyzw.xyzw;\n    vec2 r7 = r.xyzw.xyzw.xyzw.xyzw;\n    vec2 r8 = r.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r9 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r10 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r11 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r12 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r13 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r14 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r15 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r16 = r.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw.xyzw;\n    vec2 r17 =", "\n    return v.x < 0.0? vec2(0.0, v.y) : v;\n}\n\n// Compute the distance from the origin to the point\nvec2 distance( in vec2 p )\n{\n    return p.x * p.x + p.y * p.y;\n}\n\n// Compute the distance from the origin to the line defined by p1 and p2\nvec2 distanceToLine( in vec2 p1, in vec2 p2 )\n{\n    vec2 d = p2 - p1;\n    return abs( d.x * d.x + d.y * d.y ) / sqrt( d.x * d.x + d.y * d.y );\n}\n\n// Compute the distance from the origin to the plane defined by p1, p2 and p3\nvec2 distanceToPlane( in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 d = p2 - p1;\n    vec2 e = p3 - p1;\n    return abs( d.x * e.x + d.y * e.y ) / sqrt( d.x * d.x + d.y * d.y );\n}\n\n// Compute the distance from the origin to the point on the line defined by p1 and p2\nvec2 distanceToLinePoint( in vec2 p1, in vec2 p2, in vec2 p )\n{\n    vec2 d = p2 - p1;\n    return abs( d.x * (p.x - p1.x) + d.y * (p.y - p1.y) ) / sqrt( d.x * d.x + d.y * d.y );\n}\n\n// Compute the distance from the origin to the point on the plane defined by p1, p2 and p3\nvec2 distanceToPlanePoint( in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n    vec2 d = p2 - p1;\n    vec2 e = p3 - p1;\n    return abs( d.x * (p.x - p1.x) + d.", "QVector3d p1, p2, p3, p4;\n    p1 = p + a;\n    p2 = p + b;\n    p3 = p1 + w1 * (p2 - p1);\n    p4 = p2 + w2 * (p3 - p2);\n    return p4;\n}\n\n// https://www.shadertoy.com/view/sj3Ddv\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{QVector3d p1, p2, p3, p4;\n    p1 = p + a;\n    p2 = p + b;\n    p3 = p1 + w1 * (p2 - p1);\n    p4 = p2 + w2 * (p3 - p2);\n    return p4;\n}\n\n// https://www.shadertoy.com/view/sj3Ddv\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{QVector3d p1, p2, p3, p4;\n    p1 = p + a;\n    p2 = p + b;\n    p3 = p1 + w1 * (p2 - p1);\n    p4 = p2 + w2 * (p3 - p2);\n    return p4;\n}\n\n// https://www.shadertoy.com/view/sj3Ddv\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{QVector3d p1, p2, p3, p4;\n    p1 = p + a;\n    p2 = p + b;\n    p3 = p1 + w1 * (p2 - p1);\n    p4 = p2 + w2 * (p3 - p2);\n    return p4;\n}\n\n// https://www.shadertoy.com/view/sj3Ddv\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w", "#include \"sun.h\"\n    vec3 sunCol = sunDir;\n    vec3 sunDir = normalize(sunDir);\n    vec3 rayDir = normalize(rayDir);\n    vec3 sunDirRef = normalize(cross(rayDir, sunDir));\n    vec3 sunDirRef2 = normalize(cross(sunDir, sunDirRef));\n    vec3 sunDirRef3 = normalize(cross(sunDirRef, sunDirRef2));\n    vec3 sunDirRef4 = normalize(cross(sunDirRef2, sunDirRef3));\n    vec3 sunDirRef5 = normalize(cross(sunDirRef3, sunDirRef4));\n    vec3 sunDirRef6 = normalize(cross(sunDirRef4, sunDirRef5));\n    vec3 sunDirRef7 = normalize(cross(sunDirRef5, sunDirRef6));\n    vec3 sunDirRef8 = normalize(cross(sunDirRef6, sunDirRef7));\n    vec3 sunDirRef9 = normalize(cross(sunDirRef7, sunDirRef8));\n    vec3 sunDirRef10 = normalize(cross(sunDirRef8, sunDirRef9));\n    vec3 sunDirRef11 = normalize(cross(sunDirRef9, sunDirRef10));\n    vec3 sunDirRef12 = normalize(cross(sunDirRef10, sunDirRef11));\n    vec3 sunDirRef13 = normalize(cross(sunDirRef11, sunDirRef12));\n    vec3 sunDirRef14 = normalize(cross(sunDirRef12, sunDirRef13));\n    vec3 sunDirRef15 = normalize(cross(sunDirRef13, sunDirRef14));\n    vec3 sunDirRef16 = normalize(cross(sunDirRef14, sunDirRef15));\n    vec3 sunDirRef17 = normalize(cross(sunDirRef15, sunDirRef16));\n    vec3 sunDirRef18 = normalize(cross(sunDirRef16, sunDirRef17));\n    vec3 sunDirRef19 = normalize(cross(sunDirRef17, sunDirRef18));\n    vec3 sunDirRef20 = normalize(cross(sunDirRef18, sunDirRef", "#\n    vec4 p = p0 + t * (p1 - p0) + t * t * (p2 - 2 * p0 + p1) + t * t * t * (p3 - 3 * p0 + 3 * p1 - p2);\n    return p;\n}\n\n#define CURVE_LENGTH_PX 100\n#define CURVE_LENGTH_TOLERANCE 0.1\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{#\n    vec4 p = p0 + t * (p1 - p0) + t * t * (p2 - 2 * p0 + p1) + t * t * t * (p3 - 3 * p0 + 3 * p1 - p2);\n    return p;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{#\n    vec4 p = p0 + t * (p1 - p0) + t * t * (p2 - 2 * p0 + p1) + t * t * t * (p3 - 3 * p0 + 3 * p1 - p2);\n    return p;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{#\n    vec4 p = p0 + t * (p1 - p0) + t * t * (p2 - 2 * p0 + p1) + t * t * t * (p3 - 3 * p0 + 3 * p1 - p2);\n    return p;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{#\n    vec4 p = p0 + t * (p1 - p0) + t * t * (p2 - 2", "#define PI 3.1415926535897932384626433832795\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat r = sqrt(x*x + y*y);\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31*r;\n\tfloat r33 = r32*r;\n\tfloat r34 = r33*r;\n\tfloat r35 = r34*r;\n\tfloat r36 = r35*r;\n\tfloat r37 = r36*r;\n\tfloat r38 = r37*r;\n\tfloat r39 = r38*r;\n\tfloat r40 = r39*r;\n\tfloat r41 = r40*r;\n\tfloat r42 = r41*r;\n", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec4 camPos = vec4(0.0, 0.0, 0.0, 1.0);\n    float t0 = t;\n    t = t0 - 0.5f;\n    vec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4", "\n    return u * 0.1f;\n}\n\nfloat Hash2d(float u, float v)\n{\n    return u * 0.1f + v * 0.1f;\n}\n\nfloat Hash3d(float u, float v, float w)\n{\n    return u * 0.1f + v * 0.1f + w * 0.1f;\n}\n\nfloat Hash4d(float u, float v, float w, float x)\n{\n    return u * 0.1f + v * 0.1f + w * 0.1f + x * 0.1f;\n}\n\nfloat Hash5d(float u, float v, float w, float x, float y)\n{\n    return u * 0.1f + v * 0.1f + w * 0.1f + x * 0.1f + y * 0.1f;\n}\n\nfloat Hash6d(float u, float v, float w, float x, float y, float z)\n{\n    return u * 0.1f + v * 0.1f + w * 0.1f + x * 0.1f + y * 0.1f + z * 0.1f;\n}\n\nfloat Hash7d(float u, float v, float w, float x, float y, float z, float t)\n{\n    return u * 0.1f + v * 0.1f + w * 0.1f + x * 0.1f + y * 0.1f + z * 0.1f + t * 0.1f;\n}\n\nfloat Hash8d(float u, float v, float w, float x, float y, float z, float t, float p)\n{\n    return u * 0.1f + v * 0.1f + w * 0.1f + x * 0.1f + y * 0.1f + z * 0.1f + t * 0.1f + p * 0.1f;\n}\n\nfloat Hash9d(float u, float v, float w, float x, float y, float z, float t, float p, float q)\n{\n    return u * 0.1f + v * 0.1f", "#include \"noise.h\"\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat r = sqrt(x*x + y*y + z*z);\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31*r;\n\tfloat r33 = r32*r;\n\tfloat r34 = r33*r;\n\tfloat r35 = r34*r;\n\tfloat r36 = r35*r;\n\tfloat r37 = r36*r;\n\tfloat r38 = r37*r;\n\tfloat r39 = r38*r;\n\tfloat r40 = r39*r;\n\tfloat r41 = r40*r;\n\tfloat r42 = r41*r;\n\tfloat r43 = r", "\n    // This is the distance function that calculates the distance between two points\n    float distance = sqrt(pow(p.x - center.x, 2) + pow(p.y - center.y, 2) + pow(p.z - center.z, 2));\n    return distance;\n}\n\n// This is the function that draws the fractal\nvoid draw()\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -5.0);\n    glRotatef(angle, 0.0, 0.0, 1.0);\n    glBegin(GL_TRIANGLES);\n    for (int i = 0; i < numVertices; i++)\n    {\n        glVertex3fv(vertices[i]);\n    }\n    glEnd();\n    glutSwapBuffers();\n}\n\n// This is the main function that runs the program\nint main()\n{\n    glutInit(sys.argv);\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutCreateWindow(\"Fractal\");\n    glutDisplayFunc(draw);\n    glutIdleFunc(draw);\n    glutMainLoop();\n    return 0;\n}\n```\n\nThis code creates a fractal shape using the turtle graphics library. The fractal is created by drawing triangles with increasing size and complexity. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles. The fractal is created by using a recursive function that calls itself to draw smaller triangles", "#include \"light.h\"\n    vec3 ambient = vec3(0.2, 0.2, 0.2);\n    vec3 diffuse = vec3(0.8, 0.8, 0.8);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    vec3 ambientLight = ambient;\n    vec3 diffuseLight = diffuse;\n    vec3 specularLight = specular;\n    vec3 ambientLightDir = normalize(sunDir - ambient);\n    vec3 diffuseLightDir = normalize(sunDir - diffuse);\n    vec3 specularLightDir = normalize(sunDir - specular);\n    vec3 ambientLightDir2 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir2 = normalize(rayDir - diffuse);\n    vec3 specularLightDir2 = normalize(rayDir - specular);\n    vec3 ambientLightDir3 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir3 = normalize(rayDir - diffuse);\n    vec3 specularLightDir3 = normalize(rayDir - specular);\n    vec3 ambientLightDir4 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir4 = normalize(rayDir - diffuse);\n    vec3 specularLightDir4 = normalize(rayDir - specular);\n    vec3 ambientLightDir5 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir5 = normalize(rayDir - diffuse);\n    vec3 specularLightDir5 = normalize(rayDir - specular);\n    vec3 ambientLightDir6 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir6 = normalize(rayDir - diffuse);\n    vec3 specularLightDir6 = normalize(rayDir - specular);\n    vec3 ambientLightDir7 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir7 = normalize(rayDir - diffuse);\n    vec3 specularLightDir7 = normalize(rayDir - specular);\n    vec3 ambientLightDir8 = normalize(rayDir - ambient);\n    vec3 diffuseLightDir8 = normalize(rayDir - diffuse);\n    vec3 specularLightDir8 =", "#ifdef DEBUG\n    printf( \"smin(%f, %f, %f) = %f\\n\", a, b, k, (a-b)/k );\n#endif\n    return (a-b)/k;\n}\n\n#ifdef DEBUG\n#define SMIN(a,b,k) (a-b)/k\n#else\n#define SMIN(a,b,k) (a-b)/k\n#endif\n\n#ifdef DEBUG\n#define SMIN_MAX(a,b,k) SMIN(a,b,k)\n#else\n#define SMIN_MAX(a,b,k) SMIN(a,b,k)\n#endif\n\n#ifdef DEBUG\n#define SMIN_MIN(a,b,k) SMIN(b,a,k)\n#else\n#define SMIN_MIN(a,b,k) SMIN(b,a,k)\n#endif\n\n#ifdef DEBUG\n#define SMIN_MAX_MIN(a,b,k) SMIN_MAX(a,b,k)\n#else\n#define SMIN_MAX_MIN(a,b,k) SMIN_MAX(a,b,k)\n#endif\n\n#ifdef DEBUG\n#define SMIN_MIN_MAX(a,b,k) SMIN_MIN(a,b,k)\n#else\n#define SMIN_MIN_MAX(a,b,k) SMIN_MIN(a,b,k)\n#endif\n\n#ifdef DEBUG\n#define SMIN_MAX_MIN_MAX(a,b,k) SMIN_MAX_MIN(a,b,k)\n#else\n#define SMIN_MAX_MIN_MAX(a,b,k) SMIN_MAX_MIN(a,b,k)\n#endif\n\n#ifdef DEBUG\n#define SMIN_MIN_MAX_MIN(a,b,k) SMIN_MIN_MAX(a,b,k)\n#else\n#define SMIN_MIN_MAX_MIN(a,b,k) SMIN_MIN_MAX(a,b,k)\n#endif\n\n#ifdef DEBUG\n#define SMIN_MAX", "\n    // dirVec MUST BE NORMALIZED FIRST!!!!\n    float d = dot(pos - spherePos, dirVecPLZNormalizeMeFirst);\n    if (d > 1.0f)\n        return 0.0f;\n    if (d < -1.0f)\n        return 0.0f;\n    float r = pow(d, 2.0f) - rad * rad;\n    if (r < 0.0f)\n        return 0.0f;\n    return pow(r, -1.0f);\n}\n\n// Returns the intersection point of the ray with the sphere.\n// If the ray does not intersect the sphere, returns the closest point on the ray to the sphere.\n// If the ray is parallel to the sphere, returns the closest point on the ray to the sphere.\n// If the ray is outside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is inside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is parallel to the sphere, returns the closest point on the ray to the sphere.\n// If the ray is outside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is inside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is parallel to the sphere, returns the closest point on the ray to the sphere.\n// If the ray is outside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is inside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is parallel to the sphere, returns the closest point on the ray to the sphere.\n// If the ray is outside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is inside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is parallel to the sphere, returns the closest point on the ray to the sphere.\n// If the ray is outside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is inside the sphere, returns the closest point on the ray to the sphere.\n// If the ray is parallel to the sphere, returns the closest point on the ray to the sphere.\n// If the ray is", "The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance field is the distance from the origin to the object.\n    return (p - origin).length();\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{The distance", "    \n    vec3 p = vec3(0.0f, 0.0f, 0.0f);\n    vec3 q = vec3(1.0f, 0.0f, 0.0f);\n    vec3 r = vec3(0.0f, 1.0f, 0.0f);\n    vec3 s = vec3(0.0f, 0.0f, 1.0f);\n    vec3 t0 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t1 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t2 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t3 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t4 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t5 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t6 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t7 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t8 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t9 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t10 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t11 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t12 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t13 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t14 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t15 = vec3(0.0f, 0.0f, 0.0f);\n    vec3 t16 = vec3(0.0f,", "    \n    vec3 d1 = vec3(0.0, 0.0, 0.0);\n    vec3 d2 = vec3(0.0, 0.0, 0.0);\n    vec3 d3 = vec3(0.0, 0.0, 0.0);\n    vec3 d4 = vec3(0.0, 0.0, 0.0);\n    vec3 d5 = vec3(0.0, 0.0, 0.0);\n    vec3 d6 = vec3(0.0, 0.0, 0.0);\n    vec3 d7 = vec3(0.0, 0.0, 0.0);\n    vec3 d8 = vec3(0.0, 0.0, 0.0);\n    vec3 d9 = vec3(0.0, 0.0, 0.0);\n    vec3 d10 = vec3(0.0, 0.0, 0.0);\n    vec3 d11 = vec3(0.0, 0.0, 0.0);\n    vec3 d12 = vec3(0.0, 0.0, 0.0);\n    vec3 d13 = vec3(0.0, 0.0, 0.0);\n    vec3 d14 = vec3(0.0, 0.0, 0.0);\n    vec3 d15 = vec3(0.0, 0.0, 0.0);\n    vec3 d16 = vec3(0.0, 0.0, 0.0);\n    vec3 d17 = vec3(0.0, 0.0, 0.0);\n    vec3 d18 = vec3(0.0, 0.0, 0.0);\n    vec3 d19 = vec3(0.0, 0.0, 0.0);\n    vec3 d20 = vec3(0.0, 0.0, 0.0);\n    vec3 d21 = vec3(0.0, 0.0, 0.0);\n    vec3 d22 = vec3(0.0, 0.0, 0.0);\n    vec3 d23 = vec3(0.0, 0.0, 0.0);\n    vec3 d", "\n    return vec3(t*t*t, t*t, t);\n}\n\n// curve third derivative (deceleration)\nvec3 mapD3(float t)\n{\n    return vec3(t*t*t*t, t*t*t, t*t);\n}\n\n// curve fourth derivative (deceleration)\nvec3 mapD4(float t)\n{\n    return vec3(t*t*t*t*t, t*t*t*t, t*t*t);\n}\n\n// curve fifth derivative (deceleration)\nvec3 mapD5(float t)\n{\n    return vec3(t*t*t*t*t*t, t*t*t*t*t, t*t*t*t);\n}\n\n// curve sixth derivative (deceleration)\nvec3 mapD6(float t)\n{\n    return vec3(t*t*t*t*t*t*t, t*t*t*t*t*t, t*t*t*t*t);\n}\n\n// curve seventh derivative (deceleration)\nvec3 mapD7(float t)\n{\n    return vec3(t*t*t*t*t*t*t*t, t*t*t*t*t*t*t, t*t*t*t*t*t);\n}\n\n// curve eighth derivative (deceleration)\nvec3 mapD8(float t)\n{\n    return vec3(t*t*t*t*t*t*t*t*t, t*t*t*t*t*t*t*t, t*t*t*t*t*t*t);\n}\n\n// curve ninth derivative (deceleration)\nvec3 mapD9(float t)\n{\n    return vec3(t*t*t*t*t*t*t*t*t*t, t*t*t*t*t*t*t*t*t, t*t*t*t*t*t*t);\n}\n\n// curve tenth derivative (deceleration)\nvec3 mapD10(float t)\n{\n    ", "\n    vec3 pb = b - a;\n    vec3 pa = p - a;\n    vec3 pa2 = pa * pa;\n    vec3 pa3 = pa2 * pa;\n    vec3 pa4 = pa3 * pa;\n    vec3 pa5 = pa4 * pa;\n    vec3 pa6 = pa5 * pa;\n    vec3 pa7 = pa6 * pa;\n    vec3 pa8 = pa7 * pa;\n    vec3 pa9 = pa8 * pa;\n    vec3 pa10 = pa9 * pa;\n    vec3 pa11 = pa10 * pa;\n    vec3 pa12 = pa11 * pa;\n    vec3 pa13 = pa12 * pa;\n    vec3 pa14 = pa13 * pa;\n    vec3 pa15 = pa14 * pa;\n    vec3 pa16 = pa15 * pa;\n    vec3 pa17 = pa16 * pa;\n    vec3 pa18 = pa17 * pa;\n    vec3 pa19 = pa18 * pa;\n    vec3 pa20 = pa19 * pa;\n    vec3 pa21 = pa20 * pa;\n    vec3 pa22 = pa21 * pa;\n    vec3 pa23 = pa22 * pa;\n    vec3 pa24 = pa23 * pa;\n    vec3 pa25 = pa24 * pa;\n    vec3 pa26 = pa25 * pa;\n    vec3 pa27 = pa26 * pa;\n    vec3 pa28 = pa27 * pa;\n    vec3 pa29 = pa28 * pa;\n    vec3 pa30 = pa29 * pa;\n    vec3 pa31 = pa30 * pa;\n    vec3 pa32 = pa31 * pa;\n    vec3 pa33 = pa32 * pa;\n    vec3 pa34 = pa33 * pa;\n    vec3 pa35 = pa34 * pa;\n    vec3 pa36 = pa35 * pa;\n    vec3 pa37 = pa36 * pa;\n    vec3 pa38 = pa37 * pa;\n    vec3 pa39 = pa38 * pa;\n    vec3 pa40 = pa39 * pa;\n    vec3 pa41 = pa40 * pa;\n    vec3 pa42 = pa41 * pa;", "\n    vec3 dv = b - a;\n    vec3 d = dv * dv;\n    vec3 dv = o - a;\n    vec3 dv2 = dv * dv;\n    vec3 dv3 = dv2 * dv;\n    vec3 dv4 = dv3 * dv;\n    vec3 dv5 = dv4 * dv;\n    vec3 dv6 = dv5 * dv;\n    vec3 dv7 = dv6 * dv;\n    vec3 dv8 = dv7 * dv;\n    vec3 dv9 = dv8 * dv;\n    vec3 dv10 = dv9 * dv;\n    vec3 dv11 = dv10 * dv;\n    vec3 dv12 = dv11 * dv;\n    vec3 dv13 = dv12 * dv;\n    vec3 dv14 = dv13 * dv;\n    vec3 dv15 = dv14 * dv;\n    vec3 dv16 = dv15 * dv;\n    vec3 dv17 = dv16 * dv;\n    vec3 dv18 = dv17 * dv;\n    vec3 dv19 = dv18 * dv;\n    vec3 dv20 = dv19 * dv;\n    vec3 dv21 = dv20 * dv;\n    vec3 dv22 = dv21 * dv;\n    vec3 dv23 = dv22 * dv;\n    vec3 dv24 = dv23 * dv;\n    vec3 dv25 = dv24 * dv;\n    vec3 dv26 = dv25 * dv;\n    vec3 dv27 = dv26 * dv;\n    vec3 dv28 = dv27 * dv;\n    vec3 dv29 = dv28 * dv;\n    vec3 dv30 = dv29 * dv;\n    vec3 dv31 = dv30 * dv;\n    vec3 dv32 = dv31 * dv;\n    vec3 dv33 = dv32 * dv", "\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float rx = r.x;\n    float ry = r.y;\n    float rz = r.z;\n    float rw = r.w;\n    float sx = x * x;\n    float sy = y * y;\n    float sz = rz * rz;\n    float sw = rw * rw;\n    float s = sx + sy + sz + sw;\n    float r = sqrt(s);\n    float rr = r * r;\n    float rr2 = rr * rr;\n    float rr3 = rr2 * rr;\n    float rr4 = rr3 * rr;\n    float rr5 = rr4 * rr;\n    float rr6 = rr5 * rr;\n    float rr7 = rr6 * rr;\n    float rr8 = rr7 * rr;\n    float rr9 = rr8 * rr;\n    float rr10 = rr9 * rr;\n    float rr11 = rr10 * rr;\n    float rr12 = rr11 * rr;\n    float rr13 = rr12 * rr;\n    float rr14 = rr13 * rr;\n    float rr15 = rr14 * rr;\n    float rr16 = rr15 * rr;\n    float rr17 = rr16 * rr;\n    float rr18 = rr17 * rr;\n    float rr19 = rr18 * rr;\n    float rr20 = rr19 * rr;\n    float rr21 = rr20 * rr;\n    float rr22 = rr21 * rr;\n    float rr23 = rr22 * rr;\n    float rr24 = rr23 * rr;\n    float rr25 = rr24 * rr;\n    float rr26 = rr25 * rr;\n    float rr27 = rr26 * rr;\n    float rr28", "#\n    // This function calculates the reflection of a ray of light off of a surface.\n    // rayDir is the direction of the ray, and sunDir is the direction of the sun.\n    // The function returns the color of the reflected ray.\n    // The rayDir and sunDir are in the range of -1.0 to 1.0.\n    // The sunCol is in the range of 0.0 to 1.0.\n    // The sunCol is the color of the sun.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the reflected ray.\n    // The sunCol is the color of the", "\n    // This is the matrix that transforms the rays coming out of our eyes\n    // and going through the window.\n    mat3 eyeRayTransformationMatrix;\n\n    // This is the matrix that transforms the rays coming out of our eyes\n    // and going through the window.\n    mat3 eyeRayTransformationMatrix = mat3(\n        1.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 0.0f, 1.0f\n    );\n\n    // This is the matrix that transforms the rays coming out of our eyes\n    // and going through the window.\n    eyeRayTransformationMatrix = eyeRayTransformationMatrix * mat3(\n        cos(ta.x), -sin(ta.x), 0.0f,\n        sin(ta.x),  cos(ta.x), 0.0f,\n        0.0f, 0.0f, 1.0f\n    );\n\n    // This is the matrix that transforms the rays coming out of our eyes\n    // and going through the window.\n    eyeRayTransformationMatrix = eyeRayTransformationMatrix * mat3(\n        cos(ta.y), -sin(ta.y), 0.0f,\n        sin(ta.y),  cos(ta.y), 0.0f,\n        0.0f, 0.0f, 1.0f\n    );\n\n    // This is the matrix that transforms the rays coming out of our eyes\n    // and going through the window.\n    eyeRayTransformationMatrix = eyeRayTransformationMatrix * mat3(\n        cos(ta.z), -sin(ta.z), 0.0f,\n        sin(ta.z),  cos(ta.z), 0.0f,\n        0.0f, 0.0f, 1.0f\n    );\n\n    // This is the matrix that transforms the rays coming out of our eyes\n    // and going through the window.\n    eyeRayTransformationMatrix = eyeRayTransformationMatrix * mat3(\n        cos(ro.x), -sin(ro.x), 0.0f,\n        sin(ro.x),  cos(ro.x), 0.0f,\n", "\n    vec3 currentRayPosition = currentRayPosition;\n    vec3 currentRayPosition = currentRayPosition - vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);\n    vec3 currentRayPosition = currentRayPosition * 0.5;\n    vec3 currentRayPosition = currentRayPosition + vec3(0.5,0.5,0.5);", "#\n    // This is the distance to the first thing\n    // and the distance to the second thing\n    float distanceToFirst = distance( thing1.x, thing1.y ) ;\n    float distanceToSecond = distance( thing2.x, thing2.y ) ;\n    // This is the thing that is closer\n    // and the distance to it\n    vec2 closer = thing1 ;\n    float closerDistance = distanceToFirst ;\n    // If the second thing is closer\n    if( distanceToSecond < closerDistance ){\n        // Then it is closer\n        // and we return it\n        closer = thing2 ;\n        closerDistance = distanceToSecond ;\n    }\n    // We return the thing that is closer\n    return closer ;\n}\n\n// This function takes in a vector of things\n// and returns the thing that is closest\n// to the origin\nvec2 closestToOrigin( vec2 things ){#\n    // This is the thing that is closest\n    // and the distance to it\n    vec2 closest = things[0] ;\n    float closestDistance = distance( closest.x, closest.y ) ;\n    // This is the distance to the first thing\n    // and the distance to the second thing\n    for( int i = 1 ; i < things.size() ; i++ ){\n        // This is the distance to the ith thing\n        // and the distance to the ith thing\n        float distanceToIth = distance( things[i].x, things[i].y ) ;\n        // If the ith thing is closer\n        if( distanceToIth < closestDistance ){\n            // Then it is closer\n            // and we return it\n            closest = things[i] ;\n            closestDistance = distanceToIth ;\n        }\n    }\n    // We return the thing that is closest\n    return closest ;\n}\n\n// This function takes in a vector of things\n// and returns the thing that is closest\n// to the origin\nvec2 closestToOrigin( vec2 things ){#\n    // This is the thing that is closest\n    // and the distance to it\n    vec2 closest = things[0] ;\n    float closestDistance = distance( closest.x, closest.y ) ;\n    ", "#\n    // Get the ray's position in the world\n    vec3 rayPosition = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld = rayPositionInWorld( currentRayPosition );\n\n    // Get the ray's position in the world\n    vec3 rayPositionInWorld =", "\n    vec3 normal = vec3(0,0,0);\n    vec3 normal2 = vec3(0,0,0);\n    vec3 normal3 = vec3(0,0,0);\n    vec3 normal4 = vec3(0,0,0);\n    vec3 normal5 = vec3(0,0,0);\n    vec3 normal6 = vec3(0,0,0);\n    vec3 normal7 = vec3(0,0,0);\n    vec3 normal8 = vec3(0,0,0);\n    vec3 normal9 = vec3(0,0,0);\n    vec3 normal10 = vec3(0,0,0);\n    vec3 normal11 = vec3(0,0,0);\n    vec3 normal12 = vec3(0,0,0);\n    vec3 normal13 = vec3(0,0,0);\n    vec3 normal14 = vec3(0,0,0);\n    vec3 normal15 = vec3(0,0,0);\n    vec3 normal16 = vec3(0,0,0);\n    vec3 normal17 = vec3(0,0,0);\n    vec3 normal18 = vec3(0,0,0);\n    vec3 normal19 = vec3(0,0,0);\n    vec3 normal20 = vec3(0,0,0);\n    vec3 normal21 = vec3(0,0,0);\n    vec3 normal22 = vec3(0,0,0);\n    vec3 normal23 = vec3(0,0,0);\n    vec3 normal24 = vec3(0,0,0);\n    vec3 normal25 = vec3(0,0,0);\n    vec3 normal26 = vec3(0,0,0);\n    vec3 normal27 = vec3(0,0,0);\n    vec3 normal28 = vec3(0,0,0);\n    vec3 normal29 = vec3(0,0,0);\n    vec3 normal30 = vec3(0,0,0);\n    vec3 normal31 = vec3(0,0,0);\n    vec3 normal32 = vec3(0,0,0);\n", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// this is the function that will be called by the\n// render function.\nvoid draw(){\n    // we need to clear the screen first.\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // we need to set the background color.\n    glClearColor(0.0, 0.0, 0.0, 0.0);\n\n    // we need to set the depth buffer.\n    glEnable(GL_DEPTH_TEST);\n\n    // we need to set the projection matrix.\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, 1.0, 0.1, 100.0);\n\n    // we need to set the modelview matrix.\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -5.0);\n\n    // we need to set the color of the cube.\n    glColor3f(1.0, 1.0, 1.0);\n\n    // we need to draw the cube.\n    drawCube();\n}\n\n// this is the function that will be called by the\n// draw function.\nvoid drawCube(){\n    // we need to draw the cube.\n    glBegin(GL_QUADS);\n\n    // we need to draw the front face.\n    glVertex3f(1.0, 1.0, -1.0);\n    glVertex3f(-1.0, 1.0, -1.0);\n    glVertex3f(-1.0, 1.0, 1.0);\n    glVertex3f(1.0, 1.0, 1.0);\n\n    // we need to draw the back face.\n    glVertex3f(1.0, -1.0, -1.0);\n    glVertex3f(-1.0, -1.0, -1.0);\n    glVertex3f(-1.0, -1.0, 1.0);\n    glVertex3f(1.0,", "#include \"box.h\"\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 normal = normalize(normalOfSurface);\n    vec3 hit = normalize(positionOfHit - box.position);\n    vec3 hitNormal = normalize(cross(hit, normal));\n    color = box.color * hitNormal.dot(normal);\n    return color;\n}\n\n// This is the function that will be called when the ray hits the box\nvoid boxHit(vec3 positionOfHit, vec3 normalOfSurface, vec3 color){#include \"box.h\"\n    vec3 hit = normalize(positionOfHit - box.position);\n    vec3 hitNormal = normalize(cross(hit, normalOfSurface));\n    vec3 hitDir = normalize(hit);\n    vec3 hitDirNormal = normalize(cross(hitDir, hitNormal));\n    vec3 hitDirNormal2 = normalize(cross(hitDir, hitDirNormal));\n    vec3 hitDirNormal3 = normalize(cross(hitDir, hitDirNormal2));\n    vec3 hitDirNormal4 = normalize(cross(hitDir, hitDirNormal3));\n    vec3 hitDirNormal5 = normalize(cross(hitDir, hitDirNormal4));\n    vec3 hitDirNormal6 = normalize(cross(hitDir, hitDirNormal5));\n    vec3 hitDirNormal7 = normalize(cross(hitDir, hitDirNormal6));\n    vec3 hitDirNormal8 = normalize(cross(hitDir, hitDirNormal7));\n    vec3 hitDirNormal9 = normalize(cross(hitDir, hitDirNormal8));\n    vec3 hitDirNormal10 = normalize(cross(hitDir, hitDirNormal9));\n    vec3 hitDirNormal11 = normalize(cross(hitDir, hitDirNormal10));\n    vec3 hitDirNormal12 = normalize(cross(hitDir, hitDirNormal11));\n    vec3 hitDirNormal13 = normalize(cross(hitDir, hitDirNormal12));\n    vec3 hitDirNormal14 = normalize(cross(hitDir, hitDirNormal13));\n    vec3 hitDirNormal15 = normalize(cross(hitDir,", "#include \"color.h\"\n    // This is the color of the world\n    vec3 worldColor = vec3(0.0,0.0,0.0);\n    // This is the color of the ray\n    vec3 rayColor = vec3(0.0,0.0,0.0);\n    // This is the color of the object\n    vec3 objectColor = vec3(0.0,0.0,0.0);\n    // This is the color of the light\n    vec3 lightColor = vec3(0.0,0.0,0.0);\n    // This is the color of the shadow\n    vec3 shadowColor = vec3(0.0,0.0,0.0);\n    // This is the color of the sky\n    vec3 skyColor = vec3(0.0,0.0,0.0);\n    // This is the color of the ground\n    vec3 groundColor = vec3(0.0,0.0,0.0);\n    // This is the color of the grass\n    vec3 grassColor = vec3(0.0,0.0,0.0);\n    // This is the color of the tree\n    vec3 treeColor = vec3(0.0,0.0,0.0);\n    // This is the color of the flower\n    vec3 flowerColor = vec3(0.0,0.0,0.0);\n    // This is the color of the rock\n    vec3 rockColor = vec3(0.0,0.0,0.0);\n    // This is the color of the water\n    vec3 waterColor = vec3(0.0,0.0,0.0);\n    // This is the color of the sky\n    vec3 skyColor = vec3(0.0,0.0,0.0);\n    // This is the color of the ground\n    vec3 groundColor = vec3(0.0,0.0,0.0);\n    // This is the color of the grass\n    vec3 grassColor = vec3(0.0,0.0,0.0);\n    // This is the color of the tree\n    vec3 treeColor = vec3(0.0,0", "#ifdef _MSC_VER\n    return (x > 0.5)? (x - b) : (b - x);\n#else\n    return (x > 0.5)? (x - b) : (b - x);\n#endif\n}\n\n// returns a value between 0 and 1\n// if x is near 0.5 then value is 0.5\n// if x is near 1.0 then value is 1.0\n// if x is near 0.0 then value is 0.0\nfloat smoothstep(float x) {\n    return bias(x, 0.5) * bias(x, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.5 then value is 0.5\n// if x is near 1.0 then value is 1.0\n// if x is near 0.0 then value is 0.0\nfloat smoothstep_inverse(float y) {\n    return bias(y, 0.5) * bias(y, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.5 then value is 0.5\n// if x is near 1.0 then value is 1.0\n// if x is near 0.0 then value is 0.0\nfloat smoothstep_inverse_inverse(float y) {\n    return bias(y, 0.5) * bias(y, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.5 then value is 0.5\n// if x is near 1.0 then value is 1.0\n// if x is near 0.0 then value is 0.0\nfloat smoothstep_inverse_inverse_inverse(float y) {\n    return bias(y, 0.5) * bias(y, 0.5) * bias(y, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.5 then value is 0.5\n// if x is near 1.0 then value is 1.0\n// if x is near 0.0 then value is 0.0\nfloat smoothstep_inverse_inverse_inverse_inverse(float y) {\n    return bias(", "\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// returns a random number in the range 0..1\nfloat rand_float(){\n    return rand();\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive_inclusive_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive_inclusive_inclusive_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive_inclusive_inclusive_inclusive_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive_inclusive_inclusive_inclusive_inclusive_inclusive(float min, float max){\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// returns a random number in the range 0..1\nfloat rand_float_inclusive_inclusive_inclusive_inclusive_inclusive_inclusive_inclusive_inclusive(float min, float", "\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// returns a random number in the range 0..1 excluding 0\nfloat rand_exclusive(vec2 p){\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// returns a random number in the range 0..1 including 0\nfloat rand_inclusive_float(vec2 p){\n    return (float)rand_inclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 excluding 0\nfloat rand_exclusive_float(vec2 p){\n    return (float)rand_exclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 including 0\nfloat rand_inclusive_int(vec2 p){\n    return (float)rand_inclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 excluding 0\nfloat rand_exclusive_int(vec2 p){\n    return (float)rand_exclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 including 0\nfloat rand_inclusive_int_float(vec2 p){\n    return (float)rand_inclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 excluding 0\nfloat rand_exclusive_int_float(vec2 p){\n    return (float)rand_exclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 including 0\nfloat rand_inclusive_int_int(vec2 p){\n    return (float)rand_inclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 excluding 0\nfloat rand_exclusive_int_int(vec2 p){\n    return (float)rand_exclusive(p) + 0.5f;\n}\n\n// returns a random number in the range 0..1 including 0\nfloat rand_inclusive_int_int_float(vec2 p){\n    return (float)rand_inclusive(p) + 0.5f;\n}\n\n// returns", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#else\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#endif\n}\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input p --> is point\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#else\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#endif\n}\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input p --> is point\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#else\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#endif\n}\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input p --> is point\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;\n#else\n    return (p.x*p.x + p.y*p.y + p.z*p.z) - r*r;", "\n\tfloat x = p.xz.y;\n\tfloat y = p.xz.x;\n\tfloat z = p.xz.z;\n\tfloat r = t.x;\n\tfloat t = t.y;\n\treturn sqrt(x*x + y*y + z*z) - t;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n\tfloat x = p.xz.y;\n\tfloat y = p.xz.x;\n\tfloat z = p.xz.z;\n\tfloat r = t.x;\n\tfloat t = t.y;\n\treturn sqrt(x*x + y*y + z*z) - t;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n\tfloat x = p.xz.y;\n\tfloat y = p.xz.x;\n\tfloat z = p.xz.z;\n\tfloat r = t.x;\n\tfloat t = t.y;\n\treturn sqrt(x*x + y*y + z*z) - t;\n}\n", "#ifdef DEBUG\n    printf(\"smin(%f, %f) = %f\\n\", d1, d2, (d1+d2)/2.0f);\n#endif\n    return (d1+d2)/2.0f;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{#ifdef DEBUG\n    printf(\"smin(%f, %f) = %f\\n\", d1, d2, (d1+d2)/2.0f);\n#endif\n    return (d1+d2)/2.0f;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{#ifdef DEBUG\n    printf(\"smin(%f, %f) = %f\\n\", d1, d2, (d1+d2)/2.0f);\n#endif\n    return (d1+d2)/2.0f;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{#ifdef DEBUG\n    printf(\"smin(%f, %f) = %f\\n\", d1, d2, (d1+d2)/2.0f);\n#endif\n    return (d1+d2)/2.0f;", "#ifdef DEBUG\n    cout << \"opBlend: d1 = \" << d1 << \", d2 = \" << d2 << endl;\n#endif\n    return (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{#ifdef DEBUG\n    cout << \"opBlend: d1 = \" << d1 << \", d2 = \" << d2 << endl;\n#endif\n    return (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{#ifdef DEBUG\n    cout << \"opBlend: d1 = \" << d1 << \", d2 = \" << d2 << endl;\n#endif\n    return (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{#ifdef DEBUG\n    cout << \"opBlend: d1 = \" << d1 << \", d2 = \" << d2 << endl;\n#endif\n    return (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{#ifdef DEBUG\n    cout << \"opBlend: d1 = \" << d1 << \", d2 = \" << d2 << endl;\n#endif\n    return (d1 + d2) / 2.0;\n}\n\n", "#ifdef _OPENGL_\n    vec3 p2 = vec3(p.x*cos(yaw), p.y*sin(yaw), p.z);\n    vec3 p3 = vec3(p.x*cos(yaw+t), p.y*sin(yaw+t), p.z);\n    vec3 p4 = vec3(p.x*cos(yaw+2*t), p.y*sin(yaw+2*t), p.z);\n    vec3 p5 = vec3(p.x*cos(yaw+3*t), p.y*sin(yaw+3*t), p.z);\n    vec3 p6 = vec3(p.x*cos(yaw+4*t), p.y*sin(yaw+4*t), p.z);\n    vec3 p7 = vec3(p.x*cos(yaw+5*t), p.y*sin(yaw+5*t), p.z);\n    vec3 p8 = vec3(p.x*cos(yaw+6*t), p.y*sin(yaw+6*t), p.z);\n    vec3 p9 = vec3(p.x*cos(yaw+7*t), p.y*sin(yaw+7*t), p.z);\n    vec3 p10 = vec3(p.x*cos(yaw+8*t), p.y*sin(yaw+8*t), p.z);\n    vec3 p11 = vec3(p.x*cos(yaw+9*t), p.y*sin(yaw+9*t), p.z);\n    vec3 p12 = vec3(p.x*cos(yaw+10*t), p.y*sin(yaw+10*t), p.z);\n    vec3 p13 = vec3(p.x*cos(yaw+11*t), p.y*sin(yaw+11*t), p.z);\n    vec3 p14 = vec3(p.x*cos(yaw+12*t), p.y*sin(yaw+12*t),", "#ifdef _DEBUG_\n    printf(\"opU(%f, %f) -> \", o1.x, o2.x);\n#endif\n    if(o1.x < o2.x)\n    {\n        return o1;\n    }\n    else\n    {\n        return o2;\n    }\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{#ifdef _DEBUG_\n    printf(\"opU(%f, %f) -> \", o1.x, o2.x);\n#endif\n    if(o1.x < o2.x)\n    {\n        return o1;\n    }\n    else\n    {\n        return o2;\n    }\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{#ifdef _DEBUG_\n    printf(\"opU(%f, %f) -> \", o1.x, o2.x);\n#endif\n    if(o1.x < o2.x)\n    {\n        return o1;\n    }\n    else\n    {\n        return o2;\n    }\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{#ifdef _DEBUG_\n    printf(\"opU(%f, %f) -> \", o1.x, o2.x);\n#endif\n    if(o1.x < o2.x)\n    {\n        return o1;\n    }\n    else\n    {\n        return o2;\n    ", "#include \"map.h\"\n    vec3 p_ = p;\n    vec3 p_min = p;\n    vec3 p_min_dist = vec3(0,0,0);\n    for(int i = 0; i < world.size(); i++)\n    {\n        vec3 p_i = world[i];\n        float dist = dot(p_i - p_, p_i - p_);\n        if(dist < p_min_dist)\n        {\n            p_min = p_i;\n            p_min_dist = dist;\n        }\n    }\n    return p_min;\n}\n\n// ~~~~~~~ raycast\n// input p --> is ray position\n// input o --> is object/point\n// output t --> is distance from ray to object\n// output o_ --> is object/point\n// output t_ --> is distance from ray to object\n// output o_t --> is object/point\n// ~~~~~~~\nvec3 raycast(vec3 p, vec3 o)\n{#include \"raycast.h\"\n    vec3 p_ = p;\n    vec3 o_ = o;\n    float t_ = 0;\n    float t_min = 0;\n    float t_min_dist = 0;\n    vec3 o_t = o;\n    for(int i = 0; i < world.size(); i++)\n    {\n        vec3 p_i = world[i];\n        float dist = dot(p_i - p_, p_i - p_);\n        if(dist < t_min_dist)\n        {\n            t_min_dist = dist;\n            t_min = dist / (p_i - o_);\n            o_t = p_i + t_min * (p_i - o_);\n        }\n    }\n    return o_t;\n}\n\n// ~~~~~~~ raycast_all\n// input p --> is ray position\n// input o --> is object/point\n// output t --> is distance from ray to object\n// output o_ --> is object/point\n// output t_ --> is distance from ray to object\n// output o_t --> is object/point\n// ~~~~~~", "#include \"ray.h\"\n    vec2 ret;\n    if( rayHit( ro, rd, &ret ) )\n    {\n        return ret;\n    }\n    return vec2(0,0);\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{#include \"ray.h\"\n    vec2 ret;\n    if( rayHit( ro, rd, &ret ) )\n    {\n        return ret;\n    }\n    return vec2(0,0);\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{#include \"ray.h\"\n    vec2 ret;\n    if( rayHit( ro, rd, &ret ) )\n    {\n        return ret;\n    }\n    return vec2(0,0);\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{#include \"ray.h\"\n    vec2 ret;\n    if( rayHit( ro, rd, &ret ) )\n    {\n        return ret;\n    }\n    return vec2(0,0);\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x =", "#include \"ray.h\"\n    // find closest surface\n    vec3 closest;\n    for (int i = 0; i < surfaces.size(); i++)\n    {\n        if (ray_intersect(ro, rd, surfaces[i].pos, surfaces[i].dir))\n        {\n            closest = surfaces[i].pos;\n            break;\n        }\n    }\n    // apply color\n    vec3 color = surfaces[closest.y][closest.x].color;\n    return color;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{#include \"ray.h\"\n    // find closest surface\n    vec3 closest;\n    for (int i = 0; i < surfaces.size(); i++)\n    {\n        if (ray_intersect(ro, rd, surfaces[i].pos, surfaces[i].dir))\n        {\n            closest = surfaces[i].pos;\n            break;\n        }\n    }\n    // apply color\n    vec3 color = surfaces[closest.y][closest.x].color;\n    return color;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{#include \"ray.h\"\n    // find closest surface\n    vec3 closest;\n    for (int i = 0; i < surfaces.size(); i++)\n    {\n        if (ray_intersect(ro, rd, surfaces[i].pos, surfaces[i].dir))\n        {\n            closest = surfaces[i].pos;\n            break;\n        }\n    }\n    // apply color\n    vec3 color = surfaces[closest.y][closest.x].color;\n    return color;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro -->", "#define PI 3.1415926535897932384626433832795\n    // ~~~~~~~ camera matrix\n    mat3 cameraMatrix;\n    // ~~~~~~~ camera position\n    vec3 camPos = vec3( camPos );\n    // ~~~~~~~ target position\n    vec3 targetPos = vec3( targetPos );\n    // ~~~~~~~ camera roll\n    float roll = roll;\n    // ~~~~~~~ camera matrix\n    cameraMatrix.set(\n        vec3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            camPos.x, camPos.y, camPos.z,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            ", "\n    float i = id;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        i = -i;\n    if (i < 0)\n        ", "#ifdef _GL_ARB_USE_\n    vec3 p_flat = p.xyz;\n    vec3 t_flat = t.xyz;\n    vec3 t_flat_x = t_flat.x;\n    vec3 t_flat_y = t_flat.y;\n    vec3 t_flat_z = t_flat.z;\n    vec3 t_flat_x_2 = t_flat_x*t_flat_x;\n    vec3 t_flat_y_2 = t_flat_y*t_flat_y;\n    vec3 t_flat_z_2 = t_flat_z*t_flat_z;\n    vec3 t_flat_x_y = t_flat_x*t_flat_y;\n    vec3 t_flat_x_z = t_flat_x*t_flat_z;\n    vec3 t_flat_y_z = t_flat_y*t_flat_z;\n    vec3 t_flat_x_y_2 = t_flat_x_y*t_flat_y_y;\n    vec3 t_flat_x_z_2 = t_flat_x_z*t_flat_z_2;\n    vec3 t_flat_y_z_2 = t_flat_y_z*t_flat_z_2;\n    vec3 t_flat_x_y_z = t_flat_x_y*t_flat_z;\n    vec3 t_flat_x_z_y = t_flat_x_z*t_flat_y;\n    vec3 t_flat_y_z_x = t_flat_y_z*t_flat_x;\n    vec3 t_flat_x_y_z_2 = t_flat_x_y_z*t_flat_y_z_2;\n    vec3 t_flat_x_z_y_2 = t_flat_x_z_y*t_flat_x_z_2;\n    vec3 t_flat_y_z_x_2 = t_flat_y_z_x*t_flat_y_z_2;\n    ", "#ifdef _PLANE_\n    return p.y;\n#else\n    return p.y - floor(p.y);\n#endif\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input p --> specs of sphere\n//        p.x --> size x\n//        p.y --> size y\n//        p.z --> size z\n//        p.r --> radius\n// ~~~~~~~ signed distance function for sphere\nfloat sdSphere(vec3 p)\n{#ifdef _PLANE_\n    return p.y - floor(p.y);\n#else\n    return p.y - floor(p.y) - p.z + floor(p.z);\n#endif\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input p --> specs of cylinder\n//        p.x --> size x\n//        p.y --> size y\n//        p.z --> size z\n//        p.r --> radius\n//        p.h --> height\n// ~~~~~~~ signed distance function for cylinder\nfloat sdCylinder(vec3 p)\n{#ifdef _PLANE_\n    return p.y - floor(p.y);\n#else\n    return p.y - floor(p.y) - p.z + floor(p.z) - p.h + floor(p.h);\n#endif\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input p --> specs of cone\n//        p.x --> size x\n//        p.y --> size y\n//        p.z --> size z\n//        p.r --> radius\n//        p.h --> height\n// ~~~~~~~ signed distance function for cone\nfloat sdCone(vec3 p)\n{#ifdef _PLANE_\n    return p.y - floor(p.y);\n#else\n    return p.y - floor(p.y) - p.z + floor(p.z) - p.h + floor(p.h);\n#endif\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input p --> specs of torus\n//        p.x --> size x\n//        p.y --> size y\n//        p.", "#ifdef DEBUG\n    printf(\"smin(%f, %f, %f) = %f\\n\", d1, d2, k, smin(d1, d2, k));\n#endif\n    if (d1 == d2)\n        return d1;\n    else\n        return (1.0f - k) * d1 + k * d2;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{#ifdef DEBUG\n    printf(\"smin(%f, %f, %f) = %f\\n\", d1, d2, k, smin(d1, d2, k));\n#endif\n    if (d1 == d2)\n        return d1;\n    else\n        return (1.0f - k) * d1 + k * d2;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{#ifdef DEBUG\n    printf(\"smin(%f, %f, %f) = %f\\n\", d1, d2, k, smin(d1, d2, k));\n#endif\n    if (d1 == d2)\n        return d1;\n    else\n        return (1.0f - k) * d1 + k * d2;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n//", "#ifdef DEBUG\n    cout << \"opBlend: \" << o1.x << \" \" << o1.y << \" \" << o1.z << \" \" << o1.w << endl;\n    cout << \"opBlend: \" << o2.x << \" \" << o2.y << \" \" << o2.z << \" \" << o2.w << endl;\n    cout << \"opBlend: \" << bf << endl;\n#endif\n    vec4 o1_color = o1.rgba;\n    vec4 o2_color = o2.rgba;\n    vec4 blended_color = o1_color * (1.0 - bf) + o2_color * bf;\n    return blended_color;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{#ifdef DEBUG\n    cout << \"opBlend: \" << o1.x << \" \" << o1.y << \" \" << o1.z << \" \" << o1.w << endl;\n    cout << \"opBlend: \" << o2.x << \" \" << o2.y << \" \" << o2.z << \" \" << o2.w << endl;\n    cout << \"opBlend: \" << bf << endl;\n#endif\n    vec4 o1_color = o1.rgba;\n    vec4 o2_color = o2.rgba;\n    vec4 blended_color = o1_color * (1.0 - bf) + o2_color * bf;\n    return blended_color;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)", "#ifdef _OPENMP\n    #pragma omp parallel for\n    for(int i=0;i<d1.size();i++)\n    {\n        d1[i] = d1[i] - d2[i];\n    }\n    #pragma omp critical\n    return d1;\n}\n#endif\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, where effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{#ifdef _OPENMP\n    #pragma omp parallel for\n    for(int i=0;i<d1.size();i++)\n    {\n        d1[i] = d1[i] - d2[i];\n    }\n    #pragma omp critical\n    return d1;\n}\n#endif\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, where effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{#ifdef _OPENMP\n    #pragma omp parallel for\n    for(int i=0;i<d1.size();i++)\n    {\n        d1[i] = d1[i] - d2[i];\n    }\n    #pragma omp critical\n    return d1;\n}\n#endif\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, where effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{#ifdef _OPENMP\n    #pragma omp parallel for\n    for(int i=0;i<d1.size();i++)", "#include \"gl/gl_shaders.h\"#}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightDir2 = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir3 = vec3(0.0, 1.0, 0.0);\n    vec3 lightDir4 = vec3(0.0, -1.0, 0.0);\n    vec3 lightDir5 = vec3(1.0, 0.0, 0.0);\n    vec3 lightDir6 = vec3(-1.0, 0.0, 0.0);\n    vec3 lightDir7 = vec3(0.0, 0.0, 1.0);\n    vec3 lightDir8 = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir9 = vec3(1.0, 1.0, 0.0);\n    vec3 lightDir10 = vec3(-1.0, -1.0, 0.0);\n    vec3 lightDir11 = vec3(1.0, -1.0, 0.0);\n    vec3 lightDir12 = vec3(-1.0, 1.0, 0.0);\n    vec3 lightDir13 = vec3(1.0, 1.0, 0.0);\n    vec3 lightDir14 = vec3(-1.0, -1.0, 0.0);\n    vec3 lightDir15 = vec3(1.0, 1.0, 0.0);\n    vec3 lightDir16 = vec3(-1.0, 1.0, 0.0);\n    vec3 lightDir17 = vec3(1.0, -1.0, 0.0);\n    vec3 lightDir18 = vec3(-1.0, -1.0, 0.0);\n    vec", "\n    vec3 p0 = p;\n    vec3 p1 = p + vec3(1, 0, 0);\n    vec3 p2 = p + vec3(0, 1, 0);\n    vec3 p3 = p + vec3(0, 0, 1);\n    vec3 p4 = p + vec3(-1, 0, 0);\n    vec3 p5 = p + vec3(0, -1, 0);\n    vec3 p6 = p + vec3(0, 0, -1);\n    vec3 p7 = p + vec3(1, 1, 0);\n    vec3 p8 = p + vec3(1, -1, 0);\n    vec3 p9 = p + vec3(1, 0, -1);\n    vec3 p10 = p + vec3(-1, 1, 0);\n    vec3 p11 = p + vec3(-1, -1, 0);\n    vec3 p12 = p + vec3(-1, 0, -1);\n    vec3 p13 = p + vec3(0, 1, 1);\n    vec3 p14 = p + vec3(0, -1, 1);\n    vec3 p15 = p + vec3(0, 0, 1);\n    vec3 p16 = p + vec3(0, 1, -1);\n    vec3 p17 = p + vec3(0, -1, -1);\n    vec3 p18 = p + vec3(0, 0, -1);\n    vec3 p19 = p + vec3(1, 1, 1);\n    vec3 p20 = p + vec3(1, -1, 1);\n    vec3 p21 = p + vec3(1, 0, -1);\n    vec3 p22 = p + vec3(-1, 1, 1);\n    vec3 p23 = p + vec3(-1, -1, 1);\n    vec3 p24 = p + vec3(-1, 0, -1);\n    vec3 p25 = p + vec3(0, 1, -1);\n    vec3 p26 = p + vec3(0, -1, -1);\n    vec3 p27 = p + vec3(0, 0, -", "#ifdef DEBUG\n    cout << \"castRay: ro = \" << ro << \", rd = \" << rd << endl;\n#endif\n    vec3 ray = ro + rd;\n    vec3 rayDir = rd;\n    float dist = 0;\n    float hit = 0;\n    float itter = 0;\n    float itterRatio = itterRatio;\n    float itterRatio2 = itterRatio * itterRatio;\n    float itterRatio3 = itterRatio2 * itterRatio;\n    float itterRatio4 = itterRatio3 * itterRatio;\n    float itterRatio5 = itterRatio4 * itterRatio;\n    float itterRatio6 = itterRatio5 * itterRatio;\n    float itterRatio7 = itterRatio6 * itterRatio;\n    float itterRatio8 = itterRatio7 * itterRatio;\n    float itterRatio9 = itterRatio8 * itterRatio;\n    float itterRatio10 = itterRatio9 * itterRatio;\n    float itterRatio11 = itterRatio10 * itterRatio;\n    float itterRatio12 = itterRatio11 * itterRatio;\n    float itterRatio13 = itterRatio12 * itterRatio;\n    float itterRatio14 = itterRatio13 * itterRatio;\n    float itterRatio15 = itterRatio14 * itterRatio;\n    float itterRatio16 = itterRatio15 * itterRatio;\n    float itterRatio17 = itterRatio16 * itterRatio;\n    float itterRatio18 = itterRatio17 * itterRatio;\n    float itterRatio19 = itterRatio18 * itterRatio;\n    float itterRatio20 = itterRatio19 * itterRatio;\n    float itterRatio21 = itterRatio20 * itterRatio;\n    float itterRatio22 = itterRatio21 * itterRatio;\n    float", "\n    vec3 p = sp - lp;\n    vec3 n = normalize(p);\n    vec3 d = normalize(cross(n, lp - sp));\n    vec3 dn = normalize(cross(n, d));\n    vec3 dn2 = normalize(cross(dn, d));\n    vec3 dn3 = normalize(cross(dn, dn2));\n    vec3 dn4 = normalize(cross(dn, dn3));\n    vec3 dn5 = normalize(cross(dn, dn4));\n    vec3 dn6 = normalize(cross(dn, dn5));\n    vec3 dn7 = normalize(cross(dn, dn6));\n    vec3 dn8 = normalize(cross(dn, dn7));\n    vec3 dn9 = normalize(cross(dn, dn8));\n    vec3 dn10 = normalize(cross(dn, dn9));\n    vec3 dn11 = normalize(cross(dn, dn10));\n    vec3 dn12 = normalize(cross(dn, dn11));\n    vec3 dn13 = normalize(cross(dn, dn12));\n    vec3 dn14 = normalize(cross(dn, dn13));\n    vec3 dn15 = normalize(cross(dn, dn14));\n    vec3 dn16 = normalize(cross(dn, dn15));\n    vec3 dn17 = normalize(cross(dn, dn16));\n    vec3 dn18 = normalize(cross(dn, dn17));\n    vec3 dn19 = normalize(cross(dn, dn18));\n    vec3 dn20 = normalize(cross(dn, dn19));\n    vec3 dn21 = normalize(cross(dn, dn20));\n    vec3 dn22 = normalize(cross(dn, dn21));\n    vec3 dn23 = normalize(cross(dn, dn22));\n    vec3 dn24 = normalize(cross(dn, dn23));\n    vec3 dn25 = normalize(cross(dn, dn24));\n    ", "#ifdef DEBUG\n    printf(\"castRay_AmbientOcclusion: %f %f %f\\n\", sp.x, sp.y, sp.z);\n    printf(\"castRay_AmbientOcclusion: %f %f %f\\n\", nor.x, nor.y, nor.z);\n#endif\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1.0;\n    float tmin_t = 0.0;\n    float tmax_t = 1.0;\n    float tmin_t2 = 0.0;\n    float tmax_t2 = 1.0;\n    float tmin_t3 = 0.0;\n    float tmax_t3 = 1.0;\n    float tmin_t4 = 0.0;\n    float tmax_t4 = 1.0;\n    float tmin_t5 = 0.0;\n    float tmax_t5 = 1.0;\n    float tmin_t6 = 0.0;\n    float tmax_t6 = 1.0;\n    float tmin_t7 = 0.0;\n    float tmax_t7 = 1.0;\n    float tmin_t8 = 0.0;\n    float tmax_t8 = 1.0;\n    float tmin_t9 = 0.0;\n    float tmax_t9 = 1.0;\n    float tmin_t10 = 0.0;\n    float tmax_t10 = 1.0;\n    float tmin_t11 = 0.0;\n    float tmax_t11 = 1.0;\n    float tmin_t12 = 0.0;\n    float tmax_t12 = 1.0;\n    float tmin_t13 = 0.0;\n    float tmax_t13 = 1.0;\n    float tmin_t14 = 0.0;\n    float tmax_t14 = 1.0;\n    float tmin_t15 = 0.0;\n    float tmax_t15 = 1.0;\n    float tmin_t16 = 0.0;\n    float tmax_t", "#ifdef DEBUG\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "#include \"gamma.h\"\n    return gamma(c);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{#include \"gamma.h\"\n    return gamma(c);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{#include \"gamma.h\"\n    return gamma(c);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{#include \"gamma.h\"\n    return gamma(c);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{#include \"gamma.h\"\n    return gamma(c);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{#include \"gamma.h\"\n    return gamma(c);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www", "#include \"fog.h\"\n    vec3 cf1 = fc1;\n    vec3 cf2 = fc2;\n    vec3 cf = (fc1+fc2)/2.0;\n    vec3 cf1_dot_c = dot(cf1,c);\n    vec3 cf2_dot_c = dot(cf2,c);\n    vec3 cf_dot_c = dot(cf,c);\n    vec3 cf_dot_c_dot_c = dot(cf,cf_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c_dot_c_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c_dot_c_dot_c_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c);\n    vec3 cf_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c_dot_c = dot(cf,cf_dot_c_dot_c", "#ifdef DEBUG\n    printf(\"calculateLightAttn(cF=%f,lF=%f,qF=%f,d=%f)\\n\",cF,lF,qF,d);\n#endif\n    return cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{#ifdef DEBUG\n    printf(\"calculateLightAttn(cF=%f,lF=%f,qF=%f,d=%f)\\n\",cF,lF,qF,d);\n#endif\n    return cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{#ifdef DEBUG\n    printf(\"calculateLightAttn(cF=%f,lF=%f,qF=%f,d=%f)\\n\",cF,lF,qF,d);\n#endif\n    return cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow", "#ifdef DEBUG\n    cout << \"calculateRayDir: fCoord: \" << fCoord << \", cMatrix: \" << cMatrix << endl;\n#endif\n    vec3 rayDir;\n    vec3 cCoord;\n    cCoord = cMatrix * fCoord;\n    rayDir = cCoord / cCoord.norm();\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{#ifdef DEBUG\n    cout << \"calculateRayDir: fCoord: \" << fCoord << \", cMatrix: \" << cMatrix << endl;\n#endif\n    vec3 rayDir;\n    vec3 cCoord;\n    cCoord = cMatrix * fCoord;\n    rayDir = cCoord / cCoord.norm();\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{#ifdef DEBUG\n    cout << \"calculateRayDir: fCoord: \" << fCoord << \", cMatrix: \" << cMatrix << endl;\n#endif\n    vec3 rayDir;\n    vec3 cCoord;\n    cCoord = cMatrix * fCoord;\n    rayDir = cCoord / cCoord.norm();\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{#ifdef DEBUG\n    cout << \"calculateRayDir: fCoord: \" << fCoord << \", cMatrix: \" << cMatrix << endl;\n#endif\n    vec3 rayDir;\n    ", "#define PI 3.1415926535897932384626433832795\n    vec3 cPos_inv = invert(cPos);\n    vec3 cPos_inv_x = cPos_inv.x;\n    vec3 cPos_inv_y = cPos_inv.y;\n    vec3 cPos_inv_z = cPos_inv.z;\n    vec3 cPos_inv_w = cPos_inv.w;\n    vec3 cPos_inv_xy = cPos_inv_x*cPos_inv_y;\n    vec3 cPos_inv_xz = cPos_inv_x*cPos_inv_z;\n    vec3 cPos_inv_yz = cPos_inv_y*cPos_inv_z;\n    vec3 cPos_inv_xw = cPos_inv_x*cPos_inv_w;\n    vec3 cPos_inv_yw = cPos_inv_y*cPos_inv_w;\n    vec3 cPos_inv_zw = cPos_inv_z*cPos_inv_w;\n    vec3 cPos_inv_xyz = cPos_inv_xy*cPos_inv_z;\n    vec3 cPos_inv_xwz = cPos_inv_xw*cPos_inv_z;\n    vec3 cPos_inv_ywz = cPos_inv_yw*cPos_inv_z;\n    vec3 cPos_inv_xyzw = cPos_inv_xyz*cPos_inv_w;\n    vec3 cPos_inv_xwxy = cPos_inv_xw*cPos_inv_xy;\n    vec3 cPos_inv_ywxy = cPos_inv_yw*cPos_inv_xy;\n    vec3 cPos_inv_xyzwxy = cPos_inv_xyz*cPos_inv_xy;\n    vec3 cPos_inv_xwxyz = cPos_inv_xw*cPos_inv_xyz;\n    vec3 cPos_inv_ywxyz = cPos_inv_yw*cPos_inv_xy", "\n    // Create a new image with the same size as the viewport\n    // and a depth of 4 (RGBA)\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    gl_FragColor.rgb = vec4(0.0, 0.0, 0.0, 1.0);\n    gl_FragColor.a = 1.0;\n}\n\nvoid main()\n{\n    // Create a new image with the same size as the viewport\n    // and a depth of 4 (RGBA)\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    gl_FragColor.rgb = vec4(0.0, 0.0, 0.0, 1.0);\n    gl_FragColor.a = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz = vec3(0.0, 0.0, 0.0);\n    gl_FragColor.w = 1.0;\n    gl_FragColor.xyz", "\n    return (p.x - radius.x) * (p.x - radius.x) +\n           (p.y - radius.y) * (p.y - radius.y) +\n           (p.z - radius.z) * (p.z - radius.z);\n}\n// sphere distance field\nfloat sdSphere(vec3 p, vec3 radius)\n{\n    return (p.x - radius.x) * (p.x - radius.x) +\n           (p.y - radius.y) * (p.y - radius.y) +\n           (p.z - radius.z) * (p.z - radius.z) -\n           radius.x * radius.x - radius.y * radius.y - radius.z * radius.z;\n}\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 radius, vec3 height)\n{\n    return (p.x - radius.x) * (p.x - radius.x) +\n           (p.y - radius.y) * (p.y - radius.y) +\n           (p.z - radius.z) * (p.z - radius.z) -\n           radius.x * radius.x - radius.y * radius.y;\n}\n// plane distance field\nfloat sdPlane(vec3 p, vec3 normal, float distance)\n{\n    return (p.x - normal.x) * (p.x - normal.x) +\n           (p.y - normal.y) * (p.y - normal.y) +\n           (p.z - normal.z) * (p.z - normal.z) -\n           distance * distance;\n}\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n", "    \n    vec2 p0 = p - r*vec2(cos(p.y), sin(p.y));\n    return (p0.x*p0.x + p0.y*p0.y) < r*r;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r)\n{\n    vec2 p0 = p - r*vec2(cos(p.y), sin(p.y));\n    return (p0.x*p0.x + p0.y*p0.y + p0.z*p0.z) < r*r;\n}\n\n// simple cone distance field\nfloat cone(vec2 p, float r, float h)\n{\n    vec2 p0 = p - r*vec2(cos(p.y), sin(p.y));\n    return (p0.x*p0.x + p0.y*p0.y + p0.z*p0.z) < r*r && (p0.z*p0.z) < h*h;\n}\n\n// simple pyramid distance field\nfloat pyramid(vec2 p, float r, float h)\n{\n    vec2 p0 = p - r*vec2(cos(p.y), sin(p.y));\n    return (p0.x*p0.x + p0.y*p0.y + p0.z*p0.z) < r*r && (p0.z*p0.z) < h*h && (p0.z*p0.z) > h*h/2;\n}\n\n// simple torus distance field\nfloat torus(vec2 p, float r, float h)\n{\n    vec2 p0 = p - r*vec2(cos(p.y), sin(p.y));\n    return (p0.x*p0.x + p0.y*p0.y + p0.z*p0.z) < r*r && (p0.z*p0.z) < h*h;\n}\n\n// simple hyperboloid distance field\nfloat hyperboloid(vec2 p, float r, float h)\n{\n    ", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec3 p_local = gl_Position.xyz;\n    vec3 p_local_inv = gl_Position.xyz.xyz.xyz;\n    vec3 p_local_inv_inv = gl_Position.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = gl_Position.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz.xyz;\n    vec3 p_local_inv_inv_inv_inv_inv_inv_inv_", "#include <complex>\n    return complex<double>((c.real()*c.real()*c.real()*c.real()*c.real() + c.imag()*c.imag()*c.imag()*c.imag()*c.imag()))\n}\n\n#Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{#include <complex>\n    return complex<double>((c.real()*c.real()*c.real()*c.real()*c.real()*c.real() + c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()))\n}\n\n#Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{#include <complex>\n    return complex<double>((c.real()*c.real()*c.real()*c.real()*c.real()*c.real()*c.real() + c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()))\n}\n\n#Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{#include <complex>\n    return complex<double>((c.real()*c.real()*c.real()*c.real()*c.real()*c.real()*c.real()*c.real() + c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()))\n}\n\n#Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{#include <complex>\n    return complex<double>((c.real()*c.real()*c.real()*c.real()*c.real()*c.real()*c.real()*c.real()*c.real() + c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*c.imag()*", "\n    vec2 morphCoord = morphConstant * coord;\n    vec2 morphCoord2 = morphCoord * morphCoord;\n    vec2 morphCoord3 = morphCoord2 * morphCoord;\n    vec2 morphCoord4 = morphCoord3 * morphCoord;\n    vec2 morphCoord5 = morphCoord4 * morphCoord;\n    vec2 morphCoord6 = morphCoord5 * morphCoord;\n    vec2 morphCoord7 = morphCoord6 * morphCoord;\n    vec2 morphCoord8 = morphCoord7 * morphCoord;\n    vec2 morphCoord9 = morphCoord8 * morphCoord;\n    vec2 morphCoord10 = morphCoord9 * morphCoord;\n    vec2 morphCoord11 = morphCoord10 * morphCoord;\n    vec2 morphCoord12 = morphCoord11 * morphCoord;\n    vec2 morphCoord13 = morphCoord12 * morphCoord;\n    vec2 morphCoord14 = morphCoord13 * morphCoord;\n    vec2 morphCoord15 = morphCoord14 * morphCoord;\n    vec2 morphCoord16 = morphCoord15 * morphCoord;\n    vec2 morphCoord17 = morphCoord16 * morphCoord;\n    vec2 morphCoord18 = morphCoord17 * morphCoord;\n    vec2 morphCoord19 = morphCoord18 * morphCoord;\n    vec2 morphCoord20 = morphCoord19 * morphCoord;\n    vec2 morphCoord21 = morphCoord20 * morphCoord;\n    vec2 morphCoord22 = morphCoord21 * morphCoord;\n    vec2 morphCoord23 = morphCoord22 * morphCoord;\n    vec2 morphCoord24 = morphCoord23 * morphCoord;\n    vec2 morphCoord25 = morphCoord24 * morphCoord;\n    vec2 morphCoord26 = morphCoord25 * morphCoord;\n    vec2 morphCoord27 = morphCoord26 * morphCoord;\n    vec2 morphCoord28 = morphCoord27 * morphCoord;\n    vec2 morphCoord29 = morphCoord28", "\n    vec2 uv2 = uv * constant;\n    vec2 uv3 = uv2 + constant;\n    vec2 uv4 = uv2 + 2 * constant;\n    vec2 uv5 = uv2 + 3 * constant;\n    vec2 uv6 = uv2 + 4 * constant;\n    vec2 uv7 = uv2 + 5 * constant;\n    vec2 uv8 = uv2 + 6 * constant;\n    vec2 uv9 = uv2 + 7 * constant;\n    vec2 uv10 = uv2 + 8 * constant;\n    vec2 uv11 = uv2 + 9 * constant;\n    vec2 uv12 = uv2 + 10 * constant;\n    vec2 uv13 = uv2 + 11 * constant;\n    vec2 uv14 = uv2 + 12 * constant;\n    vec2 uv15 = uv2 + 13 * constant;\n    vec2 uv16 = uv2 + 14 * constant;\n    vec2 uv17 = uv2 + 15 * constant;\n    vec2 uv18 = uv2 + 16 * constant;\n    vec2 uv19 = uv2 + 17 * constant;\n    vec2 uv20 = uv2 + 18 * constant;\n    vec2 uv21 = uv2 + 19 * constant;\n    vec2 uv22 = uv2 + 20 * constant;\n    vec2 uv23 = uv2 + 21 * constant;\n    vec2 uv24 = uv2 + 22 * constant;\n    vec2 uv25 = uv2 + 23 * constant;\n    vec2 uv26 = uv2 + 24 * constant;\n    vec2 uv27 = uv2 + 25 * constant;\n    vec2 uv28 = uv2 + 26 * constant;\n    vec2 uv29 = uv2 + 27 * constant;\n    vec2 uv30 = uv2 + 28 * constant;\n    vec2 uv31 = uv2 + 29 * constant;\n    vec2 uv32 = uv2 + 30 * constant;\n    vec2 uv33 = uv2 + 31 * constant;\n    vec2 u", "\n    return x < 0.5? -x : x;\n}\n\nfloat triangle(float x) {\n    return repeat(x * 2 - 1);\n}\n\nfloat triangle_wave(float x) {\n    return triangle(x / (2 * PI) * 2) * PI;\n}\n\nfloat triangle_wave_period(float period) {\n    return 2 * PI / period;\n}\n\nfloat triangle_wave_amplitude(float amplitude) {\n    return amplitude / 2;\n}\n\nfloat triangle_wave_frequency(float frequency) {\n    return 1 / triangle_wave_period(frequency);\n}\n\nfloat triangle_wave_phase(float phase) {\n    return phase * triangle_wave_period(frequency);\n}\n\nfloat triangle_wave(float x, float frequency, float amplitude, float phase) {\n    return amplitude * triangle(x - phase) * triangle_wave_frequency(frequency);\n}\n\nfloat triangle_wave_period(float frequency) {\n    return 2 * PI / frequency;\n}\n\nfloat triangle_wave_amplitude(float amplitude) {\n    return amplitude / 2;\n}\n\nfloat triangle_wave_frequency(float frequency) {\n    return 1 / triangle_wave_period(frequency);\n}\n\nfloat triangle_wave_phase(float phase) {\n    return phase * triangle_wave_period(frequency);\n}\n\nfloat triangle_wave(float x, float frequency, float amplitude, float phase) {\n    return amplitude * triangle(x - phase) * triangle_wave_frequency(frequency);\n}\n\nfloat triangle_wave(float x, float frequency, float amplitude, float phase) {\n    return amplitude * triangle(x - phase) * triangle_wave_frequency(frequency);\n}\n\nfloat triangle_wave(float x, float frequency, float amplitude, float phase) {\n    return amplitude * triangle(x - phase) * triangle_wave_frequency(frequency);\n}\n\nfloat triangle_wave(float x, float frequency, float amplitude, float phase) {\n    return amplitude * triangle(x - phase) * triangle_wave_frequency(frequency);\n}\n\nfloat triangle_wave(float x, float frequency, float amplitude, float phase) {\n    return amplitude *", "\n    // This is the distance from the line to the point\n    float d = 0.0;\n    // This is the distance from the point to the line\n    float dp = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrevPrevPrevPrevPrev = 0.0;\n    // This is the distance from the point to the line at the last point\n    float dpPrevPrev", "#include <math.h>\n    float dx = pB.x - pA.x;\n    float dy = pB.y - pA.y;\n    float d = sqrt(dx*dx + dy*dy);\n    float dp = d*thick;\n    float dxp = dx*dp;\n    float dyp = dy*dp;\n    float x = pA.x;\n    float y = pA.y;\n    float x1 = x + dxp;\n    float y1 = y + dyp;\n    float x2 = x1 + dxp;\n    float y2 = y1 + dyp;\n    float x3 = x2 + dxp;\n    float y3 = y2 + dyp;\n    float x4 = x3 + dxp;\n    float y4 = y3 + dyp;\n    float x5 = x4 + dxp;\n    float y5 = y4 + dyp;\n    float x6 = x5 + dxp;\n    float y6 = y5 + dyp;\n    float x7 = x6 + dxp;\n    float y7 = y6 + dyp;\n    float x8 = x7 + dxp;\n    float y8 = y7 + dyp;\n    float x9 = x8 + dxp;\n    float y9 = y8 + dyp;\n    float x10 = x9 + dxp;\n    float y10 = y9 + dyp;\n    float x11 = x10 + dxp;\n    float y11 = y10 + dyp;\n    float x12 = x11 + dxp;\n    float y12 = y11 + dyp;\n    float x13 = x12 + dxp;\n    float y13 = y12 + dyp;\n    float x14 = x13 + dxp;\n    float y14 = y13 + dyp;\n    float x15 = x14 + dxp;\n    float y15 = y14 + dyp;\n    float x16 = x15 + dxp;\n    float y16 = y15 + dyp;\n    float x17 = x16 + dxp;\n    float y17 = y16 + dyp;\n    ", "#define OUTLINE_THICK 1.0\n    float u = uv.x;\n    float v = uv.y;\n    float ua = pA.x - u;\n    float ub = pA.y - v;\n    float va = pB.x - u;\n    float vb = pB.y - v;\n    float ua2 = ua * ua;\n    float ub2 = ub * ub;\n    float va2 = va * va;\n    float vb2 = vb * vb;\n    float uab = ua * va + ub * vb;\n    float uab2 = uab * uab;\n    float uabv = uab * vb;\n    float uab2v = uab2 * vb;\n    float uab2uabv = uab2 * uabv;\n    float uab2uab2v = uab2 * uab2v;\n    float uab2uab2uabv = uab2 * uab2 * uabv;\n    float uab2uab2uab2v = uab2 * uab2 * uab2 * vb;\n    float uab2uab2uab2uabv = uab2 * uab2 * uab2 * uabv;\n    float uab2uab2uab2uab2uabv = uab2 * uab2 * uab2 * uab2 * uabv;\n    float uab2uab2uab2uab2uab2uabv = uab2 * uab2 * uab2 * uab2 * uab2 * uabv;\n    float uab2uab2uab2uab2uab2uab2uabv = uab2 * uab2 * uab2 * uab2 * uab2 * uab2 * uabv;\n    float uab2uab2uab2uab2uab2uab2uab2uab2uabv = uab2 * uab2 * uab2 * uab2 * uab2 * uab2 * uab2 * uab2 * uabv;", "#include \"math.h\"\n    float u = uv.x;\n    float v = uv.y;\n    float u1 = u + thick;\n    float v1 = v + thick;\n    float u2 = u - thick;\n    float v2 = v - thick;\n    float u3 = u + thick;\n    float v3 = v - thick;\n    float u4 = u - thick;\n    float v4 = v + thick;\n    float u5 = u + thick;\n    float v5 = v + thick;\n    float u6 = u - thick;\n    float v6 = v - thick;\n    float u7 = u + thick;\n    float v7 = v + thick;\n    float u8 = u - thick;\n    float v8 = v - thick;\n    float u9 = u + thick;\n    float v9 = v + thick;\n    float u10 = u - thick;\n    float v10 = v - thick;\n    float u11 = u + thick;\n    float v11 = v + thick;\n    float u12 = u - thick;\n    float v12 = v - thick;\n    float u13 = u + thick;\n    float v13 = v + thick;\n    float u14 = u - thick;\n    float v14 = v - thick;\n    float u15 = u + thick;\n    float v15 = v + thick;\n    float u16 = u - thick;\n    float v16 = v - thick;\n    float u17 = u + thick;\n    float v17 = v + thick;\n    float u18 = u - thick;\n    float v18 = v - thick;\n    float u19 = u + thick;\n    float v19 = v + thick;\n    float u20 = u - thick;\n    float v20 = v - thick;\n    float u21 = u + thick;\n    float v21 = v + thick;\n    float u22 = u - thick;\n    float v22 = v - thick;\n    float u23 = u + thick;\n    float v23 = v + thick;\n    float u24 = u - thick;\n    float v24 = v - thick;\n    float u25", "#include <math.h>\n    float u = uv.x;\n    float v = uv.y;\n    float u1 = pA.x;\n    float v1 = pA.y;\n    float u2 = pB.x;\n    float v2 = pB.y;\n    float u3 = u1 + (u2 - u1) * (1.0 - v);\n    float v3 = v1 + (v2 - v1) * (1.0 - u);\n    float u4 = u1 + (u2 - u1) * v;\n    float v4 = v1 + (v2 - v1) * u;\n    float u5 = u1 + (u2 - u1) * (1.0 - v);\n    float v5 = v1 + (v2 - v1) * (1.0 - u);\n    float u6 = u1 + (u2 - u1) * v;\n    float v6 = v1 + (v2 - v1) * u;\n    float u7 = u1 + (u2 - u1) * (1.0 - v);\n    float v7 = v1 + (v2 - v1) * (1.0 - u);\n    float u8 = u1 + (u2 - u1) * v;\n    float v8 = v1 + (v2 - v1) * u;\n    float u9 = u1 + (u2 - u1) * (1.0 - v);\n    float v9 = v1 + (v2 - v1) * (1.0 - u);\n    float u10 = u1 + (u2 - u1) * v;\n    float v10 = v1 + (v2 - v1) * u;\n    float u11 = u1 + (u2 - u1) * (1.0 - v);\n    float v11 = v1 + (v2 - v1) * (1.0 - u);\n    float u12 = u1 + (u2 - u1) * v;\n    float v12 = v1 + (v2 - v1) * u;\n    float u13 = u1 + (u", "#define OUTLINE_THICK 1.0\n    float u = uv.x;\n    float v = uv.y;\n    float u1 = u + thick;\n    float v1 = v + thick;\n    float u2 = u - thick;\n    float v2 = v - thick;\n    float u3 = u + thick;\n    float v3 = v + thick;\n    float u4 = u - thick;\n    float v4 = v - thick;\n    float u5 = u + thick;\n    float v5 = v + thick;\n    float u6 = u - thick;\n    float v6 = v - thick;\n    float u7 = u + thick;\n    float v7 = v + thick;\n    float u8 = u - thick;\n    float v8 = v - thick;\n    float u9 = u + thick;\n    float v9 = v + thick;\n    float u10 = u - thick;\n    float v10 = v - thick;\n    float u11 = u + thick;\n    float v11 = v + thick;\n    float u12 = u - thick;\n    float v12 = v - thick;\n    float u13 = u + thick;\n    float v13 = v + thick;\n    float u14 = u - thick;\n    float v14 = v - thick;\n    float u15 = u + thick;\n    float v15 = v + thick;\n    float u16 = u - thick;\n    float v16 = v - thick;\n    float u17 = u + thick;\n    float v17 = v + thick;\n    float u18 = u - thick;\n    float v18 = v - thick;\n    float u19 = u + thick;\n    float v19 = v + thick;\n    float u20 = u - thick;\n    float v20 = v - thick;\n    float u21 = u + thick;\n    float v21 = v + thick;\n    float u22 = u - thick;\n    float v22 = v - thick;\n    float u23 = u + thick;\n    float v23 = v + thick;\n    float u24 = u - thick;\n    float v24 = v - thick;\n    ", "QVector3D p3 = p;\n    vec3 p3u = p3.xyz;\n    vec3 p3v = p3.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3v.xyz;\n    vec3 p3u = p3u.xyz;\n    vec3 p3v = p3", "\n    float d = dot( rd, nor );\n    if( d < 0.0f )\n        return 0.0f;\n    float t = (dot( ro - cen, nor ) + rad ) / d;\n    if( t < 0.0f )\n        return 0.0f;\n    if( t > 1.0f )\n        return 1.0f;\n    return t;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rd2 )\n{\n    float d = dot( rd, rd2 );\n    if( d < 0.0f )\n        return 0.0f;\n    float t = (dot( ro - cen, rd ) + sqrt( d ) ) / d;\n    if( t < 0.0f )\n        return 0.0f;\n    if( t > 1.0f )\n        return 1.0f;\n    return t;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 pn )\n{\n    float d = dot( rd, pn );\n    if( d < 0.0f )\n        return 0.0f;\n    float t = (dot( ro - pn, pn ) - d ) / d;\n    if( t < 0.0f )\n        return 0.0f;\n    if( t > 1.0f )\n        return 1.0f;\n    return t;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 pn )\n{\n    float d = dot( rd, pn );\n    if( d < 0.0f )\n        return 0.0f;\n    float t = (dot( ro - pn, pn ) - d ) / d;\n    if( t < 0.0f )\n        return 0.0f;\n    if( t > 1.0f )\n        return 1.0f;\n    return t;\n}\n\n// ray-plane intersection\nfloat i", "    \n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 s = rd - ro;\n    vec3 t = r - s;\n    vec3 u = t * (d.dot(t) / (s.dot(s)));\n    vec3 v = s * (u / (d.dot(u)));\n    vec3 w = r - u - v;\n    return (cen + u + v) * rad;\n}\n\n// ray-box intersection (full)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{    \n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 s = rd - ro;\n    vec3 t = r - s;\n    vec3 u = t * (d.dot(t) / (s.dot(s)));\n    vec3 v = s * (u / (d.dot(u)));\n    vec3 w = r - u - v;\n    return (cen + u + v) * rad;\n}\n\n// ray-box intersection (vectorized)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{    \n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 s = rd - ro;\n    vec3 t = r - s;\n    vec3 u = t * (d.dot(t) / (s.dot(s)));\n    vec3 v = s * (u / (d.dot(u)));\n    vec3 w = r - u - v;\n    return (cen + u + v) * rad;\n}\n\n// ray-box intersection (vectorized)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{    \n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 s = rd - ro;\n    vec3", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    // gl_ARB_version_major_minor_major\n    // gl_ARB_version_major_minor_minor\n    // gl_ARB_version_major_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor\n    // gl_ARB_version_major_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_minor_", "    \n    vec3 r = ro - pa;\n    vec3 d = pb - pa;\n    float t = dot( r, d ) / (dot( r, r ) * dot( d, d ) + ra * ra );\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,0.0);\n    vec3 n = (d / (dot( r, d ) + ra * ra ));\n    return vec4(t,n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{    \n    vec3 r = ro - pa;\n    vec3 d = pb - pa;\n    float t = dot( r, d ) / (dot( r, r ) * dot( d, d ) + ra * ra );\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,0.0);\n    vec3 n = (d / (dot( r, d ) + ra * ra ));\n    return vec4(t,n);\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in vec3 pd ) // point a, point b, point c, normal\n{    \n    vec3 n = pd - pa;\n    float t = dot( rd, n ) / (dot( rd, rd ) * dot( n, n ) + 1.0 );\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,0.0);\n    vec3 n = (n / (dot( rd, n ) + 1.0 ));\n    return vec4(t,n);\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane2( in vec3 ro, in vec3 rd, \n                in vec3 pa, in", "\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 n = cross( r, d );\n    vec3 dn = dot( n, d );\n    if ( dn < 0 ) return vec3(0,0);\n    vec3 t = (rad - dn) / dn;\n    return cen + t * d;\n}\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 n = cross( r, d );\n    vec3 dn = dot( n, d );\n    if ( dn < 0 ) return vec3(0,0);\n    vec3 t = (rad - dn) / dn;\n    return cen + t * d;\n}\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 n = cross( r, d );\n    vec3 dn = dot( n, d );\n    if ( dn < 0 ) return vec3(0,0);\n    vec3 t = (rad - dn) / dn;\n    return cen + t * d;\n}\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 n = cross( r, d );\n    vec3 dn = dot( n, d );\n    if ( dn < 0 ) return vec3(0,0);\n    vec3 t = (rad - dn) / dn;\n    return cen + t * d;\n}\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec", "\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.", "    \n    vec3 n = (a-b).normalize();\n    vec3 c = (pos-a).normalize();\n    vec3 s = (pos-b).normalize();\n    vec3 t = (n*c).normalize();\n    vec3 u = (n*s).normalize();\n    vec3 v = (c*s).normalize();\n    vec3 w = (c*t).normalize();\n    vec3 x = (s*t).normalize();\n    vec3 y = (t*u).normalize();\n    vec3 z = (u*v).normalize();\n    vec3 nn = (n*n).normalize();\n    vec3 nn2 = (n*n2).normalize();\n    vec3 nn3 = (n*n3).normalize();\n    vec3 nn4 = (n*n4).normalize();\n    vec3 nn5 = (n*n5).normalize();\n    vec3 nn6 = (n*n6).normalize();\n    vec3 nn7 = (n*n7).normalize();\n    vec3 nn8 = (n*n8).normalize();\n    vec3 nn9 = (n*n9).normalize();\n    vec3 nn10 = (n*n10).normalize();\n    vec3 nn11 = (n*n11).normalize();\n    vec3 nn12 = (n*n12).normalize();\n    vec3 nn13 = (n*n13).normalize();\n    vec3 nn14 = (n*n14).normalize();\n    vec3 nn15 = (n*n15).normalize();\n    vec3 nn16 = (n*n16).normalize();\n    vec3 nn17 = (n*n17).normalize();\n    vec3 nn18 = (n*n18).normalize();\n    vec3 nn19 = (n*n19).normalize();\n    vec3 nn20 = (n*n20).normalize();\n    vec3 nn21 = (n*n21).normalize();\n    vec3 nn22 = (n*n22).normalize", "    \n    vec3 r = ro + rad;\n    vec3 d = rd - ro;\n    vec3 s = d.cross(r);\n    vec3 t = d.dot(r);\n    if( t < 0.0 ) return vec3(0.0,0.0);\n    if( t > 1.0 ) return vec3(1.0,1.0);\n    return s.normalize() * t;\n}\n\n// ray-box intersection in world space\nvec2 iWorld( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 w ) \n{    \n    vec3 r = ro + rad;\n    vec3 d = rd - ro;\n    vec3 s = d.cross(r);\n    vec3 t = d.dot(r);\n    if( t < 0.0 ) return vec3(0.0,0.0);\n    if( t > 1.0 ) return vec3(1.0,1.0);\n    return s.normalize() * t * w;\n}\n\n// ray-box intersection in world space\nvec2 iWorld2( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 w ) \n{    \n    vec3 r = ro + rad;\n    vec3 d = rd - ro;\n    vec3 s = d.cross(r);\n    vec3 t = d.dot(r);\n    if( t < 0.0 ) return vec3(0.0,0.0);\n    if( t > 1.0 ) return vec3(1.0,1.0);\n    return s.normalize() * t * w;\n}\n\n// ray-box intersection in world space\nvec2 iWorld3( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 w ) \n{    \n    vec3 r = ro + rad;\n    vec3 d = rd - ro;\n    vec3 s = d.cross(r);\n    vec3 t = d.dot(r);\n    if( t < 0.0 ) return vec3(0.0,0.0);\n    if( t > 1.0", "    \n    vec3 a = ro - rd;\n    vec3 b = raymarch( a, invert( a ) );\n    vec3 c = raymarch( a, invert( b ) );\n    vec3 d = raymarch( a, invert( c ) );\n    vec3 e = raymarch( a, invert( d ) );\n    vec3 f = raymarch( a, invert( e ) );\n    vec3 g = raymarch( a, invert( f ) );\n    vec3 h = raymarch( a, invert( g ) );\n    vec3 i = raymarch( a, invert( h ) );\n    vec3 j = raymarch( a, invert( i ) );\n    vec3 k = raymarch( a, invert( j ) );\n    vec3 l = raymarch( a, invert( k ) );\n    vec3 m = raymarch( a, invert( l ) );\n    vec3 n = raymarch( a, invert( m ) );\n    vec3 o = raymarch( a, invert( n ) );\n    vec3 p = raymarch( a, invert( o ) );\n    vec3 q = raymarch( a, invert( p ) );\n    vec3 r = raymarch( a, invert( q ) );\n    vec3 s = raymarch( a, invert( r ) );\n    vec3 t = raymarch( a, invert( s ) );\n    vec3 u = raymarch( a, invert( t ) );\n    vec3 v = raymarch( a, invert( u ) );\n    vec3 w = raymarch( a, invert( v ) );\n    vec3 x = raymarch( a, invert( w ) );\n    vec3 y = raymarch( a, invert( x ) );\n    vec3 z = raymarch( a, invert( y ) );\n    vec3 aa = a + rd;\n    vec3 bb = b + rd;\n    vec3 cc = c + rd;\n    vec3 dd = d + rd;\n    vec3", "\n    vec3 f = (vec3)0;\n    if (i == 0)\n        f = (vec3)0;\n    else if (i == 1)\n        f = (vec3)1;\n    else\n    {\n        f = (vec3)0;\n        f[0] = (float)1;\n        f[1] = (float)1;\n        f[2] = (float)0;\n        for (int j = 3; j < n; j++)\n        {\n            f[0] = (float)0;\n            f[1] = (float)0;\n            f[2] = (float)0;\n            f[0] = (float)1;\n            f[1] = (float)1;\n            f[2] = (float)0;\n            for (int k = 0; k < j; k++)\n            {\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)1;\n                f[1] = (float)1;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f[1] = (float)0;\n                f[2] = (float)0;\n                f[0] = (float)0;\n                f", "\n    mat3 res = mat3(1,0,0,0,0,1,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0,0,0,0,0);\n    resS = mat3(0,0,0,0,0", "\n    vec2 p_noise = p + vec2(0.5, 0.5) * vec2(0.5, 0.5) * vec2(0.5, 0.5);\n    vec3 p_noise_xy = p_noise - p;\n    vec3 p_noise_yz = vec2(0.5, 0.5) * p_noise_xy;\n    return vec3(p_noise_xy, p_noise_yz);\n}\n\n// return the gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 p_noise = p + vec2(0.5, 0.5) * vec2(0.5, 0.5) * vec2(0.5, 0.5);\n    vec3 p_noise_xy = p_noise - p;\n    vec3 p_noise_yz = vec2(0.5, 0.5) * p_noise_xy;\n    return vec3(p_noise_xy, p_noise_yz);\n}\n\n// return the gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 p_noise = p + vec2(0.5, 0.5) * vec2(0.5, 0.5) * vec2(0.5, 0.5);\n    vec3 p_noise_xy = p_noise - p;\n    vec3 p_noise_yz = vec2(0.5, 0.5) * p_noise_xy;\n    return vec3(p_noise_xy, p_noise_yz);\n}\n\n// return the gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 p_noise = p + vec2(0.5, 0.5) * vec2(0.5, 0.5) * vec2(0.5, 0.5);\n    vec3 p_noise_xy = p_noise - p;\n    vec3", "\n    float dist = 0.0f;\n    float x = p.x - size.x / 2.0f;\n    float y = p.y - size.y / 2.0f;\n    float dx = x * x;\n    float dy = y * y;\n    float d = sqrt(dx + dy);\n    if (d > radius)\n    {\n        return d - radius;\n    }\n    else\n    {\n        return 0.0f;\n    }\n}\n\nfloat smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    float dist = 0.0f;\n    float x = p1.x - p2.x;\n    float y = p1.y - p2.y;\n    float dx = x * x;\n    float dy = y * y;\n    float d = sqrt(dx + dy);\n    if (d > radius)\n    {\n        return d - radius;\n    }\n    else\n    {\n        return 0.0f;\n    }\n}\n\nfloat smoothDistance(vec2 p1, vec2 p2, float radius)\n{\n    float dist = 0.0f;\n    float x = p1.x - p2.x;\n    float y = p1.y - p2.y;\n    float dx = x * x;\n    float dy = y * y;\n    float d = sqrt(dx + dy);\n    if (d > radius)\n    {\n        return d - radius;\n    }\n    else\n    {\n        return 0.0f;\n    }\n}\n\nfloat smoothDistance(vec2 p1, vec2 p2, float radius)\n{\n    float dist = 0.0f;\n    float x = p1.x - p2.x;\n    float y = p1.y - p2.y;\n    float dx = x * x;\n    float dy = y * y;\n    float d = sqrt(dx + dy);\n    if (d > radius)\n    {\n        return d - radius;\n    }\n    else\n    {\n        return 0.0f;\n    }\n}\n\n", "\n    vec2 u = uv - orient;\n    vec2 v = uv - orient.rotate(u.angle);\n    return u.length() < v.length()? u : v;\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient.rotate(uv.angle);\n    vec2 v = uv - orient.rotate(u.angle);\n    return u.length() < v.length()? u : v;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient.rotate(uv.angle);\n    vec2 v = uv - orient.rotate(u.angle + pi);\n    return u.length() < v.length()? u : v;\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient.rotate(uv.angle);\n    vec2 v = uv - orient.rotate(u.angle - pi);\n    return u.length() < v.length()? u : v;\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient.rotate(uv.angle);\n    vec2 v = uv - orient.rotate(u.angle + pi / 2);\n    return u.length() < v.length()? u : v;\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient.rotate(uv.angle);\n    vec2 v = uv - orient.rotate(u.angle - pi / 2);\n    return u.length() < v.length()? u : v;\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient.rotate(uv.angle);\n    vec2 v = uv - orient.rotate(u.angle + pi / 4);\n    return u.", "\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(u, v, 0.0);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(v, u, 0.0);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(0.0, v, u);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(v, 0.0, u);\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(0.0, v, u);\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(v, 0.0, u);\n}\n\n// Pattern 8\nvec3 pat8(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(0.0, v, u);\n}\n\n// Pattern 9\nvec3 pat9(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n    return vec3(v, 0.0, u);\n}\n\n// Pattern 10\nvec3 pat10(vec2 uv, vec2 orient)\n{\n    vec2 u = uv - orient;\n    vec2 v = cross(u, orient);\n", "    \n    float x = p.x;\n    float y = p.y;\n    float dx = ddx.x;\n    float dy = ddy.x;\n    float dx2 = dx*dx;\n    float dy2 = dy*dy;\n    float dxdy = dx*dy;\n    float dxdy2 = dxdy*dxdy;\n    float dxdy3 = dxdy*dxdy;\n    float dxdy4 = dxdy*dxdy;\n    float dxdy5 = dxdy*dxdy;\n    float dxdy6 = dxdy*dxdy;\n    float dxdy7 = dxdy*dxdy;\n    float dxdy8 = dxdy*dxdy;\n    float dxdy9 = dxdy*dxdy;\n    float dxdy10 = dxdy*dxdy;\n    float dxdy11 = dxdy*dxdy;\n    float dxdy12 = dxdy*dxdy;\n    float dxdy13 = dxdy*dxdy;\n    float dxdy14 = dxdy*dxdy;\n    float dxdy15 = dxdy*dxdy;\n    float dxdy16 = dxdy*dxdy;\n    float dxdy17 = dxdy*dxdy;\n    float dxdy18 = dxdy*dxdy;\n    float dxdy19 = dxdy*dxdy;\n    float dxdy20 = dxdy*dxdy;\n    float dxdy21 = dxdy*dxdy;\n    float dxdy22 = dxdy*dxdy;\n    float dxdy23 = dxdy*dxdy;\n    float dxdy24 = dxdy*dxdy;\n    float dxdy25 = dxdy*dxdy;\n    float dxdy26 = dxdy*dxdy;\n    float dxdy27 = dxdy*dxdy;\n    float dxdy28 = dxdy*dxdy;\n    float dxdy29 = dxdy*dxdy;\n    float dxdy30 = dxdy*dxdy;\n    float dxdy31 = dxdy*dxdy;\n    float dxdy32 = dxdy*dxdy;\n    float dxdy33 = dxdy*dxdy;\n    float dxdy34 = dxdy*dxdy;\n    float dxdy35 = dxdy*dxdy;\n", "\n    vec3 dmap = vec3(0.0,0.0,0.0);\n    dmap[0] = p[0]*p[1]*p[2] - p[0]*p[2]*p[1] - p[0]*p[1]*p[2] + p[0]*p[2]*p[1];\n    dmap[1] = p[0]*p[1]*p[2] - p[0]*p[2]*p[1] + p[0]*p[1]*p[2] - p[0]*p[2]*p[1];\n    dmap[2] = p[0]*p[1]*p[2] - p[0]*p[2]*p[1] - p[0]*p[1]*p[2] + p[0]*p[2]*p[1];\n    return dmap;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    vec3 dmap = vec3(0.0,0.0,0.0);\n    dmap[0] = p[0]*p[1]*p[2] - p[0]*p[2]*p[1] - p[0]*p[1]*p[2] + p[0]*p[2]*p[1];\n    dmap[1] = p[0]*p[1]*p[2] - p[0]*p[2]*p[1] + p[0]*p[1]*p[2] - p[0]*p[2]*p[1];\n    dmap[2] = p[0]*p[1]*p[2] - p[0]*p[2]*p[1] - p[0]*p[1]*p[2] + p[0]*p[2]*p[1];\n    return dmap;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in", "#pragma omp parallel for reduction(+:a)\n    a[0] = b[0];\n    a[1] = b[1];\n    a[2] = b[2];\n}\n\nI'm not sure what the reduction(+:a) is doing, but it seems to be a good idea.\n\nA:\n\nI'm not sure what the reduction(+:a) is doing, but it seems to be a good idea.\n\nIt is a good idea, but it is not the right idea.\nThe reduction(+:a) is a reduction of the sum of the values of the array a.\nThe reduction(+:a) is not a reduction of the sum of the values of the array a, but of the sum of the values of the array a, and the sum of the values of the array b.\nThe reduction(+:a) is not a reduction of the sum of the values of the array a, but of the sum of the values of the array a, and the sum of the values of the array b, and the sum of the values of the array b.\nThe reduction(+:a) is not a reduction of the sum of the values of the array a, but of the sum of the values of the array a, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b.\nThe reduction(+:a) is not a reduction of the sum of the values of the array a, but of the sum of the values of the array a, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array b, and the sum of the values of the array", "\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//returns the distance between two points\nvec3 dist(vec3 a,vec3 b){\n    return v33(a,b).length();\n}\n\n//returns the angle between two vectors\nfloat angle(vec3 a,vec3 b){\n    return acos(v33(a,b).dot(v33(a,a).inverse()*v33(b,b).inverse()));\n}\n\n//returns the angle between two vectors in degrees\nfloat angleDeg(vec3 a,vec3 b){\n    return acos(v33(a,b).dot(v33(a,a).inverse()*v33(b,b).inverse()))*180/3.14159;\n}\n\n//returns the angle between two vectors in radians\nfloat angleRad(vec3 a,vec3 b){\n    return acos(v33(a,b).dot(v33(a,a).inverse()*v33(b,b).inverse()))*3.14159/180;\n}\n\n//returns the angle between two vectors in degrees\nfloat angleDeg2(vec3 a,vec3 b){\n    return acos(v33(a,b).dot(v33(a,a).inverse()*v33(b,b).inverse()))*180/3.14159;\n}\n\n//returns the angle between two vectors in radians\nfloat angleRad2(vec3 a,vec3 b){\n    return acos(v33(a,b).dot(v33(a,a).inverse()*v33(b,b).inverse()))*3.14159/180;\n}\n\n//returns the angle between two vectors in degrees\nfloat angleDeg3(vec3 a,vec3 b){\n    return acos(v33(a,b).dot(v33(a,a).inverse()*v33(b,b).inverse()))*180/3.14159;\n}\n\n//returns the angle between two vectors in radians\n", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//compute the dot product of two vectors\nv33 dot(v33 a,v33 b){\n    return v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//compute the cross product of two vectors\nv33 cross(v33 a,v33 b){\n    return v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\n//compute the length of a vector\nv33 length(v33 a){\n    return sqrt(dot(a,a));\n}\n\n//compute the normal of a triangle\nv33 normal(v33 a,v33 b,v33 c){\n    v33 n = cross(subc(b,a),subc(c,a));\n    n.normalize();\n    return n;\n}\n\n//compute the distance from a point to a triangle\nv3d distance(v3d p,v3d a,v3d b,v3d c){\n    v3d n = normal(a,b,c);\n    v3d d = dot(subc(p,a),n);\n    return length(subc(p,a))-d;\n}\n\n//compute the distance from a point to a plane\nv3d distance(v3d p,v3d a,v3d b,v3d c){\n    v3d n = cross(subc(a,b),subc(a,c));\n    v3d d = dot(subc(p,a),n);\n    return length(subc(p,a))-d;\n}\n\n//compute the distance from a point to a line\nv3d distance(v3d p,v3d a,v3d b){\n    v3d n = subc(b,a);\n    v3d d = dot(subc(p,", "\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BB\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AB\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BA\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AB\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BA\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AB\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BA\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AB\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BA\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AB\nvec2 dt(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials", "\n    return a.x*b.x + a.y*b.y;\n}\n\n//compute the dot product of v33s\nvec3 dotprod(vec3 a,vec3 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//compute the cross product of v33s\nvec3 crossprod(vec3 a,vec3 b){\n    return vec3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//compute the magnitude of a vector\nfloat mag(vec3 a){\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\n//compute the angle between two vectors\nfloat angle(vec3 a,vec3 b){\n    return acos(dotprod(a,b)/(mag(a)*mag(b));\n}\n\n//compute the projection of a vector onto another\nvec3 proj(vec3 a,vec3 b){\n    return (a.x*b.x + a.y*b.y + a.z*b.z)/(mag(b)*mag(b));\n}\n\n//compute the orthogonal projection of a vector onto another\nvec3 orthproj(vec3 a,vec3 b){\n    return (a.x*b.y - a.y*b.x)/(mag(b)*mag(b));\n}\n\n//compute the projection of a vector onto the x-axis\nvec3 projx(vec3 a){\n    return vec3(a.x,0,0);\n}\n\n//compute the projection of a vector onto the y-axis\nvec3 projy(vec3 a){\n    return vec3(0,a.y,0);\n}\n\n//compute the projection of a vector onto the z-axis\nvec3 projz(vec3 a){\n    return vec3(0,0,a.z);\n}\n\n//", "\n    return vec2(a.x*b.x,a.y*b.y);\n}\n\n//dual mult\nv33 mul(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec4 b){\n    return vec4(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec5 b){\n    return vec5(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec6 b){\n    return vec6(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w,a.y*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec7 b){\n    return vec7(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w,a.y*b.w,a.z*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec8 b){\n    return vec8(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b.w,a.y*b.w,a.z*b.w,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,vec9 b){\n    return vec9(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w,a.x*b", "\n    float a=dot(p,w);\n    if(a<0.0f){\n        return 0.0f;\n    }\n    return 1.0f;\n}\n\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2(p,w)\n//checkerF2", "#pragma omp parallel for reduction(+:Fb)\n    Fb = 0.0;\n    for(int i=0;i<3;i++){\n        Fb += (p[i]*w[i])*(p[i]*w[i]);\n    }\n    return Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF4(vec3 p,vec3 w){#pragma omp parallel for reduction(+:Fb)\n    Fb = 0.0;\n    for(int i=0;i<3;i++){\n        Fb += (p[i]*w[i])*(p[i]*w[i]);\n    }\n    return Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF5(vec3 p,vec3 w){#pragma omp parallel for reduction(+:Fb)\n    Fb = 0.0;\n    for(int i=0;i<3;i++){\n        Fb += (p[i]*w[i])*(p[i]*w[i]);\n    }\n    return Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF6(vec3 p,vec3 w){#pragma omp parallel for reduction(+:Fb)\n    Fb = 0.0;\n    for(int i=0;i<3;i++){\n        Fb += (p[i]*w[i])*(p[i]*w[i]);\n    }\n    return Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2", "    //sphere softShadow of(ray,sphere)\n    vec3 rr = r.xyz;\n    vec3 rs = s.xyz;\n    vec3 rs2 = rs.xyz;\n    vec3 rs3 = rs.xyz;\n    vec3 rs4 = rs.xyz;\n    vec3 rs5 = rs.xyz;\n    vec3 rs6 = rs.xyz;\n    vec3 rs7 = rs.xyz;\n    vec3 rs8 = rs.xyz;\n    vec3 rs9 = rs.xyz;\n    vec3 rs10 = rs.xyz;\n    vec3 rs11 = rs.xyz;\n    vec3 rs12 = rs.xyz;\n    vec3 rs13 = rs.xyz;\n    vec3 rs14 = rs.xyz;\n    vec3 rs15 = rs.xyz;\n    vec3 rs16 = rs.xyz;\n    vec3 rs17 = rs.xyz;\n    vec3 rs18 = rs.xyz;\n    vec3 rs19 = rs.xyz;\n    vec3 rs20 = rs.xyz;\n    vec3 rs21 = rs.xyz;\n    vec3 rs22 = rs.xyz;\n    vec3 rs23 = rs.xyz;\n    vec3 rs24 = rs.xyz;\n    vec3 rs25 = rs.xyz;\n    vec3 rs26 = rs.xyz;\n    vec3 rs27 = rs.xyz;\n    vec3 rs28 = rs.xyz;\n    vec3 rs29 = rs.xyz;\n    vec3 rs30 = rs.xyz;\n    vec3 rs31 = rs.xyz;\n    vec3 rs32 = rs.xyz;\n    vec3 rs33 = rs.xyz;\n    vec3 rs34 = rs.xyz;\n    vec3 rs35 = rs.xyz;\n    vec3 rs36 = rs.xyz;\n    vec3 rs37 = rs.xyz;\n    vec3 rs38 = rs.xyz;\n    vec3 rs39 = rs.xyz;\n    vec3 rs40 = rs.xyz;\n    vec3 rs41 = rs", "    \n    vec3 v = u - s.position;\n    float d = dot(n,v);\n    if(d<0.0){\n        return 1.0;\n    }\n    float r = (s.radius + d) / s.radius;\n    return pow(r,2.0);\n}\n\n//sphere intersection\nvec3 sphereIntersection(vec3 u,vec3 n,vec4 s){\n    vec3 v = u - s.position;\n    float d = dot(n,v);\n    if(d<0.0){\n        return s.position;\n    }\n    float r = (s.radius + d) / s.radius;\n    vec3 t = v - n*d;\n    vec3 p = s.position + t*r;\n    return p;\n}\n\n//sphere intersection\nvec3 sphereIntersection(vec3 u,vec3 n,vec4 s){\n    vec3 v = u - s.position;\n    float d = dot(n,v);\n    if(d<0.0){\n        return s.position;\n    }\n    float r = (s.radius + d) / s.radius;\n    vec3 t = v - n*d;\n    vec3 p = s.position + t*r;\n    return p;\n}\n\n//sphere intersection\nvec3 sphereIntersection(vec3 u,vec3 n,vec4 s){\n    vec3 v = u - s.position;\n    float d = dot(n,v);\n    if(d<0.0){\n        return s.position;\n    }\n    float r = (s.radius + d) / s.radius;\n    vec3 t = v - n*d;\n    vec3 p = s.position + t*r;\n    return p;\n}\n\n//sphere intersection\nvec3 sphereIntersection(vec3 u,vec3 n,vec4 s){\n    vec3 v = u - s.position;\n    float d = dot(n,v);\n    if(d<0.0){\n        return s.position;\n    }\n    float r = (s.radius + d) / s.radius", "    \n    vec2 p3 = p0 + p1 - p2;\n    vec2 p4 = p1 + p2 - p0;\n    vec2 p5 = p2 + p0 - p1;\n    vec2 p6 = p0 + p1 + p2;\n\n    vec2 p7 = p0 + p1 - p2;\n    vec2 p8 = p1 + p2 - p0;\n    vec2 p9 = p2 + p0 - p1;\n\n    vec2 p10 = p0 + p1 + p2;\n    vec2 p11 = p1 + p2 + p0;\n    vec2 p12 = p2 + p0 + p1;\n\n    vec2 p13 = p0 + p1 - p2;\n    vec2 p14 = p1 + p2 - p0;\n    vec2 p15 = p2 + p0 - p1;\n\n    vec2 p16 = p0 + p1 + p2;\n    vec2 p17 = p1 + p2 + p0;\n    vec2 p18 = p2 + p0 + p1;\n\n    vec2 p19 = p0 + p1 - p2;\n    vec2 p20 = p1 + p2 - p0;\n    vec2 p21 = p2 + p0 - p1;\n\n    vec2 p22 = p0 + p1 + p2;\n    vec2 p23 = p1 + p2 + p0;\n    vec2 p24 = p2 + p0 + p1;\n\n    vec2 p25 = p0 + p1 - p2;\n    vec2 p26 = p1 + p2 - p0;\n    vec2 p27 = p2 + p0 - p1;\n\n    vec2 p28 = p0 + p1 + p2;\n    vec2 p29 = p1 + p2 + p0;\n    vec2 p30 = p2 + p0 + p1;\n\n    vec2 p31 = p0 + p1 - p2;\n    vec2 p32 = p1 + p2 - p0;\n    vec2 p33 = p2 + p0 - p1;\n\n    vec2 p34 = p0 + p1 + p2", "\n    vec2 p3 = p0 + p1 - p2;\n    vec2 p4 = p1 + p2 - p0;\n    vec2 p5 = p2 + p0 - p1;\n    vec2 p6 = p0 + p1 + p2;\n    vec2 p7 = p1 + p2 + p0;\n    vec2 p8 = p2 + p0 + p1;\n    vec2 p9 = p0 + p1 + p2;\n    vec2 p10 = p1 + p2 + p0;\n    vec2 p11 = p2 + p0 + p1;\n    vec2 p12 = p0 + p1 + p2;\n    vec2 p13 = p1 + p2 + p0;\n    vec2 p14 = p2 + p0 + p1;\n    vec2 p15 = p0 + p1 + p2;\n    vec2 p16 = p1 + p2 + p0;\n    vec2 p17 = p2 + p0 + p1;\n    vec2 p18 = p0 + p1 + p2;\n    vec2 p19 = p1 + p2 + p0;\n    vec2 p20 = p2 + p0 + p1;\n    vec2 p21 = p0 + p1 + p2;\n    vec2 p22 = p1 + p2 + p0;\n    vec2 p23 = p2 + p0 + p1;\n    vec2 p24 = p0 + p1 + p2;\n    vec2 p25 = p1 + p2 + p0;\n    vec2 p26 = p2 + p0 + p1;\n    vec2 p27 = p0 + p1 + p2;\n    vec2 p28 = p1 + p2 + p0;\n    vec2 p29 = p2 + p0 + p1;\n    vec2 p30 = p0 + p1 + p2;\n    vec2 p31 = p1 + p2 + p0;\n    vec2 p32 = p2 + p0 + p1;\n    vec2 p33 = p0 + p1 + p2;\n    vec2 p34 = p1 + p2 + p0;", "\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.mathworks.com/matlabcentral/fileexchange/527-bbox-of-a-bezier-curve\n    // http://www.math", "    \n    vec2 p0p1 = p1 - p0;\n    vec2 p1p2 = p2 - p1;\n    vec2 p2p3 = p3 - p2;\n    vec2 p0p2 = p2 - p0;\n    vec2 p0p3 = p3 - p0;\n    vec2 p1p3 = p3 - p1;\n\n    vec2 p0p1p2 = p0p1 + p1p2;\n    vec2 p0p1p2p3 = p0p1p2 + p2p3;\n    vec2 p0p1p2p3p4 = p0p1p2p3 + p3p4;\n\n    vec2 p0p1p2p3p4 = p0p1p2p3p4 + p0p2;\n    vec2 p0p1p2p3p4p5 = p0p1p2p3p4 + p1p5;\n    vec2 p0p1p2p3p4p5p6 = p0p1p2p3p4 + p2p6;\n    vec2 p0p1p2p3p4p5p6p7 = p0p1p2p3p4 + p3p7;\n    vec2 p0p1p2p3p4p5p6p7p8 = p0p1p2p3p4 + p4p8;\n    vec2 p0p1p2p3p4p5p6p7p8p9 = p0p1p2p3p4 + p5p9;\n    vec2 p0p1p2p3p4p5p6p7p8p9p10 = p0p1p2p3p4 + p6p10;\n    vec2 p0p1p2p3p4p5p6p7p8p9p10p11 = p0p1p2p3p4 + p7p11;\n    vec2 p0p1p2p3p4p5p6p7p8p9p10p11p12 = p0p1p2p3p4 +", "#ifdef DEBUG\n    cout << \"udBezier: p0 = \" << p0 << \", p1 = \" << p1 << \", p2 = \" << p2 << \", p3 = \" << p3 << \", pos = \" << pos << endl;\n#endif\n    vec2 u = p3 - p0;\n    vec2 v = p1 - p0;\n    vec2 w = p2 - p0;\n    vec2 uv = u.cross(v);\n    vec2 uw = u.cross(w);\n    vec2 uvw = uv.cross(w);\n    vec2 uvw_inv = uvw.invert();\n    vec2 uvw_inv_u = uvw_inv.cross(u);\n    vec2 uvw_inv_v = uvw_inv.cross(v);\n    vec2 uvw_inv_w = uvw_inv.cross(w);\n    vec2 uvw_inv_u_u = uvw_inv_u.cross(u);\n    vec2 uvw_inv_v_v = uvw_inv_v.cross(v);\n    vec2 uvw_inv_w_w = uvw_inv_w.cross(w);\n    vec2 uvw_inv_u_v = uvw_inv_u.cross(v);\n    vec2 uvw_inv_v_u = uvw_inv_v.cross(u);\n    vec2 uvw_inv_w_u = uvw_inv_w.cross(u);\n    vec2 uvw_inv_u_w = uvw_inv_u.cross(w);\n    vec2 uvw_inv_v_w = uvw_inv_v.cross(w);\n    vec2 uvw_inv_w_v = uvw_inv_w.cross(v);\n    vec2 uvw_inv_u_v_u = uvw_inv_u_v.cross(u);\n    vec2 uvw_inv_v_v_v = uvw_inv_v_v", "\n    vec3 t, u, v;\n    float s, tt, uu, vv;\n\n    // Compute the vectors from the origin to the vertices\n    vec3 v0v1 = v1 - v0;\n    vec3 v1v2 = v2 - v1;\n    vec3 v0v2 = v2 - v0;\n\n    // Compute the vectors from the origin to the edges\n    vec3 e0v0 = v0 - ro;\n    vec3 e0v1 = v1 - ro;\n    vec3 e0v2 = v2 - ro;\n\n    // Compute the vectors from the origin to the triangle\n    vec3 e1v0 = v0v1;\n    vec3 e1v1 = v1v2;\n    vec3 e1v2 = v2v0;\n\n    // Compute the vectors from the origin to the triangle edge\n    vec3 e2v0 = v0v1;\n    vec3 e2v1 = v1v2;\n    vec3 e2v2 = v2v0;\n\n    // Compute the vectors from the origin to the triangle vertex\n    vec3 e3v0 = v0v2;\n    vec3 e3v1 = v1v0;\n    vec3 e3v2 = v2v1;\n\n    // Compute the vectors from the origin to the triangle edge\n    vec3 e4v0 = v0v2;\n    vec3 e4v1 = v1v0;\n    vec3 e4v2 = v2v1;\n\n    // Compute the vectors from the origin to the triangle vertex\n    vec3 e5v0 = v0v1;\n    vec3 e5v1 = v1v2;\n    vec3 e5v2 = v2v0;\n\n    // Compute the vectors from the origin to the triangle edge\n    vec3 e6v0 = v0v1;\n    vec3 e6v1 = v1v2;\n    vec3 e6v2 = v2v0;\n\n    // Compute the vectors from the origin to the triangle vertex\n    vec3 e7v0 = v0v2;\n    vec3 e7v1 = v1", "\n    float a = dot( v0, v1 ) - dot( v0, v2 );\n    float b = dot( v1, v2 ) - dot( v1, v0 );\n    float c = dot( v2, v0 ) - dot( v2, v1 );\n    float d = 2.0f * ( a * ( nor.x * v0.x + nor.y * v0.y + nor.z * v0.z ) +\n                      b * ( nor.x * v1.x + nor.y * v1.y + nor.z * v1.z ) +\n                      c * ( nor.x * v2.x + nor.y * v2.y + nor.z * v2.z ) );\n    float e = dot( v0, v0 ) - dot( v1, v1 ) - dot( v2, v2 );\n    float f = 2.0f * ( a * ( nor.x * v0.x + nor.y * v0.y + nor.z * v0.z ) +\n                      b * ( nor.x * v1.x + nor.y * v1.y + nor.z * v1.z ) +\n                      c * ( nor.x * v2.x + nor.y * v2.y + nor.z * v2.z ) );\n    float g = dot( v1, v1 ) - dot( v0, v0 ) - dot( v2, v2 );\n    float h = 2.0f * ( a * ( nor.x * v1.x + nor.y * v1.y + nor.z * v1.z ) +\n                      b * ( nor.x * v2.x + nor.y * v2.y + nor.z * v2.z ) +\n                      c * ( nor.x * v0.x + nor.y * v0.y + nor.z * v0.z ) );\n    float i = dot( v2, v2 ) - dot( v0, v0 ) - dot( v1, v1 );\n    float j = 2.0f * ( a * ( nor.x * v2.x + nor.y * v2", "\n    float x = pos.x;\n    float y = pos.y;\n    float a = A.x - x;\n    float b = A.y - y;\n    float c = B.x - x;\n    float d = B.y - y;\n    float e = C.x - x;\n    float f = C.y - y;\n    float g = a*a + b*b;\n    float h = c*c + d*d;\n    float i = e*e + f*f;\n    float j = 2*a*c + 2*b*d;\n    float k = 2*a*e + 2*b*f;\n    float l = a*a*i + b*b*j + c*c*k;\n    float m = 2*a*c*i + 2*b*d*j + 2*a*e*k;\n    float n = 2*b*c*i + 2*a*d*j + 2*b*e*k;\n    float o = a*a*l + b*b*m + c*c*n;\n    float p = 2*a*c*l + 2*b*d*m + 2*a*e*n;\n    float q = 2*b*c*l + 2*a*d*m + 2*b*e*n;\n    float r = a*a*o + b*b*p + c*c*q;\n    float s = 2*a*c*o + 2*b*d*p + 2*a*e*q;\n    float t = 2*b*c*o + 2*a*d*p + 2*b*e*q;\n    float u = a*a*r + b*b*s + c*c*t;\n    float v = 2*a*c*r + 2*b*d*s + 2*a*e*t;\n    float w = 2*b*c*r + 2*a*d*s + 2*b*e*t;\n    float x = (a*a*u + b*b*v + c*c*w) / (g*g);\n", "\n    float h = p.y - he;\n    float s = sqrt(r1*r1 + h*h);\n    float t = sqrt(r2*r2 + h*h);\n    float a = (r1 + r2) / 2.0;\n    float b = (r1 - r2) / 2.0;\n    float c = (r1 + r2) / 2.0;\n    float d = (r1 - r2) / 2.0;\n    float e = sqrt(a*a + b*b);\n    float f = sqrt(c*c + d*d);\n    float g = sqrt(a*a + c*c);\n    float h = sqrt(b*b + d*d);\n    float i = sqrt(e*e + f*f);\n    float j = sqrt(g*g + h*h);\n    float k = sqrt(e*e + f*f);\n    float l = sqrt(g*g + h*h);\n    float m = sqrt(e*e + f*f);\n    float n = sqrt(g*g + h*h);\n    float o = sqrt(e*e + f*f);\n    float p = sqrt(g*g + h*h);\n    float q = sqrt(e*e + f*f);\n    float r = sqrt(g*g + h*h);\n    float s = sqrt(e*e + f*f);\n    float t = sqrt(g*g + h*h);\n    float u = sqrt(e*e + f*f);\n    float v = sqrt(g*g + h*h);\n    float w = sqrt(e*e + f*f);\n    float x = sqrt(g*g + h*h);\n    float y = sqrt(e*e + f*f);\n    float z = sqrt(g*g + h*h);\n    float aa = a*a;\n    float ab = a*b;\n    float ac = a*c;\n    float ad = a*d;\n    float ae = a*", "\n    float s = (b-a).x;\n    float h = (b-a).y;\n    float r = sqrt(a.x*a.x + a.y*a.y);\n    float h2 = h*h;\n    float r2 = r*r;\n    float ra2 = ra*ra;\n    float rb2 = rb*rb;\n    float s2 = s*s;\n    float h2s = h2*s;\n    float h2ra = h2*ra;\n    float h2rb = h2*rb;\n    float h2s2 = h2s*s2;\n    float h2ra2 = h2ra*ra2;\n    float h2rb2 = h2rb*rb2;\n    float h2s2ra = h2s2*ra2;\n    float h2s2rb = h2s2*rb2;\n    float h2s2ra2 = h2s2ra*ra2;\n    float h2s2rb2 = h2s2rb*rb2;\n    float h2s2ra2rb = h2s2ra2*rb2;\n    float h2s2rb2ra = h2s2rb2*ra2;\n    float h2s2ra2rb2 = h2s2ra2rb*rb2;\n    float h2s2rb2ra2 = h2s2rb2ra*rb2;\n    float h2s2rb2ra2rb = h2s2rb2ra2*rb2;\n    float h2s2rb2ra2rb2 = h2s2rb2ra2rb*rb2;\n    float h2s2rb2ra2rb2ra = h2s2rb2ra2rb2*ra2;\n    float h2s2rb2ra2rb2ra2 = h2s2rb2ra2rb2ra*rb2;\n    float h2s2rb2ra2rb2ra2rb = h2s2rb2ra2rb2ra2*rb2;\n    float h2s2rb2ra2rb2ra2rb2 = h2s2rb2ra2", "\n    vec3 normal;\n    vec3 v1 = vec3( pos.x - vec3(0.5,0.5,0.5), pos.y - vec3(0.5,0.5,0.5), pos.z - vec3(0.5,0.5,0.5) );\n    vec3 v2 = vec3( pos.x - vec3(0.5,0.5,0.5), pos.y - vec3(0.5,0.5,0.5), pos.z - vec3(0.5,0.5,0.5) );\n    normal = v1.cross( v2 );\n    normal.normalize();\n    return normal;\n}\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of two vectors to get a normal vector.\n\nA:\n\nYou can use the cross product of", "\n    float t = (tmin + tmax) * 0.5f;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41 * t;\n    float t43 = t42 * t;\n    float t44 = t43 * t;\n    float t45 = t44 * t;\n    float t46 = t45 * t;", "\n    float h = 0.0f;\n    for( int i = 0; i < q.x; i++ )\n    {\n        h += q.x[i] * q.x[i];\n    }\n    for( int i = 0; i < q.y; i++ )\n    {\n        h += q.y[i] * q.y[i];\n    }\n    return h;\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    float h = 0.0f;\n    for( int i = 0; i < q.x; i++ )\n    {\n        h += q.x[i] * q.x[i];\n    }\n    for( int i = 0; i < q.y; i++ )\n    {\n        h += q.y[i] * q.y[i];\n    }\n    return h;\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    float h = 0.0f;\n    for( int i = 0; i < q.x; i++ )\n    {\n        h += q.x[i] * q.x[i];\n    }\n    for( int i = 0; i < q.y; i++ )\n    {\n        h += q.y[i] * q.y[i];\n    }\n    return h;\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    float h = 0.0f;\n    for( int i = 0; i < q.x; i++ )\n    {\n        h += q.x[i] * q.x[i];\n    }\n    for( int i = 0; i < q.y; i++ )\n    {\n        h += q.y[i] * q.y[i];\n    }\n    return h;\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    float h = 0.0f;\n    for( int i = 0; i < q.x; i++ )\n    {\n        h += q.x[i] * q.", "    \n    float x_noise = (float)rand()/RAND_MAX;\n    float y_noise = (float)rand()/RAND_MAX;\n    float noise_val = x_noise*x_noise + y_noise*y_noise;\n    float noise_val = noise_val*p;\n    return noise_val;\n}\n\n// noise function for a single pixel\nfloat noise_pixel( in vec2 p )\n{\n    float x = p.x;\n    float y = p.y;\n    float noise_val = noise( x, p.x );\n    float noise_val = noise( y, p.y );\n    return noise_val;\n}\n\n// noise function for a single pixel\nfloat noise_pixel( in vec2 p )\n{\n    float x = p.x;\n    float y = p.y;\n    float noise_val = noise( x, p.x );\n    float noise_val = noise( y, p.y );\n    return noise_val;\n}\n\n// noise function for a single pixel\nfloat noise_pixel( in vec2 p )\n{\n    float x = p.x;\n    float y = p.y;\n    float noise_val = noise( x, p.x );\n    float noise_val = noise( y, p.y );\n    return noise_val;\n}\n\n// noise function for a single pixel\nfloat noise_pixel( in vec2 p )\n{\n    float x = p.x;\n    float y = p.y;\n    float noise_val = noise( x, p.x );\n    float noise_val = noise( y, p.y );\n    return noise_val;\n}\n\n// noise function for a single pixel\nfloat noise_pixel( in vec2 p )\n{\n    float x = p.x;\n    float y = p.y;\n    float noise_val = noise( x, p.x );\n    float noise_val = noise( y, p.y );\n    return noise_val;\n}\n\n// noise function for a single pixel\nfloat noise_pixel( in vec2 p )\n{\n    float x = p.", "\n    float x0 = x.x;\n    float x1 = x.y;\n    float x2 = x.x*x.x + x.y*x.y;\n    float x3 = x2*x2 + x0*x0;\n    float x4 = x3*x3 + x1*x1;\n    float x5 = x4*x4 + x2*x2;\n    float x6 = x5*x5 + x0*x0;\n    float x7 = x6*x6 + x1*x1;\n    float x8 = x7*x7 + x2*x2;\n    float x9 = x8*x8 + x0*x0;\n    float x10 = x9*x9 + x1*x1;\n    float x11 = x10*x10 + x2*x2;\n    float x12 = x11*x11 + x0*x0;\n    float x13 = x12*x12 + x1*x1;\n    float x14 = x13*x13 + x2*x2;\n    float x15 = x14*x14 + x0*x0;\n    float x16 = x15*x15 + x1*x1;\n    float x17 = x16*x16 + x2*x2;\n    float x18 = x17*x17 + x0*x0;\n    float x19 = x18*x18 + x1*x1;\n    float x20 = x19*x19 + x2*x2;\n    float x21 = x20*x20 + x0*x0;\n    float x22 = x21*x21 + x1*x1;\n    float x23 = x22*x22 + x2*x2;\n    float x24 = x23*x23 + x0*x0;\n    float x25 = x24*x24 + x1*x1;\n    float x26 = x25*x25 + x2*x2;\n    float x27 = x26*x26 + x0*x0;\n    float x28 = x27*x27 + x1*x1;\n    ", "\n    float a = r.x;\n    float b = r.y;\n    float c = r.z;\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float e = sqrt(a*a + b*b + c*c);\n    float f = sqrt(a*a + b*b + c*c);\n    float g = sqrt(a*a + b*b + c*c);\n    float h = sqrt(a*a + b*b + c*c);\n    float i = sqrt(a*a + b*b + c*c);\n    float j = sqrt(a*a + b*b + c*c);\n    float k = sqrt(a*a + b*b + c*c);\n    float l = sqrt(a*a + b*b + c*c);\n    float m = sqrt(a*a + b*b + c*c);\n    float n = sqrt(a*a + b*b + c*c);\n    float o = sqrt(a*a + b*b + c*c);\n    float p = sqrt(a*a + b*b + c*c);\n    float q = sqrt(a*a + b*b + c*c);\n    float r = sqrt(a*a + b*b + c*c);\n    float s = sqrt(a*a + b*b + c*c);\n    float t = sqrt(a*a + b*b + c*c);\n    float u = sqrt(a*a + b*b + c*c);\n    float v = sqrt(a*a + b*b + c*c);\n    float w = sqrt(a*a + b*b + c*c);\n    float x = sqrt(a*a + b*b + c*c);\n    float y = sqrt(a*a + b*b + c*c);\n    float z = sqrt(a*a + b*b + c*c);\n    float a1 = a*a;\n    float", "    \n    float x = p.x - r.x;\n    float y = p.y - r.y;\n    float z = p.z - r.z;\n    float s = sqrt(x*x + y*y + z*z);\n    return (1.0 - (s/r.z) * (s/r.z));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec2 r ) \n{    \n    float x = p.x - r.x;\n    float y = p.y - r.y;\n    float z = p.z - r.z;\n    float s = sqrt(x*x + y*y + z*z);\n    return (1.0 - (s/r.y) * (s/r.y));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZY( in vec3 p, in vec2 r ) \n{    \n    float x = p.x - r.x;\n    float y = p.y - r.y;\n    float z = p.z - r.z;\n    float s = sqrt(x*x + y*y + z*z);\n    return (1.0 - (s/r.x) * (s/r.x));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYZX( in vec3 p, in vec2 r ) \n{    \n    float x = p.x - r.x;\n    float y = p.y - r.y;\n    float z = p.z - r.z;\n    float s = sqrt(x*x + y*y + z*z);\n    return (1.0 - (s/r.y) * (s/r.y));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZXY( in vec3 p, in vec2 r ) \n{    \n    float x = p.x - r.x;\n    float y = p.y - r.y", "\n    float d = 0.0;\n    for( int i = 0; i < 3; ++i )\n    {\n        d += (p[i] - r[i]) * (p[i] - r[i]);\n    }\n    return sqrt(d);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good( in vec3 p, in vec3 r ) \n{\n    float d = 0.0;\n    for( int i = 0; i < 3; ++i )\n    {\n        d += (p[i] - r[i]) * (p[i] - r[i]);\n    }\n    return sqrt(d);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good2( in vec3 p, in vec3 r ) \n{\n    float d = 0.0;\n    for( int i = 0; i < 3; ++i )\n    {\n        d += (p[i] - r[i]) * (p[i] - r[i]);\n    }\n    return sqrt(d);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good3( in vec3 p, in vec3 r ) \n{\n    float d = 0.0;\n    for( int i = 0; i < 3; ++i )\n    {\n        d += (p[i] - r[i]) * (p[i] - r[i]);\n    }\n    return sqrt(d);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good4( in vec3 p, in vec3 r ) \n{\n    float d = 0.0;\n    for( int i = 0; i < 3; ++i )\n    {\n        d += (p[i] - r[i]) * (p[i] - r[i]);\n    }\n    return sqrt(d);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good5( in vec3 p, in vec3 r ) ", "\n    float a = r.x;\n    float b = r.y;\n    float c = r.z;\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float e = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float f = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float g = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float h = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float i = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float j = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float k = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float l = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float m = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float n = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float o = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float p = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float q = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float r = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    float s =", "\n    float x, y;\n    x = p.x;\n    y = p.y;\n    if (x < 0.0f)\n        x = 0.0f;\n    if (x > 1.0f)\n        x = 1.0f;\n    if (y < 0.0f)\n        y = 0.0f;\n    if (y > 1.0f)\n        y = 1.0f;\n    return (x + y) / 2.0f;\n}\n\n// http://www.cs.cmu.edu/~matt/courses/cs36c/lectures/lec5/lec5.pdf\nfloat checkersGrad( in vec2 p )\n{\n    float x, y;\n    x = p.x;\n    y = p.y;\n    if (x < 0.0f)\n        x = 0.0f;\n    if (x > 1.0f)\n        x = 1.0f;\n    if (y < 0.0f)\n        y = 0.0f;\n    if (y > 1.0f)\n        y = 1.0f;\n    return (x + y) / 2.0f;\n}\n\n// http://www.cs.cmu.edu/~matt/courses/cs36c/lectures/lec5/lec5.pdf\nfloat checkersGradBox( in vec2 p )\n{\n    float x, y;\n    x = p.x;\n    y = p.y;\n    if (x < 0.0f)\n        x = 0.0f;\n    if (x > 1.0f)\n        x = 1.0f;\n    if (y < 0.0f)\n        y = 0.0f;\n    if (y > 1.0f)\n        y = 1.0f;\n    return (x + y) / 2.0f;\n}\n\n// http://www.cs.cmu.edu/~matt/courses/cs36c/lectures/lec5/lec5.pdf\nfloat checkersGrad( in vec2 p )\n{\n    float x", "\n    return a*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x", "\n    float y = 0.0;\n    float a = p;\n    float b = 1.0 - p;\n    float c = 1.0;\n    float d = -1.0;\n    float e = 1.0;\n    float f = -1.0;\n    float g = 1.0;\n    float h = -1.0;\n    float i = 1.0;\n    float j = -1.0;\n    float k = 1.0;\n    float l = -1.0;\n    float m = 1.0;\n    float n = -1.0;\n    float o = 1.0;\n    float p = -1.0;\n    float q = 1.0;\n    float r = -1.0;\n    float s = 1.0;\n    float t = -1.0;\n    float u = 1.0;\n    float v = -1.0;\n    float w = 1.0;\n    float x = -1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = -1.0;\n    float x = 1.0;\n    float y = -1.0;\n    float z = 1.0;\n    float w = -1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = -1.0;\n    float w = 1.0;\n    float x = -1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = -1.0;\n    float x = 1.0;\n    float y = -1.0;\n    float z = 1.0;\n    float w = -1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = -1.0;\n    float w = 1.0;\n    float x = -1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = -1.0;\n    float x = 1.0;\n    float y = -1.0;\n    float", "\n    // h is the hue\n    // return a color\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if( h < 0.0 )\n        h += 1.0;\n    if( h > 1.0 )\n        h -= 1.0;\n    if( h < 0.5 )\n        c = vec3(1.0 - h, h, 0.0);\n    else\n        c = vec3(h, 1.0 - h, 0.0);\n    return c;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf_rgb( float h, float s, float v )\n{\n    // h is the hue\n    // s is the saturation\n    // v is the value\n    // return a color\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if( h < 0.0 )\n        h += 1.0;\n    if( h > 1.0 )\n        h -= 1.0;\n    if( s < 0.0 )\n        s += 1.0;\n    if( s > 1.0 )\n        s -= 1.0;\n    if( v < 0.0 )\n        v += 1.0;\n    if( v > 1.0 )\n        v -= 1.0;\n    if( h < 0.5 )\n        c = vec3(1.0 - h, h, 0.0);\n    else\n        c = vec3(h, 1.0 - h, 0.0);\n    if( s < 0.5 )\n        c = c * vec3(1.0 - s, s, 0.0);\n    else\n        c = c * vec3(s, 1.0 - s, 0.0);\n    if( v < 0.5 )\n        c = c * vec3(1.0 - v, v, 0.0);\n    else\n        c = c * vec3(v, 1.0 - v, 0.0);\n    return c;\n}\n\n// modified DLMF coloring, adapted", "\n    vec3 rp = rd - pa;\n    vec3 rp2 = rp * rp;\n    vec3 rp3 = rp2 * rp;\n    vec3 rp4 = rp3 * rp;\n    vec3 rp5 = rp4 * rp;\n    vec3 rp6 = rp5 * rp;\n    vec3 rp7 = rp6 * rp;\n    vec3 rp8 = rp7 * rp;\n    vec3 rp9 = rp8 * rp;\n    vec3 rp10 = rp9 * rp;\n    vec3 rp11 = rp10 * rp;\n    vec3 rp12 = rp11 * rp;\n    vec3 rp13 = rp12 * rp;\n    vec3 rp14 = rp13 * rp;\n    vec3 rp15 = rp14 * rp;\n    vec3 rp16 = rp15 * rp;\n    vec3 rp17 = rp16 * rp;\n    vec3 rp18 = rp17 * rp;\n    vec3 rp19 = rp18 * rp;\n    vec3 rp20 = rp19 * rp;\n    vec3 rp21 = rp20 * rp;\n    vec3 rp22 = rp21 * rp;\n    vec3 rp23 = rp22 * rp;\n    vec3 rp24 = rp23 * rp;\n    vec3 rp25 = rp24 * rp;\n    vec3 rp26 = rp25 * rp;\n    vec3 rp27 = rp26 * rp;\n    vec3 rp28 = rp27 * rp;\n    vec3 rp29 = rp28 * rp;\n    vec3 rp30 = rp29 * rp;\n    vec3 rp31 = rp30 * rp;\n    vec3 rp32 = rp31 * rp;\n    vec3 rp33 = rp32 * rp;\n    vec3 rp34 = rp33 * rp;\n    vec3 rp", "\n    vec3 p0 = a + (b - a) * (p - a);\n    vec3 p1 = b + (a - b) * (p - b);\n    vec3 p2 = a + (b - a) * (p - a);\n    vec3 p3 = b + (a - b) * (p - b);\n\n    vec3 p0p1 = p0 - p1;\n    vec3 p0p2 = p0 - p2;\n    vec3 p0p3 = p0 - p3;\n    vec3 p1p2 = p1 - p2;\n    vec3 p1p3 = p1 - p3;\n    vec3 p2p3 = p2 - p3;\n\n    vec3 p0p1p2 = p0p1 - p0p2;\n    vec3 p0p1p3 = p0p1 - p0p3;\n    vec3 p0p2p3 = p0p2 - p0p3;\n    vec3 p1p2p3 = p1p2 - p1p3;\n\n    vec3 p0p1p2p3 = p0p1p2 - p0p2p3;\n    vec3 p0p1p2p3 = p0p1p2p3;\n\n    vec3 p0p1p2p3p4 = p0p1p2p3 - p0p3p4;\n    vec3 p0p1p2p3p4 = p0p1p2p3p4;\n\n    vec3 p0p1p2p3p4p5 = p0p1p2p3p4 - p1p4p5;\n    vec3 p0p1p2p3p4p5 = p0p1p2p3p4p5;\n\n    vec3 p0p1p2p3p4p5p6 = p0p1p2p3p4p5 - p2p4p5p6;\n    vec3 p0p1p2p3p4p5p6 = p0p1p2p3p4p5p6;\n\n    vec3 p0p1p2p3", "\n    vec3 rdShadow = rd - (rd - ro) * (1.0f - r);\n    vec3 aShadow = a - (a - ro) * (1.0f - r);\n    vec3 bShadow = b - (b - ro) * (1.0f - r);\n    vec3 rdShadow2 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow3 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow4 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow5 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow6 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow7 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow8 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow9 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow10 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow11 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow12 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow13 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow14 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rdShadow15 = rdShadow - (rdShadow - bShadow) * (1.0f - r);\n    vec3 rdShadow16 = rdShadow - (rdShadow - aShadow) * (1.0f - r);\n    vec3 rd", "#ifdef DEBUG\n    cout << \"snake(uv=\" << uv << \", rad1=\" << rad1 << \", rad2=\" << rad2 << \", th=\" << th << \")\";\n#endif\n    vec2 r1 = vec2(rad1, 0);\n    vec2 r2 = vec2(rad2, 0);\n    vec2 th = vec2(th, 0);\n    vec2 th1 = vec2(th, 0);\n    vec2 th2 = vec2(th, 0);\n    vec2 th3 = vec2(th, 0);\n    vec2 th4 = vec2(th, 0);\n    vec2 th5 = vec2(th, 0);\n    vec2 th6 = vec2(th, 0);\n    vec2 th7 = vec2(th, 0);\n    vec2 th8 = vec2(th, 0);\n    vec2 th9 = vec2(th, 0);\n    vec2 th10 = vec2(th, 0);\n    vec2 th11 = vec2(th, 0);\n    vec2 th12 = vec2(th, 0);\n    vec2 th13 = vec2(th, 0);\n    vec2 th14 = vec2(th, 0);\n    vec2 th15 = vec2(th, 0);\n    vec2 th16 = vec2(th, 0);\n    vec2 th17 = vec2(th, 0);\n    vec2 th18 = vec2(th, 0);\n    vec2 th19 = vec2(th, 0);\n    vec2 th20 = vec2(th, 0);\n    vec2 th21 = vec2(th, 0);\n    vec2 th22 = vec2(th, 0);\n    vec2 th23 = vec2(th, 0);\n    vec2 th24 = vec2(th, 0);\n    vec2 th25 = vec2(th, 0);\n    vec2 th26 = vec2(th, 0);\n    vec2 th27 = vec2(th, 0);\n    vec2 th28 = vec2(th, 0);\n    vec2 th29 = vec2(th, 0);\n    vec2 th30 = vec2(th, 0);\n    ", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float s = x*x + y*y;\n    float c = sqrt(s);\n    float r2 = r*r;\n    float s2 = s*s;\n    float c2 = c*c;\n    float s3 = s2*s2;\n    float c3 = c2*c2;\n    float s4 = s3*s3;\n    float c4 = c3*c3;\n    float s5 = s4*s4;\n    float c5 = c4*c4;\n    float s6 = s5*s5;\n    float c6 = c5*c5;\n    float s7 = s6*s6;\n    float c7 = c6*c6;\n    float s8 = s7*s7;\n    float c8 = c7*c7;\n    float s9 = s8*s8;\n    float c9 = c8*c8;\n    float s10 = s9*s9;\n    float c10 = c9*c9;\n    float s11 = s10*s10;\n    float c11 = c10*c10;\n    float s12 = s11*s11;\n    float c12 = c11*c11;\n    float s13 = s12*s12;\n    float c13 = c12*c12;\n    float s14 = s13*s13;\n    float c14 = c13*c13;\n    float s15 = s14*s14;\n    float c15 = c14*c14;\n    float s16 = s15*s15;\n    float c16 = c15*c15;\n    float s17 = s16*s16;\n    float c17 = c16*c16;\n    float s18 = s17*s17;\n    float c18 = c17*c17;\n    float s19 = s18*s18;\n    float c19 = c18*c18;\n    float s20 = s19*s19;\n    float c20 = c19*c19;\n", "\n    vec3 dx = pos.x*pos.x;\n    vec3 dy = pos.y*pos.y;\n    vec3 dz = pos.z*pos.z;\n    vec3 dxdy = pos.x*pos.y;\n    vec3 dxdz = pos.x*pos.z;\n    vec3 dydz = pos.y*pos.z;\n    vec3 r = sqrt(dx+dy+dz);\n    vec3 r2 = r*r;\n    vec3 r3 = r*r*r;\n    vec3 r4 = r*r*r*r;\n    vec3 r5 = r*r*r*r*r;\n    vec3 r6 = r*r*r*r*r*r;\n    vec3 r7 = r*r*r*r*r*r*r;\n    vec3 r8 = r*r*r*r*r*r*r*r;\n    vec3 r9 = r*r*r*r*r*r*r*r*r;\n    vec3 r10 = r*r*r*r*r*r*r*r*r*r;\n    vec3 r11 = r*r*r*r*r*r*r*r*r*r*r;\n    vec3 r12 = r*r*r*r*r*r*r*r*r*r*r*r;\n    vec3 r13 = r*r*r*r*r*r*r*r*r*r*r*r*r;\n    vec3 r14 = r*r*r*r*r*r*r*r*r*r*r*r*r*r;\n    vec3 r15 = r*r*r*r*r*r*r*r*r*r*r*r*r*r*r;\n    vec3 r16 = r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r;\n    vec3 r17 = r*r*r*r*r*r*r*r*r*r*r*r*", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    float s = (p.x*sca.x + p.y*sca.y)*(p.x*scb.x + p.y*scb.y) - (p.x*scb.y - p.y*scb.x)*(p.x*sca.y - p.y*sca.x);\n    return s*(ra*ra + rb*rb - s*s);\n#else\n    float s = (p.x*sca.x + p.y*sca.y)*(p.x*scb.x + p.y*scb.y) - (p.x*scb.y - p.y*scb.x)*(p.x*sca.y - p.y*sca.x);\n    return s*(ra*ra + rb*rb - s*s);\n#endif\n}\n\n// returns the distance from the origin to the point\nfloat dist( in vec2 p )\n{\n    return sqrt(p.x*p.x + p.y*p.y);\n}\n\n// returns the distance from the origin to the line\nfloat distLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    return abs(a.x*p.y - a.y*p.x + b.x*p.x - b.y*p.y);\n}\n\n// returns the distance from the origin to the point on the line\nfloat distPointLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    return abs(a.x*p.y - a.y*p.x + b.x*p.x - b.y*p.y) / dist(a-b);\n}\n\n// returns the distance from the origin to the point on the line\nfloat distPointLine2( in vec2 p, in vec2 a, in vec2 b )\n{\n    return abs(a.x*p.y - a.y*p.x + b.x*p.x - b.y*p.y) / dist", "\n    vec3 r = ro - rd;\n    float d = dot(r,r);\n    float t = max(0.0f, min(1.0f, d/tmax));\n    vec3 s = (1.0f-t)*rd + t*ro;\n    return (s.x*mint + s.y*mint + s.z*mint);\n}\n\nfloat calcHardShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    vec3 r = ro - rd;\n    float d = dot(r,r);\n    float t = max(0.0f, min(1.0f, d/tmax));\n    vec3 s = (1.0f-t)*rd + t*ro;\n    return (s.x*(1.0f-mint) + s.y*(1.0f-mint) + s.z*(1.0f-mint));\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float t = max(0.0f, min(1.0f, dot(ro-rd,ro-rd)/tmax));\n    vec3 s = (1.0f-t)*rd + t*ro;\n    return (s.x*mint + s.y*mint + s.z*mint);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float t = max(0.0f, min(1.0f, dot(ro-rd,ro-rd)/tmax));\n    vec3 s = (1.0f-t)*rd + t*ro;\n    return (s.x*(1.0f-mint) + s.y*(1.0f-mint) + s.z*(1.0f-mint));\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float t = max(0.0f, min(1.0f, dot(ro-rd,ro-", "\n    vec3 normal;\n    vec3 normal2;\n    vec3 normal3;\n    vec3 normal4;\n    vec3 normal5;\n    vec3 normal6;\n    vec3 normal7;\n    vec3 normal8;\n    vec3 normal9;\n    vec3 normal10;\n    vec3 normal11;\n    vec3 normal12;\n    vec3 normal13;\n    vec3 normal14;\n    vec3 normal15;\n    vec3 normal16;\n    vec3 normal17;\n    vec3 normal18;\n    vec3 normal19;\n    vec3 normal20;\n    vec3 normal21;\n    vec3 normal22;\n    vec3 normal23;\n    vec3 normal24;\n    vec3 normal25;\n    vec3 normal26;\n    vec3 normal27;\n    vec3 normal28;\n    vec3 normal29;\n    vec3 normal30;\n    vec3 normal31;\n    vec3 normal32;\n    vec3 normal33;\n    vec3 normal34;\n    vec3 normal35;\n    vec3 normal36;\n    vec3 normal37;\n    vec3 normal38;\n    vec3 normal39;\n    vec3 normal40;\n    vec3 normal41;\n    vec3 normal42;\n    vec3 normal43;\n    vec3 normal44;\n    vec3 normal45;\n    vec3 normal46;\n    vec3 normal47;\n    vec3 normal48;\n    vec3 normal49;\n    vec3 normal50;\n    vec3 normal51;\n    vec3 normal52;\n    vec3 normal53;\n    vec3 normal54;\n    vec3 normal55;\n    vec3 normal56;\n    vec3 normal57;\n    vec3 normal58;\n    vec3 normal59;\n    vec3 normal60;\n    vec3 normal61;\n    vec3 normal62;\n    vec3 normal63;\n    vec3 normal64;\n    vec3 normal65;\n    vec3 normal66;\n    vec3 normal67;\n    vec3 normal68;\n    vec3 normal69;\n    vec3 normal70;\n    vec3 normal71;\n    vec3 normal72;\n    vec3 normal73;\n    ", "\n    vec3 r = ro - rd;\n    float d = dot( r, r );\n    float t = time / tmax;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41 * t;\n    float t43 = t42 * t;\n    float t44 = t43 * t;\n    float t45 = t44", "\n    float x, y;\n    x = p.x;\n    y = p.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += dpdx.x;\n    y += dpdx.y;\n    x += dpdy.x;\n    y += dpdy.y;\n    x -= p.x;\n    y -= p.y;\n    x -= dpdx.x;\n    y -= dpdx.y;\n    x -= dpdy.x;\n    y -= dpdy.y;\n    x += dpdx.x", "\n    if( k == 1 )\n        return x;\n    else\n        return staircase( x, 1/k );\n}\n\nA:\n\nI think you are looking for the inverse of the function.\nThe inverse of a function f(x) is a function g(x) such that f(g(x)) = x and g(f(x)) = x.\nIn your case, f(x) = x^k and g(x) = x^(1/k).\n\nA:\n\nThe inverse of a function f(x) is a function g(x) such that f(g(x)) = x and g(f(x)) = x.\nIn your case, f(x) = x^k and g(x) = x^(1/k).\n\nA:\n\nThe inverse of a function f(x) is a function g(x) such that f(g(x)) = x and g(f(x)) = x.\nIn your case, f(x) = x^k and g(x) = x^(1/k).\n\nA:\n\nThe inverse of a function f(x) is a function g(x) such that f(g(x)) = x and g(f(x)) = x.\nIn your case, f(x) = x^k and g(x) = x^(1/k).\n\n", "\n    vec3 sky_dir = normalize(surface_normal);\n    vec3 sky_pos = sample_pos + sky_dir * 0.1;\n    vec3 sky_color = ambient_color(sky_pos, light_dir, background_col);\n    return sky_color;\n}\n\n//-------------------------------------------------------------------------------\n//Render the planet\n//-------------------------------------------------------------------------------\nvoid render_planet(vec3 pos, vec3 size, vec3 color, vec3 sky_color, vec3 light_dir, vec3 background_col) {\n    gl_Position = vec4(pos, 0.0, 1.0);\n    gl_PointSize = size.x;\n    gl_Color = vec4(color, 1.0);\n    gl_PointSize = size.y;\n    gl_Color = vec4(sky_color, 1.0);\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n    gl_PointSize = size.y;\n    gl_PointSize = size.z;\n    gl_PointSize = size.x;\n", "\n    vec3 pos_light = light_dir * 0.5;\n    vec3 pos_light_norm = normalize(pos_light);\n    vec3 pos_light_norm_dir = normalize(pos_light_norm * dir);\n    vec3 pos_light_norm_dir_norm = normalize(pos_light_norm_dir);\n    vec3 pos_light_norm_dir_norm_dir = normalize(pos_light_norm_dir_norm * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm = normalize(pos_light_norm_dir_norm_dir * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir = normalize(pos_light_norm_dir_norm_dir_norm * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir_norm = normalize(pos_light_norm_dir_norm_dir_norm_dir * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir_norm_dir = normalize(pos_light_norm_dir_norm_dir_norm_dir_norm * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir_norm_dir_norm = normalize(pos_light_norm_dir_norm_dir_norm_dir_norm * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir = normalize(pos_light_norm_dir_norm_dir_norm_dir_norm_dir * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm = normalize(pos_light_norm_dir_norm_dir_norm_dir_norm_dir_norm * dir);\n    vec3 pos_light_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir = normalize(pos_light_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm * dir);\n    vec3 pos_light_norm_dir_norm_", "#\n    vec3 camera_vector;\n    vec3 ray_direction;\n    vec3 ray_origin;\n    vec3 ray_direction_normal;\n    vec3 ray_direction_normal_normalized;\n    vec3 ray_direction_normal_normalized_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution;\n    vec3 ray_direction_normal_normalized_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_dot_resolution_", "\n    float s = 0.0f;\n    float c2 = c.x*c.x + c.y*c.y;\n    float c3 = c2*c2;\n    float c4 = c3*c3;\n    float c5 = c4*c3;\n    float c6 = c5*c3;\n    float c7 = c6*c3;\n    float c8 = c7*c3;\n    float c9 = c8*c3;\n    float c10 = c9*c3;\n    float c11 = c10*c3;\n    float c12 = c11*c3;\n    float c13 = c12*c3;\n    float c14 = c13*c3;\n    float c15 = c14*c3;\n    float c16 = c15*c3;\n    float c17 = c16*c3;\n    float c18 = c17*c3;\n    float c19 = c18*c3;\n    float c20 = c19*c3;\n    float c21 = c20*c3;\n    float c22 = c21*c3;\n    float c23 = c22*c3;\n    float c24 = c23*c3;\n    float c25 = c24*c3;\n    float c26 = c25*c3;\n    float c27 = c26*c3;\n    float c28 = c27*c3;\n    float c29 = c28*c3;\n    float c30 = c29*c3;\n    float c31 = c30*c3;\n    float c32 = c31*c3;\n    float c33 = c32*c3;\n    float c34 = c33*c3;\n    float c35 = c34*c3;\n    float c36 = c35*c3;\n    float c37 = c36*c3;\n    float c38 = c37*c3;\n    float c39 = c38*c3;\n    float c40 = c39*c3;\n    float c41 = c40*c3;\n    float c42 = c41*c3;", "#include \"ray.h\"\n    // Get the material's color.\n    vec3 color = material_colors[material];\n    // Get the material's ambient, diffuse, and specular\n    // coefficients.\n    vec3 ambient = material_ambient[material];\n    vec3 diffuse = material_diffuse[material];\n    vec3 specular = material_specular[material];\n    // Get the normal vector.\n    vec3 normal = ray.direction;\n    // Get the dot product of the normal and the surface normal.\n    float dot = normal.dot(surface_normal);\n    // If the dot product is less than zero, the ray is\n    // parallel to the surface, so the color is black.\n    if (dot < 0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    // If the dot product is greater than one, the ray\n    // is outside the surface, so the color is white.\n    if (dot > 1) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    // Otherwise, the color is a weighted sum of the\n    // ambient, diffuse, and specular colors.\n    vec3 color_light = ambient + diffuse * dot;\n    vec3 color_specular = specular * pow(dot, shininess);\n    return color_light + color_specular;\n}\n\n// Get the surface normal given a ray.\nvec3 get_surface_normal(cast_ray_result ray) {#include \"ray.h\"\n    // Get the surface normal.\n    vec3 normal = surface_normal;\n    // If the ray intersects the surface, the normal\n    // is the cross product of the ray direction and\n    // the surface normal.\n    if (ray.hit) {\n        vec3 n = ray.direction.cross(surface_normal);\n        normal = n;\n    }\n    return normal;\n}\n\n// Get the surface normal given a material number.\nvec3 get_material_normal(int material, cast_ray_result ray) {#include \"ray.h\"\n    // Get the material's normal.\n    vec3 normal = material_normals[material];\n    ", "#include <stdio.h>\n    switch (material) {\n    case 0:\n        return 0.0;\n    case 1:\n        return 1.0;\n    default:\n        return 0.5;\n    }\n}\n\n// Get the reflectivity of a surface.\n// The surface is a 2D array of floats.\n// The reflectivity is a 2D array of floats.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity is the same size as the surface.\n// The reflectivity", "\n    switch (material) {\n        case 1:\n            return 1.0f;\n        case 2:\n            return 1.5f;\n        case 3:\n            return 1.7f;\n        case 4:\n            return 1.9f;\n        default:\n            return 1.0f;\n    }\n}\n\n// Get the angle of refraction of a ray of light.\nfloat get_refraction_angle(float angle_of_incidence, float material_refraction) {\n    return angle_of_incidence * material_refraction;\n}\n\n// Get the angle of incidence of a ray of light.\nfloat get_angle_of_incidence(float angle_of_refraction, float material_refraction) {\n    return angle_of_refraction / material_refraction;\n}\n\n// Get the angle of refraction of a ray of light.\nfloat get_refraction_angle(float angle_of_incidence, float material_refraction) {\n    return angle_of_incidence * material_refraction;\n}\n\n// Get the angle of incidence of a ray of light.\nfloat get_angle_of_incidence(float angle_of_refraction, float material_refraction) {\n    return angle_of_refraction / material_refraction;\n}\n\n// Get the angle of refraction of a ray of light.\nfloat get_refraction_angle(float angle_of_incidence, float material_refraction) {\n    return angle_of_incidence * material_refraction;\n}\n\n// Get the angle of incidence of a ray of light.\nfloat get_angle_of_incidence(float angle_of_refraction, float material_refraction) {\n    return angle_of_refraction / material_refraction;\n}\n\n// Get the angle of refraction of a ray of light.\nfloat get_refraction_angle(float angle_of_incidence, float material_refraction) {\n    return angle_of_incidence * material_refraction;\n}\n\n// Get the angle of incidence of a ray of light.\nfloat get_angle_of_incidence(float angle_of_refraction, float material_refraction) {\n", "#include \"materials.h\"\n    return materials[material].opacity;\n}\n\n// Get the color of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_color(int material) {#include \"materials.h\"\n    return materials[material].color;\n}\n\n// Get the texture of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture(int material) {#include \"materials.h\"\n    return materials[material].texture;\n}\n\n// Get the texture coordinates of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture_coords(int material) {#include \"materials.h\"\n    return materials[material].texture_coords;\n}\n\n// Get the texture coordinates of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture_coords(int material) {#include \"materials.h\"\n    return materials[material].texture_coords;\n}\n\n// Get the texture coordinates of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture_coords(int material) {#include \"materials.h\"\n    return materials[material].texture_coords;\n}\n\n// Get the texture coordinates of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture_coords(int material) {#include \"materials.h\"\n    return materials[material].texture_coords;\n}\n\n// Get the texture coordinates of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture_coords(int material) {#include \"materials.h\"\n    return materials[material].texture_coords;\n}\n\n// Get the texture coordinates of a material.\n// 0.0 is completely transparent.\n// 1.0 is completely opaque.\nfloat get_material_texture_coords(int material) {", "#include \"line_intersects_line.h\"\n    vec3 a = tri_a - tri_b;\n    vec3 b = tri_b - tri_c;\n    vec3 c = tri_c - tri_a;\n    vec3 d = line_a - line_b;\n    vec3 e = line_b - line_a;\n    vec3 f = line_c - line_a;\n    vec3 g = line_a - line_c;\n    vec3 h = line_b - line_c;\n    vec3 i = line_a - line_b;\n    vec3 j = line_c - line_b;\n    vec3 k = line_a - line_c;\n    vec3 l = line_b - line_a;\n    vec3 m = line_c - line_a;\n    vec3 n = line_a - line_c;\n    vec3 p = line_b - line_a;\n    vec3 q = line_c - line_a;\n    vec3 r = line_a - line_b;\n    vec3 s = line_b - line_c;\n    vec3 t = line_c - line_b;\n    vec3 u = line_a - line_c;\n    vec3 v = line_b - line_c;\n    vec3 w = line_c - line_a;\n    vec3 x = line_a - line_b;\n    vec3 y = line_b - line_c;\n    vec3 z = line_c - line_a;\n    vec3 aa = a * a;\n    vec3 ab = a * b;\n    vec3 ac = a * c;\n    vec3 ad = a * d;\n    vec3 ae = a * e;\n    vec3 af = a * f;\n    vec3 ag = a * g;\n    vec3 ah = a * h;\n    vec3 ai = a * i;\n    vec3 aj = a * j;\n    vec3 ak = a * k;\n    vec3 al = a * l;\n    vec3 am = a * m;\n    vec3 an = a * n;\n    vec3 ap", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MIN", "\n    vec3 up = normalize(cross(camera_target, camera_position));\n    vec3 right = normalize(cross(up, camera_target));\n    vec3 forward = normalize(camera_target - camera_position);\n\n    // Create a rotation matrix from the three vectors\n    mat3 rotation_matrix = mat3(\n        right.x, -forward.y, -up.z,\n        forward.x, right.y, -up.z,\n        -up.x, -up.y, right.z,\n        up.x, up.y, -right.z\n    );\n\n    // Create a translation matrix from the camera position\n    vec3 translation_matrix = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n        camera_position.x, camera_position.y, camera_position.z\n    );\n\n    // Combine the two matrices to get the final matrix\n    mat3 final_matrix = translation_matrix * rotation_matrix;\n\n    return final_matrix;\n}\n\n// Generate a perspective projection matrix based on a field of view,\n// aspect ratio, near and far clipping planes.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/perspective-projection-matrix\nmat3 perspective_matrix(float field_of_view, float aspect_ratio, float near, float far) {\n    float fov_radians = field_of_view * M_PI / 180;\n    float aspect_ratio_sqrt = sqrt(aspect_ratio);\n\n    // Create a projection matrix based on the given parameters\n    mat3 projection_matrix = mat3(\n        1 / (aspect_ratio_sqrt * tan(fov_radians / 2)), 0, 0,\n        0, 1 / (aspect_ratio_sqrt * tan(fov_radians / 2)), 0,\n        0, 0, -(far + near) / (far - near), -2 * far * near / (far - near),\n        0, 0, -1\n    );\n\n    return projection_mat", "\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    //...\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin", "\n    vec3 ray_direction = ray_target - ray_origin;\n    vec3 ray_direction_normal = normalize(ray_direction);\n    vec3 ray_direction_normal_dot_light = dot(ray_direction_normal, light_direction);\n    vec3 ray_direction_normal_dot_light_squared = ray_direction_normal_dot_light * ray_direction_normal_dot_light;\n    vec3 ray_direction_normal_dot_light_squared_plus_one = ray_direction_normal_dot_light_squared + 1.0;\n    vec3 ray_direction_normal_dot_light_squared_plus_one_sqrt = sqrt(ray_direction_normal_dot_light_squared_plus_one);\n    vec3 ray_direction_normal_dot_light_squared_plus_one_sqrt_squared = ray_direction_normal_dot_light_squared_plus_one_sqrt * ray_direction_normal_dot_light_squared_plus_one_sqrt;\n    vec3 ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one = ray_direction_normal_dot_light_squared_plus_one_sqrt_squared + 1.0;\n    vec3 ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one_sqrt = sqrt(ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one);\n    vec3 ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one_sqrt_squared = ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one_sqrt * ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one;\n    vec3 ray_direction_normal_dot_light_squared_plus_one_sqrt_squared_plus_one_sqrt_squared_plus_one_sqrt = ray_direction_normal_dot", "\n    return (x + (float)rand()/RAND_MAX);\n}\n\n// Basic noise\nfloat bnoise( in float x, in float y )\n{\n    return (x + (float)rand()/RAND_MAX) + (y + (float)rand()/RAND_MAX);\n}\n\n// Basic noise\nfloat bnoise( in float x, in float y, in float z )\n{\n    return (x + (float)rand()/RAND_MAX) + (y + (float)rand()/RAND_MAX) + (z + (float)rand()/RAND_MAX);\n}\n\n// Basic noise\nfloat bnoise( in float x, in float y, in float z, in float w )\n{\n    return (x + (float)rand()/RAND_MAX) + (y + (float)rand()/RAND_MAX) + (z + (float)rand()/RAND_MAX) + (w + (float)rand()/RAND_MAX);\n}\n\n// Basic noise\nfloat bnoise( in float x, in float y, in float z, in float w, in float u )\n{\n    return (x + (float)rand()/RAND_MAX) + (y + (float)rand()/RAND_MAX) + (z + (float)rand()/RAND_MAX) + (w + (float)rand()/RAND_MAX) + (u + (float)rand()/RAND_MAX);\n}\n\n// Basic noise\nfloat bnoise( in float x, in float y, in float z, in float w, in float u, in float v )\n{\n    return (x + (float)rand()/RAND_MAX) + (y + (float)rand()/RAND_MAX) + (z + (float)rand()/RAND_MAX) + (w + (float)rand()/RAND_MAX) + (u + (float)rand()/RAND_MAX) + (v + (float)rand()/RAND_MAX);\n}\n\n// Basic noise\nfloat bnoise( in float x, in float y, in float z, in float w, in", "\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Generate a random number in the range [0,1)\nfloat rand( )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range( float min, float max )\n{\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range_int( int min, int max )\n{\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range_float( float min, float max )\n{\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range_float_int( int min, int max )\n{\n    return min + rand() / (float)RAND_MAX * (max - min);\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range_float_int_float( float min, float max, int min_int, int max_int )\n{\n    return min + rand() / (float)RAND_MAX * (max - min) * (max_int - min_int) + min_int;\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range_float_int_float_int( float min, float max, int min_int, int max_int )\n{\n    return min + rand() / (float)RAND_MAX * (max - min) * (max_int - min_int) + min_int;\n}\n\n// Generate a random number in the range [0,1)\nfloat rand_in_range_float_int_float_int_float( float min, float max, int min_int, int max_int", "\n    int hash = n;\n    for( int i = 0; i < sizeof( n ); i++ )\n    {\n        hash = ( hash * 31 ) + n % 31;\n    }\n    return hash;\n}\n\nint main( void )\n{\n    int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int b[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int c[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int d[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int e[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int f[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int g[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int h[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int i[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int j[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int k[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int l[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int m[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int n[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int o[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int p[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int q[] = { 1, 2, 3, 4, 5, 6,", "    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{    \n    return (p + (float)rand()/RAND_MAX);\n}\n\n// gradient noise\nfloat gnoise(", "\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float x2 = 0.0;\n    float x3 = 0.0;\n    float x4 = 0.0;\n    float x5 = 0.0;\n    float x6 = 0.0;\n    float x7 = 0.0;\n    float x8 = 0.0;\n    float x9 = 0.0;\n    float x10 = 0.0;\n    float x11 = 0.0;\n    float x12 = 0.0;\n    float x13 = 0.0;\n    float x14 = 0.0;\n    float x15 = 0.0;\n    float x16 = 0.0;\n    float x17 = 0.0;\n    float x18 = 0.0;\n    float x19 = 0.0;\n    float x20 = 0.0;\n    float x21 = 0.0;\n    float x22 = 0.0;\n    float x23 = 0.0;\n    float x24 = 0.0;\n    float x25 = 0.0;\n    float x26 = 0.0;\n    float x27 = 0.0;\n    float x28 = 0.0;\n    float x29 = 0", "\n    vec3 r = p - center;\n    vec3 q = r.normalize();\n    vec3 s = q.cross(normal);\n    vec3 t = q.cross(s);\n    vec3 u = q.cross(t);\n    vec3 v = q.cross(u);\n    vec3 w = q.cross(v);\n    vec3 x = q.cross(w);\n    vec3 y = q.cross(x);\n    vec3 z = q.cross(y);\n    vec3 a = q.dot(normal);\n    vec3 b = q.dot(s);\n    vec3 c = q.dot(t);\n    vec3 d = q.dot(u);\n    vec3 e = q.dot(v);\n    vec3 f = q.dot(w);\n    vec3 g = q.dot(x);\n    vec3 h = q.dot(y);\n    vec3 i = q.dot(z);\n    vec3 j = q.dot(a);\n    vec3 k = q.dot(b);\n    vec3 l = q.dot(c);\n    vec3 m = q.dot(d);\n    vec3 n = q.dot(e);\n    vec3 o = q.dot(f);\n    vec3 p = q.dot(g);\n    vec3 q = q.dot(h);\n    vec3 r = q.dot(i);\n    vec3 s = q.dot(j);\n    vec3 t = q.dot(k);\n    vec3 u = q.dot(l);\n    vec3 v = q.dot(m);\n    vec3 w = q.dot(n);\n    vec3 x = q.dot(o);\n    vec3 y = q.dot(p);\n    vec3 z = q.dot(q);\n    vec3 a = a * a;\n    vec3 b = b * b;\n    vec3 c = c * c;\n    vec3 d = d * d;\n    vec3 e = e * e;\n    vec3 f = f * f;\n    vec3 g = g * g;\n    vec3 h = h * h;\n    vec", "\n    vec3 p = pb * 2 - 1;\n    vec3 a = p * p * p * (1 - p);\n    vec3 b = p * p * (1 - p) * (1 - 2 * p);\n    vec3 c = p * (1 - p) * (1 - 2 * p) * (1 - p);\n    vec3 d = (1 - p) * (1 - p) * (1 - p) * (1 - p);\n    return vec3(\n        a * (1 - b) * (1 - c) * (1 - d),\n        a * (1 - b) * (1 + c) * (1 - d),\n        a * (1 + b) * (1 - c) * (1 - d),\n        a * (1 + b) * (1 + c) * (1 - d),\n        b * (1 - a) * (1 - c) * (1 - d),\n        b * (1 - a) * (1 + c) * (1 - d),\n        b * (1 + a) * (1 - c) * (1 - d),\n        b * (1 + a) * (1 + c) * (1 - d),\n        c * (1 - a) * (1 - b) * (1 - d),\n        c * (1 - a) * (1 + b) * (1 - d),\n        c * (1 + a) * (1 - b) * (1 - d),\n        c * (1 + a) * (1 + b) * (1 - d),\n        d * (1 - a) * (1 - b) * (1 + d),\n        d * (1 - a) * (1 + b) * (1 + d),\n        d * (1 + a) * (1 - b) * (1 + d),\n        d * (1 + a) * (1 + b) * (1 + d),\n    );\n}\n\n// For a point p in the unit box, return a color\n// based on the solutions of the associated cubic\n// polynomial. The point p is interprested as the \n// 3 polar angles of a 4D point in a unit sphere", "\n    vec3 r = ro - cen;\n    vec3 d = rd - cen;\n    vec3 n = cross(r, d);\n    vec3 dn = dot(n, d);\n    vec3 dn2 = dn * dn;\n    vec3 dn3 = dn2 * dn;\n    vec3 dn4 = dn3 * dn;\n    vec3 dn5 = dn4 * dn;\n    vec3 dn6 = dn5 * dn;\n    vec3 dn7 = dn6 * dn;\n    vec3 dn8 = dn7 * dn;\n    vec3 dn9 = dn8 * dn;\n    vec3 dn10 = dn9 * dn;\n    vec3 dn11 = dn10 * dn;\n    vec3 dn12 = dn11 * dn;\n    vec3 dn13 = dn12 * dn;\n    vec3 dn14 = dn13 * dn;\n    vec3 dn15 = dn14 * dn;\n    vec3 dn16 = dn15 * dn;\n    vec3 dn17 = dn16 * dn;\n    vec3 dn18 = dn17 * dn;\n    vec3 dn19 = dn18 * dn;\n    vec3 dn20 = dn19 * dn;\n    vec3 dn21 = dn20 * dn;\n    vec3 dn22 = dn21 * dn;\n    vec3 dn23 = dn22 * dn;\n    vec3 dn24 = dn23 * dn;\n    vec3 dn25 = dn24 * dn;\n    vec3 dn26 = dn25 * dn;\n    vec3 dn27 = dn26 * dn;\n    vec3 dn28 = dn27 * dn;\n    vec3 dn29 = dn28 * dn;\n    vec3 dn30 = dn29 * dn;\n    vec3 dn31 = dn30 * dn;\n    vec3 dn32 = dn31 * dn;", "QVector3D p = cen - ro;\nfloat d = p.length();\nfloat r = rad.length();\nfloat s = d/r;\nfloat t = p.x*p.x + p.y*p.y + p.z*p.z;\nfloat u = t/r*r;\nfloat v = (t-u)/r*r;\nfloat w = (t-u)/r*r;\nfloat x = (t-u)/r*r;\nfloat y = (t-u)/r*r;\nfloat z = (t-u)/r*r;\nfloat a = (t-u)/r*r;\nfloat b = (t-u)/r*r;\nfloat c = (t-u)/r*r;\nfloat d = (t-u)/r*r;\nfloat e = (t-u)/r*r;\nfloat f = (t-u)/r*r;\nfloat g = (t-u)/r*r;\nfloat h = (t-u)/r*r;\nfloat i = (t-u)/r*r;\nfloat j = (t-u)/r*r;\nfloat k = (t-u)/r*r;\nfloat l = (t-u)/r*r;\nfloat m = (t-u)/r*r;\nfloat n = (t-u)/r*r;\nfloat o = (t-u)/r*r;\nfloat p = (t-u)/r*r;\nfloat q = (t-u)/r*r;\nfloat r = (t-u)/r*r;\nfloat s = (t-u)/r*r;\nfloat t = (t-u)/r*r;\nfloat u = (t-u)/r*r;\nfloat v = (t-u)/r*r;\nfloat w = (t-u)/r*r;\nfloat x = (t-u)/r*r;\nfloat y = (t-u)/r*r;\nfloat z = (t-u)/r*r;\nfloat a = (t-u)/r*r;\nfloat b = (t-u)/r*r;\nfloat c = (t-u)/r", "\n    vec3 r = ro - rd;\n    vec3 rd2 = rd * rd;\n    float rd2dotr = rd2.dot(r);\n    float rd2dotr2 = rd2dotr * rd2dotr;\n    float rd2dotr3 = rd2dotr2 * rd2dotr;\n    float rd2dotr4 = rd2dotr3 * rd2dotr;\n    float rd2dotr5 = rd2dotr4 * rd2dotr;\n    float rd2dotr6 = rd2dotr5 * rd2dotr;\n    float rd2dotr7 = rd2dotr6 * rd2dotr;\n    float rd2dotr8 = rd2dotr7 * rd2dotr;\n    float rd2dotr9 = rd2dotr8 * rd2dotr;\n    float rd2dotr10 = rd2dotr9 * rd2dotr;\n    float rd2dotr11 = rd2dotr10 * rd2dotr;\n    float rd2dotr12 = rd2dotr11 * rd2dotr;\n    float rd2dotr13 = rd2dotr12 * rd2dotr;\n    float rd2dotr14 = rd2dotr13 * rd2dotr;\n    float rd2dotr15 = rd2dotr14 * rd2dotr;\n    float rd2dotr16 = rd2dotr15 * rd2dotr;\n    float rd2dotr17 = rd2dotr16 * rd2dotr;\n    float rd2dotr18 = rd2dotr17 * rd2dotr;\n    float rd2dotr19 = rd2dotr18 * rd2dotr;\n    float rd2dotr20 = rd2dotr19 * rd2dotr;\n    float rd2dotr21 = rd2dotr20 * rd2dotr;\n    float rd2dotr22 = r", "    \n    srand(time(NULL) + seed);\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// shadow\nfloat shadow(float x, float y, float z) {\n    float x_ = x + rand() / (float)RAND_MAX;\n    float y_ = y + rand() / (float)RAND_MAX;\n    float z_ = z + rand() / (float)RAND_MAX;\n    return (x_ * x_ + y_ * y_ + z_ * z_) / (x_ * x_ + y_ * y_ + z_ * z_ + 1.0f);\n}\n\n// shadow\nfloat shadow_2(float x, float y, float z) {\n    float x_ = x + rand() / (float)RAND_MAX;\n    float y_ = y + rand() / (float)RAND_MAX;\n    float z_ = z + rand() / (float)RAND_MAX;\n    return (x_ * x_ + y_ * y_ + z_ * z_) / (x_ * x_ + y_ * y_ + z_ * z_ + 1.0f) * (x_ * x_ + y_ * y_ + z_ * z_ + 1.0f);\n}\n\n// shadow\nfloat shadow_3(float x, float y, float z) {\n    float x_ = x + rand() / (float)RAND_MAX;\n    float y_ = y + rand() / (float)RAND_MAX;\n    float z_ = z + rand() / (float)RAND_MAX;\n    return (x_ * x_ + y_ * y_ + z_ * z_) / (x_ * x_ + y_ * y_ + z_ * z_ + 1.0f) * (x_ * x_ + y_ * y_ + z_ * z_ + 1.0f) * (x_ * x_ + y_ * y_ + z_ * z_ + 1.0f);\n}\n\n// shadow\nfloat shadow_4(float x, float y, float z) {\n    float x_ = x + rand", "\n    vec3 p = a + t*(b-a);\n    vec3 q = c + t*(d-c);\n    return p + q;\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + t*(b-a);\n    vec3 q = c + t*(d-c);\n    return p + q;\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + t*(b-a);\n    vec3 q = c + t*(d-c);\n    return p + q;\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + t*(b-a);\n    vec3 q = c + t*(d-c);\n    return p + q;\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + t*(b-a);\n    vec3 q = c + t*(d-c);\n    return p + q;\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a", "\n    vec3 p1 = p + vec3(la,0,0);\n    vec3 p2 = p + vec3(0,lb,0);\n    vec3 p3 = p + vec3(0,0,h);\n    vec3 p4 = p + vec3(ra,0,0);\n    vec3 p5 = p + vec3(0,0,h);\n    vec3 p6 = p + vec3(0,0,h);\n    vec3 p7 = p + vec3(ra,0,0);\n    vec3 p8 = p + vec3(0,lb,0);\n    vec3 p9 = p + vec3(0,0,h);\n    vec3 p10 = p + vec3(0,0,h);\n    vec3 p11 = p + vec3(ra,0,0);\n    vec3 p12 = p + vec3(0,lb,0);\n    vec3 p13 = p + vec3(0,0,h);\n    vec3 p14 = p + vec3(0,0,h);\n    vec3 p15 = p + vec3(ra,0,0);\n    vec3 p16 = p + vec3(0,lb,0);\n    vec3 p17 = p + vec3(0,0,h);\n    vec3 p18 = p + vec3(0,0,h);\n    vec3 p19 = p + vec3(ra,0,0);\n    vec3 p20 = p + vec3(0,lb,0);\n    vec3 p21 = p + vec3(0,0,h);\n    vec3 p22 = p + vec3(0,0,h);\n    vec3 p23 = p + vec3(ra,0,0);\n    vec3 p24 = p + vec3(0,lb,0);\n    vec3 p25 = p + vec3(0,0,h);\n    vec3 p26 = p + vec3(0,0,h);\n    vec3 p27 = p + vec3(ra,0,0);\n    vec3 p28 = p + vec3(0,lb,0);\n    vec3 p29 = p", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    vec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n    {\n        vec4 pa = vec4(0.0,0.0,0.0,0.0);\n        vec2 pa_a = a - p;\n        vec2 pa_b = b - p;\n        float pa_a_mag = sqrt(pa_a.x*pa_a.x + pa_a.y*pa_a.y);\n        float pa_b_mag = sqrt(pa_b.x*pa_b.x + pa_b.y*pa_b.y);\n        float pa_a_dot_pa_b = pa_a.x*pa_b.x + pa_a.y*pa_b.y;\n        float pa_a_dot_pa_a = pa_a.x*pa_a.x + pa_a.y*pa_a.y;\n        float pa_b_dot_pa_a = pa_b.x*pa_a.x + pa_b.y*pa_a.y;\n        float pa_b_dot_pa_b = pa_b.x*pa_b.x + pa_b.y*pa_b.y;\n        float pa_a_dot_pa_b_mag = pa_a_dot_pa_b*pa_a_dot_pa_b;\n        float pa_b_dot_pa_b_mag = pa_b_dot_pa_b*pa_b_dot_pa_b;\n        float pa_a_dot_pa_b_dot_pa_a = pa_a_dot_pa_b*pa_a_dot_pa_a;\n        float pa_b_dot_pa_b_dot_pa_a = pa_b_dot_pa_b*pa_a_dot_pa_a;\n        float pa_a_dot_pa_b_dot_pa_b = pa_a_dot_pa_b*pa_b_dot_pa_b;\n        float pa_", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    vec4 pb = b;\n    vec4 pb2 = b;\n    vec4 pb3 = b;\n    vec4 pb4 = b;\n    vec4 pb5 = b;\n    vec4 pb6 = b;\n    vec4 pb7 = b;\n    vec4 pb8 = b;\n    vec4 pb9 = b;\n    vec4 pb10 = b;\n    vec4 pb11 = b;\n    vec4 pb12 = b;\n    vec4 pb13 = b;\n    vec4 pb14 = b;\n    vec4 pb15 = b;\n    vec4 pb16 = b;\n    vec4 pb17 = b;\n    vec4 pb18 = b;\n    vec4 pb19 = b;\n    vec4 pb20 = b;\n    vec4 pb21 = b;\n    vec4 pb22 = b;\n    vec4 pb23 = b;\n    vec4 pb24 = b;\n    vec4 pb25 = b;\n    vec4 pb26 = b;\n    vec4 pb27 = b;\n    vec4 pb28 = b;\n    vec4 pb29 = b;\n    vec4 pb30 = b;\n    vec4 pb31 = b;\n    vec4 pb32 = b;\n    vec4 pb33 = b;\n    vec4 pb34 = b;\n    vec4 pb35 = b;\n    vec4 pb36 = b;\n    vec4 pb37 = b;\n    vec4 pb38 = b;\n    vec4 pb39 = b;\n    vec4 pb40 = b;\n    vec4 pb41 = b;\n    vec4 pb42 = b;\n    vec4 pb43 = b;\n    vec4 pb44 = b;\n    vec4 pb45 = b;\n    vec4 pb46 = b;\n    vec4 pb47 = b;\n    vec4 pb48 = b;\n    vec4 pb49 = b;\n    vec", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec3 sdgBox( in vec2 p, in vec2 b )\n    {\n        vec3 x, y, z;\n        vec3 xyz;\n        vec3 dx, dy, dz;\n        vec3 dx2, dy2, dz2;\n        vec3 dxdy, dyz, dz2;\n        vec3 dx2dy2, dy2dz2, dz2dx2;\n        vec3 dxdy2dz2, dy2dz2dx2, dz2dx2dz2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        vec3 dxdy2dz2dx2;\n        ", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec4 rp = vec2(r,0);\n    vec4 rp2 = rp * rp;\n    vec4 rp3 = rp2 * rp;\n    vec4 rp4 = rp3 * rp;\n    vec4 rp5 = rp4 * rp;\n    vec4 rp6 = rp5 * rp;\n    vec4 rp7 = rp6 * rp;\n    vec4 rp8 = rp7 * rp;\n    vec4 rp9 = rp8 * rp;\n    vec4 rp10 = rp9 * rp;\n    vec4 rp11 = rp10 * rp;\n    vec4 rp12 = rp11 * rp;\n    vec4 rp13 = rp12 * rp;\n    vec4 rp14 = rp13 * rp;\n    vec4 rp15 = rp14 * rp;\n    vec4 rp16 = rp15 * rp;\n    vec4 rp17 = rp16 * rp;\n    vec4 rp18 = rp17 * rp;\n    vec4 rp19 = rp18 * rp;\n    vec4 rp20 = rp19 * rp;\n    vec4 rp21 = rp20 * rp;\n    vec4 rp22 = rp21 * rp;\n    vec4 rp23 = rp22 * rp;\n    vec4 rp24 = rp23 * rp;\n    vec4 rp25 = rp24 * rp;\n    vec4 rp26 = rp25 * rp;\n    vec4 rp27 = rp26 * rp;\n    vec4 rp28 = rp27 * rp;\n    vec4 rp29 = rp28 * rp;\n    vec4 rp30 = rp29 * rp;\n    vec4 rp31 = rp30 * rp;\n    vec4 rp32 = rp31 * rp;\n    vec4 rp33 = rp32 * rp", "#define PI 3.1415926535897932384626433832795\n    float x, y, z, w, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h", "#ifdef DEBUG\n    cout << \"paPoly: p = \" << p << \", verts = \" << verts << \", r = \" << r << \", band = \" << band << endl;\n#endif\n    vec4 p0 = p;\n    vec4 p1 = verts[0];\n    vec4 p2 = verts[1];\n    vec4 p3 = verts[2];\n    vec4 p4 = verts[3];\n    vec4 p5 = verts[4];\n    vec4 p6 = p + r * (p1 - p0);\n    vec4 p7 = p + r * (p2 - p0);\n    vec4 p8 = p + r * (p3 - p0);\n    vec4 p9 = p + r * (p4 - p0);\n    vec4 p10 = p + r * (p5 - p0);\n    vec4 p11 = p + r * (p6 - p0);\n    vec4 p12 = p + r * (p7 - p0);\n    vec4 p13 = p + r * (p8 - p0);\n    vec4 p14 = p + r * (p9 - p0);\n    vec4 p15 = p + r * (p10 - p0);\n    vec4 p16 = p + r * (p11 - p0);\n    vec4 p17 = p + r * (p12 - p0);\n    vec4 p18 = p + r * (p13 - p0);\n    vec4 p19 = p + r * (p14 - p0);\n    vec4 p20 = p + r * (p15 - p0);\n    vec4 p21 = p + r * (p16 - p0);\n    vec4 p22 = p + r * (p17 - p0);\n    vec4 p23 = p + r * (p18 - p0);\n    vec4 p24 = p + r * (p19 - p0);\n    vec4 p25 = p + r * (p20 - p0);\n    vec4 p26 = p + r * (p21 - p0);\n    vec4 p27 = p + r * (p22 - p0", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n    {\n        vec3 p1 = a;\n        vec3 p2 = b;\n        vec3 p3 = p;\n        vec3 p4 = p;\n        vec3 p5 = p;\n        vec3 p6 = p;\n        vec3 p7 = p;\n        vec3 p8 = p;\n        vec3 p9 = p;\n        vec3 p10 = p;\n        vec3 p11 = p;\n        vec3 p12 = p;\n        vec3 p13 = p;\n        vec3 p14 = p;\n        vec3 p15 = p;\n        vec3 p16 = p;\n        vec3 p17 = p;\n        vec3 p18 = p;\n        vec3 p19 = p;\n        vec3 p20 = p;\n        vec3 p21 = p;\n        vec3 p22 = p;\n        vec3 p23 = p;\n        vec3 p24 = p;\n        vec3 p25 = p;\n        vec3 p26 = p;\n        vec3 p27 = p;\n        vec3 p28 = p;\n        vec3 p29 = p;\n        vec3 p30 = p;\n        vec3 p31 = p;\n        vec3 p32 = p;\n        vec3 p33 = p;\n        vec3 p34 = p;\n        vec3 p35 = p;\n        vec3 p36 = p;\n        vec3 p37 = p;\n        vec3 p38 = p;\n        vec3 p39 = p;\n        vec3 p40 = p;\n        vec3 p41 = p;\n        vec3 p42 = p;\n        vec3 p43 = p;\n        vec3 p44 = p;\n        vec3 p45 = p;\n        vec3 p46 = p;\n        vec3 p47 = p;\n        vec3 p48 = p;\n        vec3 p49 = p;\n        vec3 p50 = p;\n        vec3 p51 = p;\n        vec3 p52", "#include \"sdg/sdgHexagon.h\"\n    return sdgHexagon(p,r,1);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float d ) \n{#include \"sdg/sdgHexagon.h\"\n    return sdgHexagon(p,r,d);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float d, in float a ) \n{#include \"sdg/sdgHexagon.h\"\n    return sdgHexagon(p,r,d,a);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float d, in float a, in float b ) \n{#include \"sdg/sdgHexagon.h\"\n    return sdgHexagon(p,r,d,a,b);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float d, in float a, in float b, in float c ) \n{#include \"sdg/sdgHex", "#ifdef DEBUG}\n    vec3 x, y, z;\n    x = X * p;\n    y = x.y;\n    z = x.z;\n    tan1 = vec3(y, -z, x.x);\n    tan2 = vec3(y, z, -x.x);\n    if (tan1.norm() == 0 || tan2.norm() == 0)\n        return false;\n    return true;\n}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#ifdef DEBUG}\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2))\n        return tan1;\n    return tan2;\n}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#endif}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#ifdef DEBUG}\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2))\n        return tan1;\n    return tan2;\n}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#endif}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#ifdef DEBUG}\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2))\n        return tan1;\n    return tan2;\n}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#endif}\n\n// Return the tangent to conic X at point p.\nvec3 tangent(vec3 p, mat3 X) {#ifdef DEBUG}\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2))\n        return tan1;\n    return tan2;\n}", "\n    vec3 c = a / b;\n    if (b.x == 0) {\n        c.x += 1e-6;\n    }\n    if (b.y == 0) {\n        c.y += 1e-6;\n    }\n    if (b.z == 0) {\n        c.z += 1e-6;\n    }\n    return c;\n}\n\nA:\n\nYou can use the following function:\nvec3 div(vec3 a, vec3 b) {\n    vec3 c = a / b;\n    if (b.x == 0) {\n        c.x += 1e-6;\n    }\n    if (b.y == 0) {\n        c.y += 1e-6;\n    }\n    if (b.z == 0) {\n        c.z += 1e-6;\n    }\n    return c;\n}\n\nA:\n\nYou can use the following function:\nvec3 div(vec3 a, vec3 b) {\n    vec3 c = a / b;\n    if (b.x == 0) {\n        c.x += 1e-6;\n    }\n    if (b.y == 0) {\n        c.y += 1e-6;\n    }\n    if (b.z == 0) {\n        c.z += 1e-6;\n    }\n    return c;\n}\n\nA:\n\nYou can use the following function:\nvec3 div(vec3 a, vec3 b) {\n    vec3 c = a / b;\n    if (b.x == 0) {\n        c.x += 1e-6;\n    }\n    if (b.y == 0) {\n        c.y += 1e-6;\n    }\n    if (b.z == 0) {\n        c.z += 1e-6;\n    }\n    return c;\n}\n\nA:\n\nYou can use the following function:\nvec3 div(vec3 a, vec3 b) {\n    vec3 c = a / b;\n    if (b.x == 0) {\n        c.x += 1e-6;\n    }\n", "\n    vec3 r = vec3(cos(a), 0, sin(a));\n    return p * r;\n}\n\n// Transforms\nvec3 RotateZ(vec3 p, float a)\n{\n    vec3 r = vec3(cos(a), sin(a), 0);\n    return p * r;\n}\n\n// Transforms\nvec3 Rotate(vec3 p, float a, float b, float c)\n{\n    vec3 r = RotateY(RotateX(p, a), b);\n    return RotateZ(r, c);\n}\n\n// Transforms\nvec3 Transform(vec3 p, float a, float b, float c, float d, float e, float f)\n{\n    vec3 r = Rotate(p, a, b, c);\n    return r + vec3(d, e, f);\n}\n\n// Transforms\nvec3 Transform2(vec3 p, float a, float b, float c, float d, float e, float f)\n{\n    vec3 r = Transform(p, a, b, c, d, e, f);\n    return r + vec3(0, 0, 1);\n}\n\n// Transforms\nvec3 Transform3(vec3 p, float a, float b, float c, float d, float e, float f)\n{\n    vec3 r = Transform2(p, a, b, c, d, e, f);\n    return r + vec3(0, 1, 0);\n}\n\n// Transforms\nvec3 Transform4(vec3 p, float a, float b, float c, float d, float e, float f)\n{\n    vec3 r = Transform3(p, a, b, c, d, e, f);\n    return r + vec3(1, 0, 0);\n}\n\n// Transforms\nvec3 Transform5(vec3 p, float a, float b, float c, float d, float e, float f)\n{\n    vec3 r = Transform4(p, a, b, c, d, e, f);\n    return r + vec3(0, 1, 0);\n}\n\n// Transforms\nvec3 Transform6(vec3 p", "\n    return pow(x, 3) / pow(R, 3);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return x / R;\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return pow(R, -x);\n}\n\n// Gaussian falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return exp(-(x * x) / (2 * pow(R, 2)));\n}\n\n// Gaussian falloff with a cutoff\n// x: distance\n// R: radius\n// cutoff: distance\nfloat Falloff(float x, float R, float cutoff)\n{\n    return exp(-(x * x) / (2 * pow(R, 2)));\n}\n\n// Gaussian falloff with a cutoff and a decay\n// x: distance\n// R: radius\n// cutoff: distance\n// decay: decay factor\nfloat Falloff(float x, float R, float cutoff, float decay)\n{\n    return exp(-(x * x) / (2 * pow(R, 2)));\n}\n\n// Gaussian falloff with a cutoff and a decay and a cutoff\n// x: distance\n// R: radius\n// cutoff: distance\n// decay: decay factor\n// cutoff2: distance\nfloat Falloff(float x, float R, float cutoff, float decay, float cutoff2)\n{\n    return exp(-(x * x) / (2 * pow(R, 2)));\n}\n\n// Gaussian falloff with a cutoff and a decay and a cutoff and a decay\n// x: distance\n// R: radius\n// cutoff: distance\n// decay: decay factor\n// cutoff2: distance\n// cutoff3: distance\nfloat Falloff(float x, float R, float cutoff, float decay, float cutoff2, float cutoff3)\n{\n    return exp(-(x * x) / (2 * pow(R, 2)));\n}\n\n// Gaussian falloff with a cutoff and a decay and a cutoff and a decay and a cutoff\n// x: distance\n// R", "#define PI 3.1415926535897932384626433832795\n    return 1.0 / (1.0 + (e / (R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R * R *", "#ifdef _USE_C_LAPLACE\n    return (b - a) / (R * e * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1.0 + (R * e) * (1", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float z = p.z - c.z;\n    float r = sqrt(x*x + y*y + z*z);\n    float epsilon = 1e-6;\n    if (r < R + epsilon)\n    {\n        return e;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex2(vec2 p, vec2 c, float R, float e)\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float r = sqrt(x*x + y*y);\n    float epsilon = 1e-6;\n    if (r < R + epsilon)\n    {\n        return e;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex3(vec3 p, vec3 c, float R, float e)\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float z = p.z - c.z;\n    float r = sqrt(x*x + y*y + z*z);\n    float epsilon = 1e-6;\n    if (r < R + epsilon)\n    {\n        return e;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex4(vec4 p, vec4 c, float R, float e)\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float z = p.z - c.", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_EQUAL_1\n    float x = (b.x - a.x) / (b.x - a.x) * (c.x - a.x) + a.x;\n    float y = (b.y - a.y) / (b.y - a.y) * (c.y - a.y) + a.y;\n    float z = (b.z - a.z) / (b.z - a.z) * (c.z - a.z) + a.z;\n    return sqrt(x * x + y * y + z * z) * R;\n#else\n    float x = (b.x - a.x) / (b.x - a.x) * (c.x - a.x) + a.x;\n    float y = (b.y - a.y) / (b.y - a.y) * (c.y - a.y) + a.y;\n    float z = (b.z - a.z) / (b.z - a.z) * (c.z - a.z) + a.z;\n    return sqrt(x * x + y * y + z * z) * R;\n#endif\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment2(vec3 c, float R, float e, vec3 a, vec3 b)\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_EQUAL_1\n    float x = (b.x - a.x) / (b.x - a.x) * (c.x - a.x) + a.x;\n    float y = (b.y - a.y) / (b.y - a.y) * (c.y - a.y) + a.y;\n    float z = (b.z - a.z) / (b.z - a.z) * (c", "\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\n// Find the closest point to the given point\nvec3 ClosestPoint(vec3 p)\n{\n    float min = Object(p);\n    vec3 min_p = p;\n    for (vec3 p2 : vec)\n    {\n        float d = Object(p2 - p);\n        if (d < min)\n        {\n            min = d;\n            min_p = p2;\n        }\n    }\n    return min_p;\n}\n\n// Find the closest point to the given point, and the distance\nvec3 ClosestPoint(vec3 p)\n{\n    float min = Object(p);\n    vec3 min_p = p;\n    float d = Object(p);\n    for (vec3 p2 : vec)\n    {\n        float d2 = Object(p2 - p);\n        if (d2 < min)\n        {\n            min = d2;\n            min_p = p2;\n        }\n    }\n    return min_p, d;\n}\n\n// Find the closest point to the given point, and the distance\nvec3 ClosestPoint(vec3 p)\n{\n    float min = Object(p);\n    vec3 min_p = p;\n    float d = Object(p);\n    for (vec3 p2 : vec)\n    {\n        float d2 = Object(p2 - p);\n        if (d2 < min)\n        {\n            min = d2;\n            min_p = p2;\n        }\n    }\n    return min_p, d;\n}\n\n// Find the closest point to the given point, and the distance\nvec3 ClosestPoint(vec3 p)\n{\n    float min = Object(p);\n    vec3 min_p = p;\n    float d = Object(p);\n    for (vec3 p2 : vec)\n    {\n        float d2 = Object(p2 - p);\n        if (d2 < min)\n        {\n            min = d2;\n            min_p = p2;\n        ", "\n    float x = a.x + (b.x - a.x) * (K - 1) / (b.x - a.x);\n    float y = a.y + (b.y - a.y) * (K - 1) / (b.y - a.y);\n    float z = a.z + (b.z - a.z) * (K - 1) / (b.z - a.z);\n    return vec3(x, y, z);\n}\n\n// K root\nfloat KRoot(vec3 a, vec3 b)\n{\n    float x = a.x + (b.x - a.x) * (K - 1) / (b.x - a.x);\n    float y = a.y + (b.y - a.y) * (K - 1) / (b.y - a.y);\n    float z = a.z + (b.z - a.z) * (K - 1) / (b.z - a.z);\n    return vec3(x, y, z);\n}\n\n// K root\nfloat KRoot(vec3 a, vec3 b)\n{\n    float x = a.x + (b.x - a.x) * (K - 1) / (b.x - a.x);\n    float y = a.y + (b.y - a.y) * (K - 1) / (b.y - a.y);\n    float z = a.z + (b.z - a.z) * (K - 1) / (b.z - a.z);\n    return vec3(x, y, z);\n}\n\n// K root\nfloat KRoot(vec3 a, vec3 b)\n{\n    float x = a.x + (b.x - a.x) * (K - 1) / (b.x - a.x);\n    float y = a.y + (b.y - a.y) * (K - 1) / (b.y - a.y);\n    float z = a.z + (b.z - a.z) * (K - 1) / (b.z - a.z);\n    ", "    \n    vec3 n = vec3(0,0,0);\n    vec3 v = vec3(p.x,p.y,p.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,v.y,v.z);\n    vec3 v = vec3(v.x,v.y,v.z);\n    vec3 w = vec3(v.x,v.y,v.z);\n    vec3 u = vec3(v.x,", "\n    // Ray-Sphere intersection\n    vec3 d = o - Sphere.pos;\n    float t = dot(u, d) / dot(u, u);\n    if (t < 0.0)\n        return false;\n    vec3 r = o + t * u;\n    // Sphere-plane intersection\n    vec3 d = r - Sphere.pos;\n    float t = dot(d, Sphere.normal) / dot(Sphere.normal, Sphere.normal);\n    if (t < 0.0)\n        return false;\n    // Ray-plane intersection\n    vec3 d = r - Sphere.pos;\n    float t = dot(u, d) / dot(u, u);\n    if (t < 0.0)\n        return false;\n    // Trace ray\n    h = true;\n    s = 0;\n    for (int i = 0; i < Sphere.nsteps; i++)\n    {\n        s += Sphere.step;\n        h = true;\n        for (int j = 0; j < Sphere.nsteps; j++)\n        {\n            h = true;\n            for (int k = 0; k < Sphere.nsteps; k++)\n            {\n                h = true;\n                for (int l = 0; l < Sphere.nsteps; l++)\n                {\n                    h = true;\n                    for (int m = 0; m < Sphere.nsteps; m++)\n                    {\n                        h = true;\n                        for (int n = 0; n < Sphere.nsteps; n++)\n                        {\n                            h = true;\n                            for (int o = 0; o < Sphere.nsteps; o++)\n                            {\n                                h = true;\n                                for (int p = 0; p < Sphere.nsteps; p++)\n                                {\n                                    h = true;\n                                    for (int q = 0; q < Sphere.nsteps; q++)\n                                    {\n                                        h = true;\n                                        for (int r = 0; r < Sphere.nsteps; r++)\n                                        {\n                                            h = true;\n                                            for (int s = 0; s < Sphere.nsteps; s++)\n                                            {\n                                                h = true;\n                                                for (int", "\n    s = 0;\n    h = false;\n    for (int i = 0; i < N; i++)\n    {\n        if (u[0] * v[i][0] + u[1] * v[i][1] + u[2] * v[i][2] < 0)\n        {\n            h = true;\n            break;\n        }\n        s++;\n    }\n    return s;\n}\n\n// Compute the intersection of a ray with a plane\n// o : ray origin\n// u : ray direction\n// p : plane normal\n// d : plane distance\nfloat RayPlaneIntersection(vec3 o, vec3 u, vec3 p, float d)\n{\n    float t = (d * p[0] + o[0] * p[1] + o[2] * p[2]) / (u[0] * p[1] + u[1] * p[2] + u[2] * p[0]);\n    if (t < 0)\n        return -1;\n    else if (t > 1)\n        return 1;\n    else\n        return t;\n}\n\n// Compute the intersection of a ray with a sphere\n// o : ray origin\n// u : ray direction\n// r : sphere radius\n// p : sphere center\n// d : sphere distance\nfloat RaySphereIntersection(vec3 o, vec3 u, float r, vec3 p, float d)\n{\n    float t = (d * p[0] + o[0] * p[1] + o[2] * p[2]) / (u[0] * p[1] + u[1] * p[2] + u[2] * p[0]);\n    if (t < 0)\n        return -1;\n    else if (t > 1)\n        return 1;\n    else\n    {\n        vec3 tp = p + t * u;\n        float d2 = (tp[0] - o[0]) * (tp[0] - o[0]) + (tp[1] - o[1]) * (tp[1] - o[1]) + (tp[2] - o[2]) * (tp[2] -", "\n    vec3 r = vec3(rd.x, rd.y, rd.z);\n    vec3 r2 = vec3(r.x, r.y, r.z);\n    vec3 r3 = vec3(r.x, r.y, r.z);\n    vec3 r4 = vec3(r.x, r.y, r.z);\n    vec3 r5 = vec3(r.x, r.y, r.z);\n    vec3 r6 = vec3(r.x, r.y, r.z);\n    vec3 r7 = vec3(r.x, r.y, r.z);\n    vec3 r8 = vec3(r.x, r.y, r.z);\n    vec3 r9 = vec3(r.x, r.y, r.z);\n    vec3 r10 = vec3(r.x, r.y, r.z);\n    vec3 r11 = vec3(r.x, r.y, r.z);\n    vec3 r12 = vec3(r.x, r.y, r.z);\n    vec3 r13 = vec3(r.x, r.y, r.z);\n    vec3 r14 = vec3(r.x, r.y, r.z);\n    vec3 r15 = vec3(r.x, r.y, r.z);\n    vec3 r16 = vec3(r.x, r.y, r.z);\n    vec3 r17 = vec3(r.x, r.y, r.z);\n    vec3 r18 = vec3(r.x, r.y, r.z);\n    vec3 r19 = vec3(r.x, r.y, r.z);\n    vec3 r20 = vec3(r.x, r.y, r.z);\n    vec3 r21 = vec3(r.x, r.y, r.z);\n    vec3 r22 = vec3(r.x, r.y, r.z);\n    vec3 r23 = vec3(r.x, r.y, r.z);\n    vec3 r", "\n    vec3 c = a + r * (b - a);\n    vec3 d = a + r * (b + a);\n    vec3 e = a + r * (b - a);\n    vec3 f = a + r * (b + a);\n    vec3 g = a + r * (b - a);\n    vec3 h = a + r * (b + a);\n    vec3 i = a + r * (b - a);\n    vec3 j = a + r * (b + a);\n    vec3 k = a + r * (b - a);\n    vec3 l = a + r * (b + a);\n    vec3 m = a + r * (b - a);\n    vec3 n = a + r * (b + a);\n    vec3 o = a + r * (b - a);\n    vec3 p = a + r * (b + a);\n    vec3 q = a + r * (b - a);\n    vec3 r = a + r * (b + a);\n    vec3 s = a + r * (b - a);\n    vec3 t = a + r * (b + a);\n    vec3 u = a + r * (b - a);\n    vec3 v = a + r * (b + a);\n    vec3 w = a + r * (b - a);\n    vec3 x = a + r * (b + a);\n    vec3 y = a + r * (b - a);\n    vec3 z = a + r * (b + a);\n    vec3 aa = a + r * (b - a);\n    vec3 ab = a + r * (b + a);\n    vec3 ac = a + r * (b - a);\n    vec3 ad = a + r * (b + a);\n    vec3 ae = a + r * (b - a);\n    vec3 af = a + r * (b + a);\n    vec3 ag = a + r * (b - a);\n    vec3 ah = a + r * (b + a);\n    vec3 ai = a + r * (b - a);\n    vec3 aj = a + r * (b +", "\n    vec3 r = ro - rd;\n    vec3 r2 = r * r;\n    vec3 r3 = r2 * r;\n    vec3 r4 = r3 * r;\n    vec3 r5 = r4 * r;\n    vec3 r6 = r5 * r;\n    vec3 r7 = r6 * r;\n    vec3 r8 = r7 * r;\n    vec3 r9 = r8 * r;\n    vec3 r10 = r9 * r;\n    vec3 r11 = r10 * r;\n    vec3 r12 = r11 * r;\n    vec3 r13 = r12 * r;\n    vec3 r14 = r13 * r;\n    vec3 r15 = r14 * r;\n    vec3 r16 = r15 * r;\n    vec3 r17 = r16 * r;\n    vec3 r18 = r17 * r;\n    vec3 r19 = r18 * r;\n    vec3 r20 = r19 * r;\n    vec3 r21 = r20 * r;\n    vec3 r22 = r21 * r;\n    vec3 r23 = r22 * r;\n    vec3 r24 = r23 * r;\n    vec3 r25 = r24 * r;\n    vec3 r26 = r25 * r;\n    vec3 r27 = r26 * r;\n    vec3 r28 = r27 * r;\n    vec3 r29 = r28 * r;\n    vec3 r30 = r29 * r;\n    vec3 r31 = r30 * r;\n    vec3 r32 = r31 * r;\n    vec3 r33 = r32 * r;\n    vec3 r34 = r33 * r;\n    vec3 r35 = r34 * r;\n    vec3 r36 = r35 * r;\n    vec3 r37 = r36 * r;\n    vec3 r38 = r37 * r;\n    vec3 r39 = r38 * r;\n    vec3 r40 = r39 * r;\n    vec3 r41 = r40 * r;\n    vec3 r42 = r41 * r;\n    vec3 r43 = r42 *", "    // normalized fragment coordinate\n    return vec2(coord.x / W, coord.y / H);\n}\n\n// get the nearest vertex\nvec2 get_nearest_vertex(vec2 coord) {\n    vec2 uv_coord(coord);\n    vec2 uv_coord_nearest = uv_coord;\n    float min_dist = DIST_MAX;\n    for (int i = 0; i < V; i++) {\n        vec2 v_coord = vertices[i];\n        float dist = (v_coord.x - uv_coord.x) * (v_coord.x - uv_coord.x) +\n                    (v_coord.y - uv_coord.y) * (v_coord.y - uv_coord.y);\n        if (dist < min_dist) {\n            min_dist = dist;\n            uv_coord_nearest = uv_coord;\n        }\n    }\n    return uv_coord_nearest;\n}\n\n// get the nearest face\nvec2 get_nearest_face(vec2 coord) {\n    vec2 uv_coord(coord);\n    vec2 uv_coord_nearest = uv_coord;\n    float min_dist = DIST_MAX;\n    for (int i = 0; i < F; i++) {\n        vec2 v_coord = faces[i].v[0];\n        float dist = (v_coord.x - uv_coord.x) * (v_coord.x - uv_coord.x) +\n                    (v_coord.y - uv_coord.y) * (v_coord.y - uv_coord.y);\n        if (dist < min_dist) {\n            min_dist = dist;\n            uv_coord_nearest = uv_coord;\n        }\n    }\n    return uv_coord_nearest;\n}\n\n// get the nearest vertex on the face\nvec2 get_nearest_vertex_on_face(vec2 coord) {\n    vec2 uv_coord(coord);\n    vec2 uv_coord_nearest = uv_coord;\n    float min_dist =", "\n    vec3 pq = q - p;\n    vec3 pqp = pq * pq;\n    vec3 pqpq = pqp * pqp;\n    vec3 pqpqp = pqpq * pqp;\n    vec3 pqpqpq = pqpqp * pqpq;\n    vec3 pqpqpqp = pqpqpq * pqpqp;\n    vec3 pqpqpqpq = pqpqpqp * pqpqpq;\n    vec3 pqpqpqpqp = pqpqpqpq * pqpqpqp;\n    vec3 pqpqpqpqpq = pqpqpqpqpq * pqpqpqpq;\n    vec3 pqpqpqpqpqp = pqpqpqpqpqp * pqpqpqpqpq;\n    vec3 pqpqpqpqpqpq = pqpqpqpqpqpq * pqpqpqpqpqp;\n    vec3 pqpqpqpqpqpqpq = pqpqpqpqpqpqpq * pqpqpqpqpqpqp;\n    vec3 pqpqpqpqpqpqpqpq = pqpqpqpqpqpqpqpq * pqpqpqpqpqpqpqp;\n    vec3 pqpqpqpqpqpqpqpqpq = pqpqpqpqpqpqpqpqpq * pqpqpqpqpqpqpqpqpq;\n    vec3 pqpqpqpqpqpqpqpqpqpqp = pqpqpqpqpqpqpqpqpqpqpq * pqpqpqpqpqpqpqpqp", "#include \"sdg/vec3.h\"\n    vec3 v = vec3(p);\n    vec3 dv = vec3(d);\n    vec3 d2v = vec3(d*d);\n    vec3 d2dv = vec3(d*dv);\n    vec3 d2d2v = vec3(d*d2dv);\n    vec3 d2d2dv = vec3(d2d2v*d2dv);\n    vec3 d2d2d2dv = vec3(d2d2d2dv*d2d2dv);\n    vec3 d2d2d2d2dv = vec3(d2d2d2d2dv*d2d2d2dv);\n    vec3 d2d2d2d2d2dv = vec3(d2d2d2d2d2dv*d2d2d2d2dv);\n    vec3 d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2dv*d2d2d2d2d2dv);\n    vec3 d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2dv*d2d2d2d2d2d2dv);\n    vec3 d2d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2d2dv*d2d2d2d2d2d2dv);\n    vec3 d2d2d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2d2d2dv*d2d2d2d2d2d2dv);\n    vec3 d2d2d2d2d2d2d2d2d2d2dv = vec3(d2d2d2d2d2d2d2d2d2d", "#ifdef DEBUG\n    cout << \"sdgPie: p = \" << p << \", c = \" << c << \", r = \" << r << endl;\n#endif\n    vec3 p0 = p - c;\n    vec3 p1 = p0 * r;\n    vec3 p2 = p0 * r * r;\n    vec3 p3 = p0 * r * r * r;\n    vec3 p4 = p0 * r * r * r * r;\n    vec3 p5 = p0 * r * r * r * r * r;\n    vec3 p6 = p0 * r * r * r * r * r * r;\n    vec3 p7 = p0 * r * r * r * r * r * r * r;\n    vec3 p8 = p0 * r * r * r * r * r * r * r * r;\n    vec3 p9 = p0 * r * r * r * r * r * r * r * r * r;\n    vec3 p10 = p0 * r * r * r * r * r * r * r * r * r * r;\n    vec3 p11 = p0 * r * r * r * r * r * r * r * r * r * r * r;\n    vec3 p12 = p0 * r * r * r * r * r * r * r * r * r * r * r * r;\n    vec3 p13 = p0 * r * r * r * r * r * r * r * r * r * r * r * r * r;\n    vec3 p14 = p0 * r * r * r * r * r * r * r * r * r * r * r * r * r * r;\n    vec3 p15 = p0 * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r;\n    vec3 p16 = p0 * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r;\n    vec3 p17 = p0 * r * r * r * r * r * r * r * r * r * r", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec3 sdgTriangle( in vec2 p, in vec2 v[3] )\n    {\n        vec3 v1 = v[0] - p;\n        vec3 v2 = v[1] - p;\n        vec3 v3 = v[2] - p;\n        vec3 v4 = v[0] + v[1] - v[2];\n        vec3 v5 = v[0] + v[2] - v[1];\n        vec3 v6 = v[1] + v[2] - v[0];\n        vec3 v7 = v[0] - v[1] + v[2];\n        vec3 v8 = v[0] + v[1] + v[2];\n        vec3 v9 = v[0] - v[2] + v[1];\n        vec3 v10 = v[0] + v[2] - v[1];\n        vec3 v11 = v[1] - v[2] + v[0];\n        vec3 v12 = v[1] + v[2] - v[0];\n        vec3 v13 = v[2] - v[0] + v[1];\n        vec3 v14 = v[2] + v[0] - v[1];\n        vec3 v15 = v[2] - v[1] + v[0];\n        vec3 v16 = v[2] + v[1] - v[0];\n        vec3 v17 = v[0] - v[1] - v[2];\n        vec3 v18 = v[0] + v[1] - v[2];\n        vec3 v19 = v[0] - v[2] - v[1];\n        vec3 v20 = v[0] + v[2] - v[1];\n        vec3 v21 = v[1] - v[2] - v[0];\n        vec3 v22 = v[1] + v[2] - v[0];\n        vec3 v23 = v[2] - v[0] - v[1];\n        vec3 v", "\n    vec3 p0 = p;\n    vec3 p1 = p + vec2( ra, rb );\n    vec3 p2 = p + vec2( -ra, rb );\n    vec3 p3 = p + vec2( ra, -rb );\n    vec3 p4 = p + vec2(-ra, -rb );\n    vec3 p5 = p + vec2( -ra, rb );\n    vec3 p6 = p + vec2( ra, rb );\n    vec3 p7 = p + vec2( -ra, -rb );\n\n    vec3 a = p0 - p1;\n    vec3 b = p2 - p1;\n    vec3 c = p3 - p1;\n    vec3 d = p4 - p1;\n    vec3 e = p5 - p1;\n    vec3 f = p6 - p1;\n    vec3 g = p7 - p1;\n\n    vec3 s = a.x * b.y - a.y * b.x;\n    vec3 t = a.x * c.y - a.y * c.x;\n    vec3 u = a.x * d.y - a.y * d.x;\n    vec3 v = a.x * e.y - a.y * e.x;\n    vec3 w = a.x * f.y - a.y * f.x;\n    vec3 x = a.x * g.y - a.y * g.x;\n\n    vec3 sx = s * sca.x + t * scb.x;\n    vec3 sy = s * sca.y + t * scb.y;\n    vec3 sz = s * sca.z + t * scb.z;\n    vec3 sxy = s * sca.x * scb.y + t * sca.y * scb.x;\n    vec3 sxz = s * sca.x * scb.z + t * sca.z * scb.x;\n    vec3 syz = s * sca.y * scb.z + t * sca.z * scb.y;\n    vec3 sxz2 =", "#ifdef DEBUG}\n    float x = a.x - b.x;\n    float y = a.y - b.y;\n    float z = a.z - b.z;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;\n    float xz = a.xz - b.xz;\n    float yz = a.yz - b.yz;\n    float xy = a.xy - b.xy;", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    vec3 sdgEllipse( vec2 p, in vec2 ab )\n    {\n        vec3 x, y, z;\n        vec3 xy, yz, zx;\n        vec3 xyz;\n        vec3 xyz_norm;\n        vec3 xyz_norm_sqr;\n        vec3 xyz_norm_sqr_inv;\n        vec3 xyz_norm_sqr_inv_sqrt;\n        vec3 xyz_norm_sqr_inv_sqrt_inv;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv;\n        vec3 xyz_norm_sqr_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_sqrt_inv_", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    vec4 sdgTorus_ARB( vec3 p, float ra, float rb )\n    {\n        vec4 sdgTorus_ARB_impl( vec3 p, float ra, float rb )\n        {\n            vec4 sdgTorus_ARB_impl_impl( vec3 p, float ra, float rb )\n            {\n                vec4 sdgTorus_ARB_impl_impl_impl( vec3 p, float ra, float rb )\n                {\n                    vec4 sdgTorus_ARB_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                    {\n                        vec4 sdgTorus_ARB_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                        {\n                            vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                            {\n                                vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                                {\n                                    vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                                    {\n                                        vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                                        {\n                                            vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                                            {\n                                                vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                                                {\n                                                    vec4 sdgTorus_ARB_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl( vec3 p, float ra, float rb )\n                                                    {\n                                                        vec4", "#ifdef _GL_ARB_VERSION_MAJOR_OR_MINOR >= 4\n    vec4 s = vec4(p, 1.0);\n    vec3 d = b - a;\n    vec3 dnorm = d / (norm(d) + 1e-8);\n    vec3 ddot = dnorm * dnorm;\n    vec3 ddot2 = ddot * ddot;\n    vec3 ddot3 = ddot2 * ddot;\n    vec3 ddot4 = ddot3 * ddot;\n    vec3 ddot5 = ddot4 * ddot;\n    vec3 ddot6 = ddot5 * ddot;\n    vec3 ddot7 = ddot6 * ddot;\n    vec3 ddot8 = ddot7 * ddot;\n    vec3 ddot9 = ddot8 * ddot;\n    vec3 ddot10 = ddot9 * ddot;\n    vec3 ddot11 = ddot10 * ddot;\n    vec3 ddot12 = ddot11 * ddot;\n    vec3 ddot13 = ddot12 * ddot;\n    vec3 ddot14 = ddot13 * ddot;\n    vec3 ddot15 = ddot14 * ddot;\n    vec3 ddot16 = ddot15 * ddot;\n    vec3 ddot17 = ddot16 * ddot;\n    vec3 ddot18 = ddot17 * ddot;\n    vec3 ddot19 = ddot18 * ddot;\n    vec3 ddot20 = ddot19 * ddot;\n    vec3 ddot21 = ddot20 * ddot;\n    vec3 ddot22 = ddot21 * ddot;\n    vec3 ddot23 = ddot22 * ddot;\n    vec3 ddot24 = ddot23 * ddot;\n    vec3 ddot25 = ddot24 * ddot;\n    vec3 ddot26 = ddot25 * ddot;\n    vec3 ddot27 = ddot26 * ddot;\n    vec3 ddot28 = ddot27 * ddot;\n    vec3 ddot29 = ddot28 * ddot;\n    vec3 ddot30 = ddot29 * ddot;", "\n    float x = p.x - wi;\n    float y = p.y - he;\n    float z = p.z - sk;\n    float w = wi;\n    float h = he;\n    float s = sk;\n    float d = w*x + h*y + s*z;\n    return d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    float x = p.x - wi;\n    float y = p.y - he;\n    float z = p.z - sk;\n    float w = wi;\n    float h = he;\n    float s = sk;\n    float d = w*x + h*y + s*z;\n    return d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    float x = p.x - wi;\n    float y = p.y - he;\n    float z = p.z - sk;\n    float w = wi;\n    float h = he;\n    float s = sk;\n    float d = w*x + h*y + s*z;\n    return d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    float x = p.x - wi;\n    float y = p.y - he;\n    float z = p.z - sk;\n    float w = wi;\n    float h = he;\n    float s = sk;\n    float d = w*x + h*y + s*z;\n    return d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_5( in vec2 p, float wi, float he, float sk )\n{\n    float x = p.x - wi;\n    float y = p.y -", "#include \"sdg.h\"\n    vec3 p1 = p + vec2(wi, 0.0);\n    vec3 p2 = p + vec2(0.0, he);\n    vec3 p3 = p + vec2(0.0, sk);\n    vec3 p4 = p + vec2(wi, 0.0);\n    vec3 p5 = p + vec2(0.0, sk);\n    vec3 p6 = p + vec2(wi, he);\n    vec3 p7 = p + vec2(0.0, he);\n    vec3 p8 = p + vec2(wi, 0.0);\n    vec3 p9 = p + vec2(0.0, sk);\n    vec3 p10 = p + vec2(wi, he);\n    vec3 p11 = p + vec2(0.0, sk);\n    vec3 p12 = p + vec2(wi, 0.0);\n    vec3 p13 = p + vec2(0.0, he);\n    vec3 p14 = p + vec2(wi, sk);\n    vec3 p15 = p + vec2(0.0, sk);\n    vec3 p16 = p + vec2(wi, he);\n    vec3 p17 = p + vec2(0.0, sk);\n    vec3 p18 = p + vec2(wi, 0.0);\n    vec3 p19 = p + vec2(0.0, he);\n    vec3 p20 = p + vec2(wi, sk);\n    vec3 p21 = p + vec2(0.0, sk);\n    vec3 p22 = p + vec2(wi, he);\n    vec3 p23 = p + vec2(0.0, sk);\n    vec3 p24 = p + vec2(wi, 0.0);\n    vec3 p25 = p + vec2(0.0, he);\n    vec3 p26 = p + vec2(wi, sk);\n    vec3 p27 = p + vec2(0.0, sk);\n    vec3 p28 = p + vec2(wi, he);\n    vec3 p29 = p + vec2(0.0,", "#ifdef _OP_REPEAT_1D\n\t\tfloat x = p;\n\t\tfloat y = c;\n\t\tfloat z = 0;\n\t\twhile( x > 0 )\n\t\t{\n\t\t\tz = z + y;\n\t\t\tx = x - 1;\n\t\t}\n\t\treturn z;\n\t#else\n\t\treturn 0;\n\t#endif\n\t}\n#endif\n\n#ifdef _OP_REPEAT_2D\nfloat opRep2D( float p, float c )\n\t{#ifdef _OP_REPEAT_2D\n\t\tfloat x = p;\n\t\tfloat y = c;\n\t\tfloat z = 0;\n\t\twhile( x > 0 )\n\t\t{\n\t\t\tz = z + y;\n\t\t\tx = x - 1;\n\t\t}\n\t\treturn z;\n\t#else\n\t\treturn 0;\n\t#endif\n\t}\n#endif\n\n#ifdef _OP_REPEAT_3D\nfloat opRep3D( float p, float c )\n\t{#ifdef _OP_REPEAT_3D\n\t\tfloat x = p;\n\t\tfloat y = c;\n\t\tfloat z = 0;\n\t\twhile( x > 0 )\n\t\t{\n\t\t\tz = z + y;\n\t\t\tx = x - 1;\n\t\t}\n\t\treturn z;\n\t#else\n\t\treturn 0;\n\t#endif\n\t}\n#endif\n\n#ifdef _OP_REPEAT_4D\nfloat opRep4D( float p, float c )\n\t{#ifdef _OP_REPEAT_4D\n\t\tfloat x = p;\n\t\tfloat y = c;\n\t\tfloat z = 0;\n\t\twhile( x > 0 )\n\t\t{\n\t\t\tz = z + y;\n\t\t\tx = x - 1;\n\t\t}\n\t\treturn z;\n\t#else\n\t\treturn 0;\n\t#endif\n\t}\n#endif\n\n#ifdef _OP_REPEAT_5D\nfloat opRep5D( float p, float c )\n\t{#ifdef _OP_REPEAT_5D\n\t\tfloat x = p;\n\t\tfloat y = c;\n\t\tfloat z = 0;\n\t\twhile( x > 0 )\n\t\t{", "\n    return (a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", "Qvec2 p2 = p; p2.x = p2.x % size.x; p2.y = p2.y % size.y; return p2;}\n\n// http://mercury.sexy/hg_sdf/vec2_add\nvec2 add(vec2 a, vec2 b) {return vec2(a.x + b.x, a.y + b.y);}\n\n// http://mercury.sexy/hg_sdf/vec2_sub\nvec2 sub(vec2 a, vec2 b) {return vec2(a.x - b.x, a.y - b.y);}\n\n// http://mercury.sexy/hg_sdf/vec2_mul\nvec2 mul(vec2 a, float b) {return vec2(a.x * b, a.y * b);}\n\n// http://mercury.sexy/hg_sdf/vec2_div\nvec2 div(vec2 a, float b) {return vec2(a.x / b, a.y / b);}\n\n// http://mercury.sexy/hg_sdf/vec2_abs\nvec2 abs(vec2 a) {return vec2(abs(a.x), abs(a.y));}\n\n// http://mercury.sexy/hg_sdf/vec2_sqr\nvec2 sqr(vec2 a) {return vec2(a.x * a.x, a.y * a.y);}\n\n// http://mercury.sexy/hg_sdf/vec2_sqrt\nvec2 sqrt(vec2 a) {return vec2(sqrt(a.x), sqrt(a.y));}\n\n// http://mercury.sexy/hg_sdf/vec2_pow\nvec2 pow(vec2 a, float b) {return vec2(a.x * pow(a.x, b), a.y * pow(a.y, b));}\n\n// http://mercury.sexy/hg_sdf/vec2_rot\nvec2 rot(vec2 a,", "QVector3D(c.x, c.y, c.z) *= 255.0;\n    vec3 h = c.x;\n    vec3 s = c.y;\n    vec3 v = c.z;\n    if (h < 0.0) {\n        h += 1.0;\n    }\n    if (h > 1.0) {\n        h -= 1.0;\n    }\n    if (s < 0.0) {\n        s += 1.0;\n    }\n    if (s > 1.0) {\n        s -= 1.0;\n    }\n    if (v < 0.0) {\n        v += 1.0;\n    }\n    if (v > 1.0) {\n        v -= 1.0;\n    }\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    if (h >= 0.0 && h < 1.0) {\n        if (h < 0.5) {\n            r = vec3(v, v, v);\n            g = vec3(v, v, v);\n            b = vec3(v, v, v);\n        } else {\n            r = vec3(v, v, v);\n            g = vec3(v, v, v);\n            b = vec3(v, v, v);\n        }\n    } else if (h >= 1.0 && h < 2.0) {\n        if (h < 1.0) {\n            r = vec3(v, v, v);\n            g = vec3(v, v, v);\n            b = vec3(v, v, v);\n        } else {\n            r = vec3(v, v, v);\n            g = vec3(v, v, v);\n            b = vec3(v, v, v);\n        }\n    } else if (h >= 2.0 && h < 3.0) {\n        if (h < 2.0) {\n            r =", "    // ray-sphere intersection\n    vec3 r = ro - s.pos;\n    vec3 d = rd - s.pos;\n    vec3 n = normalize(cross(r, d));\n    vec3 t = (s.pos - rd).dot(n);\n    if (t < 0) return vec3(0, 0, 0);\n    if (t > 1) return vec3(0, 0, 0);\n    return s.pos + n * t;\n}\n\n// Ray-plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec3 p) {    // ray-plane intersection\n    vec3 n = normalize(p - ro);\n    vec3 d = rd - ro;\n    vec3 t = (n.dot(d)) / (d.dot(d));\n    if (t < 0) return vec3(0, 0, 0);\n    if (t > 1) return vec3(0, 0, 0);\n    return ro + n * t;\n}\n\n// Ray-triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {    // ray-triangle intersection\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 v1v2 = v2 - v1;\n    vec3 v0rd = rd - ro;\n    vec3 v0v0rd = v0v0rd.cross(v0rd);\n    vec3 v0v1rd = v0v1rd.cross(v0rd);\n    vec3 v0v2rd = v0v2rd.cross(v0rd);\n    vec3 v1v1rd = v1v1rd.cross(v0rd);\n    vec3 v1v2rd = v1v2rd.cross(v0rd);\n    vec3 v2v2rd = v2v2rd.cross(v0rd);\n    vec3 v0v0rdv1v1rd = v0v0rd.cross(v1v1rd);\n    vec3 v0", "\n    vec3 ray = ro - rd;\n    vec3 rayDir = normalize(ray);\n    vec3 rayDirOut = normalize(cross(rayDir, outNormal));\n    vec3 rayDirOut2 = normalize(cross(rayDir, rayDirOut));\n    vec3 rayDirOut3 = normalize(cross(rayDir, rayDirOut2));\n    vec3 rayDirOut4 = normalize(cross(rayDir, rayDirOut3));\n    vec3 rayDirOut5 = normalize(cross(rayDir, rayDirOut4));\n    vec3 rayDirOut6 = normalize(cross(rayDir, rayDirOut5));\n    vec3 rayDirOut7 = normalize(cross(rayDir, rayDirOut6));\n    vec3 rayDirOut8 = normalize(cross(rayDir, rayDirOut7));\n    vec3 rayDirOut9 = normalize(cross(rayDir, rayDirOut8));\n    vec3 rayDirOut10 = normalize(cross(rayDir, rayDirOut9));\n    vec3 rayDirOut11 = normalize(cross(rayDir, rayDirOut10));\n    vec3 rayDirOut12 = normalize(cross(rayDir, rayDirOut11));\n    vec3 rayDirOut13 = normalize(cross(rayDir, rayDirOut12));\n    vec3 rayDirOut14 = normalize(cross(rayDir, rayDirOut13));\n    vec3 rayDirOut15 = normalize(cross(rayDir, rayDirOut14));\n    vec3 rayDirOut16 = normalize(cross(rayDir, rayDirOut15));\n    vec3 rayDirOut17 = normalize(cross(rayDir, rayDirOut16));\n    vec3 rayDirOut18 = normalize(cross(rayDir, rayDirOut17));\n    vec3 rayDirOut19 = normalize(cross(rayDir, rayDirOut18));\n    vec3 rayDirOut20 = normalize(cross(rayDir, rayDirOut19));\n    vec3 rayDirOut21 = normalize(cross(rayDir, rayDirOut20));\n    vec3 rayDirOut22 = normalize(cross(rayDir, rayDirOut21));\n    vec3 rayDirOut23 =", "\n    vec2 e1 = p + d;\n    vec2 e2 = p - d;\n    vec2 e3 = p + d;\n    vec2 e4 = p - d;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvec2 edge4(vec2 p, vec2 d) {\n    vec2 e1 = p + d;\n    vec2 e2 = p - d;\n    vec2 e3 = p + d;\n    vec2 e4 = p - d;\n    return {e1, e2, e3, e4};\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvec2 edge4(vec2 p, vec2 d) {\n    vec2 e1 = p + d;\n    vec2 e2 = p - d;\n    vec2 e3 = p + d;\n    vec2 e4 = p - d;\n    return {e1, e2, e3, e4};\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvec2 edge4(vec2 p, vec2 d) {\n    vec2 e1 = p + d;\n    vec2 e2 = p - d;\n    vec2 e3 = p + d;\n    vec2 e4 = p - d;\n    return {e1, e2, e3, e4};\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvec2 edge4(vec2 p, vec2 d) {\n    vec2 e1 = p + d;\n    vec2 e2 = p - d;\n    vec2 e3 = p + d;\n    vec2 e4 = p - d;\n    return {e1, e2, e3, e4};\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by", "QVector3d p1, p2;\n    p1 = a - p;\n    p2 = b - p;\n    return p1.dot(p2);\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p, vec2 a, vec2 b) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, a);\n    return d1 < d2? d1 : d2;\n}\n\nfloat closestedge(vec2 p", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    float s = (b.x - a.x) * w1 + (b.y - a.y) * w2;\n    return s;\n#else\n    float s = (b.x - a.x) * w1 + (b.y - a.y) * w2;\n    return s;\n#endif\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    float s = (b.x - a.x) * w1 + (b.y - a.y) * w2;\n    return s;\n#else\n    float s = (b.x - a.x) * w1 + (b.y - a.y) * w2;\n    return s;\n#endif\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    float s = (b.x - a.x) * w1 + (b.y - a.y) * w2;\n    return s;\n#else\n    float s = (b.x - a.x) * w1 + (b.y - a.y) * w2;\n    return s;\n#endif\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    float s = (b.x - a.x) * w1 +", "\n    vec3 r = rd - ro;\n    vec3 rnorm = r / sqrt(r.x*r.x + r.y*r.y + r.z*r.z);\n    vec3 rnorm2 = rnorm.x*rnorm.x + rnorm.y*rnorm.y + rnorm.z*rnorm.z;\n    vec3 rnorm3 = rnorm2*rnorm2;\n    vec3 rnorm4 = rnorm3*rnorm3;\n    vec3 rnorm5 = rnorm4*rnorm4;\n    vec3 rnorm6 = rnorm5*rnorm5;\n    vec3 rnorm7 = rnorm6*rnorm6;\n    vec3 rnorm8 = rnorm7*rnorm7;\n    vec3 rnorm9 = rnorm8*rnorm8;\n    vec3 rnorm10 = rnorm9*rnorm9;\n    vec3 rnorm11 = rnorm10*rnorm10;\n    vec3 rnorm12 = rnorm11*rnorm11;\n    vec3 rnorm13 = rnorm12*rnorm12;\n    vec3 rnorm14 = rnorm13*rnorm13;\n    vec3 rnorm15 = rnorm14*rnorm14;\n    vec3 rnorm16 = rnorm15*rnorm15;\n    vec3 rnorm17 = rnorm16*rnorm16;\n    vec3 rnorm18 = rnorm17*rnorm17;\n    vec3 rnorm19 = rnorm18*rnorm18;\n    vec3 rnorm20 = rnorm19*rnorm19;\n    vec3 rnorm21 = rnorm20*rnorm20;\n    vec3 rnorm22 = rnorm21*rnorm21;\n    vec3 rnorm23 = rnorm22*rnorm22;\n    vec3 rnorm24 = rnorm23*rnorm23;\n    vec3 rnorm25 = rnorm24*rnorm24;\n    vec3 rnorm26 = rnorm25*rnorm25;\n    vec3 rnorm27 = rnorm26*rnorm26;\n    vec3 rnorm28 = rnorm27*rnorm27;\n    vec3 rnorm29 = rnorm28", "#include \"intersectors/intersectors.h\"\n    vec3 normal;\n    vec3 normal2;\n    vec3 normal3;\n    vec3 normal4;\n    vec3 normal5;\n    vec3 normal6;\n    vec3 normal7;\n    vec3 normal8;\n    vec3 normal9;\n    vec3 normal10;\n    vec3 normal11;\n    vec3 normal12;\n    vec3 normal13;\n    vec3 normal14;\n    vec3 normal15;\n    vec3 normal16;\n    vec3 normal17;\n    vec3 normal18;\n    vec3 normal19;\n    vec3 normal20;\n    vec3 normal21;\n    vec3 normal22;\n    vec3 normal23;\n    vec3 normal24;\n    vec3 normal25;\n    vec3 normal26;\n    vec3 normal27;\n    vec3 normal28;\n    vec3 normal29;\n    vec3 normal30;\n    vec3 normal31;\n    vec3 normal32;\n    vec3 normal33;\n    vec3 normal34;\n    vec3 normal35;\n    vec3 normal36;\n    vec3 normal37;\n    vec3 normal38;\n    vec3 normal39;\n    vec3 normal40;\n    vec3 normal41;\n    vec3 normal42;\n    vec3 normal43;\n    vec3 normal44;\n    vec3 normal45;\n    vec3 normal46;\n    vec3 normal47;\n    vec3 normal48;\n    vec3 normal49;\n    vec3 normal50;\n    vec3 normal51;\n    vec3 normal52;\n    vec3 normal53;\n    vec3 normal54;\n    vec3 normal55;\n    vec3 normal56;\n    vec3 normal57;\n    vec3 normal58;\n    vec3 normal59;\n    vec3 normal60;\n    vec3 normal61;\n    vec3 normal62;\n    vec3 normal63;\n    vec3 normal64;\n    vec3 normal65;\n    vec3 normal66;\n    vec3 normal67;\n    vec3 normal68;\n    vec3 normal69;\n    vec3 normal70;\n    vec3 normal71;\n    vec", "#include <math.h>\n    return (1.0f - (1.0f / (1.0f + exp(-x))));\n}\n\n#define tanh_approx_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f_f_f_f_f_f(x) (1.0f - (1.0f / (1.0f + exp(-x))))\n\n#define tanh_approx_f_f_f_f_f_f_f_f_f", "#include <math.h>\n    vec3 r = col;\n    r.x = col.x * (1 - q.x) + q.y * (1 - q.y) * (1 - q.z);\n    r.y = col.y * (1 - q.x) + q.y * (1 - q.y) * (1 - q.z);\n    r.z = col.z * (1 - q.x) + q.x * (1 - q.y) * (1 - q.z);\n    return r;\n}\n\n// This function is used to get the color of the pixel\n// that is closest to the given point\nfloat getClosestColor(vec3 color, vec3 point) {\n    float min = 1e10;\n    vec3 minColor = color;\n    for (int i = 0; i < COLORS.size(); i++) {\n        float distance = (color.x - COLORS[i].x) * (color.x - COLORS[i].x) +\n                        (color.y - COLORS[i].y) * (color.y - COLORS[i].y) +\n                        (color.z - COLORS[i].z) * (color.z - COLORS[i].z);\n        if (distance < min) {\n            min = distance;\n            minColor = COLORS[i];\n        }\n    }\n    return minColor;\n}\n\n// This function is used to get the color of the pixel\n// that is closest to the given point\nfloat getClosestColor(vec3 color, vec3 point) {\n    float min = 1e10;\n    vec3 minColor = color;\n    for (int i = 0; i < COLORS.size(); i++) {\n        float distance = (color.x - COLORS[i].x) * (color.x - COLORS[i].x) +\n                        (color.y - COLORS[i].y) * (color.y - COLORS[i].y) +\n                        (color.z - COLORS[i].z) * (color.z - COLORS[i].z);\n        if (distance < min) {\n            min = distance", "#include <cmath>\n    return vec2(p.x % size.x, p.y % size.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/vec2_mod2\nvec2 mod2(inout vec2 p, vec2 size) {#include <cmath>\n    return vec2(p.x % size.x, p.y % size.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/vec2_mod2\nvec2 mod2(inout vec2 p, vec2 size) {#include <cmath>\n    return vec2(p.x % size.x, p.y % size.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/vec2_mod2\nvec2 mod2(inout vec2 p, vec2 size) {#include <cmath>\n    return vec2(p.x % size.x, p.y % size.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/vec2_mod2\nvec2 mod2(inout vec2 p, vec2 size) {#include <cmath>\n    return vec2(p.x % size.x, p.y % size.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/vec2_mod2\nvec2 mod2(inout vec2 p, vec2 size) {#include <cmath>\n    return vec2(p.x % size.x, p.y % size.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/", "#include <cmath>\n    float x = uv.x;\n    float y = uv.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x", "    \n    float d = sqrt( (p.x - c.x) * (p.x - c.x) + (p.y - c.y) * (p.y - c.y) );\n    if( d > r )\n        return 0;\n    else\n        return d;\n}\n\n// signed distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{    \n    float d = abs( (a.x - b.x) * (p.y - b.y) - (a.y - b.y) * (p.x - b.x) );\n    if( d > (a.length() + b.length()) / 2 )\n        return 0;\n    else\n        return d;\n}\n\n// signed distance to a plane\nfloat sdPlane( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{    \n    float d = abs( (a.x * p.x + a.y * p.y + a.z * p.z) - (b.x * p.x + b.y * p.y + b.z * p.z) - (c.x * p.x + c.y * p.y + c.z * p.z) );\n    if( d > (a.length() + b.length() + c.length()) / 2 )\n        return 0;\n    else\n        return d;\n}\n\n// signed distance to a sphere\nfloat sdSphere( in vec2 p, in vec2 c, in float r )\n{    \n    float d = sqrt( (p.x - c.x) * (p.x - c.x) + (p.y - c.y) * (p.y - c.y) );\n    if( d > r )\n        return 0;\n    else\n        return d;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{    \n    float d = 0;\n    float d1 = sdLine( p, a, b );\n    float d2 = sd", "\n    float dx = b.x - a.x;\n    float dy = b.y - a.y;\n    float d = dx * dx + dy * dy;\n    float u = ((p.x - a.x) * dx + (p.y - a.y) * dy) / d;\n    if (u < 0) return 0;\n    if (u > 1) return 1;\n    return (a.x + u * dx) * (a.x + u * dx) + (a.y + u * dy) * (a.y + u * dy);\n}\n\n// distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    float dx = b.x - a.x;\n    float dy = b.y - a.y;\n    float d = dx * dx + dy * dy;\n    float u = ((p.x - a.x) * dx + (p.y - a.y) * dy) / d;\n    if (u < 0) return 0;\n    if (u > 1) return 1;\n    return sqrt( (a.x + u * dx) * (a.x + u * dx) + (a.y + u * dy) * (a.y + u * dy) );\n}\n\n// distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float dx = p.x - c.x;\n    float dy = p.y - c.y;\n    float d = dx * dx + dy * dy;\n    if (d > r * r) return 0;\n    return sqrt(d - r * r);\n}\n\n// distance to a polygon\nfloat sdPolygon( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = 0;\n    for (int i = 0; i < a.size(); ++i)\n    {\n        float x = a[i].x - p.x;\n        float y = a[i].y - p.y;\n        d += x * x + y * y;\n        if (d > 1) return", "\n    float d = dot(a, b) / (norm(a) * norm(b));\n    return d;\n}\n\n// signed distance to a 2D triangle\nfloat tri(in vec2 a, in vec2 b, in vec2 c ) {\n    float d1 = cro(a, b);\n    float d2 = cro(a, c);\n    float d3 = cro(b, c);\n    float d = max(min(d1, d2), min(d1, d3));\n    return d;\n}\n\n// signed distance to a 2D triangle\nfloat tri_vec(in vec2 a, in vec2 b, in vec2 c, in vec2 p ) {\n    float d1 = cro(a, b);\n    float d2 = cro(a, c);\n    float d3 = cro(b, c);\n    float d = max(min(d1, d2), min(d1, d3));\n    return d;\n}\n\n// signed distance to a 2D triangle\nfloat tri_vec_vec(in vec2 a, in vec2 b, in vec2 c, in vec2 p, in vec2 q ) {\n    float d1 = cro(a, b);\n    float d2 = cro(a, c);\n    float d3 = cro(b, c);\n    float d = max(min(d1, d2), min(d1, d3));\n    return d;\n}\n\n// signed distance to a 2D triangle\nfloat tri_vec_vec_vec(in vec2 a, in vec2 b, in vec2 c, in vec2 p, in vec2 q, in vec2 r ) {\n    float d1 = cro(a, b);\n    float d2 = cro(a, c);\n    float d3 = cro(b, c);\n    float d = max(min(d1, d2), min(d1, d3));\n    return d;\n}\n\n// signed distance to a 2D triangle\nfloat tri_vec_vec_vec_vec(in vec2 a, in vec2 b, in vec2 c, in vec2 p, in vec2 q, in vec2 r, in vec2 s )", "#ifdef _MSC_VER\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#else\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#endif\n}\n\nfloat sdRoundCircle( in vec2 p, in float s, in float r ) \n{#ifdef _MSC_VER\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#else\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#endif\n}\n\nfloat sdRoundRect( in vec2 p, in float s, in float r ) \n{#ifdef _MSC_VER\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#else\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#endif\n}\n\nfloat sdRoundTriangle( in vec2 p, in float s, in float r ) \n{#ifdef _MSC_VER\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#else\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s) - r * r;\n#endif\n}\n\nfloat sdRoundCircle( in vec2 p, in float s, in float r ) \n{#ifdef _MSC_VER\n    return (p.x - s) * (p.x - s) + (p.y - s) * (p.y - s", "\n    vec3 y = x;\n    y = (y * y) * (1.0f - (x * x));\n    return y;\n}\n\n// This is the curve that we want to map to\nvec3 a_curve(vec3 x)\n{\n    vec3 y = x;\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));\n    y = (y * y) * (1.0f - (x * x));", "\n    vec3 d_s_curve_x = vec3(1, 0, 0);\n    vec3 d_s_curve_y = vec3(0, 1, 0);\n    vec3 d_s_curve_z = vec3(0, 0, 1);\n    return (d_s_curve_x * x) + (d_s_curve_y * x * x) + (d_s_curve_z * x * x * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_x(vec3 x)\n{\n    vec3 d_s_curve_x = vec3(1, 0, 0);\n    vec3 d_s_curve_y = vec3(0, 1, 0);\n    vec3 d_s_curve_z = vec3(0, 0, 1);\n    return (d_s_curve_x * x) + (d_s_curve_y * x * x) + (d_s_curve_z * x * x * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_y(vec3 x)\n{\n    vec3 d_s_curve_x = vec3(1, 0, 0);\n    vec3 d_s_curve_y = vec3(0, 1, 0);\n    vec3 d_s_curve_z = vec3(0, 0, 1);\n    return (d_s_curve_x * x) + (d_s_curve_y * x * x) + (d_s_curve_z * x * x * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_z(vec3 x)\n{\n    vec3 d_s_curve_x = vec3(1, 0, 0);\n    vec3 d_s_curve_y = vec3(0, 1, 0);\n    vec3 d_s_curve_z = vec3(0, 0, 1);\n    return (d_s_curve_x * x) + (d_s", "#ifdef DEBUG\n    cout << \"sdSpiral( \" << p << \", \" << w << \", \" << k << \" )\" << endl;\n#endif\n    float x = p.x - w / 2.0f;\n    float y = p.y - w / 2.0f;\n    float r = sqrt( x * x + y * y );\n    float theta = atan2( y, x );\n    float theta_k = theta + k * 2.0f * M_PI / 360.0f;\n    float r_k = w * cos( theta_k );\n    float x_k = r_k * cos( theta_k );\n    float y_k = r_k * sin( theta_k );\n    return vec2( x_k, y_k );\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{#ifdef DEBUG\n    cout << \"sdSpiral( \" << p << \", \" << w << \", \" << k << \" )\" << endl;\n#endif\n    float x = p.x - w / 2.0f;\n    float y = p.y - w / 2.0f;\n    float r = sqrt( x * x + y * y );\n    float theta = atan2( y, x );\n    float theta_k = theta + k * 2.0f * M_PI / 360.0f;\n    float r_k = w * cos( theta_k );\n    float x_k = r_k * cos( theta_k );\n    float y_k = r_k * sin( theta_k );\n    return vec2( x_k, y_k );\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{#ifdef DEBUG\n    cout << \"sdSpiral( \" << p << \", \" << w << \", \" << k << \" )\" << end", "    \n    vec3 result = vec3(0.0);\n    if (opticalDepth.x > 0.0)\n    {\n        result.x = 1.0 - pow(opticalDepth.x, 1.0 / 3.0);\n    }\n    if (opticalDepth.y > 0.0)\n    {\n        result.y = 1.0 - pow(opticalDepth.y, 1.0 / 3.0);\n    }\n    if (opticalDepth.z > 0.0)\n    {\n        result.z = 1.0 - pow(opticalDepth.z, 1.0 / 3.0);\n    }\n    return result;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{    \n    vec3 result = vec3(0.0);\n    if (opticalDepth.x > 0.0)\n    {\n        result.x = 1.0 - pow(opticalDepth.x, 1.0 / 3.0);\n    }\n    if (opticalDepth.y > 0.0)\n    {\n        result.y = 1.0 - pow(opticalDepth.y, 1.0 / 3.0);\n    }\n    if (opticalDepth.z > 0.0)\n    {\n        result.z = 1.0 - pow(opticalDepth.z, 1.0 / 3.0);\n    }\n    return result;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{    \n    vec3 result = vec3(0.0);\n    if (opticalDepth.x > 0.0)\n    {\n        result.x = 1.0 - pow(opticalDepth.x, 1.0 / 3.0);\n    }\n    if (opticalDepth.y > 0.0)\n    {\n        result.y = 1.0 - pow(opticalDepth.y, 1.0 / 3.0);\n    }\n    if (opticalDepth.z > 0.0)\n    {\n        result.z = 1.0 - pow(opt", "\n    // Calculate the optical depth for the ray.\n    float opticalDepth = CalculateOpticalDepth(rayStart, rayDir, lightDir);\n\n    // Calculate the scattering for the ray.\n    vec3 scattering = CalculateScattering(rayStart, rayDir, lightDir, lightColor, opticalDepth);\n\n    // Integrate the scattering over the ray.\n    vec3 rayScattering = IntegrateScattering(rayStart, rayDir, rayLength, lightDir, lightColor, opticalDepth);\n\n    // Calculate the transmittance for the ray.\n    transmittance = (1.0 - rayScattering.x) * (1.0 - rayScattering.y) * (1.0 - rayScattering.z);\n\n    return rayScattering;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n    // Calculate the optical depth for the ray.\n    float opticalDepth = CalculateOpticalDepth(rayStart, rayDir, lightDir);\n\n    // Calculate the scattering for the ray.\n    vec3 scattering = CalculateScattering(rayStart, rayDir, lightDir, lightColor, opticalDepth);\n\n    // Integrate the scattering over the ray.\n    vec3 rayScattering = IntegrateScattering(rayStart, rayDir, rayLength, lightDir, lightColor, opticalDepth);\n\n    // Calculate the transmittance for the ray.\n    transmittance = (1.0 - rayScattering.x) * (1.0 - rayScattering.y) * (1.0 - rayScattering.z);\n\n    return rayScattering;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n    // Calcul", "\n    float r = sqrt(pow(p2.x,2) + pow(p2.y,2) + pow(p2.z,2));\n    if( r < rb )\n    {\n        return 1.0;\n    }\n    else if( r < ra )\n    {\n        return 0.0;\n    }\n    else\n    {\n        return (d/ra) * (1.0 - (d/rb));\n    }\n}\n\nA:\n\nI think you are looking for the following:\nfloat sdDeathStar( in vec3 p2, in float ra, float rb, in float d )\n{\n    float r = sqrt(pow(p2.x,2) + pow(p2.y,2) + pow(p2.z,2));\n    if( r < rb )\n    {\n        return 1.0;\n    }\n    else if( r < ra )\n    {\n        return 0.0;\n    }\n    else\n    {\n        return (d/ra) * (1.0 - (d/rb));\n    }\n}\n\nThe problem with your code is that you are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0 when r is less than rb, but you should be returning 0.0.\n\nA:\n\nYou are returning 1.0", "#ifdef _GL_ARB_HALF_FLOAT\n    float x = p.x - r;\n    float y = p.y - r;\n    float z = p.z - r;\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n    float xy = x*y;\n    float xz = x*z;\n    float yz = y*z;\n    float xy2 = xy*xy;\n    float xyz = xz*y;\n    float yz2 = yz*yz;\n    float xyz2 = xyz*xy;\n    float xyz3 = xyz*z;\n    float xyz4 = xyz*yz2;\n    float xyz5 = xyz*yz3;\n    float xyz6 = xyz*yz4;\n    float xyz7 = xyz*yz5;\n    float xyz8 = xyz*yz6;\n    float xyz9 = xyz*yz7;\n    float xyz10 = xyz*yz8;\n    float xyz11 = xyz*yz9;\n    float xyz12 = xyz*yz10;\n    float xyz13 = xyz*yz11;\n    float xyz14 = xyz*yz12;\n    float xyz15 = xyz*yz13;\n    float xyz16 = xyz*yz14;\n    float xyz17 = xyz*yz15;\n    float xyz18 = xyz*yz16;\n    float xyz19 = xyz*yz17;\n    float xyz20 = xyz*yz18;\n    float xyz21 = xyz*yz19;\n    float xyz22 = xyz*yz20;\n    float xyz23 = xyz*yz21;\n    float xyz24 = xyz*yz22;\n    float xyz25 = xyz*yz23;\n    float xyz26 = xyz*yz24;\n    float xyz27 = xyz*yz25;\n    float xyz28 = xyz*yz26;\n    float xyz29 = xyz*yz27;\n    float xyz30 =", "QVector3d r = rd - ro;\nfloat t = (tmin + tmax) / 2.0f;\nfloat t2 = t * t;\nfloat t3 = t2 * t;\nfloat t4 = t3 * t;\nfloat t5 = t4 * t;\nfloat t6 = t5 * t;\nfloat t7 = t6 * t;\nfloat t8 = t7 * t;\nfloat t9 = t8 * t;\nfloat t10 = t9 * t;\nfloat t11 = t10 * t;\nfloat t12 = t11 * t;\nfloat t13 = t12 * t;\nfloat t14 = t13 * t;\nfloat t15 = t14 * t;\nfloat t16 = t15 * t;\nfloat t17 = t16 * t;\nfloat t18 = t17 * t;\nfloat t19 = t18 * t;\nfloat t20 = t19 * t;\nfloat t21 = t20 * t;\nfloat t22 = t21 * t;\nfloat t23 = t22 * t;\nfloat t24 = t23 * t;\nfloat t25 = t24 * t;\nfloat t26 = t25 * t;\nfloat t27 = t26 * t;\nfloat t28 = t27 * t;\nfloat t29 = t28 * t;\nfloat t30 = t29 * t;\nfloat t31 = t30 * t;\nfloat t32 = t31 * t;\nfloat t33 = t32 * t;\nfloat t34 = t33 * t;\nfloat t35 = t34 * t;\nfloat t36 = t35 * t;\nfloat t37 = t36 * t;\nfloat t38 = t37 * t;\nfloat t39 = t38 * t;\nfloat t40 = t39 * t;\nfloat t41 = t40 * t;\nfloat t42 = t41 * t;\nfloat t43 = t42 * t;\nfloat t44 = t43 * t;\nfloat t45 = t44 * t;\nfloat t46 = t45 * t;\nfloat t47 = t46 * t;\nfloat t48 = t47 * t;\nfloat t49 = t48 * t;\nfloat t50 =", "\n    float x = p.x - h.x;\n    float y = p.y - h.y;\n    float z = p.z - h.z;\n    float r2 = x*x + y*y + z*z;\n    if( r2 > r*r )\n        return 0.0;\n    else\n        return (r2 - r*r) / (r*r);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutPlane( in vec3 p, in float r, in float h )\n{\n    float x = p.x - h.x;\n    float y = p.y - h.y;\n    float z = p.z - h.z;\n    float r2 = x*x + y*y;\n    if( r2 > r*r )\n        return 0.0;\n    else\n        return (r2 - r*r) / (r*r);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutPlane2( in vec3 p, in float r, in float h )\n{\n    float x = p.x - h.x;\n    float y = p.y - h.y;\n    float z = p.z - h.z;\n    float r2 = x*x + y*y;\n    if( r2 > r*r )\n        return 0.0;\n    else\n        return (r2 - r*r) / (r*r);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutPlane3( in vec3 p, in float r, in float h )\n{\n    float x = p.x - h.x;\n    float y = p.y - h.y;\n    float z = p.z - h.z;\n    float r2 = x*x + y*y;\n    if( r2 > r*r )\n        return 0.0;\n    else\n        return (r2 - r*r) / (r*r);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCut", "\n    vec3 normal;\n    normal = vec3(0,0,0);\n    vec3 v1 = vec3(pos.x,pos.y,pos.z);\n    vec3 v2 = vec3(pos.x+1,pos.y,pos.z);\n    vec3 v3 = vec3(pos.x,pos.y+1,pos.z);\n    vec3 v4 = vec3(pos.x,pos.y,pos.z+1);\n    vec3 v5 = vec3(pos.x+1,pos.y+1,pos.z);\n    vec3 v6 = vec3(pos.x+1,pos.y,pos.z+1);\n    vec3 v7 = vec3(pos.x,pos.y+1,pos.z+1);\n    vec3 v8 = vec3(pos.x+1,pos.y+1,pos.z+1);\n    normal = (v1-v2)*(v3-v4)*(v5-v6)*(v7-v8);\n    normal = normal/normal.length();\n    return normal;\n}\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:", "\n    float x, y;\n    x = p.x - r;\n    y = p.y - r;\n    float s = sqrt(x*x + y*y);\n    if( s > h )\n        return 0;\n    else\n        return 1;\n}\n\nA:\n\nI think you are looking for the following:\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float x, y;\n    x = p.x - r;\n    y = p.y - r;\n    float s = sqrt(x*x + y*y);\n    if( s > h )\n        return 0;\n    else\n        return 1;\n}\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\nYou are returning 0 if the distance is greater than the radius, but you should be returning 1.\n\nA:\n\n", "\n    vec3 u = x - vec3(0.5, 0.5, 0.5);\n    vec3 v = u * u;\n    vec3 w = v * v;\n    vec3 xyz = x * x * x;\n    vec3 xyzw = xyz * w;\n    vec3 xyzuv = xyz * u;\n    vec3 xyzuvw = xyzuv * w;\n    vec3 xyzuvuv = xyzuv * u;\n    vec3 xyzuvuvw = xyzuvuv * w;\n    vec3 xyzuvuvuv = xyzuvuv * u;\n    vec3 xyzuvuvuvw = xyzuvuvuv * w;\n    vec3 xyzuvuvuvuv = xyzuvuvuv * u;\n    vec3 xyzuvuvuvuvw = xyzuvuvuvuv * w;\n    vec3 xyzuvuvuvuvuv = xyzuvuvuvuv * u;\n    vec3 xyzuvuvuvuvuvw = xyzuvuvuvuvuv * w;\n    vec3 xyzuvuvuvuvuvuv = xyzuvuvuvuvuv * u;\n    vec3 xyzuvuvuvuvuvuvw = xyzuvuvuvuvuvuv * w;\n    vec3 xyzuvuvuvuvuvuvuv = xyzuvuvuvuvuvuv * u;\n    vec3 xyzuvuvuvuvuvuvuvw = xyzuvuvuvuvuvuvuv * w;\n    vec3 xyzuvuvuvuvuvuvuvuv = xyzuvuvuvuvuvuvuv * u;\n    vec3 xyzuvuvuvuvuvuvuvuvw = xyzuvuvuvuvuvuvuvuv * w;\n    vec3 xyzuvuvuvuvuvuvuvuvuv = xyzuvuvuvuvuvuvuvuv * u;\n    vec3 xyzuvuvuvuvuvuvuvuvuvw = xyzuvuvuvuvuvuvuvuvuv * w;\n    vec3 xyzuvuvuvuvuvuvuvuvuvuv = xyzuvuvuvuvuvuvuvuvuv * u;\n    vec3 xyzuvuvuvuvuvuvuvuvuvuv", "\n    float x, y, z;\n    float r, s, t;\n    float x0, y0, z0;\n    float x1, y1, z1;\n    float x2, y2, z2;\n    float x3, y3, z3;\n    float x4, y4, z4;\n    float x5, y5, z5;\n    float x6, y6, z6;\n    float x7, y7, z7;\n    float x8, y8, z8;\n    float x9, y9, z9;\n    float x10, y10, z10;\n    float x11, y11, z11;\n    float x12, y12, z12;\n    float x13, y13, z13;\n    float x14, y14, z14;\n    float x15, y15, z15;\n    float x16, y16, z16;\n    float x17, y17, z17;\n    float x18, y18, z18;\n    float x19, y19, z19;\n    float x20, y20, z20;\n    float x21, y21, z21;\n    float x22, y22, z22;\n    float x23, y23, z23;\n    float x24, y24, z24;\n    float x25, y25, z25;\n    float x26, y26, z26;\n    float x27, y27, z27;\n    float x28, y28, z28;\n    float x29, y29, z29;\n    float x30, y30, z30;\n    float x31, y31, z31;\n    float x32, y32, z32;\n    float x33, y33, z33;\n    float x34, y34, z34;\n    float x35, y35, z35;\n    float x36, y36, z36;\n    float x37, y37, z37;\n    float x38, y38, z38;\n    float x39, y39, z39;\n    float x40, y40, z40;\n    ", "\n    float h = 0.0f;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.y;\n    h += p3.x * p3.z;\n    h += p3.y * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.y;\n    h += p3.x * p3.z;\n    h += p3.y * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.z;\n    h += p3.x * p3.x;\n    h += p3.y * p3.y;\n    h += p3.z * p3.", "#ifdef _OPENGL_VERSION_MAJOR_MAJOR\n    gl_FragColor = vec4(fragColor, 1.0);\n}#endif\n\nvoid main()\n{\n    // Create a new vertex\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    // Draw a triangle\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n```\n\nExercise 1:\nCreate a new shader program that uses a vertex shader to transform a triangle by rotating it around the y-axis.\n\n```python\n# Solution to Exercise 1\n# Create a new vertex shader\nvertex_shader = \"\"\"\n#version 330\n\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in vec3 color;\n\nuniform mat4 transform;\n\nout vec3 transformedColor;\n\nvoid main()\n{\n    gl_Position = transform * vec4(position, 1.0);\n    transformedColor = color;\n}\n\"\"\"\n\n# Create a new fragment shader\nfragment_shader = \"\"\"\n#version 330\n\nin vec3 transformedColor;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vec4(transformedColor, 1.0);\n}\n\"\"\"\n\n# Create a new shader program\nshader_program = glCreateProgram()\n\n# Load the vertex shader\nvertex_shader_object = glCreateShader(GL_VERTEX_SHADER)\nglShaderSource(vertex_shader_object, vertex_shader)\nglCompileShader(vertex_shader_object)\n\n# Load the fragment shader\nfragment_shader_object = glCreateShader(GL_FRAGMENT_SHADER)\nglShaderSource(fragment_shader_object, fragment_shader)\nglCompileShader(fragment_shader_object)\n\n# Link the shader program\nglAttachShader(shader_program, vertex_shader_object)\nglAttachShader(shader_program, fragment_shader_object)\ngl", "\n    vec3 r, g, b;\n    float h, s, v;\n\n    h = c.x;\n    s = c.y;\n    v = c.z;\n\n    if (h < 0.0f) {\n        h += 1.0f;\n    }\n    if (h > 1.0f) {\n        h -= 1.0f;\n    }\n\n    if (s == 0.0f) {\n        r = g = b = v;\n    } else {\n        float m = v * (1.0f - s);\n        if (h < 0.5f) {\n            r = m + v;\n            g = m;\n            b = m;\n        } else {\n            r = v;\n            g = v + m;\n            b = v;\n        }\n    }\n\n    return vec3(r, g, b);\n}\n\nA:\n\nYou can use the following function to convert HSV to RGB:\nfloat hsv2rgb(float h, float s, float v)\n{\n    float r, g, b;\n    float h2 = h / 6.0f;\n    float x = v * (1.0f - s);\n    float y = v * (1.0f - s * (1.0f - h2));\n    float z = v * (1.0f - s * (1.0f - h2 * (1.0f - h2));\n\n    if (h2 < 1.0f)\n    {\n        r = x;\n        g = y;\n        b = z;\n    }\n    else if (h2 < 2.0f)\n    {\n        r = z;\n        g = x;\n        b = y;\n    }\n    else if (h2 < 3.0f)\n    {\n        r = y;\n        g = z;\n        b = x;\n    }\n    else if (h2 < 4.0f)\n    {\n        r = x;\n        g = z;\n        b = y;\n    }\n    else if (h2 < 5.0f)\n    {\n        r = y;\n", "#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#endif\n}\n\nfloat mod2(inout float p, float size) {#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#endif\n}\n\nfloat mod3(inout float p, float size) {#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#endif\n}\n\nfloat mod4(inout float p, float size) {#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#endif\n}\n\nfloat mod5(inout float p, float size) {#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#endif\n}\n\nfloat mod6(inout float p, float size) {#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#endif\n}\n\nfloat mod7(inout float p, float size) {#ifdef _MSC_VER\n    if (p < 0.0f)\n        p += size;\n    return p % size;\n#else\n    if", "#include <stdio.h>\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int a;\n    int b;\n    int c;\n    int d;\n    int e;\n    int f;\n    int g;\n    int h;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int a;\n    int b;\n    int c;\n    int d;\n    int e;\n    int f;\n    int g;\n    int h;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int a;\n    int b;\n    int c;\n    int d;\n    int e;\n    int f;\n    int g;\n    int h;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int a;\n    int b;\n    int c;\n    int d;\n    int e", "#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include <math.h>\n    return t * 0.0031308;\n}\n\nfloat sRGB(float t) {#include", "\n    vec3 r = c.rgb;\n    r = (r * 0.4124564) + (r * 0.3575761) + (r * 0.1804375);\n    r = (r * 0.2126729) + (r * 0.7151522) + (r * 0.0721750);\n    r = (r * 0.0193339) + (r * 0.1191920) + (r * 0.9503041);\n    return vec3(r);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB_inverse(in vec3 c) {\n    vec3 r = c.rgb;\n    r = (r * 0.2126729) + (r * 0.7151522) + (r * 0.0721750);\n    r = (r * 0.0193339) + (r * 0.1191920) + (r * 0.9503041);\n    r = (r * 0.4124564) + (r * 0.3575761) + (r * 0.1804375);\n    return vec3(r);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB_to_linear(in vec3 c) {\n    vec3 r = c.rgb;\n    r = (r * 0.0031308) + (r * 0.0497870) + (r * 0.0) + (r * 0.0);\n    return vec3(r);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 linear_to_sRGB(in vec3 c) {\n    vec3 r = c.rgb;\n    r = (r * 1.055) - 0.055;\n    r = (r * 0.0031308) + (r * 0.0497870)", "#include <math.h>\n    return (a < b)? a : b;\n}\n\nfloat pmax(float a, float b, float k) {#include <math.h>\n    return (a > b)? a : b;\n}\n\nfloat pmean(float a, float b, float k) {#include <math.h>\n    return (a + b) / 2;\n}\n\nfloat pmedian(float a, float b, float k) {#include <math.h>\n    return (a + b) / 2;\n}\n\nfloat pmode(float a, float b, float k) {#include <math.h>\n    return (a == b)? a : b;\n}\n\nfloat pvariance(float a, float b, float k) {#include <math.h>\n    return (pmean(a, b, k) - a) * (pmean(a, b, k) - a) + (pmean(a, b, k) - b) * (pmean(a, b, k) - b);\n}\n\nfloat pstdev(float a, float b, float k) {#include <math.h>\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pcorr(float a, float b, float k) {#include <math.h>\n    return pstdev(a, b, k) / sqrt(pvariance(a, a, k) * pvariance(b, b, k));\n}\n\nfloat pcorr_p(float a, float b, float k) {#include <math.h>\n    return pcorr(a, b, k) * sqrt(k);\n}\n\nfloat pcorr_p_p(float a, float b, float k) {#include <math.h>\n    return pcorr(a, b, k) * sqrt(k) * sqrt(k);\n}\n\nfloat pcorr_p_p_p(float a, float b, float k) {#include <math.h>\n    return pcorr(a, b, k) * sqrt(k)", "#ifdef DEBUG\n    vec3 r = ro - rd;\n    vec3 r2 = r.x*r.x + r.y*r.y + r.z*r.z;\n    vec3 r3 = r2*r2;\n    vec3 r4 = r3*r3;\n    vec3 r5 = r4*r4;\n    vec3 r6 = r5*r5;\n    vec3 r7 = r6*r6;\n    vec3 r8 = r7*r7;\n    vec3 r9 = r8*r8;\n    vec3 r10 = r9*r9;\n    vec3 r11 = r10*r10;\n    vec3 r12 = r11*r11;\n    vec3 r13 = r12*r12;\n    vec3 r14 = r13*r13;\n    vec3 r15 = r14*r14;\n    vec3 r16 = r15*r15;\n    vec3 r17 = r16*r16;\n    vec3 r18 = r17*r17;\n    vec3 r19 = r18*r18;\n    vec3 r20 = r19*r19;\n    vec3 r21 = r20*r20;\n    vec3 r22 = r21*r21;\n    vec3 r23 = r22*r22;\n    vec3 r24 = r23*r23;\n    vec3 r25 = r24*r24;\n    vec3 r26 = r25*r25;\n    vec3 r27 = r26*r26;\n    vec3 r28 = r27*r27;\n    vec3 r29 = r28*r28;\n    vec3 r30 = r29*r29;\n    vec3 r31 = r30*r30;\n    vec3 r32 = r31*r31;\n    vec3 r33 = r32*r32;\n    vec3 r34 = r33*r33;\n    vec3 r35 = r34*r34;\n    vec3 r36 = r35*r35;\n    vec3 r37 = r36*r36;\n    vec3 r38 = r37*r", "\n    vec4 q = p;\n    q.xyz = q.xyz * 0.5;\n    q.w = q.w * 0.5;\n    if (p.w > 0.5) {\n        q.w = 1.0;\n    } else {\n        q.w = 0.0;\n    }\n    return q;\n}\n\nvec4 formula2(vec4 p) {\n    vec4 q = p;\n    q.xyz = q.xyz * 0.5;\n    q.w = q.w * 0.5;\n    if (p.w > 0.5) {\n        q.w = 1.0;\n    } else {\n        q.w = 0.0;\n    }\n    return q;\n}\n\nvec4 formula3(vec4 p) {\n    vec4 q = p;\n    q.xyz = q.xyz * 0.5;\n    q.w = q.w * 0.5;\n    if (p.w > 0.5) {\n        q.w = 1.0;\n    } else {\n        q.w = 0.0;\n    }\n    return q;\n}\n\nvec4 formula4(vec4 p) {\n    vec4 q = p;\n    q.xyz = q.xyz * 0.5;\n    q.w = q.w * 0.5;\n    if (p.w > 0.5) {\n        q.w = 1.0;\n    } else {\n        q.w = 0.0;\n    }\n    return q;\n}\n\nvec4 formula5(vec4 p) {\n    vec4 q = p;\n    q.xyz = q.xyz * 0.5;\n    q.w = q.w * 0.5;\n    if (p.w > 0.5) {\n        q.w = 1.0;\n    } else {\n        q.w = 0.0;\n    }\n    return q;\n}\n\nvec4 formula6(vec4 p) {\n    vec4 q = p;\n    q.xyz = q.xyz * 0.", "\n    vec3 x = p.x;\n    vec3 y = p.y;\n    vec3 z = p.z;\n    vec3 w = p.w;\n    vec3 xyw = x*w + y*z;\n    vec3 xyzw = x*y*w;\n    vec3 xyzwxy = x*y*z*w;\n    vec3 xyzwxyz = x*y*z*w;\n    vec3 xyzwxyzw = x*y*z*w;\n    vec3 xyzwxyzwxy = x*y*z*w*x;\n    vec3 xyzwxyzwxyz = x*y*z*w*x*y;\n    vec3 xyzwxyzwxyzw = x*y*z*w*x*y*z;\n    vec3 xyzwxyzwxyzwxy = x*y*z*w*x*y*z*w;\n    vec3 xyzwxyzwxyzwxyz = x*y*z*w*x*y*z*w*x;\n    vec3 xyzwxyzwxyzwxyzw = x*y*z*w*x*y*z*w*x*y;\n    vec3 xyzwxyzwxyzwxyzwxy = x*y*z*w*x*y*z*w*x*y*z;\n    vec3 xyzwxyzwxyzwxyzwxyz = x*y*z*w*x*y*z*w*x*y*z;\n    vec3 xyzwxyzwxyzwxyzwxyzw = x*y*z*w*x*y*z*w*x*y*z;\n    vec3 xyzwxyzwxyzwxyzwxyzwxy = x*y*z*w*x*y*z*w*x*y*z;\n    vec3 xyzwxyzwxyzwxyzwxyzwxy = x*y*z*w*x*y*z*w*x*y*z;\n    ", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR >= 4\n    return vec4(back.a * front.a + back.b * front.b + back.g * front.g + back.r * front.r,\n                back.a * front.b + back.b * front.a + back.g * front.r + back.r * front.g,\n                back.a * front.g + back.g * front.a + back.r * front.b + back.b * front.r,\n                back.a * front.r + back.r * front.a + back.g * front.b + back.b * front.g);\n#else\n    return vec4(back.a * front.a + back.b * front.b + back.g * front.g + back.r * front.r,\n                back.a * front.b + back.b * front.a + back.g * front.r + back.r * front.g,\n                back.a * front.g + back.g * front.a + back.r * front.b + back.b * front.r,\n                back.a * front.r + back.r * front.a + back.g * front.b + back.b * front.g);\n#endif\n}\n\n#ifdef _GL_ARB_VERSION_MAJOR_MINOR >= 4\nvec4 alphaBlend(vec4 back, vec4 front) {#ifdef _GL_ARB_VERSION_MAJOR_MINOR >= 4\n    return vec4(back.a * front.a + back.b * front.b + back.g * front.g + back.r * front.r,\n                back.a * front.b + back.b * front.a + back.g * front.r + back.r * front.g,\n                back.a * front.g + back.g * front.a + back.r * front.b + back.b * front.r,\n                back.a * front.r + back.r * front.a + back.g * front.b + back.b * front.g);\n#else\n    return vec4(back.a", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MIN", "#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    x = x*r;\n    y = y*r;\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(1.0f/3.0f);\n    x = x*(1.0f/3.0f);\n    y = y*(", "#include \"tonemapping.h\"\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    vec3 h = vec3(0.0, 0.0, 0.0);\n    vec3 i = vec3(0.0, 0.0, 0.0);\n    vec3 j = vec3(0.0, 0.0, 0.0);\n    vec3 k = vec3(0.0, 0.0, 0.0);\n    vec3 l = vec3(0.0, 0.0, 0.0);\n    vec3 m = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0", "#include <iostream>\n    return {p.x, p.y};\n}\n\nint main() {\n    std::vector<vec2> v1 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v2 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v3 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v4 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v5 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v6 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v7 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v8 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v9 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v10 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v11 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v12 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v13 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v14 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v15 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v16 = { {1,2}, {3,4}, {5,6} };\n    std::vector<vec2> v17 = { {1,2}, {3,", "#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include \"blackbody.h\"\n    vec3 result = blackbody(Temp);\n    result.x = result.x * 0.5;\n    return result;\n}\n\nvec3 blackbody(float Temp) {#include", "#include <random>\n    static const float sigma = 0.1f;\n    static const float x = 0.5f;\n    static const float y = 0.5f;\n    static const float x2 = x * x;\n    static const float y2 = y * y;\n    static const float x3 = x2 * x;\n    static const float y3 = y2 * y;\n    static const float x4 = x3 * x;\n    static const float y4 = y3 * y;\n    static const float x5 = x4 * x;\n    static const float y5 = y4 * y;\n    static const float x6 = x5 * x;\n    static const float y6 = y5 * y;\n    static const float x7 = x6 * x;\n    static const float y7 = y6 * y;\n    static const float x8 = x7 * x;\n    static const float y8 = y7 * y;\n    static const float x9 = x8 * x;\n    static const float y9 = y8 * y;\n    static const float x10 = x9 * x;\n    static const float y10 = y9 * y;\n    static const float x11 = x10 * x;\n    static const float y11 = y10 * y;\n    static const float x12 = x11 * x;\n    static const float y12 = y11 * y;\n    static const float x13 = x12 * x;\n    static const float y13 = y12 * y;\n    static const float x14 = x13 * x;\n    static const float y14 = y13 * y;\n    static const float x15 = x14 * x;\n    static const float y15 = y14 * y;\n    static const float x16 = x15 * x;\n    static const float y16 = y15 * y;\n    static const float x17 = x16 * x;\n    static const float y17 = y16 * y;\n    static const float x18 = x17 * x;\n    static const float y18 = y17 * y;\n    static const float x19 = x18 * x;\n    static const float y19 = y18 * y;\n    static const", "#include <math.h>\n    vec3 r = ro - rd;\n    vec3 n = normalize(r);\n    vec3 u = normalize(sph.xyz - ro);\n    vec3 v = normalize(sph.xyz - rd);\n    vec3 w = cross(n, u);\n    vec3 x = cross(n, v);\n    vec3 y = cross(u, v);\n    vec3 z = cross(u, w);\n    vec3 t = dot(n, u);\n    vec3 s = dot(n, v);\n    vec3 t0 = t * t;\n    vec3 s0 = s * s;\n    vec3 t1 = t0 + s0;\n    vec3 t2 = t1 + s0;\n    vec3 t3 = t2 + s0;\n    vec3 t4 = t3 + s0;\n    vec3 t5 = t4 + s0;\n    vec3 t6 = t5 + s0;\n    vec3 t7 = t6 + s0;\n    vec3 t8 = t7 + s0;\n    vec3 t9 = t8 + s0;\n    vec3 t10 = t9 + s0;\n    vec3 t11 = t10 + s0;\n    vec3 t12 = t11 + s0;\n    vec3 t13 = t12 + s0;\n    vec3 t14 = t13 + s0;\n    vec3 t15 = t14 + s0;\n    vec3 t16 = t15 + s0;\n    vec3 t17 = t16 + s0;\n    vec3 t18 = t17 + s0;\n    vec3 t19 = t18 + s0;\n    vec3 t20 = t19 + s0;\n    vec3 t21 = t20 + s0;\n    vec3 t22 = t21 + s0;\n    vec3 t23 = t22 + s0;\n    vec3 t24 = t23 + s0;\n    vec3 t25 = t24 + s0;\n    vec3 t26 = t25 + s0;\n    vec3 t27 = t26 + s0;\n    vec", "#include <math.h>\n    vec3 r = (vec2)n;\n    vec3 d = (vec2)p;\n    vec3 s = (vec2)n.xy;\n    vec3 s2 = (vec2)s.xy;\n    vec3 s3 = (vec2)s.xy;\n    vec3 s4 = (vec2)s.xy;\n    vec3 s5 = (vec2)s.xy;\n    vec3 s6 = (vec2)s.xy;\n    vec3 s7 = (vec2)s.xy;\n    vec3 s8 = (vec2)s.xy;\n    vec3 s9 = (vec2)s.xy;\n    vec3 s10 = (vec2)s.xy;\n    vec3 s11 = (vec2)s.xy;\n    vec3 s12 = (vec2)s.xy;\n    vec3 s13 = (vec2)s.xy;\n    vec3 s14 = (vec2)s.xy;\n    vec3 s15 = (vec2)s.xy;\n    vec3 s16 = (vec2)s.xy;\n    vec3 s17 = (vec2)s.xy;\n    vec3 s18 = (vec2)s.xy;\n    vec3 s19 = (vec2)s.xy;\n    vec3 s20 = (vec2)s.xy;\n    vec3 s21 = (vec2)s.xy;\n    vec3 s22 = (vec2)s.xy;\n    vec3 s23 = (vec2)s.xy;\n    vec3 s24 = (vec2)s.xy;\n    vec3 s25 = (vec2)s.xy;\n    vec3 s26 = (vec2)s.xy;\n    vec3 s27 = (vec2)s.xy;\n    vec3 s28 = (vec2)s.xy;\n    vec3 s29 = (vec2)s.xy;\n    vec3 s30 = (vec2)s.xy;\n    vec3 s31 = (vec2)s.xy;\n    vec3 s32 = (vec2)s.xy;\n    ", "\n    if( t < 0 )\n        return 0;\n    if( t == 0 )\n        return x;\n    return cantor( x, t/2 ) + cantor( x, (t+1)/2 );\n}\n\nA:\n\nI think you are looking for the following:\n#include <stdio.h>\n\nint main(void)\n{\n    int n, i, j;\n    float x, y;\n\n    printf(\"Enter the number of iterations: \");\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < i; j++)\n        {\n            x = (float)j / (float)i;\n            y = (float)i / (float)j;\n            printf(\"%f %f\\n\", x, y);\n        }\n    }\n\n    return 0;\n}\n\nA:\n\nI think you are looking for this:\n#include <stdio.h>\n\nint main(void)\n{\n    int n, i, j;\n    float x, y;\n\n    printf(\"Enter the number of iterations: \");\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < i; j++)\n        {\n            x = (float)j / (float)i;\n            y = (float)i / (float)j;\n            printf(\"%f %f\\n\", x, y);\n        }\n    }\n\n    return 0;\n}\n\nA:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int n, i, j;\n    float x, y;\n\n    printf(\"Enter the number of iterations: \");\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < i; j++)\n        {\n            x = (float)j / (float)i;\n            y = (float)i / (float)j;\n            printf(\"%f %f\\n\", x", "#include <math.h>\n    float x,y;\n    x = p.x - a.x;\n    y = p.y - a.y;\n    x = x*x;\n    y = y*y;\n    x = x + b.x*b.x;\n    y = y + b.y*b.y;\n    return sqrt(x + y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{#include <math.h>\n    float x,y;\n    x = p.x - a.x;\n    y = p.y - a.y;\n    x = x*x;\n    y = y*y;\n    x = x + b.x*b.x;\n    y = y + b.y*b.y;\n    return sqrt(x + y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{#include <math.h>\n    float x,y;\n    x = p.x - a.x;\n    y = p.y - a.y;\n    x = x*x;\n    y = y*y;\n    x = x + b.x*b.x;\n    y = y + b.y*b.y;\n    return sqrt(x + y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{#include <math.h>\n    float x,y;\n    x = p.x - a.x;\n    y = p.y - a.y;\n    x = x*x;\n    y = y*y;\n    x = x + b.x*b.x;\n    y = y + b.y*b.y;\n    return sqrt(x + y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{#include <math.h>\n    float x,y;\n    x = p.x - a.x;\n    y = p.y - a.y;\n    x = x*", "\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float x0 = 0.0;\n    float y0 = 0.0;\n    float z0 = 0.0;\n    float x1 = 1.0;\n    float y1 = 1.0;\n    float z1 = 1.0;\n    float x2 = 0.5;\n    float y2 = 0.5;\n    float z2 = 0.5;\n    float x3 = 0.5;\n    float y3 = 0.5;\n    float z3 = 0.5;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float z4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float z5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float z6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float z7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float z8 = 0.0;\n    float x9 = 0.0;\n    float y9 = 0.0;\n    float z9 = 0.0;\n    float x10 = 0.0;\n    float y10 = 0.0;\n    float z10 = 0.0;\n    float x11 = 0.0;\n    float y11 = 0.0;\n    float z11 = 0.0;\n    float x12 = 0.0;\n    float y12 = 0.0;\n    float z12 = 0.0;\n    float x13 = 0.0;\n    float y13 = 0.0;\n    float z13 = 0.0;\n    float x14 = 0.0;\n    float y14 = 0.0;\n    float z14 = 0.0;\n    float x15 = 0.0;\n    float y15 = 0.0;\n    float z15 = 0.0;\n    float x16", "#include <math.h>\n    return atan2(y, x);\n}\n\nfloat atan_approx_2(float y, float x) {#include <math.h>\n    return atan2(y, x) + M_PI;\n}\n\nfloat atan_approx_3(float y, float x) {#include <math.h>\n    return atan2(y, x) + 2 * M_PI;\n}\n\nfloat atan_approx_4(float y, float x) {#include <math.h>\n    return atan2(y, x) + 3 * M_PI;\n}\n\nfloat atan_approx_5(float y, float x) {#include <math.h>\n    return atan2(y, x) + 4 * M_PI;\n}\n\nfloat atan_approx_6(float y, float x) {#include <math.h>\n    return atan2(y, x) + 5 * M_PI;\n}\n\nfloat atan_approx_7(float y, float x) {#include <math.h>\n    return atan2(y, x) + 6 * M_PI;\n}\n\nfloat atan_approx_8(float y, float x) {#include <math.h>\n    return atan2(y, x) + 7 * M_PI;\n}\n\nfloat atan_approx_9(float y, float x) {#include <math.h>\n    return atan2(y, x) + 8 * M_PI;\n}\n\nfloat atan_approx_10(float y, float x) {#include <math.h>\n    return atan2(y, x) + 9 * M_PI;\n}\n\nfloat atan_approx_11(float y, float x) {#include <math.h>\n    return atan2(y, x) + 10 * M_PI;\n}\n\nfloat atan_approx_12(float y, float x) {#include <math.h>\n    return atan2(y, x) + 11 * M_PI;\n", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul2(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.x * w.y - z.y * w.x);\n}\n\nvec2 cmul3(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y + z.z * w.z, z.x * w.y - z.y * w.x + z.z * w.z);\n}\n\nvec2 cmul4(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y - z.z * w.z, z.x * w.y + z.y * w.x + z.z * w.z);\n}\n\nvec2 cmul5(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y + z.z * w.z, z.x * w.y - z.y * w.x - z.z * w.z);\n}\n\nvec2 cmul6(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y - z.z * w.z, z.x * w.y + z.y * w.x + z.z * w.z);\n}\n\nvec2 cmul7(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y - z.z * w.z, z.x * w.y - z.y * w.x + z.z * w.z);\n}\n\nvec2 cmul8(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y + z.z * w.z, z.x", "\n    vec2 x = z.x / (1.0 + z.y * z.y);\n    vec2 y = z.y / (1.0 + z.x * z.x);\n    return vec2(x, y);\n}\n\n// Inverse hyperbolic cosine \nvec2 coth(vec2 z) {\n    vec2 x = 1.0 / (1.0 + z.x * z.x);\n    vec2 y = 1.0 / (1.0 + z.y * z.y);\n    return vec2(x, y);\n}\n\n// Inverse hyperbolic sine \nvec2 sinh(vec2 z) {\n    vec2 x = (z.x + sqrt(z.x * z.x + z.y * z.y)) / 2.0;\n    vec2 y = (z.y + sqrt(z.x * z.x + z.y * z.y)) / 2.0;\n    return vec2(x, y);\n}\n\n// Inverse hyperbolic cosecant \nvec2 csc(vec2 z) {\n    vec2 x = 1.0 / (z.x + sqrt(z.x * z.x + z.y * z.y));\n    vec2 y = 1.0 / (z.y + sqrt(z.x * z.x + z.y * z.y));\n    return vec2(x, y);\n}\n\n// Inverse hyperbolic secant \nvec2 sec(vec2 z) {\n    vec2 x = 1.0 / (z.x + sqrt(z.x * z.x + z.y * z.y));\n    vec2 y = 1.0 / (z.y + sqrt(z.x * z.x + z.y * z.y));\n    return vec2(x, y);\n}\n\n// Inverse hyperbolic cotangent \nvec2 cot(vec2 z) {\n    vec2 x = 1.0 / (z.x + sqrt(z.x * z.x + z.y * z.y));\n    vec2 y = 1", "\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(z.y) + z.y * exp(-z.x);\n    return res;\n}\n\nvec2 cosh(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) + z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 cotanh(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 coth(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) + z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 csc(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = 1.0 / z.x;\n    res.y = 1.0 / z.y;\n    return res;\n}\n\nvec2 sec(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = 1.0 / z.x;\n    res.y = 1.0 / z.y;\n    return res;\n}\n\nvec2 cscx(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.x * w.y - z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.x * w.y - z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.x * w.y - z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.x * w.y - z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.", "\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 cexp_vec(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 cexp_vec_vec(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 cexp_vec_vec_vec(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 cexp_vec_vec_vec_vec(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x) - z.y * exp(-z.y);\n    res.y = z.x * exp(-z.x) + z.y * exp(z.y);\n    return res;\n}\n\nvec2 cexp_vec_vec_vec_vec_vec(vec2 z) {\n    vec2 res = vec2(0.0, 0.0);\n    res.x = z.x * exp(z.x", "\n    vec4 result = alpha;\n    result.a = alpha.a * contrast;\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;\n    result.a = random(0, 1);\n    return result;\n}\n\n// Returns a vector with the same color as the input, but with a random\n// value between 0 and 1\nvec4 randomVector(vec4 color) {\n    vec4 result = color;", "    \n    vec3 r = (1.0f/3.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (1.0f/2.0f) * (", "\n    vec3 u, v, w;\n    u = uvw.x;\n    v = uvw.y;\n    w = uvw.z;\n    if (u == 0.0 && v == 0.0 && w == 0.0) return 1;\n    if (u == 0.0 && v == 0.0) return 2;\n    if (u == 0.0 && w == 0.0) return 3;\n    if (v == 0.0 && w == 0.0) return 4;\n    if (u == 0.0) return 5;\n    if (v == 0.0) return 6;\n    if (w == 0.0) return 7;\n    return 0;\n}\n\n//Tetrahedron Tiling\ntilingVal3D tetTile(vec3 uvw) {\n    vec3 u, v, w;\n    u = uvw.x;\n    v = uvw.y;\n    w = uvw.z;\n    if (u == 0.0 && v == 0.0 && w == 0.0) return 1;\n    if (u == 0.0 && v == 0.0) return 2;\n    if (u == 0.0 && w == 0.0) return 3;\n    if (v == 0.0 && w == 0.0) return 4;\n    if (u == 0.0) return 5;\n    if (v == 0.0) return 6;\n    if (w == 0.0) return 7;\n    return 0;\n}\n\n//Triangle Tiling\ntilingVal3D triTile(vec3 uvw) {\n    vec3 u, v, w;\n    u = uvw.x;\n    v = uvw.y;\n    w = uvw.z;\n    if (u == 0.0 && v == 0.0 && w == 0.0) return 1;\n    if (u == 0.0 && v == 0.0) return 2;\n    if (u == 0.0 && w == 0.0) return 3;\n    if (v == 0.0 && w == 0.0) return 4;\n    if (u", "    \n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec3 rohmCell(vec3 uvw, vec3 offset, float gridRes) {    \n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec3 rohmCell(vec3 uvw, vec3 offset, float gridRes) {    \n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec3 rohmCell(vec3 uvw, vec3 offset, float gridRes) {    \n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec3 rohmCell(vec3 uvw, vec3 offset, float gridRes) {    \n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec3 rohmCell(vec3 uvw, vec3 offset, float gridRes) {    \n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    return uvwScaledOffset;\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\nvec3 rohmCell(vec3 uvw, vec3 offset, float", "#include \"quadgrid.h\"\n    vec3 u, v, w;\n    u = uvw.xyz;\n    v = uvw.xyz + vec3(0.5, 0.5, 0.5);\n    w = uvw.xyz + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);\n    v = v + vec3(0.5, 0.5, 0.5);\n    w = w + vec3(0.5, -0.5, 0.5);", "    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = p - c;\n    return sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = p - c;\n    return sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = p - c;\n    return sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = p - c;\n    return sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = p - c;\n    return sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = p - c;\n    return sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec", "    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if (t < 0.0) {\n        c = vec3(0.0, 0.0, 1.0);\n    } else if (t < 0.33) {\n        c = vec3(0.0, 1.0, 0.0);\n    } else if (t < 0.66) {\n        c = vec3(1.0, 0.0, 0.0);\n    } else if (t < 0.99) {\n        c = vec3(0.0, 0.0, 1.0);\n    } else if (t < 1.0) {\n        c = vec3(0.0, 1.0, 1.0);\n    } else {\n        c = vec3(1.0, 0.0, 1.0);\n    }\n    return c;\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if (t < 0.0) {\n        c = vec3(0.0, 0.0, 1.0);\n    } else if (t < 0.33) {\n        c = vec3(0.0, 1.0, 0.0);\n    } else if (t < 0.66) {\n        c = vec3(1.0, 0.0, 0.0);\n    } else if (t < 0.99) {\n        c = vec3(0.0, 0.0, 1.0);\n    } else if (t < 1.0) {\n        c = vec3(0.0, 1.0, 1.0);\n    } else {\n        c = vec3(1.0, 0.0, 1.0);\n    }\n    return c;\n}\n\n// makes Linear colormap with polynomial 6\nvec3 Linear(float t) {    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if (t < 0.0) {\n        c = vec3(", "\n    vec3 r = vec3(0, 0, 0);\n    r.x = v.x * cos(a.x) - v.y * sin(a.x) + a.z * sin(a.x) * cos(a.y);\n    r.y = v.x * sin(a.x) + v.y * cos(a.x) + a.z * sin(a.x) * cos(a.y);\n    r.z = v.x * cos(a.x) * cos(a.y) - v.y * sin(a.x) * sin(a.y) + a.z * sin(a.x);\n    return r;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    vec3 r = vec3(0, 0, 0);\n    r.x = v.x * cos(a.x) - v.y * sin(a.x) + a.z * sin(a.x) * cos(a.y);\n    r.y = v.x * sin(a.x) + v.y * cos(a.x) + a.z * sin(a.x) * cos(a.y);\n    r.z = v.x * cos(a.x) * cos(a.y) - v.y * sin(a.x) * sin(a.y) + a.z * sin(a.x);\n    return r;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    vec3 r = vec3(0, 0, 0);\n    r.x = v.x * cos(a.x) - v.y * sin(a.x) + a.z * sin(a.x) * cos(a.y);\n    r.y = v.x * sin(a.x) + v.y * cos(a.x) +", "#include <cmath>\n    return (co.x * co.x + co.y * co.y) * (1.0f / (float)sizeof(vec2));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 co) {#include <cmath>\n    return (co.x * co.x + co.y * co.y + co.z * co.z) * (1.0f / (float)sizeof(vec3));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 co) {#include <cmath>\n    return (co.x * co.x + co.y * co.y + co.z * co.z + co.w * co.w) * (1.0f / (float)sizeof(vec4));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec5 co) {#include <cmath>\n    return (co.x * co.x + co.y * co.y + co.z * co.z + co.w * co.w + co.x * co.x) * (1.0f / (float)sizeof(vec5));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec6 co) {#include <cmath>\n    return (co.x * co.x + co.y * co.y + co.z * co.z + co.w * co.w + co.x * co.x + co.y * co.y) * (1.0f / (float)sizeof(vec6));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec7 co) {#include <cmath>\n    return (co.x * co.x + co.y * co.y + co.z * co.z + co.w * co.w + co.x * co.x + co.y * co.y + co.z * co.z) * (1.0f / (float)sizeof(vec7));\n}\n\n//", "\n    float x = p.x;\n    float y = p.y;\n    float dx = x - 0.5f;\n    float dy = y - 0.5f;\n    float d = sqrt(dx*dx + dy*dy);\n    float d2 = d*d;\n    float d3 = d2*d;\n    float d4 = d3*d;\n    float d5 = d4*d;\n    float d6 = d5*d;\n    float d7 = d6*d;\n    float d8 = d7*d;\n    float d9 = d8*d;\n    float d10 = d9*d;\n    float d11 = d10*d;\n    float d12 = d11*d;\n    float d13 = d12*d;\n    float d14 = d13*d;\n    float d15 = d14*d;\n    float d16 = d15*d;\n    float d17 = d16*d;\n    float d18 = d17*d;\n    float d19 = d18*d;\n    float d20 = d19*d;\n    float d21 = d20*d;\n    float d22 = d21*d;\n    float d23 = d22*d;\n    float d24 = d23*d;\n    float d25 = d24*d;\n    float d26 = d25*d;\n    float d27 = d26*d;\n    float d28 = d27*d;\n    float d29 = d28*d;\n    float d30 = d29*d;\n    float d31 = d30*d;\n    float d32 = d31*d;\n    float d33 = d32*d;\n    float d34 = d33*d;\n    float d35 = d34*d;\n    float d36 = d35*d;\n    float d37 = d36*d;\n    float d38 = d37*d;\n    float d39 = d38*d;\n    float d40 = d39*d;\n    float d41 = d40*d;\n    float d42 = d41*d;\n    float d", "\n    vec2 uv2 = uv * 2.0;\n    vec2 uv3 = uv2 + vec2(1.0, 0.0);\n    vec2 uv4 = uv2 + vec2(0.5, sqrt(3.0) / 2.0);\n    vec2 uv5 = uv2 + vec2(0.5, -sqrt(3.0) / 2.0);\n    vec2 uv6 = uv2 + vec2(-1.0, 0.0);\n    vec2 uv7 = uv2 + vec2(-0.5, sqrt(3.0) / 2.0);\n    vec2 uv8 = uv2 + vec2(-0.5, -sqrt(3.0) / 2.0);\n    vec2 uv9 = uv2 + vec2(1.0, 0.0);\n    vec2 uv10 = uv2 + vec2(0.0, sqrt(3.0) / 2.0);\n    vec2 uv11 = uv2 + vec2(0.0, -sqrt(3.0) / 2.0);\n    vec2 uv12 = uv2 + vec2(0.5, sqrt(3.0) / 2.0);\n    vec2 uv13 = uv2 + vec2(0.5, -sqrt(3.0) / 2.0);\n    vec2 uv14 = uv2 + vec2(-0.5, sqrt(3.0) / 2.0);\n    vec2 uv15 = uv2 + vec2(-0.5, -sqrt(3.0) / 2.0);\n    vec2 uv16 = uv2 + vec2(-1.0, 0.0);\n    vec2 uv17 = uv2 + vec2(0.0, -sqrt(3.0) / 2.0);\n    vec2 uv18 = uv2 + vec2(0.0, sqrt(3.0) / 2.0);\n    vec2 uv19 = uv2 + vec2(0.5, sqrt(3.0) /", "\n    float r = 1.0 - t;\n    float g = 1.0 - (t * t);\n    float b = (t * t * t);\n    return vec3(r, g, b);\n}\n\n// make colormap with polynomial 4 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis2(float t) {\n    float r = 1.0 - t;\n    float g = 1.0 - (t * t);\n    float b = (t * t * t);\n    return vec3(r, g, b);\n}\n\n// make colormap with polynomial 3 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis3(float t) {\n    float r = 1.0 - t;\n    float g = 1.0 - (t * t);\n    float b = (t * t * t);\n    return vec3(r, g, b);\n}\n\n// make colormap with polynomial 2 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis4(float t) {\n    float r = 1.0 - t;\n    float g = 1.0 - (t * t);\n    float b = (t * t * t);\n    return vec3(r, g, b);\n}\n\n// make colormap with polynomial 1 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis5(float t) {\n    float r = 1.0 - t;\n    float g = 1.0 - (t * t);\n    float b = (t * t * t);\n    return vec3(r, g, b);\n}\n\n// make colormap with polynomial 0 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis6(float t) {\n    float r = 1.0 - t;\n    float g = 1.0 - (t * t);\n    float b = (t * t * t);\n    return vec3(r, g,", "\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from -1-1 to 1-1\nfloat make1to1(float x) {\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to0(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from -1-1 to -1-1\nfloat make1to1(float x) {\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to 1-1\nfloat make0to1(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from -1-1 to 1-1\nfloat make1to0(float x) {\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to0(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from -1-1 to 1-1\nfloat make1to1(float x) {\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to0(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from -1-1 to 1-1\nfloat make1to1(float x) {\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to0(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from -1-1 to 1-1\nfloat make1to1(float x) {\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make", "\n    float x = uv.x + offset.x;\n    float y = uv.y + offset.y;\n    float xOffset = x - floor(x);\n    float yOffset = y - floor(y);\n    float xDot = xOffset * xOffset;\n    float yDot = yOffset * yOffset;\n    float xDotY = xOffset * yOffset;\n    float xDotX = xOffset * xOffset;\n    float yDotY = yOffset * yOffset;\n    float xDotXY = xOffset * yOffset;\n    float xDotXY = xOffset * xOffset;\n    float yDotXY = yOffset * xOffset;\n    float xDotXYY = xOffset * yOffset;\n    float xDotXYX = xOffset * xOffset;\n    float yDotXYX = yOffset * xOffset;\n    float xDotXYYY = xOffset * yOffset;\n    float xDotXYYYX = xOffset * yOffset;\n    float yDotXYYYX = yOffset * xOffset;\n    float xDotXYYYYY = xOffset * yOffset;\n    float xDotXYYYYYX = xOffset * yOffset;\n    float yDotXYYYYYX = yOffset * xOffset;\n    float xDotXYYYYYYY = xOffset * yOffset;\n    float yDotXYYYYYYYX = yOffset * xOffset;\n    float xDotXYYYYYYYY = xOffset * yOffset;\n    float yDotXYYYYYYYYX = yOffset * xOffset;\n    float xDotXYYYYYYYYYX = xOffset * yOffset;\n    float yDotXYYYYYYYYYX = yOffset * xOffset;\n    float xDotXYYYYYYYYYYYX = xOffset * yOffset;\n    float yDotXYYYYYYYYYYYX = yOffset * xOffset;\n    float xDotXYYYYYYYYYYYYYX = xOffset * yOffset;\n    float yDotXYYYYYYYYYYYYYX = yOffset * xOffset;\n    float xDotXYYYYYYYYYYYYYYYX", "\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float x1 = x + len * sin(time * 2 * pi);\n    float y1 = y + len * cos(time * 2 * pi);\n    float x2 = x + len * sin(time * 2 * pi + pi / 2);\n    float y2 = y + len * cos(time * 2 * pi + pi / 2);\n    float x3 = x + len * sin(time * 2 * pi + 3 * pi / 2);\n    float y3 = y + len * cos(time * 2 * pi + 3 * pi / 2);\n    float x4 = x + len * sin(time * 2 * pi + 5 * pi / 2);\n    float y4 = y + len * cos(time * 2 * pi + 5 * pi / 2);\n    float x5 = x + len * sin(time * 2 * pi + 7 * pi / 2);\n    float y5 = y + len * cos(time * 2 * pi + 7 * pi / 2);\n    float x6 = x + len * sin(time * 2 * pi + 9 * pi / 2);\n    float y6 = y + len * cos(time * 2 * pi + 9 * pi / 2);\n    float x7 = x + len * sin(time * 2 * pi + 11 * pi / 2);\n    float y7 = y + len * cos(time * 2 * pi + 11 * pi / 2);\n    float x8 = x + len * sin(time * 2 * pi + 13 * pi / 2);\n    float y8 = y + len * cos(time * 2 * pi + 13 * pi / 2);\n    float x9 = x + len * sin(time * 2 * pi + 15 * pi / 2);\n    float y9 = y + len * cos(time * 2 * pi + 15 * pi / 2);\n    float x10 = x + len * sin(time * 2 * pi + 17 * pi / 2);\n    float y10 = y + len * cos(time * 2 * pi + 17 * pi / 2);\n    float x11 = x + len * sin(time * 2 * pi + 19 * pi /", "    \n    vec2 flow = vec2(0, 0);\n    vec2 center = vec2(radius, 0);\n    vec2 direction = vec2(0, -1);\n    vec2 speed = vec2(radius, 0);\n    vec2 time_step = vec2(0, 0);\n    vec2 time_step_vec = vec2(0, 0);\n    vec2 time_step_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0, 0);\n    vec2 time_step_", "    \n    vec2 tileCenter = pos + vec2(tileSize / 2, tileSize / 2);\n    return tileCenter;\n}\n\n// Computes the tile containing pixel pos\nvec2 tileCoord(vec2 pos) {\n    vec2 tileCoord = pos / tileSize;\n    return tileCoord;\n}\n\n// Computes the tile containing the arrow\nvec2 arrowTileCoord(vec2 pos) {\n    vec2 arrowTileCoord = tileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n    return arrowTileCoord;\n}\n\n// Computes the tile containing the arrow tip\nvec2 arrowTipCoord(vec2 pos) {\n    vec2 arrowTipCoord = arrowTileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n    return arrowTipCoord;\n}\n\n// Computes the tile containing the arrow tip\nvec2 arrowTipCoord(vec2 pos) {\n    vec2 arrowTipCoord = arrowTileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n    return arrowTipCoord;\n}\n\n// Computes the tile containing the arrow tip\nvec2 arrowTipCoord(vec2 pos) {\n    vec2 arrowTipCoord = arrowTileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n    return arrowTipCoord;\n}\n\n// Computes the tile containing the arrow tip\nvec2 arrowTipCoord(vec2 pos) {\n    vec2 arrowTipCoord = arrowTileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n    return arrowTipCoord;\n}\n\n// Computes the tile containing the arrow tip\nvec2 arrowTipCoord(vec2 pos) {\n    vec2 arrowTipCoord = arrowTileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n    return arrowTipCoord;\n}\n\n// Computes the tile containing the arrow tip\nvec2 arrowTipCoord(vec2 pos) {\n    vec2 arrowTipCoord = arrowTileCoord(pos) + vec2(tileSize / 2, tileSize / 2);\n", "\n    float u = (p1.x - p.x) * (p2.y - p.y) - (p2.x - p.x) * (p1.y - p.y);\n    if (u < 0) {\n        return -(p1.x - p.x) * (p.y - p1.y) + (p.x - p1.x) * (p1.y - p.y);\n    }\n    if (u > 0) {\n        return -(p2.x - p.x) * (p.y - p2.y) + (p.x - p2.x) * (p2.y - p.y);\n    }\n    return 0;\n}\n\n// Computes the signed distance from a point to a line segment\nfloat point(vec2 p, vec2 p1, vec2 p2) {\n    float u = (p1.x - p.x) * (p2.y - p.y) - (p2.x - p.x) * (p1.y - p.y);\n    if (u < 0) {\n        return -(p1.x - p.x) * (p.y - p1.y) + (p.x - p1.x) * (p1.y - p.y);\n    }\n    if (u > 0) {\n        return -(p2.x - p.x) * (p.y - p2.y) + (p.x - p2.x) * (p2.y - p.y);\n    }\n    return 0;\n}\n\n// Computes the distance from a point to a line segment\nfloat distance(vec2 p, vec2 p1, vec2 p2) {\n    float u = (p1.x - p.x) * (p2.y - p.y) - (p2.x - p.x) * (p1.y - p.y);\n    if (u < 0) {\n        return point(p, p1, p2) + line(p, p1, p2);\n    }\n    if (u > 0) {\n        return point(p", "\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - v).length() / v.length();\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec", "\n    return x - 1.0;\n}\n\n//shifts value range from 0-1 to 1-1\nvec2 make1to1(vec2 x) {\n    return x + 1.0;\n}\n\n//shifts value range from 1-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x - 2.0;\n}\n\n//shifts value range from -1-1 to 1-1\nvec2 make0to1(vec2 x) {\n    return x + 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return x + 1.0;\n}\n\n//shifts value range from 0-1 to 1-1\nvec2 make1to1(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from 1-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x + 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from 0-1 to 1-1\nvec2 make1to1(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from 1-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from 0-1 to 1-1\nvec2 make1to1(vec2 x) {\n    return x - 1.0;\n}\n\n//shifts value range from 1-1 to -1-1\nvec2 make1to0(vec", "    \n    vec2 center = point - offset;\n    vec2 radius = spread;\n    vec2 x = center.x - radius;\n    vec2 y = center.y - radius;\n    vec2 z = center.z - radius;\n    vec2 r = sqrt(x*x + y*y + z*z);\n    vec2 r2 = r*r;\n    vec2 r3 = r2*r2;\n    vec2 r4 = r3*r2;\n    vec2 r5 = r4*r2;\n    vec2 r6 = r5*r2;\n    vec2 r7 = r6*r2;\n    vec2 r8 = r7*r2;\n    vec2 r9 = r8*r2;\n    vec2 r10 = r9*r2;\n    vec2 r11 = r10*r2;\n    vec2 r12 = r11*r2;\n    vec2 r13 = r12*r2;\n    vec2 r14 = r13*r2;\n    vec2 r15 = r14*r2;\n    vec2 r16 = r15*r2;\n    vec2 r17 = r16*r2;\n    vec2 r18 = r17*r2;\n    vec2 r19 = r18*r2;\n    vec2 r20 = r19*r2;\n    vec2 r21 = r20*r2;\n    vec2 r22 = r21*r2;\n    vec2 r23 = r22*r2;\n    vec2 r24 = r23*r2;\n    vec2 r25 = r24*r2;\n    vec2 r26 = r25*r2;\n    vec2 r27 = r26*r2;\n    vec2 r28 = r27*r2;\n    vec2 r29 = r28*r2;\n    vec2 r30 = r29*r2;\n    vec2 r31 = r30*r2;\n    vec2 r32 = r31*r2;\n    vec2 r33 = r32*r2;\n    vec2 r34 = r33*r2;\n    vec2 r35 = r34", "\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float s = sqrt(x*x + y*y);\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float s = sqrt(x*x + y*y);\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float s = sqrt(x*x + y*y);\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float s = sqrt(x*x + y*y);\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float s = sqrt(x*x + y*y);\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float s = sqrt(x*x + y*y);\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    float x = p.x", "    \n    float x = p.x - id.x;\n    float y = p.y - id.y;\n    float z = p.z - id.z;\n    float s = sqrt(x*x + y*y + z*z);\n    float t = s*sp;\n    float r = t*t;\n    float s1 = s*s;\n    float s2 = s1*s1;\n    float s3 = s2*s2;\n    float s4 = s3*s3;\n    float s5 = s4*s4;\n    float s6 = s5*s5;\n    float s7 = s6*s6;\n    float s8 = s7*s7;\n    float s9 = s8*s8;\n    float s10 = s9*s9;\n    float s11 = s10*s10;\n    float s12 = s11*s11;\n    float s13 = s12*s12;\n    float s14 = s13*s13;\n    float s15 = s14*s14;\n    float s16 = s15*s15;\n    float s17 = s16*s16;\n    float s18 = s17*s17;\n    float s19 = s18*s18;\n    float s20 = s19*s19;\n    float s21 = s20*s20;\n    float s22 = s21*s21;\n    float s23 = s22*s22;\n    float s24 = s23*s23;\n    float s25 = s24*s24;\n    float s26 = s25*s25;\n    float s27 = s26*s26;\n    float s28 = s27*s27;\n    float s29 = s28*s28;\n    float s30 = s29*s29;\n    float s31 = s30*s30;\n    float s32 = s31*s31;\n    float s33 = s32*s32;\n    float s34 = s33*s33;\n    float s35 = s34*s34;\n    float s36 = s35*s35;\n    float s", "    \n    float r = (float)p.x*p.x + (float)p.y*p.y;\n    float s = (float)p.x*p.x + (float)p.y*p.y;\n    float t = (float)p.x*p.x + (float)p.y*p.y;\n    float u = (float)p.x*p.x + (float)p.y*p.y;\n    float v = (float)p.x*p.x + (float)p.y*p.y;\n    float w = (float)p.x*p.x + (float)p.y*p.y;\n    float x = (float)p.x*p.x + (float)p.y*p.y;\n    float y = (float)p.x*p.x + (float)p.y*p.y;\n    float z = (float)p.x*p.x + (float)p.y*p.y;\n    float a = (float)p.x*p.x + (float)p.y*p.y;\n    float b = (float)p.x*p.x + (float)p.y*p.y;\n    float c = (float)p.x*p.x + (float)p.y*p.y;\n    float d = (float)p.x*p.x + (float)p.y*p.y;\n    float e = (float)p.x*p.x + (float)p.y*p.y;\n    float f = (float)p.x*p.x + (float)p.y*p.y;\n    float g = (float)p.x*p.x + (float)p.y*p.y;\n    float h = (float)p.x*p.x + (float)p.y*p.y;\n    float i = (float)p.x*p.x + (float)p.y*p.y;\n    float j = (float)p.x*p.x + (float)p.y*p.", "\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z + 1.0);\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(", "\n    vec3 uv = uvw.xyz;\n    vec3 w = uvw.wxyz;\n    vec3 u = uv.xyz;\n    vec3 v = uv.xyz;\n    vec3 w2 = w.xyz;\n    vec3 u2 = u.xyz;\n    vec3 v2 = v.xyz;\n    vec3 w3 = w2.xyz;\n    vec3 u3 = u2.xyz;\n    vec3 v3 = v2.xyz;\n    vec3 w4 = w3.xyz;\n    vec3 u4 = u3.xyz;\n    vec3 v4 = v3.xyz;\n    vec3 w5 = w4.xyz;\n    vec3 u5 = u4.xyz;\n    vec3 v5 = v4.xyz;\n    vec3 w6 = w5.xyz;\n    vec3 u6 = u5.xyz;\n    vec3 v6 = v5.xyz;\n    vec3 w7 = w6.xyz;\n    vec3 u7 = u6.xyz;\n    vec3 v7 = v6.xyz;\n    vec3 w8 = w7.xyz;\n    vec3 u8 = u7.xyz;\n    vec3 v8 = v7.xyz;\n    vec3 w9 = w8.xyz;\n    vec3 u9 = u8.xyz;\n    vec3 v9 = v8.xyz;\n    vec3 w10 = w9.xyz;\n    vec3 u10 = u9.xyz;\n    vec3 v10 = v9.xyz;\n    vec3 w11 = w10.xyz;\n    vec3 u11 = u10.xyz;\n    vec3 v11 = v10.xyz;\n    vec3 w12 = w11.xyz;\n    vec3 u12 = u11.xyz;\n    vec3 v12 = v11.xyz;\n    vec3 w13 = w12.xyz;\n    vec3 u13 = u12.xyz;\n    vec3 v13 = v", "    \n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\n// get the cell index of a point\nint getCellIndex(vec3 point, vec3 offset, float gridRes) {\n    vec3 uvw = point - offset;\n    int uvw_int = uvw / gridRes;\n    return uvw_int.x + uvw_int.y * gridRes.z;\n}\n\n// get the cell index of a point\nint getCellIndex(vec3 point, vec3 offset, float gridRes) {\n    vec3 uvw = point - offset;\n    int uvw_int = uvw / gridRes;\n    return uvw_int.x + uvw_int.y * gridRes.z;\n}\n\n// get the cell index of a point\nint getCellIndex(vec3 point, vec3 offset, float gridRes) {\n    vec3 uvw = point - offset;\n    int uvw_int = uvw / gridRes;\n    return uvw_int.x + uvw_int.y * gridRes.z;\n}\n\n// get the cell index of a point\nint getCellIndex(vec3 point, vec3 offset, float gridRes) {\n    vec3 uvw = point - offset;\n    int uvw_int = uvw / gridRes;\n    return uvw_int.x + uvw_int.y * gridRes.z;\n}\n\n// get the cell index of a point\nint getCellIndex(vec3 point, vec3 offset, float gridRes) {\n    vec3 uvw = point - offset;\n    int uvw_int = uvw / gridRes;\n    return uvw_int.x + uvw_int.y * gridRes.z;\n}\n\n// get the cell index of a point\nint getCellIndex(vec3 point, vec3 offset, float gridRes) {\n    vec3 uvw", "\n    vec3 r = vec3(1.0, 1.0, 1.0);\n    vec3 g = vec3(1.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 1.0);\n    vec3 c = vec3(0.0, 1.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b1 = vec3(0.0, 0.0, 0.0);\n    vec3 b2 = vec3(0.0, 0.0, 0.0);\n    vec3 b3 = vec3(0.0, 0.0, 0.0);\n    vec3 b4 = vec3(0.0, 0.0, 0.0);\n    vec3 b5 = vec3(0.0, 0.0, 0.0);\n    vec3 b6 = vec3(0.0, 0.0, 0.0);\n    vec3 b7 = vec3(0.0, 0.0, 0.0);\n    vec3 b8 = vec3(0.0, 0.0, 0.0);\n    vec3 b9 = vec3(0.0, 0.0, 0.0);\n    vec3 b10 = vec3(0.0, 0.0, 0.0);\n    vec3 b11 = vec3(0.0, 0.0, 0.0);\n    vec3 b12 = vec3(0.0, 0.0, 0.0);\n    vec3 b13 = vec3(0.0, 0.0, 0.0);\n    vec3 b14 = vec3(0.0, 0.0, 0.0);\n    vec3 b15 = vec3(0.0, 0.0, 0.0);\n    vec3 b16 = vec3(0.0,", "    \n    vec3 a = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(1.0f, 1.0f, 1.0f));\n    vec3 b = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(1.0f, -1.0f, 1.0f));\n    vec3 c = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(1.0f, 1.0f, -1.0f));\n    vec3 d = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(-1.0f, 1.0f, 1.0f));\n    vec3 e = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(-1.0f, -1.0f, 1.0f));\n    vec3 f = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(-1.0f, 1.0f, -1.0f));\n    vec3 g = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(1.0f, -1.0f, -1.0f));\n    vec3 h = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(1.0f, 1.0f, -1.0f));\n    vec3 i = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(1.0f, -1.0f, -1.0f));\n    vec3 j = (1.0f/3.0f) * (p - (1.0f/2.0f) * vec3(-1.0f, -1", "    \n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t3*t;\n    float t5 = t4*t;\n    float t6 = t5*t;\n    float t7 = t6*t;\n    float t8 = t7*t;\n    float t9 = t8*t;\n    float t10 = t9*t;\n    float t11 = t10*t;\n    float t12 = t11*t;\n    float t13 = t12*t;\n    float t14 = t13*t;\n    float t15 = t14*t;\n    float t16 = t15*t;\n    float t17 = t16*t;\n    float t18 = t17*t;\n    float t19 = t18*t;\n    float t20 = t19*t;\n    float t21 = t20*t;\n    float t22 = t21*t;\n    float t23 = t22*t;\n    float t24 = t23*t;\n    float t25 = t24*t;\n    float t26 = t25*t;\n    float t27 = t26*t;\n    float t28 = t27*t;\n    float t29 = t28*t;\n    float t30 = t29*t;\n    float t31 = t30*t;\n    float t32 = t31*t;\n    float t33 = t32*t;\n    float t34 = t33*t;\n    float t35 = t34*t;\n    float t36 = t35*t;\n    float t37 = t36*t;\n    float t38 = t37*t;\n    float t39 = t38*t;\n    float t40 = t39*t;\n    float t41 = t40*t;\n    float t42 = t41*t;\n    float t43 = t42*t;\n    float t44 = t43*t;\n    float t45 = t44*t;\n    float t46 = t45*t;\n    float t47 = t46*t;\n    float t48 =", "\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = u + v;\n    vec2 y = u + w;\n    vec2 z = v + w;\n    return vec3(x, y, z);\n}\n\n// simple square Tiling\nvec3 squareTiling(vec2 uv) {\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = u + v;\n    vec2 y = u + w;\n    vec2 z = v + w;\n    return vec3(x, y, z);\n}\n\n// simple square Tiling\nvec3 squareTiling(vec2 uv) {\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = u + v;\n    vec2 y = u + w;\n    vec2 z = v + w;\n    return vec3(x, y, z);\n}\n\n// simple square Tiling\nvec3 squareTiling(vec2 uv) {\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = u + v;\n    vec2 y = u + w;\n    vec2 z = v + w;\n    return vec3(x, y, z);\n}\n\n// simple square Tiling\nvec3 squareTiling(vec2 uv) {\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = u + v;\n    vec2 y = u + w;\n    vec2 z = v + w;\n    return vec3(x, y, z);\n}\n\n// simple square Tiling\nvec3 squareTiling(vec2 uv) {\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w", "    \n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = uv.yx;\n    vec2 y = uv.xy;\n    vec2 z = uv.yx;\n    vec2 a = uv.xy;\n    vec2 b = uv.yx;\n    vec2 c = uv.xy;\n    vec2 d = uv.yx;\n    vec2 e = uv.xy;\n    vec2 f = uv.yx;\n    vec2 g = uv.xy;\n    vec2 h = uv.yx;\n    vec2 i = uv.xy;\n    vec2 j = uv.yx;\n    vec2 k = uv.xy;\n    vec2 l = uv.yx;\n    vec2 m = uv.xy;\n    vec2 n = uv.yx;\n    vec2 o = uv.xy;\n    vec2 p = uv.yx;\n    vec2 q = uv.xy;\n    vec2 r = uv.yx;\n    vec2 s = uv.xy;\n    vec2 t = uv.yx;\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = uv.yx;\n    vec2 y = uv.xy;\n    vec2 z = uv.yx;\n    vec2 a = uv.xy;\n    vec2 b = uv.yx;\n    vec2 c = uv.xy;\n    vec2 d = uv.yx;\n    vec2 e = uv.xy;\n    vec2 f = uv.yx;\n    vec2 g = uv.xy;\n    vec2 h = uv.yx;\n    vec2 i = uv.xy;\n    vec2 j = uv.yx;\n    vec2 k = uv.xy;\n    vec2 l = uv.yx;\n    vec2 m = uv.xy;\n    vec2 n = uv.yx;\n    vec2 o", "\n    vec2 u = uv.xy - offset;\n    vec2 v = uv.xy + offset;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv = uv.xy;\n    vec2 uv", "\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0 / gridRes);\n}\n\n// nakes a pixelized pattern\nvec3 pixelize(vec2 uv, float gridRes) {\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0 / gridRes);\n}\n\n// nakes a pixelized pattern\nvec3 pixelize(vec2 uv, float gridRes) {\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0 / gridRes);\n}\n\n// nakes a pixelized pattern\nvec3 pixelize(vec2 uv, float gridRes) {\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0 / gridRes);\n}\n\n// nakes a pixelized pattern\nvec3 pixelize(vec2 uv, float gridRes) {\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0 / gridRes);\n}\n\n// nakes a pixelized pattern\nvec3 pixelize(vec2 uv, float gridRes) {\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 + vec2(0.5, 0.5);\n    return uv2 + (uv3 - uv2) * (1.0 / gridRes);\n}\n\n// nakes a pixelized pattern", "\n    float x = uv.x + offset.x;\n    float y = uv.y + offset.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float xy = x * y;\n    float xy2 = xy * xy;\n    float xy3 = xy * xy2;\n    float xy4 = xy * xy3;\n    float xy5 = xy * xy4;\n    float xy6 = xy * xy5;\n    float xy7 = xy * xy6;\n    float xy8 = xy * xy7;\n    float xy9 = xy * xy8;\n    float xy10 = xy * xy9;\n    float xy11 = xy * xy10;\n    float xy12 = xy * xy11;\n    float xy13 = xy * xy12;\n    float xy14 = xy * xy13;\n    float xy15 = xy * xy14;\n    float xy16 = xy * xy15;\n    float xy17 = xy * xy16;\n    float xy18 = xy * xy17;\n    float xy19 = xy * xy18;\n    float xy20 = xy * xy19;\n    float xy21 = xy * xy20;\n    float xy22 = xy * xy21;\n    float xy23 = xy * xy22;\n    float xy24 = xy * xy23;\n    float xy25 = xy * xy24;\n    float xy26 = xy * xy25;\n    float xy27 = xy * xy26;\n    float xy28 = xy * xy27;\n    float xy29 = xy * xy28;\n    float xy30 = xy * xy29;\n    float xy31 = xy * xy30;\n    float xy32 = xy * xy31;\n    float xy33 = xy * xy32;\n    float xy34 =", "\n    float x = uv.x;\n    float y = uv.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float xy = x * y;\n    float xy2 = xy * xy;\n    float xy3 = xy * xy2;\n    float xy4 = xy * xy3;\n    float xy5 = xy * xy4;\n    float xy6 = xy * xy5;\n    float xy7 = xy * xy6;\n    float xy8 = xy * xy7;\n    float xy9 = xy * xy8;\n    float xy10 = xy * xy9;\n    float xy11 = xy * xy10;\n    float xy12 = xy * xy11;\n    float xy13 = xy * xy12;\n    float xy14 = xy * xy13;\n    float xy15 = xy * xy14;\n    float xy16 = xy * xy15;\n    float xy17 = xy * xy16;\n    float xy18 = xy * xy17;\n    float xy19 = xy * xy18;\n    float xy20 = xy * xy19;\n    float xy21 = xy * xy20;\n    float xy22 = xy * xy21;\n    float xy23 = xy * xy22;\n    float xy24 = xy * xy23;\n    float xy25 = xy * xy24;\n    float xy26 = xy * xy25;\n    float xy27 = xy * xy26;\n    float xy28 = xy * xy27;\n    float xy29 = xy * xy28;\n    float xy30 = xy * xy29;\n    float xy31 = xy * xy30;\n    float xy32 = xy * xy31;\n    float xy33 = xy * xy32;\n    float xy34 = xy * xy33;\n", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MIN", "\n    float x, y;\n    x = p.x;\n    y = p.y;\n    float a = sqrt(3.0f) / 2.0f;\n    float b = sqrt(3.0f) / 2.0f;\n    float c = sqrt(3.0f) / 2.0f;\n    float d = sqrt(3.0f) / 2.0f;\n    float e = sqrt(3.0f) / 2.0f;\n    float f = sqrt(3.0f) / 2.0f;\n    float g = sqrt(3.0f) / 2.0f;\n    float h = sqrt(3.0f) / 2.0f;\n    float i = sqrt(3.0f) / 2.0f;\n    float j = sqrt(3.0f) / 2.0f;\n    float k = sqrt(3.0f) / 2.0f;\n    float l = sqrt(3.0f) / 2.0f;\n    float m = sqrt(3.0f) / 2.0f;\n    float n = sqrt(3.0f) / 2.0f;\n    float o = sqrt(3.0f) / 2.0f;\n    float p = sqrt(3.0f) / 2.0f;\n    float q = sqrt(3.0f) / 2.0f;\n    float r = sqrt(3.0f) / 2.0f;\n    float s = sqrt(3.0f) / 2.0f;\n    float t = sqrt(3.0f) / 2.0f;\n    float u = sqrt(3.0f) / 2.0f;\n    float v = sqrt(3.0f) / 2.0f;\n    float w = sqrt(3.0f) / 2.0f;\n    float x1 = x + r * cos(a);\n    float y1 = y + r * sin(a);\n    float x2 = x + r * cos(b);\n    float y2 = y + r *", "#include \"vec2.h\"\n    vec2 h = vec2(p.x / 16, p.y / 16);\n    return h;\n}\n\n// #include \"vec2.h\"\n// #include \"vec3.h\"\n// #include \"vec4.h\"\n// #include \"vec5.h\"\n// #include \"vec6.h\"\n// #include \"vec7.h\"\n// #include \"vec8.h\"\n// #include \"vec9.h\"\n// #include \"vec10.h\"\n// #include \"vec11.h\"\n// #include \"vec12.h\"\n// #include \"vec13.h\"\n// #include \"vec14.h\"\n// #include \"vec15.h\"\n// #include \"vec16.h\"\n// #include \"vec17.h\"\n// #include \"vec18.h\"\n// #include \"vec19.h\"\n// #include \"vec20.h\"\n// #include \"vec21.h\"\n// #include \"vec22.h\"\n// #include \"vec23.h\"\n// #include \"vec24.h\"\n// #include \"vec25.h\"\n// #include \"vec26.h\"\n// #include \"vec27.h\"\n// #include \"vec28.h\"\n// #include \"vec29.h\"\n// #include \"vec30.h\"\n// #include \"vec31.h\"\n// #include \"vec32.h\"\n// #include \"vec33.h\"\n// #include \"vec34.h\"\n// #include \"vec35.h\"\n// #include \"vec36.h\"\n// #include \"vec37.h\"\n// #include \"vec38.h\"\n// #include \"vec39.h\"\n// #include \"vec40.h\"\n// #include \"vec41.h\"\n// #include \"vec42.h\"\n// #include \"vec43.h\"\n// #include \"vec44.h\"\n// #include \"vec45.h\"\n// #include \"vec46.h\"\n// #include \"vec47.h\"\n// #include \"vec48.h\"\n// #include \"", "#include <cmath>\n    return sin(x) + cos(x) + x;\n}\n\nint main()\n{\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float x2 = 0.0;\n    float x3 = 0.0;\n    float x4 = 0.0;\n    float x5 = 0.0;\n    float x6 = 0.0;\n    float x7 = 0.0;\n    float x8 = 0.0;\n    float x9 = 0.0;\n    float x10 = 0.0;\n    float x11 = 0.0;\n    float x12 = 0.0;\n    float x13 = 0.0;\n    float x14 = 0.0;\n    float x15 = 0.0;\n    float x16 = 0.0;\n    float x17 = 0.0;\n    float x18 = 0.0;\n    float x19 = 0.0;\n    float x20 = 0.0;\n    float x21 = 0.0;\n    float x22 = 0.0;\n    float x23 = 0.0;\n    float x24 = 0.0;\n    float x25 = 0.", "\n    vec3 r = t.x * 0.4124564 + t.y * 0.3575761 + t.z * 0.1804375;\n    vec3 g = t.x * 0.2126729 + t.y * 0.7151522 + t.z * 0.0721750;\n    vec3 b = t.x * 0.0193339 + t.y * 0.1191920 + t.z * 0.9503041;\n    return vec3(r, g, b);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB2(vec3 t) {\n    vec3 r = t.x * 0.4124564 + t.y * 0.3575761 + t.z * 0.1804375;\n    vec3 g = t.x * 0.2126729 + t.y * 0.7151522 + t.z * 0.0721750;\n    vec3 b = t.x * 0.0193339 + t.y * 0.1191920 + t.z * 0.9503041;\n    return vec3(r, g, b);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB2(vec3 t) {\n    vec3 r = t.x * 0.4124564 + t.y * 0.3575761 + t.z * 0.1804375;\n    vec3 g = t.x * 0.2126729 + t.y * 0.7151522 + t.z * 0.0721750;\n    vec3 b = t.x * 0.0193339 + t.y * 0.1191920 + t.z * 0.9503041;\n    return vec3(r, g, b);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB2(vec", "\n    return p.x * p.x + p.y * p.y;\n}\n\nfloat df1(vec2 p) {\n    return 2.0f * p.x;\n}\n\nfloat df2(vec2 p) {\n    return 2.0f * p.y;\n}\n\nfloat df3(vec2 p) {\n    return 2.0f * p.x * p.y;\n}\n\nfloat df4(vec2 p) {\n    return 2.0f * p.x * p.x;\n}\n\nfloat df5(vec2 p) {\n    return 2.0f * p.y * p.y;\n}\n\nfloat df6(vec2 p) {\n    return 2.0f * p.x * p.y * p.y;\n}\n\nfloat df7(vec2 p) {\n    return 2.0f * p.x * p.x * p.x;\n}\n\nfloat df8(vec2 p) {\n    return 2.0f * p.y * p.y * p.y;\n}\n\nfloat df9(vec2 p) {\n    return 2.0f * p.x * p.x * p.x * p.x;\n}\n\nfloat df10(vec2 p) {\n    return 2.0f * p.y * p.y * p.y * p.y;\n}\n\nfloat df11(vec2 p) {\n    return 2.0f * p.x * p.x * p.x * p.x * p.x;\n}\n\nfloat df12(vec2 p) {\n    return 2.0f * p.y * p.y * p.y * p.y * p.y;\n}\n\nfloat df13(vec2 p) {\n    return 2.0f * p.x * p.x * p.x * p.x * p.x * p.x;\n}\n\nfloat df14(vec2 p) {\n    return 2.0f * p.y * p.y * p.y * p.y * p.y * p.y;\n}\n\nfloat df15(vec2 p", "    // Distance function\n    return sqrt(p.x*p.x + p.y*p.y);\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {    // Distance function\n    return sqrt(p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y);\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {    // Distance function\n    return sqrt(p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y);\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {    // Distance function\n    return sqrt(p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y);\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {    // Distance function\n    return sqrt(p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y) * (p.x + p.y) / (p.x*p.x + p.y*p.y);\n}\n\n// Multiscale truchet\nfloat df6(vec2", "\n    float a = p0.x - p.x;\n    float b = p0.y - p.y;\n    float c = p1.x - p.x;\n    float d = p1.y - p.y;\n    float e = p2.x - p.x;\n    float f = p2.y - p.y;\n    float g = a*e - b*d;\n    float h = c*e - d*a;\n    float k = c*f - d*b;\n    float l = a*f - b*e;\n    float m = a*d - b*c;\n    float n = a*b - c*d;\n    float p = (n*l - m*k) / (2*g);\n    float q = (m*e - n*d) / (2*g);\n    float r = (n*b - m*a) / (2*g);\n    float s = (a*f - b*e) / (2*g);\n    float t = (b*d - a*c) / (2*g);\n    float u = (a*c - b*f) / (2*g);\n    float v = (b*e - a*d) / (2*g);\n    float w = (a*d - b*c) / (2*g);\n    float x = (a*e - b*f) / (2*g);\n    float y = (b*f - a*e) / (2*g);\n    float z = (a*f - b*e) / (2*g);\n    float d = sqrt(pow(p,2) + pow(q,2) + pow(r,2) + pow(s,2) + pow(t,2) + pow(u,2) + pow(v,2) + pow(w,2) + pow(x,2) + pow(y,2) + pow(z,2));\n    return d;\n}\n\nA:\n\nThe problem is that you are using the wrong formula.\nThe formula you are using is the one for the signed distance to a line.\nThe formula for", "#ifdef DEBUG\n    vec3 r = ro - rd;\n    vec3 r2 = r.norm2();\n    vec3 r3 = r2 * r2;\n    vec3 r4 = r3 * r2;\n    vec3 r5 = r4 * r2;\n    vec3 r6 = r5 * r2;\n    vec3 r7 = r6 * r2;\n    vec3 r8 = r7 * r2;\n    vec3 r9 = r8 * r2;\n    vec3 r10 = r9 * r2;\n    vec3 r11 = r10 * r2;\n    vec3 r12 = r11 * r2;\n    vec3 r13 = r12 * r2;\n    vec3 r14 = r13 * r2;\n    vec3 r15 = r14 * r2;\n    vec3 r16 = r15 * r2;\n    vec3 r17 = r16 * r2;\n    vec3 r18 = r17 * r2;\n    vec3 r19 = r18 * r2;\n    vec3 r20 = r19 * r2;\n    vec3 r21 = r20 * r2;\n    vec3 r22 = r21 * r2;\n    vec3 r23 = r22 * r2;\n    vec3 r24 = r23 * r2;\n    vec3 r25 = r24 * r2;\n    vec3 r26 = r25 * r2;\n    vec3 r27 = r26 * r2;\n    vec3 r28 = r27 * r2;\n    vec3 r29 = r28 * r2;\n    vec3 r30 = r29 * r2;\n    vec3 r31 = r30 * r2;\n    vec3 r32 = r31 * r2;\n    vec3 r33 = r32 * r2;\n    vec3 r34 = r33 * r2;\n    vec3 r35 = r34 * r2;\n    vec3 r36 = r35 * r2;\n    vec3 r37 = r36 * r2;\n    vec3 r38 = r37 * r2;\n    vec3 r39 = r38 * r2;\n    vec3", "#include <math.h>\n    float x = p.x;\n    float y = p.y;\n    float dx = x - w/2;\n    float dy = y - r/2;\n    float d = sqrt(dx*dx + dy*dy);\n    return w/2 + (w/2 + r/2)*(d/r);\n}\n\nfloat roundedY(vec2 p, float w, float r) {#include <math.h>\n    float x = p.x;\n    float y = p.y;\n    float dx = x - w/2;\n    float dy = y - r/2;\n    float d = sqrt(dx*dx + dy*dy);\n    return w/2 + (w/2 + r/2)*(d/r);\n}\n\nfloat roundedX(vec2 p, float w, float r) {#include <math.h>\n    float x = p.x;\n    float y = p.y;\n    float dx = x - w/2;\n    float dy = y - r/2;\n    float d = sqrt(dx*dx + dy*dy);\n    return w/2 + (w/2 + r/2)*(d/r);\n}\n\nfloat roundedY(vec2 p, float w, float r) {#include <math.h>\n    float x = p.x;\n    float y = p.y;\n    float dx = x - w/2;\n    float dy = y - r/2;\n    float d = sqrt(dx*dx + dy*dy);\n    return w/2 + (w/2 + r/2)*(d/r);\n}\n\nfloat roundedX(vec2 p, float w, float r) {#include <math.h>\n    float x = p.x;\n    float y = p.y;\n    float dx = x - w/2;\n    float dy = y - r/2;\n    float d = sqrt(dx*dx + dy*dy);\n    return w/2 + (w/2 + r/2)*(d/r);\n}\n\nfloat roundedY(vec2 p, float w, float", "\n    float x = p.x;\n    float y = p.y;\n    float x2 = x*x;\n    float y2 = y*y;\n    float x3 = x2*x2;\n    float y3 = y2*y2;\n    float x4 = x3*x3;\n    float y4 = y3*y3;\n    float x5 = x4*x4;\n    float y5 = y4*y4;\n    float x6 = x5*x5;\n    float y6 = y5*y5;\n    float x7 = x6*x6;\n    float y7 = y6*y6;\n    float x8 = x7*x7;\n    float y8 = y7*y7;\n    float x9 = x8*x8;\n    float y9 = y8*y8;\n    float x10 = x9*x9;\n    float y10 = y9*y9;\n    float x11 = x10*x10;\n    float y11 = y10*y10;\n    float x12 = x11*x11;\n    float y12 = y11*y11;\n    float x13 = x12*x12;\n    float y13 = y12*y12;\n    float x14 = x13*x13;\n    float y14 = y13*y13;\n    float x15 = x14*x14;\n    float y15 = y14*y14;\n    float x16 = x15*x15;\n    float y16 = y15*y15;\n    float x17 = x16*x16;\n    float y17 = y16*y16;\n    float x18 = x17*x17;\n    float y18 = y17*y17;\n    float x19 = x18*x18;\n    float y19 = y18*y18;\n    float x20 = x19*x19;\n    float y20 = y19*y19;\n    float x21 = x20*x20;\n    float y21 = y20*y20;\n    float x22 = x21*x21;\n    float y22 =", "    \n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f;\n    float dy = y - 1.0f;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{    \n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f;\n    float dy = y - 1.0f;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{    \n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f;\n    float dy = y - 1.0f;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{    \n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f;\n    float dy = y - 1.0f;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{    \n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f;\n    float dy = y - 1.0f;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{    \n    float x = p.x;\n    float y = p.y;\n    float dx = x - 1.0f;\n    float dy = y - 1.0f;\n    float d = sqrt(dx*dx + dy*dy);\n    return d;\n}\n", "#include <math.h>\n    return (a < b)? a : b;\n}\n\nfloat pmax(float a, float b, float k) {#include <math.h>\n    return (a > b)? a : b;\n}\n\nfloat pmean(float a, float b, float k) {#include <math.h>\n    return (a + b) / 2;\n}\n\nfloat pmedian(float a, float b, float k) {#include <math.h>\n    return (a + b) / 2;\n}\n\nfloat pmode(float a, float b, float k) {#include <math.h>\n    return (a == b)? a : b;\n}\n\nfloat pvariance(float a, float b, float k) {#include <math.h>\n    return pow(a - pmean(a, b, k), 2) + pow(b - pmean(a, b, k), 2) / (k - 1);\n}\n\nfloat pstdev(float a, float b, float k) {#include <math.h>\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pcorr(float a, float b, float k) {#include <math.h>\n    return pstdev(a, b, k) / sqrt(pvariance(a, a, k) * pvariance(b, b, k));\n}\n\nfloat pcorr_p(float a, float b, float k) {#include <math.h>\n    return pcorr(a, b, k) * sqrt(k - 1);\n}\n\nfloat pcorr_p_p(float a, float b, float k) {#include <math.h>\n    return pcorr_p(a, b, k) * sqrt(k * (k - 1));\n}\n\nfloat pcorr_p_p_p(float a, float b, float k) {#include <math.h>\n    return pcorr_p_p(a, b, k) * sqrt(k * (k - 1) * (k - 2));", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MINOR_MAJOR_MIN", "#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n    float x, y;\n    x = p.x;\n    y = p.y;\n    return sqrt(x*x + y*y);\n}\n\nfloat heart(vec2 p) {#include <math.h>\n", "\n    float h = 0.0f;\n    for (int i = 0; i < 3; ++i) {\n        h += p[i] * vec2(i, 0.0f);\n    }\n    return h;\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec2 p) {\n    float h = 0.0f;\n    for (int i = 0; i < 3; ++i) {\n        h += p[i] * vec2(i, sin(i));\n    }\n    return h;\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec2 p) {\n    float h = 0.0f;\n    for (int i = 0; i < 3; ++i) {\n        h += p[i] * vec2(i, cos(i));\n    }\n    return h;\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec2 p) {\n    float h = 0.0f;\n    for (int i = 0; i < 3; ++i) {\n        h += p[i] * vec2(i, sin(i) * cos(i));\n    }\n    return h;\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec2 p) {\n    float h = 0.0f;\n    for (int i = 0; i < 3; ++i) {\n        h += p[i] * vec2(i, sin(i) * sin(i));\n    }\n    return h;\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash17(vec2 p) {\n    float h = 0.0f;\n    for (int i = 0; i < 3; ++i) {\n        h += p[i] * vec2(i, cos(i) * cos(i));\n    }\n    return", "\n    vec3 p = pos;\n    vec3 x = A;\n    vec3 y = B;\n    vec3 z = C;\n    vec3 dx = x - p;\n    vec3 dy = y - p;\n    vec3 dz = z - p;\n    vec3 xy = x * y;\n    vec3 xz = x * z;\n    vec3 yz = y * z;\n    vec3 xyz = xy + xz;\n    vec3 xyz2 = xyz * xyz;\n    vec3 xyz3 = xyz2 * xyz;\n    vec3 xyz4 = xyz3 * xyz;\n    vec3 xyz5 = xyz4 * xyz;\n    vec3 xyz6 = xyz5 * xyz;\n    vec3 xyz7 = xyz6 * xyz;\n    vec3 xyz8 = xyz7 * xyz;\n    vec3 xyz9 = xyz8 * xyz;\n    vec3 xyz10 = xyz9 * xyz;\n    vec3 xyz11 = xyz10 * xyz;\n    vec3 xyz12 = xyz11 * xyz;\n    vec3 xyz13 = xyz12 * xyz;\n    vec3 xyz14 = xyz13 * xyz;\n    vec3 xyz15 = xyz14 * xyz;\n    vec3 xyz16 = xyz15 * xyz;\n    vec3 xyz17 = xyz16 * xyz;\n    vec3 xyz18 = xyz17 * xyz;\n    vec3 xyz19 = xyz18 * xyz;\n    vec3 xyz20 = xyz19 * xyz;\n    vec3 xyz21 = xyz20 * xyz;\n    vec3 xyz22 = xyz21 * xyz;\n    vec3 xyz23 = xyz22 * xyz;\n    vec3 xyz24 = xyz23 * xyz;\n    vec3 xyz25 = xyz24 * xyz;\n    vec3 xyz26 = xyz25 * xyz;\n    vec3 xyz27 = xyz26 * xyz;\n    vec3 xyz28 = xyz27 * xyz", "#ifdef DEBUG\n    cout << \"sdParabola(pos = \" << pos.x << \", \" << pos.y << \", \" << wi << \", \" << he << \")\" << endl;\n#endif\n    vec3 p = pos;\n    vec3 f = vec3(wi, 0, he);\n    vec3 d = vec3(0, 0, 1);\n    vec3 dp = vec3(0, 0, 0);\n    vec3 dp2 = vec3(0, 0, 0);\n    vec3 dp3 = vec3(0, 0, 0);\n    vec3 dp4 = vec3(0, 0, 0);\n    vec3 dp5 = vec3(0, 0, 0);\n    vec3 dp6 = vec3(0, 0, 0);\n    vec3 dp7 = vec3(0, 0, 0);\n    vec3 dp8 = vec3(0, 0, 0);\n    vec3 dp9 = vec3(0, 0, 0);\n    vec3 dp10 = vec3(0, 0, 0);\n    vec3 dp11 = vec3(0, 0, 0);\n    vec3 dp12 = vec3(0, 0, 0);\n    vec3 dp13 = vec3(0, 0, 0);\n    vec3 dp14 = vec3(0, 0, 0);\n    vec3 dp15 = vec3(0, 0, 0);\n    vec3 dp16 = vec3(0, 0, 0);\n    vec3 dp17 = vec3(0, 0, 0);\n    vec3 dp18 = vec3(0, 0, 0);\n    vec3 dp19 = vec3(0, 0, 0);\n    vec3 dp20 = vec3(0, 0, 0);\n    vec3 dp21 = vec3(0, 0, 0);\n    vec3 dp22 = vec3(0, 0, 0);\n    vec3 dp23 = vec3(0, 0, 0);\n    vec3 dp24 = vec3(0, 0, 0);\n    vec3 dp25 = vec3(0, 0, 0);\n", "#ifdef DEBUG\n    cout << \"sdParabola(pos = \" << pos << \", k = \" << k << \")\" << endl;\n#endif\n    vec3 p = pos;\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 dp = vec3(0.0, 0.0, 0.0);\n    vec3 d2 = vec3(0.0, 0.0, 0.0);\n    vec3 d3 = vec3(0.0, 0.0, 0.0);\n    vec3 d4 = vec3(0.0, 0.0, 0.0);\n    vec3 d5 = vec3(0.0, 0.0, 0.0);\n    vec3 d6 = vec3(0.0, 0.0, 0.0);\n    vec3 d7 = vec3(0.0, 0.0, 0.0);\n    vec3 d8 = vec3(0.0, 0.0, 0.0);\n    vec3 d9 = vec3(0.0, 0.0, 0.0);\n    vec3 d10 = vec3(0.0, 0.0, 0.0);\n    vec3 d11 = vec3(0.0, 0.0, 0.0);\n    vec3 d12 = vec3(0.0, 0.0, 0.0);\n    vec3 d13 = vec3(0.0, 0.0, 0.0);\n    vec3 d14 = vec3(0.0, 0.0, 0.0);\n    vec3 d15 = vec3(0.0, 0.0, 0.0);\n    vec3 d16 = vec3(0.0, 0.0, 0.0);\n    vec3 d17 = vec3(0.0, 0.0, 0.0);\n    vec3 d18 = vec3(0.0, 0.0, 0.0);\n    vec3 d19 = vec3(0.0, 0.0, 0.0);\n    vec3 d20 =", "#include \"math.h\"\n    vec3 r = vec3(p.x, p.y, p.z);\n    vec3 rp = r + d*vec3(cos(ra), sin(ra), 0);\n    vec3 rp2 = rp*rp;\n    vec3 rp3 = rp2*rp;\n    vec3 rp4 = rp3*rp;\n    vec3 rp5 = rp4*rp;\n    vec3 rp6 = rp5*rp;\n    vec3 rp7 = rp6*rp;\n    vec3 rp8 = rp7*rp;\n    vec3 rp9 = rp8*rp;\n    vec3 rp10 = rp9*rp;\n    vec3 rp11 = rp10*rp;\n    vec3 rp12 = rp11*rp;\n    vec3 rp13 = rp12*rp;\n    vec3 rp14 = rp13*rp;\n    vec3 rp15 = rp14*rp;\n    vec3 rp16 = rp15*rp;\n    vec3 rp17 = rp16*rp;\n    vec3 rp18 = rp17*rp;\n    vec3 rp19 = rp18*rp;\n    vec3 rp20 = rp19*rp;\n    vec3 rp21 = rp20*rp;\n    vec3 rp22 = rp21*rp;\n    vec3 rp23 = rp22*rp;\n    vec3 rp24 = rp23*rp;\n    vec3 rp25 = rp24*rp;\n    vec3 rp26 = rp25*rp;\n    vec3 rp27 = rp26*rp;\n    vec3 rp28 = rp27*rp;\n    vec3 rp29 = rp28*rp;\n    vec3 rp30 = rp29*rp;\n    vec3 rp31 = rp30*rp;\n    vec3 rp32 = rp31", "\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2.0 - 1.0;\n    p.y = (p.y + 0.5) * 2.0 - 1.0;\n    return p;\n}\n\nivec2 Pcg2(ivec2 v)\n{\n    ivec2 p = v;\n    p.x = (p.x + 0.5) * 2", "\n    ivec3 r = v;\n    r.x = v.x * (1.0 - v.x) * (1.0 - v.x) * (1.0 - v.x);\n    r.y = v.y * (1.0 - v.y) * (1.0 - v.y) * (1.0 - v.y);\n    r.z = v.z * (1.0 - v.z) * (1.0 - v.z) * (1.0 - v.z);\n    return r;\n}\n\nivec3 Pcg3(ivec3 v)\n{\n    ivec3 r = v;\n    r.x = v.x * (1.0 - v.x) * (1.0 - v.x) * (1.0 - v.x);\n    r.y = v.y * (1.0 - v.y) * (1.0 - v.y) * (1.0 - v.y);\n    r.z = v.z * (1.0 - v.z) * (1.0 - v.z) * (1.0 - v.z);\n    return r;\n}\n\nivec3 Pcg3(ivec3 v)\n{\n    ivec3 r = v;\n    r.x = v.x * (1.0 - v.x) * (1.0 - v.x) * (1.0 - v.x);\n    r.y = v.y * (1.0 - v.y) * (1.0 - v.y) * (1.0 - v.y);\n    r.z = v.z * (1.0 - v.z) * (1.0 - v.z) * (1.0 - v.z);\n    return r;\n}\n\nivec3 Pcg3(ivec3 v)\n{\n    ivec3 r = v;\n    r.x = v.x * (1.0 - v.x) * (1.0 - v.x) * (1.0 - v.x);\n    r.y = v.y * (1.0", "    \n    vec2 p = pos - A;\n    vec2 q = B - A;\n    vec2 r = C - A;\n    float a = dot(q, q) + dot(r, r);\n    float b = 2 * dot(q, p) + 2 * dot(r, q);\n    float c = dot(p, p) + dot(r, r);\n    float d = 2 * dot(p, q) + dot(r, p);\n    float e = dot(p, p) - dot(q, q) - dot(r, r);\n    float f = 2 * dot(p, q) - dot(r, p);\n    float g = dot(p, p) - dot(r, r);\n    float h = dot(p, q) - dot(q, p);\n    float i = dot(p, p) - dot(r, r);\n    float j = dot(p, q) - dot(q, p);\n    float k = dot(p, p) - dot(r, r);\n    float l = dot(p, q) - dot(q, p);\n    float m = dot(p, p) - dot(r, r);\n    float n = dot(p, q) - dot(q, p);\n    float o = dot(p, p) - dot(r, r);\n    float p = dot(p, q) - dot(q, p);\n    float q = dot(p, p) - dot(r, r);\n    float r = dot(p, q) - dot(q, p);\n    float s = dot(p, p) - dot(r, r);\n    float t = dot(p, q) - dot(q, p);\n    float u = dot(p, p) - dot(r, r);\n    float v = dot(p, q) - dot(q, p);\n    float w = dot(p, p) - dot(r, r);\n    float x = dot(p, q) - dot(q, p);\n    float y = dot(p, p) - dot(r, r);\n    float z = dot(p, q) - dot(q,", "\n    float x = (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n    return x;\n}\n\n// Source: https://www.shadertoy.com/view/wjvz9y\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    float x = (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n    return x;\n}\n\n// Source: https://www.shadertoy.com/view/wjvz9y\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    float x = (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n    return x;\n}\n\n// Source: https://www.shadertoy.com/view/wjvz9y\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    float x = (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n    return x;\n}\n\n// Source: https://www.shadertoy.com/view/wjvz9y\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    float x = (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n    return x;\n}\n\n// Source: https://www.shadertoy.com/view/wjvz9y\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    float x = (a.x - p.x) * (b.y - p.y) - (a", "#ifdef DEBUG\n    cout << \"iWedge: ro = \" << ro << \", rd = \" << rd << \", s = \" << s << endl;\n#endif\n    vec3 r = rd - ro;\n    vec3 n = cross( r, s );\n    vec3 d = dot( r, s );\n    if( d < 0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 0.0 );\n    }\n    vec3 t = (s.x * n.y - s.y * n.x) / d;\n    vec3 t0 = (s.x * r.y - s.y * r.x) / d;\n    vec3 t1 = (s.x * r.z - s.z * r.x) / d;\n    vec3 t2 = (s.y * r.z - s.z * r.y) / d;\n    vec3 t3 = (s.x * r.w - s.w * r.x) / d;\n    vec3 t4 = (s.y * r.w - s.w * r.y) / d;\n    vec3 t5 = (s.z * r.w - s.w * r.z) / d;\n    vec3 t6 = (s.x * r.w - s.w * r.x) / d;\n    vec3 t7 = (s.y * r.w - s.w * r.y) / d;\n    vec3 t8 = (s.z * r.w - s.w * r.z) / d;\n    vec3 t9 = (s.x * r.w - s.w * r.x) / d;\n    vec3 t10 = (s.y * r.w - s.w * r.y) / d;\n    vec3 t11 = (s.z * r.w - s.w * r.z) / d;\n    vec3 t12 = (s.x * r.w - s.w * r.x) / d;\n    vec3 t13 = (s.y * r.w - s.w * r.", "\n    int a_abs = abs(a);\n    int b_abs = abs(b);\n    int x_abs = abs(x);\n    int a_sign = a_abs >> 24;\n    int b_sign = b_abs >> 24;\n    int x_sign = x_abs >> 24;\n    int a_exp = a_abs >> 12;\n    int b_exp = b_abs >> 12;\n    int x_exp = x_abs >> 12;\n    int a_m12 = a_abs & 0xfff;\n    int b_m12 = b_abs & 0xfff;\n    int x_m12 = x_abs & 0xfff;\n    int a_m12_sign = a_m12 >> 12;\n    int b_m12_sign = b_m12 >> 12;\n    int x_m12_sign = x_m12 >> 12;\n    int a_m12_exp = a_m12 & 0xfff;\n    int b_m12_exp = b_m12 & 0xfff;\n    int x_m12_exp = x_m12 & 0xfff;\n    int a_m12_m12 = a_m12 & 0xfff;\n    int b_m12_m12 = b_m12 & 0xfff;\n    int x_m12_m12 = x_m12 & 0xfff;\n    int a_m12_m12_sign = a_m12_sign >> 12;\n    int b_m12_m12_sign = b_m12_sign >> 12;\n    int x_m12_m12_sign = x_m12_sign >> 12;\n    int a_m12_m12_exp = a_m12_exp & 0xfff;\n    int b_m12_m12_exp = b_m12_exp & 0xfff;\n    int x_m12_m12_exp = x_m12_exp & 0xfff;\n    int a_m12_m12_m12 = a_m12_m12 & 0xfff;\n    int b_m12_m12_m12 = b_m12_m12", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    vec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n    {\n        vec3 c = a + b;\n        vec3 d = a - b;\n        vec3 e = a * b;\n        vec3 f = a / b;\n        vec3 g = a % b;\n        vec3 h = a ^ b;\n        vec3 i = a & b;\n        vec3 j = a | b;\n        vec3 k = a << b;\n        vec3 l = a >> b;\n        vec3 m = a << 1;\n        vec3 n = a >> 1;\n        vec3 o = a << 2;\n        vec3 p = a >> 2;\n        vec3 q = a << 3;\n        vec3 r = a >> 3;\n        vec3 s = a << 4;\n        vec3 t = a >> 4;\n        vec3 u = a << 5;\n        vec3 v = a >> 5;\n        vec3 w = a << 6;\n        vec3 x = a >> 6;\n        vec3 y = a << 7;\n        vec3 z = a >> 7;\n        vec3 a = a + b;\n        vec3 b = a - b;\n        vec3 c = a * b;\n        vec3 d = a / b;\n        vec3 e = a % b;\n        vec3 f = a ^ b;\n        vec3 g = a & b;\n        vec3 h = a | b;\n        vec3 i = a << b;\n        vec3 j = a >> b;\n        vec3 k = a << 1;\n        vec3 l = a >> 1;\n        vec3 m = a << 2;\n        vec3 n = a >> 2;\n        vec3 o = a << 3;\n        vec3 p = a >> 3;\n        vec3 q = a << 4;\n        vec3 r = a >> 4;\n        vec3 s = a << 5;\n        vec3 t = a >> 5;\n        vec3 u = a << 6;\n        vec3 v = a >> 6;\n        vec3 w =", "\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    return x*x + y*y - ab.a*ab.a - ab.b*ab.b > 0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat outside_Hyperbola( vec2 p, in vec2 ab){\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    return x*x + y*y - ab.a*ab.a - ab.b*ab.b < 0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Ellipse( vec2 p, in vec2 ab){\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    return x*x + y*y - ab.a*ab.a - ab.b*ab.b > 0;\n}\n\n//using the \"locus of points\" geometric defn of ellipse\nfloat outside_Ellipse( vec2 p, in vec2 ab){\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    return x*x + y*y - ab.a*ab.a - ab.b*ab.b < 0;\n}\n\n//using the \"locus of points\" geometric defn of ellipse\nfloat inside_Circle( vec2 p, in vec2 ab){\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    return x*x + y*y - ab.a*ab.a - ab.b*ab.b > 0;\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat outside_Circle( vec2 p, in vec2 ab){\n    float x = p.x - ab.x;\n    float y = p.y - ab.y;\n    return x*x + y*y - ab.a*ab.a - ab.b*ab.b < 0;\n", "    \n    float c = a + b;\n    return c;\n}\n\nfloat sub_ploss(in float a, in float b){    \n    float c = a - b;\n    return c;\n}\n\nfloat mul_ploss(in float a, in float b){    \n    float c = a * b;\n    return c;\n}\n\nfloat div_ploss(in float a, in float b){    \n    float c = a / b;\n    return c;\n}\n\nfloat pow_ploss(in float a, in float b){    \n    float c = pow(a, b);\n    return c;\n}\n\nfloat sqrt_ploss(in float a){    \n    float c = sqrt(a);\n    return c;\n}\n\nfloat log_ploss(in float a){    \n    float c = log(a);\n    return c;\n}\n\nfloat exp_ploss(in float a){    \n    float c = exp(a);\n    return c;\n}\n\nfloat sin_ploss(in float a){    \n    float c = sin(a);\n    return c;\n}\n\nfloat cos_ploss(in float a){    \n    float c = cos(a);\n    return c;\n}\n\nfloat tan_ploss(in float a){    \n    float c = tan(a);\n    return c;\n}\n\nfloat asin_ploss(in float a){    \n    float c = asin(a);\n    return c;\n}\n\nfloat acos_ploss(in float a){    \n    float c = acos(a);\n    return c;\n}\n\nfloat atan_ploss(in float a){    \n    float c = atan(a);\n    return c;\n}\n\nfloat atan2_ploss(in float a, in float b){    \n    float c = atan2(a, b);\n    return c;\n}\n\nfloat sinh_ploss(in float a){    \n    float c = sinh(a);\n    return c;\n}\n\nfloat cosh_ploss(in float a){    \n    float c = cosh(", "\n    //p is the center of the hyperbola\n    //ab is the distance between the foci\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector of the two solutions\n    //s1 and s2 are the distances from the center to the vertices\n    //returns a vector", "\n    vec3 p0 = a + (b - a) * (p - a);\n    vec3 p1 = b + (a - b) * (p - b);\n    vec3 p2 = a + (b - a) * (p - a);\n    vec3 p3 = b + (a - b) * (p - b);\n\n    vec3 p0p1 = p1 - p0;\n    vec3 p0p2 = p2 - p0;\n    vec3 p0p3 = p3 - p0;\n\n    vec3 p0p1p2 = p2 - p1;\n    vec3 p0p1p3 = p3 - p1;\n    vec3 p0p2p3 = p3 - p2;\n\n    vec3 p0p1p2p3 = p3 - p1;\n\n    vec3 p0p1p2p3p0 = p0p1p2p3 - p0p1p2;\n    vec3 p0p1p2p3p1 = p0p1p2p3 - p0p1p3;\n    vec3 p0p1p2p3p2 = p0p1p2p3 - p0p2p3;\n    vec3 p0p1p2p3p3 = p0p1p2p3 - p0p3p3;\n\n    vec3 p0p1p2p3p0p1 = p0p1p2p3p0 - p0p1p2;\n    vec3 p0p1p2p3p0p2 = p0p1p2p3p0 - p0p2p3;\n    vec3 p0p1p2p3p0p3 = p0p1p2p3p0 - p0p3p3;\n    vec3 p0p1p2p3p1p2 = p0p1p2p3p1 - p0p1p2;\n    vec3 p0p1p2p3p1p3 = p0p1p2p3p1 - p0p1p3;\n    vec3 p0p1p2p3p2p3 = p", "\n    vec3 p1 = p - a;\n    vec3 p2 = p - b;\n    vec3 p3 = p - a;\n    vec3 p4 = p - b;\n    vec3 p5 = p - a;\n    vec3 p6 = p - b;\n    vec3 p7 = p - a;\n    vec3 p8 = p - b;\n    vec3 p9 = p - a;\n    vec3 p10 = p - b;\n    vec3 p11 = p - a;\n    vec3 p12 = p - b;\n    vec3 p13 = p - a;\n    vec3 p14 = p - b;\n    vec3 p15 = p - a;\n    vec3 p16 = p - b;\n    vec3 p17 = p - a;\n    vec3 p18 = p - b;\n    vec3 p19 = p - a;\n    vec3 p20 = p - b;\n    vec3 p21 = p - a;\n    vec3 p22 = p - b;\n    vec3 p23 = p - a;\n    vec3 p24 = p - b;\n    vec3 p25 = p - a;\n    vec3 p26 = p - b;\n    vec3 p27 = p - a;\n    vec3 p28 = p - b;\n    vec3 p29 = p - a;\n    vec3 p30 = p - b;\n    vec3 p31 = p - a;\n    vec3 p32 = p - b;\n    vec3 p33 = p - a;\n    vec3 p34 = p - b;\n    vec3 p35 = p - a;\n    vec3 p36 = p - b;\n    vec3 p37 = p - a;\n    vec3 p38 = p - b;\n    vec3 p39 = p - a;\n    vec3 p40 = p - b;\n    vec3 p41 = p - a;\n    vec3 p42 = p - b;\n    vec3 p43 = p - a;\n    vec3 p44 = p - b;\n    vec3 p45 = p - a;\n    vec3 p46 = p - b;\n    vec3 p47", "\n    vec3 p0 = p - cen;\n    vec3 p1 = p0 / (p0.norm() + 1e-6);\n    vec3 p2 = p1 * rad;\n    vec3 p3 = p0 + p2;\n    return p3.norm();\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    vec3 p0 = p - cen;\n    vec3 p1 = p0 / (p0.norm() + 1e-6);\n    vec3 p2 = p1 * rad;\n    vec3 p3 = p0 + p2;\n    return p3.norm();\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    vec3 p0 = p - cen;\n    vec3 p1 = p0 / (p0.norm() + 1e-6);\n    vec3 p2 = p1 * rad;\n    vec3 p3 = p0 + p2;\n    return p3.norm();\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    vec3 p0 = p - cen;\n    vec3 p1 = p0 / (p0.norm() + 1e-6);\n    vec3 p2 = p1 * rad;\n    vec3 p3 = p0 + p2;\n    return p3.norm();\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    vec3 p0 = p - cen;\n    vec3 p1 = p0 / (p0.norm() + 1e-6);\n    vec3 p2 = p1 * rad;\n    vec3 p3 = p0 + p2;\n    return p3.norm();\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec", "#include <math.h>\n    vec3 normal;\n    vec3 u, v;\n    vec3 w;\n    vec3 n;\n    vec3 d;\n    vec3 d2;\n    vec3 d3;\n    vec3 d4;\n    vec3 d5;\n    vec3 d6;\n    vec3 d7;\n    vec3 d8;\n    vec3 d9;\n    vec3 d10;\n    vec3 d11;\n    vec3 d12;\n    vec3 d13;\n    vec3 d14;\n    vec3 d15;\n    vec3 d16;\n    vec3 d17;\n    vec3 d18;\n    vec3 d19;\n    vec3 d20;\n    vec3 d21;\n    vec3 d22;\n    vec3 d23;\n    vec3 d24;\n    vec3 d25;\n    vec3 d26;\n    vec3 d27;\n    vec3 d28;\n    vec3 d29;\n    vec3 d30;\n    vec3 d31;\n    vec3 d32;\n    vec3 d33;\n    vec3 d34;\n    vec3 d35;\n    vec3 d36;\n    vec3 d37;\n    vec3 d38;\n    vec3 d39;\n    vec3 d40;\n    vec3 d41;\n    vec3 d42;\n    vec3 d43;\n    vec3 d44;\n    vec3 d45;\n    vec3 d46;\n    vec3 d47;\n    vec3 d48;\n    vec3 d49;\n    vec3 d50;\n    vec3 d51;\n    vec3 d52;\n    vec3 d53;\n    vec3 d54;\n    vec3 d55;\n    vec3 d56;\n    vec3 d57;\n    vec3 d58;\n    vec3 d59;\n    vec3 d60;\n    vec3 d61;\n    vec3 d62;\n    vec3 d63;\n    vec3 d64;\n    vec3 d65;\n    vec3 d66;\n    vec3 d67;\n    vec3 d68;\n    vec3", "\n    vec3 r = ro - rd;\n    vec3 n = normalize(r);\n    vec3 s = normalize(r - n * dot(r,n));\n    vec3 d = normalize(rd - ro);\n    vec3 dn = normalize(dot(d,n));\n    vec3 ds = normalize(dot(d,s));\n    vec3 dn2 = normalize(dot(d,n) * 2);\n    vec3 ds2 = normalize(dot(d,s) * 2);\n    vec3 dn3 = normalize(dot(d,n) * 3);\n    vec3 ds3 = normalize(dot(d,s) * 3);\n    vec3 dn4 = normalize(dot(d,n) * 4);\n    vec3 ds4 = normalize(dot(d,s) * 4);\n    vec3 dn5 = normalize(dot(d,n) * 5);\n    vec3 ds5 = normalize(dot(d,s) * 5);\n    vec3 dn6 = normalize(dot(d,n) * 6);\n    vec3 ds6 = normalize(dot(d,s) * 6);\n    vec3 dn7 = normalize(dot(d,n) * 7);\n    vec3 ds7 = normalize(dot(d,s) * 7);\n    vec3 dn8 = normalize(dot(d,n) * 8);\n    vec3 ds8 = normalize(dot(d,s) * 8);\n    vec3 dn9 = normalize(dot(d,n) * 9);\n    vec3 ds9 = normalize(dot(d,s) * 9);\n    vec3 dn10 = normalize(dot(d,n) * 10);\n    vec3 ds10 = normalize(dot(d,s) * 10);\n    vec3 dn11 = normalize(dot(d,n) * 11);\n    vec3 ds11 = normalize(dot(d,s) * 11);\n    vec3 dn12 = normalize(dot(d,n) * 12);\n    vec3 ds", "#ifdef _GL_ARB_VERSION_MAJOR_MINOR_MAJOR\n    vec3 sdgTrapezoid_v2( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n    {\n        vec3 ocl2 = ocl;\n        vec3 ocl3 = ocl;\n        vec3 ocl4 = ocl;\n        vec3 ocl5 = ocl;\n        vec3 ocl6 = ocl;\n        vec3 ocl7 = ocl;\n        vec3 ocl8 = ocl;\n        vec3 ocl9 = ocl;\n        vec3 ocl10 = ocl;\n        vec3 ocl11 = ocl;\n        vec3 ocl12 = ocl;\n        vec3 ocl13 = ocl;\n        vec3 ocl14 = ocl;\n        vec3 ocl15 = ocl;\n        vec3 ocl16 = ocl;\n        vec3 ocl17 = ocl;\n        vec3 ocl18 = ocl;\n        vec3 ocl19 = ocl;\n        vec3 ocl20 = ocl;\n        vec3 ocl21 = ocl;\n        vec3 ocl22 = ocl;\n        vec3 ocl23 = ocl;\n        vec3 ocl24 = ocl;\n        vec3 ocl25 = ocl;\n        vec3 ocl26 = ocl;\n        vec3 ocl27 = ocl;\n        vec3 ocl28 = ocl;\n        vec3 ocl29 = ocl;\n        vec3 ocl30 = ocl;\n        vec3 ocl31 = ocl;\n        vec3 ocl32 = ocl;\n        vec3 ocl33 = ocl;\n        vec3 ocl34 = ocl;\n        vec3 ocl35 = ocl;\n        vec3 ocl36 = ocl;\n        vec3 ocl37 = ocl;\n        vec3 ocl38 = ocl;\n        vec3 ocl39 = ocl;\n        vec3 ocl40 = ocl;\n        vec3 ocl41 = ocl;\n        vec3 ocl42 = ocl;\n        ", "#define PI 3.1415926535897932384626433832795\n    vec3 r = p - center;\n    float r2 = r.x*r.x + r.y*r.y + r.z*r.z;\n    float r3 = r2*r2;\n    float r4 = r3*r3;\n    float r5 = r4*r3;\n    float r6 = r5*r3;\n    float r7 = r6*r3;\n    float r8 = r7*r3;\n    float r9 = r8*r3;\n    float r10 = r9*r3;\n    float r11 = r10*r3;\n    float r12 = r11*r3;\n    float r13 = r12*r3;\n    float r14 = r13*r3;\n    float r15 = r14*r3;\n    float r16 = r15*r3;\n    float r17 = r16*r3;\n    float r18 = r17*r3;\n    float r19 = r18*r3;\n    float r20 = r19*r3;\n    float r21 = r20*r3;\n    float r22 = r21*r3;\n    float r23 = r22*r3;\n    float r24 = r23*r3;\n    float r25 = r24*r3;\n    float r26 = r25*r3;\n    float r27 = r26*r3;\n    float r28 = r27*r3;\n    float r29 = r28*r3;\n    float r30 = r29*r3;\n    float r31 = r30*r3;\n    float r32 = r31*r3;\n    float r33 = r32*r3;\n    float r34 = r33*r3;\n    float r35 = r34*r3;\n    float r36 = r35*r3;\n    float r37 = r36*r3;\n    float r38 = r37*r3;\n    float r39 = r38*r3;\n    float r40 = r39*r", "\n    float u = (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n    if (u < 0.0f) return 0.0f;\n    if (u > 1.0f) return 1.0f;\n    return u;\n}\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points (x1,y1) and (x2,y2) is given by:\nsqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((x2-x1)^2 + (y2-y1)^2)\n\nA:\n\nYou can use the distance formula:\ndistance = sqrt((", "\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist2(in vec3 p, in vec3 q) {\n    return dot2(p-q);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist(in vec3 p, in vec3 q) {\n    return sqrt(dist2(p, q));\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist_sq(in vec3 p, in vec3 q) {\n    return dot2(p-q);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist_sq_inv(in vec3 p, in vec3 q) {\n    return 1.0f / dist2(p, q);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist_inv(in vec3 p, in vec3 q) {\n    return 1.0f / dist(p, q);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist_inv_sq(in vec3 p, in vec3 q) {\n    return 1.0f / dist_sq(p, q);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist_inv_sq_inv(in vec3 p, in vec3 q) {\n    return 1.0f / dist_sq_inv(p, q);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/distfunctions.html\nfloat dist_inv_sq_inv_inv(in vec3 p, in vec3 q) {\n    return 1.0f / dist_inv_sq_inv_inv(", "\n    float dx = p.x - minCorner.x;\n    float dy = p.y - minCorner.y;\n    return (dx*dx + dy*dy);\n}\n\n// Find the closest point to the given point\n// Returns the closest point and the distance\n// If the point is inside the box, returns the point and 0\n// If the point is outside the box, returns the point and the distance\n// If the point is on the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n// If the point is on the corner of the box, returns the point and the distance\n// If the point is on the edge of the box, returns the point and the distance\n//", "\n    // Calculate the distance from the camera to the water surface\n    float d = max(0, -cdir.z);\n    // Calculate the color of the water based on the distance\n    vec4 color = vec4(0.5 + 0.5 * d, 0.5 + 0.5 * d, 0.5 + 0.5 * d, 1.0);\n    // Apply the texture to the color\n    color.rgb = texture2D(water_texture, uv).rgb;\n    return color;\n}\n\n// Procedural texture generation for the sky\nvec3 sky(vec2 uv, vec3 cdir)\n{\n    // Calculate the distance from the camera to the sky\n    float d = max(0, -cdir.z);\n    // Calculate the color of the sky based on the distance\n    vec4 color = vec4(0.5 + 0.5 * d, 0.5 + 0.5 * d, 0.5 + 0.5 * d, 1.0);\n    // Apply the texture to the color\n    color.rgb = texture2D(sky_texture, uv).rgb;\n    return color;\n}\n\n// Procedural texture generation for the grass\nvec3 grass(vec2 uv, vec3 cdir)\n{\n    // Calculate the distance from the camera to the grass\n    float d = max(0, -cdir.z);\n    // Calculate the color of the grass based on the distance\n    vec4 color = vec4(0.5 + 0.5 * d, 0.5 + 0.5 * d, 0.5 + 0.5 * d, 1.0);\n    // Apply the texture to the color\n    color.rgb = texture2D(grass_texture, uv).rgb;\n    return color;\n}\n\n// Procedural texture generation for the flowers\nvec3 flowers(vec2 uv, vec3 cdir)\n{\n    // Calculate the distance from the camera to the flowers\n    float d =", "\n    vec2 p = uv * vec2(width, height);\n    return vec3(p.x, p.y, 1.0);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pix2cam(vec3 p)\n{\n    vec2 p2 = p / vec3(1.0, 1.0, 1.0);\n    return vec2(p2.x, p2.y);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 cam2pix(vec3 p)\n{\n    vec2 p2 = p / vec3(1.0, 1.0, 1.0);\n    return vec2(p2.x, p2.y);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 cam2pix_inv(vec3 p)\n{\n    vec2 p2 = p / vec3(1.0, 1.0, 1.0);\n    return vec2(p2.x, p2.y);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 cam2pix_inv_inv(vec3 p)\n{\n    vec2 p2 = p / vec3(1.0, 1.0, 1.0);\n    return vec2(p2.x, p2.y);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 cam2pix_inv_inv_inv(vec3 p)\n{\n    vec2 p2 = p / vec3(1.0, 1.0, 1.0);\n    return vec2(p2.x, p2.y);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 cam2pix_inv_inv_inv_inv(vec3 p)\n{\n    vec2 p2 = p / vec3(1.0, 1.0, 1.0);\n    return vec2(p2.x, p2.y);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 cam2pix_inv_inv_inv_inv_inv(vec3 p)", "\n    vec3 w = q.xyzw * v;\n    vec3 x = q.xyzw * q.xyzw * v.xyzw;\n    vec3 y = q.xyzw * q.xyzw * v.xzw;\n    vec3 z = q.xyzw * q.xyzw * v.yzw;\n    return vec3(w.x + x.y + y.z + z.w, w.y - x.z + y.w + z.x, w.z - x.w + y.x + z.y);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    vec4 w = q1.xyzw * q2.xyzw;\n    vec4 x = q1.xyzw * q2.xzw;\n    vec4 y = q1.xyzw * q2.yzw;\n    vec4 z = q1.xyzw * q2.wzw;\n    return vec4(w.x + x.y + y.z + z.w, w.y - x.z + y.w + z.x, w.z - x.w + y.x + z.y, w.w - x.x - y.y - z.z);\n}\n\n// Quaternion-matrix multiplication\nvec4 quatmul(vec4 q, vec4 m)\n{\n    vec4 w = q.xyzw * m.xyzw;\n    vec4 x = q.xyzw * m.xzw;\n    vec4 y = q.xyzw * m.yzw;\n    vec4 z = q.xyzw * m.wzw;\n    return vec4(w.x + x.y + y.z + z.w, w.y - x.z + y.w + z.x, w.z - x.w + y.x + z.y, w.w - x.x - y.y - z.z);\n}\n\n// Quaternion-matrix inverse\nvec4 quatinv(vec", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return r*r - d*d;\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return r*r - d*d;\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return r*r - d*d;\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return r*r - d*d;\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return r*r - d*d;\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return r*r - d*d;\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    ", "\n    float x = p.x - a.x;\n    float y = p.y - a.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x", "\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opDifference( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opDifference( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return m + (d - a) * (m - vec2(0,0));\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions/\nvec2 opDifference( vec2 m, float d, float a )\n{\n    ", "QVector3D p1v = QVector3D( ro, rd, 0 );\n    p1v.normalize();\n    p1 = p1v * rad;\n    p2 = p1v * -rad;\n}\n\nvoid intersectSegment( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{QVector3D p1v = QVector3D( ro, rd, 0 );\n    p1v.normalize();\n    p1 = p1v * rad;\n    p2 = p1v * -rad;\n}\n\nvoid intersectSegmentCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{QVector3D p1v = QVector3D( ro, rd, 0 );\n    p1v.normalize();\n    p1 = p1v * rad;\n    p2 = p1v * -rad;\n    p2 += p1v * rad;\n}\n\nvoid intersectSegmentSegment( in vec2 ro1, in vec2 rd1, in vec2 ro2, in vec2 rd2, float rad, out vec4 p1, out vec4 p2 )\n{QVector3D p1v = QVector3D( ro1, rd1, 0 );\n    p1v.normalize();\n    p1 = p1v * rad;\n    p2 = p1v * -rad;\n    p2 += p1v * rad;\n    p2 += p1v * rad;\n    p2 += p1v * rad;\n    p2 += p1v * rad;\n}\n\nvoid intersectSegmentSegmentCircle( in vec2 ro1, in vec2 rd1, in vec2 ro2, in vec2 rd2, float rad, out vec4 p1, out vec4 p2 )\n{QVector3D p1v = QVector3D( ro1, rd1, 0 );\n    p1v.normalize();\n    p1 = p1v * rad;\n    p2 = p1v * -rad;\n    p2 += p1", "#include \"sdg.h\"\n    vec3 f(vec2 p)\n    {\n        vec3 x, y, z;\n        x = p.x - c.x;\n        y = p.y - c.y;\n        z = p.z - c.z;\n        return vec3(x*x, y*y, z*z);\n    }\n    vec3 dfdp(vec2 p)\n    {\n        vec3 x, y, z;\n        x = p.x - c.x;\n        y = p.y - c.y;\n        z = p.z - c.z;\n        return vec3(2*x, 2*y, 2*z);\n    }\n    vec3 sdgCircle(vec2 p, vec2 c, float r)\n    {\n        vec3 x, y, z;\n        x = p.x - c.x;\n        y = p.y - c.y;\n        z = p.z - c.z;\n        x = x*x;\n        y = y*y;\n        z = z*z;\n        x = x + y;\n        y = x + z;\n        z = x + y;\n        x = sqrt(x);\n        y = sqrt(y);\n        z = sqrt(z);\n        x = x*r;\n        y = y*r;\n        z = z*r;\n        return vec3(x, y, z);\n    }\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r ) \n{#include \"sdg.h\"\n    vec3 f(vec2 p)\n    {\n        vec3 x, y, z;\n        x = p.x - c.x;\n        y = p.y - c.y;\n        z = p.z - c.z;\n        return vec3(x*x, y*", "#include \"sdfs.h\"\n    vec3 sdg;\n    sdfs::sdf(sdg, p, b);\n    return sdg;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{#include \"sdfs.h\"\n    vec3 sdg;\n    sdfs::sdf(sdg, p, b);\n    return sdg;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{#include \"sdfs.h\"\n    vec3 sdg;\n    sdfs::sdf(sdg, p, b);\n    return sdg;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{#include \"sdfs.h\"\n    vec3 sdg;\n    sdfs::sdf(sdg, p, b);\n    return sdg;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{#include \"sdfs.h\"\n    vec3 sdg;\n    sdfs::sdf(sdg, p, b);\n    return sdg;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//", "#ifdef _OPENGL_\n    vec3 sdg = vec3(0.0,0.0,0.0);\n    vec3 x = p.x;\n    vec3 y = p.y;\n    vec3 z = 0.0;\n    vec3 yz = vec3(0.0,1.0,0.0);\n    vec3 xz = vec3(1.0,0.0,0.0);\n    vec3 xy = vec3(0.0,1.0,0.0);\n    vec3 xyz = vec3(0.0,0.0,1.0);\n    vec3 xyz = vec3(1.0,0.0,0.0);\n    vec3 xyzz = vec3(0.0,0.0,1.0);\n    vec3 xyzxy = vec3(0.0,0.0,1.0);\n    vec3 xyzxyz = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzx = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxy = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyz = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzx = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzxy = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzxyz = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzxyzx = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzxyzxy = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzxyzxyz = vec3(0.0,0.0,1.0);\n    vec3 xyzxyzxyzxyzxyzx = vec3(0.0,0.", "#ifdef DEBUG\n    float a3 = a1 + a2;\n    float b3 = b1 + b2;\n    float a4 = a1 - a2;\n    float b4 = b1 - b2;\n    float a5 = a1 * a2;\n    float b5 = b1 * b2;\n    float a6 = a1 / a2;\n    float b6 = b1 / b2;\n    float a7 = a1 % a2;\n    float b7 = b1 % b2;\n    float a8 = a1 >> a2;\n    float b8 = b1 >> b2;\n    float a9 = a1 << a2;\n    float b9 = b1 << b2;\n    float a10 = a1 & a2;\n    float b10 = b1 & b2;\n    float a11 = a1 ^ a2;\n    float b11 = b1 ^ b2;\n    float a12 = a1 | a2;\n    float b12 = b1 | b2;\n    float a13 = a1 == a2;\n    float b13 = b1 == b2;\n    float a14 = a1!= a2;\n    float b14 = b1!= b2;\n    float a15 = a1 < a2;\n    float b15 = b1 < b2;\n    float a16 = a1 > a2;\n    float b16 = b1 > b2;\n    float a17 = a1 <= a2;\n    float b17 = b1 <= b2;\n    float a18 = a1 >= a2;\n    float b18 = b1 >= b2;\n    float a19 = a1 == a1;\n    float b19 = b1 == b1;\n    float a20 = a1!= a1;\n    float b20 = b1!= b1;\n    float a21 = a1 < b1;\n    float b21 = b1 < b1;\n    float a22 = a1 > b1;\n    float b22 = b1 > b1;\n    float a23 = a1 <= b1;\n    float b23 = b1 <= b1;\n    float a", "\n    return a * sin(n * x) + b;\n}\n\n// https://www.desmos.com/calculator/xzqzcjxjxk\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat k(float a, float b, float n, float x) {\n    return a * cos(n * x) + b;\n}\n\n// https://www.desmos.com/calculator/xzqzcjxjxk\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat l(float a, float b, float n, float x) {\n    return a * sin(n * x) - b;\n}\n\n// https://www.desmos.com/calculator/xzqzcjxjxk\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat m(float a, float b, float n, float x) {\n    return a * cos(n * x) - b;\n}\n\n// https://www.desmos.com/calculator/xzqzcjxjxk\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat n(float a, float b, float n, float x) {\n    return a * sin(n * x) + b;\n}\n\n// https://www.desmos.com/calculator/xzqzcjxjxk\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat o(float a, float b", "#include \"noise.h\"\n                vec2 uv_noise = vec2(noise2(uv.x, uv.y), 0.0f);\n                float uv_noise_x = uv_noise.x;\n                float uv_noise_y = uv_noise.y;\n                float uv_noise_x_sq = uv_noise_x * uv_noise_x;\n                float uv_noise_y_sq = uv_noise_y * uv_noise_y;\n                float uv_noise_x_y = uv_noise_x * uv_noise_y;\n                float uv_noise_x_sq_y = uv_noise_x_sq * uv_noise_y;\n                float uv_noise_y_sq_x = uv_noise_y_sq * uv_noise_x;\n                float uv_noise_x_sq_y_x = uv_noise_x_sq_y * uv_noise_x;\n                float uv_noise_y_sq_x_y = uv_noise_y_sq_x * uv_noise_y;\n                float uv_noise_x_sq_y_x_y = uv_noise_x_sq_y_x * uv_noise_x;\n                float uv_noise_y_sq_x_y_x = uv_noise_y_sq_x_y * uv_noise_y;\n                float uv_noise_x_sq_y_x_y_x = uv_noise_x_sq_y_x_y * uv_noise_x;\n                float uv_noise_y_sq_x_y_x_y = uv_noise_y_sq_x_y_x * uv_noise_y;\n                float uv_noise_x_sq_y_x_y_x_y = uv_noise_x_sq_y_x", "\n    vec3 result = vec3(0,0,0);\n    result.x = (x/14) * (6/13);\n    result.y = (y/14) * (6/13);\n    result.z = (x/14) * (6/13);\n    return result;\n}\n\nA:\n\nYou can use a lookup table.\nconst float table[14][13] = {\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n    {0,0,0,0,0,0,0,0,0,0,0,0},\n};\n\nconst float table_x[13] = {\n    0,0,0,0,0,0,0,0,0,0,0,0\n};\n\nconst float table_y[13] = {\n    0,0,0,0,0", "\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return (d - r) / r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return (d - r) / r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return (d - r) / r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return (d - r) / r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sqrt(x*x + y*y);\n    return (d - r) / r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = sq", "#include <cmath>\n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += pow( p.x - c.x, 2.0 ) + pow( p.y - c.y, 2.0 );\n    }\n    s = sqrt( s );\n    s = s * b.x;\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSphere( in vec2 p, in vec2 c, in vec2 b ) \n{#include <cmath>\n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += pow( p.x - c.x, 2.0 ) + pow( p.y - c.y, 2.0 );\n    }\n    s = sqrt( s );\n    s = s * b.x;\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCone( in vec2 p, in vec2 c, in vec2 b ) \n{#include <cmath>\n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += pow( p.x - c.x, 2.0 ) + pow( p.y - c.y, 2.0 );\n    }\n    s = sqrt( s );\n    s = s * b.x;\n    return s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCylinder( in vec2 p, in vec2 c, in vec2 b ) \n{#include <cmath>\n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += pow( p.x - c.x, 2.0 ) + pow( p.y - c.y, 2.0 );\n    }\n    s = sqrt( s );\n    s = s * b.x;\n    return s;\n", "QVector2D s;\ns.x = (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y) - (b.x - a.x) * (b.x - a.x) - (b.y - a.y) * (b.y - a.y);\ns.y = (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y) - (b.x - a.x) * (b.x - a.x) - (b.y - a.y) * (b.y - a.y);\nreturn s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqCircle( in vec2 p, in vec2 a, in vec2 b )\n{QVector2D s;\ns.x = (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y) - (b.x - a.x) * (b.x - a.x) - (b.y - a.y) * (b.y - a.y);\ns.y = (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y) - (b.x - a.x) * (b.x - a.x) - (b.y - a.y) * (b.y - a.y);\nreturn s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqCircleCircle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{QVector2D s;\ns.x = (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y) - (b.x", "\n    // https://iquilezles.org/articles/distfunctions2d\n    vec2 p1 = a + h * (b - a) / d2min;\n    vec2 p2 = a + h * (b + a) / d2min;\n    vec2 p3 = a + h * (b - a) / d2min;\n    vec2 p4 = a + h * (b + a) / d2min;\n    vec2 p5 = a + h * (b - a) / d2min;\n    vec2 p6 = a + h * (b + a) / d2min;\n    vec2 p7 = a + h * (b - a) / d2min;\n    vec2 p8 = a + h * (b + a) / d2min;\n    vec2 p9 = a + h * (b - a) / d2min;\n    vec2 p10 = a + h * (b + a) / d2min;\n    vec2 p11 = a + h * (b - a) / d2min;\n    vec2 p12 = a + h * (b + a) / d2min;\n    vec2 p13 = a + h * (b - a) / d2min;\n    vec2 p14 = a + h * (b + a) / d2min;\n    vec2 p15 = a + h * (b - a) / d2min;\n    vec2 p16 = a + h * (b + a) / d2min;\n    vec2 p17 = a + h * (b - a) / d2min;\n    vec2 p18 = a + h * (b + a) / d2min;\n    vec2 p19 = a + h * (b - a) / d2min;\n    vec2 p20 = a + h * (b + a) / d2min;\n    vec2 p21 = a + h * (b - a) / d2min;\n    vec2 p22 = a + h * (b + a) / d2min;\n    vec2 p23 = a + h * (b - a) / d2min;\n    vec2 p24 = a + h", "\n    float sdf = 0.0;\n    int i = 0;\n    int nSeg = 0;\n    int nArc = 0;\n    int nLine = 0;\n    int nArcSeg = 0;\n    int nLineSeg = 0;\n    int nArcArc = 0;\n    int nArcArcSeg = 0;\n    int nLineArc = 0;\n    int nArcLine = 0;\n    int nArcArcLine = 0;\n    int nLineArcArc = 0;\n    int nArcLineArc = 0;\n    int nLineArcLineArc = 0;\n    int nArcArcLineArcSeg = 0;\n    int nLineArcLineArcSeg = 0;\n    int nArcLineArcLineArcSeg = 0;\n    int nLineArcLineArcLineArc = 0;\n    int nArcLineArcLineArcLineArc = 0;\n    int nArcLineArcLineArcLineArcLine = 0;\n    int nLineArcLineArcLineArcLineArcLine = 0;\n    int nArcLineArcLineArcLineArcLineArcLineArc = 0;\n    int nLineArcLineArcLineArcLineArcLineArcLineArcArc = 0;\n    int nArcLineArcLineArcLineArcLineArcLineArcLineArcArcLineArc = 0;\n    int nLineArcLineArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArc = 0;\n    int nArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcArcLineArc = 0;\n    int nLineArcLineArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArcLineArc", "\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p.size() );\n}\n\nA:\n\nYou are not using the return value of the function.\nfloat sdA( in vec2 p )\n{\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p.size() );\n}\n\nfloat sdA( in vec2 p )\n{\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p.size() );\n}\n\nA:\n\nYou are not using the return value of the function.\nfloat sdA( in vec2 p )\n{\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p.size() );\n}\n\nfloat sdA( in vec2 p )\n{\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p.size() );\n}\n\nA:\n\nYou are not using the return value of the function.\nfloat sdA( in vec2 p )\n{\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p.size() );\n}\n\nfloat sdA( in vec2 p )\n{\n    float sum = 0.0;\n    for( int i = 0; i < p.size(); i++ )\n    {\n        sum += p[i];\n    }\n    return sqrt( sum / p", "    \n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in vec2 p )\n{    \n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in vec3 p )\n{    \n    float s = 0.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in vec4 p )\n{    \n    float s = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in vec5 p )\n{    \n    float s = 0.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in vec6 p )\n{    \n    float s = 0.0;\n    for( int i = 0; i < 6; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in vec7 p )\n{    \n    float s = 0.0;\n    for( int i = 0; i < 7; i++ )\n    {\n        s += p[i] * p[i];\n    }\n    s = sqrt( s );\n    return s;\n}\n\nfloat sD( in", "\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = uv.xy;\n    vec2 y = uv.yx;\n    vec2 z = uv.xy;\n    vec2 a = uv.xy;\n    vec2 b = uv.yx;\n    vec2 c = uv.xy;\n    vec2 d = uv.yx;\n    vec2 e = uv.xy;\n    vec2 f = uv.yx;\n    vec2 g = uv.xy;\n    vec2 h = uv.yx;\n    vec2 i = uv.xy;\n    vec2 j = uv.yx;\n    vec2 k = uv.xy;\n    vec2 l = uv.yx;\n    vec2 m = uv.xy;\n    vec2 n = uv.yx;\n    vec2 o = uv.xy;\n    vec2 p = uv.yx;\n    vec2 q = uv.xy;\n    vec2 r = uv.yx;\n    vec2 s = uv.xy;\n    vec2 t = uv.yx;\n    vec2 u = uv.xy;\n    vec2 v = uv.yx;\n    vec2 w = uv.xy;\n    vec2 x = uv.xy;\n    vec2 y = uv.yx;\n    vec2 z = uv.xy;\n    vec2 a = uv.xy;\n    vec2 b = uv.yx;\n    vec2 c = uv.xy;\n    vec2 d = uv.yx;\n    vec2 e = uv.xy;\n    vec2 f = uv.yx;\n    vec2 g = uv.xy;\n    vec2 h = uv.yx;\n    vec2 i = uv.xy;\n    vec2 j = uv.yx;\n    vec2 k = uv.xy;\n    vec2 l = uv.yx;\n    vec2 m = uv.xy;\n    vec2 n = uv.yx;\n    vec2 o =", "#\n    // Compute the distance from p to the segment\n    vec2 distSeg = a - p;\n    vec2 distPt = p - b;\n    float distSegPt = distSeg.length();\n    float distPtSeg = distPt.length();\n    float distSegPt2 = distSegPt * distSegPt;\n    float distPtSeg2 = distPtSeg * distPtSeg;\n    float distPtSeg3 = distPtSeg2 * distPtSeg;\n    float distPtSeg4 = distPtSeg3 * distPtSeg;\n    float distPtSeg5 = distPtSeg4 * distPtSeg;\n    float distPtSeg6 = distPtSeg5 * distPtSeg;\n    float distPtSeg7 = distPtSeg6 * distPtSeg;\n    float distPtSeg8 = distPtSeg7 * distPtSeg;\n    float distPtSeg9 = distPtSeg8 * distPtSeg;\n    float distPtSeg10 = distPtSeg9 * distPtSeg;\n    float distPtSeg11 = distPtSeg10 * distPtSeg;\n    float distPtSeg12 = distPtSeg11 * distPtSeg;\n    float distPtSeg13 = distPtSeg12 * distPtSeg;\n    float distPtSeg14 = distPtSeg13 * distPtSeg;\n    float distPtSeg15 = distPtSeg14 * distPtSeg;\n    float distPtSeg16 = distPtSeg15 * distPtSeg;\n    float distPtSeg17 = distPtSeg16 * distPtSeg;\n    float distPtSeg18 = distPtSeg17 * distPtSeg;\n    float distPtSeg19 = distPtSeg18 * distPtSeg;\n    float distPtSeg20 = distPtSeg19 * distPtSeg;\n    float distPtSeg21 = distPtSeg20 * distPtSeg;\n    float distPtSeg22 = distPtSeg21 * distPtSeg;\n    float distPtSeg23 = distP", "\n    float d = p.x - a.x;\n    float e = p.y - a.y;\n    float f = b.x - a.x;\n    float g = b.y - a.y;\n    float h = d * d + e * e;\n    float i = f * f + g * g;\n    float j = 2 * f * d + 2 * g * e;\n    float k = d * d * (1 - (i / j));\n    float l = a.x + k * f;\n    float m = a.y + k * g;\n    float n = p.x - l;\n    float o = p.y - m;\n    float p = n * n + o * o;\n    float q = 2 * n * o;\n    float r = p * (1 - (q / h));\n    float s = m * (1 - (q / h));\n    float t = (r / s);\n    float u = (r / s);\n    float v = (r / s);\n    float w = (r / s);\n    float x = (r / s);\n    float y = (r / s);\n    float z = (r / s);\n    float aa = (r / s);\n    float bb = (r / s);\n    float cc = (r / s);\n    float dd = (r / s);\n    float ee = (r / s);\n    float ff = (r / s);\n    float gg = (r / s);\n    float hh = (r / s);\n    float ii = (r / s);\n    float jj = (r / s);\n    float kk = (r / s);\n    float ll = (r / s);\n    float mm = (r / s);\n    float nn = (r / s);\n    float oo = (r / s);\n    float pp = (r / s);\n    float qq = (r / s);\n    float rr = (r / s);\n    float ss = (r / s);\n    float tt = (r / s);\n    float uu = (r / s);\n    float vv", "\n    // find closest point on box\n    vec2 p0 = b.min;\n    vec2 p1 = b.max;\n    vec2 p2 = p0 + (p1 - p0) * (p - p0) / (p1 - p0);\n    vec2 p3 = p1 - (p1 - p0) * (p - p0) / (p1 - p0);\n\n    // find closest point on rounded box\n    vec2 p4 = p0 + (p1 - p0) * (p - p0) / (p1 - p0);\n    vec2 p5 = p1 - (p1 - p0) * (p - p0) / (p1 - p0);\n    vec2 p6 = p4 + (p5 - p4) * (r - p4.y) / (p5.y - p4.y);\n    vec2 p7 = p5 - (p5 - p4) * (r - p4.y) / (p5.y - p4.y);\n\n    // return closest point\n    return p6;\n}\n\nA:\n\nI think you can use the following code:\n// find closest point on box\nvec2 p0 = b.min;\nvec2 p1 = b.max;\nvec2 p2 = p0 + (p1 - p0) * (p - p0) / (p1 - p0);\nvec2 p3 = p1 - (p1 - p0) * (p - p0) / (p1 - p0);\n\n// find closest point on rounded box\nvec2 p4 = p0 + (p1 - p0) * (p - p0) / (p1 - p0);\nvec2 p5 = p1 - (p1 - p0) * (p - p0) / (p1 - p0);\nvec2 p6 = p4 + (p5 - p4) * (r - p4.y) / (p5.y - p4.y);\nvec2 p7 = p5 - (p5 - p4) * (r - p4.y) / (p5.y - p4.y);\n\n// return closest point", "    \n    float dx = p.x - b.x;\n    float dy = p.y - b.y;\n    float d = sqrt(dx*dx + dy*dy);\n    float d2 = d*d;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n    float r35 = r34*r;\n    float r36 = r35*r;\n    float r37 = r36*r;\n    float r38 = r37*r;\n    float r39 = r38*r;\n    float r40 = r39*r;\n    float r41 = r40*r;\n    float r42 = r41*r;\n    float r43 = r42*", "    \n    float dx = p.x - b.x;\n    float dy = p.y - b.y;\n    return sqrt(dx*dx + dy*dy);\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    float dx = b.x - a.x;\n    float dy = b.y - a.y;\n    float d = abs(dx*p.x + dy*p.y - (dx*a.x + dy*a.y));\n    return d / sqrt(dx*dx + dy*dy);\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = 0.0;\n    for( int i = 0; i < a.size(); ++i )\n    {\n        float x = a[i].x;\n        float y = a[i].y;\n        float dx = b[i].x - x;\n        float dy = b[i].y - y;\n        float d1 = abs(dx*p.x + dy*p.y - (dx*x + dy*y));\n        if( d1 < d )\n        {\n            d = d1;\n        }\n    }\n    return d;\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = 0.0;\n    for( int i = 0; i < a.size(); ++i )\n    {\n        float x = a[i].x;\n        float y = a[i].y;\n        float dx = b[i].x - x;\n        float dy = b[i].y - y;\n        float d1 = abs(dx*p.x + dy*p.y - (dx*x + dy*y));\n        if( d1 < d )\n        {\n            d = d1;\n        }\n    }\n    return d;\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2 a, in vec2 b", "#define PI 3.1415926535897932384626433832795#}\nfloat hash13(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash14(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash15(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash16(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash17(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash18(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash19(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash20(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash21(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash22(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash23(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash24(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash25(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash26(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash27(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash28(vec2 p){#define PI 3.1415926535897932384626433832795#}\nfloat hash29(vec2 p){#define PI 3.1415926535897932384626433832795#", "\n    vec2 random_vec = vec2(rand() / (RAND_MAX + 1.0), rand() / (RAND_MAX + 1.0));\n    return x + random_vec;\n}\n\nA:\n\nYou can use the random() function from the <random> header.\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<double> dist(0.0, 1.0);\n\ndouble random_value = dist(gen);\n\nA:\n\nYou can use the random() function from the <random> header.\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<double> dist(0.0, 1.0);\n\ndouble random_value = dist(gen);\n\nA:\n\nYou can use the random() function from the <random> header.\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<double> dist(0.0, 1.0);\n\ndouble random_value = dist(gen);\n\nA:\n\nYou can use the random() function from the <random> header.\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<double> dist(0.0, 1.0);\n\ndouble random_value = dist(gen);\n\nA:\n\nYou can use the random() function from the <random> header.\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<double> dist(0.0, 1.0);\n\ndouble random_value = dist(gen);\n\nA:\n\nYou can use the random() function from the <random> header.\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<double> dist(0.0", "\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y));\n}\n\n// From iq and x\nvec2 random3(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y));\n}\n\n// From iq and y\nvec2 random4(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y));\n}\n\n// From iq and x and y\nvec2 random5(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y));\n}\n\n// From iq and x and y and z\nvec2 random6(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y),rand()%(st.z-st.z));\n}\n\n// From iq and x and y and z and w\nvec2 random7(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y),rand()%(st.z-st.z),rand()%(st.w-st.w));\n}\n\n// From iq and x and y and z and w and v\nvec2 random8(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y),rand()%(st.z-st.z),rand()%(st.w-st.w),rand()%(st.v-st.v));\n}\n\n// From iq and x and y and z and w and v and u\nvec2 random9(vec2 st,int iq){\n    return vec2(rand()%(st.x-st.x),rand()%(st.y-st.y),rand()", "\n    float x2 = x.x*x.x;\n    float y2 = x.y*x.y;\n    float xy = x.x*x.y;\n    float xy2 = xy*xy;\n    float xy3 = xy*xy2;\n    float xy4 = xy*xy3;\n    float xy5 = xy*xy4;\n    float xy6 = xy*xy5;\n    float xy7 = xy*xy6;\n    float xy8 = xy*xy7;\n    float xy9 = xy*xy8;\n    float xy10 = xy*xy9;\n    float xy11 = xy*xy10;\n    float xy12 = xy*xy11;\n    float xy13 = xy*xy12;\n    float xy14 = xy*xy13;\n    float xy15 = xy*xy14;\n    float xy16 = xy*xy15;\n    float xy17 = xy*xy16;\n    float xy18 = xy*xy17;\n    float xy19 = xy*xy18;\n    float xy20 = xy*xy19;\n    float xy21 = xy*xy20;\n    float xy22 = xy*xy21;\n    float xy23 = xy*xy22;\n    float xy24 = xy*xy23;\n    float xy25 = xy*xy24;\n    float xy26 = xy*xy25;\n    float xy27 = xy*xy26;\n    float xy28 = xy*xy27;\n    float xy29 = xy*xy28;\n    float xy30 = xy*xy29;\n    float xy31 = xy*xy30;\n    float xy32 = xy*xy31;\n    float xy33 = xy*xy32;\n    float xy34 = xy*xy33;\n    float xy35 = xy*xy34;\n    float xy36 = xy*xy35;\n    float xy37 = xy*xy36;\n    float", "\n    float sigma = 0.1;\n    float t = x.x + x.y;\n    float tau = 0.1;\n    float r = (1.0 - t / tau) * (1.0 - t / tau) * (1.0 - t / tau);\n    return r * sigma;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec2 x)\n{\n    vec2 y = x;\n    for (int i = 0; i < 100; ++i)\n    {\n        y += fbm(x);\n    }\n    return y;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec2 x)\n{\n    vec2 y = x;\n    for (int i = 0; i < 100; ++i)\n    {\n        y += fbm(x);\n    }\n    return y;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec2 x)\n{\n    vec2 y = x;\n    for (int i = 0; i < 100; ++i)\n    {\n        y += fbm(x);\n    }\n    return y;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec2 x)\n{\n    vec2 y = x;\n    for (int i = 0; i < 100; ++i)\n    {\n        y += fbm(x);\n    }\n    return y;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec2 x)\n{\n    vec2 y = x;\n    for (int i = 0; i < 100; ++i)\n    {\n        y += fbm(x);\n    }\n    return y;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec2 x)\n{\n    vec2 y = x;\n    for (int i = 0; i < 100; ++i)\n    {\n        y += fbm(x);\n    }\n    return y;\n}\n\n// Generate a single-octave noise function\nvec2 noise(vec", "#ifdef _MSC_VER\n    return (x.x + x.y) / 2.0f;\n#else\n    return (x.x + x.y) / 2.0f;\n#endif\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{#ifdef _MSC_VER\n    return (x.x + x.y) / 2.0f;\n#else\n    return (x.x + x.y) / 2.0f;\n#endif\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{#ifdef _MSC_VER\n    return (x.x + x.y) / 2.0f;\n#else\n    return (x.x + x.y) / 2.0f;\n#endif\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{#ifdef _MSC_VER\n    return (x.x + x.y) / 2.0f;\n#else\n    return (x.x + x.y) / 2.0f;\n#endif\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{#ifdef _MSC_VER\n    return (x.x + x.y) / 2.0f;\n#else\n    return (x.x + x.y) / 2.0f;\n#endif\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{#ifdef _MSC_VER\n    return (x.x + x.y) / 2.0f;\n#else\n    return (x.x + x.y) / 2.0f;\n#endif\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2", "#ifdef _CUBEMAP_USE_CUBEMAP_C\n    return _cubemap_areaElement(x, y);\n#else\n    return (x*y);\n#endif\n}\n\nfloat texelSolidAngle(float x, float y)\n{#ifdef _CUBEMAP_USE_CUBEMAP_C\n    return _cubemap_texelSolidAngle(x, y);\n#else\n    return (x*y);\n#endif\n}\n\n// This is the same as the one in the cubemapgen source code.\n// It is used to compute the area of a cubemap.\nfloat cubemapArea(float x, float y)\n{#ifdef _CUBEMAP_USE_CUBEMAP_C\n    return _cubemap_cubemapArea(x, y);\n#else\n    return (x*y);\n#endif\n}\n\n// This is the same as the one in the cubemapgen source code.\n// It is used to compute the solid angle of a cubemap.\nfloat cubemapSolidAngle(float x, float y)\n{#ifdef _CUBEMAP_USE_CUBEMAP_C\n    return _cubemap_cubemapSolidAngle(x, y);\n#else\n    return (x*y);\n#endif\n}\n\n// This is the same as the one in the cubemapgen source code.\n// It is used to compute the area of a cubemap.\nfloat cubemapArea(float x, float y)\n{#ifdef _CUBEMAP_USE_CUBEMAP_C\n    return _cubemap_cubemapArea(x, y);\n#else\n    return (x*y);\n#endif\n}\n\n// This is the same as the one in the cubemapgen source code.\n// It is used to compute the solid angle of a cubemap.\nfloat cubemapSolidAngle(float x, float y)\n{#ifdef _CUBEMAP_USE_CUBEMAP_C\n    return _cubemap_cubemapSolidAngle(", "\n    vec3 p1 = p3 - vec3(0.5, 0.5, 0.5);\n    vec3 p2 = p3 - vec3(0.5, -0.5, 0.5);\n    vec3 p3 = p3 - vec3(-0.5, 0.5, 0.5);\n    vec3 p4 = p3 - vec3(-0.5, -0.5, 0.5);\n    vec3 p5 = p3 - vec3(0.5, -0.5, 0.5);\n    vec3 p6 = p3 - vec3(0.5, 0.5, -0.5);\n    vec3 p7 = p3 - vec3(-0.5, 0.5, -0.5);\n    vec3 p8 = p3 - vec3(-0.5, -0.5, -0.5);\n    vec3 p9 = p3 - vec3(0.5, -0.5, -0.5);\n    vec3 p10 = p3 - vec3(0.5, 0.5, 0.5);\n    vec3 p11 = p3 - vec3(-0.5, 0.5, 0.5);\n    vec3 p12 = p3 - vec3(-0.5, -0.5, 0.5);\n    vec3 p13 = p3 - vec3(0.5, -0.5, 0.5);\n    vec3 p14 = p3 - vec3(0.5, 0.5, -0.5);\n    vec3 p15 = p3 - vec3(-0.5, 0.5, -0.5);\n    vec3 p16 = p3 - vec3(-0.5, -0.5, -0.5);\n    vec3 p17 = p3 - vec3(0.5, -0.5, -0.5);\n    vec3 p18 = p3 - vec3(0.5, 0.5, -0.5);\n    vec3 p19 = p3 - vec3(-0.5, 0.5, -0.5);\n    vec3 p20 = p3 - vec3(-0.5, -", "Theta = 0.5f;\n    vec3 p1 = p + vec3(0.5f, 0.5f, 0.5f);\n    vec3 p2 = p + vec3(0.5f, -0.5f, 0.5f);\n    vec3 p3 = p + vec3(-0.5f, 0.5f, 0.5f);\n    vec3 p4 = p + vec3(-0.5f, -0.5f, 0.5f);\n    vec3 p5 = p + vec3(0.5f, 0.5f, -0.5f);\n    vec3 p6 = p + vec3(0.5f, -0.5f, -0.5f);\n    vec3 p7 = p + vec3(-0.5f, 0.5f, -0.5f);\n    vec3 p8 = p + vec3(-0.5f, -0.5f, -0.5f);\n    vec3 p9 = p + vec3(0.5f, 0.5f, 0.5f);\n    vec3 p10 = p + vec3(0.5f, -0.5f, 0.5f);\n    vec3 p11 = p + vec3(-0.5f, 0.5f, 0.5f);\n    vec3 p12 = p + vec3(-0.5f, -0.5f, 0.5f);\n    vec3 p13 = p + vec3(0.5f, 0.5f, -0.5f);\n    vec3 p14 = p + vec3(0.5f, -0.5f, -0.5f);\n    vec3 p15 = p + vec3(-0.5f, 0.5f, -0.5f);\n    vec3 p16 = p + vec3(-0.5f, -0.5f, -0.5f);\n    vec3 p17 = p + vec3(0.5f, 0.5f, 0.5f);\n    vec3 p18 = p + vec3(0.5f, -0.5f, 0.5f);\n", "\n    vec2 h = vec2(0.0,0.0);\n    h += x.x*x.x;\n    h += x.y*x.y;\n    h += x.x*x.y;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h += x.x*x.x;\n    h", "\n    float x = p.x - a.x;\n    float y = p.y - a.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x", "    \n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float z = p.z - b.z;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float xy = x * y;\n    float xz = x * z;\n    float yz = y * z;\n    float xy2 = xy * xy;\n    float xyz = xz * yz;\n    float xyz2 = xyz * xyz;\n    float xyz3 = xyz2 * z;\n    float xyz4 = xyz2 * xyz;\n    float xyz5 = xyz2 * xy;\n    float xyz6 = xyz2 * xz;\n    float xyz7 = xyz2 * y;\n    float xyz8 = xyz2 * z;\n    float xyz9 = xyz2 * xy;\n    float xyz10 = xyz2 * xz;\n    float xyz11 = xyz2 * y;\n    float xyz12 = xyz2 * z;\n    float xyz13 = xyz2 * xy;\n    float xyz14 = xyz2 * xz;\n    float xyz15 = xyz2 * y;\n    float xyz16 = xyz2 * z;\n    float xyz17 = xyz2 * xy;\n    float xyz18 = xyz2 * xz;\n    float xyz19 = xyz2 * y;\n    float xyz20 = xyz2 * z;\n    float xyz21 = xyz2 * xy;\n    float xyz22 = xyz2 * xz;\n    float xyz23 = xyz2 * y;\n    float xyz24 = xyz2 * z;\n    float xyz25 = xyz2 * xy;\n    float xyz26 = xyz2 * xz;\n    float xyz27 = xyz2 * y;\n    float xyz28 = xyz2 * z;\n    float xyz29 = xyz2 * xy;\n    float xyz30 = xyz", "\n    vec3 u, v;\n    float a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u1, v1, w, x, y, z;\n    float a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u2, v2, w2, x2, y2, z2;\n    float a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2, s2, t2, u3, v3, w3, x3, y3, z3;\n    float a3, b3, c3, d3, e3, f3, g3, h3, i3, j3, k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u4, v4, w4, x4, y4, z4;\n    float a4, b4, c4, d4, e4, f4, g4, h4, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4, u5, v5, w5, x5, y5, z5;\n    float a5, b5, c5, d5, e5, f5, g5, h5, i5, j5, k5, l5, m5, n5, o5, p5, q5, r5, s5, t5, u6, v6, w6, x6, y6, z6;\n    float a6, b6, c6, d6, e6, f6, g6, h6, i6, j6, k6, l6, m6,", "QVector2 p1 = p - vec2(0.5, 0.5);\n    float h = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        h += p1[i] * vec2(1, -1)[i];\n    }\n    return h;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash13(vec2 p)\n{QVector2 p1 = p - vec2(0.5, 0.5);\n    float h = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        h += p1[i] * vec2(1, -1)[i];\n    }\n    return h;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash14(vec2 p)\n{QVector2 p1 = p - vec2(0.5, 0.5);\n    float h = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        h += p1[i] * vec2(1, -1)[i];\n    }\n    return h;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash15(vec2 p)\n{QVector2 p1 = p - vec2(0.5, 0.5);\n    float h = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        h += p1[i] * vec2(1, -1)[i];\n    }\n    return h;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash16(vec2 p)\n{QVector2 p1 = p - vec2(0.5, 0.5);\n    float h = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        h += p1[i] * vec2(1, -1)[i];\n    }\n    return h;\n}\n\n// https://www.shadertoy.com/view/4dj", "\n    float a = acs.x;\n    float b = acs.y;\n    float c = acs.x*a + acs.y*b;\n    float d = acs.x*a*a + acs.y*b*b;\n    float e = acs.x*a*a*a + acs.y*b*b*b;\n    float f = acs.x*a*a*a*a + acs.y*b*b*b*b;\n    float g = acs.x*a*a*a*a*a + acs.y*b*b*b*b*b;\n    float h = acs.x*a*a*a*a*a*a + acs.y*b*b*b*b*b*b*b;\n    float i = acs.x*a*a*a*a*a*a*a*a;\n    float j = acs.x*a*a*a*a*a*a*a*a*a;\n    float k = acs.x*a*a*a*a*a*a*a*a*a*a;\n    float l = acs.x*a*a*a*a*a*a*a*a*a*a*a;\n    float mn = m*m;\n    float n = mn*m;\n    float pn = p*p;\n    float q = pn*p;\n    float rn = r*r;\n    float s = pn*r;\n    float t = pn*rn;\n    float u = pn*s;\n    float v = pn*t;\n    float w = pn*u;\n    float x = pn*v;\n    float y = pn*w;\n    float z = pn*x;\n    float a1 = a*a;\n    float b1 = b*b;\n    float c1 = c*c;\n    float d1 = d*d;\n    float e1 = e*e;\n    float f1 = f*f;\n    float g1 = g*g;", "#\n    vec3 n = (p[0]*p[1]*p[2] + p[1]*p[2]*p[3] + p[2]*p[3]*p[0] + p[3]*p[0]*p[1] - p[0]*p[3]*p[2] - p[1]*p[0]*p[2] - p[2]*p[1]*p[3]) / (2.0*(p[0]*p[0] + p[1]*p[1] + p[2]*p[2] + p[3]*p[3]));\n    vec3 n2 = (p[0]*p[1]*p[2] + p[1]*p[2]*p[3] + p[2]*p[3]*p[0] + p[3]*p[0]*p[1] - p[0]*p[3]*p[2] - p[1]*p[0]*p[2] - p[2]*p[1]*p[3]) / (2.0*(p[0]*p[0] + p[1]*p[1] + p[2]*p[2] + p[3]*p[3]));\n    vec3 n3 = (p[0]*p[1]*p[2] + p[1]*p[2]*p[3] + p[2]*p[3]*p[0] + p[3]*p[0]*p[1] - p[0]*p[3]*p[2] - p[1]*p[0]*p[2] - p[2]*p[1]*p[3]) / (2.0*(p[0]*p[0] + p[1]*p[1] + p[2]*p[2] + p[3]*p[3]));\n    return normalize(vec3(n,n2,n3));\n}\n\n// https://iquilezles.org/articles/normals", "#ifdef DEBUG\n    float t = t0;\n    float t_min = t0;\n    float t_max = t1;\n    float t_min_t = t0;\n    float t_max_t = t1;\n    float t_min_t_2 = t0;\n    float t_max_t_2 = t1;\n    float t_min_t_3 = t0;\n    float t_max_t_3 = t1;\n    float t_min_t_4 = t0;\n    float t_max_t_4 = t1;\n    float t_min_t_5 = t0;\n    float t_max_t_5 = t1;\n    float t_min_t_6 = t0;\n    float t_max_t_6 = t1;\n    float t_min_t_7 = t0;\n    float t_max_t_7 = t1;\n    float t_min_t_8 = t0;\n    float t_max_t_8 = t1;\n    float t_min_t_9 = t0;\n    float t_max_t_9 = t1;\n    float t_min_t_10 = t0;\n    float t_max_t_10 = t1;\n    float t_min_t_11 = t0;\n    float t_max_t_11 = t1;\n    float t_min_t_12 = t0;\n    float t_max_t_12 = t1;\n    float t_min_t_13 = t0;\n    float t_max_t_13 = t1;\n    float t_min_t_14 = t0;\n    float t_max_t_14 = t1;\n    float t_min_t_15 = t0;\n    float t_max_t_15 = t1;\n    float t_min_t_16 = t0;\n    float t_max_t_16 = t1;\n    float t_min_t_17 = t0;\n    float t_max_t_17 = t1;\n    float t_min_t", "\n    float ao = 0.0f;\n    float ao2 = 0.0f;\n    float ao3 = 0.0f;\n    float ao4 = 0.0f;\n    float ao5 = 0.0f;\n    float ao6 = 0.0f;\n    float ao7 = 0.0f;\n    float ao8 = 0.0f;\n    float ao9 = 0.0f;\n    float ao10 = 0.0f;\n    float ao11 = 0.0f;\n    float ao12 = 0.0f;\n    float ao13 = 0.0f;\n    float ao14 = 0.0f;\n    float ao15 = 0.0f;\n    float ao16 = 0.0f;\n    float ao17 = 0.0f;\n    float ao18 = 0.0f;\n    float ao19 = 0.0f;\n    float ao20 = 0.0f;\n    float ao21 = 0.0f;\n    float ao22 = 0.0f;\n    float ao23 = 0.0f;\n    float ao24 = 0.0f;\n    float ao25 = 0.0f;\n    float ao26 = 0.0f;\n    float ao27 = 0.0f;\n    float ao28 = 0.0f;\n    float ao29 = 0.0f;\n    float ao30 = 0.0f;\n    float ao31 = 0.0f;\n    float ao32 = 0.0f;\n    float ao33 = 0.0f;\n    float ao34 = 0.0f;\n    float ao35 = 0.0f;\n    float ao36 = 0.0f;\n    float ao37 = 0.0f;\n    float ao38 = 0.0f;\n    float ao39 = 0.0f;\n    float ao40 = 0.0f;\n    float ao41 = 0.0f;\n    float ao42 = 0.0f;\n    float ao43 = 0.", "\n    vec3 axisNormal = normalize(axis);\n    vec3 rotationMatrix = vec3(0, 0, 0);\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    rotationMatrix[0] = cosAngle + axisNormal[0] * axisNormal[0] * (1.0 - cosAngle);\n    rotationMatrix[1] = axisNormal[0] * axisNormal[1] * (1.0 - cosAngle) - axisNormal[2] * sinAngle;\n    rotationMatrix[2] = axisNormal[0] * axisNormal[2] * (1.0 - cosAngle) + axisNormal[1] * sinAngle;\n    rotationMatrix[3] = axisNormal[1] * axisNormal[1] * (1.0 - cosAngle) + axisNormal[2] * sinAngle;\n    rotationMatrix[4] = axisNormal[1] * axisNormal[2] * (1.0 - cosAngle) - axisNormal[0] * sinAngle;\n    rotationMatrix[5] = axisNormal[2] * axisNormal[2] * (1.0 - cosAngle) + axisNormal[0] * sinAngle;\n    return rotationMatrix;\n}\n\n// Helper function generating a translation matrix\nmat3 createTranslationMatrix(vec3 translation) {\n    vec3 translationMatrix = vec3(0, 0, 0);\n    translationMatrix[0] = 1.0;\n    translationMatrix[1] = 0.0;\n    translationMatrix[2] = 0.0;\n    translationMatrix[3] = translation[0];\n    translationMatrix[4] = translation[1];\n    translationMatrix[5] = translation[2];\n    return translationMatrix;\n}\n\n// Helper function generating a scaling matrix\nmat3 createScalingMatrix(vec3 scaling) {\n    vec3 scalingMatrix = vec3(0, 0, 0);\n    scalingMatrix[0] = scaling[0];\n    scalingMatrix[1] = scaling[1];\n    scalingMatrix[2] = scaling[2];\n    scalingMatrix[3] = 1.0;\n    scalingMatrix[", "\n    vec2 uv = fragCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the camera to the mouse\nvec3 getRay(vec2 mouseCoord) {\n    vec2 uv = mouseCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the camera to the light\nvec3 getRay(vec2 lightCoord) {\n    vec2 uv = lightCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the light to the camera\nvec3 getRay(vec2 cameraCoord) {\n    vec2 uv = cameraCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the light to the mouse\nvec3 getRay(vec2 mouseCoord) {\n    vec2 uv = mouseCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the mouse to the light\nvec3 getRay(vec2 lightCoord) {\n    vec2 uv = lightCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the mouse to the camera\nvec3 getRay(vec2 cameraCoord) {\n    vec2 uv = cameraCoord - UV;\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    return ray;\n}\n\n// Helper function that generates a ray from the camera to the light\nvec3 getRay(vec2 lightCoord) {\n    vec2 uv = lightCoord - UV;\n    ", "\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co){\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float sigma){\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float sigma, float x, float y){\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float sigma, float x, float y, float a, float b){\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float sigma, float x, float y, float a, float b, float c, float d){\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float sigma, float x, float y, float a, float b, float c, float d, float e){\n    float x = rand() / (float)RAND_MAX;\n    float y = rand() / (float)RAND_MAX;\n    return x*x + y*y;\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float", "\n    float r = rand() / (float)RAND_MAX;\n    vec3 r3d = vec3(r,r,r);\n    return p + r3d;\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    float r = rand() / (float)RAND_MAX;\n    vec4 r4d = vec4(r,r,r,r);\n    return p + r4d;\n}\n\n// Hash for 5d vectors\nfloat rand5d(vec5 p){\n    float r = rand() / (float)RAND_MAX;\n    vec5 r5d = vec5(r,r,r,r,r);\n    return p + r5d;\n}\n\n// Hash for 6d vectors\nfloat rand6d(vec6 p){\n    float r = rand() / (float)RAND_MAX;\n    vec6 r6d = vec6(r,r,r,r,r,r);\n    return p + r6d;\n}\n\n// Hash for 7d vectors\nfloat rand7d(vec7 p){\n    float r = rand() / (float)RAND_MAX;\n    vec7 r7d = vec7(r,r,r,r,r,r,r);\n    return p + r7d;\n}\n\n// Hash for 8d vectors\nfloat rand8d(vec8 p){\n    float r = rand() / (float)RAND_MAX;\n    vec8 r8d = vec8(r,r,r,r,r,r,r,r);\n    return p + r8d;\n}\n\n// Hash for 9d vectors\nfloat rand9d(vec9 p){\n    float r = rand() / (float)RAND_MAX;\n    vec9 r9d = vec9(r,r,r,r,r,r,r,r,r);\n    return p + r9d;\n}\n\n// Hash for 10d vectors\nfloat rand10d(vec10 p){\n    float r = rand() / (float)RAND_MAX;\n    vec10 r10d = vec10(r,r,r,r,r", "\n    vec3 u = normalize(x);\n    vec3 v = normalize(x + vec3(0.5, 0.5, 0.5));\n    vec3 w = normalize(x + vec3(0.5, -0.5, 0.5));\n    vec3 xyz = u + v + w;\n    return (xyz.x + xyz.y + xyz.z) * 0.5;\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 u = normalize(x);\n    vec3 v = normalize(x + vec3(0.5, 0.5, 0.5));\n    vec3 w = normalize(x + vec3(0.5, -0.5, 0.5));\n    vec3 xyz = u + v + w;\n    return (xyz.x + xyz.y + xyz.z) * 0.5;\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 u = normalize(x);\n    vec3 v = normalize(x + vec3(0.5, 0.5, 0.5));\n    vec3 w = normalize(x + vec3(0.5, -0.5, 0.5));\n    vec3 xyz = u + v + w;\n    return (xyz.x + xyz.y + xyz.z) * 0.5;\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 u = normalize(x);\n    vec3 v = normalize(x + vec3(0.5, 0.5, 0.5));\n    vec3 w = normalize(x + vec3(0.5, -0.5, 0.5));\n    vec3 xyz = u + v + w;\n    return (xyz.x + xyz.y + xyz.z) * 0.5;\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 u = normalize(x);\n    vec3 v = normalize(x + vec3(0.5, 0.5", "\n    vec3 u = p - vec3(0.5, 0.5, 0.5);\n    vec3 v = u.xyz * 0.5;\n    vec3 w = u.xyz * 0.5;\n    vec3 x = v.xyz * 0.5;\n    vec3 y = w.xyz * 0.5;\n    vec3 z = x.xyz * 0.5;\n    vec3 a = x.xyz * 0.5;\n    vec3 b = y.xyz * 0.5;\n    vec3 c = z.xyz * 0.5;\n    vec3 d = a.xyz * 0.5;\n    vec3 e = b.xyz * 0.5;\n    vec3 f = c.xyz * 0.5;\n    vec3 g = d.xyz * 0.5;\n    vec3 h = e.xyz * 0.5;\n    vec3 i = f.xyz * 0.5;\n    vec3 j = g.xyz * 0.5;\n    vec3 k = h.xyz * 0.5;\n    vec3 l = i.xyz * 0.5;\n    vec3 m = j.xyz * 0.5;\n    vec3 n = k.xyz * 0.5;\n    vec3 o = l.xyz * 0.5;\n    vec3 p = m.xyz * 0.5;\n    vec3 q = n.xyz * 0.5;\n    vec3 r = o.xyz * 0.5;\n    vec3 s = p.xyz * 0.5;\n    vec3 t = q.xyz * 0.5;\n    vec3 u = r.xyz * 0.5;\n    vec3 v = s.xyz * 0.5;\n    vec3 w = t.xyz * 0.5;\n    vec3 x = u.xyz * 0.5;\n    vec3 y = v.xyz * 0.5;\n    vec3 z = w.xyz * 0.5;\n    vec3 a = x.xyz * 0.5;\n    vec3 b = y.xy", "#include \"fbm.h\"\n    vec3 p0 = p;\n    vec3 p1 = p + vec3(0.5, 0.5, 0.5);\n    vec3 p2 = p + vec3(0.5, -0.5, 0.5);\n    vec3 p3 = p + vec3(-0.5, 0.5, 0.5);\n    vec3 p4 = p + vec3(-0.5, -0.5, 0.5);\n    vec3 p5 = p + vec3(0.5, -0.5, -0.5);\n    vec3 p6 = p + vec3(0.5, 0.5, -0.5);\n    vec3 p7 = p + vec3(-0.5, 0.5, -0.5);\n    vec3 p8 = p + vec3(-0.5, -0.5, -0.5);\n    vec3 p9 = p + vec3(0.5, -0.5, -0.5);\n    vec3 p10 = p + vec3(0.5, 0.5, -0.5);\n    vec3 p11 = p + vec3(-0.5, 0.5, -0.5);\n    vec3 p12 = p + vec3(-0.5, -0.5, -0.5);\n    vec3 p13 = p + vec3(0.5, -0.5, -0.5);\n    vec3 p14 = p + vec3(0.5, 0.5, -0.5);\n    vec3 p15 = p + vec3(-0.5, 0.5, -0.5);\n    vec3 p16 = p + vec3(-0.5, -0.5, -0.5);\n    vec3 p17 = p + vec3(0.5, -0.5, -0.5);\n    vec3 p18 = p + vec3(0.5, 0.5, -0.5);\n    vec3 p19 = p + vec3(-0.5, 0.5, -0.5);\n    vec3 p20 = p + vec3(-0.5", "#ifdef DEBUG}\n    vec3 pos3D = vec3(pos.x, pos.y, pos.z);\n    vec3 pos2D = vec2(pos.x, pos.y);\n    vec3 pos1D = vec1(pos.x, pos.y, pos.z);\n    vec3 pos0D = vec0(pos.x, pos.y, pos.z);\n    vec3 pos1D_1 = vec1(pos.x, pos.y, pos.z+1);\n    vec3 pos1D_2 = vec1(pos.x, pos.y, pos.z-1);\n    vec3 pos2D_1 = vec2(pos.x+1, pos.y);\n    vec3 pos2D_2 = vec2(pos.x-1, pos.y);\n    vec3 pos3D_1 = vec3(pos.x+1, pos.y, pos.z+1);\n    vec3 pos3D_2 = vec3(pos.x+1, pos.y, pos.z-1);\n    vec3 pos3D_3 = vec3(pos.x-1, pos.y, pos.z+1);\n    vec3 pos3D_4 = vec3(pos.x-1, pos.y, pos.z-1);\n    vec3 pos3D_5 = vec3(pos.x, pos.y+1, pos.z+1);\n    vec3 pos3D_6 = vec3(pos.x, pos.y+1, pos.z-1);\n    vec3 pos3D_7 = vec3(pos.x, pos.y-1, pos.z+1);\n    vec3 pos3D_8 = vec3(pos.x, pos.y-1, pos.z-1);\n    vec3 pos3D_9 = vec3(pos.x+1, pos.y+1, pos.z+1);\n    vec3 pos3D_10 = vec3(pos.x+1, pos.y+1, pos.z-1);\n    vec3 pos3D_11 = vec3(pos.x+1, pos.y-1,", "\n    vec3 pos = point;\n    vec3 dir = vec3(0.0, 1.0, 0.0);\n    vec3 dir2 = vec3(0.0, 1.0, 0.0);\n    vec3 dir3 = vec3(0.0, 1.0, 0.0);\n    vec3 dir4 = vec3(0.0, 1.0, 0.0);\n    vec3 dir5 = vec3(0.0, 1.0, 0.0);\n    vec3 dir6 = vec3(0.0, 1.0, 0.0);\n    vec3 dir7 = vec3(0.0, 1.0, 0.0);\n    vec3 dir8 = vec3(0.0, 1.0, 0.0);\n    vec3 dir9 = vec3(0.0, 1.0, 0.0);\n    vec3 dir10 = vec3(0.0, 1.0, 0.0);\n    vec3 dir11 = vec3(0.0, 1.0, 0.0);\n    vec3 dir12 = vec3(0.0, 1.0, 0.0);\n    vec3 dir13 = vec3(0.0, 1.0, 0.0);\n    vec3 dir14 = vec3(0.0, 1.0, 0.0);\n    vec3 dir15 = vec3(0.0, 1.0, 0.0);\n    vec3 dir16 = vec3(0.0, 1.0, 0.0);\n    vec3 dir17 = vec3(0.0, 1.0, 0.0);\n    vec3 dir18 = vec3(0.0, 1.0, 0.0);\n    vec3 dir19 = vec3(0.0, 1.0, 0.0);\n    vec3 dir20 = vec3(0.0, 1.0, 0.0);\n    vec3 dir21 = vec3(0.0, 1.0, 0.0);\n    vec3 dir22 = vec3(0.0, 1.0, 0.0);\n    vec3 dir23 = vec3(0.0, 1.0, 0.0", "\n    vec3 ray = pointEnd - pointStart;\n    vec3 normal = normalize(ray);\n    vec3 direction = normalize(ray * dist);\n    vec3 fog = fogLight(direction, random);\n    vec3 color = alphaBlend(background, fog, 0.5);\n    return color;\n}\n\n// This is the raymarch algorithm, it's a bit more complicated than it looks\nvec3 raymarch(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec3 ray = pointEnd - pointStart;\n    vec3 normal = normalize(ray);\n    vec3 direction = normalize(ray * dist);\n    vec3 fog = fogLight(direction, random);\n    vec3 color = alphaBlend(background, fog, 0.5);\n    return color;\n}\n\n// This is the fog light algorithm, it's a bit more complicated than it looks\nvec3 fogLight(vec3 direction, float random){\n    vec3 fog = vec3(0.0, 0.0, 0.0);\n    vec3 light = vec3(0.0, 0.0, 1.0);\n    vec3 normal = normalize(direction);\n    vec3 lightDir = normalize(light * 0.5);\n    vec3 lightDir2 = normalize(light * 0.5);\n    vec3 lightDir3 = normalize(light * 0.5);\n    vec3 lightDir4 = normalize(light * 0.5);\n    vec3 lightDir5 = normalize(light * 0.5);\n    vec3 lightDir6 = normalize(light * 0.5);\n    vec3 lightDir7 = normalize(light * 0.5);\n    vec3 lightDir8 = normalize(light * 0.5);\n    vec3 lightDir9 = normalize(light * 0.5);\n    vec3 lightDir10 = normalize(light * 0.5);\n    vec3 lightDir11 = normalize(light * 0.5);\n    vec3 lightDir12 = normalize(light * 0.5);\n    vec3 lightDir13 = normalize(light * 0.5);\n    vec3 lightDir14 = normalize(light", "\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    vec3 h = vec3(0.0, 0.0, 0.0);\n    vec3 i = vec3(0.0, 0.0, 0.0);\n    vec3 j = vec3(0.0, 0.0, 0.0);\n    vec3 k = vec3(0.0, 0.0, 0.0);\n    vec3 l = vec3(0.0, 0.0, 0.0);\n    vec3 m = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0);\n    vec3 y = vec3"]}