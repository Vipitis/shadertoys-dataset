{"input_none": ["\n\treturn cosf( a );\n}\n\nfloat", "\n    float d = length(p - _position);\n    return d;\n}\n\nvec", "\n    vec3 q = p - voxelPos;\n    return length(q) - voxelRadius;\n}\n\nfloat", "\n    vec3 P0 = vec3(0.0, 0.0, 0.0);\n    vec3 P1 = vec3(1.0, 0.0, 0.0);\n    vec3 P2 = vec3(0.0, 1.0, 0.0);\n    vec3 P3 = vec3(0.0, 0.0, 1.0);\n    vec3 P4 = vec3(0.0, 0.0, -1.0);\n    vec3 P5 = vec3(0.0, 1.0, 1.0);\n    vec3 P6 = vec3(1.0, 0.0, 1.0);\n    vec3 P7 = vec3(1.0, 1.0, 0.0);\n    vec3 P8 = vec3(1.0, 1.0, 1.0);\n    vec3 P9 = vec3(1.0, 0.0, 1.0);\n    vec3 P10 = vec3(1.0, 1.0, 1.0);\n    vec3 P11 = vec3(1.0, 1.0, 1.0);\n    vec3 P12 = vec3(1.0, 1.0, 1.0);\n    vec3 P13 = vec3(1.0, 1.0, 1.0);\n    vec3 P14 = vec3(1.0, 1.0, 1.0);\n    vec3 P15 = vec3(1.0, 1.0, 1.0);\n    vec3 P16 = vec3(1.0, 1.0, 1.0);\n    vec3 P17 = vec3(1.0, 1.0, 1.0);\n    vec3 P18 = vec3(1.0, 1.0, 1.0);\n    vec3 P19 =", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.5;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float d = (r - 0.5) * 0.5;\n    float s = sin(a + t) * 0.5 + 0.5;\n    float c = cos(a + t) * 0.5 + 0.5;\n    float dd = d * d;\n    float sd = s * s;\n    float cd = c * c;\n    float dd2 = dd * dd;\n    float sd2 = sd * sd;\n    float cd2 = cd * cd;\n    float dd3 = dd2 * dd;\n    float sd3 = sd2 * sd;\n    float cd3 = cd2 * cd;\n    float dd4 = dd3 * dd;\n    float sd4 = sd3 * sd;\n    float cd4 = cd3 * cd;\n    float dd5 = dd4 * dd;\n    float sd5 = sd4 * sd;\n    float cd5 = cd4 * cd;\n    float dd6 = dd5 * dd;\n    float sd6 = sd5 * sd;\n    float cd6 = cd5 * cd;\n    float dd7 = dd6 * dd;\n    float sd7 = sd6 * sd;\n    float cd7 = cd6 * cd;\n    float dd8 = dd7 * dd;\n    float sd8 = sd7 * sd;\n    float cd8 = cd7 * cd;\n    float dd9 = dd8 * dd;\n    float sd9 = sd8 * sd;\n    float cd9 = cd8 * cd;\n    float dd10 = dd9 * dd;\n   ", "\n    return vec4(x, x, x, 1.0);\n}\n\nvec", "\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta > 0.0)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    return color;\n}\n\nvec", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    float n = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float persistence = 0.5;\n\n    for (int i = 0; i < NUM_NOISE_LAYERS; i++) {\n        n += amp * noise(p * freq);\n        freq *= 2.0;\n        amp *= persistence;\n    }\n\n    return n;\n}\n\nfloat", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec2 q = p - vec2(0.5);\n    float r = dot(q, q);\n    return r * r * (3.0 - 2.0 * r);\n}\n\nfloat", "\n    vec2 q = p - vec2(floor(p.x), floor(p.y));\n    vec2 r = vec2(fract(p.x), fract(p.y));\n    float d = dot(q, q);\n    if (d < eps) return 0.0;\n    r = r*r*(3.0 - 2.0*r);\n    return -1.0 + 2.0*dot(r, r);\n}\n\nfloat", "\n    vec3 lightPosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightDirection = normalize( lightPosition - eyePosition );\n    vec3 lightColor = vec3( 1.0, 1.0, 1.0 );\n    vec3 ambientColor = vec3( 0.2, 0.2, 0.2 );\n    vec3 diffuseColor = vec3( 0.0, 0.0, 0.0 );\n    vec3 specularColor = vec3( 0.0, 0.0, 0.0 );\n    float shininess = 10.0;\n    float attenuation = 1.0;\n    float distance = length( lightPosition - eyePosition );\n    float attenuationFactor = attenuation / ( distance * distance );\n    diffuseColor = lightColor * max( 0.0, dot( lightDirection, rayDirection ) ) * attenuationFactor;\n    vec3 eyeDirection = normalize( eyePosition - rayHitInfo );\n    vec3 reflectionDirection = reflect( -rayDirection, rayDirection );\n    float specularFactor = max( 0.0, dot( reflectionDirection, eyeDirection ) );\n    specularFactor = pow( specularFactor, shininess );\n    specularColor = lightColor * specularFactor * attenuationFactor;\n    return ( ambientColor + diffuseColor + specularColor ) * colorTheWorld;\n}\n\nvoid main()\n{\n    vec3 eyePosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 rayDirection = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheWorld = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheRay = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheLight = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorThe", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    vec2 res = vec2(0.0);\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        res.x = max(res.x, d);\n        t += d;\n        if(d < 0.001) break;\n    }\n    return res;\n}\n\nvoid main()\n{\n    vec2 res = vec2(0.0);\n    vec2 tex = vec2(0.0);\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 amb = vec3(0.0);\n    vec3 dif = vec3(0.0);\n    vec3 spe = vec3(0.0);\n    vec3 fog = vec3(0.0);\n    vec3 sky = vec3(0.0);\n    vec3 sun = vec3(0.0);\n    vec3 moon = vec3(0.0);\n    vec3 moon_col = vec3(0.0);\n    vec3 moon_amb = vec3(0.0);\n    vec3 moon_dif = vec3(0.0);\n    vec3 moon_spe = vec3(0.0);\n    vec3 moon_fog = vec3(0.0);\n    vec3 moon_sky = vec3(0.0);\n    vec3 moon_sun = vec3(0.0);\n    vec3 moon_moon = vec3(0.0);\n    vec3 moon_moon_col = vec3(0.0);\n    vec3 moon_moon_amb = vec3(0.0);\n    vec3 moon_moon_dif = vec3(", "\n    vec4 p2 = vec4(p, 1.0);\n    p2.y *= -1.0;\n    p2.x *= -1.0;\n    p2.z *= -1.0;\n    p2.w = 1.0;\n    return p2;\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 refDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAttenuation2 = vec3(0.0);\n    vec3 lightAttenuation3 = vec3(0.0);\n    vec3 lightAttenuation4 = vec3(0.0);\n    vec3 lightAttenuation5 = vec3(0.0);\n    vec3 lightAttenuation6 = vec3(0.0);\n    vec3 lightAttenuation7 = vec3(0.0);\n    vec3 lightAttenuation8 = vec3(0.0);\n    vec3 lightAttenuation9 = vec3(0.0);\n    vec3 lightAttenuation10 = vec3(0.0);\n    vec3 lightAttenuation11 = vec3(0.0);\n    vec3 lightAttenuation12 = vec3(0.0);\n    vec3 lightAttenuation13 = vec3(0.0);\n    vec3 lightAttenuation14 = vec3(0.0);\n    vec3 lightAttenuation15 = vec3(0.0);\n    vec3 lightAttenuation16 = vec3(0.0);\n    vec3 lightAttenuation17 = vec3(0.0);\n    vec3 lightAttenuation18 = vec3(0.0);\n    vec3 lightAttenuation19 = vec3(0.0);\n    vec3 lightAttenuation20 = vec3(", "\n    vec3 n = normalize(oN);\n    vec3 n1 = normalize(oN + vec3(1.0, 0.0, 0.0));\n    vec3 n2 = normalize(oN + vec3(-1.0, 0.0, 0.0));\n    vec3 n3 = normalize(oN + vec3(0.0, 1.0, 0.0));\n    vec3 n4 = normalize(oN + vec3(0.0, -1.0, 0.0));\n    vec3 n5 = normalize(oN + vec3(0.0, 0.0, 1.0));\n    vec3 n6 = normalize(oN + vec3(0.0, 0.0, -1.0));\n\n    float d1 = dot(n, p - oN);\n    float d2 = dot(n1, p - oN);\n    float d3 = dot(n2, p - oN);\n    float d4 = dot(n3, p - oN);\n    float d5 = dot(n4, p - oN);\n    float d6 = dot(n5, p - oN);\n    float d7 = dot(n6, p - oN);\n\n    return vec3(d1, d2, d3) - vec3(d4, d5, d6) - vec3(d7, 0.0, 0.0);\n}\n\nvec", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 envColor = vec3(0.0);\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float blurAmount = 0.0;\n    float blurScale = 1.0;\n    float blurFactor = 1.0;\n    float blurFactor2 = 1.0;\n    float blurFactor3 = 1.0;\n    float blurFactor4 = 1.0;\n    float blurFactor5 = 1.0;\n    float blurFactor6 = 1.0;\n    float blurFactor7 = 1.0;\n    float blurFactor8 = 1.0;\n    float blurFactor9 = 1.0;\n    float blurFactor10 = 1.0;\n    float blurFactor11 = 1.0;\n    float blurFactor12 = 1.0;\n    float blurFactor13 = 1.0;\n    float blurFactor14 = 1.0;\n    float blurFactor15 = 1.0;\n    float blurFactor16 = 1.0;\n    float blurFactor17 = 1.0;\n    float blurFactor18 = 1.0;\n    float blurFactor19 = 1.0;\n    float blurFactor20 = 1.0;\n    float blurFactor21 = 1.0;\n    float blurFactor22 = 1.0;\n    float blurFactor23 = 1.0;\n    float blurFactor24 = 1.0;\n    float blurFactor25 = 1.0;\n    float blurFactor26 = 1.0;\n    float blurFactor27 = 1.0;\n    float blurFactor28 = 1.0;\n    float blurFactor29 = 1.0;\n    float blurFactor30 = 1.0;\n    float blurFactor31 = 1.0;\n    float blurFactor32 = 1.0;\n    float blurFactor33 = 1.0;\n    float blurFactor34 = 1.0;\n    float blurFactor35 = ", "\n    float d = distance(coords, A);\n    float d2 = distance(coords, B);\n    float h = height;\n    float a = (d2 - d) / (d2 - d + h);\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat", "\n    return start * (1.0f - percent) + end * percent;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec2 v = b - a;\n    vec2 w = p - a;\n    return dot(w, v) / dot(v, v);\n}\n\nfloat", "\n    vec3 color = vec3(0.0f);\n    vec3 lightDir = vec3(0.0f);\n    vec3 lightColor = vec3(0.0f);\n    vec3 lightPos = vec3(0.0f);\n    vec3 lightPos2 = vec3(0.0f);\n    vec3 lightPos3 = vec3(0.0f);\n    vec3 lightPos4 = vec3(0.0f);\n    vec3 lightPos5 = vec3(0.0f);\n    vec3 lightPos6 = vec3(0.0f);\n    vec3 lightPos7 = vec3(0.0f);\n    vec3 lightPos8 = vec3(0.0f);\n    vec3 lightPos9 = vec3(0.0f);\n    vec3 lightPos10 = vec3(0.0f);\n    vec3 lightPos11 = vec3(0.0f);\n    vec3 lightPos12 = vec3(0.0f);\n    vec3 lightPos13 = vec3(0.0f);\n    vec3 lightPos14 = vec3(0.0f);\n    vec3 lightPos15 = vec3(0.0f);\n    vec3 lightPos16 = vec3(0.0f);\n    vec3 lightPos17 = vec3(0.0f);\n    vec3 lightPos18 = vec3(0.0f);\n    vec3 lightPos19 = vec3(0.0f);\n    vec3 lightPos20 = vec3(0.0f);\n    vec3 lightPos21 = vec3(0.0f);\n    vec3 lightPos22 = vec3(0.0f);\n    vec3 lightPos23 = vec3(0.0f);\n    vec3 lightPos24 = vec3(0.0f);\n    vec3 lightPos25 = vec3(0.", "\n    vec3 object_center = vec3(0.0, 0.0, 0.0);\n    float radius = 1.0;\n    return length(p - object_center) - radius;\n}\n\nfloat", "\n    float t0, t1;\n    vec3 oc = org - vec3(0.0, 0.0, 0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    else\n    {\n        discriminant = sqrt(discriminant);\n        t0 = (-b - discriminant) / (2.0 * a);\n        t1 = (-b + discriminant) / (2.0 * a);\n        if (t0 > t1)\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if (t0 < 0.0)\n        {\n            near = t1;\n            far = t1;\n        }\n        else if (t1 < 0.0)\n        {\n            near = t0;\n            far = t0;\n        }\n        else\n        {\n            near = t0;\n            far = t1;\n        }\n        return true;\n    }\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float t0, t1;\n    vec3 oc = org - vec3(0.0, 0.0, 0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    else\n    {\n        discriminant = sqrt(discriminant);\n        t0 =", "\n    float d = s.w;\n    vec3 q = p - s.xyz;\n    return dot(q, q) - d*d;\n}\n\nfloat", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    vec2 pos = p;\n    float d = 0.0;\n    for(int i = 0; i < 10; i++){\n        d += drawCircle(pos, 0.05);\n        pos.x += 0.05;\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    float d = drawShape(p);\n    gl_FragColor = vec4(vec3(d), 1.0);\n}", "\n    vec3 n = normalize(sn);\n    vec3 t = normalize(cross(n, sp));\n    vec3 b = cross(t, n);\n    return (sp + b * bumpFactor) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec3 sp = vec3(0.0, 0.0, 0.0);\n    vec3 sn = vec3(0.0, 0.0, 0.0);\n    vec3 sn2 = vec3(0.0, 0.0, 0.0);\n    vec3 sn3 = vec3(0.0, 0.0, 0.0);\n    vec3 sn4 = vec3(0.0, 0.0, 0.0);\n    vec3 sn5 = vec3(0.0, 0.0, 0.0);\n    vec3 sn6 = vec3(0.0, 0.0, 0.0);\n    vec3 sn7 = vec3(0.0, 0.0, 0.0);\n    vec3 sn8 = vec3(0.0, 0.0, 0.0);\n    vec3 sn9 = vec3(0.0, 0.0, 0.0);\n    vec3 sn10 = vec3(0.0, 0.0, 0.0);\n    vec3 sn11 = vec3(0.0, 0.0, 0.0);\n    vec3 sn12 = vec3(0.0, 0.0, 0.0);\n    vec3 sn13 = vec3(0.0, 0.0, 0.0);\n    vec3 sn14 = vec3(0.0, 0.0, 0.0);\n    vec3 sn15 = vec3(0.0, 0.0, 0.0);\n    vec3 sn16 = vec3(0.0, 0", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec3 light = normalize(vec3(1, 1, 1));\n    vec3 v = normalize(p - eye);\n    vec3 r = reflect(-light, n);\n    float s = pow(max(dot(r, v), 0.0), 100.0);\n    return vec3(s);\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy, 0.0);\n    vec3 n = normal(p);\n    vec3 c = shade(p, n);\n    gl_FragColor = vec4(c, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44", "\n    return length(p)-rad;\n}\n\nfloat", "\n    vec3 q = p;\n    float d = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float e = 0.0;\n    float f = 1.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;", "\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    float light_intensity = 0.5;\n    float light_attenuation = 1.0;\n    float light_radius = 0.0;\n    float light_softness = 0.0;\n    float light_softness_scale = 1.0;\n    float light_softness_power = 1.0;\n    float light_softness_offset = 0.0;\n    float light_softness_falloff = 0.0;\n    float light_softness_falloff_scale = 1.0;\n    float light_softness_falloff_power = 1.0;\n    float light_softness_falloff_offset = 0.0;\n    float light_softness_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff_falloff = 0.0;\n    float", "\n    vec3 col = vec3(0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float diffuseIntensity = dot(lightDir, rd);\n    if (diffuseIntensity > 0.0)\n    {\n        col += lightColor * lightIntensity * diffuseIntensity;\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 col = vec3(0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float diffuseIntensity = dot(lightDir, rd);\n    if (diffuseIntensity > 0.0)\n    {\n        col += lightColor * lightIntensity * diffuseIntensity;\n    }\n    col = skyColor(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * ti;\n    float t = texture(tex, p.xy).x;\n    if (t < 0.001) {\n        col = vec3(0.0);\n    } else {\n        col = vec3(1.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = vec3(0.0);\n    float ti = 0.0;\n    for (int i = 0; i < 100; i++) {\n        col += rayColor(ro, rd, ti);\n        ti += max(0.001, 0.0001 * length(rd));\n    }\n    col /= 100.0;\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5", "\n    vec2 q = p - diamond.xy;\n    return length(q - vec2(diamond.zw)) - diamond.w;\n}\n\nfloat", "\n    return vec3(1.0) - smoothstep(0.0, 1.0, abs(sin(uv.x * 10.0) * 0.5 + sin(uv.y * 10.0) * 0.5));\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        color += pattern(uv + vec2(i, 0.0));\n    }\n    color /= 10.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 p = pos;\n    float d = 0.0;\n    for ( int i = 0; i < 10; i++ ) {\n        d += texture( iChannel0, p ).r;\n        p *= 2.0;\n        p.x += sin( p.y * 10.0 ) * 0.01;\n        p.y += cos( p.x * 10.0 ) * 0.01;\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3( 0.0 );\n    float d = dist_field( p );\n    col = vec3( 1.0 - d );\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 r = reflect(-l, n);\n    vec3 vl = normalize(l + eye);\n    vec3 vr = reflect(vl, n);\n    float diff = max(dot(l, n), 0.0);\n    float spec = pow(max(dot(vr, vl), 0.0), 16.0);\n    return vec3(0.2, 0.2, 0.2) * diff + vec3(0.8, 0.8, 0.8) * spec;\n}\n\nvoid main() {\n    vec3 eye = vec3(0.0, 0.0, 1.0);\n    vec3 n = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 v = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 color = shading(v, n, eye);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    return sin(p.x + offset) * sin(p.y + offset);\n}\n\nfloat", "\n    float xmts = x.x;\n    float ymts = x.y;\n    float zmts = x.z;\n    float wmts = x.w;\n    float xmts2 = xmts * xmts;\n    float ymts2 = ymts * ymts;\n    float zmts2 = zmts * zmts;\n    float wmts2 = wmts * wmts;\n    float xmts3 = xmts2 * xmts;\n    float ymts3 = ymts2 * ymts;\n    float zmts3 = zmts2 * zmts;\n    float wmts3 = wmts2 * wmts;\n    float xmts4 = xmts3 * xmts;\n    float ymts4 = ymts3 * ymts;\n    float zmts4 = zmts3 * zmts;\n    float wmts4 = wmts3 * wmts;\n    float xmts5 = xmts4 * xmts;\n    float ymts5 = ymts4 * ymts;\n    float zmts5 = zmts4 * zmts;\n    float wmts5 = wmts4 * wmts;\n    float xmts6 = xmts5 * xmts;\n    float ymts6 = ymts5 * ymts;\n    float zmts6 = zmts5 * zmts;\n    float wmts6 = wmts5 * wmts;\n    float xmts7 = xmts6 * xmts;\n    float ymts7 = ymts6 * ymts;\n    float zmts7 = zmts6 * zmts;\n    float wmts7 = wmts6 * wmts;\n    float xmts8 = xmts7 * xmts;\n    float ymts8 = ymts7 * ymts;\n    float zmts8 = zmts7 * zmts;\n    float wmts8 = wmts7 *", "\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - h + r;\n}\n\nfloat", "\n    float d = scene(p);\n    if (d < eps) {\n        return 0.0;\n    }\n    return d;\n}\n\nfloat", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec", "\n    vec3 a = vec3(12.9898,78.233,45.145);\n    vec3 b = vec3(13.302,15.0287,83.985);\n    vec3 c = vec3(8.124,6.1595,105.291);\n    vec3 d = vec3(1.0,1.0,1.0);\n    vec3 u = fract(sin(dot(p,a))*c);\n    vec3 f = fract(sin(dot(p,b))*c);\n    vec3 g = fract(sin(dot(p,c))*c);\n    return mix(mix(mix(dot(u,f),g),mix(f,g,f.x),f.y),mix(mix(u,g,u.x),mix(g,f,g.x),u.y),f.z);\n}\n\nfloat", "\n    vec4 color = texture2D(u_texture, coord);\n    vec4 color2 = texture2D(u_texture2, coord);\n    vec4 color3 = texture2D(u_texture3, coord);\n    vec4 color4 = texture2D(u_texture4, coord);\n    vec4 color5 = texture2D(u_texture5, coord);\n    vec4 color6 = texture2D(u_texture6, coord);\n    vec4 color7 = texture2D(u_texture7, coord);\n    vec4 color8 = texture2D(u_texture8, coord);\n    vec4 color9 = texture2D(u_texture9, coord);\n    vec4 color10 = texture2D(u_texture10, coord);\n    vec4 color11 = texture2D(u_texture11, coord);\n    vec4 color12 = texture2D(u_texture12, coord);\n    vec4 color13 = texture2D(u_texture13, coord);\n    vec4 color14 = texture2D(u_texture14, coord);\n    vec4 color15 = texture2D(u_texture15, coord);\n    vec4 color16 = texture2D(u_texture16, coord);\n    vec4 color17 = texture2D(u_texture17, coord);\n    vec4 color18 = texture2D(u_texture18, coord);\n    vec4 color19 = texture2D(u_texture19, coord);\n    vec4 color20 = texture2D(u_texture20, coord);\n    vec4 color21 = texture2D(u_texture21, coord);\n    vec4 color22 = texture2D(u_texture22, coord);\n    vec4 color23 = texture2D(u_texture23, coord);\n    vec4 color24 = texture2D(u_texture24, coord);\n    vec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * w);\n}\n\nfloat", "\n    vec3 q = p;\n    float f = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += a * texture(iChannel0, q.yz).r;\n        q = q * 2.0 - vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float f = bumpFunction(p);\n    col = vec3(f);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 ray_nds = vec4(scr_pt, 0.0, 1.0);\n    vec4 ray_clip = viewp_inv * ray_nds;\n    vec4 ray_eye = view_inv * ray_clip;\n    vec4 ray_world = proj_inv * ray_eye;\n    ray_world.xyz /= ray_world.w;\n    return ray_world;\n}\n\nvec", "\n    float d = distance(pA, pB);\n    float l = length(pA - pB);\n    float r = rounded;\n    float dd = d - r;\n    float dd2 = d - r - thick.x;\n    float dd3 = d - r - thick.y;\n    float dd4 = d - r - thick.x - thick.y;\n    float dd5 = d - r - thick.x - thick.y - thick.x;\n    float dd6 = d - r - thick.x - thick.y - thick.y;\n    float dd7 = d - r - thick.x - thick.y - thick.x - thick.y;\n    float dd8 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd9 = d - r - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd10 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y;\n    float dd11 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd12 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd13 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y;\n    float dd14 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd15 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd16 = d - r - thick.x - thick.y - thick.x - thick.y - thick", "\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 0.0) - p);\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float diff = max(dot(n, lightDir), 0.0);\n    float spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - diff);\n    color += vec3(0.0, 0.0, 0.0) * spec;\n    return color;\n}\n\nvoid main()\n{\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        p = vec3(0.0, 0.0, 0.0);\n        n = vec3(0.0, 0.0, 0.0);\n        for (int j = 0; j < 100; j++)\n        {\n            p += vec3(0.0, 0.0, 0.0);\n            n += vec3(0.0, 0.0, 0.0);\n        }\n        p /= 100.0;\n        n /= 100.0;\n        color += Shade(p, n);\n    }\n    color /= 100.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 i = vec2( 0.0 );\n    vec2 f = vec2( 1.0 );\n    for( int j = 0; j < 10; j++ )\n    {\n        if( f.x < f.y )\n            f = vec2( f.x * 2.0, f.y * 2.0 );\n        else\n            f = vec2( f.x, f.y * 2.0 );\n        i += f;\n        if( length( ro + rd * i.x - cen ) > rad.x )\n            break;\n        if( length( ro + rd * i.y - cen ) > rad.y )\n            break;\n    }\n    return i;\n}\n\nvec", "\n\tfloat wave = (sin(x) * a) + b;\n\treturn wave;\n}\n\nfloat", "\n    return (vec2){a.x * b.x, a.y * b.y};\n}\n\nvec", "\n    vec4 res = vec4(0.0);\n    vec3 ab = pb - pa;\n    float d = dot(ab, ab);\n    float e = dot(ab, rd);\n    float f = dot(ab, ro) - ra;\n    float g = d*f - e*e;\n    if (g > 0.0)\n    {\n        float h = sqrt(g);\n        float t = (e + h) / d;\n        if (t > 0.0)\n        {\n            vec3 pt = ro + t*rd;\n            float y = length(pt - pa);\n            if (y < h)\n            {\n                res.x = t;\n                res.y = y;\n                res.z = h;\n            }\n        }\n    }\n    return res;\n}\n\nvec", "\n    float d = length(P - U);\n    if (d < r) {\n        O.xyz = C;\n        O.w = 1.0;\n    }\n}\n\nvoid main() {\n    vec2 U = gl_FragCoord.xy / iResolution.xy;\n    vec2 P = -1.0 + 2.0 * U;\n    P.x *= iResolution.x / iResolution.y;\n    vec3 C = vec3(0.0);\n    sphere(C, U, P, 0.5, vec3(1.0, 0.0, 0.0));\n    sphere(C, U, P, 0.25, vec3(0.0, 1.0, 0.0));\n    sphere(C, U, P, 0.125, vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(C, 1.0);\n}\n", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float h = map(a, 0.0, 6.28318530718, 0.0, 1.0);\n    return r * h;\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 q = p + vec2(sin(i + time), cos(i + time)) * 0.01;\n        col += vec3(1.0 - map(q));\n    }\n    col /= 100.0;\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.1));\n    col = pow(col, vec3(1.0 / 0.6));\n    col = pow(col, vec3(1.0 / 0.4));\n    col = pow(col, vec3(1.0 / 0.3));\n    col = pow(col, vec3(1.0 / 0.2));\n    col = pow(col, vec3(1.0 / 0.1));\n    col = pow(col, vec3(1.0 / 0.06));\n    col = pow(col, vec3(1.0 / 0.04));\n    col = pow(col, vec3(1.0 / 0.03));\n    col = pow(col, vec3(1.0 / 0.02));\n    col = pow(col, vec3(1.0 / 0.01));\n   ", "\n    vec3 scale = vec3(1.0, 1.0, 1.0);\n    if(layerID == 0.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 1.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 2.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 3.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 4.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 5.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 6.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 7.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 8.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 9.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 10.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 11.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 12.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if", "\n    return vec3(p.x, p.y, 0.0);\n}\n\nvec", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tymin = 0.0;\n    float tymax = 1000.0;\n    float tzmin = 0.0;\n    float tzmax = 1000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n", "\n    vec3 rayDirection = normalize(currentRayPosition - cameraPosition);\n    vec3 rayOrigin = cameraPosition;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return fract(x * sm);\n}\n\nfloat", "\n    p = fract(p * vec3(12345.6789, 12345.6789, 12345.6789));\n    p += dot(p, p + 19.19);\n    return fract(vec3(dot(p, p + 19.19), dot(p, p + 19.19), dot(p, p + 19.19)));\n}\n\nfloat", "\n    vec3 a = fract(p);\n    a = a * a * (3.0 - 2.0 * a);\n\n    return mix(mix(a.x, a.y, a.z), mix(a.y, a.z, a.x), a.x);\n}\n\nfloat", "\n\t\treturn length(p);\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.5;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.25;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.03125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.015625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0078125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00390625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.001953125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0009765625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00048828125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.000244140625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0001220703125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00006103515625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.000030517578125;\n\t}\n\t\n\tfloat func(vec", "\n    vec2 balloonPosition = vec2( 0.0, 0.0 );\n    balloonPosition.x = sdfBalloonPosition.x;\n    balloonPosition.y = sdfBalloonPosition.y;\n    return sdfBalloonPosition.z - length( currentRayPosition - balloonPosition );\n}\n\nvec", "\n    vec4 res = vec4( 0.0 );\n    vec3 p = ro;\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 100000.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        if( tmax - tmin < 0.0001 )\n            break;\n        float tm = ( tmin + tmax ) * 0.5;\n        vec3 pp = p + tm * rd;\n        float d = length( pp - rad );\n        if( d < tmax )\n        {\n            tmax = d;\n            res = vec4( tm, tm, tm, 1.0 );\n        }\n        tmin = max( tmin, tm );\n        t = tm;\n    }\n    return res;\n}\n\nvec", "\n    vec3 a = fract(p);\n    a = a*a*(3.0-2.0*a);\n    return a.x*(a.y+a.z) + a.y*a.z;\n}\n\nfloat", "\n    vec3 oc = p - a;\n    vec3 ab = b - a;\n    vec3 n = cross(oc,ab);\n    float d = dot(n,c);\n    float t = dot(n,oc)/d;\n    return t;\n}\n\nfloat", "\n    vec2 z0 = z;\n    z.x = c.x;\n    z.y = c.y;\n    for(int i = 0; i < 100; i++){\n        z.x = z0.x*z0.x - z0.y*z0.y + c.x;\n        z.y = 2.0*z0.x*z0.y + c.y;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main(){\n    vec2 c = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 z = vec2(0.0);\n    float m = mandelbrot(c, z);\n    gl_FragColor = vec4(m, m, m, 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n    return mat4(x, y, z, vec4(0, 0, 0, 1));\n}\n\nvec", "\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),rgb,c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy/iResolution.xy);\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float aa = 1.0;\n    for(int i=0;i<5;i++){\n        vec2 off = vec2(0.0);\n        off.x = i*0.1;\n        col += hsv2rgb(vec3(mod(iTime+off.x,1.0),1.0,1.0));\n    }\n    col /= 5.0;\n    col = pow(col,vec3(0.4545));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.", "\n    float c = cos(dir), s = sin(dir);\n    return ciPat(p, w, c, s);\n}\n\nfloat", "\n    return (b - a) * x + a;\n}\n\nfloat", "\n    float dist = length(xy);\n    float alpha = smoothstep(0.0, 1.0, dist);\n    baseCol = mix(baseCol, curveCol, alpha);\n}\n\nvoid main()\n{\n    vec2 xy = gl_FragCoord.xy / resolution.xy;\n    vec4 baseCol = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 curveCol = vec4(0.0, 0.0, 0.0, 0.0);\n\n    drawFunc(baseCol, xy, curveCol);\n\n    gl_FragColor = baseCol;\n}\n", "\n    return 0.5*sin(j*p.x)+0.5*sin(j*p.y);\n}\n\nfloat", "\n    return f*f;\n}\n\nint", "\n    return vec3(c.r, c.g, c.b);\n}\n\nvec", "\n    return sdBox(p,s);\n}\n\nDAVec3 sdBox(DAVec3 p,vec3 s){\n    DAVec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s){\n    DAVec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(q)-t;\n    return length(max(r,0.0))+min(max(max(r.x,r.y),r.z),0.0)+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t,DAVec3 u){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(q)-t;\n    DAVec3 s = abs(r)-u;\n    return length(max(s,0.0))+min(max(max(max(s.x,s.y),s.z),r.x),r.y)+min(max(max(max(q.x,q.y),q.z),r.x),r.y)+min(max(max(q.x,q.y),q.z),q.z);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t,DAVec3 u,DAVec3 v){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(", "\n    vec4 sd = vec4(0.0);\n    vec4 sd1 = vec4(0.0);\n    vec4 sd2 = vec4(0.0);\n    vec4 sd3 = vec4(0.0);\n    vec4 sd4 = vec4(0.0);\n    vec4 sd5 = vec4(0.0);\n    vec4 sd6 = vec4(0.0);\n    vec4 sd7 = vec4(0.0);\n    vec4 sd8 = vec4(0.0);\n    vec4 sd9 = vec4(0.0);\n    vec4 sd10 = vec4(0.0);\n    vec4 sd11 = vec4(0.0);\n    vec4 sd12 = vec4(0.0);\n    vec4 sd13 = vec4(0.0);\n    vec4 sd14 = vec4(0.0);\n    vec4 sd15 = vec4(0.0);\n    vec4 sd16 = vec4(0.0);\n    vec4 sd17 = vec4(0.0);\n    vec4 sd18 = vec4(0.0);\n    vec4 sd19 = vec4(0.0);\n    vec4 sd20 = vec4(0.0);\n    vec4 sd21 = vec4(0.0);\n    vec4 sd22 = vec4(0.0);\n    vec4 sd23 = vec4(0.0);\n    vec4 sd24 = vec4(0.0);\n    vec4 sd25 = vec4(0.0);\n    vec4 sd26 = vec4(0.0);\n    vec4 sd27 = vec4(0.0);\n    vec4 sd28 = vec4(0.0);\n", "\n    vec3 color = vec3(0.0);\n    vec3 rayDir = normalize(pos - cameraPos);\n    vec3 rayPos = cameraPos;\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 hit = raymarch(rayPos, rayDir);\n        if (hit.x == -1.0)\n        {\n            break;\n        }\n        color += shade(hit);\n        rayPos = hit;\n    }\n    return vec4(color, depth);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / resolution.xy) - 0.5;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n    vec3 rayPos = cameraPos;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 hit = raymarch(rayPos, rayDir);\n        if (hit.x == -1.0)\n        {\n            break;\n        }\n        color += shade(hit);\n        rayPos = hit;\n    }\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return pow(x, vec3(1.0 / 2.2));\n}\n\nvec", "\n    return dot(p,p);\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 view_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 half_dir = normalize(light_dir + view_dir);\n    float diffuse = max(dot(light_dir, p), 0.0);\n    float specular = pow(max(dot(half_dir, p), 0.0), 16.0);\n    color = vec3(0.0, 0.0, 0.0);\n    return color;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 view_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 half_dir = normalize(light_dir + view_dir);\n    float diffuse = max(dot(light_dir, p), 0.0);\n    float specular = pow(max(dot(half_dir, p), 0.0), 16.0);\n    color = vec3(0.0, 0.0, 0.0);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float f = 0.0;\n    f += dot( p, vec2( 12.9898, 78.233 ) );\n    f += dot( p, vec2( 43.123, 53.4321 ) );\n    return fract(sin(f)*43758.5453);\n}\n\nfloat", "\n    gl_Position = vec4(p, 0.0, 1.0);\n}\n\nvoid v(vec3 p){\n    gl_Position = vec4(p, 0.0);\n}\n\nvoid v(vec4 p){\n    gl_Position = p;\n}\n\nvoid v(mat4 m){\n    gl_Position = m * vec4(a_position, 1.0);\n}\n\nvoid v(mat3 m){\n    gl_Position = vec4(m * a_position, 1.0);\n}\n\nvoid v(mat2 m){\n    gl_Position = vec4(m * a_position, 0.0, 1.0);\n}\n\nvoid v(float x, float y){\n    gl_Position = vec4(x, y, 0.0, 1.0);\n}\n\nvoid v(float x, float y, float z){\n    gl_Position = vec4(x, y, z, 1.0);\n}\n\nvoid v(float x, float y, float z, float w){\n    gl_Position = vec4(x, y, z, w);\n}\n\nvoid v(float x, float y, float z, float w, float u, float v){\n    gl_Position = vec4(x, y, z, w);\n    gl_PointSize = u;\n    gl_Position.w = v;\n}\n\nvoid v(float x, float y, float z, float w, float u, float v, float r, float g, float b, float a){\n    gl_Position = vec4(x, y, z, w);\n    gl_PointSize = u;\n    gl_Position.w = v;\n    gl_PointSize = r;\n    gl_Position.w = g;\n    gl_Position.w = b;\n    gl_Position.w = a;\n}\n\nvoid v(float x, float y, float z, float w, float u, float v, float r, float g, float b, float a, float s, float t){\n    gl_Position = vec4(x, y", "\n    return (u.x-m.x)*(u.x-m.x)+(u.y-m.y)*(u.y-m.y);\n}\n\nfloat", "\n    return 0.5*length(u-m)+0.5*length(u-m-vec2(1,0));\n}\n\nfloat", "\n    return dot(u, m.xy) + m.z;\n}\n\nfloat", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    return cross(a, b);\n}\n\nvec", "\n    vec3 v0 = A;\n    vec3 v1 = B;\n    vec3 v2 = C;\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 p = warpTriangle(e1, e2, Xi);\n    vec3 wo = normalize(p - v0);\n    w = wo;\n    wPdf = pdfTriangle(e1, e2, Xi);\n}\n\nvoid sampleSphericalHemisphere(in vec3 A, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 wo = sampleSphericalHemisphere(Xi);\n    w = wo;\n    wPdf = pdfSphericalHemisphere(Xi);\n}\n\nvoid sampleCosineHemisphere(in vec3 A, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 wo = sampleCosineHemisphere(Xi);\n    w = wo;\n    wPdf = pdfCosineHemisphere(Xi);\n}\n\nvoid sampleCone(in vec3 A, in vec3 B, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec3 v0 = A;\n    vec3 v1 = B;\n    vec3 e1 = v1 - v0;\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 p = warpCone(e1, Xi);\n    vec3 wo = normalize(p - v0);\n    w = wo;\n    wPdf = pdfCone(e1, Xi);\n}\n\nvoid", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    float d = length(p);\n    return d;\n}\n\nfloat", "\n    vec4 res = vec4(0.0);\n    res.x = p.x * p.x;\n    res.y = p.y * p.y;\n    res.z = p.z * p.z;\n    res.w = p.x * p.y;\n    return res;\n}\n\nvec", "\n    float t = time*0.01;\n    float t2 = time*0.02;\n    float t3 = time*0.03;\n    float t4 = time*0.04;\n    float t5 = time*0.05;\n    float t6 = time*0.06;\n    float t7 = time*0.07;\n    float t8 = time*0.08;\n    float t9 = time*0.09;\n    float t10 = time*0.1;\n    float t11 = time*0.11;\n    float t12 = time*0.12;\n    float t13 = time*0.13;\n    float t14 = time*0.14;\n    float t15 = time*0.15;\n    float t16 = time*0.16;\n    float t17 = time*0.17;\n    float t18 = time*0.18;\n    float t19 = time*0.19;\n    float t20 = time*0.2;\n    float t21 = time*0.21;\n    float t22 = time*0.22;\n    float t23 = time*0.23;\n    float t24 = time*0.24;\n    float t25 = time*0.25;\n    float t26 = time*0.26;\n    float t27 = time*0.27;\n    float t28 = time*0.28;\n    float t29 = time*0.29;\n    float t30 = time*0.3;\n    float t31 = time*0.31;\n    float t32 = time*0.32;\n    float t33 = time*0.33;\n    float t34 = time*0.34;\n    float t35 = time*0.35;\n    float t36 = time*0.36;\n    float t37 = time*0.37;\n    float t38 =", "\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n        if(d < 0.001) break;\n    }\n    return t;\n}\n\nfloat", "\n    vec3 rd = lp - ro;\n    float d = length(rd);\n    rd = normalize(rd);\n    float n = k / (d * d);\n    float m = t / (d * d);\n    return n * exp(-m);\n}\n\nfloat", "\n    vec3 p0 = p - vec3(0.0, 0.0, 0.0);\n    vec3 p1 = p - vec3(1.0, 0.0, 0.0);\n    vec3 p2 = p - vec3(0.0, 1.0, 0.0);\n    vec3 p3 = p - vec3(0.0, 0.0, 1.0);\n    vec3 p4 = p - vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p - vec3(1.0, 0.0, 1.0);\n    vec3 p6 = p - vec3(0.0, 1.0, 1.0);\n    vec3 p7 = p - vec3(1.0, 1.0, 1.0);\n\n    float d0 = dot(p0, p0);\n    float d1 = dot(p1, p1);\n    float d2 = dot(p2, p2);\n    float d3 = dot(p3, p3);\n    float d4 = dot(p4, p4);\n    float d5 = dot(p5, p5);\n    float d6 = dot(p6, p6);\n    float d7 = dot(p7, p7);\n\n    float d = min(d0, min(d1, min(d2, min(d3, min(d4, min(d5, min(d6, d7)))))));\n\n    if (d < edge) {\n        edge = d;\n        crv = 0.0;\n    }\n\n    if (d < t) {\n        t = d;\n        crv = 1.0;\n    }\n\n    return t;\n}\n\nfloat", "\n    vec3 p0 = m[0] * p3.x + m[1] * p3.y + m[2] * p3.z + t;\n    vec3 p1 = m[3] * p3.x + m[4] * p3.y + m[5] * p3.z + t;\n    vec3 p2 = m[6] * p3.x + m[7] * p3.y + m[8] * p3.z + t;\n    return vec4(p0, p1, p2);\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    color.r = p.x;\n    color.g = p.y;\n    color.b = 0.0;\n    color.a = 1.0;\n    return color;\n}\n\nvec", "\n    return sin(p.x + p.y + dir) * 0.5 + 0.5;\n}\n\nfloat", "\n    return q.x * cos(dir) + q.y * sin(dir);\n}\n\nfloat", "\n    vec3 v0 = p3 - n[0];\n    vec3 v1 = p3 - n[1];\n    vec3 v2 = p3 - n[2];\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0f - v - w;\n    return vec4(u, v, w, 0.0f);\n}\n\nvec", "\n    vec4 qp = q - p;\n    vec4 qr = q - r;\n    vec4 h = cross(qp, qr);\n    float a = dot(qp, h);\n    float b = dot(qr, h);\n    float c = dot(h, h);\n    float d = a*a + b*b - c*0.25;\n    if (d < 0.0) return 0.0;\n    float e = sqrt(d);\n    return -a*b*0.25/e;\n}\n\nfloat", "\n    float d = length(p);\n    return 1.0 - smoothstep(lW, lW+0.01, d);\n}\n\nfloat", "\n    vec2 dp = ddx * ddy;\n    vec2 dp2 = dp * dp;\n    vec2 dp3 = dp2 * dp;\n    vec2 dp4 = dp3 * dp;\n    vec2 dp5 = dp4 * dp;\n    vec2 dp6 = dp5 * dp;\n    vec2 dp7 = dp6 * dp;\n    vec2 dp8 = dp7 * dp;\n    vec2 dp9 = dp8 * dp;\n    vec2 dp10 = dp9 * dp;\n    vec2 dp11 = dp10 * dp;\n    vec2 dp12 = dp11 * dp;\n    vec2 dp13 = dp12 * dp;\n    vec2 dp14 = dp13 * dp;\n    vec2 dp15 = dp14 * dp;\n    vec2 dp16 = dp15 * dp;\n    vec2 dp17 = dp16 * dp;\n    vec2 dp18 = dp17 * dp;\n    vec2 dp19 = dp18 * dp;\n    vec2 dp20 = dp19 * dp;\n    vec2 dp21 = dp20 * dp;\n    vec2 dp22 = dp21 * dp;\n    vec2 dp23 = dp22 * dp;\n    vec2 dp24 = dp23 * dp;\n    vec2 dp25 = dp24 * dp;\n    vec2 dp26 = dp25 * dp;\n    vec2 dp27 = dp26 * dp;\n    vec2 dp28 = dp27 * dp;\n    vec2 dp29 = dp28 * dp;\n    vec2 dp30 = dp", "\n    vec2 d = n - f;\n    float d2 = dot( d, d );\n    if( d2 > EPSILON )\n    {\n        float d3 = sqrt( d2 );\n        float t = ( d.x * f.x + d.y * f.y ) / d3;\n        if( t < 0.0 )\n        {\n            t = 0.0;\n        }\n        else if( t > 1.0 )\n        {\n            t = 1.0;\n        }\n        mr = f + t * d;\n        mg = f + ( t - 1.0 ) * d;\n    }\n    else\n    {\n        mr = f;\n        mg = f;\n    }\n}\n\nvoid main()\n{\n    vec2 f = gl_FragCoord.xy;\n    vec2 mr, mg;\n    closest( f, vec2( 0.0, 0.0 ), mr, mg );\n    vec2 d = mr - f;\n    float d2 = dot( d, d );\n    if( d2 > EPSILON )\n    {\n        float d3 = sqrt( d2 );\n        float t = ( d.x * f.x + d.y * f.y ) / d3;\n        if( t < 0.0 )\n        {\n            t = 0.0;\n        }\n        else if( t > 1.0 )\n        {\n            t = 1.0;\n        }\n        vec2 p = f + t * d;\n        vec2 q = f + ( t - 1.0 ) * d;\n        vec2 r = mix( p, q, 0.5 );\n        vec2 s = mix( mr, mg, 0.5 );\n        float d4 = dot( r - s, r - s );\n        if( d4 > EPSILON )\n        {\n            float d5 = sqrt( d4 );\n            float t2 = ( r.x * s.x + r.y * s.y ) / d5;\n            if( t2 < 0.0 )", "\n\t\treturn lerp(start_pos, end_pos, t);\n\t}\n\t\n\tvec2 lerp_vel(  float t){\n\t\treturn lerp(start_vel, end_vel, t);\n\t}\n\t\n\tvec2 lerp_acc(  float t){\n\t\treturn lerp(start_acc, end_acc, t);\n\t}\n\t\n\tvec2 lerp_jerk(  float t){\n\t\treturn lerp(start_jerk, end_jerk, t);\n\t}\n\t\n\tvec2 lerp_slope(  float t){\n\t\treturn lerp(start_slope, end_slope, t);\n\t}\n\t\n\tvec2 lerp_bias(  float t){\n\t\treturn lerp(start_bias, end_bias, t);\n\t}\n\t\n\tvec2 lerp_damp(  float t){\n\t\treturn lerp(start_damp, end_damp, t);\n\t}\n\t\n\tvec2 lerp_friction(  float t){\n\t\treturn lerp(start_friction, end_friction, t);\n\t}\n\t\n\tvec2 lerp_gravity(  float t){\n\t\treturn lerp(start_gravity, end_gravity, t);\n\t}\n\t\n\tvec2 lerp_friction_bias(  float t){\n\t\treturn lerp(start_friction_bias, end_friction_bias, t);\n\t}\n\t\n\tvec2 lerp_friction_damp(  float t){\n\t\treturn lerp(start_friction_damp, end_friction_damp, t);\n\t}\n\t\n\tvec2 lerp_friction_slope(  float t){\n\t\treturn lerp(start_friction_slope, end_friction_slope, t);\n\t}\n\t\n\tvec2 lerp_friction_bias_slope(  float t){\n\t\treturn lerp(start_friction_bias_slope, end_friction_bias_slope, t);", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    return (p0 + p1 + p2) / 3.0;\n}\n\nvec", "\n    float a = p1.x - p0.x;\n    float b = p1.y - p0.y;\n    float c = p2.x - p0.x;\n    float d = p2.y - p0.y;\n    return atan2(a*d-b*c, a*a+b*b);\n}\n\nfloat", "\n    vec2 h12 = h1 - h2;\n    vec2 h13 = h1 - h3;\n    vec2 h23 = h2 - h3;\n    float d12 = length(h12);\n    float d13 = length(h13);\n    float d23 = length(h23);\n    float d123 = d12 + d13 - d23;\n    float d123_ = d123 * 0.5;\n    float d123_2 = d123_ * d123_;\n    float d123_3 = d123_2 * d123_;\n    float d123_4 = d123_3 * d123_;\n    float d123_5 = d123_4 * d123_;\n    float d123_6 = d123_5 * d123_;\n    float d123_7 = d123_6 * d123_;\n    float d123_8 = d123_7 * d123_;\n    float d123_9 = d123_8 * d123_;\n    float d123_10 = d123_9 * d123_;\n    float d123_11 = d123_10 * d123_;\n    float d123_12 = d123_11 * d123_;\n    float d123_13 = d123_12 * d123_;\n    float d123_14 = d123_13 * d123_;\n    float d123_15 = d123_14 * d123_;\n    float d123_16 = d123_15 * d123_;\n    float d123_17 = d123_16 * d123_;\n    float d123_18 = d123_17 * d123", "\n    vec2 q = p - vec2(0.5);\n    vec2 r = vec2(length(q), atan(q.y, q.x));\n    return r;\n}\n\nvoid main() {\n    vec2 p = triangulate(gl_FragCoord.xy);\n    vec2 q = vec2(0.5);\n    vec2 r = vec2(length(p - q), atan(p.y - q.y, p.x - q.x));\n    float d = length(p - q);\n    float a = atan(p.y - q.y, p.x - q.x);\n    float b = atan(p.y, p.x);\n    float c = atan(q.y, q.x);\n    float d1 = abs(a - b);\n    float d2 = abs(a - c);\n    float d3 = abs(b - c);\n    float d4 = abs(a - d);\n    float d5 = abs(b - d);\n    float d6 = abs(c - d);\n    float d7 = abs(a - d1);\n    float d8 = abs(b - d2);\n    float d9 = abs(c - d3);\n    float d10 = abs(a - d4);\n    float d11 = abs(b - d5);\n    float d12 = abs(c - d6);\n    float d13 = abs(a - d7);\n    float d14 = abs(b - d8);\n    float d15 = abs(c - d9);\n    float d16 = abs(a - d10);\n    float d17 = abs(b - d11);\n    float d18 = abs(c - d12);\n    float d19 = abs(a - d13);\n    float d20 = abs(b - d14);\n    float d21 = abs(c - d15);\n    float d22 = abs(a - d16);\n    float d23 = abs(b - d17);\n    float", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n    {\n        t = -1.0;\n        return false;\n    }\n    else\n    {\n        float sqrtd = sqrt( discriminant );\n        float root = (-b - sqrtd) / (2.0 * a);\n        if ( root < tmin || tmax < root )\n        {\n            root = (-b + sqrtd) / (2.0 * a);\n            if ( root < tmin || tmax < root )\n            {\n                t = -1.0;\n                return false;\n            }\n        }\n        t = root;\n    }\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize( hitPos - sph.center );\n    return true;\n}\n\nbool IntersectTriangle( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2,\n                        out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross( p - v0, e2 );\n    float a = dot( e1, h );\n    if ( a > -0.0001 && a < 0.0001 )\n        return false;    // This ray is parallel to this triangle.\n    float f = 1.0 / a;\n    vec3 s = p - v0;\n    float u = f * dot( s, h );\n    if ( u < 0.0 || u > 1.0 )\n        return false;\n    vec3 q = cross( s, e1 );\n    float v = f *", "\n    float t0, t1;\n    float a = Dot( ray.dir, ray.dir );\n    float b = 2.0f * Dot( ray.dir, ray.org - sph.center );\n    float c = Dot( ray.org - sph.center, ray.org - sph.center ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n    if ( discriminant < 0.0f )\n        return false;\n    else\n    {\n        discriminant = sqrtf( discriminant );\n        t0 = ( -b - discriminant ) / ( 2.0f * a );\n        t1 = ( -b + discriminant ) / ( 2.0f * a );\n        if ( t0 > t1 )\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if ( t0 < tmin )\n            t0 = tmin;\n        if ( t1 > tmax )\n            t1 = tmax;\n        if ( t0 > t1 )\n            return false;\n        else\n            return true;\n    }\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t0, t1;\n    float a = tri.v0.x - tri.v1.x;\n    float b = tri.v0.y - tri.v1.y;\n    float c = tri.v0.z - tri.v1.z;\n    float d = tri.v0.x - tri.v2.x;\n    float e = tri.v0.y - tri.v2.y;\n    float f = tri.v0.z - tri.v2.z;\n    float g = ray.dir.x;\n    float h = ray.dir.y;\n    float i = ray.dir.z;\n    float j = tri.v0.x - ray.org.x;\n    float k = tri.v0", "\n    vec3 k_rg_min = vec3( 0.0 );\n    vec3 k_rg_max = vec3( 0.0 );\n    vec3 k_rg_min_t = vec3( 0.0 );\n    vec3 k_rg_max_t = vec3( 0.0 );\n    vec3 k_rg_min_t_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg", "\n    vec2 p = p0;\n    vec2 dp = p1 - p0;\n    vec2 dp2 = p2 - p1;\n    float t = clamp(dot(p, dp2) / dot(dp, dp2), 0.0, 1.0);\n    return vec4(mix(p0, p1, t), 0.0, 1.0);\n}\n\nvec", "\n    vec3 min = vec3( min( p0.x, min( p1.x, p2.x ) ), min( p0.y, min( p1.y, p2.y ) ), min( p0.z, min( p1.z, p2.z ) ) );\n    vec3 max = vec3( max( p0.x, max( p1.x, p2.x ) ), max( p0.y, max( p1.y, p2.y ) ), max( p0.z, max( p1.z, p2.z ) ) );\n    return BezierAABB( min, max );\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return k * k * (3 - 2 * k);\n}\n\nfloat", "\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return (coord - res / 2.0f) / res;\n}\n\nvec", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    return 0.5 * ( 1.0 - step( r, 0.5 ) );\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy / resolution.xy ) - 0.5;\n    float t = time * 0.05;\n    float d = checkersGradBox( p );\n    float d2 = checkersGradBox( p + vec2( 0.0, 0.001 ) );\n    float d3 = checkersGradBox( p + vec2( 0.0, 0.002 ) );\n    float d4 = checkersGradBox( p + vec2( 0.0, 0.003 ) );\n    float d5 = checkersGradBox( p + vec2( 0.0, 0.004 ) );\n    float d6 = checkersGradBox( p + vec2( 0.0, 0.005 ) );\n    float d7 = checkersGradBox( p + vec2( 0.0, 0.006 ) );\n    float d8 = checkersGradBox( p + vec2( 0.0, 0.007 ) );\n    float d9 = checkersGradBox( p + vec2( 0.0, 0.008 ) );\n    float d10 = checkersGradBox( p + vec2( 0.0, 0.009 ) );\n    float d11 = checkersGradBox( p + vec2( 0.0, 0.010 ) );\n    float d12 = checkersGradBox( p + vec2( 0.0, 0.011 ) );\n    float d13 = checkersGradBox( p + vec2( 0.0, 0.012 ) );\n    float d14 = checkersGradBox( p + vec2( 0.0, 0.013 ) );\n    float d1", "\n    return vec3(\n        dot(rgb, vec3(0.2126, 0.7152, 0.0722)),\n        dot(rgb, vec3(0.2126, 0.2990, 0.5343)),\n        dot(rgb, vec3(0.0722, 0.5343, 0.2126))\n    );\n}\n\nvec", "\n    return fract(sin(p)*43758.5453);\n}\n\nfloat", "\n    vec3 e = vec3( 0.00392, 0.00195, 0.00077 );\n    return normalize( e.zyx * dot( e, p ) + e );\n}\n\nvoid main()\n{\n    vec3 p = ( gl_FragCoord.xyz / vec3( iResolution.xyz ) - 0.5 ) * 2.0;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 rd = normalize( p.xyz );\n\n    vec3 col = vec3( 0.0 );\n\n    vec3 lightDir = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    vec3 lightColor = vec3( 1.0 );\n\n    float intensity = 0.0;\n    float attenuation = 1.0;\n\n    for ( int i = 0; i < 10; i++ )\n    {\n        vec3 h = normalize( lightDir + rd );\n        float nh = max( 0.0, dot( h, normal( p ) ) );\n        float diffuse = max( 0.0, dot( lightDir, normal( p ) ) );\n        float specular = pow( nh, 10.0 );\n        intensity = diffuse + specular;\n        col += lightColor * intensity * attenuation;\n        attenuation *= 0.5;\n        p += rd * 0.01;\n    }\n\n    col = pow( col, vec3( 0.4545 ) );\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    float x = pos.x;\n    float y = pos.y;\n    float r = radius;\n    float w = width;\n    float h = r * 2;\n    float d = r * 0.5;\n    float a = PI / 4;\n    float b = PI / 2;\n    float c = PI;\n    float s = sin(a);\n    float c = cos(a);\n    float t = sin(b);\n    float u = cos(b);\n    float v = sin(c);\n    float w = cos(c);\n    float x1 = x + r * c;\n    float y1 = y + r * s;\n    float x2 = x + r * c;\n    float y2 = y - r * s;\n    float x3 = x - r * c;\n    float y3 = y - r * s;\n    float x4 = x - r * c;\n    float y4 = y + r * s;\n    float x5 = x + r * c;\n    float y5 = y + r * s;\n    float x6 = x + r * c;\n    float y6 = y - r * s;\n    float x7 = x - r * c;\n    float y7 = y - r * s;\n    float x8 = x - r * c;\n    float y8 = y + r * s;\n    float x9 = x + r * c;\n    float y9 = y + r * s;\n    float x10 = x + r * c;\n    float y10 = y - r * s;\n    float x11 = x - r * c;\n    float y11 = y - r * s;\n    float x12 = x - r * c;\n    float y12 = y + r * s;\n    float x13 = x + r * c;\n    float y13 = y + r * s;\n    float x14 = x + r * c;\n    float y14 = y - r * s;\n    float x15 = x - r * c;\n    float y15 = y - r * s;\n   ", "\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in float t)\n{\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = t;\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t)\n{\n    sp = p;\n    tp = p + t;\n    rp = p;\n    mul = length(t);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in float tt)\n{\n    sp = p;\n    tp = p + t * tt;\n    rp = p;\n    mul = length(t * tt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt)\n{\n    sp = p;\n    tp = p + t * tt;\n    rp = p;\n    mul = length(t * tt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt, in float ttt)\n{\n    sp = p;\n    tp = p + t * tt * ttt;\n    rp = p;\n    mul = length(t * tt * ttt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt, in vec3 t", "\n    return vec2(\n        abs(p.x) - 1.0,\n        abs(p.y) - 1.0\n    );\n}\n\nvec", "\n    return (vec2){z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x};\n}\n\nvec", "\n    vec2 p0 = p;\n    vec2 p1 = p + vec2(aaSize, 0.0);\n    vec2 p2 = p + vec2(aaSize, aaSize);\n    vec2 p3 = p + vec2(0.0, aaSize);\n    vec2 p4 = p + vec2(aaSize, aaSize);\n    vec2 p5 = p + vec2(aaSize, 0.0);\n    vec2 p6 = p + vec2(0.0, aaSize);\n    vec2 p7 = p + vec2(0.0, 0.0);\n\n    vec2 p8 = p + vec2(aaSize, aaSize);\n    vec2 p9 = p + vec2(aaSize, 0.0);\n    vec2 p10 = p + vec2(0.0, aaSize);\n    vec2 p11 = p + vec2(0.0, 0.0);\n\n    vec2 p12 = p + vec2(aaSize, aaSize);\n    vec2 p13 = p + vec2(aaSize, 0.0);\n    vec2 p14 = p + vec2(0.0, aaSize);\n    vec2 p15 = p + vec2(0.0, 0.0);\n\n    vec2 p16 = p + vec2(aaSize, aaSize);\n    vec2 p17 = p + vec2(aaSize, 0.0);\n    vec2 p18 = p + vec2(0.0, aaSize);\n    vec2 p19 = p + vec2(0.0, 0.0);\n\n    vec2 p20 = p + vec2(aaSize, aaSize);\n    vec2 p21 = p + vec2(aaSize, 0.0);\n    vec2 p22 = p + vec2(0.0, aaSize);\n    ve", "\n    vec2 box = vec2(1.0);\n    box.x = abs(pos.x) - 0.5;\n    box.y = abs(pos.y) - 0.5;\n    return box;\n}\n\nvec", "\n    return vec2(\n        (pos.x + 1.0) * 0.5,\n        (pos.y + 1.0) * 0.5\n    );\n}\n\nvec", "\n    return vec2(pos.x / pos.z, pos.y / pos.z);\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 rayDir = normalize(camDir + lightDir);\n    vec3 rayOrigin = camPos;\n    float t = 0.0;\n    float tMax = 1000.0;\n    float tMin = 0.001;\n    float tDelta = 0.001;\n    float tDeltaMax = 0.001;\n    float tDeltaMin = 0.001;\n    float tDeltaMax2 = 0.001;\n    float tDeltaMin2 = 0.001;\n    float tDeltaMax3 = 0.001;\n    float tDeltaMin3 = 0.001;\n    float tDeltaMax4 = 0.001;\n    float tDeltaMin4 = 0.001;\n    float tDeltaMax5 = 0.001;\n    float tDeltaMin5 = 0.001;\n    float tDeltaMax6 = 0.001;\n    float tDeltaMin6 = 0.001;\n    float tDeltaMax7 = 0.001;\n    float tDeltaMin7 = 0.001;\n    float tDeltaMax8 = 0.001;\n    float tDeltaMin8 = 0.001;\n    float tDeltaMax9 = 0.001;\n    float tDeltaMin9 = 0.001;\n    float tDeltaMax10 = 0.001;\n    float tDeltaMin10 = 0.001;\n    float tDeltaMax11 = 0.001;\n    float tDeltaMin11 = 0.001;\n    float tDeltaMax12 = 0.001;\n    float tDeltaMin12 = 0.001;\n    float tDeltaMax13 = 0.001;\n    float tDeltaMin13 = 0.001;\n    float tDeltaMax14 = 0.001;\n    float tDeltaMin14 = 0.001;\n    float tDeltaMax15 = 0.001;\n    float tDeltaMin15", "\n    vec2 iRes = vec2(0.0);\n    vec2 fRes = vec2(0.0);\n    vec2 tRes = vec2(0.0);\n    vec2 gRes = vec2(0.0);\n    vec2 bRes = vec2(0.0);\n    vec2 dRes = vec2(0.0);\n    vec2 sRes = vec2(0.0);\n    vec2 cRes = vec2(0.0);\n    vec2 eRes = vec2(0.0);\n    vec2 pRes = vec2(0.0);\n    vec2 nRes = vec2(0.0);\n    vec2 hRes = vec2(0.0);\n    vec2 jRes = vec2(0.0);\n    vec2 kRes = vec2(0.0);\n    vec2 lRes = vec2(0.0);\n    vec2 mRes = vec2(0.0);\n    vec2 oRes = vec2(0.0);\n    vec2 qRes = vec2(0.0);\n    vec2 rRes = vec2(0.0);\n    vec2 tRes2 = vec2(0.0);\n    vec2 uRes = vec2(0.0);\n    vec2 vRes = vec2(0.0);\n    vec2 wRes = vec2(0.0);\n    vec2 xRes = vec2(0.0);\n    vec2 yRes = vec2(0.0);\n    vec2 zRes = vec2(0.0);\n    vec2 aRes = vec2(0.0);\n    vec2 bRes2 = vec2(0.0);\n    vec2 cRes2 = vec2(0.0);\n    vec2 dRes2 = vec2(0.0);\n    vec2 eRes2 = vec2(0.0);\n    vec2 fRes2 = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return dot(plane.normal, pos - plane.position);\n}\n\nfloat", "\n    vec3 p = fract(fx);\n    p = p*p*(3.0-2.0*p);\n    return mix(mix(mix(dot(ix,ivec3(1,1,1)),ix.yzx,p.x),\n                  mix(ix.xz,ix.yx,p.x),p.y),\n               mix(mix(ix.zy,ix.yz,p.x),\n                   mix(ix.zx,ix.xy,p.x),p.y),p.z);\n}\n\nfloat", "\n    vec3 fxyz2 = fxyz*fxyz;\n    vec3 fxyz3 = fxyz2*fxyz;\n    vec3 fxyz4 = fxyz3*fxyz;\n    vec3 fxyz5 = fxyz4*fxyz;\n    vec3 fxyz6 = fxyz5*fxyz;\n    vec3 fxyz7 = fxyz6*fxyz;\n    vec3 fxyz8 = fxyz7*fxyz;\n    vec3 fxyz9 = fxyz8*fxyz;\n    vec3 fxyz10 = fxyz9*fxyz;\n    vec3 fxyz11 = fxyz10*fxyz;\n    vec3 fxyz12 = fxyz11*fxyz;\n    vec3 fxyz13 = fxyz12*fxyz;\n    vec3 fxyz14 = fxyz13*fxyz;\n    vec3 fxyz15 = fxyz14*fxyz;\n    vec3 fxyz16 = fxyz15*fxyz;\n    vec3 fxyz17 = fxyz16*fxyz;\n    vec3 fxyz18 = fxyz17*fxyz;\n    vec3 fxyz19 = fxyz18*fxyz;\n    vec3 fxyz20 = fxyz19*fxyz;\n    vec3 fxyz21 = fxyz20*fxyz;\n    vec3 fxyz22 = fxyz21*fxyz;\n    vec3 fxyz23 = fxyz22*fxyz;\n    vec3 fxyz24 = fxyz23*fxyz;\n    vec3 fxyz25 = fxyz24*fxyz;\n    vec3 fxyz26 = fxyz25*fxyz;\n    vec3", "\n    vec3 q = vec3( length(p.xz) - r, p.y );\n    return length(max(abs(q)-vec2(h,0.5),0.0)) - 0.5;\n}\n\nfloat", "\n    float d = sdf(p);\n    return d;\n}\n\nfloat", "\n    return normalize(cross(get_edge(p, 0), get_edge(p, 1)));\n}\n\nvec", "\n    return max(0.0,dot(n,l)*d);\n}\n\nfloat", "\n    float t0 = 0.0;\n    float t1 = 1000000.0;\n    float tmin = 0.001;\n    float tmax = 1000000.0;\n    float t = tmin;\n    float tmin2 = 0.001;\n    float tmax2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min = 0.001;\n    float t2max = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n   ", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    // Initialize the scene\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n}\n\nvoid DrawScene()\n{\n    // Draw the scene\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // Draw the scene\n    glBegin(GL_TRIANGLES);\n    glColor3f(1.0f, 0.0f, 0.0f);\n    glVertex3f(-0.5f, -0.5f, 0.0f);\n    glColor3f(0.0f, 1.0f, 0.0f);\n    glVertex3f(0.5f, -0.5f, 0.0f);\n    glColor3f(0.0f, 0.0f, 1.0f);\n    glVertex3f(0.0f, 0.5f, 0.0f);\n    glEnd();\n}\n\nvoid Reshape(int w, int h)\n{\n    // Reshape the scene\n    glViewport(0, 0, w, h);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0f, (float)w / (float)h, 0.1f, 100.0f);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n}\n\nvoid Keyboard(unsigned char key, int x, int y)\n{\n    // Handle keyboard input\n    switch (key)\n    {\n    case 27:\n        exit(0);\n        break;\n    }\n}\n\nvoid Mouse(int button, int state, int x, int y)\n{\n    // Handle mouse input\n    switch (button)\n    {\n    case GLUT_LEFT_BUTTON", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n    {\n        t = -1.0;\n        return false;\n    }\n    else\n    {\n        float sqrtd = sqrt( discriminant );\n        float root = (-b - sqrtd) / (2.0 * a);\n        if ( root < tmin || tmax < root )\n        {\n            root = (-b + sqrtd) / (2.0 * a);\n            if ( root < tmin || tmax < root )\n            {\n                t = -1.0;\n                return false;\n            }\n        }\n        t = root;\n    }\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize( hitPos - sph.center );\n    return true;\n}\n\nbool IntersectTriangle( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2,\n                        out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross( p - v0, e2 );\n    float a = dot( e1, h );\n    if ( a > -0.0001 && a < 0.0001 )\n        return false;    // This ray is parallel to this triangle.\n    float f = 1.0 / a;\n    vec3 s = p - v0;\n    float u = f * dot( s, h );\n    if ( u < 0.0 || u > 1.0 )\n        return false;\n    vec3 q = cross( s, e1 );\n    float v = f *", "\n    float t0, t1;\n    float a = Dot( ray.dir, ray.dir );\n    float b = 2.0f * Dot( ray.dir, ray.org - sph.center );\n    float c = Dot( ray.org - sph.center, ray.org - sph.center ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n    if ( discriminant < 0.0f )\n        return false;\n    else\n    {\n        discriminant = sqrtf( discriminant );\n        t0 = ( -b - discriminant ) / ( 2.0f * a );\n        t1 = ( -b + discriminant ) / ( 2.0f * a );\n        if ( t0 > t1 )\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if ( t0 < tmin )\n            t0 = tmin;\n        if ( t1 > tmax )\n            t1 = tmax;\n        if ( t0 > t1 )\n            return false;\n        else\n            return true;\n    }\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t0, t1;\n    float a = tri.v0.x - tri.v1.x;\n    float b = tri.v0.y - tri.v1.y;\n    float c = tri.v0.z - tri.v1.z;\n    float d = tri.v0.x - tri.v2.x;\n    float e = tri.v0.y - tri.v2.y;\n    float f = tri.v0.z - tri.v2.z;\n    float g = ray.dir.x;\n    float h = ray.dir.y;\n    float i = ray.dir.z;\n    float j = tri.v0.x - ray.org.x;\n    float k = tri.v0", "\n    vec3 k_rg_min = vec3( 0.0 );\n    vec3 k_rg_max = vec3( 0.0 );\n    vec3 k_rg_min_t = vec3( 0.0 );\n    vec3 k_rg_max_t = vec3( 0.0 );\n    vec3 k_rg_min_t_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid main()\n{\n    vec3 ro = camera.position;\n    vec3 rd = normalize( camera.direction + camera.right * uv.x + camera.up * uv.y );\n\n    vec3 col = vec3( 0.0 );\n    vec3 light = vec3( 0.0 );\n\n    vec3 p = ro + rd * 10.0;\n    vec3 n = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    float t = map( p, 0.0, 100.0 );\n    p = ro + rd * t;\n    float d = map( p, 0.0, 100.0 );\n    float s = calcSoftshadow( p, rd, 0.0, 10.0 );\n    col = vec3( 0.0, 0.0, 0.0 );\n    if( d < 10.0 )\n    {\n        col = vec3( 0.0, 0.0, 0.0 );\n        light = vec3( 0.0, 0.0, 0.0 );\n    }\n    else\n    {\n        col = vec3( 0.0, 0.0, 0.0 );\n        light = vec3( 0.0, 0.0, 0.0 );\n    }\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec", "\n\tvec3 color = vec3(0.0);\n\tvec3 ray_dir = normalize(dir);\n\tvec3 ray_start = start;\n\tvec3 ray_end = ray_start + ray_dir * max_dist;\n\tvec3 ray_color = vec3(0.0);\n\tvec3 ray_end_color = vec3(0.0);\n\tvec3 ray_end_color_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_", "\n    vec3 light_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    float light_dist = length(light_dir);\n    float attenuation = 1.0 / (light_dist * light_dist);\n    float diffuse_strength = max(0.0, dot(surface_normal, light_dir_norm));\n    vec3 diffuse_col = vec3(0.0);\n    if (diffuse_strength > 0.0) {\n        diffuse_col = vec3(1.0, 1.0, 1.0) * diffuse_strength * attenuation;\n    }\n    vec3 view_dir = normalize(sample_pos - camera_pos);\n    vec3 reflect_dir = reflect(-light_dir_norm, surface_normal);\n    float specular_strength = pow(max(0.0, dot(view_dir, reflect_dir)), 32.0);\n    vec3 specular_col = vec3(0.0);\n    if (specular_strength > 0.0) {\n        specular_col = vec3(1.0, 1.0, 1.0) * specular_strength * attenuation;\n    }\n    light_col = diffuse_col + specular_col;\n    return light_col;\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 ambient_color = vec3(0.1);\n    vec3 diffuse_color = vec3(0.5);\n    vec3 specular_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_spec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv - 0.5;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.5) * 2.0;\n    float t = mod(iTime, 1.0);\n    float s = sin(t * 3.14159265359);\n    float c = cos(t * 3.14159265359);\n    float aa = a * 0.5 + 0.5;\n    float rr = r * 0.5 + 0.5;\n    float aa2 = aa * 0.5 + 0.5;\n    float rr2 = rr * 0.5 + 0.5;\n    float aa3 = aa * 0.5 + 0.5;\n    float rr3 = rr * 0.5 + 0.5;\n    float aa4 = aa * 0.5 + 0.5;\n    float rr4 = rr * 0.5 + 0.5;\n    float aa5 = aa * 0.5 + 0.5;\n    float rr5 = rr * 0.5 + 0.5;\n    float aa6 = aa * 0.5 + 0.5;\n    float rr6 = rr * 0.5 + 0.5;\n    float aa7 = aa * 0.5 + 0.5;\n    float rr7 = rr * 0.5 + 0.5;\n    float aa8 = aa * 0.5 + 0.5;\n    float rr8 = rr * 0.5 + 0.5;\n    float aa9 = aa * 0.5 + 0.5;\n    float rr9 = rr * 0.5 + 0.5;\n    float aa10 = aa * 0.5 + 0.5;\n    float rr10 = rr * ", "\n    vec3 oc = r0 - s0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightSpotDir = vec3(0.0);\n    vec3 lightSpotColor = vec3(0.0);\n    vec3 lightSpotIntensity = vec3(0.0);\n    vec3 lightSpotAttenuation = vec3(0.0);\n    vec3 lightSpotDir2 = vec3(0.0);\n    vec3 lightSpotColor2 = vec3(0.0);\n    vec3 lightSpotIntensity2 = vec3(0.0);\n    vec3 lightSpotAttenuation2 = vec3(0.0);\n    vec3 lightSpotDir3 = vec3(0.0);\n    vec3 lightSpotColor3 = vec3(0.0);\n    vec3 lightSpotIntensity3 = vec3(0.0);\n    vec3 lightSpotAttenuation3 = vec3(0.0);\n    vec3 lightSpotDir4 = vec3(0.0);\n    vec3 lightSpotColor4 = vec3(0.0);\n    vec3 lightSpotIntensity4 = vec3(0.0);\n    vec3 lightSpotAttenuation4 = vec3(0.0);\n    vec3 lightSpotDir5 = vec3(0.0);\n    vec3 lightSpotColor5 = vec3(0.0);\n    vec3 lightSpotIntensity5 = vec3(0.0);\n    vec3 lightSpotAttenuation5 = vec3(0.0);\n    vec3 lightSpotDir6 = vec3(0.0);\n    vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float t = 0.0;\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        vec3 intersection = ray_origin + t * ray_direction;\n        float distance = length(intersection - ray_origin);\n        if (distance < EPSILON) {\n            return intersection;\n        }\n        t += distance;\n    }\n    return vec3(0.0);\n}\n\nvec", "\n    vec3 c = vec3(0.0);\n    float t = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        t += a;\n        a *= 0.5;\n        c += jigsaw_noise(p * t) * a;\n    }\n    return c;\n}\n\nvoid main()\n{\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 p = st;\n    float t = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        t += a;\n        a *= 0.5;\n        color += jigsaw_noise(p * t) * a;\n    }\n    gl_FragColor = vec4(color, 1.0);\n}", "\n    return sqrt(pow(p.x, 2) + pow(p.y, 2) + pow(p.z, 2));\n}\n\nvec", "\n    vec3 Pi = floor( P );\n    vec3 Pf = fract( P );\n    vec3 Px = Pf.x + vec3( 1.0, 0.0, 1.0 );\n    vec3 Py = Pf.y + vec3( 1.0, 1.0, 0.0 );\n    vec3 Pz = Pf.z + vec3( 0.0, 1.0, 1.0 );\n    vec3 Pw = Pf.z + vec3( 1.0, 0.0, 1.0 );\n    vec3 Pn = Pf.z + vec3( -1.0, 0.0, 1.0 );\n    vec3 Pt = Pf.z + vec3( 1.0, -1.0, 0.0 );\n    vec3 Pb = Pf.z + vec3( -1.0, -1.0, 0.0 );\n    vec3 Pq = Pf.z + vec3( 1.0, 1.0, -1.0 );\n    vec3 Pr = Pf.z + vec3( -1.0, 1.0, -1.0 );\n    vec3 Pu = Pf.z + vec3( 1.0, -1.0, -1.0 );\n    vec3 Pv = Pf.z + vec3( -1.0, 1.0, -1.0 );\n    vec4 Pi0 = texture( iChannel0, Pi );\n    vec4 Pi1 = texture( iChannel0, Pi + vec3( 1.0, 0.0, 0.0 ) );\n    vec4 Pi2 = texture( iChannel0, Pi + vec3( 0.0, 1.0, 0.0 ) );\n    vec4 Pi3 = texture( iChannel0, Pi + vec3( 1.0, 1.0, 0.0 ) );\n    vec4 Pi4 = texture( iChannel0, Pi +", "\n    return fract(sin(x)*43758.5453);\n}\n\nfloat", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    float t = (p.x - a.x) / (b.x - a.x);\n    if (t < 0.0) return d;\n    if (t > 1.0) return d;\n    return mix(d, 0.0, 1.0 - t);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return texture2D(tex, p).r;\n}\n\nvoid main(){\n    vec2 p = (gl_FragCoord.xy / resolution.xy);\n    vec2 p2 = p * 2.0 - 1.0;\n    vec2 p3 = p2 * 2.0 - 1.0;\n    vec2 p4 = p3 * 2.0 - 1.0;\n    vec2 p5 = p4 * 2.0 - 1.0;\n    vec2 p6 = p5 * 2.0 - 1.0;\n    vec2 p7 = p6 * 2.0 - 1.0;\n    vec2 p8 = p7 * 2.0 - 1.0;\n    vec2 p9 = p8 * 2.0 - 1.0;\n    vec2 p10 = p9 * 2.0 - 1.0;\n    vec2 p11 = p10 * 2.0 - 1.0;\n    vec2 p12 = p11 * 2.0 - 1.0;\n    vec2 p13 = p12 * 2.0 - 1.0;\n    vec2 p14 = p13 * 2.0 - 1.0;\n    vec2 p15 = p14 * 2.0 - 1.0;\n    vec2 p16 = p15 * 2.0 - 1.0;\n    vec2 p17 = p16 * 2.0 - 1.0;\n    vec2 p18 = p17 * 2.0 - 1.0;\n    vec2 p19 = p18 * 2.0 - 1.0;\n    vec2 p20 = p19 * 2.0 - 1.0;\n    vec2 p21 = p20 * 2.0 - 1.0;\n    vec2 p22 = p21 * 2.0 - 1.0;\n    vec2 p", "\n    return (1.0 - cos(2.0 * PI * ix)) * (1.0 - cos(2.0 * PI * iy));\n}\n\nfloat", "\n    vec3 color = vec3( 0.0 );\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( pos );\n        t += d;\n        pos = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 10.0 * t );\n    return color;\n}\n\nvoid main()\n{\n    vec3 color = vec3( 0.0 );\n    vec3 p = vec3( 0.0 );\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( p );\n        t += d;\n        p = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 10.0 * t );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    return 1.0 - smoothstep(0.0, 1.0, p);\n}\n\nfloat", "\n    return vec2(\n        atan(z.y, z.x),\n        sqrt(z.x * z.x + z.y * z.y)\n    );\n}\n\nvec", "\n    return (vec2){z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x};\n}\n\nvec", "\n    return dot(p, vec3(127.1, 311.7, 723.5));\n}\n\nfloat", "\n    float wave = sin( p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    return wave;\n}\n\nvoid main()\n{\n    vec3 p = vec3( gl_FragCoord.xy, 0.0 );\n    vec3 color = vec3( 0.0 );\n    float wave = waveDisplacement( p );\n    color = vec3( wave );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    float a = atan( p.y, p.x ) / PI;\n    float r = length( p );\n    float h = map( r );\n    return vec3( a, h, r );\n}\n\nvec", "\n    float t = dot(rp, rp) - 1.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t4", "\n    return (d - start) / (end - start);\n}\n\nfloat", "\n    vec4 color = vec4(0.0);\n    color.r = p.x;\n    color.g = p.y;\n    color.b = 0.0;\n    color.a = 1.0;\n    return color;\n}\n\nvec", "\n    return vec2(p.x*p.x,p.y*p.y);\n}\n\nvec", "\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);", "\n    float x = pc.x;\n    float y = pc.y;\n    float r = sqrt(x*x + y*y);\n    float theta = atan2(y,x);\n    float d = (r - a) / (b - a);\n    if(d > 1) return 0;\n    if(d < 0) return 0;\n    return 1;\n}\n\nfloat", "\n    return smoothstep(0.0, 1.0, abs(st.x - pct));\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float pct = plot(st, 0.0);\n    color = mix(vec3(1.0), vec3(0.0), pct);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n    vec2 q = p - circ.xy;\n    float r = circ.z;\n    return vec2(\n        r * q.x * (1.0 - q.y * q.y) + circ.x,\n        r * q.y * (1.0 - q.x * q.x) + circ.y\n    );\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy / resolution.xy) - vec2(0.5);\n    vec2 q = p * 2.0;\n    vec2 r = vec2(0.0);\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n    vec2 u = vec2(0.0);\n    vec2 v = vec2(0.0);\n    vec2 w = vec2(0.0);\n    vec2 x = vec2(0.0);\n    vec2 y = vec2(0.0);\n    vec2 z = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d = vec2(0.0);\n    vec2 e = vec2(0.0);\n    vec2 f = vec2(0.0);\n    vec2 g = vec2(0.0);\n    vec2 h = vec2(0.0);\n    vec2 i = vec2(0.0);\n    vec2 j = vec2(0.0);\n    vec2 k = vec2(0.0);\n    vec2 l = vec2(0.0);\n    vec2 m = vec2(0.0);\n    vec2 n = vec2(0.0);\n    vec2 o = vec2(0.0);\n    vec2 p0 = vec2(0.0);\n", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAmbient = vec3(0.0);\n    vec3 lightDiffuse = vec3(0.0);\n    vec3 lightSpecular = vec3(0.0);\n    vec3 lightAttenuationQuadratic = vec3(0.0);\n    vec3 lightAttenuationLinear = vec3(0.0);\n    vec3 lightAttenuationConstant = vec3(0.0);\n    vec3 lightAmbientQuadratic = vec3(0.0);\n    vec3 lightDiffuseQuadratic = vec3(0.0);\n    vec3 lightSpecularQuadratic = vec3(0.0);\n    vec3 lightAmbientLinear = vec3(0.0);\n    vec3 lightDiffuseLinear = vec3(0.0);\n    vec3 lightSpecularLinear = vec3(0.0);\n    vec3 lightAttenuationConstantQuadratic = vec3(0.0);\n    vec3 lightAttenuationConstantLinear = vec3(0.0);\n    vec3 lightAttenuationConstantConstant = vec3(0.0);\n    vec3 lightAmbientConstant = vec3(0.0);\n    vec3 lightDiffuseConstant = vec3(0.0);\n    vec3 lightSpecularConstant = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = mod(a, 2.0 * PI);\n    float t = mod(a / (2.0 * PI), 1.0);\n    float c = cos(r);\n    float s = sin(r);\n    float n = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float r2 = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float g = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float b = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n\n    col = vec3(r2, g, b);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return vec3(hash, hash, hash);\n}\n\nvec", "\n    return bccNoise_PlaneFirst(X.x, X.y, X.z);\n}\n\nvec", "\n    float d = scene(p);\n    if (d < eps) {\n        return 0.0;\n    }\n    return d;\n}\n\nfloat", "\n\t\tfloat t = ( targetPos - ray.origin ).Dot( ray.direction ) / ray.direction.Dot( ray.direction );\n\t\treturn ray.origin + t * ray.direction;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos );\n\t\tfloat distance = ( closestPoint - targetPos ).Length();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos, radius );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tnormal = ( closestPoint - targetPos ).Normalize();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal, out vec3 tangent ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos, radius );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tnormal = ( closestPoint - targetPos ).Normalize();\n\t\ttangent = ( closestPoint - targetPos ).Cross( normal ).Normalize();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal, out vec3 tangent, out vec3 bitang", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    vec4 p4 = vec4(p, 1.0);\n    p4 = p4 * 2.0 - 1.0;\n    p4.y = -p4.y;\n    p4 = p4 * 0.5 + 0.5;\n    return p4;\n}\n\nvec", "\n    float t = ( targetPos - ray.origin ).length() / ray.direction.length();\n    float d = ( targetPos - ray.origin ).dot( ray.direction );\n    float r = lightDiameter / 2.0;\n    float a = r * r / ( r * r + ( t - d ) * ( t - d ) );\n    float b = sqrt( 1.0 - a * a );\n    float c = ( t - d ) * b;\n    float d1 = c * ( 1.0 - a ) + a;\n    float d2 = c * a - 1.0;\n    float d3 = ( t - d ) * ( 1.0 - b ) + b;\n    float d4 = ( t - d ) * b - 1.0;\n    float d5 = ( t - d ) * ( 1.0 - a ) - a;\n    float d6 = c * ( 1.0 - b ) - b;\n    float d7 = c * b - 1.0;\n    float d8 = ( t - d ) * b - 1.0;\n    float d9 = ( t - d ) * ( 1.0 - b ) - b;\n    float d10 = ( t - d ) * b - 1.0;\n    float d11 = c * ( 1.0 - a ) - a;\n    float d12 = c * a - 1.0;\n    float d13 = ( t - d ) * ( 1.0 - b ) - b;\n    float d14 = ( t - d ) * b - 1.0;\n    float d15 = ( t - d ) * ( 1.0 - a ) - a;\n    float d16 = c * ( 1.0 - b ) - b;\n    float d17 = c * b - 1.0;\n    float d18 = ( t - d ) * b - 1.0;\n    float d19 = ( t - d ) * ( 1.0 - b ) - b;\n    float d20 = ( t - d ) * b - 1.0;\n   ", "\n    return vec2(\n        abs(p.x) - 1.0,\n        abs(p.y) - 1.0\n    );\n}\n\nvec", "\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    return (v >= 0 && v <= 1) && (w >= 0 && w <= 1);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p1 = vec2(0.0, 0.0);\n    vec2 p2 = vec2(resolution.x, 0.0);\n    vec2 p3 = vec2(resolution.x, resolution.y);\n    if (in_triangle(p1, p2, p3, uv)) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    vec2 p = uv - vec2(0.5);\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    float t = atan(p.y, p.x) / (2.0 * PI);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r6 * r2;\n    float r10 = r8 * r2;\n    float r12 = r10 * r2;\n    float r14 = r12 * r2;\n    float r16 = r14 * r2;\n    float r18 = r16 * r2;\n    float r20 = r18 * r2;\n    float r22 = r20 * r2;\n    float r24 = r22 * r2;\n    float r26 = r24 * r2;\n    float r28 = r26 * r2;\n    float r30 = r28 * r2;\n    float r32 = r30 * r2;\n    float r34 = r32 * r2;\n    float r36 = r34 * r2;\n    float r38 = r36 * r2;\n    float r40 = r38 * r2;\n    float r42 = r40 * r2;\n    float r44 = r42 * r2;\n    float r46 = r44 * r2;\n    float r48 = r46 * r2;\n    float r50 = r48 * r2;\n    float r52 = r50 * r2;\n    float r54 = r52 * r2;\n    float r56 = r54 * r2;\n    float r58 = r56 * r2;\n    float r60 = r58 * r2;\n    float r62 = r60 * r2;\n    float", "\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    float angle_offset = rotation * 2.0 * PI;\n    float angle_offset_2 = angle_offset * 2.0;\n    float angle_offset_3 = angle_offset * 3.0;\n    float angle_offset_4 = angle_offset * 4.0;\n    float angle_offset_5 = angle_offset * 5.0;\n    float angle_offset_6 = angle_offset * 6.0;\n    float angle_offset_7 = angle_offset * 7.0;\n    float angle_offset_8 = angle_offset * 8.0;\n    float angle_offset_9 = angle_offset * 9.0;\n    float angle_offset_10 = angle_offset * 10.0;\n    float angle_offset_11 = angle_offset * 11.0;\n    float angle_offset_12 = angle_offset * 12.0;\n    float angle_offset_13 = angle_offset * 13.0;\n    float angle_offset_14 = angle_offset * 14.0;\n    float angle_offset_15 = angle_offset * 15.0;\n    float angle_offset_16 = angle_offset * 16.0;\n    float angle_offset_17 = angle_offset * 17.0;\n    float angle_offset_18 = angle_offset * 18.0;\n    float angle_offset_19 = angle_offset * 19.0;\n    float angle_offset_20 = angle_offset * 20.0;\n    float angle_offset_21 = angle_offset * 21.0;\n    float angle_offset_22 = angle_offset * 22.0;\n    float angle_offset_23 = angle_offset * 23.0;\n    float angle_offset_24 = angle_offset * 24.0;\n    float angle_offset_25 = angle_offset * 25.0;\n    float angle_", "\n    vec2 p = vec2(0.5) - uv;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n    p.x *= circumradius;\n    p.y *= circumradius;\n    p = abs(p);\n    float d = length(p);\n    return step(d, r);\n}\n\nfloat", "\n    float r = sqrt(U.x * U.x + U.y * U.y);\n    float phi = atan2(U.y, U.x);\n    float a = 0.0;\n    float b = 1.0;\n    for (int i = 0; i < 100; i++) {\n        float c = (a + b) / 2.0;\n        if (r * c < d) a = c;\n        else b = c;\n    }\n    return a;\n}\n\nfloat", "\n    return (n * 11) % 1000000007;\n}\n\nuint hash2(uint n)\n{\n    return (n * 13) % 1000000007;\n}\n\nuint hash3(uint n)\n{\n    return (n * 17) % 1000000007;\n}\n\nuint hash4(uint n)\n{\n    return (n * 19) % 1000000007;\n}\n\nuint hash5(uint n)\n{\n    return (n * 23) % 1000000007;\n}\n\nuint hash6(uint n)\n{\n    return (n * 29) % 1000000007;\n}\n\nuint hash7(uint n)\n{\n    return (n * 31) % 1000000007;\n}\n\nuint hash8(uint n)\n{\n    return (n * 37) % 1000000007;\n}\n\nuint hash9(uint n)\n{\n    return (n * 41) % 1000000007;\n}\n\nuint hash10(uint n)\n{\n    return (n * 43) % 1000000007;\n}\n\nuint hash11(uint n)\n{\n    return (n * 47) % 1000000007;\n}\n\nuint hash12(uint n)\n{\n    return (n * 53) % 1000000007;\n}\n\nuint hash13(uint n)\n{\n    return (n * 59) % 1000000007;\n}\n\nuint hash14(uint n)\n{\n    return (n * 61) % 1000000007;\n}\n\nuint hash15(uint n)\n{\n   ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec3 normal = vec3(0.0);\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    normal.x = calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy);\n    normal.y = calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy);\n    normal.z = calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx);\n    return normalize(normal);\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, calcHeight(gl_FragCoord.xy));\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    float shininess = 10.0;\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float distance = length(pos);\n    float attenuationFactor = 1.0 / (1.0 + attenuation * distance);\n    intensity = max(dot(normal, lightDir), 0.0);\n    intensity = intensity * attenuationFactor;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    if (intensity > 0.0) {\n        diffuse = vec3(0.0, 0.0, 0.0);\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float specularFactor = pow(max(dot(normal, halfVector), 0.0), shininess);\n        specular = vec3(0.0, 0.0, 0.0);\n        if (specularFactor > 0.0", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col,", "\n    vec3 normal = vec3(0.0);\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    normal.x = calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy);\n    normal.y = calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy);\n    normal.z = calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx);\n    return normalize(normal);\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, calcHeight(gl_FragCoord.xy));\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    float shininess = 10.0;\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float distance = length(pos);\n    float attenuationFactor = 1.0 / (1.0 + attenuation * distance);\n    intensity = max(dot(normal, lightDir), 0.0);\n    intensity = intensity * attenuationFactor;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    if (intensity > 0.0) {\n        diffuse = vec3(0.0, 0.0, 0.0);\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float specularFactor = pow(max(dot(normal, halfVector), 0.0), shininess);\n        specular = vec3(0.0, 0.0, 0.0);\n        if (specularFactor > 0.0", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col,", "\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        estimateHeight(p + e.yxx) - estimateHeight(p - e.yxx),\n        estimateHeight(p + e.xyx) - estimateHeight(p - e.xyx),\n        estimateHeight(p + e.xxy) - estimateHeight(p - e.xxy)\n    ));\n}\n\nfloat", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    vec3 c = texture2D( material, coord ).rgb;\n    if ( c.r == 0.0 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return false;\n    }\n    color = c;\n    return true;\n}\n\nvoid main() {\n    vec3 color;\n    if ( getMaterialColor( 0, gl_TexCoord[0].st, color ) ) {\n        gl_FragColor = vec4( color, 1.0 );\n    } else {\n        gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n}\n", "\n    vec2 q = vec2( dot(p, ab), p.x );\n    return vec2( length(q) - ab.y, dot(q, q) - ab.x );\n}\n\nfloat", "\n    return vec3(fmod(p, 1.0), fmod(p + 1.0, 1.0), fmod(p + 2.0, 1.0));\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    float tmin = -1.0;\n    float tmax = 1.0;\n    float tymin = (1.0 - raypos.y) / raypos.z;\n    float tymax = (1.0 - raypos.y) / raypos.z;\n    if (tymin > tmax)\n        std::swap(tymin, tmax);\n    if (tymin > tymin)\n        tymin = tymin;\n    if (tymax < tmax)\n        tmax = tymax;\n    float tzmin = (1.0 - raypos.z) / raypos.w;\n    float tzmax = (1.0 - raypos.z) / raypos.w;\n    if (tzmin > tmax)\n        std::swap(tzmin, tmax);\n    if (tzmin > tzmax)\n        tzmax = tzmin;\n    if (tmin > tzmin)\n        tmin = tzmin;\n    if (tmax < tzmax)\n        tmax = tzmax;\n    return tmin;\n}\n\nvec", "\n\trotmat[0][0] = cos(rotation.x) * cos(rotation.y);\n\trotmat[0][1] = cos(rotation.x) * sin(rotation.y);\n\trotmat[0][2] = -sin(rotation.x);\n\trotmat[1][0] = sin(rotation.x) * cos(rotation.y);\n\trotmat[1][1] = sin(rotation.x) * sin(rotation.y);\n\trotmat[1][2] = cos(rotation.x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2][2] = 1;\n}\n\nvoid mat3::rotate(vec3 rotation){\n\trotmat[0][0] = cos(rotation.x) * cos(rotation.y);\n\trotmat[0][1] = cos(rotation.x) * sin(rotation.y);\n\trotmat[0][2] = -sin(rotation.x);\n\trotmat[1][0] = sin(rotation.x) * cos(rotation.y);\n\trotmat[1][1] = sin(rotation.x) * sin(rotation.y);\n\trotmat[1][2] = cos(rotation.x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2][2] = 1;\n}\n\nvoid mat3::rotate(float x, float y, float z){\n\trotmat[0][0] = cos(x) * cos(y);\n\trotmat[0][1] = cos(x) * sin(y);\n\trotmat[0][2] = -sin(x);\n\trotmat[1][0] = sin(x) * cos(y);\n\trotmat[1][1] = sin(x) * sin(y);\n\trotmat[1][2] = cos(x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2", "\n    vec4 raypos = rayori;\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec4 pos = raypos;\n        pos.xyz += raydir.xyz * t;\n        if(pos.w < 0.0) break;\n        t += raydir.w;\n    }\n    return pos;\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec2 texCoord = uv.xy;\n    float time = iGlobalTime;\n    float offset = time * 0.001;\n    float offset2 = time * 0.002;\n    float offset3 = time * 0.003;\n    float offset4 = time * 0.004;\n    float offset5 = time * 0.005;\n    float offset6 = time * 0.006;\n    float offset7 = time * 0.007;\n    float offset8 = time * 0.008;\n    float offset9 = time * 0.009;\n    float offset10 = time * 0.01;\n    float offset11 = time * 0.011;\n    float offset12 = time * 0.012;\n    float offset13 = time * 0.013;\n    float offset14 = time * 0.014;\n    float offset15 = time * 0.015;\n    float offset16 = time * 0.016;\n    float offset17 = time * 0.017;\n    float offset18 = time * 0.018;\n    float offset19 = time * 0.019;\n    float offset20 = time * 0.02;\n    float offset21 = time * 0.021;\n    float offset22 = time * 0.022;\n    float offset23 = time * 0.023;\n    float offset24 = time * 0.024;\n    float offset25 = time * 0.025;\n    float offset26 = time * 0.026;\n    float offset27 = time * 0.027;\n    float offset28 = time * 0.028;\n    float offset29 = time * 0.029;\n    float offset30 = time * 0.03;\n    float offset31", "\n    vec3 raypos = rayori;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float tmin_tmax[2];\n    for(int i = 0; i < 100; i++){\n        tmin_tmax[0] = tmin;\n        tmin_tmax[1] = tmax;\n        t = raymarch(raypos, raydir, tmin_tmax);\n        if(t < tmin_tmax[0]){\n            tmin_tmax[0] = t;\n        }\n        if(t > tmin_tmax[1]){\n            tmin_tmax[1] = t;\n        }\n        if(tmin_tmax[1] - tmin_tmax[0] < 0.001){\n            break;\n        }\n        tmin = tmin_tmax[0];\n        tmax = tmin_tmax[1];\n    }\n    return raypos + raydir * t;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    float strength = maxStrength * sin(frequency * coord.x + time * travelRate);\n    return strength;\n}\n\nvoid main()\n{\n    vec2 coord = gl_FragCoord.xy / resolution.xy;\n    vec2 coord2 = coord * 2.0 - 1.0;\n    vec2 coord3 = coord2 * 2.0 - 1.0;\n    vec2 coord4 = coord3 * 2.0 - 1.0;\n    vec2 coord5 = coord4 * 2.0 - 1.0;\n    vec2 coord6 = coord5 * 2.0 - 1.0;\n    vec2 coord7 = coord6 * 2.0 - 1.0;\n    vec2 coord8 = coord7 * 2.0 - 1.0;\n    vec2 coord9 = coord8 * 2.0 - 1.0;\n    vec2 coord10 = coord9 * 2.0 - 1.0;\n    vec2 coord11 = coord10 * 2.0 - 1.0;\n    vec2 coord12 = coord11 * 2.0 - 1.0;\n    vec2 coord13 = coord12 * 2.0 - 1.0;\n    vec2 coord14 = coord13 * 2.0 - 1.0;\n    vec2 coord15 = coord14 * 2.0 - 1.0;\n    vec2 coord16 = coord15 * 2.0 - 1.0;\n    vec2 coord17 = coord16 * 2.0 - 1.0;\n    vec2 coord18 = coord17 * 2.0 - 1.0;\n    vec2 coord19 = coord18 * 2.0 - 1.0;\n    vec2 coord20 = coord19 * 2.0 - 1.0;\n    vec2 coord21 = coord20 * 2.0 - 1.0;\n    vec2 coord22 = coord21 * ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec2 p1 = p + d;\n    vec2 p2 = p + d + vec2(0.0, 1.0);\n    vec2 p3 = p + d + vec2(1.0, 0.0);\n    vec2 p4 = p + d + vec2(1.0, 1.0);\n    vec2 p5 = p + d + vec2(0.0, 2.0);\n    vec2 p6 = p + d + vec2(1.0, 2.0);\n    vec2 p7 = p + d + vec2(2.0, 1.0);\n    vec2 p8 = p + d + vec2(2.0, 0.0);\n    vec2 p9 = p + d + vec2(2.0, 2.0);\n    vec2 p10 = p + d + vec2(3.0, 1.0);\n    vec2 p11 = p + d + vec2(3.0, 0.0);\n    vec2 p12 = p + d + vec2(3.0, 2.0);\n    vec2 p13 = p + d + vec2(4.0, 1.0);\n    vec2 p14 = p + d + vec2(4.0, 0.0);\n    vec2 p15 = p + d + vec2(4.0, 2.0);\n    vec2 p16 = p + d + vec2(5.0, 1.0);\n    vec2 p17 = p + d + vec2(5.0, 0.0);\n    vec2 p18 = p + d + vec2(5.0, 2.0);\n    vec2 p19 = p + d + vec2(6.0, 1.0);\n    vec2 p20 = p + d + vec2(6.0, 0.0);\n    vec2 p21 = p + d + ve", "\n    return color * (1.0 - filmic_exposure) + vec3(1.0) * filmic_exposure;\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_texcoord).rgb;\n    vec3 filmic_color = filmic(color);\n    vec3 gamma = vec3(1.0 / 2.2);\n    vec3 gamma_color = pow(filmic_color, gamma);\n    out_color = vec4(gamma_color, 1.0);\n}\n", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = clamp( dot( ap, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    return sdSegment( p, a, b ) - w1 * ( 1.0 - t ) - w2 * t;\n}\n\nfloat", "\n    vec2 q = uv - p;\n    return vec3( length(q) - 0.02, 0.0, 0.0 );\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 col = vec3(0.0);\n    col += blob(uv, p);\n    col += blob(uv, p + vec2(0.0, 1.0));\n    col += blob(uv, p + vec2(1.0, 0.0));\n    col += blob(uv, p + vec2(1.0, 1.0));\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n\tfloat t = falloff * rnd.x;\n\treturn vec3( 1.0 - smoothstep( 0.0, 1.0, t ), 1.0 - smoothstep( 0.0, 1.0, t ), 1.0 - smoothstep( 0.0, 1.0, t ) );\n}\n\nvoid main()\n{\n\tvec3 rnd = vec3( 0.0 );\n\trnd.x = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\trnd.y = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\trnd.z = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\n\tvec3 color = vec3( 0.0 );\n\tcolor += pulse( 0.0, rnd );\n\tcolor += pulse( 0.1, rnd );\n\tcolor += pulse( 0.2, rnd );\n\tcolor += pulse( 0.3, rnd );\n\tcolor += pulse( 0.4, rnd );\n\tcolor += pulse( 0.5, rnd );\n\tcolor += pulse( 0.6, rnd );\n\tcolor += pulse( 0.7, rnd );\n\tcolor += pulse( 0.8, rnd );\n\tcolor += pulse( 0.9, rnd );\n\tcolor += pulse( 1.0, rnd );\n\n\tgl_FragColor = vec4( color, 1.0 );\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return vec3(fmod(p, 1.0), fmod(p + 1.0, 1.0), fmod(p + 2.0, 1.0));\n}\n\nvec", "\n    return (1.0f - expf(-2.0f * x)) / (1.0f + expf(-2.0f * x));\n}\n\nfloat", "\n    vec2 uv = q;\n    uv.y = 1.0 - uv.y;\n    vec3 c = texture2D(u_texture, uv).rgb;\n    return mix(col, c, 0.2);\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n\n    col = postProcess(col, q);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), q.z) - 1.0;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s ="]}