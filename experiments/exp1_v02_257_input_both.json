{"input_both": [[{"generated_text": "\n\treturn max(0.0,cos(a)*2-1);\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) =.5, fsin(2/3) =.5\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat"}], [{"generated_text": "\n    vec3 q = p;\n    q.xz = Rotate(q.xz, rotDir, rotSpeed);\n    q.y = Rotate(q.y, rotDir, rotSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 r = p;\n    r.xz = Rotate(r.xz, scaleDir, scaleSpeed);\n    r.y = Rotate(r.y, scaleDir, scaleSpeed);\n\n    // Translate, but only the part that is on the side of transDir\n    vec3 s = p;\n    s.xz = Rotate(s.xz, transDir, transSpeed);\n    s.y = Rotate(s.y, transDir, transSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 t = p;\n    t.xz = Rotate(t.xz, scaleDir, scaleSpeed);\n    t.y = Rotate(t.y, scaleDir, scaleSpeed);\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 u = p;\n    u.xz = Rotate(u.xz, rotDir, rotSpeed);\n    u.y = Rotate(u.y, rotDir, rotSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 v = p;\n    v.xz = Rotate(v.xz, scaleDir, scaleSpeed);\n    v.y = Rotate(v.y, scaleDir, scaleSpeed);\n\n    // Translate, but only the part that is on the side of transDir\n    vec3 w = p;\n    w.xz = Rotate(w.xz, transDir, transSpeed);\n    w.y = Rotate(w.y, transDir, transSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 x = p;\n    x.xz = Rotate(x.xz, scaleDir, scaleSpeed);\n    x.y ="}], [{"generated_text": "\n\tglowCounter += (1.0 - glowCounter) * (1.0 - glowCounter);\n\n\t// Get the voxel position\n\tvec3 voxelPos = floor(p);\n\n\t// Get the voxel size\n\tfloat voxelSize = voxelSizeF;\n\n\t// Get the voxel color\n\tvec4 voxelColor = texture(voxelTexture, voxelPos.xy / voxelSize);\n\n\t// Get the voxel distance\n\tfloat voxelDist = length(p - voxelPos);\n\n\t// Get the voxel glow\n\tfloat voxelGlow = glowCounter;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity = voxelColor.a;\n\n\t// Get the voxel distance\n\tfloat voxelDist2 = voxelDist * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow2 = voxelGlow * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity2 = voxelOpacity * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist3 = voxelDist2 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow3 = voxelGlow2 * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity3 = voxelOpacity2 * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist4 = voxelDist3 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow4 = voxelGlow3 * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity4 = voxelOpacity3 * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist5 = voxelDist4 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow5 = voxelGlow4 * voxelG"}], [{"generated_text": "\n\tglowCounter += 1.0;\n\n\t// Get the distance to the scene\n\tfloat d = scene(p);\n\n\t// Get the closest point on the scene\n\tP = vec3(p.x, p.y, d);\n\n\t// Return the distance to the scene\n\treturn vec2(d, glowCounter);\n}\n\n// Distance to the scene and color of the closest point\nvec"}], [{"generated_text": " position in the pixel\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\t// Get the fragment position in the screen\n\tvec2 p_screen = (p * 2.0) - 1.0;\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n"}], [{"generated_text": "\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\n\t// this is a bit of a hack to get the color gradient to work\n\t// the color values are in the range 0.0 to 1.0\n\t// the x value is in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to "}], [{"generated_text": "\n\tvec4 c = texture(color_map, vec2(d, 0.5));\n\t\n\t// apply gamma correction\n\tc.rgb = pow(c.rgb, vec3(1.0/2.2));\n\t\n\t// apply brightness\n\tc.rgb *= vec3(0.5);\n\t\n\t// apply contrast\n\tc.rgb = (c.rgb - 0.5) * 2.0 + 0.5;\n\t\n\t// apply saturation\n\tc.rgb = mix(c.rgb, vec3(0.0), 0.5);\n\t\n\treturn c;\n}\n\n// main\nvoid main()\n{\n\t// get distance to surface\n\tfloat d = texture(depth_map, v_texcoord).r;\n\t\n\t// shade point\n\tvec4 c = shade(d);\n\t\n\t// write to framebuffer\n\tgl_FragColor = c;\n}\n"}], [{"generated_text": " and forth\n    float fade = clamp(0.5 + 0.5 * (1.0 + dot(rayDir, sunDir)), 0.0, 1.0);\n\n    // softbox\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    float dist = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        pos = vec3(0.0);\n        dist = 0.0;\n        for (int j = 0; j < 10; j++)\n        {\n            pos += vec3(0.0, 0.0, 0.0);\n            pos.x += scale;\n            pos.y += scale;\n            pos.z += scale;\n            dist += scale;\n            scale *= 0.5;\n        }\n        pos.x -= dist;\n        pos.y -= dist;\n        pos.z -= dist;\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n       "}], [{"generated_text": "\n    float time = (coords.x - 2.0) / 2.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat"}], [{"generated_text": "\n    float time = (coords.x - 2.0) / 4.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat"}], [{"generated_text": "\n    float time = (coords.x - 1.0) / 3.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat"}], [{"generated_text": "\n    float speed = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    float t = p.z * 0.001;\n\n    // The first layer is just a simple noise function.\n    float n = noise(p);\n\n    // The second layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t)) * 0.5;\n\n    // The third layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 2.0)) * 0.25;\n\n    // The fourth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 4.0)) * 0.125;\n\n    // The fifth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 8.0)) * 0.0625;\n\n    // The sixth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 16.0)) * 0.03125;\n\n    // The seventh layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 32.0)) * 0.015625;\n\n    // The eighth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 64.0)) * 0.0078125;\n\n    // The ninth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 128.0)) * 0.00390625;\n\n    // The tenth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 256.0)) * 0.001953125;"}], [{"generated_text": "\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but doesn't disperse things as nicely as the first way.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec"}], [{"generated_text": "\n    // This is a simplex grid, with a 3x3x3 grid.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid"}], [{"generated_text": "\n    vec2 cell = floor(p);\n    vec2 cell_size = vec2(1.0);\n    vec2 cell_offset = vec2(0.5);\n    vec2 cell_center = (cell + cell_offset) * cell_size;\n\n    // The distance from the cell center to the point.\n    vec2 dist = abs(p - cell_center);\n\n    // The distance from the cell center to the point.\n    float dist_min = min(dist.x, dist.y);\n\n    // The distance from the cell center to the point.\n    float dist_max = max(dist.x, dist.y);\n\n    // The distance from the cell center to the point.\n    float dist_avg = (dist_min + dist_max) / 2.0;\n\n    // The distance from the cell center to the point.\n    float dist_max_avg = max(dist_max, dist_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_avg = min(dist_min, dist_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_min = max(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_max = min(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_max = max(dist_max_avg, dist_max_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_min = min(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_min_max = max(dist_max_min, dist_min_max);\n\n    // The distance from the cell center to the point.\n    float dist_min_min_max = min(dist_max_min, dist_min_max);\n\n    // The distance from the cell center to the point."}], [{"generated_text": "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0."}], [{"generated_text": "\n    vec2 res = vec2(0.0);\n\n    // find the closest object\n    float t = INF;\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < t)\n        {\n            t = d;\n            res = objects[i].position;\n        }\n    }\n\n    // move the object\n    if (t < INF)\n    {\n        p = res;\n    }\n\n    // find the closest point on the sphere\n    float d = distance(p, vec3(0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the cylinder\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the cone\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the torus\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere"}], [{"generated_text": "\n\tfloat t = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tmin = 0.001;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0.0;\n\tfloat t43 = 0.0;\n\tfloat t"}], [{"generated_text": "\n    vec4 result = vec4(0.0);\n\n    // find the closest object\n    float t = findClosest(p);\n\n    // if there is an object, then we have a hit\n    if (t > 0.0)\n    {\n        // get the position of the object\n        vec3 q = p + t * rayDir;\n\n        // get the color of the object\n        vec3 color = getColor(q);\n\n        // get the normal of the object\n        vec3 normal = getNormal(q);\n\n        // get the specular color of the object\n        vec3 specular = getSpecular(q);\n\n        // get the ambient color of the object\n        vec3 ambient = getAmbient(q);\n\n        // get the diffuse color of the object\n        vec3 diffuse = getDiffuse(q);\n\n        // get the light direction\n        vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n\n        // get the diffuse color of the light\n        vec3 diffuseLight = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diffuseLight2 = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight2 = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight2 = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diffuseLight3 = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight3 = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight3 = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diff"}], [{"generated_text": "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin_tmax = 0.0;\n    float tmax_tmin = 10000.0;\n    float tmin_tmax_t = 0.0;\n    float tmax_tmin_t = 10000.0;\n    float tmin_tmax_t_t = 0.0;\n    float tmax_tmin_t_t = 10000.0;\n    float tmin_tmax_t_t_t = 0.0;\n    float tmax_tmin_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t_t_t = 10000.0"}], [{"generated_text": "s\n    vec3 wp1 = vec3(0.0);\n    vec3 wp2 = vec3(0.0);\n    vec3 wp3 = vec3(0.0);\n    vec3 wp4 = vec3(0.0);\n    vec3 wp5 = vec3(0.0);\n    vec3 wp6 = vec3(0.0);\n    vec3 wp7 = vec3(0.0);\n    vec3 wp8 = vec3(0.0);\n    vec3 wp9 = vec3(0.0);\n    vec3 wp10 = vec3(0.0);\n    vec3 wp11 = vec3(0.0);\n    vec3 wp12 = vec3(0.0);\n    vec3 wp13 = vec3(0.0);\n    vec3 wp14 = vec3(0.0);\n    vec3 wp15 = vec3(0.0);\n    vec3 wp16 = vec3(0.0);\n    vec3 wp17 = vec3(0.0);\n    vec3 wp18 = vec3(0.0);\n    vec3 wp19 = vec3(0.0);\n    vec3 wp20 = vec3(0.0);\n    vec3 wp21 = vec3(0.0);\n    vec3 wp22 = vec3(0.0);\n    vec3 wp23 = vec3(0.0);\n    vec3 wp24 = vec3(0.0);\n    vec3 wp25 = vec3(0.0);\n    vec3 wp26 = vec3(0.0);\n    vec3 wp27 = vec3(0.0);\n    vec3 wp28 = vec3(0.0);\n    vec3 wp29 = vec3(0."}], [{"generated_text": "\n    float n = 123456789.0;\n    float b = 0.0;\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float h = fract(sin(dot(p, vec3(n, n+1.0, n+2.0))) * 43758.5453);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float f = fract(sin(dot(p, vec3(n+3.0, n+5.0, n+7.0))) * 98765.4321);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float g = fract(sin(dot(p, vec3(n+9.0, n+13.0, n+17.0))) * 15973.3645);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float r = fract(sin(dot(p, vec3(n+19.0, n+23.0, n+27.0))) * 31415.9265);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to"}], [{"generated_text": "\n\tvec3 color = vec3(0.0);\n\tvec2 uv = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin = 0.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000001;\n\tfloat tstep20 = 0.0000000000000"}], [{"generated_text": "\n    vec2 box = vec2(abs(A.x - B.x), abs(A.y - B.y));\n    // calculate the distance from the box center to the line\n    float lineDist = distance(coords, mix(A, B, 0.5));\n    // calculate the distance from the box center to the line\n    float boxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxBoxBoxDist = distance(coords, mix(A + box * 0.5, B -"}], [{"generated_text": "\n     float dot = dot(start, end);\n\n     // If the dot product is negative, the angle between the vectors is greater than 180 degrees.\n     // In this case, we need to take the shortest path.\n     if (dot < 0.0f)\n     {\n          dot = -dot;\n     }\n\n     // If the dot product is 1, the angle between the vectors is 0 degrees.\n     // In this case, we need to take the longer path.\n     if (dot > 0.9999f)\n     {\n          return normalize(start + (end - start) * percent);\n     }\n\n     // The angle between the vectors is less than 180 degrees.\n     // Perform a linear interpolation.\n     float theta = acos(dot);\n     float sinTheta = sin(theta);\n\n     // If the angle is 0, return the first vector.\n     if (sinTheta < 0.0001f)\n     {\n          return start;\n     }\n\n     // Compute the sin of the angle.\n     float sinPerTheta = sin(theta * percent);\n\n     // Compute the cos of the angle.\n     float cosPerTheta = sqrt(1.0f - sinPerTheta * sinPerTheta);\n\n     // Compute the cross product.\n     vec2 perp;\n     perp.x = perp.y = 0.0f;\n     perp.x = perp.y = (end.y * sinPerTheta - start.y * cosPerTheta) / sinTheta;\n\n     // Compute the final vector.\n     return normalize(start + perp * cosPerTheta);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    float dist = length( ta - ro );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( p.x * uu + p.y * vv + dist * ww );\n\n    // raymarch\n    vec3 col = vec3( 0.0 );\n    float t = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + t * rd;\n        float d = map( pos );\n        col += d * vec3( 0.5, 0.5, 0.5 );\n        t += d;\n        if( t > 100.0 || d < 0.001 ) break;\n    }\n\n    // tone mapping\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // output to screen\n    fragColor = vec4( col, 1.0 );\n}\n"}], [{"generated_text": "\n    //\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b"}], [{"generated_text": " and forth\n    float fade = clamp(0.5 + 0.5 * rayDir.y, 0.0, 1.0);\n    vec3 color = vec3(0.0);\n    color += vec3(0.0, 0.0, 0.0) * fade;\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - fade);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec"}], [{"generated_text": "\n    vec2 d = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d1 = vec2(0.0);\n    vec2 d2 = vec2(0.0);\n    vec2 d3 = vec2(0.0);\n    vec2 d4 = vec2(0.0);\n    vec2 d5 = vec2(0.0);\n    vec2 d6 = vec2(0.0);\n    vec2 d7 = vec2(0.0);\n    vec2 d8 = vec2(0.0);\n    vec2 d9 = vec2(0.0);\n    vec2 d10 = vec2(0.0);\n    vec2 d11 = vec2(0.0);\n    vec2 d12 = vec2(0.0);\n    vec2 d13 = vec2(0.0);\n    vec2 d14 = vec2(0.0);\n    vec2 d15 = vec2(0.0);\n    vec2 d16 = vec2(0.0);\n    vec2 d17 = vec2(0.0);\n    vec2 d18 = vec2(0.0);\n    vec2 d19 = vec2(0.0);\n    vec2 d20 = vec2(0.0);\n    vec2 d21 = vec2(0.0);\n    vec2 d22 = vec2(0.0);\n    vec2 d23 = vec2(0.0);\n    vec2 d24 = vec2(0.0);\n    vec2 d25 = vec2(0.0);\n    vec2 d26 = vec2(0.0);\n    vec2 d27 = vec2(0.0);\n   "}], [{"generated_text": "^2\n\t// t = -0.5*org.x/dir.x\n\tfloat t = -0.5*dot(org, dir)/dot(dir, dir);\n\tnear = t;\n\tfar = t + 0.5;\n\treturn near >= 0 && far <= 1;\n}\n\n// from https://www.shadertoy.com/view/4s23DX\nfloat"}], [{"generated_text": "\n    vec3 q = p - vec3(s.xy, s.z);\n    vec3 q2 = q * q;\n    vec3 q3 = q2 * q;\n    vec3 q4 = q3 * q;\n    vec3 q5 = q4 * q;\n    vec3 q6 = q5 * q;\n    vec3 q7 = q6 * q;\n    vec3 q8 = q7 * q;\n    vec3 q9 = q8 * q;\n    vec3 q10 = q9 * q;\n    vec3 q11 = q10 * q;\n    vec3 q12 = q11 * q;\n    vec3 q13 = q12 * q;\n    vec3 q14 = q13 * q;\n    vec3 q15 = q14 * q;\n    vec3 q16 = q15 * q;\n    vec3 q17 = q16 * q;\n    vec3 q18 = q17 * q;\n    vec3 q19 = q18 * q;\n    vec3 q20 = q19 * q;\n    vec3 q21 = q20 * q;\n    vec3 q22 = q21 * q;\n    vec3 q23 = q22 * q;\n    vec3 q24 = q23 * q;\n    vec3 q25 = q24 * q;\n    vec3 q26 = q25 * q;\n    vec3 q27 = q26 * q;\n    vec3 q28 = q27 * q;\n    vec3 q29 = q28 * q;\n    vec3 q30 = q29 * q;\n    vec3 q31 = q30 * q;\n    vec3 q32 = q31 * q;\n    vec3 q33 = q32 * q;\n    vec3 q34 = q33 * q;\n    vec3 q35 = q34 * q"}], [{"generated_text": "\n    float n = noise(p);\n    float n2 = noise(p + vec3(1.0, 0.0, 0.0));\n    float n3 = noise(p + vec3(0.0, 1.0, 0.0));\n    float n4 = noise(p + vec3(0.0, 0.0, 1.0));\n    \n    // This is the actual formula.\n    return mix(n, n2, step(0.5, fract(p.x)));\n    return mix(n3, n4, step(0.5, fract(p.y)));\n    return mix(n, n3, step(0.5, fract(p.z)));\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat"}], [{"generated_text": "\n    float d = length(p) - 1.0;\n    \n    // The distance to the nearest wrappable circle.\n    float d2 = min(d, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d3 = min(d2, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d4 = min(d3, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d5 = min(d4, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d6 = min(d5, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d7 = min(d6, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d8 = min(d7, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d9 = min(d8, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d10 = min(d9, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d11 = min(d10, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d12 = min(d11, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d13 = min(d12, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d14 = min(d13, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d15 = min(d14, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d16 = min(d15, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d1"}], [{"generated_text": "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bump mapping to apply.\n    //\n    // The following is the bump mapping function.\n    //\n    // The bump mapping function is a simple bump mapping function.\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor"}], [{"generated_text": "\n    //return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n    \n    // Better, but not as nicely as the other methods.\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec"}], [{"generated_text": "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 light_color = vec3(1.0, 1.0, 1.0);\n  float light_intensity = 1.0;\n\n  // ambient\n  vec3 ambient = vec3(0.1, 0.1, 0.1) * light_color * light_intensity;\n\n  // diffuse\n  float diffuse = max(dot(light_dir, n), 0.0);\n  vec3 diffuse_color = vec3(0.5, 0.5, 0.5) * light_color * diffuse * light_intensity;\n\n  // specular\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  float specular = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);\n  vec3 specular_color = vec3(1.0, 1.0, 1.0) * light_color * specular * light_intensity;\n\n  return ambient + diffuse_color + specular_color;\n}\n\n// raymarching\n// p : point,\n// n : normal at point\nfloat"}], [{"generated_text": "\n    Ray ray = Ray(vec3(0.0), vec3(0.0, 0.0, 1.0));\n    //creates a camera object\n    Camera cam = Camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 1.0, 1.0, 1.0);\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //creates a plane object\n    Plane plane = Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    //creates a light object\n    Light light = Light(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    //creates a material object\n    Material material = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, "}], [{"generated_text": "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(rd, vec3(0.0, 1.0, 0.0));\n    t = clamp(t, 0.0, 1.0);\n    sky = mix(sky, par, t);\n    return sky;\n}\n\n// skybox\nvec"}], [{"generated_text": "i\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n"}], [{"generated_text": "\n    return length(p) - rad;\n}\n\n//cube\nfloat"}], [{"generated_text": "\n    float floor = p.y - param.y;\n    float ceiling = param.y - p.y;\n\n    // distance to the floor\n    float d1 = abs(floor) - param.z;\n\n    // distance to the ceiling\n    float d2 = abs(ceiling) - param.z;\n\n    // return the smaller distance\n    return min(d1, d2);\n}\n\n// scene distance\nfloat"}], [{"generated_text": "\n    float floor = p.y - param.y;\n    float ceiling = param.y - p.y;\n\n    // light gathering\n    float light = max(floor, ceiling);\n\n    // distance to light\n    float dist = length(p - param);\n\n    // return the distance to light\n    return dist - light;\n}\n\n// scene distant with light gathering\nfloat"}], [{"generated_text": "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(ro, par);\n    if (t < 0.0)\n        return sky;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t3"}], [{"generated_text": "i\n    const float k = 1.0;\n    const float k2 = 1.0;\n    const float k3 = 1.0;\n    const float k4 = 1.0;\n    const float k5 = 1.0;\n    const float k6 = 1.0;\n    const float k7 = 1.0;\n    const float k8 = 1.0;\n    const float k9 = 1.0;\n    const float k10 = 1.0;\n    const float k11 = 1.0;\n    const float k12 = 1.0;\n    const float k13 = 1.0;\n    const float k14 = 1.0;\n    const float k15 = 1.0;\n    const float k16 = 1.0;\n    const float k17 = 1.0;\n    const float k18 = 1.0;\n    const float k19 = 1.0;\n    const float k20 = 1.0;\n    const float k21 = 1.0;\n    const float k22 = 1.0;\n    const float k23 = 1.0;\n    const float k24 = 1.0;\n    const float k25 = 1.0;\n    const float k26 = 1.0;\n    const float k27 = 1.0;\n    const float k28 = 1.0;\n    const float k29 = 1.0;\n    const float k30 = 1.0;\n    const float k31 = 1.0;\n    const float k32 = 1.0;\n    const float k33 = 1.0;\n    const float k34 = 1.0;\n    const float k35 = 1.0;\n    const float k36 = 1.0;\n    const float k37 = 1.0;\n    const float k38 = 1.0;\n    const float k39 = 1.0;\n    const float k40 = 1.0;\n    const float k41 = 1.0;\n    const float k42 = 1.0;\n    const float k43 = 1.0;\n    const float k"}], [{"generated_text": "\n    vec2 q = p - diamond.xy;\n    return length(q - vec2(clamp(q.x, -diamond.z, diamond.z), clamp(q.y, -diamond.w, diamond.w))) - diamond.z;\n}\n\n// triangle: (center.x, center.y, helf width, helf height)\nfloat"}], [{"generated_text": "\n    // to avoid the need for a separate background texture.\n    vec3 background = vec3(0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);"}], [{"generated_text": "\n\tfloat d = length( pos - vec3( 0.0, 0.0, 0.0 ) );\n\treturn d;\n}\n\n// get distance in the world\nfloat"}], [{"generated_text": "\n\tvec3 light = vec3(0.0, 0.0, 0.0);\n\tvec3 diffuse = vec3(0.0, 0.0, 0.0);\n\tvec3 specular = vec3(0.0, 0.0, 0.0);\n\tvec3 ambient = vec3(0.0, 0.0, 0.0);\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tvec3 lightDir = normalize(light - v);\n\tvec3 viewDir = normalize(eye - v);\n\tvec3 halfDir = normalize(lightDir + viewDir);\n\tfloat diff = max(dot(n, lightDir), 0.0);\n\tdiffuse = diff * vec3(1.0, 1.0, 1.0);\n\tfloat spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n\tspecular = spec * vec3(1.0, 1.0, 1.0);\n\tambient = vec3(0.1, 0.1, 0.1) * diffuse;\n\tcolor = (ambient + diffuse + specular) * vec3(1.0, 1.0, 1.0);\n\treturn color;\n}\n\n// raymarching\nvec"}], [{"generated_text": "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but doesn't disperse things quite as nicely as the first. :)\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat"}], [{"generated_text": "\n    // 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n   "}], [{"generated_text": ".\n    float d = length(p.xy) - r;\n    // How far along the cylinder the point is, vertically.\n    float dz = p.z;\n    // If the point is inside the cylinder, return the distance.\n    if (dz < -h / 2.0) {\n        return d;\n    }\n    // If the point is outside the cylinder, return the distance.\n    if (dz > h / 2.0) {\n        return d;\n    }\n    // If the point is on the cylinder, return the distance.\n    return dz;\n}\n\n/**\n * Signed distance function for an XY aligned sphere centered at the origin with\n * radius r.\n */\nfloat"}], [{"generated_text": "\n    float t = TIME * 0.01;\n    float s = sin(t);\n    float c = cos(t);\n    p.xz *= mat2(c, s, -s, c);\n    \n    // Scale the scene\n    p *= 1.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, -0.5, 0.5, 0.866);\n    \n    // Move the scene\n    p.xz -= vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, -0.5, 0.5, 0.866);\n    \n    // Move the scene\n    p.xz -= vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *"}], [{"generated_text": "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(\n        s.x, u.x, -f.x,\n        s.y, u.y, -f.y,\n        s.z, u.z, -f.z\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat"}], [{"generated_text": "\n    float f = fbm(p);\n    f = fbm(p*2.0);\n    f = fbm(p*4.0);\n    f = fbm(p*8.0);\n    f = fbm(p*16.0);\n    f = fbm(p*32.0);\n    f = fbm(p*64.0);\n    f = fbm(p*128.0);\n    f = fbm(p*256.0);\n    f = fbm(p*512.0);\n    f = fbm(p*1024.0);\n    f = fbm(p*2048.0);\n    f = fbm(p*4096.0);\n    f = fbm(p*8192.0);\n    f = fbm(p*16384.0);\n    f = fbm(p*32768.0);\n    f = fbm(p*65536.0);\n    f = fbm(p*131072.0);\n    f = fbm(p*262144.0);\n    f = fbm(p*524288.0);\n    f = fbm(p*1048576.0);\n    f = fbm(p*2097152.0);\n    f = fbm(p*4194304.0);\n    f = fbm(p*8388608.0);\n    f = fbm(p*16777216.0);\n    f = fbm(p*33554432.0);\n    f = fbm(p*67108864.0);\n    f = fbm(p*134217728.0);\n    f = fbm(p*268435456.0);\n    f = fbm(p*536870912.0);\n    f = fbm(p"}], [{"generated_text": "\n    //It is used to calculate the color of a biomorph\n    //The biomorph is a 2D fractal\n    //The biomorph is a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fract"}], [{"generated_text": "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nvec"}], [{"generated_text": "\n    vec2 p2 = vec2(p.x, p.z);\n    float r = length(p2);\n    float theta = atan(p2.y, p2.x);\n    float phi = atan(p.y, p.x);\n    \n    // The bump mapping function.\n    float bump = sin(r * 10.0) * 0.5 + 0.5;\n    bump = clamp(bump, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump2 = sin(r * 10.0) * 0.5 + 0.5;\n    bump2 = clamp(bump2, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump3 = sin(r * 10.0) * 0.5 + 0.5;\n    bump3 = clamp(bump3, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump4 = sin(r * 10.0) * 0.5 + 0.5;\n    bump4 = clamp(bump4, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump5 = sin(r * 10.0) * 0.5 + 0.5;\n    bump5 = clamp(bump5, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump6 = sin(r * 10.0) * 0.5 + 0.5;\n    bump6 = clamp(bump6, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump7 = sin(r * 10.0) * 0.5 + 0.5;\n    bump7 = clamp(bump7, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump8 = sin(r *"}], [{"generated_text": "\n    //\n    // scr_pt is in screen space, and is in the range [0,1]x[0,1].\n    //\n    // view_inv is the inverse of the view matrix.\n    //\n    // proj_inv is the inverse of the projection matrix.\n    //\n    // viewp_inv is the inverse of the view projection matrix.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray"}], [{"generated_text": "\n    if (rounded > thick.y) {\n        rounded = thick.y;\n    }\n\n    // Get the distance from the line to the point.\n    float d = distance(pA, pB);\n\n    // Get the distance from the point to the line.\n    float d2 = distance(uv, pA);\n\n    // Get the distance from the point to the line.\n    float d3 = distance(uv, pB);\n\n    // Get the distance from the point to the line.\n    float d4 = distance(uv, pA + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d5 = distance(uv, pB + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d6 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d7 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d8 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d9 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d10 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point"}], [{"generated_text": "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 light_color = vec3(1.0, 1.0, 1.0);\n  vec3 light_ambient = vec3(0.2, 0.2, 0.2);\n  vec3 light_diffuse = vec3(0.5, 0.5, 0.5);\n  vec3 light_specular = vec3(1.0, 1.0, 1.0);\n  float light_shininess = 100.0;\n\n  // material\n  vec3 material_ambient = vec3(0.2, 0.2, 0.2);\n  vec3 material_diffuse = vec3(0.5, 0.5, 0.5);\n  vec3 material_specular = vec3(1.0, 1.0, 1.0);\n  float material_shininess = 100.0;\n\n  // ambient\n  vec3 ambient = light_ambient * material_ambient;\n\n  // diffuse\n  float diff = max(dot(light_dir, n), 0.0);\n  vec3 diffuse = light_diffuse * diff * material_diffuse;\n\n  // specular\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material_shininess);\n  vec3 specular = light_specular * spec * material_specular;\n\n  // combine\n  vec3 result = (ambient + diffuse + specular) * light_color;\n  return result;\n}\n\n// raymarching\n// p : point,\n// n : normal at point\nfloat"}], [{"generated_text": "\n\tvec3 n = (cen - ro) / rd;\n\tvec3 f = fract(n);\n\tvec3 e = (cen + rad) - ro;\n\tvec3 t = e / rd;\n\tvec3 s = sign(e);\n\tvec3 t1 = min(t, f);\n\tvec3 t2 = max(t, f);\n\tvec3 tf = max(t1, t2);\n\tvec3 ts = min(s, tf);\n\treturn ts;\n}\n\n// ray-sphere intersection (simplified)\nvec"}], [{"generated_text": "\n  return sin(x * PI) * (a + (b - a) * 0.5 * (1.0 + cos(x * TWO_PI)));\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat"}], [{"generated_text": "\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\n// z * z\nvec"}], [{"generated_text": "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize(ab);\n    // center the cylinder\n    vec3 oc = ro - pa;\n    // ray-cylinder intersection\n    float tca = dot(oc, abn);\n    if( tca < 0.0 ) return vec4(0.0);\n    float d2 = dot(oc, oc) - tca*tca;\n    if( d2 > ra*ra ) return vec4(0.0);\n    float thc = sqrt( ra*ra - d2 );\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    // find the nearest t value\n    float t = t0 < 0.0? t1 : t0;\n    if( t < 0.0 ) return vec4(0.0);\n    // get the normal\n    vec3 n = abn * sign(tca - ra) + abn * sign(tca + ra);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec"}], [{"generated_text": "\n\n\tfloat d = length(P-U);\n\tfloat r2 = r*r;\n\tfloat d2 = d*d;\n\tfloat d3 = d2*d;\n\tfloat d4 = d3*d;\n\tfloat d5 = d4*d;\n\tfloat d6 = d5*d;\n\tfloat d7 = d6*d;\n\tfloat d8 = d7*d;\n\tfloat d9 = d8*d;\n\tfloat d10 = d9*d;\n\tfloat d11 = d10*d;\n\tfloat d12 = d11*d;\n\tfloat d13 = d12*d;\n\tfloat d14 = d13*d;\n\tfloat d15 = d14*d;\n\tfloat d16 = d15*d;\n\tfloat d17 = d16*d;\n\tfloat d18 = d17*d;\n\tfloat d19 = d18*d;\n\tfloat d20 = d19*d;\n\tfloat d21 = d20*d;\n\tfloat d22 = d21*d;\n\tfloat d23 = d22*d;\n\tfloat d24 = d23*d;\n\tfloat d25 = d24*d;\n\tfloat d26 = d25*d;\n\tfloat d27 = d26*d;\n\tfloat d28 = d27*d;\n\tfloat d29 = d28*d;\n\tfloat d30 = d29*d;\n\tfloat d31 = d30*d;\n\tfloat d32 = d31*d;\n\tfloat d33 = d32*d;\n\tfloat d34 = d33*d;\n\tfloat d35 = d34*d;\n\tfloat d36 = d35*d;\n\tfloat d37 = d36*d;\n\tfloat d38 = d37*d;\n\tfloat d39 = d38*d;\n\tfloat d40 = d39*d;\n"}], [{"generated_text": "\n    p.xz *= mat2(1.0, 0.5, 0.5, 1.0);\n    p.y *= 0.5;\n\n    // calculate the distance to the scene\n    float d = length(p.xz) - 0.5;\n\n    // calculate the distance to the camera\n    float d2 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d3 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d4 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d5 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d6 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d7 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d8 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d9 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d10 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d11 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d12 = length(p."}], [{"generated_text": "\n    float scale = (1.0/float(scaleCount))*layerID;\n    float scale2 = (1.0/float(scaleCount))*(layerID+1);\n\n    // The scale is a percentage of the grid size.\n    // The scale2 is a percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the"}], [{"generated_text": "\n    float scale = 0.005;\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p0 = p;\n    vec2 p1 = p + vec2(scale, 0.0);\n    vec2 p2 = p + vec2(0.0, scale);\n    vec2 p3 = p + vec2(-scale, 0.0);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p4 = p + vec2(scale, scale);\n    vec2 p5 = p + vec2(0.0, scale) + vec2(scale, scale);\n    vec2 p6 = p + vec2(scale, 0.0) + vec2(scale, scale);\n    vec2 p7 = p + vec2(0.0, scale) + vec2(0.0, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p8 = p + vec2(-scale, scale);\n    vec2 p9 = p + vec2(-scale, 0.0) + vec2(scale, scale);\n    vec2 p10 = p + vec2(-scale, 0.0) + vec2(0.0, scale);\n    vec2 p11 = p + vec2(-scale, scale) + vec2(0.0, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p12 = p + vec2(-scale, -scale);\n    vec2 p13 = p + vec2(-scale, -scale) + vec2(scale, scale);\n    vec2 p14 = p + vec2(-scale, -scale) + vec2(0.0, scale);\n    vec2 p15 = p + vec2(-scale, -scale) + vec2(-scale, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p16 = p + vec2(scale, -scale);\n"}], [{"generated_text": "\n\n    // \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b\n    float distance = length(currentRayPosition.xz) - 0.5;\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u043c\u0435\u043d\u044c\u0448\u0435 0.5, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    if (distance < 0.5)\n    {\n        return 0.0;\n    }\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u0431\u043e\u043b\u044c\u0448\u0435 0.5, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    return 1.0 - distance;\n}\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u0441 \u044d\u0444\u0444\u0435\u043a\u0442\u043e\u043c \u043f\u043b\u0430\u043c\u0435\u043d\u0438\nfloat"}], [{"generated_text": "\n    // \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0442\u044c\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0434\u043e\u043b\u0433\u043e\n    // \u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\n    return abs(flameDistance(currentRayPosition));\n}\n\n// ray marching\n// ray - \u043b\u0443\u0447, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u0442 \u043f\u043e \u0441\u0446\u0435\u043d\u0435\n// rayDirection - \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n// rayLength - \u0434\u043b\u0438\u043d\u0430 \u043b\u0443\u0447\u0430\n// currentRayPosition - \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u043b\u0443\u0447\u0430\n// currentRayLength - \u0434\u043b\u0438\u043d\u0430 \u043b\u0443\u0447\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043f\u0440\u043e\u0448\u043b\u043e\n// currentRayColor - \u0446\u0432\u0435\u0442 \u043b\u0443\u0447\u0430\n// currentRayStep - \u0448\u0430\u0433 \u043b\u0443\u0447\u0430\n// currentRayStepLength - \u0434\u043b\u0438\u043d\u0430 \u0448\u0430\u0433\u0430 \u043b\u0443\u0447\u0430\n// currentRayStepColor - \u0446\u0432\u0435\u0442 \u0448\u0430\u0433\u0430 \u043b\u0443\u0447\u0430\n// currentRayStepCount - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b"}], [{"generated_text": "\n    float s = sm;\n    \n    // Get the integer part of the input.\n    float i = floor(x);\n    \n    // Get the fractional part of the input.\n    float f = x - i;\n    \n    // Get the fractional part of the integer part.\n    float fInt = f - floor(f);\n    \n    // Get the fractional part of the integer part.\n    float fFrac = fInt - floor(fInt);\n    \n    // Get the fractional part of the integer part.\n    float fFrac2 = fFrac - floor(fFrac);\n    \n    // Get the fractional part of the integer part.\n    float fFrac3 = fFrac2 - floor(fFrac2);\n    \n    // Get the fractional part of the integer part.\n    float fFrac4 = fFrac3 - floor(fFrac3);\n    \n    // Get the fractional part of the integer part.\n    float fFrac5 = fFrac4 - floor(fFrac4);\n    \n    // Get the fractional part of the integer part.\n    float fFrac6 = fFrac5 - floor(fFrac5);\n    \n    // Get the fractional part of the integer part.\n    float fFrac7 = fFrac6 - floor(fFrac6);\n    \n    // Get the fractional part of the integer part.\n    float fFrac8 = fFrac7 - floor(fFrac7);\n    \n    // Get the fractional part of the integer part.\n    float fFrac9 = fFrac8 - floor(fFrac8);\n    \n    // Get the fractional part of the integer part.\n    float fFrac10 = fFrac9 - floor(fFrac9);\n    \n    // Get the fractional part of the integer part.\n    float fFrac11 = fFrac10 - floor(fFrac10);\n    \n    // Get the fractional part of the integer part.\n    float fFrac12 = fFrac11 - floor(fFrac11);\n    \n    // Get the fractional part of the integer"}], [{"generated_text": "\n\n    // p = fract(p * 0.3183099 + vec3(0.0, 0.0, 0.0));\n    // p += dot(p, p.yxz + 19.19);\n    // return fract(vec3(p.x + p.y + p.z, p.x + p.y + p.z) * 0.3183099);\n\n    // This is the original, but it's a bit more complicated. It's a bit more complicated, but it's\n    // more accurate. It's also more accurate, but it's slower.\n\n    p = fract(p * 0.3183099 + vec3(0.0, 0.0, 0.0));\n    p += dot(p, p.yxz + 19.19);\n    return fract(vec3(p.x + p.y + p.z, p.x + p.y + p.z) * 0.3183099);\n}\n\n// This is a simple noise function, that I've found on the internet. It's not as accurate as the\n// hash33 function, but it's faster.\nfloat"}], [{"generated_text": "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    // Determining the first vertice and the fractional position.\n    vec3 v = p - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v2 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v3 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v4 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v5 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v6 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v7 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v8 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v9 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v10 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v11 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v12 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v13 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v14 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v15 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v1"}], [{"generated_text": "\n    float n = 0.0;\n    \n    // The number of octaves.\n    int octaves = 10;\n    \n    // The frequency of the noise.\n    float freq = 1.0;\n    \n    // The amplitude of the noise.\n    float amp = 0.5;\n    \n    // The persistence.\n    float persistence = 0.5;\n    \n    // The scale.\n    float scale = 0.5;\n    \n    // The offset.\n    float offset = 0.0;\n    \n    // The total amplitude.\n    float totalAmp = 0.0;\n    \n    // The total frequency.\n    float totalFreq = freq;\n    \n    // The total persistence.\n    float totalPersistence = persistence;\n    \n    // The total scale.\n    float totalScale = scale;\n    \n    // The total offset.\n    float totalOffset = offset;\n    \n    // The total noise.\n    float totalNoise = 0.0;\n    \n    // The total noise.\n    float totalNoise2 = 0.0;\n    \n    // The total noise.\n    float totalNoise3 = 0.0;\n    \n    // The total noise.\n    float totalNoise4 = 0.0;\n    \n    // The total noise.\n    float totalNoise5 = 0.0;\n    \n    // The total noise.\n    float totalNoise6 = 0.0;\n    \n    // The total noise.\n    float totalNoise7 = 0.0;\n    \n    // The total noise.\n    float totalNoise8 = 0.0;\n    \n    // The total noise.\n    float totalNoise9 = 0.0;\n    \n    // The total noise.\n    float totalNoise10 = 0.0;\n    \n    // The total noise.\n    float totalNoise11 = 0.0;\n    \n    // The total noise.\n    float totalNoise12 = 0.0;\n    \n    // The total noise.\n    float totalNoise13 = 0.0;\n    \n    // The total noise.\n    float totalNoise14 = 0."}], [{"generated_text": "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // We calculate the distance between the current ray position and the balloon position\n  float distance = length( currentRayPosition - balloonPosition );\n  \n  // If the distance is smaller than the balloon radius, we return the distance and the color of the balloon\n  if( distance < balloonRadius ){\n    return vec2( distance, vec3( 0.0, 0.0, 1.0 ) );\n  }\n  \n  // If the distance is larger than the balloon radius, we return the distance and the color of the background\n  return vec2( distance, vec3( 0.0, 0.0, 0.0 ) );\n}\n\n//'TAG: BALL'\nvec"}], [{"generated_text": "\n\tvec3 tmin = (rad-ro)/rd;\n\tvec3 tmax = (rad-ro-1.0)/rd;\n\tvec3 t1 = min(tmin,tmax);\n\tvec3 t2 = max(tmin,tmax);\n\tfloat t0 = max(max(t1.x,t1.y),t1.z);\n\tfloat t3 = min(min(t2.x,t2.y),t2.z);\n\tif(t0>t3) return vec4(0.0);\n\tt0 = max(t0,t1.x);\n\tt3 = min(t3,t2.x);\n\tif(t3<t0) return vec4(0.0);\n\tt0 = max(t0,t1.y);\n\tt3 = min(t3,t2.y);\n\tif(t3<t0) return vec4(0.0);\n\tt0 = max(t0,t1.z);\n\tt3 = min(t3,t2.z);\n\tif(t3<t0) return vec4(0.0);\n\treturn vec4(t0,t1.x,t1.y,t1.z);\n}\n\n// ray sphere intersection by iq https://www.shadertoy.com/view/ld23DV\nvec"}], [{"generated_text": "\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.0-2.0*f);\n    \n    // Determining the first vertice.\n    vec3 v = p - f + u;\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v0 = v + u;\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v1 = v + vec3(u.x, u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v2 = v + vec3(u.x, 1.0-u.y, u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v3 = v + vec3(1.0-u.x, u.y, u.z);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v4 = v + vec3(u.x, u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v5 = v + vec3(1.0-u.x, 1.0-u.y, u.z);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v6 = v + vec3(u.x, 1.0-u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v7 = v + vec3(1.0-u.x, 1.0-u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v8 = v + vec3(u.x, u.y, 1.0-u.x-"}], [{"generated_text": "\n vec3 col=vec3(0);\n vec2 v=vec2(0);\n float d=0;\n float d2=0;\n float d3=0;\n float d4=0;\n float d5=0;\n float d6=0;\n float d7=0;\n float d8=0;\n float d9=0;\n float d10=0;\n float d11=0;\n float d12=0;\n float d13=0;\n float d14=0;\n float d15=0;\n float d16=0;\n float d17=0;\n float d18=0;\n float d19=0;\n float d20=0;\n float d21=0;\n float d22=0;\n float d23=0;\n float d24=0;\n float d25=0;\n float d26=0;\n float d27=0;\n float d28=0;\n float d29=0;\n float d30=0;\n float d31=0;\n float d32=0;\n float d33=0;\n float d34=0;\n float d35=0;\n float d36=0;\n float d37=0;\n float d38=0;\n float d39=0;\n float d40=0;\n float d41=0;\n float d42=0;\n float d43=0;\n float d44=0;\n float d45=0;\n float d46=0;\n float d47=0;\n float d48=0;\n float d49=0;\n float d50=0;\n float d51=0;\n float d52=0;\n float d53=0;\n float d54=0;\n float d55=0;\n float d56=0;\n float d57=0;\n float d58=0;\n float d59=0;\n float d60=0;\n float d61=0;\n float d62=0;\n float d6"}], [{"generated_text": "\n    //Use a float instead.\n    float a = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float i = 0.0;\n    float zr = 0.0;\n    float zi = 0.0;\n    float zr2 = 0.0;\n    float zi2 = 0.0;\n    float zr3 = 0.0;\n    float zi3 = 0.0;\n    float zr4 = 0.0;\n    float zi4 = 0.0;\n    float zr5 = 0.0;\n    float zi5 = 0.0;\n    float zr6 = 0.0;\n    float zi6 = 0.0;\n    float zr7 = 0.0;\n    float zi7 = 0.0;\n    float zr8 = 0.0;\n    float zi8 = 0.0;\n    float zr9 = 0.0;\n    float zi9 = 0.0;\n    float zr10 = 0.0;\n    float zi10 = 0.0;\n    float zr11 = 0.0;\n    float zi11 = 0.0;\n    float zr12 = 0.0;\n    float zi12 = 0.0;\n    float zr13 = 0.0;\n    float zi13 = 0.0;\n    float zr14 = 0.0;\n    float zi14 = 0.0;\n    float zr15 = 0.0;\n    float zi15 = 0.0;\n    float zr16 = 0.0;\n    float zi16 = 0.0;\n    float zr17 = 0.0;\n    float zi17 = 0.0;\n    float zr18 = 0.0;\n    float zi18 = 0.0;\n    float zr19 = 0.0;\n    float zi19 = 0.0;\n    float zr20 = 0.0;\n    float zi20 = 0.0;\n    float zr21 = "}], [{"generated_text": "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    //we need to create the new coord system\n    mat4 m;\n    m[0] = vec4(x, 0.0);\n    m[1] = vec4(y, 0.0);\n    m[2] = vec4(z, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    return m;\n}\n\n//view matrix\nmat"}], [{"generated_text": "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / iResolution.xy);\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 q = p;\n    vec2 r = p;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tt = 0.0;\n    float ttt = 0.0;\n    float tttt = 0.0;\n    float ttttt = 0.0;\n    float tttttt = 0.0;\n    float ttttttt = 0.0;\n    float tttttttt = 0.0;\n    float ttttttttt = 0.0;\n    float tttttttttt = 0.0;\n    float ttttttttttt = 0.0;\n    float tttttttttttt = 0.0;\n    float ttttttttttttt = 0.0;\n    float tttttttttttttt = 0.0;\n    float ttttttttttttttt = 0.0;\n    float tttttttttttttttt = 0.0;\n    float ttttttttttttttttt = 0.0;\n    float tttttttttttttttttt = 0.0;\n    float ttttttttttttttttttt = 0.0;\n    float tttttttttttttttttttt = 0.0;\n    float"}], [{"generated_text": "\n    float d = w / 10.0;\n    float d2 = d / 2.0;\n    float d3 = d2 / 2.0;\n    float d4 = d3 / 2.0;\n    float d5 = d4 / 2.0;\n    float d6 = d5 / 2.0;\n    float d7 = d6 / 2.0;\n    float d8 = d7 / 2.0;\n    float d9 = d8 / 2.0;\n    float d10 = d9 / 2.0;\n    float d11 = d10 / 2.0;\n    float d12 = d11 / 2.0;\n    float d13 = d12 / 2.0;\n    float d14 = d13 / 2.0;\n    float d15 = d14 / 2.0;\n    float d16 = d15 / 2.0;\n    float d17 = d16 / 2.0;\n    float d18 = d17 / 2.0;\n    float d19 = d18 / 2.0;\n    float d20 = d19 / 2.0;\n    float d21 = d20 / 2.0;\n    float d22 = d21 / 2.0;\n    float d23 = d22 / 2.0;\n    float d24 = d23 / 2.0;\n    float d25 = d24 / 2.0;\n    float d26 = d25 / 2.0;\n    float d27 = d26 / 2.0;\n    float d28 = d27 / 2.0;\n    float d29 = d28 / 2.0;\n    float d30 = d29 / 2.0;\n    float d31 = d30 / 2.0;\n    float d32 = d31 / 2.0;\n    float d33 = d32 / 2.0;\n    float d3"}], [{"generated_text": "\n    if (a == b)\n        return 0.0;\n\n    // clamp x to [0, 1]\n    x = clamp(x, 0.0, 1.0);\n\n    // lerp between a and b\n    return lerp(a, b, x);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat"}], [{"generated_text": "\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve, float curve2)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve, float curve2, float curve3)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 x"}], [{"generated_text": "\n float a=j*3.1415926535897932384626433832795;\n float b=j*3.1415926535897932384626433832795+0.5;\n float c=j*3.1415926535897932384626433832795+1.5;\n float d=j*3.1415926535897932384626433832795+2.5;\n float e=j*3.1415926535897932384626433832795+3.5;\n // random offsets of neighbors (counter-clockwise starting south)\n float f=j*3.1415926535897932384626433832795-0.5;\n float g=j*3.1415926535897932384626433832795-1.5;\n float h=j*3.1415926535897932384626433832795-2.5;\n float i=j*3.1415926535897932384626433832795-3.5;\n // random offsets of neighbors (clockwise starting east)\n float j=j*3.1415926535897932384626433832795+4.5;\n float k=j*3.1415926535897932384626433832795+5.5;\n float l="}], [{"generated_text": "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.w*5.);\n return f;\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat"}], [{"generated_text": ", but it's a good start\n    vec3 rgb = vec3(0.0);\n    rgb.r = c.r * 0.299;\n    rgb.g = c.g * 0.587;\n    rgb.b = c.b * 0.114;\n    return rgb;\n}\n\n//this is a pretty good way to get a color that is a bit more\n//\"natural\" than the default color, but it's not as good as\n//EnChromaRgb()\nvec"}], [{"generated_text": "\n  vec4 d=vec4(0.);\n  vec3 q=abs(p)-s;\n  d.x=min(max(q.x,0.),min(q.y,q.z));\n  d.y=min(max(q.y,0.),min(q.z,q.x));\n  d.z=min(max(q.z,0.),min(q.x,q.y));\n  d.w=max(max(q.x,q.y),max(q.y,q.z));\n  return d;\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec"}], [{"generated_text": "\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4"}], [{"generated_text": "\n    Material mat = distScene(pos, depth, steps);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    Material mat = distScene(pos, depth, steps, t);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t, float t2)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    Material mat = distScene(pos, depth, steps, t, t2);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t, float t2, float t3)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + "}], [{"generated_text": "\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    return clamp((x * (0.055f * (x * (x * 0.3f + 0.5f)) + 0.05f)) / (x * (0.119192f * (x * 0.3f + 0.5f) + 0.332f) + 0.18055f), 0.0f, 1.0f);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec"}], [{"generated_text": "\n    p.z += 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    if (p.x*p.x + p.y*p.y + p.z*p.z < 1.0) {\n        return vec4(0.5, 0.5, 0.5, 1.0);\n    }\n    //plane\n    else if (p.x == 0.0 && p.y == 0.0 && p.z == 0.0) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    //cube\n    else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n//scene light at position p\nvec"}], [{"generated_text": "\n    mat2 m = mat2( 0.8, -0.6, 0.6, 0.8 );\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 100 );\n    // rotate point p by 45 degrees\n    p = m * p;\n    // add noise to each axis\n    for ( int i = 0; i < 5; i++ ) {\n        f += a * noise( p );\n        p = m * p * 2.02 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// returns a fractal noise in a 3D space\nfloat"}], [{"generated_text": "\n    \n    // The first point is the wrapped point.\n    vec2 p0 = p;\n    \n    // The second point is the wrapped point rotated 90 degrees.\n    vec2 p1 = vec2(p0.y, -p0.x);\n    \n    // The third point is the wrapped point rotated 180 degrees.\n    vec2 p2 = vec2(-p0.y, p0.x);\n    \n    // The fourth point is the wrapped point rotated 270 degrees.\n    vec2 p3 = vec2(-p0.x, -p0.y);\n    \n    // The fifth point is the wrapped point rotated 360 degrees.\n    vec2 p4 = p0;\n    \n    // The sixth point is the wrapped point rotated 45 degrees.\n    vec2 p5 = vec2(-p0.y, -p0.x);\n    \n    // The seventh point is the wrapped point rotated 135 degrees.\n    vec2 p6 = vec2(p0.x, -p0.y);\n    \n    // The eighth point is the wrapped point rotated 225 degrees.\n    vec2 p7 = vec2(-p0.x, p0.y);\n    \n    // The ninth point is the wrapped point rotated 315 degrees.\n    vec2 p8 = vec2(-p0.y, -p0.x);\n    \n    // The tenth point is the wrapped point rotated 45 degrees.\n    vec2 p9 = vec2(p0.y, p0.x);\n    \n    // The eleventh point is the wrapped point rotated 135 degrees.\n    vec2 p10 = vec2(-p0.x, p0.y);\n    \n    // The twelfth point is the wrapped point rotated 225 degrees.\n    vec2 p11 = vec2(p0.x, -p0.y);\n    \n    // The thirteenth point is the wrapped point rotated 315 degrees.\n    vec"}], [{"generated_text": "\n return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat"}], [{"generated_text": "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat"}], [{"generated_text": " to define a line.\n //return length(u-d)-.1;\n return length(u-m.xy)-.1;\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat"}], [{"generated_text": "\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n "}], [{"generated_text": "\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}"}], [{"generated_text": "\n    return normalize(a - dot(a, b) * b);\n}\n\n//Gram-Schmidt method\nvec"}], [{"generated_text": "\n\tfloat alpha = acos(dot(normalize(A - B), normalize(C - B)));\n\tfloat beta = acos(dot(normalize(A - C), normalize(B - C)));\n\tfloat gamma = acos(dot(normalize(B - C), normalize(A - C)));\n\n\t//calculate the solid angle of the spherical triangle\n\tfloat solidAngle = alpha + beta + gamma - M_PI;\n\n\t//calculate the solid angle of the triangle\n\tfloat solidAngleTriangle = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of"}], [{"generated_text": "\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In"}], [{"generated_text": "\n    \n    // The tube is a cylinder with a radius of 1.\n    float r = 1.0;\n    \n    // The tube is a cylinder with a radius of 1.\n    float h = 0.5;\n    \n    // The tube is a cylinder with a radius of 1.\n    float d = 0.05;\n    \n    // The tube is a cylinder with a radius of 1.\n    float a = 0.1;\n    \n    // The tube is a cylinder with a radius of 1.\n    float b = 0.05;\n    \n    // The tube is a cylinder with a radius of 1.\n    float c = 0.01;\n    \n    // The tube is a cylinder with a radius of 1.\n    float e = 0.001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float f = 0.0001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float g = 0.00001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hh = 0.000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhh = 0.0000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhh = 0.00000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhh = 0.000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhh = 0.0000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhhh = 0.00000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhhhh = 0.000000000001;\n    \n    // The tube is a cylinder with a"}], [{"generated_text": "\n    float tubeWidth = 0.005;\n\n    // Tube height.\n    float tubeHeight = 0.005;\n\n    // Tube radius.\n    float tubeRadius = 0.005;\n\n    // Tube thickness.\n    float tubeThickness = 0.0005;\n\n    // Tube color.\n    vec4 tubeColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube inner color.\n    vec4 tubeInnerColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube bands color.\n    vec4 tubeBandsColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness"}], [{"generated_text": "\n    float g = floor(gID);\n    \n    // The distance from the point to the grid cell.\n    float d = p.x - g;\n    \n    // The distance from the point to the grid cell.\n    float d2 = p.y - g;\n    \n    // The distance from the point to the grid cell.\n    float d3 = p.z - g;\n    \n    // The distance from the point to the grid cell.\n    float d4 = p.x - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d5 = p.y - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d6 = p.z - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d7 = p.x - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d8 = p.y - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d9 = p.z - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d10 = p.x - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d11 = p.y - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d12 = p.z - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d13 = p.x - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d14 = p.y - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d15 = p.z - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d16 = p.x - g + 5.0;\n    \n    // The distance from the point to the"}], [{"generated_text": "\n    float t = 0., tmin = 1e10;\n    \n    // Loop until we reach the maximum ray distance or the object is hit.\n    for(int i = 0; i < 100; i++){\n        \n        // Get the current ray position.\n        vec3 p = o + r * t;\n        \n        // Get the distance to the object at the current ray position.\n        float d = length(p - object_position);\n        \n        // If the ray is closer than the current nearest distance, update the nearest distance.\n        if(d < tmin){\n            tmin = d;\n        }\n        \n        // If the ray is closer than the maximum ray distance, stop the ray.\n        if(t + d > max_ray_distance){\n            break;\n        }\n        \n        // Update the ray position.\n        t += d;\n    }\n    \n    // If the ray is closer than the maximum ray distance, return the nearest distance.\n    if(t < max_ray_distance){\n        return tmin;\n    }\n    \n    // If the ray is closer than the maximum ray distance, return the maximum ray distance.\n    return max_ray_distance;\n}\n\n// Calculate the color of the ray.\nvec"}], [{"generated_text": "\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm"}], [{"generated_text": "\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting"}], [{"generated_text": "\n    vec3 w = abs(m[0] * p3) + abs(m[1] * p3) + abs(m[2] * p3);\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // compute barycentric coordinates\n    return vec4(1.0 - w.x - w.y - w.z, w.x, w.y, w.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec"}], [{"generated_text": "\n    vec4 hexagonCenter = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonID = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID2 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID3 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID4 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID5 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID6 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID7 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID8 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID9 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID10 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID11 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hex"}], [{"generated_text": "\n    vec2 uv = vec2(df_truchet(p), dir);\n    \n    // The Truchet distance field is a 2D texture, so we need to sample it.\n    // The second argument is the \"wrap\" mode, which is set to clamp.\n    return texture2D(df_texture, uv).r;\n}\n\n// The Truchet distance field is a 2D texture, so we need to sample it.\n// The second argument is the \"wrap\" mode, which is set to clamp.\nfloat"}], [{"generated_text": "\n    // q is the pixel position.\n    // dir is the direction of the arc.\n    //\n    // The direction is in radians.\n    //\n    // The polar coordinate is the angle of the arc.\n    //\n    // The polar coordinate is in radians.\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar"}], [{"generated_text": "\n    vec3 w = abs(n[0].xyz) * dot(p3, n[0].xyz);\n    w += abs(n[1].xyz) * dot(p3, n[1].xyz);\n    w += abs(n[2].xyz) * dot(p3, n[2].xyz);\n    return vec4(w, 1.0) / dot(w, t);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec"}], [{"generated_text": ".\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // If the line is parallel to the plane, then\n  // the distance is zero.\n  if (abs(r.w) < EPSILON) {\n    return 0.0;\n  }\n\n  // Compute the distance to the line.\n  float t = (p.w - q.w) / r.w;\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (t < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the distance to the plane.\n  float d = dot(r, q) - dot(r, p);\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (d < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the distance to the point.\n  float s = d / r.w;\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (s < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the squared distance to the point.\n  float d2 = s * s;\n\n  // Compute the squared distance to the line.\n  float d3 = d2 + t * t;\n\n  // Return the squared distance to the line.\n  return d3;\n}\n\n// Find the (squared) distance to the line in R3 but\n// using homogeneous coordinates.\nfloat"}], [{"generated_text": "\n    float t = tru(p, lW);\n    float t2 = tru(p, lW*2.0);\n    float t3 = tru(p, lW*3.0);\n    float t4 = tru(p, lW*4.0);\n    float t5 = tru(p, lW*5.0);\n    float t6 = tru(p, lW*6.0);\n    float t7 = tru(p, lW*7.0);\n    float t8 = tru(p, lW*8.0);\n    float t9 = tru(p, lW*9.0);\n    float t10 = tru(p, lW*10.0);\n    float t11 = tru(p, lW*11.0);\n    float t12 = tru(p, lW*12.0);\n    float t13 = tru(p, lW*13.0);\n    float t14 = tru(p, lW*14.0);\n    float t15 = tru(p, lW*15.0);\n    float t16 = tru(p, lW*16.0);\n    float t17 = tru(p, lW*17.0);\n    float t18 = tru(p, lW*18.0);\n    float t19 = tru(p, lW*19.0);\n    float t20 = tru(p, lW*20.0);\n    float t21 = tru(p, lW*21.0);\n    float t22 = tru(p, lW*22.0);\n    float t23 = tru(p, lW*23.0);\n    float t24 = tru(p, lW*24.0);\n    float t25 = tru(p, lW*25.0);\n    float t26 = tru(p, lW*26.0);\n    float t27 = tru(p, lW*"}], [{"generated_text": "\n\tfloat k = 1.0 / ( 2.0 * ( ddx.x * ddy.y - ddy.x * ddx.y ) );\n\n\t// sample texture\n\tvec2 dp = ddx * ddy;\n\tvec2 dp2 = dp * dp;\n\tvec2 dp3 = dp2 * dp;\n\tvec2 dp4 = dp3 * dp;\n\tvec2 dp5 = dp4 * dp;\n\tvec2 dp6 = dp5 * dp;\n\tvec2 dp7 = dp6 * dp;\n\tvec2 dp8 = dp7 * dp;\n\tvec2 dp9 = dp8 * dp;\n\tvec2 dp10 = dp9 * dp;\n\tvec2 dp11 = dp10 * dp;\n\tvec2 dp12 = dp11 * dp;\n\tvec2 dp13 = dp12 * dp;\n\tvec2 dp14 = dp13 * dp;\n\tvec2 dp15 = dp14 * dp;\n\tvec2 dp16 = dp15 * dp;\n\tvec2 dp17 = dp16 * dp;\n\tvec2 dp18 = dp17 * dp;\n\tvec2 dp19 = dp18 * dp;\n\tvec2 dp20 = dp19 * dp;\n\tvec2 dp21 = dp20 * dp;\n\tvec2 dp22 = dp21 * dp;\n\tvec2 dp23 = dp22 * dp;\n\tvec2 dp24 = dp23 * dp;\n\tvec2 dp25 = dp24 * dp;\n\tvec2 dp26 = dp25 * dp;\n\tvec2 dp27 = dp26 * dp;\n\tvec2 dp28 = dp27 * dp;\n\tvec2 dp29 = dp28 * dp"}], [{"generated_text": " of query point\n    vec2 q = floor(n);\n    // take half-cell position of query point\n    vec2 qf = floor(f);\n    // take half-cell position of query point\n    vec2 qn = floor(n+1.0);\n    // take half-cell position of query point\n    vec2 qnf = floor(f+1.0);\n    // take half-cell position of query point\n    vec2 qnq = floor(n+q);\n    // take half-cell position of query point\n    vec2 qnqf = floor(f+q);\n    // take half-cell position of query point\n    vec2 qnqn = floor(n+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnf = floor(f+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnq = floor(n+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqf = floor(f+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqn = floor(n+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnf = floor(f+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnq = floor(n+q+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqnqf = floor(f+q+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqnqn = floor(n+q+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnqnf = floor(f+q+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnqn"}], [{"generated_text": "\n    return vec2(\n        mix(p1.x,p2.x,t),\n        mix(p1.y,p2.y,t)\n    );\n}\n\n////////////////////////////// POSICAO PONTOS\nvec"}], [{"generated_text": "\n\n    // p = p*2891336453.0 + 1.0;\n    // return fract(sin(p)*43758.5453123);\n\n    // This is a much more accurate version of the above, but it's slower.\n    // It's also more accurate, but it's not as nice.\n\n    p = p*2891336453.0 + 1.0;\n    return fract(sin(p)*43758.5453123);\n}\n\n// vec3 to vec3 hash.\nvec"}], [{"generated_text": "\n\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n"}], [{"generated_text": "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n    \n    // Incenter.\n    vec2 incenter = (p0 + p1 + p2) / 3.0;\n    \n    // Rotate incenter.\n    incenter = rotate(incenter, alpha);\n    incenter = rotate(incenter, beta);\n    incenter = rotate(incenter, gamma);\n    \n    return incenter;\n}\n\n// Triangle's circumcenter: The center of the circumcircle, which in essence is the smallest\n// circle that you can fit into a triangle.\nvec"}], [{"generated_text": "\n    float a = distance(p0, p1);\n    float b = distance(p1, p2);\n    float c = distance(p2, p0);\n\n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n\n    // Area of the triangle.\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Circumradius.\n    float r = (a * b * c) / (4.0 * area);\n\n    return r;\n}\n\n// The radius of the triangle's circumcircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat"}], [{"generated_text": "\n   // Returns distance of origin to a plane crossing projected triangle.\n   // h1, h2, h3 are the vertices of the triangle.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1"}], [{"generated_text": "\n    vec2 v0 = vec2(0.0);\n    vec2 v1 = vec2(0.0);\n    vec2 v2 = vec2(0.0);\n    vec2 v3 = vec2(0.0);\n    vec2 v4 = vec2(0.0);\n    vec2 v5 = vec2(0.0);\n    vec2 v6 = vec2(0.0);\n    vec2 v7 = vec2(0.0);\n    \n    // I'm declaring the triangles outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    triObj t0 = triObj(0.0, 0.0, 0.0);\n    triObj t1 = triObj(0.0, 0.0, 0.0);\n    triObj t2 = triObj(0.0, 0.0, 0.0);\n    triObj t3 = triObj(0.0, 0.0, 0.0);\n    triObj t4 = triObj(0.0, 0.0, 0.0);\n    triObj t5 = triObj(0.0, 0.0, 0.0);\n    triObj t6 = triObj(0.0, 0.0, 0.0);\n    triObj t7 = triObj(0.0, 0.0, 0.0);\n    \n    // I'm declaring the triangles outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    triObj t8 = triObj(0.0, 0.0, 0.0);\n    triObj t9 = triObj(0.0, 0.0, 0.0);\n    triObj t10 = triObj(0.0, 0.0, 0.0);\n    triObj t11 = triObj(0.0, 0.0, 0.0);\n    triObj t12 = triObj(0"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    //get the color of the pixel\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color2 = texture(iChannel1, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color3 = texture(iChannel2, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color4 = texture(iChannel3, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color5 = texture(iChannel4, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color6 = texture(iChannel5, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color7 = texture(iChannel6, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color8 = texture(iChannel7, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color9 = texture(iChannel8, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color10 = texture(iChannel9, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color11 = texture(iChannel10, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color12 = texture(iChannel11, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color13 = texture(iChannel12, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color14 = texture(iChannel13, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color15 = texture(iChannel14, uv).rgb;\n\n    //get the color of the pixel\n    vec"}], [{"generated_text": "\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    \n    // Better, but not as nicely as the other methods.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec"}], [{"generated_text": "\n    /////////////////////////////////\n    // 1. Compute the intersection between the ray and the sphere.\n    // 2. If there is an intersection, return true.\n    // 3. If there is no intersection, return false.\n    // 4. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 5. If there is no intersection, return false.\n    // 6. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 7. If there is no intersection, return false.\n    // 8. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 9. If there is no intersection, return false.\n    // 10. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 11. If there is no intersection, return false.\n    // 12. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 13. If there is no intersection, return false.\n    // 14. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 15. If there is no intersection, return false.\n    // 16. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 17. If there is no intersection, return false.\n    // 18. If there is one or two intersections, output the value of the smaller t, the position of the intersection ("}], [{"generated_text": "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true"}], [{"generated_text": "\n    // If there is no hit, return the background color.\n    // If there is a hit, return the color of the object.\n    //////////////////////////////////////////////////////////////////////////\n    // 1. Find the nearest hit point.\n    // 2. If there is no hit, return the background color.\n    // 3. If there is a hit, return the color of the object.\n    //////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    vec3 hitPos_ = vec3(0.0);\n    vec3 hitNormal_ = vec3(0.0);\n    vec3 k_rg_ = vec3(0.0);\n    float t_min = INFINITY;\n    float t_max = -INFINITY;\n    bool hit = false;\n    for (int i = 0; i < num_objects; i++) {\n        float t = IntersectRay(ray, objects[i]);\n        if (t < t_min) {\n            t_min = t;\n        }\n        if (t > t_max) {\n            t_max = t;\n        }\n        if (t > 0.0) {\n            hit = true;\n            hitPos_ = ray.origin + t * ray.dir;\n            hitNormal_ = objects[i].normal(hitPos_);\n            k_rg_ = objects[i].k_rg;\n        }\n    }\n    if (hit) {\n        hasHit = true;\n        hitPos = hitPos_;\n        hitNormal = hitNormal_;\n        k_rg = k_rg_;\n    } else {\n        hasHit = false;\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is"}], [{"generated_text": "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p20 = mix(p2, p0, 0.5);\n\n    // midpoints\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p120 = mix(p12, p20, 0.5);\n    vec2 p201 = mix(p20, p01, 0.5);\n\n    // corners\n    vec2 p0120 = mix(p012, p120, 0.5);\n    vec2 p1201 = mix(p120, p201, 0.5);\n    vec2 p2010 = mix(p201, p012, 0.5);\n\n    // return the bbox\n    return vec4(p0120, p1201, p2010);\n}\n\n// Approximate BBox to a quadratic bezier\nvec"}], [{"generated_text": "\n    vec3 bmin = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 bmax = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 bcenter = 0.5 * ( bmin + bmax );\n\n    // diagonal\n    vec3 bdiag = bmax - bmin;\n\n    // return\n    return bound3( bcenter - 0.5 * bdiag, bcenter + 0.5 * bdiag );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/conecone/conecone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n"}], [{"generated_text": "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TAU = 2.0 * PI;\n    const float PI_OVER_2 = PI / 2.0;\n    const float PI_OVER_4 = PI / 4.0;\n    const float PI_OVER_6 = PI / 6.0;\n    const float PI_OVER_8 = PI / 8.0;\n    const float PI_OVER_16 = PI / 16.0;\n    const float PI_OVER_32 = PI / 32.0;\n    const float PI_OVER_64 = PI / 64.0;\n    const float PI_OVER_128 = PI / 128.0;\n    const float PI_OVER_256 = PI / 256.0;\n    const float PI_OVER_512 = PI / 512.0;\n    const float PI_OVER_1024 = PI / 1024.0;\n    const float PI_OVER_2048 = PI / 2048.0;\n    const float PI_OVER_4096 = PI / 4096.0;\n    const float PI_OVER_8192 = PI / 8192.0;\n    const float PI_OVER_16384 = PI / 16384.0;\n    const float PI_OVER_32768 = PI / 32768.0;\n    const float PI_OVER_65536 = PI / 65536.0;\n    const float PI_OVER_131072 = PI / 131072.0;\n    const float PI_OVER_262144 = PI / "}], [{"generated_text": "\n    return cos( k * PI / 2.0 ); // EaseInOut\n}\n\n/**\n * Easing Curve\n */\nfloat"}], [{"generated_text": "\n    vec4 b = vec4(v.x - floor(v.x + 0.5), v.x - floor(v.x - 0.5),\n                  v.y - floor(v.y + 0.5), v.y - floor(v.y - 0.5));\n\n    // Gradients\n    // (N*5 - 1) / 4 used to avoid 0s in the gradient.\n    vec4 o = vec4(0.041970724, 0.024665052, 0.014403290, 0.009360530) - b;\n\n    // Mix final noise value\n    vec4 n0 = vec4(dot(b, vec4(dot(o, vec4(1.000000, 57.000000, 113.000000, 259.000000)))));\n    vec4 n1 = vec4(dot(b, vec4(dot(o, vec4(33.000000, 21.000000, 3.000000, 9.000000)))));\n\n    return 49.000000 * (dot(n0, v) + dot(n1, v + vec4(1.000000, 1.000000, 0.000000, 0.000000)));\n}\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat"}], [{"generated_text": "\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n"}], [{"generated_text": "\n    coord -= vec2(0.5);\n\n    // Scale the coordinate to the size of the screen.\n    coord *= res;\n\n    // Translate the coordinate to the center of the screen.\n    coord += vec2(0.5);\n\n    return coord;\n}\n\n// Remap the OpenGL space to the space where the julia set is defined ( [(-2;-2),(2;2)] ).\nvec"}], [{"generated_text": "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f"}], [{"generated_text": "\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 rgb2hcv = rgb * 2.04040323 - 0.5;\n    rgb2hcv.xz *= mat2(1.0, 1.0, -1.0, -1.0);\n    rgb2hcv.y = sqrt(rgb2hcv.y);\n    return rgb2hcv;\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec"}], [{"generated_text": "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but still not as nicely dispersed.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with perlin noise.\nfloat"}], [{"generated_text": "\n    const float eps = 0.0001;\n    return normalize(\n        vec3(\n            map( p + vec3( eps, 0.0, 0.0 ) ) - map( p - vec3( eps, 0.0, 0.0 ) ),\n            map( p + vec3( 0.0, eps, 0.0 ) ) - map( p - vec3( 0.0, eps, 0.0 ) ),\n            map( p + vec3( 0.0, 0.0, eps ) ) - map( p - vec3( 0.0, 0.0, eps ) )\n        )\n    );\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec"}], [{"generated_text": "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// 2D Perlin Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat"}], [{"generated_text": "\n    float angle = TWO_PI / width;\n    float x = radius * cos(angle);\n    float y = radius * sin(angle);\n    return DrawPoint(pos + vec2(x, y), 0.001);\n}\n\n// Draw a piece of leaf points to LEFT ((0,0)->(-1,0))\n// width (0.,1.)\nfloat"}], [{"generated_text": "\n    vec4 v3 = vec4(v.x - floor(v.x + 0.5), v.y - floor(v.y + 0.5), 0.0, 0.0);\n    vec4 i3 = floor(v3 + 0.5);\n\n    // Replicate v3 to full 4x4 grid of v\n    vec4 v4 = smoothstep(vec4(0.0), vec4(1.0, 1.0, 1.0, 1.0), v3);\n\n    // Linearly interpolate between four corners of a tile\n    vec4 i = vec4(i3.x + i3.y * 57.0, i3.x + 1.0 + i3.y * 57.0, i3.x + i3.y * 113.0, i3.x + 1.0 + i3.y * 113.0);\n    vec4 x = v4.xzxy + v4.ywys;\n\n    // Mix final noise value in range 0-1\n    return mix(mix(mix(dot(x, vec4(1.0, 57.0, 57.0, 113.0)), x.y), x.z, x.w), x.x, v4.y);\n}\n\n//SNOISE\nfloat"}], [{"generated_text": "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// get the ray direction\n\tvec3 rayDir = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n\t\n\t// get the ray origin\n\tvec3 rayOrigin = vec3(0.0);\n\t\n\t// get the ray color\n\tvec3 rayColor = vec3(0.0);\n\t\n\t// get the ray distance\n\tfloat rayDistance = 0.0;\n\t\n\t// get the ray depth\n\tfloat rayDepth = 0.0;\n\t\n\t// get the ray normal\n\tvec3 rayNormal = vec3(0.0);\n\t\n\t// get the ray material\n\tvec3 rayMaterial = vec3(0.0);\n\t\n\t// get the ray light\n\tvec3 rayLight = vec3(0.0);\n\t\n\t// get the ray reflections\n\tvec3 rayReflections = vec3(0.0);\n\t\n\t// get the ray refractions\n\tvec3 rayRefractions = vec3(0.0);\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex2 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex3 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex4 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex5 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex6 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex7 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex8 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex9 = 0.0;\n\t\n\t// get the ray refractive index"}], [{"generated_text": "\n    float n = noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\n// Thanks Shane.\nfloat"}], [{"generated_text": "\n\tvec3 q = log(p);\n\n\t// Apply the tiling\n\tq.xz *= TILE_SIZE;\n\n\t// Apply the offset\n\tq.xz += TILE_OFFSET;\n\n\t// Apply the rotation\n\tq.yzx = mul(q.yzx, ROTATION);\n\n\t// Apply the inverse log-spherical map\n\tsp = exp(q);\n\n\t// Apply the tiling\n\ttp = sp.xz * TILE_SIZE;\n\n\t// Apply the offset\n\ttp += TILE_OFFSET;\n\n\t// Apply the rotation\n\trp = mul(tp, ROTATION);\n\n\t// Apply the scaling\n\tmul = TILE_SCALE;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\t// Apply the forward log-spherical map\n\tvec3 q = log(p);\n\n\t// Apply the tiling\n\tq.xz *= TILE_SIZE;\n\n\t// Apply the offset\n\tq.xz += TILE_OFFSET;\n\n\t// Apply the rotation\n\tq.yzx = mul(q.yzx, ROTATION);\n\n\t// Apply the inverse log-spherical map\n\tsp = exp(q);\n\n\t// Apply the tiling\n\ttp = sp.xz * TILE_SIZE;\n\n\t// Apply the offset\n\ttp += TILE_OFFSET;\n\n\t// Apply the rotation\n\trp = mul(tp, ROTATION);\n\n\t// Apply the scaling\n\tmul = TILE_SCALE;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`"}], [{"generated_text": "\n    float d = length(p.xy) - 0.5;\n    //distance to plane = distance to center of plane minus height\n    //x-pos and height vary over time in some sin/cos pattern\n    float d2 = p.z - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d3 = length(p.xy) - 0.5;\n    //distance to cone = distance to center of cone minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d4 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d5 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d6 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d7 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d8 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d9 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d10 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d11 = length(p.xy) - 0."}], [{"generated_text": "\n  return vec2(z.x*w.x-z.y*w.y, z.y*w.x+z.x*w.y);\n}\n\n// Complex functions\nvec"}], [{"generated_text": "\n\tret += vec3(p.x, p.y, 0.0);\n\tret += vec3(p.x, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize, p.y, 0.0);\n\n\t// T to R\n\tret += vec3(p.x + aaSize, p.y, 0.0);\n\tret += vec3(p.x + aaSize, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y, 0.0);\n\n\t// R to B\n\tret += vec3(p.x + aaSize * 2.0, p.y, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y, 0.0);\n\n\t// B to L\n\tret += vec3(p.x + aaSize * 3.0, p.y, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x, p.y + aaSize, 0.0);\n\tret += vec3(p.x, p.y, 0.0);\n}\n\n/*\nConstruct a Penrose triangle in 3D by manually placing a bunch of angled\nsquares. Nothing really magic.\n*/\nvoid drawPen"}], [{"generated_text": "\n    mat3 rot = mat3(\n        vec3(cos(time), 0.0, sin(time)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(time), 0.0, cos(time))\n    );\n\n    // rotate the position of the box\n    vec3 rotatedPos = rot * pos;\n\n    // get the distance to the box\n    vec2 dist = vec2(length(rotatedPos.xz) - 0.5, rotatedPos.y);\n\n    // get the material ID of the box\n    vec2 materialID = vec2(0.0, 0.0);\n\n    // if the box is closer to the camera than the previous closest box, update the closest box\n    if (dist.x < closestBox.x) {\n        closestBox = dist;\n        materialID = vec2(1.0, 0.0);\n    }\n\n    // if the box is closer to the camera than the previous closest box, update the closest box\n    if (dist.x < closestBox2.x) {\n        closestBox2 = dist;\n        materialID = vec2(1.0, 1.0);\n    }\n\n    // return the distance to the box and the material ID\n    return dist;\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec"}], [{"generated_text": "\n    float dist = length(pos.xz) - 0.5;\n\n    // if the sphere is closer to the camera, make it darker\n    float darken = smoothstep(0.0, 0.05, dist);\n\n    // return the distance to the sphere and the material ID\n    return vec2(dist, darken);\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec"}], [{"generated_text": "\n    vec2 res = vec2(1.0);\n    res.x = sdf_sphere(pos, vec3(0.0, 0.0, 0.0), 0.5);\n    res.y = sdf_sphere(pos, vec3(0.0, 0.0, 0.0), 0.1);\n    return res;\n}\n\n// this is the combined scene sdf function for the shadow ray.\n// it returns a vec2 containing a depth value for the x coordinate, and a material ID for the y coordinate.\nvec"}], [{"generated_text": "\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // march the ray in the scene\n    vec4 color = vec4(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = camPos + rayDir * t;\n        vec4 s = scene(p);\n        color += s;\n        t += s.a;\n        if (t > MAX_DIST || s.a < 0.001) break;\n    }\n    \n    // return the color of the ray\n    return color;\n}\n\n// raymarches our scene with a provided camera position, camera direction, and simple directional light\nvec"}], [{"generated_text": "\n\tvec3 bmin = rad;\n\tvec3 bmax = -rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(max(t1.x, t1.y), t1.z);\n\tfloat tN = min(min(t2.x, t2.y), t2.z);\n\tif (t0 > tN) return vec2(-1.0);\n\treturn vec2(t0, tN);\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec"}], [{"generated_text": "\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// raymarching\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n"}], [{"generated_text": "\n    return dot(plane.normal, pos) - plane.distance;\n}\n\n// @brief Get signed-distance funciton weight value of sphere.\nfloat"}], [{"generated_text": " cell coordinates\n    ivec3 gx = ix;\n    // grid cell coordinates offset by 1\n    ivec3 gy = ix + ivec3(1, 1, 1);\n    // grid cell coordinates offset by 2\n    ivec3 gz = ix + ivec3(2, 2, 2);\n    // grid cell coordinates offset by 3\n    ivec3 gw = ix + ivec3(3, 3, 3);\n    // grid cell coordinates offset by 4\n    ivec3 gx1 = ix + ivec3(4, 4, 4);\n    // grid cell coordinates offset by 5\n    ivec3 gy1 = ix + ivec3(5, 5, 5);\n    // grid cell coordinates offset by 6\n    ivec3 gz1 = ix + ivec3(6, 6, 6);\n    // grid cell coordinates offset by 7\n    ivec3 gw1 = ix + ivec3(7, 7, 7);\n    // grid cell coordinates offset by 8\n    ivec3 gx2 = ix + ivec3(8, 8, 8);\n    // grid cell coordinates offset by 9\n    ivec3 gy2 = ix + ivec3(9, 9, 9);\n    // grid cell coordinates offset by 10\n    ivec3 gz2 = ix + ivec3(10, 10, 10);\n    // grid cell coordinates offset by 11\n    ivec3 gw2 = ix + ivec3(11, 11, 11);\n    // grid cell coordinates offset by 12\n    ivec3 gx3 = ix + ivec3(12, 12, 12);\n    // grid cell coordinates offset by 13\n    ivec3 gy3 = ix + ivec3(13, 13, 13);\n    // grid cell coordinates offset by 14\n    ivec3 gz3 = ix + ivec3(14, 14, 14);\n    // grid cell coordinates"}], [{"generated_text": "\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we"}], [{"generated_text": "\n    float s = sin(p.x);\n    p.x = abs(p.x);\n    p.x = p.x - 2.0 * s;\n    p.x = abs(p.x);\n    p.x = max(p.x, 0.0);\n    p.x = min(p.x, 1.0);\n    p.x = p.x * p.x * (3.0 - 2.0 * p.x);\n\n    // Distance to the capsule\n    float d = length(p) - r;\n\n    // Slice shift effect (only applied on instance of capsule)\n    p.x = abs(p.x);\n    p.x = p.x - 2.0 * s;\n    p.x = abs(p.x);\n    p.x = max(p.x, 0.0);\n    p.x = min(p.x, 1.0);\n    p.x = p.x * p.x * (3.0 - 2.0 * p.x);\n\n    // Distance to the capsule\n    d = max(d, -p.x);\n\n    // Return the distance to the capsule\n    return d;\n}\n\nfloat"}], [{"generated_text": "\n     p.xz = mat2(cos(time),sin(time),-sin(time),cos(time))*p.xz;\n     p.xz += vec2(sin(time),cos(time))*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2"}], [{"generated_text": "\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.  , 0.001)\n  // eps.xyx <=> vec3(0.  , 0.001, 0.001)\n  // eps.yxx <=> vec3(0.  , 0.001, 0.001)\n  // eps.yxy <=> vec3(0.  , 0.001, 0.001)\n  // eps.yyx <=> vec3(0.  , 0.001, 0.001)\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.xyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.yyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.xyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxx <=> vec3(0"}], [{"generated_text": "\n    return max(dot(n,l),0.0);\n}\n\n// Lighting part, still confusing\nfloat"}], [{"generated_text": "\n    vec4 q = vec4( rd.x, rd.y, rd.z, -ra*ra );\n    vec4 k = vec4( 1.0, 1.0, 1.0, -4.0 );\n    vec4 u = solveQuartic( q, k );\n\n    // -----------------------------\n    // check if ray intersects sphere\n    // -----------------------------\n    float tmin = u.x;\n    float tmax = u.y;\n    if( tmin > tmax )\n    {\n        return -1.0;\n    }\n\n    // -----------------------------\n    // compute sphere intersection\n    // -----------------------------\n    float t = tmin;\n    vec3 p = ro + t*rd;\n    float d = length( p );\n    if( d > ra )\n    {\n        return -1.0;\n    }\n\n    return t;\n}\n\n// -----------------------------\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat"}], [{"generated_text": "\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    // gradient\n    vec2 g = dpdx*f.x + dpdy*f.y;\n    g = f*f*(3.0-2.0*f);\n\n    // sum\n    return dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat"}], [{"generated_text": "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -1.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 1.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 1.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -1.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[5].center.x = -1.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = 0.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[6].center.x = 1.0;\n    Sphere[6].center.y = 0.0;\n    Sphere"}], [{"generated_text": "\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and t"}], [{"generated_text": "\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION CODE. //\n    ////////////////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION CODE. //\n    ////////////////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n"}], [{"generated_text": "\n    vec3 nearestHitPos = vec3(0.0);\n    vec3 nearestHitNormal = vec3(0.0);\n    vec3 nearestHitK_rg = vec3(0.0);\n    float nearestHitT = INFINITY;\n    for ( int i = 0; i < scene.numObjects; i++ ) {\n        Intersection_t hit = IntersectRay( ray, scene.objects[i] );\n        if ( hit.t < nearestHitT ) {\n            nearestHitT = hit.t;\n            nearestHitPos = hit.pos;\n            nearestHitNormal = hit.normal;\n            nearestHitK_rg = hit.k_rg;\n        }\n    }\n\n    // If there is no intersection, return the background color.\n    if ( nearestHitT == INFINITY ) {\n        hasHit = false;\n        hitPos = vec3(0.0);\n        hitNormal = vec3(0.0);\n        k_rg = vec3(0.0);\n        return scene.backgroundColor;\n    }\n\n    // If there is intersection, compute the color at the hit point.\n    hasHit = true;\n    hitPos = nearestHitPos;\n    hitNormal = nearestHitNormal;\n    k_rg = nearestHitK_rg;\n\n    // Compute the color at the hit point using Phong Lighting Model.\n    vec3 color = vec3(0.0);\n    for ( int i = 0; i < scene.numLights; i++ ) {\n        // Compute the shadow ray.\n        Ray_t shadowRay = Ray_t( nearestHitPos, scene.lights[i].pos - nearestHitPos );\n\n        // Find whether the shadow ray hits any object.\n        bool shadowHit = false;\n        for ( int j = 0; j < scene.numObjects; j++ ) {\n            Intersection_t shadowHit = IntersectRay( shadowRay, scene.objects[j] );\n            if ( shadowHit.t < scene.objects[j].radius ) {\n                shadowHit = true;\n                break;\n            }\n        }\n\n        // If the shadow"}], [{"generated_text": " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n\n    // shadow accumulator\n    float shade = 0.0;\n\n    // number of steps\n    const int steps = 100;\n\n    // step size\n    float d = 1.0 / float(steps);\n\n    // step count\n    int i = 0;\n\n    // loop\n    for( ; i < steps; i++ )\n    {\n        // get the current position\n        vec3 p = ro + rd * tmax;\n\n        // get the current depth\n        float t = texture( shadowMap, p.xy ).x;\n\n        // if the current depth is greater than the current bounding volume\n        // then we have a shadow\n        if( t > bv.z )\n        {\n            // add the current depth to the accumulator\n            shade += t - bv.z;\n\n            // if the current depth is less than the minimum depth then we\n            // have a shadow\n            if( t < mint )\n            {\n                // we are done\n                break;\n            }\n\n            // update the bounding volume\n            bv = bv + vec4(rd * d, 0.0);\n        }\n\n        // update the maximum depth\n        tmax -= d;\n    }\n\n    // return the shadow\n    return shade / float(i);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat"}], [{"generated_text": "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat"}], [{"generated_text": "\n    start += planet_position;\n\n    // the color of the rayleigh scattering\n    vec3 rayleigh_color = vec3(0.0);\n\n    // the color of the mie scattering\n    vec3 mie_color = vec3(0.0);\n\n    // the color of the absorption\n    vec3 absorption_color = vec3(0.0);\n\n    // the color of the ambient\n    vec3 ambient_color = vec3(0.0);\n\n    // the color of the final result\n    vec3 final_color = vec3(0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0);\n\n    // the color of the atmosphere\n    vec3 atmosphere_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_2 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_2 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_3 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_3 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_4 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_4 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_5 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_5 = vec3(0"}], [{"generated_text": "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // sample the skylight\n    vec3 skylight_sample = texture(skylight_tex, sample_pos.xy).rgb;\n\n    // sample the skylight in the direction of the light direction\n    vec3 skylight_sample_light = texture(skylight_tex, sample_pos.xy + light_dir_bend * 0.001).rgb;\n\n    // mix the skylight samples\n    vec3 skylight_mix = mix(skylight_sample, skylight_sample_light, 0.5);\n\n    // mix the skylight with the background color\n    vec3 skylight_mix_background = mix(skylight_mix, background_col, 0.5);\n\n    return skylight_mix_background;\n}\n\n/*\nThe atmosphere function takes in a sample position and a surface normal and returns the color of the atmosphere\n*/\nvec"}], [{"generated_text": "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the distance to the surface\n    float dist = length(pos);\n    \n    // the color of the sphere\n    vec3 sphere_color = vec3(0.0, 1.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_2 = vec3(0.0, 0.0, 1.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_3 = vec3(1.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_4 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_5 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_6 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_7 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_8 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_9 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_10 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_11 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_12 = vec3(0.0, 0.0"}], [{"generated_text": " and position\n    vec3 camPos = cameraPos;\n    vec3 camDir = cameraDir;\n    \n    // get the light dir\n    vec3 lightDir = normalize(lightDir);\n    \n    // get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // get the ray origin\n    vec3 rayOrigin = camPos;\n    \n    // get the ray length\n    float rayLength = 1000.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray step\n    float rayStep = 0.001;\n    \n    // get the ray step\n    float rayStep2 = 0.0001;\n    \n    // get the ray step\n    float rayStep3 = 0.00001;\n    \n    // get the ray step\n    float rayStep4 = 0.000001;\n    \n    // get the ray step\n    float rayStep5 = 0.0000001;\n    \n    // get the ray step\n    float rayStep6 = 0.00000001;\n    \n    // get the ray step\n    float rayStep7 = 0.000000001;\n    \n    // get the ray step\n    float rayStep8 = 0.0000000001;\n    \n    // get the ray step\n    float rayStep9 = 0.00000000001;\n    \n    // get the ray step\n    float rayStep10 = 0.000000000001;\n    \n    // get the ray step\n    float rayStep11 = 0.0000000000001;\n    \n    // get the ray step\n    float rayStep12 = 0.00000000000001;\n    \n    // get the ray step\n    float rayStep13 = 0.000000000000001;\n    \n    //"}], [{"generated_text": "\n\n    // Compute a\n    vec3 a = r0 - s0;\n\n    // Compute b\n    float b = dot(a, rd);\n\n    // Compute c\n    float c = dot(a, a) - sr * sr;\n\n    // Compute discriminant\n    float d = b * b - c;\n\n    // If discriminant is negative, there are no real roots, so return -1.0\n    if (d < 0.0) {\n        return -1.0;\n    }\n\n    // Compute the two roots\n    float root1 = -b - sqrt(d);\n    float root2 = -b + sqrt(d);\n\n    // Return the smaller root\n    if (root1 < 0.0) {\n        return root2;\n    }\n    if (root2 < 0.0) {\n        return root1;\n    }\n    return min(root1, root2);\n}\n\n//-----------------------------------------------------------------------\n// raySphereIntersect\n//-----------------------------------------------------------------------\nfloat"}], [{"generated_text": "ialize variables\n    vec4 finalColor = vec4(0.0);\n    vec3 rayDir = normalize(cameraRayDir);\n    vec3 rayPos = cameraPos;\n    vec3 rayPos2 = cameraPos;\n    vec3 rayPos3 = cameraPos;\n    vec3 rayPos4 = cameraPos;\n    vec3 rayPos5 = cameraPos;\n    vec3 rayPos6 = cameraPos;\n    vec3 rayPos7 = cameraPos;\n    vec3 rayPos8 = cameraPos;\n    vec3 rayPos9 = cameraPos;\n    vec3 rayPos10 = cameraPos;\n    vec3 rayPos11 = cameraPos;\n    vec3 rayPos12 = cameraPos;\n    vec3 rayPos13 = cameraPos;\n    vec3 rayPos14 = cameraPos;\n    vec3 rayPos15 = cameraPos;\n    vec3 rayPos16 = cameraPos;\n    vec3 rayPos17 = cameraPos;\n    vec3 rayPos18 = cameraPos;\n    vec3 rayPos19 = cameraPos;\n    vec3 rayPos20 = cameraPos;\n    vec3 rayPos21 = cameraPos;\n    vec3 rayPos22 = cameraPos;\n    vec3 rayPos23 = cameraPos;\n    vec3 rayPos24 = cameraPos;\n    vec3 rayPos25 = cameraPos;\n    vec3 rayPos26 = cameraPos;\n    vec3 rayPos27 = cameraPos;\n    vec3 rayPos28 = cameraPos;\n    vec3 rayPos29 = cameraPos;\n    vec3 rayPos30 = cameraPos;\n    vec3 rayPos31 = cameraPos;\n    vec3 rayPos32 = cameraPos;\n    vec3 rayPos33 = cameraPos;\n    vec3 rayPos34 = cameraPos;\n    vec3 rayPos35 = cameraPos;\n    vec3 rayPos36 = cameraPos;\n    vec3 rayPos37 = cameraPos;\n    vec3 ray"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"}], [{"generated_text": " ray\n    vec3 ray_path[MAX_PATHS];\n    ray_path[0] = ray_origin;\n\n    // Initialize the sample color -\n    // the color of the sample ray\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the sample depth -\n    // the depth of the sample ray\n    float sample_depth = 0.0;\n\n    // Initialize the sample index -\n    // the index of the sample ray in the ray path list\n    int sample_index = 0;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray = ray_target;\n\n    // Initialize the sample ray direction -\n    // the direction of the sample ray\n    vec3 sample_ray_direction = normalize(ray_target - ray_origin);\n\n    // Initialize the sample ray length -\n    // the length of the sample ray\n    float sample_ray_length = length(ray_target - ray_origin);\n\n    // Initialize the sample ray length squared -\n    // the length of the sample ray squared\n    float sample_ray_length_squared = sample_ray_length * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed = sample_ray_length_squared * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root = sqrt(sample_ray_length_cubed);\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv = 1.0 / sample_ray_length_cubed_root;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv_2 = sample_ray_length_cubed_root_inv * sample_"}], [{"generated_text": "\n    int cellID = int(p.x) + int(p.y) * 10;\n    vec2 cellCoords = vec2(p.x, p.y);\n    \n    // Local cell coordinates.\n    vec2 cellCoordsLocal = cellCoords - vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1].\n    vec2 cellCoordsLocalRange = cellCoordsLocal / 10.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset.\n    vec2 cellCoordsLocalOffset = cellCoordsLocalRange + vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenter = cellCoordsLocalOffset + vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange = cellCoordsLocalOffsetCenter / 10.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange2 = cellCoordsLocalOffsetCenterRange * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange3 = cellCoordsLocalOffsetCenterRange2 * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange4 = cellCoordsLocalOffsetCenterRange3 * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange5 = cellCoordsLocalOffset"}], [{"generated_text": "\n    vec3 sphere_loc = vec3(0.0, 0.0, 0.0);\n    float sphere_rad = 1.0;\n\n    // calculate distance from sphere\n    float dist = length(p - sphere_loc) - sphere_rad;\n\n    return dist;\n}\n\n// Get the color of the sphere\nvec"}], [{"generated_text": "\n    vec3 Pi0 = floor( P );\n    vec3 Pf0 = fract( P );\n\n    // calculate the distance from each corner to the point\n    vec3 uv0 = Pf0*Pf0*(3.0-2.0*Pf0);\n\n    // calculate the distance from each corner to the point\n    vec3 uv1 = Pf0*(1.0-Pf0)*(1.0-Pf0)*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv2 = 1.0-Pf0*(1.0-Pf0)*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv3 = 1.0-uv0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv4 = Pf0*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv5 = 1.0-uv4;\n\n    // calculate the distance from each corner to the point\n    vec3 uv6 = Pf0*(1.0-uv4);\n\n    // calculate the distance from each corner to the point\n    vec3 uv7 = 1.0-uv6;\n\n    // calculate the distance from each corner to the point\n    vec3 uv8 = Pf0*uv4;\n\n    // calculate the distance from each corner to the point\n    vec3 uv9 = 1.0-uv8;\n\n    // calculate the distance from each corner to the point\n    vec3 uv10 = Pf0*uv6;\n\n    // calculate the distance from each corner to the point\n    vec3 uv11 = 1.0-uv10;\n\n    // calculate the distance from each corner to the point\n    vec3 uv12 = Pf0*uv8;\n\n    // calculate the distance from each corner to the point\n    vec3 uv13 = 1.0-uv12;\n\n    // calculate the distance from each corner to the point\n    vec3 uv14 = Pf0"}], [{"generated_text": "\n    float n = floor(x);\n    float f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    // return noise\n    return mix(\n        noise(n),\n        noise(n + 1.0),\n        f\n    );\n}\n\n// 2D Perlin Noise\nfloat"}], [{"generated_text": "\n    vec3 ground = vec3(0.0, -0.001, 0.0);\n    vec3 ground_size = vec3(100.0, 0.001, 100.0);\n    vec3 ground_pos = vec3(0.0, -0.001, 0.0);\n    vec3 ground_rot = vec3(0.0, 0.0, 0.0);\n    vec3 ground_scale = vec3(1.0, 1.0, 1.0);\n    vec3 ground_color = vec3(0.0, 0.0, 0.0);\n    vec3 ground_normal = vec3(0.0, 1.0, 0.0);\n    vec3 ground_specular = vec3(0.0, 0.0, 0.0);\n    vec3 ground_shininess = 1.0;\n    vec3 ground_transparency = 1.0;\n    vec3 ground_reflection = 0.0;\n    vec3 ground_refraction = 0.0;\n    vec3 ground_emission = vec3(0.0, 0.0, 0.0);\n    vec3 ground_light = vec3(0.0, 0.0, 0.0);\n    vec3 ground_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 ground_light_color = vec3(0.0, 0.0, 0.0);\n    vec3 ground_light_intensity = 0.0;\n    vec3 ground_light_radius = 0.0;\n    vec3 ground_light_angle = 0.0;\n    vec3 ground_light_falloff = 0.0;\n    vec3 ground_light_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 ground_light_color_attenuation = vec3(1.0, "}], [{"generated_text": "\n    vec3 world = p;\n\n    // world to camera\n    vec3 cam = world - vec3(0.0, 0.0, 10.0);\n\n    // camera to screen\n    vec2 screen = cam.xy / cam.z * 0.5 + 0.5;\n\n    // screen to world\n    vec3 worldScreen = vec3(screen, 1.0);\n\n    // world to screen\n    vec2 worldScreen2 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen3 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen4 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen5 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen6 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen7 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen8 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen9 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen10 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen11 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen12 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen13 = worldScreen.xy / world"}], [{"generated_text": " from a to b\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    if (t < 0.0) return d;\n    if (t > 1.0) return d;\n    return d + pix * length(pa - ba * t);\n}\n\nfloat"}], [{"generated_text": "\n\tvec2 st = fragCoord/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*st;\n\tfloat d = length(p);\n\tfloat a = atan(p.y,p.x);\n\tfloat r = (d-0.01)/0.02;\n\tfloat t = iTime*0.2;\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\tfloat m = mod(t,1.0);\n\tfloat n = mod(t,2.0);\n\tfloat k = mod(t,3.0);\n\tfloat l = mod(t,4.0);\n\tfloat o = mod(t,5.0);\n\tfloat p = mod(t,6.0);\n\tfloat q = mod(t,7.0);\n\tfloat r = mod(t,8.0);\n\tfloat s = mod(t,9.0);\n\tfloat t = mod(t,10.0);\n\tfloat u = mod(t,11.0);\n\tfloat v = mod(t,12.0);\n\tfloat w = mod(t,13.0);\n\tfloat x = mod(t,14.0);\n\tfloat y = mod(t,15.0);\n\tfloat z = mod(t,16.0);\n\tfloat a = mod(t,17.0);\n\tfloat b = mod(t,18.0);\n\tfloat c = mod(t,19.0);\n\tfloat d = mod(t,20.0);\n\tfloat e = mod(t,21.0);\n\tfloat f = mod(t,22.0);\n\tfloat g = mod(t,23.0);\n\tfloat h = mod(t,24.0);\n\tfloat i = mod(t,25.0);\n\tfloat j = mod(t,26.0);\n\tfloat k = mod(t,27.0);\n\tfloat l = mod(t,28.0);\n\tfloat m = mod(t,29.0);\n\tfloat n = mod(t,"}], [{"generated_text": "\n    if(p.y > 0.0){\n        return abs(p.x) + abs(p.y);\n    }\n    \n    // Flat bottom and pointed bottom hexagons.\n    else{\n        return abs(p.x) + abs(p.y);\n    }\n}\n\n// Circular bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat"}], [{"generated_text": "\n    return (sin(ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n}\n\n// yea i basically spammed random stuff\nfloat"}], [{"generated_text": "\n    // by theta and phi to get the surface\n    float theta = atan(p.y, p.x);\n    float phi = asin(p.z);\n    float r = length(p);\n    float t = theta / 3.1415926535897932384626433832795;\n    float s = phi / 3.1415926535897932384626433832795;\n    // compute the color\n    return vec3(0.5 + 0.5 * cos(t + s), 0.5 + 0.5 * sin(t + s), 0.5 + 0.5 * cos(t - s));\n}\n\n// compute the color of a ray\nvec"}], [{"generated_text": "\n    p = p * 0.001;\n    // scale to 0-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0"}], [{"generated_text": "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec"}], [{"generated_text": "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec"}], [{"generated_text": "\n\t vec3 s = floor(p);\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, 1.0 - the integer coordinates of the four corners of T */\n\t vec3 i1 = step(vec3(0.0), x - vec3(0.0, 0.0, 1.0));\n\t vec3 i2 = step(vec3(1.0), x - vec3(1.0, 0.0, 1.0));\n\t vec3 i3 = step(vec3(1.0), x - vec3(1.0, 1.0, 1.0));\n\t vec3 i4 = step(vec3(0.0), x - vec3(0.0, 1.0, 1.0));\n\t \n\t /* calculate the contribution from the four corners */\n\t vec3 x1 = x - i1 + (i2 - i1) * vec3(0.0, 0.0, 1.0);\n\t vec3 x2 = x - i2 + (i3 - i2) * vec3(0.0, 0.0, 1.0);\n\t vec3 x3 = x - i3 + (i4 - i3) * vec3(0.0, 0.0, 1.0);\n\t vec3 x4 = x - i4 + (i1 - i4) * vec3(0.0, 0.0, 1.0);\n\t \n\t /* calculate the contribution from the four vertices */\n\t vec3 y0 = x - vec3(0.0, 0.0, 0.0);\n\t vec3 y1 = x - vec3(1.0, 0.0, 0.0);\n\t vec3 y2 = x - vec3(1.0, 1.0, 0.0);\n\t vec3 y3 = x - vec3(0.0, 1.0, 0.0);\n\t vec3 y4 = x - vec3(0.0, 0."}], [{"generated_text": " of the rings\n    float ring = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet2 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet3 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet4 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet5 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet6 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet7 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet8 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet9 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet10 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet11 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet12 = sin( p.x * 10.0 ) * 0.5 + 0.5;"}], [{"generated_text": " in the final image\n    p.xz *= 0.5;\n    p.y -= 0.001;\n\n    // add some noise to the space\n    p.xz += noise( p.xy );\n    p.y += noise( p.xz );\n\n    // add some more noise to the space\n    p.xz += noise( p.yx );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.zy );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.zy );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add"}], [{"generated_text": "\n    float k = floor(rp.x*.75)*.25;\n    float s = sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.01);\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.000025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.000005));\n    s = min(s, sd"}], [{"generated_text": "\n\tfloat t = clamp((end - d) / (end - start), 0.0, 1.0);\n\treturn mix(start, end, t);\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat"}], [{"generated_text": "\n    vec4 hexagonCenter = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon ID is the unique hexagon point.\n    int hexagonID = int(p.x) + int(p.y);\n    \n    // The hexagon center is the hexagon point closest to the current point.\n    if (abs(p.x - floor(p.x)) < abs(p.y - floor(p.y)))\n    {\n        hexagonCenter = vec4(p.x, 0.0, 0.0, hexagonID);\n    }\n    else\n    {\n        hexagonCenter = vec4(0.0, p.y, 0.0, hexagonID);\n    }\n    \n    // The hexagon center is the hexagon point closest to the current point.\n    return hexagonCenter;\n}\n\n//\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec"}], [{"generated_text": "\n    vec2 r = vec2(random(p), random(p+vec2(1.0)));\n    \n    // The distance field.\n    vec2 d = vec2(0.0);\n    \n    // The distance field.\n    for(int i=0; i<2; i++){\n        for(int j=0; j<2; j++){\n            d += abs(r[j]-0.5);\n        }\n        r = rotate(r);\n    }\n    \n    // The distance field.\n    return d;\n}\n\n// The distance field.\nvec"}], [{"generated_text": "\n    float scale = (mouse.x - 0.5) / 0.5;\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0 && scale < 1.0) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color2 = vec3(0.0, 0.0, 0.0);\n    if (scale > 1.0 && scale < 2.0) {\n        color2 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    if (scale > 2.0 && scale < 3.0) {\n        color3 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color4 = vec3(0.0, 0.0, 0.0);\n    if (scale > 3.0 && scale < 4.0) {\n        color4 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 ("}], [{"generated_text": " from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the"}], [{"generated_text": "\n    return smoothstep(pct-EPSILON, pct, st.y) - smoothstep(pct, pct+EPSILON, st.y);\n}\n\n// Plot a line on X using a value between 0.0-1.0\nfloat"}], [{"generated_text": "\n    //\n    // I'm not going to go into the details of the hyperbolic geometry here,\n    // but I'll say that the hyperbolic geometry is a bit more involved than\n    // the Euclidean geometry, so I'll leave that to you.\n\n    // The following is the number of polygon sides (N) and the number of adjacent\n    // polygons (Q) that meet at a vertex point.\n    int N = int(gl_FragCoord.x);\n    int Q = int(gl_FragCoord.y);\n\n    // The following is the radius of the initial circle.\n    float r = float(N);\n\n    // The following is the distance from the center of the initial circle to the\n    // center of the circle that runs adjacent to the current domain edges.\n    float d = float(Q);\n\n    // The following is the angle of the initial circle.\n    float a = float(Q);\n\n    // The following is the angle of the initial circle.\n    float b = float(Q);\n\n    // The following is the angle of the initial circle.\n    float c = float(Q);\n\n    // The following is the angle of the initial circle.\n    float d = float(Q);\n\n    // The following is the angle of the initial circle.\n    float e = float(Q);\n\n    // The following is the angle of the initial circle.\n    float f = float(Q);\n\n    // The following is the angle of the initial circle.\n    float g = float(Q);\n\n    // The following is the angle of the initial circle.\n    float h = float(Q);\n\n    // The following is the angle of the initial circle.\n    float i = float(Q);\n\n    // The following is the angle of the initial circle.\n    float j = float(Q);\n\n    // The following is the angle of the initial circle.\n    float k = float(Q);\n\n    // The following is the angle of the initial circle.\n    float l = float(Q);\n\n    // The following is the angle of the initial circle.\n    float m = float(Q);\n\n    // The following is the angle of the initial circle.\n    float n = float("}], [{"generated_text": "\n    float ia =.5/float(N);\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = mod(a + ia, 2.0*pi);\n    float s = sign(c - a);\n    float r2 = sqrt(r);\n    float c2 = mod(c + ia, 2.0*pi);\n    float s2 = sign(c2 - c);\n    float r3 = sqrt(r2);\n    float c3 = mod(c2 + ia, 2.0*pi);\n    float s3 = sign(c3 - c2);\n    float r4 = sqrt(r3);\n    float c4 = mod(c3 + ia, 2.0*pi);\n    float s4 = sign(c4 - c3);\n    float r5 = sqrt(r4);\n    float c5 = mod(c4 + ia, 2.0*pi);\n    float s5 = sign(c5 - c4);\n    float r6 = sqrt(r5);\n    float c6 = mod(c5 + ia, 2.0*pi);\n    float s6 = sign(c6 - c5);\n    float r7 = sqrt(r6);\n    float c7 = mod(c6 + ia, 2.0*pi);\n    float s7 = sign(c7 - c6);\n    float r8 = sqrt(r7);\n    float c8 = mod(c7 + ia, 2.0*pi);\n    float s8 = sign(c8 - c7);\n    float r9 = sqrt(r8);\n    float c9 = mod(c8 + ia, 2.0*pi);\n    float s9 = sign(c9 - c8);\n    float r10 = sqrt(r9);\n    float c10 = mod(c9 + ia, 2.0*pi);\n    float s10 = sign(c10 - c9);\n    float r11 = sqrt(r10);\n    float c11"}], [{"generated_text": "\n    vec2 m = vec2(mouseX, mouseY);\n    \n    // Mouse position inverted.\n    vec2 mInv = vec2(1.0 - m.x, 1.0 - m.y);\n    \n    // Mouse position inverted.\n    return mInv - p;\n}\n\n// Mouse pointer inversion.\nvec"}], [{"generated_text": "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 ="}], [{"generated_text": "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t// Camera\n\tvec3 ro = vec3( 0.0, 0.0, 1.0 );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n\tvec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 vv = normalize( cross(uu,ww));\n\t\n\t// Camera Movement\n\tfloat speed = 0.01;\n\tfloat rotSpeed = 0.002;\n\tfloat zoomSpeed = 0.0001;\n\tfloat zoom = 1.0;\n\t\n\t// Camera Rotation\n\tfloat rotX = iTime * rotSpeed;\n\tfloat rotY = iTime * rotSpeed;\n\t\n\t// Camera Zoom\n\tfloat zoomAmount = iMouse.z * zoomSpeed;\n\t\n\t// Camera Movement\n\tfloat moveSpeed = speed * zoom;\n\t\n\t// Camera Movement\n\tro += moveSpeed * ( p.x*uu + p.y*vv );\n\t\n\t// Camera Rotation\n\trotY += p.x * rotSpeed;\n\trotX += p.y * rotSpeed;\n\t\n\t// Camera Rotation\n\tvec3 vp = vec3( sin(rotY)*cos(rotX), cos(rotY), sin(rotY)*sin(rotX) );\n\tww = normalize( ta - ro );\n\tuu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvv = normalize( cross(uu,ww));\n\t\n\t// Light\n\tvec3 light = vec3( 0.0, 0.0, 1.0 );\n\t\n\t// Light\n\tvec3 col = vec3( 0.0 );\n\t\n\t// Light\n\tvec3 n = normalize( vec3"}], [{"generated_text": "\n\n    // Get the position of the pixel in the image.\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the pixel in the polar coordinate system.\n    vec2 q = vec2(\n        atan(p.y - 0.5, p.x - 0.5) / 3.1415926535897932384626433832795,\n        length(p - 0.5)\n    );\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb = hsv2rgb(hsb);\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb2 = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb2 = hsv2rgb(hsb2);\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb3 = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb3 = hsv2rgb(hsb3);\n\n    // Get the position of the pixel in the HSB colour space.\n   "}], [{"generated_text": " axis\n    vec3 v = vec3(\n        hash * 2.0 - 1.0,\n        hash * 2.0 - 1.0,\n        hash * 2.0 - 1.0\n    );\n    \n    // Gradient set is a normalized expanded rhombic dodecahedron\n    return normalize(v);\n}\n\n// Hash function\nfloat"}], [{"generated_text": "\n    vec3 Y = normalize(cross(X.xy, X.zx));\n    vec3 Z = normalize(cross(Y, X));\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3("}], [{"generated_text": "\n  float d = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d2 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d5 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d6 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d8 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d9 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d11 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d12 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d13 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d14 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d15 = length(p.xy) - 1.0;\n  // distance from"}], [{"generated_text": "\n    float t = dot( targetPos - ray.ro, ray.rd ) / dot( ray.rd, ray.rd );\n    return ray.ro + t * ray.rd;\n}\n\n// \uc810\uc5d0\uc11c \ubc18\uc0ac\ub418\ub294 \uc0c9\uc0c1\uc744 \uad6c\ud55c\ub2e4.\nvec"}], [{"generated_text": "\n\tmat2 rot = mat2(cos(iGlobalTime), -sin(iGlobalTime), sin(iGlobalTime), cos(iGlobalTime));\n\n\t// Get the pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the pixel color\n\tvec3 color = vec3(0.0);\n\tcolor += texture(iChannel0, uv).rgb;\n\tcolor += texture(iChannel1, uv).rgb;\n\tcolor += texture(iChannel2, uv).rgb;\n\tcolor += texture(iChannel3, uv).rgb;\n\tcolor += texture(iChannel4, uv).rgb;\n\tcolor += texture(iChannel5, uv).rgb;\n\tcolor += texture(iChannel6, uv).rgb;\n\tcolor += texture(iChannel7, uv).rgb;\n\tcolor += texture(iChannel8, uv).rgb;\n\tcolor += texture(iChannel9, uv).rgb;\n\tcolor += texture(iChannel10, uv).rgb;\n\tcolor += texture(iChannel11, uv).rgb;\n\tcolor += texture(iChannel12, uv).rgb;\n\tcolor += texture(iChannel13, uv).rgb;\n\tcolor += texture(iChannel14, uv).rgb;\n\tcolor += texture(iChannel15, uv).rgb;\n\tcolor += texture(iChannel16, uv).rgb;\n\tcolor += texture(iChannel17, uv).rgb;\n\tcolor += texture(iChannel18, uv).rgb;\n\tcolor += texture(iChannel19, uv).rgb;\n\tcolor += texture(iChannel20, uv).rgb;\n\tcolor += texture(iChannel21, uv).rgb;\n\tcolor += texture(iChannel22, uv).rgb;\n\tcolor += texture(iChannel23, uv).rgb;\n\tcolor += texture(iChannel24, uv).rgb;\n\tcolor += texture(iChannel25, uv).rgb"}], [{"generated_text": "-Normal-TexCoord\n    vec4 pos = vec4(p, 1.0);\n    pos.xyz += vec3(0.0, 0.0, 0.0);\n    pos.w = 1.0;\n    return pos;\n}\n\n//---Essential Fragment Function\nvec"}], [{"generated_text": "\n    vec3 lightPos = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 lightDir = normalize( lightPos - targetPos );\n    vec3 viewDir = normalize( ray.origin - targetPos );\n    vec3 halfDir = normalize( lightDir + viewDir );\n    \n    float NdotL = max( 0.0f, dot( lightDir, halfDir ) );\n    float NdotV = max( 0.0f, dot( lightDir, viewDir ) );\n    float NdotH = max( 0.0f, dot( lightDir, lightDir ) );\n    \n    float NdotH2 = NdotH * NdotH;\n    float NdotH4 = NdotH2 * NdotH2;\n    float NdotH6 = NdotH4 * NdotH2;\n    float NdotH8 = NdotH6 * NdotH2;\n    \n    float NdotV2 = NdotV * NdotV;\n    float NdotV4 = NdotV2 * NdotV2;\n    float NdotV6 = NdotV4 * NdotV2;\n    float NdotV8 = NdotV6 * NdotV2;\n    \n    float NdotL2 = NdotL * NdotL;\n    float NdotL4 = NdotL2 * NdotL2;\n    float NdotL6 = NdotL4 * NdotL2;\n    float NdotL8 = NdotL6 * NdotL2;\n    \n    float NdotH2_4 = NdotH2 * NdotH4;\n    float NdotH2_6 = NdotH2_4 * NdotH6;\n    float NdotH2_8 = NdotH2_6 * NdotH8;\n    \n    float NdotV2_4 = NdotV2 * NdotV4;\n    float NdotV2_6 = NdotV2_4 * NdotV6;\n    float NdotV2_8 = NdotV2_6 * NdotV8;\n    \n    float NdotL"}], [{"generated_text": "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / "}], [{"generated_text": "\n    float n0 = 0.0; // noise accumulator\n    float n1 = 0.0;\n    float n2 = 0.0;\n    float n3 = 0.0;\n    float n4 = 0.0;\n    float n5 = 0.0;\n    float n6 = 0.0;\n    float n7 = 0.0;\n    float n8 = 0.0;\n    float n9 = 0.0;\n    float n10 = 0.0;\n    float n11 = 0.0;\n    float n12 = 0.0;\n    float n13 = 0.0;\n    float n14 = 0.0;\n    float n15 = 0.0;\n    float n16 = 0.0;\n    float n17 = 0.0;\n    float n18 = 0.0;\n    float n19 = 0.0;\n    float n20 = 0.0;\n    float n21 = 0.0;\n    float n22 = 0.0;\n    float n23 = 0.0;\n    float n24 = 0.0;\n    float n25 = 0.0;\n    float n26 = 0.0;\n    float n27 = 0.0;\n    float n28 = 0.0;\n    float n29 = 0.0;\n    float n30 = 0.0;\n    float n31 = 0.0;\n    float n32 = 0.0;\n    float n33 = 0.0;\n    float n34 = 0.0;\n    float n35 = 0.0;\n    float n36 = 0.0;\n    float n37 = 0.0;\n    float n38 = 0.0;\n    float n39 = 0.0;\n    float n40 = 0.0;\n    float n41 = 0.0;\n    float n42 = 0.0;\n    float n43 = 0.0;\n    float n44 = 0.0;\n    float n45 = 0.0;\n    float n46 = 0.0;\n"}], [{"generated_text": "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    \n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    \n    return (v >= 0.0f && v <= 1.0f && w >= 0.0f && w <= 1.0f);\n}\n\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nvec"}], [{"generated_text": "\n    float n = log(start_radius)/log(1.5);\n    \n    //Find the closest hexagon to the point\n    int closest_hex = (int)n;\n    for(int i=0; i<closest_hex; i++){\n        n = log(start_radius)/log(1.5);\n        closest_hex = (int)n;\n    }\n    \n    return closest_hex;\n}\n\n//Find the closest hexagon a point would be near\nint"}], [{"generated_text": ".\n    //n-2 of next hexagon, and n-1 of cur hexagon.\n    //n-3 of next hexagon, and n of cur hexagon.\n    //n-4 of next hexagon, and n-1 of next hexagon.\n    //n-5 of next hexagon, and n-2 of next hexagon.\n    //n-6 of next hexagon, and n-3 of next hexagon.\n    //n-7 of next hexagon, and n-4 of next hexagon.\n    //n-8 of next hexagon, and n-5 of next hexagon.\n    //n-9 of next hexagon, and n-6 of next hexagon.\n    //n-10 of next hexagon, and n-7 of next hexagon.\n    //n-11 of next hexagon, and n-8 of next hexagon.\n    //n-12 of next hexagon, and n-9 of next hexagon.\n    //n-13 of next hexagon, and n-10 of next hexagon.\n    //n-14 of next hexagon, and n-11 of next hexagon.\n    //n-15 of next hexagon, and n-12 of next hexagon.\n    //n-16 of next hexagon, and n-13 of next hexagon.\n    //n-17 of next hexagon, and n-14 of next hexagon.\n    //n-18 of next hexagon, and n-15 of next hexagon.\n    //n-19 of next hexagon, and n-16 of next hexagon.\n    //n-20 of next hexagon, and n-17 of next hexagon.\n    //n-21 of next hexagon, and n-18 of next hexagon.\n    //n-22 of next hexagon, and n-19 of next hexagon.\n    //n-23 of next hexagon, and n-20 of next hexagon.\n    //n-24 of next hexagon, and n-21 of next hexagon.\n    //n-25 of next hexagon, and n-22 of next hexagon.\n    //n"}], [{"generated_text": ".\n    //n+2 of cur hexagon, n+3 of cur hexagon, and n+4 of cur hexagon.\n    //n+5 of cur hexagon, n+6 of cur hexagon, and n+7 of cur hexagon.\n    //n+8 of cur hexagon, n+9 of cur hexagon, and n+10 of cur hexagon.\n    //n+11 of cur hexagon, n+12 of cur hexagon, and n+13 of cur hexagon.\n    //n+14 of cur hexagon, n+15 of cur hexagon, and n+16 of cur hexagon.\n    //n+17 of cur hexagon, n+18 of cur hexagon, and n+19 of cur hexagon.\n    //n+20 of cur hexagon, n+21 of cur hexagon, and n+22 of cur hexagon.\n    //n+23 of cur hexagon, n+24 of cur hexagon, and n+25 of cur hexagon.\n    //n+26 of cur hexagon, n+27 of cur hexagon, and n+28 of cur hexagon.\n    //n+29 of cur hexagon, n+30 of cur hexagon, and n+31 of cur hexagon.\n    //n+32 of cur hexagon, n+33 of cur hexagon, and n+34 of cur hexagon.\n    //n+35 of cur hexagon, n+36 of cur hexagon, and n+37 of cur hexagon.\n    //n+38 of cur hexagon, n+39 of cur hexagon, and n+40 of cur hexagon.\n    //n+41 of cur hexagon, n+42 of cur hexagon, and n+43 of cur hexagon.\n    //n+44 of cur hexagon, n+45 of cur hexagon, and n+46 of cur hexagon.\n    //n+47 of cur hexagon, n+48 of cur hexagon, and n+49 of cur hexagon.\n    //n+50 of cur hexagon, n+51 of cur hexagon, and n"}], [{"generated_text": "\n    float p = exp(-d);\n    float sum = 0.0;\n    for (int i = 0; i < 1000; i++) {\n        float x = InverseTransformSampling(U);\n        sum += x;\n    }\n    return sum / 1000.0;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat"}], [{"generated_text": "'s implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash6(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);"}], [{"generated_text": "\n    vec2 center = vec2(0.5);\n    // distance from center\n    vec2 dist = fragCoord - center;\n    // distance from center squared\n    float distSq = dot(dist, dist);\n    // distance from center cubed\n    float distCubed = dot(dist, distSq);\n    // distance from center cubed squared\n    float distCubedSq = dot(dist, distCubed);\n    // distance from center cubed cubed\n    float distCubedCubed = dot(dist, distCubedSq);\n    // distance from center cubed cubed squared\n    float distCubedCubedSq = dot(dist, distCubedCubed);\n    // distance from center cubed cubed cubed\n    float distCubedCubedCubed = dot(dist, distCubedCubedSq);\n    // distance from center cubed cubed cubed squared\n    float distCubedCubedCubedSq = dot(dist, distCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed\n    float distCubedCubedCubedCubed = dot(dist, distCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed\n    float distCubedCubedCubedCubedCubed = dot(dist, distCubedCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed cubed\n    float distCubedCubedCubedC"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"}], [{"generated_text": "\n  const float epsilon = 0.0001;\n\n  // compute normal vector\n  vec3 normal = vec3(0.0);\n  normal.x = calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0));\n  normal.y = calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0));\n  normal.z = calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon));\n  return normalize(normal);\n}\n\n// Compute height of surface at pos\nfloat"}], [{"generated_text": "\n  vec3 p = castRay(ro, rd);\n  // get color of nearest object\n  vec3 col = getColor(p);\n  // get normal of nearest object\n  vec3 n = getNormal(p);\n  // get specular value of nearest object\n  float s = getSpecular(p);\n  // get diffuse value of nearest object\n  float d = getDiffuse(p);\n  // get ambient value of nearest object\n  float a = getAmbient(p);\n  // get reflection value of nearest object\n  float r = getReflection(p);\n  // get refraction value of nearest object\n  float t = getRefraction(p);\n  // get refractive index of nearest object\n  float i = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get"}], [{"generated_text": "\n    const float epsilon = 0.0001;\n    vec3 normal = vec3(0.0);\n    normal.x = calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0));\n    normal.y = calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0));\n    normal.z = calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon));\n    return normalize(normal);\n}\n\n// Compute height of surface at pos\nfloat"}], [{"generated_text": "\n    vec3 p = castRay(ro, rd);\n    // get color of nearest object\n    vec3 col = getColor(p);\n    // get normal of nearest object\n    vec3 n = getNormal(p);\n    // get specular value of nearest object\n    float s = getSpecular(p);\n    // get diffuse value of nearest object\n    float d = getDiffuse(p);\n    // get ambient value of nearest object\n    float a = getAmbient(p);\n    // get reflection value of nearest object\n    vec3 r = getReflection(p, rd);\n    // get refraction value of nearest object\n    vec3 t = getRefraction(p, rd);\n    // get refractive index of nearest object\n    float i = getRefractiveIndex(p);\n    // get refractive index of nearest object\n    float rf = getRefractiveFactor(p);\n    // get refractive index of nearest object\n    float rt = getRefractiveTransmittance(p);\n    // get refractive index of nearest object\n    float rt2 = getRefractiveTransmittance2(p);\n    // get refractive index of nearest object\n    float rt3 = getRefractiveTransmittance3(p);\n    // get refractive index of nearest object\n    float rt4 = getRefractiveTransmittance4(p);\n    // get refractive index of nearest object\n    float rt5 = getRefractiveTransmittance5(p);\n    // get refractive index of nearest object\n    float rt6 = getRefractiveTransmittance6(p);\n    // get refractive index of nearest object\n    float rt7 = getRefractiveTransmittance7(p);\n    // get refractive index of nearest object\n    float rt8 = getRefractiveTransmittance8(p);\n    // get refractive index of nearest object\n    float rt9 = getRefractiveTransmittance9(p);\n    // get refractive index of nearest object\n    float rt10 = getRefractiveTransmittance10(p);\n    //"}], [{"generated_text": "\n    vec3 color = texture(texture_diffuse1, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color2 = texture(texture_diffuse2, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color3 = texture(texture_diffuse3, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color4 = texture(texture_diffuse4, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color5 = texture(texture_diffuse5, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color6 = texture(texture_diffuse6, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color7 = texture(texture_diffuse7, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color8 = texture(texture_diffuse8, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color9 = texture(texture_diffuse9, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color10 = texture(texture_diffuse10, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color11 = texture(texture_diffuse11, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color12 = texture(texture_diffuse12, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color13 = texture(texture_diffuse13, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color14 = texture(texture_diffuse14, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color15 = texture(texture_diffuse15, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color"}], [{"generated_text": "\n    // This is a simple hash function for 2D integer coordinates.\n    // It is not optimized for speed, but it is good enough for our purposes.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it"}], [{"generated_text": "el\n\tvec2 texel = vec2( 1.0 / 16.0 );\n\tvec2 coord1 = coord;\n\tvec2 coord2 = coord + texel;\n\tvec2 coord3 = coord + texel * 2.0;\n\tvec2 coord4 = coord + texel * 3.0;\n\tvec2 coord5 = coord + texel * 4.0;\n\tvec2 coord6 = coord + texel * 5.0;\n\tvec2 coord7 = coord + texel * 6.0;\n\tvec2 coord8 = coord + texel * 7.0;\n\tvec2 coord9 = coord + texel * 8.0;\n\tvec2 coord10 = coord + texel * 9.0;\n\tvec2 coord11 = coord + texel * 10.0;\n\tvec2 coord12 = coord + texel * 11.0;\n\tvec2 coord13 = coord + texel * 12.0;\n\tvec2 coord14 = coord + texel * 13.0;\n\tvec2 coord15 = coord + texel * 14.0;\n\tvec2 coord16 = coord + texel * 15.0;\n\n\tvec3 color1 = texture( texture1, coord1 ).rgb;\n\tvec3 color2 = texture( texture1, coord2 ).rgb;\n\tvec3 color3 = texture( texture1, coord3 ).rgb;\n\tvec3 color4 = texture( texture1, coord4 ).rgb;\n\tvec3 color5 = texture( texture1, coord5 ).rgb;\n\tvec3 color6 = texture( texture1, coord6 ).rgb;\n\tvec3 color7 = texture( texture1, coord7 ).rgb;\n\tvec3 color8 = texture( texture1, coord8 ).rgb;\n\tvec3 color9 = texture( texture1, coord9 ).rgb;\n\tvec3 color10 = texture( texture1, coord10 ).rgb;\n\tvec3 color11 = texture( texture1, coord11 ).rg"}], [{"generated_text": "\n    p.x = abs(p.x);\n\n    // rotate\n    float c = cos(p.y);\n    float s = sin(p.y);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n\n    // scale\n    p.x *= ab.x;\n    p.y *= ab.y;\n\n    // translate\n    p.x += ab.x * 0.5;\n    p.y += ab.y * 0.5;\n\n    return p;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec"}], [{"generated_text": "\n    p = fract(p * 0.1031);\n    p *= 33.33;\n    p += fract(p * 2.02);\n    return fract(vec3(p, p + 2.33, p + 3.23));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n\n    // Get the position of the pixel\n    vec2 pixel = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy"}], [{"generated_text": "\n    float t = 0.0;\n    float tmin = 1000000.0;\n    float tmax = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    float t43 = 0.0;\n    float"}], [{"generated_text": "\n    float s = sin(rotation.x);\n    float c = cos(rotation.x);\n    float t = sin(rotation.y);\n    float ct = cos(rotation.y);\n    float n = sin(rotation.z);\n    float cn = cos(rotation.z);\n\n    // Create the Rotation Matrix\n    return mat3(\n        vec3(cn*ct, cn*s, -sn),\n        vec3(cn*t, cn*ct*t - s, cn*sn),\n        vec3(sn*ct, sn*s, cn*ct*t + s)\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat"}], [{"generated_text": "\n    vec4 raypos = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Ray-Marching\n    float t = 0.0;\n    float tmax = 1000.0;\n    float tmin = 0.0;\n    float tmin_tmax = 0.0;\n    float tmin_tmax_t = 0.0;\n    float tmin_tmax_t_t = 0.0;\n    float tmin_tmax_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t_t"}], [{"generated_text": "\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    // Calculate the Origin of the Ray\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n"}], [{"generated_text": "\n    vec3 raypos = vec3(0.0, 0.0, 0.0);\n    // Set the Ray Origin\n    raypos = rayori;\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n    // Set the Ray Length\n    float raylen = 100.0;\n    // Set the Ray Step Size\n    float raystep = 0.01;\n    // Set the Ray Step Count\n    float raystepcount = 0.0;\n    // Set the Ray Color\n    vec3 raycolor = vec3(0.0, 0.0, 0.0);\n    // Set the Ray Distance\n    float raydist = 0.0;\n    // Set the Ray Distance Threshold\n    float raydistthresh = 0.001;\n    // Set the Ray Distance Threshold\n    float raydistthresh2 = 0.0001;\n    // Set the Ray Distance Threshold\n    float raydistthresh3 = 0.00001;\n    // Set the Ray Distance Threshold\n    float raydistthresh4 = 0.000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh5 = 0.0000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh6 = 0.00000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh7 = 0.000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh8 = 0.0000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh9 = 0.00000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh10 = 0.000000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh11 = 0.0000000000001;\n    // Set the Ray Distance Threshold\n"}], [{"generated_text": "\n    float seed = iTime;\n    float rng = rand(seed);\n\n    // Initialize the image\n    vec3 color = vec3(0.0);\n\n    // Calculate the position of the pixel\n    vec2 pos = fragCoord.xy / iResolution.xy;\n\n    // Calculate the position of the pixel in the 3D space\n    vec3 p = vec3(pos.xy, rng);\n\n    // Calculate the ray direction\n    vec3 ray = normalize(vec3(pos.xy, 1.0));\n\n    // Calculate the ray origin\n    vec3 origin = vec3(0.0);\n\n    // Calculate the ray length\n    float length = 100.0;\n\n    // Calculate the ray color\n    vec3 rayColor = vec3(0.0);\n\n    // Calculate the ray step\n    float step = 0.001;\n\n    // Calculate the ray step\n    float step2 = 0.0001;\n\n    // Calculate the ray step\n    float step3 = 0.00001;\n\n    // Calculate the ray step\n    float step4 = 0.000001;\n\n    // Calculate the ray step\n    float step5 = 0.0000001;\n\n    // Calculate the ray step\n    float step6 = 0.00000001;\n\n    // Calculate the ray step\n    float step7 = 0.000000001;\n\n    // Calculate the ray step\n    float step8 = 0.0000000001;\n\n    // Calculate the ray step\n    float step9 = 0.00000000001;\n\n    // Calculate the ray step\n    float step10 = 0.000000000001;\n\n    // Calculate the ray step\n    float step11 = 0.0000000000001;\n\n    // Calculate the ray step\n    float step12 = 0."}], [{"generated_text": "\n    float fade = fadeOut(coord, frequency, travelRate);\n\n    // Get the ray's direction\n    vec2 rayDir = vec2(travelRate, 0.0);\n\n    // Get the ray's position\n    vec2 rayPos = vec2(coord.x, 0.0);\n\n    // Get the ray's intensity\n    float rayIntensity = rayIntensity(rayPos, rayDir, frequency, travelRate, maxStrength);\n\n    // Return the ray's intensity\n    return rayIntensity * fade;\n}\n\n// rayIntensity: (position, direction, frequency, travel rate, max strength)\n// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n// -----------------------------------------------\n"}], [{"generated_text": "\n\tvec2 d2 = d / 2.0;\n\tvec2 p2 = p - d2;\n\tvec2 p3 = p + d2;\n\tvec2 p4 = p + d;\n\tvec2 p5 = p - d;\n\tvec2 p6 = p + d2.yx;\n\tvec2 p7 = p - d2.yx;\n\tvec2 p8 = p + d2.xy;\n\tvec2 p9 = p - d2.xy;\n\tvec2 p10 = p + d.yx;\n\tvec2 p11 = p - d.yx;\n\tvec2 p12 = p + d.xy;\n\tvec2 p13 = p - d.xy;\n\tvec2 p14 = p + d2.yx + d2.xy;\n\tvec2 p15 = p - d2.yx + d2.xy;\n\tvec2 p16 = p + d2.yx - d2.xy;\n\tvec2 p17 = p - d2.yx - d2.xy;\n\tvec2 p18 = p + d2.xy + d2.yx;\n\tvec2 p19 = p - d2.xy + d2.yx;\n\tvec2 p20 = p + d2.xy - d2.yx;\n\tvec2 p21 = p - d2.xy - d2.yx;\n\tvec2 p22 = p + d.yx + d.xy;\n\tvec2 p23 = p - d.yx + d.xy;\n\tvec2 p24 = p + d.yx - d.xy;\n\tvec2 p25 = p - d.yx - d.xy;\n\tvec2 p26 = p + d.xy + d.yx;\n\tvec2 p27 = p - d.xy + d.yx;\n\tvec2 p28 = p + d.xy - d.yx;\n\tvec2 p29 = p - d.xy - d.yx;\n\tvec2 p30 = p + d2.yx +"}], [{"generated_text": "\n    return pow(color, vec3(2.2));\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec"}], [{"generated_text": "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n\n    // head\n    float d = length( ap - ab*h ) - w2;\n\n    // shaft\n    float s = length( ap - ab*h ) - w1;\n\n    return min(d,s);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat"}], [{"generated_text": "\n    uv = uv - 0.5;\n    uv.x *= TAU;\n    uv.y *= TAU;\n\n    //get the distance from the center\n    float d = length(uv);\n\n    //get the angle from the center\n    float a = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a2 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a3 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a4 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a5 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a6 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a7 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a8 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a9 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a10 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a11 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a12 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a13 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a14 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a15 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a16 = atan(uv.y, uv.x);\n\n    //"}], [{"generated_text": "\n    //vec3 colC = vec3(0.0,0.0,0.0);\n    //vec3 colD = vec3(0.0,0.0,0.0);\n    //vec3 colE = vec3(0.0,0.0,0.0);\n    //vec3 colF = vec3(0.0,0.0,0.0);\n    //vec3 colG = vec3(0.0,0.0,0.0);\n    //vec3 colH = vec3(0.0,0.0,0.0);\n    //vec3 colI = vec3(0.0,0.0,0.0);\n    //vec3 colJ = vec3(0.0,0.0,0.0);\n    //vec3 colK = vec3(0.0,0.0,0.0);\n    //vec3 colL = vec3(0.0,0.0,0.0);\n    //vec3 colM = vec3(0.0,0.0,0.0);\n    //vec3 colN = vec3(0.0,0.0,0.0);\n    //vec3 colO = vec3(0.0,0.0,0.0);\n    //vec3 colP = vec3(0.0,0.0,0.0);\n    //vec3 colQ = vec3(0.0,0.0,0.0);\n    //vec3 colR = vec3(0.0,0.0,0.0);\n    //vec3 colS = vec3(0.0,0.0,0.0);\n    //vec3 colT = vec3(0.0,0.0,0.0);\n    //vec3 colU = vec3(0.0,0.0,0.0);\n    //vec3 colV = vec3(0.0,0.0,0.0);\n    //vec3 colW = vec3(0.0,0.0,0.0);\n    //vec3 colX ="}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n"}], [{"generated_text": "\n   p = fract(p * 0.1031);\n   p *= 133.421312421;\n   p += fract(p * 0.0265348192);\n   p = fract(p);\n   p *= 133.421312421;\n   p += fract(p * 0.0265348192);\n   p = fract(p);\n   return fract(vec3(p, p + 1.0, p + 2.0));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec"}], [{"generated_text": "\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return ("}], [{"generated_text": ", but I don't remember where.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //"}], [{"generated_text": "\n    return length(max(abs(p) - 1.0, 0.0));\n}\n\n/* \u4e00\u4e2a\u5706\u7684SDF */\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Get the radius of the circle\n    float radius = iTime * 0.01;\n\n    // Get the distance from the center of the circle\n    float dist = distance(uv, vec2(0.5));\n\n    // Get the brightness of the circle\n    float brightness = (1.0 - dist) / radius;\n\n    // Set the color based on the brightness\n    col = vec3(brightness);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n"}]]}