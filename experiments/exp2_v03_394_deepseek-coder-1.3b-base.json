{"generations": ["\n    return 0.0;\n}\n\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle (can't get simpler than this)\nfloat", "\n    return (dot(v, r) < 0.0)? -v : v;\n}\n\n// Flip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    return ( dot( v, r ) < 0.0 )? -v : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    if( dot( v, r ) < 0.0 )\n        return -v;\n    return v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 10.0);\n    return sunCol * cosAlpha;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec", "\n    vec4 a0 = p0;\n    vec4 a1 = p1;\n    vec4 a2 = p2;\n    vec4 a3 = p3;\n\n    vec4 b0 = a1;\n    vec4 b1 = a2;\n    vec4 b2 = a3;\n\n    vec4 c0 = a0;\n    vec4 c1 = a1;\n    vec4 c2 = a2;\n    vec4 c3 = a3;\n\n    vec4 d0 = b0;\n    vec4 d1 = b1;\n    vec4 d2 = b2;\n    vec4 d3 = b1;\n\n    vec4 e0 = c0;\n    vec4 e1 = c1;\n    vec4 e2 = c2;\n    vec4 e3 = c3;\n\n    vec4 f0 = d0;\n    vec4 f1 = d1;\n    vec4 f2 = d2;\n    vec4 f3 = d3;\n\n    vec4 g0 = e0;\n    vec4 g1 = e1;\n    vec4 g2 = e2;\n    vec4 g3 = e3;\n\n    vec4 h0 = f0;\n    vec4 h1 = f1;\n    vec4 h2 = f2;\n    vec4 h3 = f3;\n\n    vec4 i0 = g0;\n    vec4 i1 = g1;\n    vec4 i2 = g2;\n    vec4 i3 = g3;\n\n    vec4 j0 = h0;\n    vec4 j1 = h1;\n    vec4 j2 = h2;\n    vec4 j3 = h3;\n\n    vec4 k0 = i0;\n    vec4 k1 = i1;\n    vec4 k2 = i2;\n    vec4 k3 = i3;\n\n    vec4 l0 = j0;\n    vec4 l1 = j1;\n    vec4 l", "\n\tfloat n = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat nn = 0.0;\n\tfloat o = 0.0;\n\tfloat pn = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat aw = 0.0;\n\tfloat ax = 0.0;\n\tfloat ay = 0.0;\n\tfloat az = 0.0;\n\tfloat ba = 0.0;\n\tfloat bb = 0.0;\n\tfloat bc = 0.", "\n    vec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n    p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n    p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n    p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n    p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    p1 = vec4(0.0, 0.0, 0", "\n    return fract(sin(u) * 43758.5453);\n}\n\nfloat", "\n\tfloat n = 0.0;\n\tfloat f = 1.0;\n\tfloat a = 0.5;\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f2 = 0.0;\n\tfloat f3 = 0.0;\n\tfloat f4 = 0.0;\n\tfloat f5 = 0.0;\n\tfloat f6 = 0.0;\n\tfloat f7 = 0.0;\n\tfloat f8 = 0.0;\n\tfloat f9 = 0.0;\n\tfloat f10 = 0.0;\n\tfloat f11 = 0.0;\n\tfloat f12 = 0.0;\n\tfloat f13 = 0.0;\n\tfloat f14 = 0.0;\n\tfloat f15 = 0.0;\n\tfloat f16 = 0.0;\n\tfloat f17 = 0.0;\n\tfloat f18 = 0.0;\n\tfloat f19 = 0.0;\n\tfloat f20 = 0.0;\n\tfloat f21 = 0.0;\n\tfloat f22 = 0.0;\n\tfloat f23 = 0.0;\n\tfloat f24 = 0.0;\n\tfloat f25 = 0.0;\n\tfloat f26 = 0.0;\n\tfloat f27 = 0.0;\n\tfloat f28 = 0.0;\n\tfloat f29 = 0.0;\n\tfloat f30 = 0.0;\n\tfloat f31 = 0.0;\n\tfloat f32 = 0.0;\n\tfloat f33 = 0.0;\n\tfloat f34 = 0.0;\n\tfloat f35 = 0.0;\n\tfloat f36 = 0.0;\n\tfloat f37 = 0.0;\n\tfloat f38 = 0.0;\n\tfloat f39 = 0.0;\n\tfloat", "\n    float d = length(p);\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(sunDir);\n    vec3 lightColor = vec3(1.0);\n    float lightRadius = 0.0;\n    float lightIntensity = 0.0;\n    float lightFade = 0.0;\n    float lightFadeEnd = 0.0;\n    float lightFadeStart = 0.0;\n    float lightFadeStep = 0.0;\n    float lightFadeStepEnd = 0.0;\n    float lightFadeStepStart = 0.0;\n    float lightFadeStepStartEnd = 0.0;\n    float lightFadeStepStartEndEnd = 0.0;\n    float lightFadeStepStartEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.", "\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat", "\n    vec3 L = spherePos - pos;\n    float tca = dot(L, dirVecPLZNormalizeMeFirst);\n    if (tca < 0) return -1.0;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > rad * rad) return -1.0;\n    float thc = sqrt(rad * rad - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    if (t0 < 0) t0 = t1;\n    if (t0 < 0) return -1.0;\n    return t0;\n}\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// ------------------------------------------------", "\n    vec2 d = vec2(0.0);\n    d.x = length(p.xz) - 1.0;\n    d.y = abs(p.y) - 0.5;\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// --------------------------------------------------------\n// curve\n// --------------------------------------------------------\n\n// curve\nvec", "\n    return vec3(\n        (1.0f - t) * (1.0f - t) * (1.0f - t),\n        3.0f * t * (1.0f - t) * (1.0f - t),\n        3.0f * t * t * (1.0f - t)\n    );\n}\n\n// curve derivative (velocity)\nvec", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve third derivative (acceleration)\nvec", "\n    vec2 d = vec2(0.0);\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 am = ap - ab * clamp( dot(ap, ab) / dot(ab, ab), 0.0, 1.0 );\n    d.x = length( am );\n    vec2 ba = b - p;\n    vec2 bp = p - b;\n    vec2 bm = bp - ab * clamp( dot(bp, ab) / dot(ab, ab), 0.0, 1.0 );\n    d.y = length( bm );\n    return min( d, d.yx );\n}\n\n// signed squared distance between point and segment\nvec", "\n\tvec2 r = vec2( 0.0 );\n\tvec2 ab = b - a;\n\tvec2 oc = o - a;\n\tfloat t = dot( oc, ab ) / dot( d, ab );\n\tif( t < 0.0 )\n\t{\n\t\tr.x = length( oc );\n\t}\n\telse if( t > 1.0 )\n\t{\n\t\tr.x = length( oc - ab * 2.0 );\n\t}\n\telse\n\t{\n\t\tr.x = length( oc - ab * t );\n\t}\n\tr.y = dot( oc, ab ) / dot( d, ab );\n\treturn r;\n}\n\n// signed squared distance between ray and segment\nvec", "\n    vec2  q = -0.5*p;\n    vec2  s = q - floor(q + b + 0.5);\n    vec2  a = s - 0.5*b;\n    return length(max(a,0.0)) + min(max(a.x,a.y),0.0) - b.x;\n}\n\n// --------------------------------------------------------\n// \n// --------------------------------------------------------\nfloat", "\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 1.0);\n    return sunCol * cosAlpha;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0f)) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This is the function that actually does the ray tracing.\n// It basically takes in the ray direction and the eye position.\n// It then calculates the ray direction and eye position in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction in world space.\n// It then calculates the ray direction in eye space.\n// It then calculates the ray direction", "\n    vec2 balloon = vec2( 0.0 );\n    float balloonRadius = 0.001;\n    float balloonHeight = 0.001;\n    float balloonWidth = 0.001;\n    float balloonDepth = 0.001;\n    float balloonX = currentRayPosition.x;\n    float balloonY = currentRayPosition.y;\n    float balloonZ = currentRayPosition.z;\n    float balloonX2 = balloonX + balloonWidth;\n    float balloonY2 = balloonY + balloonHeight;\n    float balloonZ2 = balloonZ + balloonDepth;\n    float balloonX3 = balloonX - balloonWidth;\n    float balloonY3 = balloonY - balloonHeight;\n    float balloonZ3 = balloonZ - balloonDepth;\n    float balloonX4 = balloonX + balloonWidth;\n    float balloonY4 = balloonY - balloonHeight;\n    float balloonZ4 = balloonZ + balloonDepth;\n    float balloonX5 = balloonX - balloonWidth;\n    float balloonY5 = balloonY + balloonHeight;\n    float balloonZ5 = balloonZ - balloonDepth;\n    float balloonX6 = balloonX + balloonWidth;\n    float balloonY6 = balloonY + balloonHeight;\n    float balloonZ6 = balloonZ - balloonDepth;\n    float balloonX7 = balloonX - balloonWidth;\n    float balloonY7 = balloonY - balloonHeight;\n    float balloonZ7 = balloonZ + balloonDepth;\n    float balloonX8 = balloonX + balloonWidth;\n    float balloonY8 = balloonY - balloonHeight;\n    float balloonZ8 = balloonZ + balloonDepth;\n    float balloonX9 = balloonX - balloonWidth;\n    float balloonY9 = balloonY + balloonHeight;\n    float balloonZ9 = balloonZ - balloonDepth;\n    float balloonX10 = balloonX + balloonWidth", "\n    // 'THING1' is the thing we are looking at\n    // 'THING2' is the thing we are looking at\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1' is the closer thing\n    // 'THING2' is the closer thing\n    // 'DISTANCE' is the distance between the two", "\n    vec2 closestThing = vec2( 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3 normal = vec3(0.0);\n    vec3 sample = vec3(1.0);\n    float epsilon = 0.0001;\n    for( int i = 0; i < 3; i++ ){\n        normal[i] = sdf( positionOfHit + sample[i] * epsilon );\n        sample[i] *= -1.0;\n    }\n    return normalize( normal );\n}\n\n// This is the main function that is called to get the color\n// of the surface.\nvec", "\n    return vec3(0.0);\n}\n\n// this is the main function that does the actual rendering.\n// it takes in the camera and the ray, and returns a color.\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float diffuse = max(dot(normalOfSurface, lightDir), 0.0);\n    color = lightColor * diffuse;\n    return color;\n}\n\n// This is the main function, which is called by the raytracer\n// to render a scene.\nvoid main() {\n    // We are going to render a scene with a single sphere.\n    // The sphere is centered at the origin, and has a radius of 1.\n    // The sphere is colored red.\n    vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n\n    // We are going to render a scene with a single plane.\n    // The plane is centered at the origin, and has a normal of\n    // (0, 1, 0). The plane is colored blue.\n    vec3 planeColor = vec3(0.0, 0.0, 1.0);\n\n    // We are going to render a scene with a single cylinder.\n    // The cylinder is centered at the origin, and has a radius of 1.\n    // The cylinder is colored green.\n    vec3 cylinderColor = vec3(0.0, 1.0, 0.0);\n\n    // We are going to render a scene with a single cone.\n    // The cone is centered at the origin, and has a radius of 1.\n    // The cone is colored yellow.\n    vec3 coneColor = vec3(1.0, 1.0, 0.0);\n\n    // We are going to render a scene with a single torus.\n    // The torus is centered at the origin, and has a radius of 1.\n    // The torus is colored purple.\n    vec3 torusColor = vec3(1.0, 0.0, 1.0);\n\n    // We are going to render a scene with a single sphere", "\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n   ", "\n  return (x * (1.0 - b)) + (b * x);\n}\n\n// https://www.desmos.com/calculator/jjj777777\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat", "\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x and y coordinates\nfloat", "\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input p --> is point\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat", "\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> sphere center\n// input r --> sphere radius\n// \n// this is a simple sphere\nfloat", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/(d2+d1), 0.0, 1.0 );\n    return mix( d2, d1, h ) - 0.001*h*h*h*h*h;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat", "\n    return 1.0 - smoothstep(0.0, 1.0, d1);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat", "\n    vec3 q = p;\n    float s = sin(yaw);\n    float c = cos(yaw);\n    q.xz = mat2(c,s,-s,c)*q.xz;\n    q.xy = mat2(c,-s,s,c)*q.xy;\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec", "\n    if(o1.x < o2.x) return o1;\n    else return o2;\n}\n\n// ~~~~~~~ do Intersection / find the closest object\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n    // find the closest object\n    float t = -1.0;\n    vec2 closest = vec2(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < objects[i].radius && d < t)\n        {\n            t = d;\n            closest = objects[i].position;\n        }\n    }\n\n    // move the object/shape by messing with p\n    if (t > 0.0)\n    {\n        p = closest;\n    }\n\n    // find the closest point on the plane\n    float t2 = -1.0;\n    vec2 closest2 = vec2(0.0);\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        float d = distance(p, planes[i].position);\n        if (d < planes[i].radius && d < t2)\n        {\n            t2 = d;\n            closest2 = planes[i].position;\n        }\n    }\n\n    // move the plane by messing with p\n    if (t2 > 0.0)\n    {\n        p = closest2;\n    }\n\n    // find the closest point on the circle\n    float t3 = -1.0;\n    vec2 closest3 = vec2(0.0);\n    for (int i = 0; i < NUM_CIRCLES; i++)\n    {\n        float d = distance(p, circles[i].position);\n        if (d < circles[i].radius && d < t3)\n        {\n            t3 = d;\n            closest3 = circles[i].position;\n        }\n    }\n\n    // move the circle by messing with p\n    if (t3 > 0.0)\n    {\n        p = closest3;\n    }\n\n    // find the closest point on the triangle\n    float t4 = -1.0;\n    vec2 closest4 = vec2(0.0);\n    for (int i = 0; i <", "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\t", "\n    // raymarching\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001 || t > 1000.0)\n            break;\n    }\n\n    // find closest surface\n    vec3 n = vec3(0.0);\n    if (d < 0.001)\n    {\n        n = normal(p);\n    }\n\n    // apply color\n    vec3 color = vec3(0.0);\n    if (d < 0.001)\n    {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n\n    return color;\n}\n\n// ~~~~~~~ main --> render scene --> output image\nvoid main()\n{\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    float fov = 60.0;\n\n    // render\n    vec3 color = vec3(0.0);\n    for (int j = 0; j < image_height; j++)\n    {\n        for (int i = 0; i < image_width; i++)\n        {\n            // pixel\n            float x = (2.0 * (i + 0.5) / image_width - 1.0) * uu.x * uu.y / image_height + ww.x;\n            float y = (1.0 - 2.0 * (j + 0.5", "\n    vec3 camDir = normalize(targetPos - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, camDir);\n    vec3 newUp = cross(camDir, right);\n    mat3 rot = mat3( right, newUp, camDir );\n    return rot * mat3(1.0, 0.0, 0.0, 0.0, cos(roll), -sin(roll), 0.0, sin(roll), cos(roll));\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat", "\n    if (id == 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    else if (id == 1.0)\n        return vec3(1.0, 0.0, 0.0);\n    else if (id == 2.0)\n        return vec3(0.0, 1.0, 0.0);\n    else if (id == 3.0)\n        return vec3(0.0, 0.0, 1.0);\n    else if (id == 4.0)\n        return vec3(1.0, 1.0, 0.0);\n    else if (id == 5.0)\n        return vec3(1.0, 0.0, 1.0);\n    else if (id == 6.0)\n        return vec3(0.0, 1.0, 1.0);\n    else if (id == 7.0)\n        return vec3(1.0, 1.0, 1.0);\n    else\n        return vec3(0.0, 0.0, 0.0);\n}\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n//  s.x = sphere radius\n//  s.y = sphere thickness\n//  \n// think of the sphere as a cylinder with a hole in the middle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere radius/core/radius which is flat on the y axis\n// then simply subtract the sphere thickness from that \nfloat", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> center\n//  returns signed distance from center\nfloat", "\n    float h = clamp( 0.5 + 0.5*(d2/d1 - 1.0), 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0 - h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n    vec4 d = o1 - o2;\n    return (o1 * (1.0 - bf) + o2 * bf);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec", "\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat", "\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.y = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.z = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    return lightPos;\n}\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/", "\n    // ray-plane intersection\n    float t = (plane.z - ro.z) / rd.z;\n    vec3 pt = ro + t * rd;\n\n    // ray-sphere intersection\n    vec3 oc = pt - sphere.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n\n    // ray-triangle intersection\n    vec3 pt2 = ro + t * rd;\n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 n = cross(e1, e2);\n    vec3 p1 = sphere.xyz + n * sphere.w;\n    vec3 p2 = sphere.xyz - n * sphere.w;\n    vec3 p3 = pt2;\n    vec3 v1 = p2 - p1;\n    vec3 v2 = p3 - p1;\n    vec3 v3 = pt2 - p1;\n    float s = sign(dot(n, cross(v1, v2)));\n    if (s < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.", "\n    vec3 l = lp - sp;\n    float d = length(l);\n    l /= d;\n    float t = d * SHADOW_DISTANCE;\n    float s = 1.0;\n    for (int i = 0; i < SHADOW_STEPS; i++)\n    {\n        float h = map(sp + l * t);\n        t += h;\n        s -= h;\n        if (s < 0.0)\n            break;\n    }\n    return clamp(s / t, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat", "\n    float t = 0.0;\n    float d = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float occ = 0.0;\n    float bias = 0.1;\n    float steps = 64.0;\n    float invsteps = 1.0 / steps;\n    for (float i = 0.0; i < steps; i++)\n    {\n        float h = map(sp + nor * t);\n        t += h * invsteps;\n        d += h * invsteps;\n        if (h < tmin || h > tmax)\n        {\n            break;\n        }\n    }\n    if (d < 0.0)\n    {\n        occ = 0.0;\n    }\n    else\n    {\n        occ = clamp(1.0 - (d * d) * (1.0 - bias), 0.0, 1.0);\n    }\n    return occ;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat", "\n    vec3 n = vec3(0.0);\n    float d = 0.0001;\n    for(int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int k=-1; k<=1; k++)\n            {\n                vec3 p2 = p + vec3(i,j,k)*d;\n                vec3 oN2 = texture(texture_normal, p2).rgb;\n                n += oN2 - oN;\n            }\n        }\n    }\n    return normalize(n);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// output --> averaged? out normal vector at point p\nvec", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// ~~~~~~~ do tone mapping\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec", "\n    float fogDensity=fs.x;\n    float fogColorLerpExp=fs.y;\n    float fogDensityFactor=1.0-exp(-d*fogDensity);\n    float fogFactor=clamp(fogDensityFactor,0.0,1.0);\n    vec3 fogColor=mix(fc1,fc2,fogFactor);\n    return mix(c,fogColor,pow(1.0-d,fogColorLerpExp));\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec", "\n    return cF + lF * d + qF * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat", "\n    vec3 rayDir = vec3(0.0);\n    vec3 fCoord3 = vec3(fCoord, 1.0);\n    vec4 fCoord4 = cMatrix * vec4(fCoord3, 1.0);\n    rayDir = normalize(fCoord4.xyz - cMatrix[2]);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec", "\n    vec3 color = vec3(0.0);\n    vec2 fCoord_ = fCoord;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    for(int i = 0; i < 10; i++)\n    {\n        vec3 p = vec3(fCoord_,0.0);\n        vec3 p_ = cMat_ * p + cPos_;\n        vec3 p_n = normalize(p_ - cPos_);\n        vec3 p_t = normalize(cross(p_n,vec3(0.0,1.0,0.0)));\n        vec3 p_b = normalize(cross(p_t,p_n));\n        float d = length(p_ - cPos_);\n        float d_ = d;\n        float d_n = 1.0;\n        float d_t = 1.0;\n        float d_b = 1.0;\n        for(int j = 0; j < 10; j++)\n        {\n            vec3 p_n_ = p_n * d_n;\n            vec3 p_t_ = p_t * d_t;\n            vec3 p_b_ = p_b * d_b;\n            vec3 p_ = p_n_ + p_t_ + p_b_;\n            vec3 p_n_n = normalize(p_ - cPos_);\n            vec3 p_t_t = normalize(cross(p_n_n,vec3(0.0,1.0,0.0)));\n            vec3 p_b_b = normalize(cross(p_t_t,p_n_n));\n            float d_ = length(p_ - cPos_);\n            d_n *= 0.5;\n            d_t *= 0.5;\n            d_b *= 0.5;\n            if(d_ < 0.001)\n            {\n                break;\n            }\n        }\n        color += vec3(d_n,d_t,d_b) * ", "\n    // Setup\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 c = p;\n    vec2 z = vec2(0.0);\n    vec2 z2 = vec2(0.0);\n    float t = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n", "\n    vec3 d = abs(p) - radius;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// sphere distance field\nfloat", "\n    return length(p.xz - vec2(0.0, r)) - r;\n}\n\n// simple sphere distance field\nfloat", "\n    vec2 d = vec2(1000.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = abs(q.x) - 0.5;\n        r.y = abs(q.y) - 0.5;\n        r.z = abs(q.z) - 0.5;\n        float d0 = length(r);\n        d = min(d, vec2(d0, float(i)));\n        q = q + r;\n    }\n    return d;\n}\n\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec", "\n\treturn vec2(pow(c.x, 5), pow(c.y, 5));\n}\n\n//Function that returns a complex number to power of 6\nvec", "\n\tvec4 color = vec4(0.0);\n\t\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\t\n\tfloat x1 = x - morphConstant.x;\n\tfloat y1 = y - morphConstant.y;\n\t\n\tfloat x2 = x + morphConstant.x;\n\tfloat y2 = y + morphConstant.y;\n\t\n\tfloat x3 = x - morphConstant.x;\n\tfloat y3 = y + morphConstant.y;\n\t\n\tfloat x4 = x + morphConstant.x;\n\tfloat y4 = y - morphConstant.y;\n\t\n\tfloat x5 = x - morphConstant.x;\n\tfloat y5 = y + morphConstant.y;\n\t\n\tfloat x6 = x + morphConstant.x;\n\tfloat y6 = y - morphConstant.y;\n\t\n\tfloat x7 = x - morphConstant.x;\n\tfloat y7 = y + morphConstant.y;\n\t\n\tfloat x8 = x + morphConstant.x;\n\tfloat y8 = y - morphConstant.y;\n\t\n\tfloat x9 = x - morphConstant.x;\n\tfloat y9 = y + morphConstant.y;\n\t\n\tfloat x10 = x + morphConstant.x;\n\tfloat y10 = y - morphConstant.y;\n\t\n\tfloat x11 = x - morphConstant.x;\n\tfloat y11 = y + morphConstant.y;\n\t\n\tfloat x12 = x + morphConstant.x;\n\tfloat y12 = y - morphConstant.y;\n\t\n\tfloat x13 = x - morphConstant.x;\n\tfloat y13 = y + morphConstant.y;\n\t\n\tfloat x14 = x + morphConstant.x;\n\tfloat y14 = y - morphConstant.y;\n\t\n\tfloat x15 = x - morphConstant.x;\n\tfloat y15 = y + morphConstant.y;\n\t\n\tfloat x16 = x + morphConstant.x;\n\tfloat y16 = y - morphConstant.y;\n\t\n\tfloat x17 = x - morphConstant.x;", "\n\tvec4 color = vec4(0.0);\n\tvec2 offset = vec2(0.0);\n\tfloat weight = 0.0;\n\tfloat weightSum = 0.0;\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\toffset = vec2(0.0);\n\t\tweight = 0.0;\n\t\tweightSum = 0.0;\n\t\t\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\toffset += vec2(0.0, 1.0);\n\t\t\tweight = texture2D(tex, uv + offset * constant).r;\n\t\t\tweightSum += weight;\n\t\t}\n\t\t\n\t\tcolor += weight / weightSum * texture2D(tex, uv + offset * constant);\n\t}\n\t\n\treturn color;\n}\n\nvoid main()\n{\n\tvec2 uv = gl_TexCoord[0].xy;\n\tvec2 constant = vec2(0.0, 1.0);\n\t\n\tvec4 color = antiAliasedBiomorph(uv, constant);\n\t\n\tgl_FragColor = color;\n}", "\n    return fmod(x, 1.0);\n}\n\n// Basically a triangle wave\nfloat", "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dp = dot(d, uv - p);\n    float dl2 = dl * dl;\n    float dp2 = dp * dp;\n    float dl4 = dl2 * dl2;\n    float dp4 = dp2 * dp2;\n    float dl8 = dl4 * dl4;\n    float dp8 = dp4 * dp4;\n    float dl16 = dl8 * dl8;\n    float dp16 = dp8 * dp8;\n    float dl32 = dl16 * dl16;\n    float dp32 = dp16 * dp16;\n    float dl64 = dl32 * dl32;\n    float dp64 = dp32 * dp32;\n    float dl128 = dl64 * dl64;\n    float dp128 = dp64 * dp64;\n    float dl256 = dl128 * dl128;\n    float dp256 = dp128 * dp128;\n    float dl512 = dl256 * dl256;\n    float dp512 = dp256 * dp256;\n    float dl1024 = dl512 * dl512;\n    float dp1024 = dp512 * dp512;\n    float dl2048 = dl1024 * dl1024;\n    float dp2048 = dp1024 * dp1024;\n    float dl4096 = dl2048 * dl2048;\n    float dp4096 = dp2048 * dp2048;\n    float dl8192 = dl", "\n    vec2 p = mix(pA, pB, uv);\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dl2 = dl * dl;\n    float dl4 = dl2 * dl2;\n    float dl8 = dl4 * dl4;\n    float dl16 = dl8 * dl8;\n    float dl32 = dl16 * dl16;\n    float dl64 = dl32 * dl32;\n    float dl128 = dl64 * dl64;\n    float dl256 = dl128 * dl128;\n    float dl512 = dl256 * dl256;\n    float dl1024 = dl512 * dl512;\n    float dl2048 = dl1024 * dl1024;\n    float dl4096 = dl2048 * dl2048;\n    float dl8192 = dl4096 * dl4096;\n    float dl16384 = dl8192 * dl8192;\n    float dl32768 = dl16384 * dl16384;\n    float dl65536 = dl32768 * dl32768;\n    float dl131072 = dl65536 * dl65536;\n    float dl262144 = dl131072 * dl131072;\n    float dl524288 = dl262144 * dl262144;\n    float dl1048576 = dl524288 * dl524288;\n    float dl2097152 = dl1048576 *", "\n    vec2 p = pA;\n    float d = distance(p, pB);\n    float t = (d - thick.x) / (d - outlineThick);\n    if (t < 0.0) {\n        return 0.0;\n    }\n    if (t > 1.0) {\n        return 1.0;\n    }\n    float d2 = distance(p, pB + (pB - pA) * t);\n    if (d2 < rounded) {\n        return 0.0;\n    }\n    return 1.0;\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat", "\n    vec2 d = pB - pA;\n    float len = length(d);\n    float t = dot(uv - pA, d) / len;\n    if (t < 0.0) return 0.0;\n    if (t > 1.0) return 0.0;\n    float r = length(uv - pA) - thick.x;\n    if (r < 0.0) return 0.0;\n    if (r > len - thick.y) return 0.0;\n    if (rounded > 0.0) {\n        float r2 = r * r;\n        if (r2 > rounded * rounded) return 0.0;\n    }\n    return 1.0;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat", "\n    vec2 d = pB - pA;\n    float len = length(d);\n    float t = dot(uv - pA, d) / len;\n    if (t < 0.0) return 0.0;\n    if (t > 1.0) return 0.0;\n    float r = rounded;\n    if (r < 0.0) r = 0.0;\n    float dl = len - 2.0 * r;\n    if (dl < 0.0) return 0.0;\n    float dl2 = dl * dl;\n    float t2 = t * t;\n    float t4 = t2 * t2;\n    float t6 = t2 * t4;\n    float t8 = t4 * t4;\n    float t10 = t6 * t4;\n    float t12 = t8 * t4;\n    float t14 = t10 * t4;\n    float t16 = t12 * t4;\n    float t18 = t14 * t4;\n    float t20 = t16 * t4;\n    float t22 = t18 * t4;\n    float t24 = t20 * t4;\n    float t26 = t22 * t4;\n    float t28 = t24 * t4;\n    float t30 = t26 * t4;\n    float t32 = t28 * t4;\n    float t34 = t30 * t4;\n    float t36 = t32 * t4;\n    float t38 = t34 * t4;\n    float t40 = t36 * t4;\n    float t42 = t38 * t4;\n    float t44 = t40 * t4;\n    float t46 = t42 * t4;\n    float t48 = t44 * t4;\n    float t50 = t46 * t4;\n    float t52 = t48 * t4;\n    float t54 = t50 * t4;\n    float t56 = t", "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dl2 = dl * dl;\n    float dl4 = dl2 * dl2;\n    float dl8 = dl4 * dl4;\n    float dl16 = dl8 * dl8;\n    float dl32 = dl16 * dl16;\n    float dl64 = dl32 * dl32;\n    float dl128 = dl64 * dl64;\n    float dl256 = dl128 * dl128;\n    float dl512 = dl256 * dl256;\n    float dl1024 = dl512 * dl512;\n    float dl2048 = dl1024 * dl1024;\n    float dl4096 = dl2048 * dl2048;\n    float dl8192 = dl4096 * dl4096;\n    float dl16384 = dl8192 * dl8192;\n    float dl32768 = dl16384 * dl16384;\n    float dl65536 = dl32768 * dl32768;\n    float dl131072 = dl65536 * dl65536;\n    float dl262144 = dl131072 * dl131072;\n    float dl524288 = dl262144 * dl262144;\n    float dl1048576 = dl524288 * dl524288;\n    float dl2097152 = dl1048576 * dl104857", "\n    col = vec3(0.0);\n    col.r = p.x;\n    col.g = p.y;\n    col.b = 0.0;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    DrawPoint(uv, p, col);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 oc = ro - cen;\n    float b = dot( oc, nor );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-sphere intersection\nfloat", "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec", "\n    vec3 ab = pb - pa;\n    float ab2 = dot( ab, ab );\n    float h = length( pa - pb );\n    float r2 = ra * ra;\n    if( ab2 > r2 )\n    {\n        // no intersection\n        return bound3( pa, pa );\n    }\n    float a = acos( clamp( ra / h, -1.0, 1.0 ) );\n    float b = asin( clamp( ab.y / ra, -1.0, 1.0 ) );\n    float s = sin( b );\n    return bound3( pa + vec3( -ab.x * s, -ab.y * s, -ab.z * s ) * a,\n                   pa + vec3( -ab.x * s, -ab.y * s,  ab.z * s ) * a );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spherebbox/spherebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box (http://iquilezles.org/www/articles/boxbbox/boxbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 p, in vec3 s )\n{\n    return bound3( p - s, p + s );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a triangle (http://iquilezles.org/www/articles/tribbox/tribbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 TriangleAABB( in vec3 pa, in vec3 pb, in vec3 pc )\n{\n    return bound3( min( pa, min( pb, pc ) ), max( pa, max( pb, pc ) ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a quad (http://iqu", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n    vec2 res = vec2( -1.0 );\n    vec3 o = ro - cen;\n    vec3 ab = abs(rd) * rad;\n    vec3 q = o - clamp( o, -ab, ab );\n    vec3 m = min( ab, abs(o) - rad );\n    if( all( lessThan( m, vec3(0.0) ) ) )\n    {\n        res.x = length( q );\n        res.y = length( m );\n    }\n    return res;\n}\n\n// ray-sphere intersection\nvec", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - r*r;\n    float d = dot(ap, ab) * 2.0;\n    float e = dot(ap, ap) - r*r;\n    float h = b*b - c*e;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if( t1 < 0.0 ) t1 = -1.0;\n    if( t2 < 0.0 ) t2 = -1.0;\n    if( t1 > t2 ) { float tt = t1; t1 = t2; t2 = tt; }\n    if( t1 < 0.0 ) return -1.0;\n    if( t1 > t2 ) return -1.0;\n    return t1;\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec", "\n    vec2 res = vec2( 1e10 );\n    vec3 rb = abs(ro) - rad;\n    vec3 rb2 = rb * rb;\n    vec3 rb0 = max( rb2.xzy, rb.yzx );\n    vec3 rb1 = min( rb2.xzy, rb.yzx );\n    vec3 rb2 = max( rb2.yzx, rb.xzy );\n    vec3 rb3 = min( rb2.yzx, rb.xzy );\n    vec3 rb4 = max( rb2.zyx, rb.xyz );\n    vec3 rb5 = min( rb2.zyx, rb.xyz );\n    vec3 rb6 = max( rb2.xzy, rb.zyx );\n    vec3 rb7 = min( rb2.xzy, rb.zyx );\n    vec3 rb8 = max( rb2.yxz, rb.xwy );\n    vec3 rb9 = min( rb2.yxz, rb.xwy );\n    vec3 rb10 = max( rb2.wyx, rb.xzw );\n    vec3 rb11 = min( rb2.wyx, rb.xzw );\n    vec3 rb12 = max( rb2.zxy, rb.wyz );\n    vec3 rb13 = min( rb2.zxy, rb.wyz );\n    vec3 rb14 = max( rb2.zyx, rb.wzy );\n    vec3 rb15 = min( rb2.zyx, rb.wzy );\n    vec3 rb16 = max( rb2.xwy, rb.zyw );\n    vec3 rb17 = min( rb2.xwy, rb.zyw );\n    vec3 rb18 = max( rb2.wy", "\n    vec4 res = vec4(0.0);\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 p = ro + rd * t;\n        float d = dist(p);\n        if( d < tmin )\n        {\n            tmin = d;\n            res = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n        if( d > tmax )\n        {\n            break;\n        }\n        t += d;\n    }\n    return res;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec4 res = interesect(ro, rd);\n    if( res.w > 0.0 )\n    {\n        vec3 p = ro + rd * res.w;\n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n        vec3 col = vec3(0.0);\n        col += vec3(0.5) * dot(n, vec3(0.0, 1.0, 0.0));\n        col += vec3(0.5) * dot(n, vec3(0.0, -1.0, 0.0));\n        col += vec3(0.5) * dot(n, vec3(1.0, 0.0, 0.0));\n        col += vec3(0.5) * dot(n, vec3(-1.0, 0.0, 0.0));\n        col += vec3(0.5) * dot(n, vec3", "\n    float t = i * 2.0 * PI;\n    float s = sin(t);\n    float c = cos(t);\n    float r = sqrt(1.0 - s * s);\n    float phi = atan2(s, c);\n    float theta = acos(n);\n    return vec3(r * cos(phi) * sin(theta), r * sin(phi) * sin(theta), r * cos(theta));\n}\n\n//------------------------------------------------------------------------------\n//\n//------------------------------------------------------------------------------\nvec", "\n    vec4 res = vec4( 0.0 );\n    vec3 p = ro;\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin2 = 0.0;\n    float tmax2 = 10000.0;\n    float tmin3 = 0.0;\n    float tmax3 = 10000.0;\n    float tmin4 = 0.0;\n    float tmax4 = 10000.0;\n    float tmin5 = 0.0;\n    float tmax5 = 10000.0;\n    float tmin6 = 0.0;\n    float tmax6 = 10000.0;\n    float tmin7 = 0.0;\n    float tmax7 = 10000.0;\n    float tmin8 = 0.0;\n    float tmax8 = 10000.0;\n    float tmin9 = 0.0;\n    float tmax9 = 10000.0;\n    float tmin10 = 0.0;\n    float tmax10 = 10000.0;\n    float tmin11 = 0.0;\n    float tmax11 = 10000.0;\n    float tmin12 = 0.0;\n    float tmax12 = 10000.0;\n    float tmin13 = 0.0;\n    float tmax13 = 10000.0;\n    float tmin14 = 0.0;\n    float tmax14 = 10000.0;\n    float tmin15 = 0.0;\n    float tmax15 = 10000.0;\n    float tmin16 = 0.0;\n    float tmax16 = 10000.0;\n    float tmin17 = 0.0;\n    float tmax17 = 10000.0;\n    float tmin18 = 0.0;\n    float tmax18 = 10", "\n    vec3 q = vec3(p, 0.0);\n    return vec3(fract(sin(dot(q, vec3(12.9898, 78.233, 45.5432))) * 43758.5453),\n                fract(cos(dot(q, vec3(12.9898, 78.233, 45.5432))) * 43758.5453),\n                0.0);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat", "\n    vec2 p = uv;\n    p.x *= orient.x;\n    p.y *= orient.y;\n    return vec3(0.0);\n}\n\n// Pattern 2\nvec", "\n    vec2 p = uv;\n    p.x *= orient.x;\n    p.y *= orient.y;\n    return vec3(0.0);\n}\n\n// Pattern 3\nvec", "\n    vec2 d = ddx * ddy;\n    return 0.25 * (\n        (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x + p.y) * (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * (p.x + p.y) * d.x * d.y\n    );\n}\n\n// grid ratio\nfloat", "\n    vec3 q = vec3(0.0);\n    q.x = p.x * p.x * p.x * ( p.x * ( p.x * 6.0 - 15.0 ) + 10.0 );\n    q.y = p.y * p.y * p.y * ( p.y * ( p.y * 6.0 - 15.0 ) + 10.0 );\n    q.z = p.z * p.z * p.z * ( p.z * ( p.z * 6.0 - 15.0 ) + 10.0 );\n    return q;\n}\n\n// --------------------------------------------------------\n// 2D noise\n// --------------------------------------------------------\n\nfloat", "\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a", "\n    return v33_sub(a,b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mul(v33 a,vec3 b){\n    return v33_mul(a,b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 div(v33 a,vec3 b){\n    return v33_div(a,b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 cross(v33 a,vec3 b){\n    return v33_cross(a,b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 normalize(v33 a){\n    return v33_normalize(a);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 reflect(v33 a,vec3 b){\n    return v33_reflect(a,b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 refract(v33 a,vec3 b,float n1,float n2){\n    return v33_refract(a,b,n1,n2);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 refract(v33 a,vec3 b,float n){\n    return v33_refract(a,b,n,1.0f);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 refract(v33 a,vec3 b,float n1,float n2){\n    return v33_refract(a,b,n1,n2);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 refract(v33 a,vec3 b,float n){\n    return v33_", "\n    v33 c;\n    c.x=a.x-b.x;\n    c.y=a.y-b.y;\n    c.z=a.z-b.z;\n    return c;\n}\n\n//multiply a by b\nv33 mult(v33 a,v33 b){\n    v33 c;\n    c.x=a.x*b.x;\n    c.y=a.y*b.y;\n    c.z=a.z*b.z;\n    return c;\n}\n\n//divide a by b\nv33 div(v33 a,v33 b){\n    v33 c;\n    c.x=a.x/b.x;\n    c.y=a.y/b.y;\n    c.z=a.z/b.z;\n    return c;\n}\n\n//add a to b\nv33 add(v33 a,v33 b){\n    v33 c;\n    c.x=a.x+b.x;\n    c.y=a.y+b.y;\n    c.z=a.z+b.z;\n    return c;\n}\n\n//subtract a from b\nv33 sub(v33 a,v33 b){\n    v33 c;\n    c.x=a.x-b.x;\n    c.y=a.y-b.y;\n    c.z=a.z-b.z;\n    return c;\n}\n\n//multiply a by b\nv33 mult(v33 a,v33 b){\n    v33 c;\n    c.x=a.x*b.x;\n    c.y=a.y*b.y;\n    c.z=a.z*b.z;\n    return c;\n}\n\n//divide a by b\nv33 div(v33 a,v33 b){\n    v33 c;\n    c.x=a.x/b.x;\n    c.y=a.y", "\n\tvec2 d;\n\td.x = a.x - b.x;\n\td.y = a.y - b.y;\n\treturn d;\n}\n\n//v33-differentials for AA\nvec", "\n    return vec2(dot(a.xyz,b),dot(a.xyz,b));\n}\n\n//dual dotprodiuct on v33s\nvec", "\n    return (v33){a.x*b.x,a.y*b.x,a.z*b.x};\n}\n\n//dot product\nfloat", "\n    vec3 q=mod(p,w)-0.5*w;\n    return fract(sin(dot(q,vec3(12.9898,78.233,45.145)))*43758.5453);\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\nfloat", "\n    float t=0.0;\n    float a=0.0;\n    float b=0.0;\n    float c=0.0;\n    float d=0.0;\n    float e=0.0;\n    float f=0.0;\n    float g=0.0;\n    float h=0.0;\n    float i=0.0;\n    float j=0.0;\n    float k=0.0;\n    float l=0.0;\n    float m=0.0;\n    float n=0.0;\n    float o=0.0;\n    float p=0.0;\n    float q=0.0;\n    float r=0.0;\n    float s=0.0;\n    float t=0.0;\n    float u=0.0;\n    float v=0.0;\n    float w=0.0;\n    float x=0.0;\n    float y=0.0;\n    float z=0.0;\n    float aa=0.0;\n    float ab=0.0;\n    float ac=0.0;\n    float ad=0.0;\n    float ae=0.0;\n    float af=0.0;\n    float ag=0.0;\n    float ah=0.0;\n    float ai=0.0;\n    float aj=0.0;\n    float ak=0.0;\n    float al=0.0;\n    float am=0.0;\n    float an=0.0;\n    float ao=0.0;\n    float ap=0.0;\n    float aq=0.0;\n    float ar=0.0;\n    float as=0.0;\n    float at=0.0;\n    float au=0.0;\n    float av=0.0;\n    float aw=0.0;\n    float ax=0.0;\n    float ay=0.0;\n    float az=0.0;\n    float ba=0.0;\n    float bb=0.0;\n    float bc=0.0;", "\n    float a = dot(r.p,r.p);\n    float b = 2.0*dot(r.p,r.d);\n    float c = dot(r.d,r.d) - 1.0;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return 0.0;\n    float t = (-b - sqrt(d))/(2.0*a);\n    if(t<0.0) t = (-b + sqrt(d))/(2.0*a);\n    if(t<0.0) return 0.0;\n    vec4 p = r.p + t*r.d;\n    float dp = length(p-s.xyz);\n    if(dp<s.w) return 0.0;\n    return 1.0;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat", "\n    float r = s.w;\n    float d = length(u-s.xyz);\n    return 1.0-smoothstep(r,r+0.005,d);\n}\n\n//sphere occlusion\nfloat", "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    vec2 s = (p + q) * 0.5;\n    vec2 t = (q + r) * 0.5;\n    vec2 u = (s + t) * 0.5;\n    vec2 v = (t + r) * 0.5;\n    vec2 w = (u + v) * 0.5;\n    vec2 x = (v + w) * 0.5;\n    vec2 y = (w + u) * 0.5;\n    vec2 z = (u + x) * 0.5;\n    vec2 a = (x + y) * 0.5;\n    vec2 b = (y + z) * 0.5;\n    vec2 c = (z + a) * 0.5;\n    vec2 d = (a + b) * 0.5;\n    vec2 e = (b + c) * 0.5;\n    vec2 f = (c + d) * 0.5;\n    vec2 g = (d + e) * 0.5;\n    vec2 h = (e + f) * 0.5;\n    vec2 i = (f + g) * 0.5;\n    vec2 j = (g + h) * 0.5;\n    vec2 k = (h + i) * 0.5;\n    vec2 l = (i + j) * 0.5;\n    vec2 m = (j + k) * 0.5;\n    vec2 n = (k + l) * 0.5;\n    vec2 o = (l + m) * 0.5;\n    vec2 p1 = (m + n) * 0.5;\n    vec2 q1 = (n + o) * 0.5;\n    vec2 r1 = (o + p) * 0.5;\n    vec2 s1 = (p +", "\n    vec2 p01 = p0 - p1;\n    vec2 p12 = p1 - p2;\n    vec2 p012 = p01 + p12;\n    vec2 p012_2 = p012 * 0.5;\n    vec2 p012_4 = p012_2 * 0.25;\n    vec2 p012_8 = p012_4 * 0.125;\n    vec2 p012_16 = p012_8 * 0.0625;\n    vec2 p012_32 = p012_16 * 0.03125;\n    vec2 p012_64 = p012_32 * 0.015625;\n    vec2 p012_128 = p012_64 * 0.0078125;\n    vec2 p012_256 = p012_128 * 0.00390625;\n    vec2 p012_512 = p012_256 * 0.001953125;\n    vec2 p012_1024 = p012_512 * 0.0009765625;\n    vec2 p012_2048 = p012_1024 * 0.00048828125;\n    vec2 p012_4096 = p012_2048 * 0.000244140625;\n    vec2 p012_8192 = p012_4096 * 0.0001220703125;\n    vec2 p012_16384 = p012_8192 * 0.00006103", "\n    vec3 bmin = vec3( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ),\n                      min( min( p0.y, p1.y ), min( p2.y, p3.y ) ),\n                      min( min( p0.z, p1.z ), min( p2.z, p3.z ) ) );\n    vec3 bmax = vec3( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ),\n                      max( max( p0.y, p1.y ), max( p2.y, p3.y ) ),\n                      max( max( p0.z, p1.z ), max( p2.z, p3.z ) ) );\n    return bound3( bmin, bmax );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    float t1 = dot( ap, ab );\n    float t2 = dot( bp, ab );\n    float t3 = dot( ap, ab );\n    float t4 = dot( bp, ab );\n    float tmin = max( max( t1, t2 ), max( t3, t4 ) );\n    float tmax = min( min( t1, t2", "\n    vec2 p01 = p0 + (p1 - p0) * 0.5;\n    vec2 p12 = p1 + (p2 - p1) * 0.5;\n    vec2 p23 = p2 + (p3 - p2) * 0.5;\n    vec2 p30 = p3 + (p0 - p3) * 0.5;\n\n    vec2 p012 = p01 + (p12 - p01) * 0.5;\n    vec2 p123 = p12 + (p23 - p12) * 0.5;\n    vec2 p230 = p23 + (p30 - p23) * 0.5;\n    vec2 p301 = p30 + (p01 - p30) * 0.5;\n\n    vec2 p0123 = p012 + (p123 - p012) * 0.5;\n    vec2 p1230 = p123 + (p230 - p123) * 0.5;\n    vec2 p2301 = p230 + (p301 - p230) * 0.5;\n    vec2 p3012 = p301 + (p012 - p301) * 0.5;\n\n    vec2 p01230 = p0123 + (p1230 - p0123) * 0.5;\n    vec2 p12301 = p1230 + (p2301 - p1230) * 0.5;\n    vec2 p23012 = p2301 + (p3012 - p2301) * 0.5;\n    vec2 p30123 = p3012 + (p0123 - p3012) * 0.5;\n\n    vec2 p012301", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    return mix(p012, p123, 0.5);\n}\n\n// 2D Bezier curve.\n//\n// p0, p1, p2, p3 are the control points.\n//\n// pos is the position in the curve.\n//\n// fast, use in production.\nvec", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross( rd, v0v2 );\n    float det = dot( v0v1, pvec );\n\n    if( det == 0.0 )\n        return vec3( -1.0 );\n\n    vec3 tvec = ro - v0;\n    float u = dot( tvec, pvec );\n    if( u < 0.0 || u > det )\n        return vec3( -1.0 );\n\n    vec3 qvec = cross( tvec, v0v1 );\n    float v = dot( rd, qvec );\n    if( v < 0.0 || u + v > det )\n        return vec3( -1.0 );\n\n    float t = dot( v0v2, qvec );\n    return vec3( t, u / det, v / det );\n}\n\n// Triangle intersection. Returns { t, u, v }\nvec", "\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 s = cross( nor, e1 );\n    float a = dot( e0, s );\n    if( a < 0.0 ) return 0.0;\n    vec3 t = pos - v0;\n    float b = dot( t, s );\n    if( b < 0.0 || b > a ) return 0.0;\n    vec3 q = cross( t, e0 );\n    float c = dot( nor, q );\n    if( c < 0.0 ) return 0.0;\n    return 1.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat", "\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    float h = clamp( dot(p,ab) / dot(ab,ab), 0.0, 1.0 );\n    float k = clamp( dot(p,bc) / dot(bc,bc), 0.0, 1.0 );\n    return length( mix( mix( p, ab, h ), mix( bc, ab+bc, k ), k ) );\n}\n\n// signed distance to a cubic bezier\nfloat", "\n    vec2 d = abs(p) - vec2(r1,r2);\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - he;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - ( ra + rb );\n}\n\n// trapezoid / capped cone\nfloat", "\n    vec2 e = vec2( 1.0, -1.0 ) * 0.57735026918962576451;\n    return normalize( e.xyy * fwidth( pos ) +\n                      e.yxy * fwidth( pos.yzx ) +\n                      e.yyx * fwidth( pos.yzx ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        t += h;\n        if( h<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// --------------------------------------------------------\n// Simplex 3D Noise - fractal noise with an interesting\n// property\n// --------------------------------------------------------\n\nfloat", "\n    vec2 i = floor( x );\n    vec2 f = fract( x );\n    f = f*f*(3.0-2.0*f);\n    float n = mix( mix( dot( i, vec2(1.0,0.0) ), dot( i, vec2(0.0,1.0) ), f.x ),\n                   mix( dot( i+vec2(1.0,0.0), vec2(1.0,0.0) ),\n                        dot( i+vec2(0.0,1.0), vec2(1.0,0.0) ), f.x ), f.y );\n    return mix( n, n+1.0, abs(f.y-0.5) );\n}\n\n// 2D Perlin noise\nfloat", "\n    float f = 0.0;\n    float a = 1.0;\n    float r = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        x *= 2.0;\n        a *= 0.5;\n        r *= 0.5;\n    }\n    return f / a;\n}\n\n// fractal noise\nfloat", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic sphere - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat", "\n    vec2 d = abs(p.xz) - r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic sphere - improved approximated distance\nfloat", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    return 1.0f - clamp( 1.0f - x, 0.0f, 1.0f );\n}\n\n// Schlick-Beckmann distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat", "\n    return (x + p) - floor( (x + p) / p ) * p;\n}\n\n// biased triangle\nfloat", "\n    float k = 1.0;\n    float a = 0.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 0.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 0.0;\n    float h_ = h * 6.0;\n    float i = floor( h_ );\n    float j = ceil( h_ );\n    float t = fract( h_ );\n    float u = t * t * (3.0 - 2.0 * t);\n    return mix(\n        mix(\n            mix(\n                mix(\n                    mix(\n                        mix(\n                            mix(\n                                mix(\n                                    mix(\n                                        mix(\n                                            mix(\n                                                mix(\n                                                    mix(\n                                                        mix(\n                                                            mix(\n                                                                mix(\n                                                                    mix(\n                                                                        mix(\n                                                                            mix(\n                                                                                mix(\n                                                                                    mix(\n                                                                                        mix(\n                                                                                            mix(\n                                                                                                mix(\n                                                                                                    mix(\n                                                                                                        mix(\n                                                                                                            mix(\n                                                                                                                mix(\n                                                                                                                    mix(\n                                                                                                                        mix(\n                                                                                                                            mix(\n                                                                                                                                mix(\n                                                                                                                                    mix(\n                                                                                                                                        mix(\n                                                                                                                                            mix(\n                                                                                                                                                mix(\n                                                                                                                                                    mix(\n                                                                                                                                                        mix(\n                                                                                                                                                            mix(\n                                                                                                                                                                mix(\n                                                                                                                                                                    mix(\n                                                                                                                                                                        mix(\n                                                                                                                                                                            mix(\n                                                                                                                                                                                mix(\n                                                                                                                                                                                    mix(\n                                                                                                                                                                                        mix(\n                                                                                                                                                                                            mix(\n                                                                                                                                                                                                    mix(\n                                                                                                                                                                                                        mix(\n                                                                                                                                                                                                            mix(\n                                                                                                                                                                                                                mix(\n                                                                                                                                                                                                                    mix(\n                                                                                                                                                                                                                        mix(\n                                                                                                                                                                                                                            mix(\n                                                                                                                                                                                                                                mix(\n                                                                                                                                                                                                                                    mix(\n                                                                                                                                                                                                                                        mix(\n                                                                                                                                                                                                                                            mix(\n                                                                                                                                                                                                                                                mix(\n                                                                                                                                                                                                                                                    mix(\n                                                                                                                                                                                                                                                        mix(\n                                                                                                                                                                                                                                                            mix(\n                                                                                                                                                                                                                                                                    mix(\n                                                                                                                                                                                                                                                                        mix(\n                                                                                                                                                                                                                                                                ", "\n    vec3 oc = pa - ro;\n    vec3 ab = pb - pa;\n    float b = dot(ab, ab);\n    float c = dot(oc, ab) * 2.0;\n    float d = dot(oc, oc) - r*r;\n    float h = b*c - 4.0*d;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = (-c - h) / 2.0;\n    if( t < 0.0 ) t = (-c + h) / 2.0;\n    if( t < 0.0 ) return -1.0;\n    vec3 pt = ro + t*rd;\n    float y = length( pt - pa ) - r;\n    if( y > 0.0 ) return -1.0;\n    float x = length( pt - pb ) - r;\n    if( x > 0.0 ) return -1.0;\n    return t;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float h = clamp(dot(ab, ap), 0.0, length(ab));\n    return length(ap - ab * clamp(h / length(ab), 0.0, 1.0)) - h;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float d = distance( a, b );\n    float t = ( d - length( ro - a ) ) / length( rd );\n    float s = smoothstep( 0.0, 1.0, k * t );\n    return s;\n}\n\n// fakesoft shadow occlusion\nfloat", "\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = rad1 + (rad2 - rad1) * (1.0 - smoothstep(0.0, 1.0, d / rad1));\n    float t = th * (1.0 - smoothstep(0.0, 1.0, d / rad1));\n    return vec2(r * cos(a + t), r * sin(a + t));\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec", "\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat", "\n\tvec3 p = pos;\n\tfloat r = length(p);\n\tfloat a = r*r*r*r;\n\tvec3 n = p/a;\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec", "\n    vec2 q = p - sca * ra;\n    float d = dot( q, q );\n    float r = rb * ra;\n    return sqrt( d - r * r );\n}\n\n// sdArc is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        sdfSphere( pos + eps.xyy, 0.01 ) - sdfSphere( pos - eps.xyy, 0.01 ),\n        sdfSphere( pos + eps.yxy, 0.01 ) - sdfSphere( pos - eps.yxy, 0.01 ),\n        sdfSphere( pos + eps.yyx, 0.01 ) - sdfSphere( pos - eps.yyx, 0.01 ) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * dot(q,q);\n    float h = f * (f + f - 16.0 * dot(f,f) + 10.0 * dot(f,f) * dot(f,f));\n    return 0.25 * (h * (h + h + 1.0) + g * (g + g + 1.0) * (g + g + 1.0));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    return 1.0 - abs( x - floor( x / k ) );\n}\n\n//\n// Sine function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat", "\n    vec3 sky_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 view_dir_norm = normalize(sample_pos - light_dir_norm);\n    float cos_theta = dot(light_dir_norm, view_dir_norm);\n    float cos_theta_sq = cos_theta * cos_theta;\n    float cos_theta_sq_inv = 1.0 - cos_theta_sq;\n    float cos_theta_sq_inv_sq = cos_theta_sq_inv * cos_theta_sq_inv;\n    float cos_theta_sq_inv_sq_inv = cos_theta_sq_inv_sq * cos_theta_sq_inv_sq;\n    float cos_theta_sq_inv_sq_inv_inv = cos_theta_sq_inv_sq_inv * cos_theta_sq_inv_sq_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv * cos_theta_sq_inv_sq_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_", "\n    vec4 color = vec4(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_attenuation = vec3(1.0);\n    vec3 light_ambient = vec3(0.0);\n    vec3 light_diffuse = vec3(0.0);\n    vec3 light_specular = vec3(0.0);\n    vec3 light_spot_dir = vec3(0.0);\n    vec3 light_spot_color = vec3(0.0);\n    vec3 light_spot_attenuation = vec3(0.0);\n    vec3 light_spot_ambient = vec3(0.0);\n    vec3 light_spot_diffuse = vec3(0.0);\n    vec3 light_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_", "\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (2.0 * (coord.x / resolution.x) - 1.0) * resolution.x / resolution.y;\n    camera_vector.y = (1.0 - 2.0 * (coord.y / resolution.y)) * resolution.y;\n    camera_vector.z = -1.0;\n    return normalize(camera_vector);\n}\n\n/*\nthis function calculates the ray direction for the current pixel\n*/\nvec", "\n    float d = length(p.xy) - ra;\n    float a = acos(clamp(p.z / ra, -1.0, 1.0));\n    float s = sin(a);\n    return d * s * s / a;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 1) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (material == 2) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    if (material == 3) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    if (material == 4) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    if (material == 5) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 6) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 7) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 8) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 9) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 10) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 11) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 12) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 13) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 14) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 15) {\n       ", "\n  if (material == MAT_GLASS) {\n    return 0.0;\n  } else if (material == MAT_METAL) {\n    return 0.0;\n  } else if (material == MAT_DIFFUSE) {\n    return 0.0;\n  } else if (material == MAT_SPECULAR) {\n    return 0.0;\n  } else if (material == MAT_REFLECTIVE) {\n    return 0.0;\n  } else if (material == MAT_TRANSLUCENT) {\n    return 0.0;\n  } else if (material == MAT_EMITTING) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_DIFFUSE) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_SPECULAR) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_TRANSLUCENT) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE_DIFFUSE) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE_SPECULAR) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE_TRANSLUCENT) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE_REFLECTIVE) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE_REFLECTIVE_DIFFUSE) {\n    return 0.0;\n  } else if (material == MAT_EMITTING_REFLECTIVE_REFLECTIVE_SPECULAR) {\n    return 0.0;\n  } else if (material == MAT", "\n    return materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat", "\n    return materials[material].opacity;\n}\n\n// Get the color of a material.\nvec", "\n    vec3 v0 = tri_b - tri_a;\n    vec3 v1 = tri_c - tri_a;\n    vec3 v2 = tri_a - line_a;\n    vec3 v3 = line_b - line_a;\n    vec3 h = cross(v1, v2);\n    float a = dot(v0, h);\n    if (a > -EPSILON && a < EPSILON) return vec3(false, 0.0, 0.0);\n    float f = 1.0 / a;\n    vec3 s = line_a - tri_a;\n    vec3 q = cross(s, v0);\n    float u = f * dot(q, h);\n    if (u < 0.0 || u > 1.0) return vec3(false, 0.0, 0.0);\n    vec3 r = cross(v1, q);\n    float v = f * dot(r, v3);\n    if (v < 0.0 || u + v > 1.0) return vec3(false, 0.0, 0.0);\n    float t = f * dot(v2, r);\n    if (t > EPSILON) return vec3(true, u, v);\n    return vec3(false, 0.0, 0.0);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec", "\n    vec3 a = tri_a - tri_c;\n    vec3 b = tri_b - tri_c;\n    return normalize(cross(a, b));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec", "\n    vec3 camera_direction = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(vec3(0, 1, 0), camera_direction));\n    vec3 camera_up = cross(camera_direction, camera_right);\n\n    return mat3(\n        camera_right.x, camera_up.x, camera_direction.x,\n        camera_right.y, camera_up.y, camera_direction.y,\n        camera_right.z, camera_up.z, camera_direction.z\n    );\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/projection-matrix\nmat", "\n  cast_ray_result result;\n  result.hit = false;\n  result.distance = -1.0f;\n  result.normal = vec3(0.0f);\n  result.material = material_default;\n  for (int i = 0; i < scene.triangle_count; i++) {\n    triangle_t triangle = scene.triangles[i];\n    cast_ray_result local_result = cast_ray_triangle(ray_origin, ray_target, triangle);\n    if (local_result.hit && (local_result.distance < result.distance || result.distance < 0.0f)) {\n      result = local_result;\n    }\n  }\n  return result;\n}\n\n//src/main.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/shm.h>\n#include <sys/ipc.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/times.h>\n#include <sys/times.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n#include <sys/utsname.h>\n", "\n    float shadow_distance = 1000.0;\n    float shadow_factor = 1.0;\n    vec3 shadow_ray_origin = ray_origin;\n    vec3 shadow_ray_target = ray_target;\n    for (int i = 0; i < 10; i++) {\n        vec3 intersection_point = intersect_ray_with_scene(shadow_ray_origin, shadow_ray_target);\n        if (intersection_point.x!= -1.0) {\n            shadow_distance = length(intersection_point - shadow_ray_origin);\n            shadow_factor = 0.0;\n            break;\n        }\n        shadow_ray_origin = shadow_ray_origin + shadow_ray_target * 0.01;\n    }\n    return shadow_factor * shadow_distance;\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    return fract(sin(p)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    return (float)fmod(sin(n+0.1) * 43758.5453123, 3.14159265358979323846);\n}\n\n//------------------------------------------------------------------------------\n//\n//------------------------------------------------------------------------------\nvoid main()\n{\n    //\n    // Setup\n    //\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    //\n    // Setup\n    //\n    vec2 c = vec2(0.5);\n    float t = 0.0;\n    float dt = 0.001;\n    float f = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n    float f2 = 0.0;\n    float f3 = 0.0;\n    float f4 = 0.0;\n    float f5 = 0.0;\n    float f6 = 0.0;\n    float f7 = 0.0;\n    float f8 = 0.0;\n    float f9 = 0.0;\n    float f10 = 0.0;\n    float f11 = 0.0;\n    float f12 = 0.0;\n    float f13 = 0.0;\n    float f14 = 0.0;\n    float f15 = 0.0;\n    float f16 = 0.0;\n    float f17 = 0.0;\n    float f18 = 0.0;\n    float f19 = 0.0;\n    float f20 = 0.0;\n    float f21 = 0.0;\n    float f22 = 0.0;\n    float f23 = 0.0;\n    float f24 = 0.0;\n    float f25 = 0.0;\n    float f26 = 0.0;\n    float f27 = 0.0;\n    float f28 = 0.0", "\n    return fract(sin(p)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    float v = 0.0;\n    float a = 1.0;\n    float freq = G;\n    float amp = 1.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        v += amp * noise( x * freq );\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return v;\n}\n\n// fbm\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if ( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n        pos = p + vec3( 0.0, 0.0, t );\n    }\n    color = vec3( 0.5 + 0.5 * sin( 10.0 * t ) );\n    return color;\n}\n\n// Return the color of the pixel\nvec", "\n    vec3 p = pb * 0.5 + 0.5;\n    vec3 c = vec3(0.0);\n    c += cubic(p.x, p.y, p.z, 0.0, 1.0, 0.0, 0.0, 0.0);\n    c += cubic(p.x, p.y, p.z, 1.0, 0.0, 0.0, 0.0, 0.0);\n    c += cubic(p.x, p.y, p.z, 0.0, 0.0, 1.0, 0.0, 0.0);\n    c += cubic(p.x, p.y, p.z, 0.0, 0.0, 0.0, 1.0, 0.0);\n    c += cubic(p.x, p.y, p.z, 0.0, 0.0, 0.0, 0.0, 1.0);\n    return c * 0.25;\n}\n\n// Return the color of the point p in the unit\n// box.\nvec", "\n    vec4 res = vec4( 1.0 );\n    vec3 q = cen - ro;\n    vec3 qd = dot( q, rd );\n    vec3 qr = dot( q, q );\n    vec3 qrd = dot( qd, rd );\n    vec3 qrr = dot( qr, rd );\n    vec3 qrd2 = qrd * qrd;\n    vec3 qrr2 = qrr * qrr;\n    vec3 qrd3 = qrd2 * qrd;\n    vec3 qrr3 = qrr2 * qrr;\n    vec3 qrd4 = qrd3 * qrd;\n    vec3 qrr4 = qrr3 * qrr;\n    vec3 qrd5 = qrd4 * qrd;\n    vec3 qrr5 = qrr4 * qrr;\n    vec3 qrd6 = qrd5 * qrd;\n    vec3 qrr6 = qrr5 * qrr;\n    vec3 qrd7 = qrd6 * qrd;\n    vec3 qrr7 = qrr6 * qrr;\n    vec3 qrd8 = qrd7 * qrd;\n    vec3 qrr8 = qrr7 * qrr;\n    vec3 qrd9 = qrd8 * qrd;\n    vec3 qrr9 = qrr8 * qrr;\n    vec3 qrd10 = qrd9 * qrd;\n    vec3 qrr10 = qrr9 * qrr;\n    vec3 qrd11 = qrd10 * qrd;\n    vec3 qrr11 = qrr10 * qrr;\n    vec3 qrd12 = qrd11 * qrd;\n    vec3 qrr12 = qrr11 * qrr;\n    vec3 qrd13 = qrd12 * qrd;\n    vec3 qrr13 = qrr12 * qrr;\n    vec3 qrd14 = qrd13 * qrd;\n    vec3 qrr14", "\n    vec3 q = cen - ro;\n    float b = dot(q,q);\n    float r = rad.x;\n    if( b > r*r ) return 0.0;\n    r = rad.y;\n    if( b > r*r ) return 0.0;\n    r = rad.z;\n    if( b > r*r ) return 0.0;\n    return 1.0;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, w * h / t);\n        t += h;\n        if (t > tmax || h < 0.001)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat", " return seed = (seed * 1664525.0f + 1013904223.0f); }\n\n// montecarlo based shadow, for ground truth comparison\nfloat", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec", "\n    vec2 d = abs(vec2(length(p.xz) - ra, p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - h + la;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat", "\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = dot( pa, pa );\n    float y = dot( pb, pb );\n    float z = dot( pa, pb );\n    float w = sqrt( x + y - 2.0 * z );\n    float d = length( pa ) - r;\n    float pd = length( pb ) - r;\n    float bd = band;\n    return vec4( d, w, z, w + bd );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 q = abs(p) - b;\n    return vec4( length(max(q,0.0)) - r, \n                 length(max(vec2(max(q.x,q.y)),0.0)) - s, \n                 length(q) - r, \n                 length(p) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 d = abs(p) - b;\n    return vec3(\n        min(max(d.x,d.y),0.0),\n        max(d.x,max(d.y,-1.0)),\n        max(d.x,d.y)\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p - vec2(0.5);\n    float d = length(q);\n    if( d > r ) return vec4(0.0);\n    float a = atan(q.y, q.x);\n    float da = dacos(q.x, q.y);\n    float b = da - a;\n    float w = r - d;\n    float x = w * (1.0 - smoothstep(0.0, band, b));\n    return vec4(x, b, da, w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 v0 = verts[0];\n    vec2 v1 = verts[1];\n    vec2 v2 = verts[2];\n    vec2 v3 = verts[3];\n    vec2 v4 = verts[4];\n\n    vec2 v01 = v1 - v0;\n    vec2 v02 = v2 - v0;\n    vec2 v03 = v3 - v0;\n    vec2 v04 = v4 - v0;\n\n    vec2 v12 = v1 - v2;\n    vec2 v13 = v3 - v1;\n    vec2 v14 = v4 - v1;\n\n    vec2 v23 = v2 - v3;\n    vec2 v24 = v4 - v2;\n\n    vec2 v34 = v3 - v4;\n\n    vec2 v012 = v01 + v02;\n    vec2 v013 = v01 + v03;\n    vec2 v014 = v01 + v04;\n\n    vec2 v123 = v12 + v13;\n    vec2 v124 = v12 + v14;\n\n    vec2 v234 = v23 + v24;\n\n    vec2 v341 = v34 + v01;\n    vec2 v342 = v34 + v02;\n    vec2 v343 = v34 + v03;\n    vec2 v344 = v34 + v04;\n\n    vec2 v0123 = v012 + v013;\n    vec2 v0124 = v012 + v014;\n\n    vec2 v1234 = v123 + v124;\n\n    vec2 v2341 = v234 + v012;\n    vec2 v2342 = v234 + v013;\n", "\n    vec2 p0 = verts[0];\n    vec2 p1 = verts[1];\n    vec2 p2 = verts[2];\n    vec2 p3 = verts[3];\n    vec2 p4 = verts[4];\n\n    vec2 p01 = p0 - p1;\n    vec2 p02 = p0 - p2;\n    vec2 p03 = p0 - p3;\n    vec2 p04 = p0 - p4;\n\n    vec2 p12 = p1 - p2;\n    vec2 p13 = p1 - p3;\n    vec2 p14 = p1 - p4;\n\n    vec2 p23 = p2 - p3;\n    vec2 p24 = p2 - p4;\n\n    vec2 p34 = p3 - p4;\n\n    vec2 p012 = p01 + p12;\n    vec2 p013 = p01 + p13;\n    vec2 p014 = p01 + p14;\n\n    vec2 p023 = p02 + p23;\n    vec2 p024 = p02 + p24;\n\n    vec2 p034 = p03 + p34;\n\n    vec2 p123 = p12 + p23;\n    vec2 p124 = p12 + p24;\n\n    vec2 p134 = p13 + p34;\n\n    vec2 p234 = p23 + p34;\n\n    vec2 p0123 = p012 + p123;\n    vec2 p0124 = p012 + p124;\n\n    vec2 p0134 = p013 + p134;\n\n    vec2 p0234 = p023 + p234;\n\n    vec2 p1234 = p123 + p23", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return vec3( pa + ba * h, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p;\n    q.x = abs(q.x);\n    float k = r * 3.1415926535897932384626433832795/3;\n    float c = cos(k);\n    float s = sin(k);\n    float t = 1.0/sqrt(3.0);\n    float ac = c*t;\n    float bc = s*t;\n    float a = ac;\n    float b = bc;\n    float cs = c*s;\n    float ss = s*s;\n    vec2 d = vec2(ac,bc);\n    vec2 e = vec2(cs,ss);\n    vec2 f = vec2(bc,-ac);\n    vec2 g = vec2(ss,-cs);\n    vec2 h = vec2(-bc,-ac);\n    vec2 i = vec2(-cs,-ss);\n    vec2 j = vec2(-ss,-cs);\n    vec2 k = vec2(0.0, -1.0);\n    vec2 l = vec2(1.0, 0.0);\n    vec2 m = vec2(0.0, 1.0);\n    vec2 n = vec2(-1.0, 0.0);\n    vec2 o = vec2(0.0, 0.0);\n    vec2 p = vec2(0.0, 0.0);\n    vec2 q = vec2(0.0, 0.0);\n    vec2 r = vec2(0.0, 0.0);\n    vec2 s = vec2(0.0, 0.0);\n    vec2 t = vec2(0.0, 0.0);\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n    vec2 w = vec2(0.0, ", "\n  vec3 dp = p - X[2];\n  float a = dot(dp, dp);\n  float b = dot(dp, X[0]);\n  float c = dot(X[0], X[0]);\n  float d = b*b - a*c;\n  if (d < 0.0) return false;\n  d = sqrt(d);\n  tan1 = (b*dp - X[1]) / d;\n  tan2 = (b*dp + X[1]) / d;\n  return true;\n}\n\n// Return the intersection of the conic X with the line segment from p1 to p2.\n// Return false if no intersection.\nbool intersect(vec3 p1, vec3 p2, mat3 X, out vec3 p) {\n  vec3 dp = p2 - p1;\n  float a = dot(dp, dp);\n  float b = dot(dp, X[0]);\n  float c = dot(X[0], X[0]);\n  float d = b*b - a*c;\n  if (d < 0.0) return false;\n  d = sqrt(d);\n  float t = (b*dp - X[1]) / d;\n  if (t < 0.0) return false;\n  if (t > 1.0) return false;\n  p = p1 + t*dp;\n  return true;\n}\n\n// Return the intersection of the conic X with the line segment from p1 to p2.\n// Return false if no intersection.\nbool intersect(vec3 p1, vec3 p2, mat3 X, out vec3 p, out vec3 tan1, out vec3 tan2) {\n  vec3 dp = p2 - p1;\n  float a = dot(dp, dp);\n  float b = dot(dp, X[0]);\n  float c = dot(X[0], X[0]);\n  float d = b*b - a*c;\n  if (d < 0.0) return false;\n  d = sqrt(d);\n  float t = (b*dp - X[1]) / d;", "\n    return vec3(a.x / b.x, a.y / b.y, a.z / b.z);\n}\n\n//returns the dot product of two vectors.\nfloat", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Transforms a point by a 4x4 matrix\nvec", "\n    return 1.0f - (1.0f - x / R) * (1.0f - x / R) * (1.0f - x / R);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat", "\n    return 1.0f - expf(-e / (2.0f * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat", "\n    float k = (a - b) / (R * R);\n    return k * k * e;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat", "\n    float d = distance(p, c);\n    return e * (1.0 - smoothstep(R, R * 2.0, d));\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n    float d = distance(c, a);\n    if (d < R)\n    {\n        return e;\n    }\n    else\n    {\n        float d2 = distance(c, b);\n        if (d2 < R)\n        {\n            return e;\n        }\n        else\n        {\n            float d3 = distance(c, a + (b - a) * 0.5);\n            if (d3 < R)\n            {\n                return e;\n            }\n            else\n            {\n                return 0.0;\n            }\n        }\n    }\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat", "\n    float d = length(p);\n    return d - 0.001;\n}\n\n// Sphere root\nfloat", "\n    return length(a - b);\n}\n\n// K root\nfloat", "\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    return normalize(vec3(\n        ObjectEval(p+eps.xyy) - ObjectEval(p-eps.xyy),\n        ObjectEval(p+eps.yxy) - ObjectEval(p-eps.yxy),\n        ObjectEval(p+eps.yyx) - ObjectEval(p-eps.yyx)\n    ));\n}\n\n// Evaluate the object at the given point\nfloat", "\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float t = 0.0;\n    vec3 p = o;\n    vec3 d = u;\n    vec3 n = vec3(0.0);\n    vec3 c = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 r = vec3(0.0);\n    vec3 v = vec3(0.0);\n    vec3 b = vec3(0.0);\n    vec3 tc = vec3(0.0);\n    vec3 tn = vec3(0.0);\n    vec3 tb = vec3(0.0);\n    vec3 tl = vec3(0.0);\n    vec3 tr = vec3(0.0);\n    vec3 tn2 = vec3(0.0);\n    vec3 tb2 = vec3(0.0);\n    vec3 tl2 = vec3(0.0);\n    vec3 tr2 = vec3(0.0);\n    vec3 tn3 = vec3(0.0);\n    vec3 tb3 = vec3(0.0);\n    vec3 tl3 = vec3(0.0);\n    vec3 tr3 = vec3(0.0);\n    vec3 tn4 = vec3(0.0);\n    vec3 tb4 = vec3(0.0);\n    vec3 tl4 = vec3(0.0);\n    vec3 tr4 = vec3(0.0);\n    vec3 tn5 = vec3(0.0);\n    vec3 tb5 = vec3(0.0);\n    vec3 tl5 = vec3(0.0);\n    vec3 tr5 = vec3(0.0);\n    vec3 tn6 = vec3(0.0);\n    vec3 t", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin_step = 0.001;\n    float tmax_step = 0.001;\n    float tmin_step_max = 10000.0;\n    float tmax_step_max = 10000.0;\n    float tmin_step_min = 0.001;\n    float tmax_step_min = 0.001;\n    float tmin_step_min_max = 0.001;\n    float tmax_step_min_max = 0.001;\n    float tmin_step_min_max_max = 0.001;\n    float tmax_step_min_max_max = 0.001;\n    float tmin_step_min_max_max_max = 0.001;\n    float tmax_step_min_max_max_max = 0.001;\n    float tmin_step_min_max_max_max_max = 0.001;\n    float tmax_step_min_max_max_max_max = 0.001;\n    float tmin_step_min_max_max_max_max_max = 0.001;\n    float tmax_step_min_max_max_max_max_max = 0.001;\n    float tmin_step_min_max_max_max_max_max_max = 0.001;\n    float tmax_step_min_max_max_max_max_max_max = 0.001;\n    float tmin_step_min_max_max_max_max_max_max_max = 0.001;\n    float tmax_step_min_max_max_max_max_max_max_max = 0.001;\n    float tmin_step_min_max_max_max_max_max_max_max_max = 0.001;\n    float tmax_step_min_max_max_max", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat", "\n    vec2 p = -1.0;\n    vec2 b = -ro.xy;\n    vec2 a = rad.xy;\n    vec2 t = b/rd.xy;\n    vec2 tmin = t;\n    vec2 tmax = t;\n    vec2 t1 = t + a.xy;\n    vec2 t2 = t - a.xy;\n    if( tmin.x > t1.x ) tmin.x = t1.x;\n    if( tmin.y > t1.y ) tmin.y = t1.y;\n    if( tmax.x < t2.x ) tmax.x = t2.x;\n    if( tmax.y < t2.y ) tmax.y = t2.y;\n    if( tmin.x > tmax.y || tmax.x < tmin.y ) return p;\n    if( tmin.x > tmin.y ) tmin.x = tmin.y;\n    if( tmax.x < tmax.y ) tmax.x = tmax.y;\n    p.x = max(tmin.x,tmin.y);\n    p.y = min(tmax.x,tmax.y);\n    return p;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    return coord / vec2(1.0, 1.0);\n}\n\n// normalized fragment coordinate\nvec", "\n    vec2 d = q - p;\n    vec2 d1 = d.yx;\n    vec2 d2 = d.x;\n    vec2 d3 = d.y;\n    vec2 d4 = d.x;\n    vec2 d5 = d.yx;\n    vec2 d6 = d.x;\n    vec2 d7 = d.yx;\n    vec2 d8 = d.x;\n    vec2 d9 = d.yx;\n    vec2 d10 = d.x;\n    vec2 d11 = d.yx;\n    vec2 d12 = d.x;\n    vec2 d13 = d.yx;\n    vec2 d14 = d.x;\n    vec2 d15 = d.yx;\n    vec2 d16 = d.x;\n    vec2 d17 = d.yx;\n    vec2 d18 = d.x;\n    vec2 d19 = d.yx;\n    vec2 d20 = d.x;\n    vec2 d21 = d.yx;\n    vec2 d22 = d.x;\n    vec2 d23 = d.yx;\n    vec2 d24 = d.x;\n    vec2 d25 = d.yx;\n    vec2 d26 = d.x;\n    vec2 d27 = d.yx;\n    vec2 d28 = d.x;\n    vec2 d29 = d.yx;\n    vec2 d30 = d.x;\n    vec2 d31 = d.yx;\n    vec2 d32 = d.x;\n    vec2 d33 = d.yx;\n    vec2 d34 = d.x;\n    vec2 d35 = d.yx;\n    vec2 d36 = d.x;\n    vec2 d37 = d.yx;\n    vec2 d38 = d.", "\n    vec2 q = p - vec2(0.5, 0.5);\n    float a = atan(q.y, q.x) + PI;\n    float b = length(q) - r;\n    float c = abs(b) - d;\n    return vec3(a, b, c);\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy", "\n    vec2 q = p - c;\n    float d = length(q);\n    float a = atan(q.y, q.x);\n    float s = sin(a);\n    float c = cos(a);\n    float k = (d - r) / (d + r);\n    return vec3(c * k, s * k, 0.0);\n}\n\n// 3D version of the pie function\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec", "\n    vec2 b = v[1] - v[0];\n    vec2 c = v[2] - v[0];\n    vec2 d = v[0] - p;\n    float e = dot(b,c);\n    float f = dot(d,c);\n    float g = dot(d,b);\n    float h = f + g - e;\n    float twoH = 2.0*h;\n    float a = 1.0/(twoH*e - h*h);\n    vec2 s = a*(b*f - c*g + d*(e-h));\n    return vec3(s, a*(-c*f + b*g - d*e));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p - sca;\n    float d = length(q);\n    if( d > ra ) return vec3(0.0);\n    float a = acos(dot(q, scb)/ra);\n    float b = acos(dot(q, sca)/rb);\n    float t = (a + b - 2.0*PI) / (2.0*PI);\n    return vec3(t, 0.0, 0.0);\n}\n\n// 3D arc\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec", "\n    return dot( a, b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\n    vec2 q = p - ab;\n    float k = dot(q, q) / dot(ab, ab);\n    return vec3(k - 0.5, 2.0 * k * (1.0 - k), 1.0 - k);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(q.x*cos(q.y),q.x*sin(q.y),p.z,0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec3 proj = a + ba * h;\n    return vec4( proj - p, length( pa ) - r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = abs(p);\n    return max(q.x,q.y) - wi - he - sk;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat", "\n    vec2 q = p - vec2(0.5, 0.5);\n    float d = length(q);\n    float a = atan(q.y, q.x) + pi;\n    float r = (wi + he) * 0.5;\n    float s = (wi - he) * 0.5;\n    float c = cos(a);\n    float s2 = sin(a);\n    float t = (d - r) / s;\n    float u = (d + r) / s;\n    float v = (d - s) / t;\n    float w = (d + s) / t;\n    float x = (wi * wi + he * he - d * d) / (2 * wi * he);\n    float y = sqrt(1 - x * x);\n    float z = atan(y, x) - pi / 2;\n    float sz = sin(z);\n    float cz = cos(z);\n    float s2z = s2 * sz;\n    float c2z = c2 * cz;\n    float s2z2 = s2z * s2z;\n    float c2z2 = c2z * c2z;\n    float s2z3 = s2z2 * s2z;\n    float c2z3 = c2z2 * c2z;\n    float s2z4 = s2z3 * s2z;\n    float c2z4 = c2z3 * c2z;\n    float s2z5 = s2z4 * s2z;\n    float c2z5 = c2z4 * c2z;\n    float s2z6 = s2z5 * s2z;\n    float c2z6 = c2z5 * c2z;\n    float s2z7 = s2z6 * s2z;\n    float c2z7 = c2z6 * c2z;\n    float s2z8 = s2z7 * s2z;\n    float c2z8 = c2z7 * c2z;\n    float s2z9 = s2z8 * s2z;\n   ", "\n\t\tfloat r;\n\t\tr = p / c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat", "\n    return (a < b)? a : b;\n}\n\n// IQ's polynominal max\nfloat", "\n    return p - size * floor(p / size);\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_circle\nfloat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec", "\n    vec3 tmin = (boxSize - abs(ro)) / rd;\n    vec3 tmax = (boxSize + abs(ro)) / rd;\n    vec3 t1 = min(tmin, tmax);\n    vec3 t2 = max(tmin, tmax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if (tNear > tFar || tFar < 0.0) {\n        outNormal = vec3(0.0);\n        return vec2(tFar, tFar);\n    }\n    outNormal = sign(rd);\n    return vec2(tNear, tFar);\n}\n\n// IQ's ray sphere intersection\nvec", "\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n    e6 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4,", "\n    vec2 v = b - a;\n    vec2 w = p - a;\n    return dot(w, v) / dot(v, v);\n}\n\nfloat", "\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 p = vec2(length(ro.xz) - tor.x, ro.y);\n    float d = length(p) - tor.y;\n    float h = length(ro.xz + rd.xz * d) - tor.x;\n    return max(h, d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec3 q = vec3(pos.x, pos.y, pos.z);\n    vec3 q2 = q * q;\n    return normalize(vec3(q2.x - q2.y, q2.x + q2.y, q2.x + q2.z));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    return mix(col, vec3(c), r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    vec3 col = vec3(c);\n    col = postProcess(col, q);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return p - size * floor(p / size);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat", "\n    return length(p-c) - r;\n}\n\n// signed distance to a circle\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle\nfloat", "\n    return dot(a, b);\n}\n\n// signed distance to a 2D triangle\nfloat", "\n    vec2 q = vec2(s,0.0);\n    vec2 a = p - q;\n    return length(a) - r;\n}\n\n// s = side length\n// r = corner radius\nfloat", "\n    return pow(x, vec3(2.2));\n}\n\n// Tone mapping function\nvec", "\n    return vec3(\n        x.y * (x.x * (x.x - 2.0) + x.y - 1.0) + x.z * (x.x * (x.x - 1.0) - 1.0),\n        x.x * (x.x * (x.x - 2.0) - 1.0) + x.y * (x.x * (x.x - 1.0) + 1.0) + x.z,\n        x.x * (x.x * (x.x - 1.0) + 1.0) - x.y * (x.x * (x.x - 2.0) - 1.0)\n    );\n}\n\n// s-curve\nvec", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = (r-w)/k;\n    return r*cos(a+c)+w;\n}\n\n// 3D version\nfloat", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec", "\n    vec3 rayEnd = rayStart + rayDir * rayLength;\n    vec3 rayColor = vec3(0.0);\n    vec3 rayLengths = vec3(0.0);\n    vec3 rayDirs = vec3(0.0);\n    vec3 rayDirsInv = vec3(0.0);\n    vec3 rayDirsSq = vec3(0.0);\n    vec3 rayDirsCos = vec3(0.0);\n    vec3 rayDirsSin = vec3(0.0);\n    vec3 rayDirsCosSq = vec3(0.0);\n    vec3 rayDirsSinSq = vec3(0.0);\n    vec3 rayDirsCosSin = vec3(0.0);\n    vec3 rayDirsCosSinSq = vec3(0.0);\n    vec3 rayDirsCosSinCos = vec3(0.0);\n    vec3 rayDirsCosSinCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosC", "\n    vec3 p = p2;\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    float r = ra;\n    float s = rb;\n    float t = d;\n    float u = dot(p, p);\n    float v = dot(q, q);\n    float w = dot(p, q);\n    float A = u + v - u*v;\n    float B = r*r;\n    float C = s*s;\n    float D = t*t;\n    float E = w*w;\n    float F = dot(p, p) - r*r;\n    float G = dot(q, q) - s*s;\n    float H = dot(p, q) - t*t;\n    float I = dot(p, p) - d*d;\n    float J = dot(q, q) - d*d;\n    float K = dot(p, p) - d*d;\n    float L = dot(q, q) - d*d;\n    float M = dot(p, p) - d*d;\n    float N = dot(q, q) - d*d;\n    float O = dot(p, p) - d*d;\n    float P = dot(q, q) - d*d;\n    float Q = dot(p, p) - d*d;\n    float R = dot(q, q) - d*d;\n    float S = dot(p, p) - d*d;\n    float T = dot(q, q) - d*d;\n    float U = dot(p, p) - d*d;\n    float V = dot(q, q) - d*d;\n    float W = dot(p, p) - d*d;\n    float X = dot(q, q) - d*d;\n    float Y = dot(p, p) - d*d;\n    float Z = dot(q, q) - d*d;\n    float AA = A*A;\n    float BB = B*B;\n    float CC = C*C;\n    float DD = D*D", "\n  vec3 q = abs(p);\n  return length(max(q-vec3(r,h,h),0.0))-r;\n}\n\n// --------------------------------------------------------\n// 3D Sphere\n//\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        t += h;\n        if( h<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat", "\n    return length(p.xy) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat", "\n    vec2 e = vec2( 1.0, -1.0 ) * 0.57735026918962576451;\n    return normalize( e.xyy * fwidth( pos ) +\n                      e.yxy * fwidth( pos.yzx ) +\n                      e.yyx * fwidth( pos.zyx ) );\n}\n\n// https://iquilezles.org/articles/sdf2d\nfloat", "\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(q) - r;\n}\n\n// r=radius, h=height\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n\n    return mix(mix(mix( dot(p, vec3(1.0, 57.0, 113.0)),\n                        dot(p, vec3(57.0, 113.0, 157.0)),\n                        f.x),\n                   mix( dot(p, vec3(113.0, 157.0, 113.0)),\n                        dot(p, vec3(157.0, 113.0, 113.0)),\n                        f.x),\n                   f.y),\n               mix(mix( dot(p, vec3(57.0, 113.0, 157.0)),\n                        dot(p, vec3(113.0, 157.0, 57.0)),\n                        f.x),\n                   mix( dot(p, vec3(157.0, 57.0, 113.0)),\n                        dot(p, vec3(57.0, 113.0, 157.0)),\n                        f.x),\n                   f.y),\n               f.z);\n}\n\n// 3d simplex noise function\nfloat", "\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(0.5), sin(0.5), -sin(0.5), cos(0.50) );\n    for (int i = 0; i < 4; ++i)\n    {\n        f += a * noise(p);\n        p = rot * p * 2.02;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat", "\n    p3 = fract(p3 * vec3(127.1, 311.7, 127.1));\n    return -1.0 + 2.0 * fract(sin(dot(p3, vec3(73.1, 246.1, 124.1))) * 43758.5453);\n}\n\n//value noise hash\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iGlobalTime;\n    float a = t * 0.001;\n    float b = t * 0.002;\n    float c = t * 0.003;\n    float d = t * 0.004;\n    float e = t * 0.005;\n    float f = t * 0.006;\n    float g = t * 0.007;\n    float h = t * 0.008;\n    float i = t * 0.009;\n    float j = t * 0.01;\n    float k = t * 0.011;\n    float l = t * 0.012;\n    float m = t * 0.013;\n    float n = t * 0.014;\n    float o = t * 0.015;\n    float p = t * 0.016;\n    float q = t * 0.017;\n    float r = t * 0.018;\n    float s = t * 0.019;\n    float t = t * 0.02;\n    float u = t * 0.021;\n    float v = t * 0.022;\n    float w = t * 0.023;\n    float x = t * 0.024;\n    float y = t * 0.025;\n    float z = t * 0.026;\n\n    vec3 col = vec3(0.0);\n\n    float d1 = length(p);\n    float d2 = length(p + vec2(sin(a), cos(a)));\n    float d3 = length(p + vec2(sin(b), cos(b)));\n    float d4 = length(p + ve", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec", "\n    p = abs(p);\n    return p - size * floor(p / size);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat", "\n    return co * 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return pow(t, 1.0 / 2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return clamp(a - k, b, b + k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < dbuffer) return -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat", "\n  vec4 q = vec4(0.0);\n  for (int i = 0; i < 10; i++) {\n    q += sin(p);\n    p = p * 2.0 + vec4(0.5);\n  }\n  return q;\n}\n\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n  vec4 q = formula(vec4(p, 0.0, 1.0));\n  vec4 r = formula(vec4(p, 1.0, 1.0));\n  vec4 s = formula(vec4(p, 2.0, 1.0));\n  vec4 t = formula(vec4(p, 3.0, 1.0));\n  vec4 u = formula(vec4(p, 4.0, 1.0));\n  vec4 v = formula(vec4(p, 5.0, 1.0));\n  vec4 w = formula(vec4(p, 6.0, 1.0));\n  vec4 x = formula(vec4(p, 7.0, 1.0));\n  vec4 y = formula(vec4(p, 8.0, 1.0));\n  vec4 z = formula(vec4(p, 9.0, 1.0));\n  vec4 a = formula(vec4(p, 10.0, 1.0));\n  vec4 b = formula(vec4(p, 11.0, 1.0));\n  vec4 c = formula(vec4(p, 12.0, 1.0));\n  vec4 d = formula(vec4(p, 13.0, 1.0));\n  vec4 e = formula(vec4(p, 14.0, 1.0));\n  vec4 f = formula(vec4(p, 15.0, 1.0));\n  vec4 g = formula(vec4", "\n    vec3 q = abs(p) - r;\n    return vec4(\n        length(max(q,0.0)) - r.x,\n        dot(q,q) - r.y,\n        q.z - r.z,\n        length(q) - r.w\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return vec4(back.rgb, back.a * front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    if (front.a == 0.0) {\n        return back;\n    }\n    if (front.a == 1.0) {\n        return front.rgb;\n    }\n    return (back * (1.0 - front.a)) + (front.rgb * front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q-r*vec2(clamp(q.x,0.0,1.0),sign(q.y)*0.5))*sign(q.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), vec3(0.0), vec3(1.0));\n}\n\n// https://github.com/64/tonemapping/blob/master/tonemapping.glsl\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    return exp(-1.0 / (Temp * 1.0e-2)) * vec3(0.216, 0.619, 0.060);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(i, vec2(1.0, 0.0)), dot(i, vec2(0.0, 1.0)), u.x),\n               mix(dot(i, vec2(1.0, 1.0)), dot(i, vec2(1.0, 0.0)), u.x), u.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/Xds3zK\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec", "\n    vec2 q = p.yx;\n    vec2 r = q.yx - vec2(n, n);\n    vec2 s = q.yx + vec2(n, n);\n    vec2 t = q.yx - vec2(n, -n);\n    vec2 u = q.yx + vec2(n, -n);\n    vec2 v = q.yx - vec2(-n, n);\n    vec2 w = q.yx + vec2(-n, n);\n    vec2 x = q.yx - vec2(-n, -n);\n    vec2 y = q.yx + vec2(-n, -n);\n    vec2 z = q.yx - vec2(n, 0);\n    vec2 a = q.yx + vec2(n, 0);\n    vec2 b = q.yx - vec2(0, n);\n    vec2 c = q.yx + vec2(0, n);\n    vec2 d = q.yx - vec2(0, -n);\n    vec2 e = q.yx + vec2(0, -n);\n    vec2 f = q.yx - vec2(-n, 0);\n    vec2 g = q.yx + vec2(-n, 0);\n    vec2 h = q.yx - vec2(n, 0);\n    vec2 i = q.yx + vec2(n, 0);\n    vec2 j = q.yx - vec2(0, n);\n    vec2 k = q.yx + vec2(0, n);\n    vec2 l = q.yx - vec2(0, -n);\n    vec2 m = q.yx + vec2(0, -n);\n    vec2 n1 = q.yx - vec2(n, n);\n    vec2 n2 = q.yx + vec2(n, n);\n    vec", "\n    return (x + t) * (x - t) / (2 * t);\n}\n\n// generalization of Devil's Staircase\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    float t = time * 0.01;\n    float a = t * 0.01;\n    float b = t * 0.01;\n    float c = t * 0.01;\n    float d = t * 0.01;\n    float e = t * 0.01;\n    float f = t * 0.01;\n    float g = t * 0.01;\n    float h = t * 0.01;\n    float i = t * 0.01;\n    float j = t * 0.01;\n    float k = t * 0.01;\n    float l = t * 0.01;\n    float m = t * 0.01;\n    float n = t * 0.01;\n    float o = t * 0.01;\n    float p = t * 0.01;\n    float q = t * 0.01;\n    float r = t * 0.01;\n    float s = t * 0.01;\n    float tt = t * 0.01;\n    float u = t * 0.01;\n    float v = t * 0.01;\n    float w = t * 0.01;\n    float x = t * 0.01;\n    float y = t * 0.01;\n    float z = t * 0.01;\n    float aa = t * 0.01;\n    float bb = t * 0.01;\n    float cc = t * 0.01;\n    float dd = t * 0.01;\n    float ee = t * 0.01;\n    float ff = t * 0.01;\n    float gg = t * 0.01;\n    float hh = t * 0.01;\n    float ii = t * 0.01;\n    float jj = t * 0.01;\n    float kk = t * 0.01;\n    float ll = t * 0", "\n    return atan(y, x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat", "\n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n    return vec2(atanh(z.x), atanh(z.y));\n}\n\n// Hyperbolic tangent \nvec", "\n    return vec2(exp(z.x), exp(z.y));\n}\n\n// My own attempt at an ctanh\nvec", "\n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n    return vec2(exp(z.x), exp(z.y));\n}\n\n// My own attempt at a ctanh\nvec", "\n    float alphaSum = alpha.x + alpha.y + alpha.z + alpha.w;\n    float alphaMax = max(max(alpha.x, alpha.y), max(alpha.z, alpha.w));\n    float alphaMin = min(min(alpha.x, alpha.y), min(alpha.z, alpha.w));\n    float alphaDiff = alphaMax - alphaMin;\n    float alphaMid = (alphaMax + alphaMin) / 2.0;\n    float alphaMidDiff = alphaMid - alphaMin;\n    float alphaMidDiffPercent = alphaMidDiff / alphaDiff;\n    float alphaMidDiffPercentSmooth = smoothstep(0.0, 1.0, alphaMidDiffPercent);\n    float alphaMidDiffPercentSmoothInverse = 1.0 - alphaMidDiffPercentSmooth;\n    float alphaMidDiffPercentSmoothInverseSquared = alphaMidDiffPercentSmoothInverse * alphaMidDiffPercentSmoothInverse;\n    float alphaMidDiffPercentSmoothInverseCubed = alphaMidDiffPercentSmoothInverseSquared * alphaMidDiffPercentSmoothInverseSquared;\n    float alphaMidDiffPercentSmoothInverseCubedSquared = alphaMidDiffPercentSmoothInverseCubed * alphaMidDiffPercentSmoothInverseCubed;\n    float alphaMidDiffPercentSmoothInverseCubedSquaredSquared = alphaMidDiffPercentSmoothInverseCubedSquared * alphaMidDiffPercentSmoothInverseCubedSquared;\n    float alphaMidDiffPercentSmoothInverseCubedSquaredSquaredSquared = alphaMidDiffPercentSmoothInverseCubedSquaredSquared * alphaMidDiffPercentSmoothInverseCubedSquaredSquared;\n    float alphaMidDiffPercentSmoothInverseCubedSquaredSquaredSquaredSquared = alphaMidDiffPercentSmoothInverseCubedSquaredSquaredSquared * alphaMidDiff", "\n    float d = length(p.xy);\n    return max(d, abs(p.z));\n}\n\n//Distance from the Edge of the Sphere\nfloat", "\n    vec3 uv = uvw.xy;\n    vec3 w = uvw.z;\n    vec3 v = vec3(0.0);\n    vec3 w2 = w*w;\n    vec3 w3 = w2*w;\n    vec3 w4 = w3*w;\n    vec3 w5 = w4*w;\n    vec3 w6 = w5*w;\n    vec3 w7 = w6*w;\n    vec3 w8 = w7*w;\n    vec3 w9 = w8*w;\n    vec3 w10 = w9*w;\n    vec3 w11 = w10*w;\n    vec3 w12 = w11*w;\n    vec3 w13 = w12*w;\n    vec3 w14 = w13*w;\n    vec3 w15 = w14*w;\n    vec3 w16 = w15*w;\n    vec3 w17 = w16*w;\n    vec3 w18 = w17*w;\n    vec3 w19 = w18*w;\n    vec3 w20 = w19*w;\n    vec3 w21 = w20*w;\n    vec3 w22 = w21*w;\n    vec3 w23 = w22*w;\n    vec3 w24 = w23*w;\n    vec3 w25 = w24*w;\n    vec3 w26 = w25*w;\n    vec3 w27 = w26*w;\n    vec3 w28 = w27*w;\n    vec3 w29 = w28*w;\n    vec3 w30 = w29*w;\n    vec3 w31 = w30*w;\n    vec3 w32 = w31*w;\n    vec3 w33 = w32*w;\n    vec3 w34", "\n    vec3 scaled = uvw * gridRes;\n    vec3 scaledOffset = offset * gridRes;\n    return tilingVal3D(scaled, scaledOffset);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes, float scale) {\n    vec3 scaled = uvw * gridRes * scale;\n    vec3 scaledOffset = offset * gridRes * scale;\n    return tilingVal3D(scaled, scaledOffset);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes, float scale, float offsetScale) {\n    vec3 scaled = uvw * gridRes * scale;\n    vec3 scaledOffset = offset * gridRes * scale * offsetScale;\n    return tilingVal3D(scaled, scaledOffset);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes, float scale, float offsetScale, float offsetScale2) {\n    vec3 scaled = uvw * gridRes * scale;\n    vec3 scaledOffset = offset * gridRes * scale * offsetScale;\n    scaledOffset.yz *= offsetScale2;\n    return tilingVal3D(scaled, scaledOffset);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes, float scale, float offsetScale, float offsetScale2, float offsetScale3) {\n    vec3 scaled = uvw * gridRes * scale;\n    vec3 scaledOffset = offset * gridRes * scale * offsetScale;\n    scaledOffset.yz *= offsetScale2;\n    scaledOffset.xz *= offsetScale3;\n    return tilingVal3D(scaled, scaledOffset);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\n", "\n    vec3 p = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 q = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 r = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 s = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 t = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 u = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 v = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 w = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 x = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 y = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 z = vec3(uvw.x, uvw.y, uvw.z);\n\n    float x0 = floor(p.x / gridRes);\n    float y0 = floor(p.y / gridRes);\n    float z0 = floor(p.z / gridRes);\n    float x1 = ceil(p.x / gridRes);\n    float y1 = ceil(p.y / gridRes);\n    float z1 = ceil(p.z / gridRes);\n\n    float x2 = floor(q.x / gridRes);\n    float y2 = floor(q.y / gridRes);\n    float z2 = floor(q.z / gridRes);\n    float x3 = ceil(q.x / gridRes);\n    float y3 = ceil(q.y / gridRes);\n    float z3 = ceil(q.z / gridRes);\n\n    float x4 = floor(r.x / gridRes);", "\n    return length(p) - 1.0;\n}\n\n//Icosahedron Distance from Center\nfloat", "\n    return vec3(\n        t * 0.5 + 0.5,\n        t * 0.5 + 0.5,\n        t * 0.5 + 0.5\n    );\n}\n\n// makes Cool colormap with polynimal 7\nvec", "\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    return m * v;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    return length(p);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat", "\n    vec2 p = uv;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t =", "\n    return mix(vec3(0.267, 0.593, 0.98), vec3(0.267, 0.593, 0.98), t) - vec3(0.5, 0.5, 0.5);\n}\n\n// makes viridis colormap with polynimal 7 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n    return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat", "\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d * 2.0) / len;\n    float f = sin(r * 10.0 + time * 0.01) * 0.5 + 0.5;\n    return f;\n}\n\n// generates pixelated directional waves\nfloat", "\n    vec2 p = uv * gridRes;\n    vec2 q = vec2(p.x, p.y + len);\n    vec2 r = vec2(p.x + len, p.y);\n    vec2 s = vec2(p.x, p.y - len);\n    vec2 t = vec2(p.x - len, p.y);\n    vec2 u = vec2(p.x, p.y);\n    vec2 v = vec2(p.x + len, p.y + len);\n    vec2 w = vec2(p.x + len, p.y - len);\n    vec2 x = vec2(p.x - len, p.y + len);\n    vec2 y = vec2(p.x - len, p.y - len);\n    vec2 z = vec2(p.x, p.y);\n\n    float a = dot(q - u, r - u);\n    float b = dot(q - v, r - v);\n    float c = dot(q - w, r - w);\n    float d = dot(q - t, r - t);\n    float e = dot(q - z, s - z);\n    float f = dot(q - x, s - x);\n    float g = dot(q - y, s - y);\n\n    float h = dot(p - u, t - u);\n    float i = dot(p - v, t - v);\n    float j = dot(p - w, t - w);\n    float k = dot(p - t, s - t);\n    float l = dot(p - x, s - x);\n    float m = dot(p - y, s - y);\n    float n = dot(p - z, s - z);\n\n    float aa = max(max(a, b), max(c, d));\n    float bb = max(max(e, f), max(g, h));\n    float cc = max(max(i, j), max(k, l));\n    float dd = max(max(m, n", "\n    return vec2(\n        point.x + sin(time) * radius,\n        point.y + cos(time) * radius\n    );\n}\n\n// makes a simple flowmap of a spiral\nvec", "\n    return vec2(floor(pos.x / arrowTileSize), floor(pos.y / arrowTileSize));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec", "\n    vec2 v = p2 - p1;\n    vec2 w = p - p1;\n    return dot(w, v) / dot(v, v);\n}\n\n// Computes the signed distance from a line segment\nfloat", "\n  vec2 q = arrowTileCenterCoord(p);\n  float d = distance(q, p);\n  float a = atan(v.y, v.x);\n  float s = sin(a);\n  float c = cos(a);\n  float r = length(v);\n  float h = r * s;\n  float w = r * c;\n  float d1 = distance(q, vec2(q.x + h, q.y + w));\n  float d2 = distance(q, vec2(q.x - h, q.y + w));\n  float d3 = distance(q, vec2(q.x + h, q.y - w));\n  float d4 = distance(q, vec2(q.x - h, q.y - w));\n  float d5 = min(d1, min(d2, min(d3, d4)));\n  return d - d5;\n}\n\n// Returns the signed distance from the arrow at the given point\nfloat", "\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec", "\n\tvec2 p = point;\n\tfloat r = length(p);\n\tfloat a = atan(p.y, p.x);\n\tfloat d = (r - offset) / spread;\n\ta += d;\n\ta = mod(a, TAU);\n\ta = a / TAU;\n\ta = a * 2.0 - 1.0;\n\treturn vec2(cos(a), sin(a));\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec2 q = p - id;\n    return length( q ) - sp;\n}\n\n// the SDF we want to repeat\nfloat", "\n    float d = length(p) - ra;\n    return d < 0.0? 0.0 : d;\n}\n\n// the point of this shader\nfloat", "\n    return length(uvw);\n}\n\n//edge distance of a Sphere\nfloat", "\n    vec4 color = texture(cubeTexture, uvw);\n    if (color.a < 0.001) {\n        discard;\n    }\n    return color;\n}\n\n// Cube Tiling\nvec", "\n    vec3 uv = uvw * gridRes;\n    vec3 iuv = floor(uv);\n    vec3 fuv = fract(uv);\n    vec3 duv = fuv - iuv;\n    vec3 duv2 = duv * duv;\n    vec3 duv3 = duv2 * duv;\n    vec3 duv4 = duv3 * duv;\n    vec3 duv5 = duv4 * duv;\n    vec3 duv6 = duv5 * duv;\n    vec3 duv7 = duv6 * duv;\n    vec3 duv8 = duv7 * duv;\n    vec3 duv9 = duv8 * duv;\n    vec3 duv10 = duv9 * duv;\n    vec3 duv11 = duv10 * duv;\n    vec3 duv12 = duv11 * duv;\n    vec3 duv13 = duv12 * duv;\n    vec3 duv14 = duv13 * duv;\n    vec3 duv15 = duv14 * duv;\n    vec3 duv16 = duv15 * duv;\n    vec3 duv17 = duv16 * duv;\n    vec3 duv18 = duv17 * duv;\n    vec3 duv19 = duv18 * duv;\n    vec3 duv20 = duv19 * duv;\n    vec3 duv21 = duv20 * duv;\n    vec3 duv22 = duv21 * duv;\n    vec3 duv23 = duv22 * duv;\n    vec3 duv24 = duv23 * duv;\n    vec3 duv25 = duv24 * duv;\n    vec3 duv26 = duv25 * duv;\n    vec3 duv27 = duv26 * duv;\n    vec3 duv28", "\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 7 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), q.z);\n}\n\n//Distance from the Edge of Octahedron\nfloat", "\n    return vec3(0.5, 0.5, 0.5) * (1.0 + sin(t * 10.0));\n}\n\n// makes summer colormap with polynimal 6\nvec", "\n    vec2 texelSize = vec2(1.0) / vec2(textureSize(tex, 0));\n    vec2 texelOffset = texelSize * 0.5;\n    vec2 texelOffsets[4] = vec2[4](\n        vec2(0.0, 0.0),\n        vec2(texelSize.x, 0.0),\n        vec2(0.0, texelSize.y),\n        vec2(texelSize.x, texelSize.y)\n    );\n    vec2 texelOffsets2[4] = vec2[4](\n        vec2(0.0, 0.0),\n        vec2(texelSize.x, 0.0),\n        vec2(0.0, texelSize.y),\n        vec2(texelSize.x, texelSize.y)\n    );\n    vec2 texelOffsets3[4] = vec2[4](\n        vec2(0.0, 0.0),\n        vec2(texelSize.x, 0.0),\n        vec2(0.0, texelSize.y),\n        vec2(texelSize.x, texelSize.y)\n    );\n    vec2 texelOffsets4[4] = vec2[4](\n        vec2(0.0, 0.0),\n        vec2(texelSize.x, 0.0),\n        vec2(0.0, texelSize.y),\n        vec2(texelSize.x, texelSize.y)\n    );\n    vec2 texelOffsets5[4] = vec2[4](\n        vec2(0.0, 0.0),\n        vec2(texelSize.x, 0.0),\n        vec2(0.0, texelSize.y),\n        vec2(texelSize.x, texelSize.y)\n    );\n", "\n    vec3 color = vec3(0.0);\n    vec2 p = uv;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float t = a / (2.0 * PI);\n    float s = smoothstep(0.0, 1.0, r);\n    float d = s * (1.0 - smoothstep(0.0, 1.0, r));\n    float c = d * (1.0 - smoothstep(0.0, 1.0, r));\n    color = vec3(c);\n    return color;\n}\n\n//rhombic shape form Manhattan distance\nvec", "\n    vec2 grid = floor(uv * gridRes) + offset;\n    return vec3(grid.x, grid.y, 0.0);\n}\n\n// nakes a checkerboard pattern\nvec", "\n    vec3 color = vec3(0.0);\n    vec2 grid = vec2(gridRes);\n    vec2 gridPos = floor(uv * grid) / grid;\n    vec2 gridPos2 = gridPos + vec2(1.0);\n    vec2 gridPos3 = gridPos + vec2(2.0);\n    vec2 gridPos4 = gridPos + vec2(3.0);\n    vec2 gridPos5 = gridPos + vec2(4.0);\n    vec2 gridPos6 = gridPos + vec2(5.0);\n    vec2 gridPos7 = gridPos + vec2(6.0);\n    vec2 gridPos8 = gridPos + vec2(7.0);\n    vec2 gridPos9 = gridPos + vec2(8.0);\n    vec2 gridPos10 = gridPos + vec2(9.0);\n    vec2 gridPos11 = gridPos + vec2(10.0);\n    vec2 gridPos12 = gridPos + vec2(11.0);\n    vec2 gridPos13 = gridPos + vec2(12.0);\n    vec2 gridPos14 = gridPos + vec2(13.0);\n    vec2 gridPos15 = gridPos + vec2(14.0);\n    vec2 gridPos16 = gridPos + vec2(15.0);\n    vec2 gridPos17 = gridPos + vec2(16.0);\n    vec2 gridPos18 = gridPos + vec2(17.0);\n    vec2 gridPos19 = gridPos + vec2(18.0);\n    vec2 gridPos20 = gridPos + vec2(19.0);\n    vec2 gridPos21 = gridPos + vec2(20.0);\n    vec2 gridPos22 = gridPos + vec2(21.0);\n    vec2 gridPos23 = gridPos + vec2(22.0", "\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - len) / (len * 2.0);\n    float w = sin(a * 10.0 + time * 0.1) * 0.5 + 0.5;\n    return w * r;\n}\n\n// generates pixelated directional waves\nfloat", "\n    vec2 p = uv * gridRes;\n    vec2 q = vec2(p.x, p.y + time);\n    vec2 r = vec2(p.x + time, p.y);\n    vec2 s = vec2(p.x, p.y - time);\n    vec2 t = vec2(p.x - time, p.y);\n    vec2 u = vec2(p.x + time, p.y + time);\n    vec2 v = vec2(p.x - time, p.y - time);\n    vec2 w = vec2(p.x + time, p.y - time);\n    vec2 x = vec2(p.x - time, p.y + time);\n    vec2 y = vec2(p.x, p.y + time);\n    vec2 z = vec2(p.x, p.y - time);\n    vec2 a = vec2(p.x - time, p.y);\n    vec2 b = vec2(p.x, p.y - time);\n    vec2 c = vec2(p.x + time, p.y);\n    vec2 d = vec2(p.x, p.y);\n    vec2 e = vec2(p.x + time, p.y + time);\n    vec2 f = vec2(p.x - time, p.y + time);\n    vec2 g = vec2(p.x, p.y + time);\n    vec2 h = vec2(p.x - time, p.y);\n    vec2 i = vec2(p.x, p.y);\n    vec2 j = vec2(p.x + time, p.y - time);\n    vec2 k = vec2(p.x - time, p.y - time);\n    vec2 l = vec2(p.x, p.y - time);\n    vec2 m = vec2(p.x - time, p.y);\n    vec", "\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return u.x*(u.y*ddx.x+ddx.y) + u.y*(u.x*ddy.x+ddy.y);\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat", "\n    float c = cos(p.x * 3.1415926535897932384626433832795/3.0);\n    float s = sin(p.x * 3.1415926535897932384626433832795/3.0);\n    float t = (p.y - 0.5) * (p.y - 0.5) * 0.25;\n    return r * (1.0 + c * 0.5 + s * 0.5 + t);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p = mod(p, 2.0);\n    p -= sign(p);\n    return p;\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nfloat", "\n    return 0.50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return pow(t, vec3(1.0 / 2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return 0.5 * (1.0 - cos(p.x * 2.0 * PI)) * (1.0 - cos(p.y * 2.0 * PI));\n}\n\n// Classic truchet pattern\nfloat", "\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat", "\n    vec2 v0 = p1 - p0;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p0 - p2;\n\n    vec2 w0 = p - p0;\n    vec2 w1 = p - p1;\n    vec2 w2 = p - p2;\n\n    float d00 = dot(w0, w0);\n    float d01 = dot(w0, w1);\n    float d11 = dot(w1, w1);\n    float d20 = dot(w2, w0);\n    float d21 = dot(w2, w1);\n\n    float h00 = clamp( dot(v0, w0) / d00, 0.0, 1.0 );\n    float h10 = clamp( dot(v1, w0) / d00, 0.0, 1.0 );\n    float h01 = clamp( dot(v0, w1) / d01, 0.0, 1.0 );\n\n    float b = clamp( 1.0 - h00 - h10, 0.0, 1.0 );\n    float c = clamp( h00, 0.0, 1.0 );\n    float d = clamp( h10, 0.0, 1.0 );\n\n    float e = clamp( dot(v2, w0) / d00, 0.0, 1.0 );\n    float f = clamp( dot(v2, w1) / d01, 0.0, 1.0 );\n\n    float k0 = clamp( 1.0 - e - f, 0.0, 1.0 );\n    float k1 = clamp( e, 0.0, 1.0 );\n    float k2 = clamp( f, 0.0, 1.0 );\n\n    float d1 = clamp( dot(v1, w2) / d20, 0.0, 1.0 );\n    float d2 = clamp( dot(", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if(t < dbuffer) return t;\n    t = -b + h;\n    if(t < dbuffer) return t;\n    return -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat", "\n    vec2 q = p - vec2(clamp(p.x, 0.0, w), p.y);\n    return length(q) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    return length( p - vec2( k, 0.0 ) ) - k;\n}\n\n// k in (0,1) range\nfloat", "\n    vec2 q = vec2( 0.5, 0.5 );\n    p -= q;\n    return length( max( abs(p)-vec2(0.5), 0.0 ) );\n}\n\n// distance to y=1/x\nfloat", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n    return max(abs(a), k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat", "\n    vec2 q = vec2(length(p.xz), p.y);\n    return length(q - vec2(sin(q.x + q.y), cos(q.x + q.y))) * 0.01;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat", "\n    vec2 p = pos - A;\n    vec2 dp = B - A;\n    vec2 dp2 = C - B;\n    float k = dot( dp, dp );\n    float k2 = dot( dp2, dp2 );\n    float t = dot( p, dp ) / k;\n    float t2 = dot( p, dp2 ) / k2;\n    float t3 = t * t;\n    float t4 = t2 * t2;\n    float t5 = t3 * t2;\n    float t6 = t4 * t2;\n    float t7 = t5 * t2;\n    float t8 = t6 * t2;\n    float t9 = t7 * t2;\n    float t10 = t8 * t2;\n    float t11 = t9 * t2;\n    float t12 = t10 * t2;\n    float t13 = t11 * t2;\n    float t14 = t12 * t2;\n    float t15 = t13 * t2;\n    float t16 = t14 * t2;\n    float t17 = t15 * t2;\n    float t18 = t16 * t2;\n    float t19 = t17 * t2;\n    float t20 = t18 * t2;\n    float t21 = t19 * t2;\n    float t22 = t20 * t2;\n    float t23 = t21 * t2;\n    float t24 = t22 * t2;\n    float t25 = t23 * t2;\n    float t26 = t24 * t2;\n    float t27 = t25 * t2;\n    float t28 = t26 * t2;\n    float t29 = t27 * t2;\n    float t30 = t28 * t2;\n    float t31 = t29 * t2;\n    float t32 = t30 * t2;\n    float t33 = t31 * t", "\n    vec2 p = pos;\n    vec2 d = vec2(wi, he);\n    vec2 q = p - d;\n    vec2 r = p + d;\n    vec2 s = p - 2.0 * d;\n    vec2 t = p + 2.0 * d;\n    vec2 u = p - 3.0 * d;\n    vec2 v = p + 3.0 * d;\n    vec2 w = p - 4.0 * d;\n    vec2 x = p + 4.0 * d;\n    vec2 y = p - 5.0 * d;\n    vec2 z = p + 5.0 * d;\n    vec2 a = p - 6.0 * d;\n    vec2 b = p + 6.0 * d;\n    vec2 c = p - 7.0 * d;\n    vec2 dd = p + 7.0 * d;\n    vec2 e = p - 8.0 * d;\n    vec2 f = p + 8.0 * d;\n    vec2 g = p - 9.0 * d;\n    vec2 h = p + 9.0 * d;\n    vec2 i = p - 10.0 * d;\n    vec2 j = p + 10.0 * d;\n    vec2 k = p - 11.0 * d;\n    vec2 l = p + 11.0 * d;\n    vec2 m = p - 12.0 * d;\n    vec2 n = p + 12.0 * d;\n    vec2 o = p - 13.0 * d;\n    vec2 pn = p + 13.0 * d;\n    vec2 qq = p - 14.0 * d;\n    vec2 rr = p + 14.0 * d;\n    vec2 ss = p - 15.0 * d;\n    vec2 tt = p + 15.0 * d;\n    vec2 uu = p - 16.0", "\n    vec2 p = pos;\n    float a = k*k;\n    float b = 2.0*k;\n    float c = -1.0;\n    float d = p.x*p.x + p.y*p.y;\n    float e = (a*d - b*b)/(4.0*a);\n    float f = sqrt(abs(a*d - b*b - 4.0*a*c))/(2.0*a);\n    return vec3(e+f, e-f, 0.0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view", "\n    vec2 q = vec2(cos(d), sin(d)) * p;\n    vec2 r = vec2(cos(ra), sin(ra)) * p;\n    vec2 s = vec2(cos(rb), sin(rb)) * p;\n    return vec3(q.x, q.y, 0.0) - vec3(r.x, r.y, 0.0) - vec3(s.x, s.y, 0.0);\n}\n\n// 3D Sphere\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    v.x = (v.x << 13) ^ v.x;\n    v.x = (v.x * (v.x * v.x * 15731 + 789221) + 1376312589);\n    v.y = (v.y << 13) ^ v.y;\n    v.y = (v.y * (v.y * v.y * 15731 + 789221) + 1376312589);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg3(ivec2 v)\n{\n    v.x = (v.x << 13) ^ v.x;\n    v.x = (v.x * (v.x * v.x * 15731 + 789221) + 1376312589);\n    v.y = (v.y << 13) ^ v.y;\n    v.y = (v.y * (v.y * v.y * 15731 + 789221) + 1376312589);\n    v.x = (v.x << 13) ^ v.x;\n    v.x = (v.x * (v.x * v.x * 15731 + 789221) + 1376312589);\n    v.y = (v.y << 13) ^ v.y;\n    v.y = (v.y * (v.y * v.y * 15731 + 789221) + 1376312589);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2", "\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    return v;\n}\n\nivec3 Pcg4(ivec3 v)\n{\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    return v;\n}\n\nivec3 Pcg5(ivec3 v)\n{\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    return v;\n}\n\nivec3 Pcg6(ivec3 v)\n{\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.", "\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    float t = dot(p, ab) / dot(ab, ab);\n    if (t < 0.0) return length(p - A);\n    vec2 cp = p - ab * clamp(t, 0.0, 1.0);\n    float d = dot(cp, bc) / dot(bc, bc);\n    if (d < 0.0) return length(cp);\n    return length(p - C);\n}\n\n// signed distance to a cubic bezier\nfloat", "\n    return (p.x - a.x) * (p.y + b.y) - (p.y - a.y) * (p.x + b.x);\n}\n\n// Source: https://www.shadertoy.com/view/Xds3zK\nfloat", "\n    vec4 res = vec4( 1e10 );\n    vec3 d = abs(rd.xyz);\n    vec3 q = s.xyz - ro.xyz;\n    vec3 h = clamp( -q*d.yzx + s.yzx*d.xzy, 0.0, s.yzx*d.xzy );\n    vec3 t1 = q - h;\n    vec3 t2 = q - h.yzx;\n    float t0 = max( max( t1.x, t1.y ), t1.z ); \n    float t3 = min( min( t2.x, t2.y ), t2.z );\n    if( t0<t3 && t0<res.x )\n    {\n        res.x = t0;\n        res.yzw = normalize( vec4( t1.x>t1.y? -s.yzx : s.yzx, 0.0 ) );\n    }\n    if( t3>t0 && t3<res.y )\n    {\n        res.y = t3;\n        res.yzw = normalize( vec4( t2.x>t2.y? -s.yzx : s.yzx, 0.0 ) );\n    }\n    return res;\n}\n\n//------------------------------------------------------------------------------\n// iCylinder\n//\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = cylinder length and radius\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec", "\n  int a_i24 = a;\n  int b_i24 = int(b*1024.0);\n  int ret_i24 = a_i24*b_i24 + int(x*1024.0);\n  ret_n = ret_i24>>12;\n  return float(ret_i24) - float(ret_n)*1024.0;\n}\n\n// https://www.shadertoy.com/view/4dX3zS\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat", "\n    vec3 d = abs(a-b);\n    return vec3(\n        min(d.x, min(d.y, d.z)),\n        min(d.yz.x, min(d.yz.y, d.yz.z)),\n        min(d.yz.z, min(d.yz.y, d.yz.x))\n    ) / k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n    vec2 ap = p - ab;\n    float a = length(ap);\n    float b = length(ab);\n    float c = a + b;\n    float d = a - b;\n    float e = a * b;\n    float f = a * d;\n    float g = b * d;\n    float h = c * d;\n    float i = c * e;\n    float j = c * f;\n    float k = c * g;\n    float l = c * h;\n    float m = c * i;\n    float n = c * j;\n    float o = c * k;\n    float p = c * l;\n    float q = c * m;\n    float r = c * n;\n    float s = c * o;\n    float t = c * p;\n    float u = c * q;\n    float v = c * r;\n    float w = c * s;\n    float x = c * t;\n    float y = c * u;\n    float z = c * v;\n    float aa = a * a;\n    float bb = b * b;\n    float cc = c * c;\n    float dd = d * d;\n    float ee = e * e;\n    float ff = f * f;\n    float gg = g * g;\n    float hh = h * h;\n    float ii = i * i;\n    float jj = j * j;\n    float kk = k * k;\n    float ll = l * l;\n    float mm = m * m;\n    float nn = n * n;\n    float oo = o * o;\n    float pp = p * p;\n    float qq = q * q;\n    float rr = r * r;\n    float ss = s * s;\n    float tt = t * t;\n    float uu = u * u;\n    float vv = v * v;\n    float ww = w * w;\n    float xx = x * x;\n    float yy = y * y;\n    float zz = z * z;\n    float aaa = aa * aa;\n    float", "\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat", "\n    vec2 p1 = vec2( ab.x, ab.y - s1 );\n    vec2 p2 = vec2( ab.x, ab.y + s1 );\n    vec2 p3 = vec2( ab.x + s2, ab.y );\n    vec2 p4 = vec2( ab.x - s2, ab.y );\n\n    vec2 p5 = vec2( ab.x, ab.y - s1 );\n    vec2 p6 = vec2( ab.x, ab.y + s1 );\n    vec2 p7 = vec2( ab.x + s2, ab.y );\n    vec2 p8 = vec2( ab.x - s2, ab.y );\n\n    vec2 p9 = vec2( ab.x, ab.y - s1 );\n    vec2 p10 = vec2( ab.x, ab.y + s1 );\n    vec2 p11 = vec2( ab.x + s2, ab.y );\n    vec2 p12 = vec2( ab.x - s2, ab.y );\n\n    vec2 p13 = vec2( ab.x, ab.y - s1 );\n    vec2 p14 = vec2( ab.x, ab.y + s1 );\n    vec2 p15 = vec2( ab.x + s2, ab.y );\n    vec2 p16 = vec2( ab.x - s2, ab.y );\n\n    vec2 p17 = vec2( ab.x, ab.y - s1 );\n    vec2 p18 = vec2( ab.x, ab.y + s1 );\n    vec2 p19 = vec2( ab.x + s2, ab.y );\n    vec2 p20 = vec2( ab.x - s2, ab.y );\n\n    vec2 p21 = vec2( ab.x, ab.y - s1 );\n    vec2 p22 = vec2", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0.0)\n        return vec4(0.0);\n    if (t > 1.0)\n        return vec4(0.0);\n    vec3 cp = a + ab * t;\n    float d = length(cp - p);\n    if (d > rb)\n        return vec4(0.0);\n    if (d > ra)\n        return vec4(cp, 1.0);\n    return vec4(cp, 0.0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4djSRW\n// https://www.sh", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    return length(p-cen) - rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 normal = vec3( 0.0 );\n    if( showSurface )\n    {\n        normal = calcNormal( pos, samplePoint );\n    }\n    else\n    {\n        normal = calcNormal( pos, samplePoint + eps.xyy );\n        normal += calcNormal( pos, samplePoint + eps.yxy );\n        normal += calcNormal( pos, samplePoint + eps.yyx );\n        normal += calcNormal( pos, samplePoint + eps.yxy );\n        normal += calcNormal( pos, samplePoint + eps.yyx );\n        normal += calcNormal( pos, samplePoint + eps.xyy );\n        normal = normalize( normal );\n    }\n    return normal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec", "\n    float res = 1.0;\n    float t = 0.0;\n    float bias = 0.005;\n    float step = 0.001;\n    float maxDist = 100.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        float h = map( samplePoint );\n        if( h < bias )\n        {\n            res = 0.0;\n            break;\n        }\n        t += h;\n        samplePoint += rd * h;\n        if( t > maxDist )\n        {\n            res = 0.0;\n            break;\n        }\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat", "\n    vec2 q = abs(p);\n    vec2 d = vec2(ra, rb);\n    vec2 qq = q - d;\n    vec2 r = vec2(rb, ra);\n    vec2 qqr = q - r;\n    vec2 s = sign(q - d);\n    vec2 t = sign(q - r);\n    vec2 u = step(qq, vec2(0.0));\n    vec2 v = step(qqr, vec2(0.0));\n    vec2 w = sign(qqr);\n    vec2 ww = sign(qq);\n    vec2 wuv = mix(w, ww, u);\n    vec2 wvu = mix(w, wuv, v);\n    vec2 wuvw = mix(wuv, wvu, u);\n    vec2 wv = mix(wvu, wuvw, v);\n    vec2 wuvwv = mix(wuvw, wv, u);\n    vec2 wvw = mix(wvu, wuvwv, v);\n    vec2 wvwv = mix(wvw, wvwv, u);\n    vec2 wvwvu = mix(wvwv, wvwvu, u);\n    vec2 wvwvuw = mix(wvwvu, wvwvuw, u);\n    vec2 wvwvuwv = mix(wvwvuw, wvwvuwv, u);\n    vec2 wvwvuwvw = mix(wvwvuwv, wvwvuwvw, u);\n    vec2 wvwvuwvwv = mix(wvwvuwvw, wvwvuwvwv, u);\n    vec2 wvwvuwvwvw = mix(wvwvuwvwv, wvwvuwvwvw, u);\n    vec2 wvwvuwvwv", "\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    return vec4(length(q)-rb, 0.0, 0.0, 0.0);\n}\n\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4djSRW\n//https://www.shadertoy.com/view/4", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat", "\n    return dot(v, v);\n}\n\n// Rounded capsule https://iquilezles.org/articles/distfunctions/\nfloat", "\n    vec2 d = max( abs(p-minCorner) - (maxCorner-minCorner), 0.0 );\n    return dot(d,d);\n}\n\n// Returns the distance from the point to the closest point on the line\nfloat", "\n    vec3 waterColor = vec3(0.0, 0.0, 0.0);\n    vec3 waterNormal = vec3(0.0, 0.0, 0.0);\n    float waterHeight = 0.0;\n    float waterScale = 0.0;\n    float waterFrequency = 0.0;\n    float waterAmplitude = 0.0;\n    float waterPhase = 0.0;\n    float waterNoise = 0.0;\n    float waterNoise2 = 0.0;\n    float waterNoise3 = 0.0;\n    float waterNoise4 = 0.0;\n    float waterNoise5 = 0.0;\n    float waterNoise6 = 0.0;\n    float waterNoise7 = 0.0;\n    float waterNoise8 = 0.0;\n    float waterNoise9 = 0.0;\n    float waterNoise10 = 0.0;\n    float waterNoise11 = 0.0;\n    float waterNoise12 = 0.0;\n    float waterNoise13 = 0.0;\n    float waterNoise14 = 0.0;\n    float waterNoise15 = 0.0;\n    float waterNoise16 = 0.0;\n    float waterNoise17 = 0.0;\n    float waterNoise18 = 0.0;\n    float waterNoise19 = 0.0;\n    float waterNoise20 = 0.0;\n    float waterNoise21 = 0.0;\n    float waterNoise22 = 0.0;\n    float waterNoise23 = 0.0;\n    float waterNoise24 = 0.0;\n    float waterNoise25 = 0.0;\n    float waterNoise26 = 0.0;\n    float waterNoise27 = 0.0;\n    float waterNoise28 = 0.0;\n    float waterNoise29 = 0.0;\n    float waterNoise30 = 0.0;\n    float waterNoise31 = 0.0;\n    float waterNoise32 = 0.0;", "\n    vec3 ray = vec3(uv.xy, 1.0);\n    vec3 ray_dir = normalize(ray);\n    return ray_dir;\n}\n\n// Camera perspective based on [0..1] viewport\nvec", "\n    return vec3(\n        q.w * v.x + q.y * v.z - q.z * v.y,\n        q.w * v.y + q.z * v.x - q.x * v.z,\n        q.w * v.z + q.x * v.y - q.y * v.x\n    );\n}\n\n// Quaternion-vector multiplication\nvec", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec2 h = vec2( 0.5 ) - m;\n    vec2 w = abs( h ) - vec2( a );\n    return vec2( sign( h.x ) * sign( h.y ) * min( max( w.x, w.y ), 0.0 ) + m );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec", "\n    vec2 oc = ro - vec2(0.0, 0.0);\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float h = b * b - 4.0 * a * c;\n    if( h < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    h = sqrt( h );\n    float t = (-b - h) / (2.0 * a);\n    if( t < 0.0 )\n    {\n        t = (-b + h) / (2.0 * a);\n    }\n    if( t < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    vec2 pt = ro + t * rd;\n    p1 = vec4( pt, t );\n    p2 = vec4( pt, t + h / 2.0 );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCylinder( in vec2 ro, in vec2 rd, float rad, float h, out vec4 p1, out vec4 p2 )\n{\n    vec2 oc = ro - vec2(0.0, 0.0);\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float h2 = h * h;\n    float h4 = h2 * h2;\n    float D = b * b - 4.0 * a * c;\n    if( D < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    D", "\n  vec2 q = p - c;\n  return vec3( length(q) - r, dot(q, q) - r*r, 0.0 );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n  vec2 d = abs(p) - b;\n  return vec3(\n    min(max(d.x,d.y),0.0),\n    max(d.x,max(d.y,-b.y)),\n    max(d.y,d.x)\n  );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p - vec2( 0.5, 0.5 );\n    float d = length( q );\n    float a = atan( q.y, q.x );\n    float r = ( d - 0.02 ) / 0.08;\n    return vec3( r, 0.5 + 0.5 * cos( 6.28318 * a + r * 10.0 ), 0.5 + 0.5 * sin( 6.28318 * a + r * 10.0 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gjjjjjjjj\nfloat", "\n  float x2 = x * x;\n  float x4 = x2 * x2;\n  float x6 = x4 * x2;\n  float x8 = x6 * x2;\n  float x10 = x8 * x2;\n  float x12 = x10 * x2;\n  float x14 = x12 * x2;\n  float x16 = x14 * x2;\n  float x18 = x16 * x2;\n  float x20 = x18 * x2;\n  float x22 = x20 * x2;\n  float x24 = x22 * x2;\n  float x26 = x24 * x2;\n  float x28 = x26 * x2;\n  float x30 = x28 * x2;\n  float x32 = x30 * x2;\n  float x34 = x32 * x2;\n  float x36 = x34 * x2;\n  float x38 = x36 * x2;\n  float x40 = x38 * x2;\n  float x42 = x40 * x2;\n  float x44 = x42 * x2;\n  float x46 = x44 * x2;\n  float x48 = x46 * x2;\n  float x50 = x48 * x2;\n  float x52 = x50 * x2;\n  float x54 = x52 * x2;\n  float x56 = x54 * x2;\n  float x58 = x56 * x2;\n  float x60 = x58 * x2;\n  float x62 = x60 * x2;\n  float x64 = x62 * x2;\n  float x66 = x64 * x2;\n  float x68 = x66 * x2;\n  float x70 = x68 * x2;\n  float x72 = x70 * x2;\n  float x74 = x72 * x2;\n  float x7", "\n                float a = 1.0;\n                float b = 0.0;\n                float c = 0.0;\n                float d = 0.0;\n                float e = 0.0;\n                float f = 0.0;\n                float g = 0.0;\n                float h = 0.0;\n                float i = 0.0;\n                float j = 0.0;\n                float k = 0.0;\n                float l = 0.0;\n                float m = 0.0;\n                float n = 0.0;\n                float o = 0.0;\n                float p = 0.0;\n                float q = 0.0;\n                float r = 0.0;\n                float s = 0.0;\n                float t = 0.0;\n                float u = 0.0;\n                float v = 0.0;\n                float w = 0.0;\n                float x = 0.0;\n                float y = 0.0;\n                float z = 0.0;\n                float w1 = 0.0;\n                float w2 = 0.0;\n                float w3 = 0.0;\n                float w4 = 0.0;\n                float w5 = 0.0;\n                float w6 = 0.0;\n                float w7 = 0.0;\n                float w8 = 0.0;\n                float w9 = 0.0;\n                float w10 = 0.0;\n                float w11 = 0.0;\n                float w12 = 0.0;\n                float w13 = 0.0;\n                float w14 = 0.0;\n                float w15 = 0.0;\n                float w16 = 0.0;\n                float w17 = 0.0;\n                float w18 = 0.0;\n                float w19 = 0.0;\n                float w20 = 0.0;\n                float w21 = 0.0;\n                float w22 = 0.0;\n                float w23 = 0.0;\n                float w24 = 0.0;\n                float w25 = 0.0;\n                float w26 = 0.0;\n", "\n    vec3 color = vec3( 0.0 );\n    vec2 uv = vec2( x, y ) / vec2( 1024 );\n    vec2 p = uv;\n    float t = 0.0;\n    for ( int i = 0; i < 100; i++ )\n    {\n        p = p * 2.0 - 1.0;\n        p.x *= p.y;\n        t += length( p );\n    }\n    color = vec3( t );\n    return color;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / vec2( 1024 );\n    vec3 color = vec3( 0.0 );\n    for ( int y = 0; y < 1024; y++ )\n    {\n        for ( int x = 0; x < 1024; x++ )\n        {\n            color += compute( x, y );\n        }\n    }\n    color /= 1024.0 * 1024.0;\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 d = abs(p-c) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 ba = b - a;\n    vec2 bp = p - b;\n    vec2 r = ab * dot(ap, ba) / dot(ba, ba);\n    vec2 s = ab * dot(bp, ab) / dot(ab, ab);\n    float d2 = dot(r, r) + h * h - d2min;\n    if( d2 < 0.0 ) return vec2(0.0);\n    float d = sqrt(d2);\n    return vec2(d - h, d + h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n    float d = 0.0;\n    for( int i = 0; i < kType[0]; i++ )\n    {\n        vec2 a = vec2( kPath[i*2], kPath[i*2+1] );\n        vec2 b = vec2( kPath[i*2+2], kPath[i*2+3] );\n        d += sdLine( p, a, b );\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat", "\n    vec2 q = vec2( dot(p,p), -1.0 );\n    return dot(q,q) * 4.0 - 1.0;\n}\n\n// correct outside, incorrect inside\nfloat", "\n    vec2 q = p - vec2( 0.5 );\n    return length( q ) * sign( q.y );\n}\n\n// correct inside, incorrect outside\nfloat", "\n    vec3 color = vec3( 0.0 );\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length( p );\n    float a = atan( p.y, p.x ) / 3.1415926535897932384626433832795;\n    float r = mod( a, 1.0 );\n    float g = mod( a + 0.5, 1.0 );\n    float b = mod( a + 1.0, 1.0 );\n    color = mix( vec3( r, g, b ), vec3( b, g, r ), d );\n    return color;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = dot( pa, ba );\n    float d = dot( pa, pa );\n    float th2 = th * th;\n    if( h*h > d*th2 )\n    {\n        float t = h / d;\n        if( t < 0.0 )\n            t = 0.0;\n        else if( t > 1.0 )\n            t = 1.0;\n        return a + ba * t;\n    }\n    else\n    {\n        float t = sqrt( d*th2 - h*h ) / d;\n        if( t < 0.0 )\n            t = 0.0;\n        else if( t > 1.0 )\n            t = 1.0;\n        return a + ba * t;\n    }\n}\n\n// Distance from point to line segment\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to circle\nfloat", "\n    vec2 q = abs(p) - b;\n    return vec2(sign(q.x) * sign(q.y) * min(max(q.x,q.y),0.0), sign(q.x) * max(-q.y,0.0));\n}\n\n// closest point on rounded box\nvec", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat", "\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to circle\nfloat", "\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat", "\n    return fract(sin(dot(x, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// My take on the noise function\nfloat", "\n    return fract(sin(vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3))))*43758.5453);\n}\n\n// --------[ Original Noise v2 Components ]----------\n\n// Simplex 2D noise\nfloat", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(dot(grad3(i), f), dot(grad3(i+vec2(1,0)), f-vec2(1,0)), f.x),\n               mix(dot(grad3(i+vec2(0,1)), f-vec2(0,1)),\n                   dot(grad3(i+vec2(1,1)), f-vec2(1,1)), f.x), f.y);\n}\n\n// A 3D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 4D\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.02 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(p, p);\n    return mix(mix(n, n-1.0, f.x), mix(n, n-1.0, f.y), f.x);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat", "\n    float x2 = x * x;\n    float y2 = y * y;\n    return 1.0f / (x2 + y2 + 1.0f);\n}\n\nfloat", "\n    p3 = fract(p3 * vec3(12345.6789, 12345.6789, 12345.6789));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3(dot(p3, p3.yzx + 33.33), dot(p3, p3.yzx + 55.55), dot(p3, p3.yzx + 77.77)));\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat", "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(f.x, f.y, u.x), mix(f.z, f.w, u.x), u.y),\n               mix(mix(f.z, f.w, u.y), mix(f.x, f.y, u.y), u.z), u.x);\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat", "\n    return fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// for visualization purposes only\nfloat", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// This is the final form\nfloat", "\n    float a = dot(normal, normal);\n    float b = dot(center, normal);\n    float c = dot(center, center) - radius*radius;\n    float d = b*b - a*c;\n    if (d < 0.0) {\n        proj_center = vec2(0.0);\n        major = vec2(0.0);\n        minor = vec2(0.0);\n        return;\n    }\n    float sqrt_d = sqrt(d);\n    float e = sqrt_d - b;\n    float f = sqrt_d + b;\n    float g = a*e;\n    float h = a*f;\n    float i = c*e;\n    float j = c*f;\n    float k = sqrt_d*e;\n    float l = sqrt_d*f;\n    float m = sqrt_d*g;\n    float n = sqrt_d*h;\n    float o = sqrt_d*i;\n    float p = sqrt_d*j;\n    float q = sqrt_d*k;\n    float r = sqrt_d*l;\n    float s = sqrt_d*m;\n    float t = sqrt_d*n;\n    float u = sqrt_d*o;\n    float v = sqrt_d*p;\n    float w = sqrt_d*q;\n    float x = sqrt_d*r;\n    float y = sqrt_d*s;\n    float z = sqrt_d*t;\n    float aa = (g + h - i) / (2.0*a);\n    float bb = (h + i - k) / (2.0*a);\n    float cc = (i + k - l) / (2.0*a);\n    float dd = (k + l - m) / (2.0*a);\n    float ee = (l + m - n) / (2.0*a);\n    float ff = (m + n - o) / (2.0*a);\n    float gg = (n + o - p) / (", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    vec2 q = p - acs;\n    float d = dot(q, q);\n    if (d > r * r) return 0.0;\n    float a = acos(dot(q, acs) / sqrt(d));\n    float b = acos(dot(q, acs) / sqrt(d) - 1.0);\n    float s = (a - an) / (bn - an);\n    float t = (b - an) / (bn - an);\n    float c = (1.0 - s - t) * m;\n    float d1 = max(0.0, c - m);\n    float d2 = max(0.0, c);\n    return sqrt(d) - r + (d1 + d2) * 0.5;\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat", "\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        sdf( p + e.yxx ) - sdf( p - e.yxx ),\n        sdf( p + e.xyx ) - sdf( p - e.xyx ),\n        sdf( p + e.xxy ) - sdf( p - e.xxy ) ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec", "\n    float res = 1.0;\n    for (float t = t0; t < t1; t += SHADOW_STEP)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (d < SHADOW_EPSILON)\n        {\n            res = min(res, 1.0 - t / t1);\n        }\n        else if (d < SHADOW_DIST)\n        {\n            res = min(res, 1.0 - d / SHADOW_DIST);\n        }\n    }\n    return res;\n}\n\n// NOTE: This is a bit of a hack to get the shadow to work.\n//       The shadow is calculated by taking the distance to the surface\n//       and then subtracting it from the starting position.\n//       This is because the shadow is calculated from the starting position\n//       and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the shadow is calculated from the\n//       starting position and not the ray origin.\n//       This is a bit of a hack because the", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0f - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,\n        oc * axis.x * axis.y - axis.z * s,\n        oc * axis.z * axis.x + axis.y * s,\n\n        oc * axis.x * axis.y + axis.z * s,\n        oc * axis.y * axis.y + c,\n        oc * axis.y * axis.z - axis.x * s,\n\n        oc * axis.z * axis.x - axis.y * s,\n        oc * axis.y * axis.z + axis.x * s,\n        oc * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = cross(ww, uu);\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n    return ro + rd * 1.5;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat", "\n    return fract(sin(dot(p, vec3(127.1, 311.7, 255.4))) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 157.0)), f.x), mix(dot(p, vec3(113.0, 157.0, 113.0)), dot(p, vec3(157.0, 113.0, 113.0)), f.x), f.y), mix(mix(dot(p, vec3(57.0, 113.0, 157.0)), dot(p, vec3(113.0, 157.0, 57.0)), f.x), mix(dot(p, vec3(157.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 157.0)), f.x), f.z), f.z);\n}\n\n// 2D value noise\nfloat", "\n    float n = 0.0;\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    fp = fp*fp*(3.0-2.0*fp);\n    for(int j=0; j<3; j++){\n        n += dot(ip, vec3(j,j+1,j+2));\n        n += dot(ip+vec3(j+3,j+3,j+3), vec3(j,j,j+1));\n    }\n    return mix(mix(mix(n, n+1.0, fp.x), mix(n+1.0, n+2.0, fp.x), fp.y),\n               mix(mix(n+3.0, n+4.0, fp.x), mix(n+2.0, n+3.0, fp.x), fp.y), fp.z);\n}\n\n// 3D simplex noise, cool trick\nfloat", "\n    float fbm = fbm(p, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, ", "\n    vec2 XY;\n    float density = 0.0;\n    float color = 0.0;\n    float step = 0.0001;\n    float step2 = 0.00001;\n    float step3 = 0.000001;\n    float step4 = 0.0000001;\n    float step5 = 0.00000001;\n    float step6 = 0.000000001;\n    float step7 = 0.0000000001;\n    float step8 = 0.00000000001;\n    float step9 = 0.000000000001;\n    float step10 = 0.0000000000001;\n    float step11 = 0.00000000000001;\n    float step12 = 0.000000000000001;\n    float step13 = 0.0000000000000001;\n    float step14 = 0.00000000000000001;\n    float step15 = 0.000000000000000001;\n    float step16 = 0.0000000000000000001;\n    float step17 = 0.00000000000000000001;\n    float step18 = 0.000000000000000000001;\n    float step19 = 0.0000000000000000000001;\n    float step20 = 0.00000000000000000000001;\n    float step21 = 0.00000000000000000", "\n    vec3 color = vec3(0.0);\n    vec3 sunDir = normalize(vec3(0.0, 1.0, 0.0));\n    float sunCoverage = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage2 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage3 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage4 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage5 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage6 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage7 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage8 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage9 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage10 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage11 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage12 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage13 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage14 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage15 = clamp(dot(sunDir, point), 0.0, 1.0);\n    float sunCoverage16 = clamp(dot(sunDir, point), 0.0, 1.0", "\n    vec3 color = vec3(0.0);\n    vec3 ray = pointEnd - pointStart;\n    vec3 rayDir = normalize(ray);\n    vec3 rayPos = pointStart;\n    float rayLength = length(ray);\n    float rayLengthSq = rayLength * rayLength;\n    float rayLengthCubed = rayLengthSq * rayLength;\n    float rayLengthInv = 1.0 / rayLength;\n    float rayLengthInvSq = rayLengthInv * rayLengthInv;\n    float rayLengthInvCubed = rayLengthInvSq * rayLengthInv;\n    float rayLengthInvQuart = rayLengthInvSq * rayLengthInvSq;\n    float rayLengthInvQuint = rayLengthInvQuart * rayLengthInv;\n    float rayLengthInvSixth = rayLengthInvQuart * rayLengthInvSq;\n    float rayLengthInvEighth = rayLengthInvQuart * rayLengthInvQuart;\n    float rayLengthInvNinth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv;\n    float rayLengthInvTenth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv * rayLengthInv;\n    float rayLengthInvTwelfth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv * rayLengthInv * rayLengthInv;\n    float rayLengthInvThirteenth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv;\n    float rayLengthInvFourteenth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv;\n    float rayLengthInvFifteenth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv;\n    float rayLengthInvSixteenth = rayLengthInvQuart * rayLengthInvQuart * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv * rayLengthInv;\n    float rayLengthInvSeventeenth = rayLengthInvQuart * rayLengthInvQuart", "\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((color*(a*color+b))/(color*(c*color+d)+e), vec3(0.0), vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec"]}