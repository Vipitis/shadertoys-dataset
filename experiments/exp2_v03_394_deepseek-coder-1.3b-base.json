{"generations": ["\n    return 0.28209479177387814 * s.x * s.x * s.x;\n}\n\nfloat SH_0_1( in vec3 s ) {\n    return 1.4885158715151261 * s.x * s.y * s.y;\n}\n\nfloat SH_0_2( in vec3 s ) {\n    return 0.83146961230254523 * s.x * s.z * s.z;\n}\n\nfloat SH_0_3( in vec3 s ) {\n    return 0.041666666666666667 * s.y * s.z * s.z;\n}\n\nfloat SH_0_4( in vec3 s ) {\n    return 0.005971587301577414 * s.x * s.y * s.z;\n}\n\nfloat SH_0_5( in vec3 s ) {\n    return 0.0003488372335877366 * s.x * s.x * s.z * s.z;\n}\n\nfloat SH_0_6( in vec3 s ) {\n    return 0.0000342030158730158 * s.y * s.y * s.z * s.z;\n}\n\nfloat SH_0_7( in vec3 s ) {\n    return 0.00000134883723358774 * s.x * s.x * s.x * s.z * s.z;\n}\n\nfloat SH_0_8( in vec3 s ) {\n    return 0.00000002384185791016 * s.y * s.y * s.y * s.z * s.z;\n}\n\nfloat SH_0_", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle (can't get simpler than this)\nfloat circle( in vec2 a, in vec2 b, in vec2 p, in float r )\n{\n    return length( p - (a+b)*0.5 ) - r;\n}\n\n// distance to a rectangle (can't get simpler than this)\nfloat rect( in vec2 a, in vec2 b, in vec2 p, in vec2 r )\n{\n    vec2 d = abs(p-a) - r;\n    vec2 d2 = abs(p-b) - r;\n    return min(max(d.x,d.y),0.0) + max(max(d2.x,d2.y),0.0);\n}\n\n// distance to a triangle (can't get simpler than this)\nfloat triangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float d00 = dot(v0,v0);\n    float d01 = dot(v0,v1);\n    float d11 = dot(v1,v1);\n    float d20 = dot(v2,v0);\n    float d21 = dot(v2,v1);\n    float h = max(0.0,min(d00+d01,d00+d11)) - d00;\n    float s = max(0.0,min(d00+d20,d00+d21)) - d00;\n    return sqrt(max(0.0,h*h+s*s));\n}\n\n// distance to a triangle (can't get simpler than this)\nfloat triangle( in vec2 a, in vec2 b", "\n    return (dot(v, r) < 0.0)? -v : v;\n}\n\n// Flip v if in the positive half plane defined by r (this works in 3D too)\nvec2 flipIfPos( in vec2 v, in vec2 r )\n{\n    return (dot(v, r) > 0.0)? v : -v;\n}\n\n// Flip v if in the positive half plane defined by r (this works in 3D too)\nvec3 flipIfPos( in vec3 v, in vec3 r )\n{\n    return (dot(v, r) > 0.0)? v : -v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n    return (dot(v, r) < 0.0)? -v : v;\n}\n\n// Flip v if in the positive half plane defined by r (this works in 3D too)\nvec4 flipIfPos( in vec4 v, in vec4 r )\n{\n    return (dot(v, r) > 0.0)? v : -v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n    return (dot(v, r) < 0.0)? -v : v;\n}\n\n// Flip v if in the positive half plane defined by r (this works in 3D too)\nvec2 flipIfPos( in vec2 v, in vec2 r, in float epsilon )\n{\n    return (dot(v, r) > epsilon)? v : -v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in float epsilon )\n{\n    return (dot(v, r) < -epsilon)? -v : v;\n}\n\n// Flip", "\n    return ( dot( v, r ) < 0.0 )? -v : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return ( dot( v, r ) > 0.0 )? -v : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    return ( dot( v, r ) > 0.0 )? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return ( dot( v, r ) < 0.0 )? -v : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{\n    return ( dot( v, r ) > 0.0 )? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return ( dot( v, r ) < 0.0 )? -v : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r, in float t )\n{\n    return ( dot( v, r ) > 0.0 )? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float t )\n{\n    return ( dot( v, r ) < 0.0 )? -v : v;", "\n    if( dot( v, r ) < 0.0 )\n        return -v;\n    return v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    if( dot( v, r ) > 0.0 )\n        return v;\n    return -v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    if( dot( v, r ) > 0.0 )\n        return v;\n    return -v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n    if( dot( v, r ) < 0.0 )\n        return -v;\n    return v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    if( dot( v, r ) > 0.0 )\n        return v;\n    return -v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n    if( dot( v, r ) < 0.0 )\n        return -v;\n    return v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r, in float epsilon )\n{\n    if( dot( v, r ) > epsilon )\n        return v;\n    return -v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - w1 - w2;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdCapsule( in vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdCapsule( in vec2 p, vec2 a, vec2 b, float r, float w )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r - w;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdCapsule( in vec2 p, vec2 a, vec2 b, float r, float w1, float w2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r - w1 - w2;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdCapsule( in vec2 p, vec2 a, vec2 b, float r, float w1, float w2, float k )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h =", "\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 1.0);\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 1.0);\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 1.0);\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta)\n{\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta, float cosAlpha)\n{\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta, float cosAlpha, float cosBeta)\n{\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta, float cosAlpha, float cosBeta, float cosGamma)\n{\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta, float cosAlpha, float cosBeta, float cosGamma, float cosDelta)\n{\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta, float cosAlpha, float cosBeta, float cosGamma, float cosDelta, float cosEpsilon)\n{\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float cosTheta, float cosAlpha, float cosBeta, float cosGamma, float cosDelta, float cosEpsilon, float", "\n    vec4 a0 = p0;\n    vec4 a1 = p1;\n    vec4 a2 = p2;\n    vec4 a3 = p3;\n\n    vec4 b0 = a1;\n    vec4 b1 = a2;\n    vec4 b2 = a3;\n\n    vec4 c0 = (2.0 * a1) + (-a0 + a2);\n    vec4 c1 = (-a0 + (2.0 * a1)) + a2;\n    vec4 c2 = (a1 + (-2.0 * a2) + a3);\n    vec4 c3 = (a2 + (2.0 * a3));\n\n    vec4 d0 = (c0 * 0.5) + (c1 * 0.5);\n    vec4 d1 = (c1 * 0.5) + (c2 * 0.5);\n    vec4 d2 = (c2 * 0.5) + (c3 * 0.5);\n    vec4 d3 = (c3 * 0.5);\n\n    vec4 e0 = (d0 * 0.5) + (d1 * 0.5);\n    vec4 e1 = (d1 * 0.5) + (d2 * 0.5);\n    vec4 e2 = (d2 * 0.5) + (d3 * 0.5);\n    vec4 e3 = (d3 * 0.5);\n\n    vec4 f0 = (e0 * 0.5) + (e1 * 0.5);\n    vec4 f1 = (e1 * 0.5) + (e2 * 0.5);\n    vec4 f2 = (e2 * 0.5) + (e3 * 0.5);\n    vec4 f3 = (e3 * 0.5);\n\n    vec4 g0 = (f0 * 0.5) + (f1 * 0.5);\n    vec4 g1 = (f1 * 0.5", "\n\tfloat n = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat aw = 0.0;\n\tfloat ax = 0.0;\n\tfloat ay = 0.0;\n\tfloat az = 0.0;\n\tfloat ba = 0.0;\n\tfloat bb = 0.0;\n\tfloat bc = 0.0;", "\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p4 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p16 = vec4(0.0, 0.0, 0.0,", "\n    return fract(sin(u) * 43758.5453);\n}\n\nfloat Hash2d(vec2 u)\n{\n    return fract(sin(dot(u, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 u)\n{\n    return fract(sin(dot(u, vec3(12.9898, 78.233, 151.784))) * 43758.5453);\n}\n\nfloat Hash4d(vec4 u)\n{\n    return fract(sin(dot(u, vec4(12.9898, 78.233, 151.784, 12.9898))) * 43758.5453);\n}\n\nfloat Hash5d(vec5 u)\n{\n    return fract(sin(dot(u, vec5(12.9898, 78.233, 151.784, 12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash6d(vec6 u)\n{\n    return fract(sin(dot(u, vec6(12.9898, 78.233, 151.784, 12.9898, 78.233, 151.784))) * 43758.5453);\n}\n\nfloat Hash7d(vec7 u)\n{\n    return fract(sin(dot(u, vec7(12.9898, 78.233, 151.784, 12.9898, 78.233, 151.784, 12.9898))) * 43758.5453);\n}\n\n", "\n\tfloat n = 0.0;\n\tfloat f = 1.0;\n\tfloat a = 0.5;\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f2 = 0.0;\n\tfloat f3 = 0.0;\n\tfloat f4 = 0.0;\n\tfloat f5 = 0.0;\n\tfloat f6 = 0.0;\n\tfloat f7 = 0.0;\n\tfloat f8 = 0.0;\n\tfloat f9 = 0.0;\n\tfloat f10 = 0.0;\n\tfloat f11 = 0.0;\n\tfloat f12 = 0.0;\n\tfloat f13 = 0.0;\n\tfloat f14 = 0.0;\n\tfloat f15 = 0.0;\n\tfloat f16 = 0.0;\n\tfloat f17 = 0.0;\n\tfloat f18 = 0.0;\n\tfloat f19 = 0.0;\n\tfloat f20 = 0.0;\n\tfloat f21 = 0.0;\n\tfloat f22 = 0.0;\n\tfloat f23 = 0.0;\n\tfloat f24 = 0.0;\n\tfloat f25 = 0.0;\n\tfloat f26 = 0.0;\n\tfloat f27 = 0.0;\n\tfloat f28 = 0.0;\n\tfloat f29 = 0.0;\n\tfloat f30 = 0.0;\n\tfloat f31 = 0.0;\n\tfloat f32 = 0.0;\n\tfloat f33 = 0.0;\n\tfloat f34 = 0.0;\n\tfloat f35 = 0.0;\n\tfloat f36 = 0.0;\n\tfloat f37 = 0.0;\n\tfloat f38 = 0.0;\n\tfloat f39 = 0.0;\n\tfloat", "\n    vec3 q = p;\n    float d = 0.0;\n    float a = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d += a * max(0.0, 0.5 - length(q.yzx));\n        a *= 0.5;\n        mat2 m = mat2(cos(0.2 * d), -sin(0.2 * d), sin(0.2 * d), cos(0.2 * d));\n        q = mul(m, q);\n    }\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    vec3 q = p;\n    float d = 0.0;\n    float a = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d += a * max(0.0, 0.5 - length(q.yzx));\n        a *= 0.5;\n        mat2 m = mat2(cos(0.2 * d), -sin(0.2 * d), sin(0.2 * d), cos(0.2 * d));\n        q = mul(m, q);\n    }\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    vec3 q = p;\n    float d = 0.0;\n    float a = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d += a * max(0.0, 0.5 - length(q.yzx));\n        a *= 0.5;\n        mat2 m = mat2(cos(0.2 * d), -sin(0.2 * d), sin(0.2 * d), cos(0.2 * d));\n        q = mul(m, q);\n    }\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float lightRadius = 1.0;\n    float lightFalloff = 1.0;\n    float lightFalloff2 = 1.0;\n    float lightFalloff3 = 1.0;\n    float lightFalloff4 = 1.0;\n    float lightFalloff5 = 1.0;\n    float lightFalloff6 = 1.0;\n    float lightFalloff7 = 1.0;\n    float lightFalloff8 = 1.0;\n    float lightFalloff9 = 1.0;\n    float lightFalloff10 = 1.0;\n    float lightFalloff11 = 1.0;\n    float lightFalloff12 = 1.0;\n    float lightFalloff13 = 1.0;\n    float lightFalloff14 = 1.0;\n    float lightFalloff15 = 1.0;\n    float lightFalloff16 = 1.0;\n    float lightFalloff17 = 1.0;\n    float lightFalloff18 = 1.0;\n    float lightFalloff19 = 1.0;\n    float lightFalloff20 = 1.0;\n    float lightFalloff21 = 1.0;\n    float lightFalloff22 = 1.0;\n    float lightFalloff23 = 1.0;\n    float lightFalloff24 = 1.0;\n    float lightFalloff25 = 1.0;\n    float lightFalloff26 = 1.0;\n    float lightFalloff27 = 1.0;\n    float lightFalloff28 = 1.0;\n    float lightFalloff29 = 1.0;\n    float lightFalloff30 = 1.0;\n    float lightFalloff31 = 1", "\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth clamp (k = 0.1);\nfloat sclamp( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h );\n}\n\n// polynomial smooth mix (k = 0.1);\nfloat smix( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth mix (k = 0.1);\nfloat smix( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth mix (k = 0.1);\nfloat smix( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth mix (k = 0.1);\nfloat smix( float a, float b, float k )\n{\n    float h", "\n    vec3 L = spherePos - pos;\n    float tca = dot(L, dirVecPLZNormalizeMeFirst);\n    if (tca < 0.0) return -1.0;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > rad * rad) return -1.0;\n    float thc = sqrt(rad * rad - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    if (t0 < 0.0) t0 = t1;\n    if (t0 < 0.0) return -1.0;\n    return t0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, vec3 sphereRad)\n{\n    vec3 L = spherePos - pos;\n    float tca = dot(L, dirVecPLZNormalizeMeFirst);\n    if (tca < 0.0) return -1.0;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > sphereRad.x * sphereRad.x) return -1.0;\n    float thc = sqrt(sphereRad.x * sphereRad.x - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    if (t0 < 0.0) t0 = t1;\n    if (t0 < 0.0) return -1.0;\n    return t0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, vec3 sphereRad, float tMin, float tMax)\n{\n    vec3 L = spherePos - pos;\n    float tca = dot(L, dirVecPLZNormalizeMeFirst);\n    if (tca < 0.0) return -1.", "\n    vec2 d = vec2(0.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = length(q.xz) - 0.5;\n        r.y = abs(q.y) - 0.5;\n        r.z = 0.0;\n        q = q + r;\n        d = max(d, r);\n    }\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 d = vec2(0.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = length(q.xz) - 0.5;\n        r.y = abs(q.y) - 0.5;\n        r.z = 0.0;\n        q = q + r;\n        d = max(d, r);\n    }\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 d = vec2(0.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = length(q.xz) - 0.5;\n        r.y = abs(q.y) - 0.5;\n        r.z = 0.0;\n        q = q + r;\n        d = max(d, r);\n    }\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 d = vec2(0.0);\n    vec3 q = p;\n    for (int", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n    return", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (jerk)\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (snap)\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (bounce)\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (roll)\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (pitch)\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (yaw)\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (roll rate)\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (pitch rate)\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (yaw rate)\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (roll acceleration)\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}", "\n    return vec3(0.0);\n}\n\n// curve first derivative (velocity)\nvec3 mapD1(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (position)\nvec3 mapD0(float t)\n{\n    return vec3(0.0);\n}\n\n// curve second derivative (velocity)\nvec3 mapD3(float t)\n{\n    return vec3(0.0);\n}\n\n// curve second derivative (acceleration)\nvec3 mapD4(float t)\n{\n    return vec3(0.0);\n}\n\n// curve second derivative (position)\nvec3 mapD5(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (velocity)\nvec3 mapD6(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (acceleration)\nvec3 mapD7(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (position)\nvec3 mapD8(float t)\n{\n    return vec3(0.0);\n}\n\n// curve second derivative (velocity)\nvec3 mapD9(float t)\n{\n    return vec3(0.0);\n}\n\n// curve second derivative (acceleration)\nvec3 mapD10(float t)\n{\n    return vec3(0.0);\n}\n\n// curve second derivative (position)\nvec3 mapD11(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (velocity)\nvec3 mapD12(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (acceleration)\nvec3 mapD13(float t)\n{\n    return vec3(0.0);\n}\n\n// curve first derivative (position)\nvec3 mapD14(float t)\n{\n    return vec3(0.0);\n}\n", "\n    vec2 u = vec2( 0.0 );\n    vec2 v = vec2( 0.0 );\n    vec2 w = vec2( 0.0 );\n    vec2 uv = vec2( 0.0 );\n    vec2 wv = vec2( 0.0 );\n    vec2 uvw = vec2( 0.0 );\n    vec2 q = vec2( 0.0 );\n    vec2 r = vec2( 0.0 );\n    vec2 s = vec2( 0.0 );\n    vec2 t = vec2( 0.0 );\n    vec2 uv0 = vec2( 0.0 );\n    vec2 wv0 = vec2( 0.0 );\n    vec2 uv1 = vec2( 0.0 );\n    vec2 wv1 = vec2( 0.0 );\n    vec2 uvw0 = vec2( 0.0 );\n    vec2 wvw0 = vec2( 0.0 );\n    vec2 uvw1 = vec2( 0.0 );\n    vec2 wvw1 = vec2( 0.0 );\n    vec2 qr = vec2( 0.0 );\n    vec2 qs = vec2( 0.0 );\n    vec2 qt = vec2( 0.0 );\n    vec2 qr0 = vec2( 0.0 );\n    vec2 qs0 = vec2( 0.0 );\n    vec2 qt0 = vec2( 0.0 );\n    vec2 qr1 = vec2( 0.0 );\n    vec2 qs1 = vec2( 0.0 );\n    vec2 qt1 = vec2( 0.0 );\n    vec2 qr2 = vec2( 0.0 );\n    vec2 qs2 = vec2( 0.0 );\n    vec2", "\n    vec2 res;\n    vec3 ab = b - a;\n    vec3 oc = o - a;\n    vec3 ad = d - a;\n    float aDotD = dot( ab, ad );\n    float bDotD = dot( ab, oc );\n    if( aDotD == 0.0 )\n    {\n        res.x = length( oc );\n        res.y = 0.0;\n    }\n    else\n    {\n        float s = bDotD / aDotD;\n        if( s < 0.0 )\n        {\n            res.x = length( oc );\n            res.y = 0.0;\n        }\n        else if( s > 1.0 )\n        {\n            res.x = length( oc - ab );\n            res.y = 0.0;\n        }\n        else\n        {\n            res.x = length( oc - ab * s );\n            res.y = s;\n        }\n    }\n    return res;\n}\n\n// signed squared distance between ray and segment\nvec2 ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 res;\n    vec3 ab = b - a;\n    vec3 oc = o - a;\n    vec3 ad = d - a;\n    float aDotD = dot( ab, ad );\n    float bDotD = dot( ab, oc );\n    if( aDotD == 0.0 )\n    {\n        res.x = length( oc );\n        res.y = 0.0;\n    }\n    else\n    {\n        float s = bDotD / aDotD;\n        if( s < 0.0 )\n        {\n            res.x = length( oc );\n            res.y = 0.0;\n        }\n        else if( s > 1.0 )\n        {\n            res.x = length( oc - ab );\n            res.y = 0.0;\n        }\n        else\n        {\n            res.x = length( oc - ab * s );\n            res", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - b.x - b.y + r.x + r.y + r.z + r.w;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundRect( in vec2 p, in vec2 b, in vec4 r ) \n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - b.x - b.y + r.x + r.y + r.z + r.w;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundTriangle( in vec2 p, in vec2 b, in vec4 r ) \n{\n    vec2 q = vec2(b.x, -b.y);\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - b.x - b.y + r.x + r.y + r.z + r.w;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundRhombus( in vec2 p, in vec2 b, in vec4 r ) \n{\n    vec2", "\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 1.0);\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n    float cosTheta = dot(rayDir, sunDir);\n    float cosAlpha = pow(cosTheta, 1.0);\n    return sunCol * cosAlpha;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n    return GetSunColorReflection(rayDir, sunDir);\n}\n\nvec3 GetSunColor(vec3 rayDir)\n{\n    return GetSunColorReflection(rayDir, sunDir);\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, vec3 sunColor)\n{\n    return sunColor;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, vec3 sunColor, vec3 sunColor2)\n{\n    return sunColor2;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, vec3 sunColor, vec3 sunColor2, vec3 sunColor3)\n{\n    return sunColor3;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, vec3 sunColor, vec3 sunColor2, vec3 sunColor3, vec3 sunColor4)\n{\n    return sunColor4;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, vec3 sunColor, vec3 sunColor2, vec3 sunColor3, vec3 sunColor4, vec3 sunColor5)\n{\n    return sunColor5;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, vec3 sunColor, vec3 sunColor2, vec3 sunColor3, vec3 sunColor4, vec3 sunColor5, vec3 sunColor6)\n{\n    return sunColor6;\n}\n\nvec3 GetSunColor(vec3 rayDir,", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0)));\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This is the function that actually does the ray tracing.\n// It basically takes in the ray direction and the eye position and returns\n// the color of the ray.\nvec3 rayTrace( in vec3 ro, in vec3 rd )\n{\n    // This is the color that we will return.\n    vec3 col = vec3(0.0);\n\n    // This is the distance from the ray origin to the first object.\n    float t = 0.0;\n\n    // This is the distance from the ray origin to the second object.\n    float t2 = 0.0;\n\n    // This is the distance from the ray origin to the third object.\n    float t3 = 0.0;\n\n    // This is the distance from the ray origin to the fourth object.\n    float t4 = 0.0;\n\n    // This is the distance from the ray origin to the fifth object.\n    float t5 = 0.0;\n\n    // This is the distance from the ray origin to the sixth object.\n    float t6 = 0.0;\n\n    // This is the distance from the ray origin to the seventh object.\n    float t7 = 0.0;\n\n    // This is the distance from the ray origin to the eighth object.\n    float t8 = 0.0;\n\n    // This is the distance from the ray origin to the ninth object.\n    float t9 = 0.0;\n\n    // This is the distance from the ray origin to the tenth object.\n    float t10 = 0.0;\n\n    // This is the distance from the ray origin to the eleventh object.\n    float t11 = 0.0;\n\n    // This is the distance from the ray origin to the twelfth object.\n    float t12 = 0.0;\n\n    // This is the distance from the ray origin to the", "\n    vec2 balloon = vec2( 0.0 );\n    float balloonRadius = 0.005;\n    float balloonHeight = 0.005;\n    float balloonWidth = 0.005;\n    float balloonDepth = 0.005;\n    float balloonX = currentRayPosition.x;\n    float balloonY = currentRayPosition.y;\n    float balloonZ = currentRayPosition.z;\n    float balloonX2 = balloonX - balloonRadius;\n    float balloonY2 = balloonY - balloonHeight;\n    float balloonZ2 = balloonZ - balloonDepth;\n    float balloonX3 = balloonX + balloonRadius;\n    float balloonY3 = balloonY + balloonHeight;\n    float balloonZ3 = balloonZ + balloonDepth;\n    float balloonX4 = balloonX - balloonWidth;\n    float balloonY4 = balloonY - balloonWidth;\n    float balloonZ4 = balloonZ - balloonWidth;\n    float balloonX5 = balloonX + balloonWidth;\n    float balloonY5 = balloonY + balloonWidth;\n    float balloonZ5 = balloonZ + balloonWidth;\n    float balloonX6 = balloonX - balloonDepth;\n    float balloonY6 = balloonY - balloonDepth;\n    float balloonZ6 = balloonZ + balloonDepth;\n    float balloonX7 = balloonX + balloonDepth;\n    float balloonY7 = balloonY + balloonDepth;\n    float balloonZ7 = balloonZ - balloonDepth;\n    float balloonX8 = balloonX - balloonWidth;\n    float balloonY8 = balloonY - balloonWidth;\n    float balloonZ8 = balloonZ + balloonWidth;\n    float balloonX9 = balloonX + balloonWidth;\n    float balloonY9 = balloonY + balloonWidth;\n    float balloonZ9 = balloonZ - balloonWidth;\n    float balloonX10 = balloonX - ball", "\n    // 'THING1' is the thing we are looking at\n    // 'THING2' is the thing we are comparing to\n    // 'DISTANCE' is the distance between the two things\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second thing\n    // 'THING1_DISTANCE' is the distance between the thing we are looking at and the first thing\n    // 'THING2_DISTANCE' is the distance between the thing we are looking at and the second", "\n    vec2 closestThing = vec2( 1000000.0 );\n    vec2 closestThingPosition = vec2( 0.0 );\n    vec2 closestThingNormal = vec2( 0.0 );\n    vec2 closestThingTexture = vec2( 0.0 );\n    vec2 closestThingSpecular = vec2( 0.0 );\n    vec2 closestThingShininess = vec2( 0.0 );\n    vec2 closestThingReflectivity = vec2( 0.0 );\n    vec2 closestThingTransparency = vec2( 0.0 );\n    vec2 closestThingRefractiveIndex = vec2( 0.0 );\n    vec2 closestThingAmbient = vec2( 0.0 );\n    vec2 closestThingDiffuse = vec2( 0.0 );\n    vec2 closestThingSpecular = vec2( 0.0 );\n    vec2 closestThingShininess = vec2( 0.0 );\n    vec2 closestThingReflectivity = vec2( 0.0 );\n    vec2 closestThingTransparency = vec2( 0.0 );\n    vec2 closestThingRefractiveIndex = vec2( 0.0 );\n    vec2 closestThingAmbient = vec2( 0.0 );\n    vec2 closestThingDiffuse = vec2( 0.0 );\n    vec2 closestThingSpecular = vec2( 0.0 );\n    vec2 closestThingShininess = vec2( 0.0 );\n    vec2 closestThingReflectivity = vec2( 0.0 );\n    vec2 closestThingTransparency = vec2( 0.0 );\n    vec2 closestThingRefractiveIndex = vec2( 0.0 );\n    vec2 closestThingAmbient = vec2( 0.0 );\n    vec2 closestThingDiffuse = vec2( 0.0", "\n    vec3 normal = vec3(0.0);\n    vec3 samplePosition = positionOfHit;\n    float delta = 0.0001;\n    float sampleDistance = 0.0;\n    for( int i = 0; i < 3; i++ ){\n        samplePosition[i] += delta;\n        sampleDistance = getDistanceOfSurface( samplePosition );\n        samplePosition[i] -= delta;\n        normal[i] = ( sampleDistance - getDistanceOfSurface( positionOfHit ) ) / delta;\n    }\n    return normalize( normal );\n}\n\n// This is the main function that is called to get the color\n// of the surface.\nvec3 getColorOfSurface( in vec3 positionOfHit ){\n    vec3 color = vec3(0.0);\n    vec3 normal = getNormalOfSurface( positionOfHit );\n    vec3 lightDirection = normalize( vec3(0.0, 0.0, 1.0) );\n    float diffuse = max( dot( normal, lightDirection ), 0.0 );\n    vec3 reflectedLightDirection = reflect( -lightDirection, normal );\n    float specular = pow( max( dot( reflectedLightDirection, normalize( vec3(0.0, 0.0, 1.0) ) ), 0.0 ), 10.0 );\n    color = vec3( diffuse, diffuse, diffuse ) * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * specular;\n    return color;\n}\n\n// This is the main function that is called to get the color\n// of the surface.\nvec3 getColorOfSurface( in vec3 positionOfHit ){\n    vec3 color = vec3(0.0);\n    vec3 normal = getNormalOfSurface( positionOfHit );\n    vec3 lightDirection = normalize( vec3(0.0, 0.0, 1.0) );\n    float diffuse = max( dot( normal, lightDirection ), 0", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// this is the main function that does the actual rendering.\n// it takes in the ray, the camera, and the scene as input.\n// it returns the color of the pixel.\nvec3 render(vec3 ray, vec3 camera, vec3 scene){\n    // this is the color of the pixel.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    // this is the ray direction.\n    vec3 rayDirection = normalize(ray - camera);\n\n    // this is the ray origin.\n    vec3 rayOrigin = camera;\n\n    // this is the distance from the camera to the ray origin.\n    float distance = length(rayOrigin - camera);\n\n    // this is the ray direction.\n    vec3 rayDirection = normalize(ray - camera);\n\n    // this is the ray origin.\n    vec3 rayOrigin = camera;\n\n    // this is the distance from the camera to the ray origin.\n    float distance = length(rayOrigin - camera);\n\n    // this is the ray direction.\n    vec3 rayDirection = normalize(ray - camera);\n\n    // this is the ray origin.\n    vec3 rayOrigin = camera;\n\n    // this is the distance from the camera to the ray origin.\n    float distance = length(rayOrigin - camera);\n\n    // this is the ray direction.\n    vec3 rayDirection = normalize(ray - camera);\n\n    // this is the ray origin.\n    vec3 rayOrigin = camera;\n\n    // this is the distance from the camera to the ray origin.\n    float distance = length(rayOrigin - camera);\n\n    // this is the ray direction.\n    vec3 rayDirection = normalize(ray - camera);\n\n    // this is the ray origin.\n    vec3 rayOrigin = camera;\n\n    // this is the distance from the camera to the ray origin.\n    float distance = length(rayOrigin - camera);\n\n    // this is the ray direction.\n    vec3 rayDirection = normalize(ray - camera);\n\n   ", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float diffuse = max(dot(normalOfSurface, lightDir), 0.0);\n    color = lightColor * diffuse;\n    return color;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\nvec3 doSphereColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float diffuse = max(dot(normalOfSurface, lightDir), 0.0);\n    color = lightColor * diffuse;\n    return color;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\nvec3 doCylinderColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float diffuse = max(dot(normalOfSurface, lightDir), 0.0);\n    color = lightColor * diffuse;\n    return color;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\nvec3 doConeColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.", "\n    // We will use the rayHitInfo to determine what color we want to return\n    // We will use the eyePosition to determine what color we want to return\n    // We will use the rayDirection to determine what color we want to return\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec3 color\n    // We will return a vec", "\n  return abs(x * 2.0 - 1.0) - b;\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n  return abs(x * 2.0 - 1.0) - b;\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n  return abs(x * 2.0 - 1.0) - b;\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n  return abs(x * 2.0 - 1.0) - b;\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n  return abs(x * 2.0 - 1.0) - b;\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if", "\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x coordinate\nfloat noise(float x){\n    return fract(sin(x)*43758.5453);\n}\n\n// creates a noise function that is a function of the x and y coordinates\nfloat noise(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x, y, and z coordinates\nfloat noise(vec3 p){\n    return fract(sin(dot(p,vec3(127.1,311.7,19.8)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x, y, z, and w coordinates\nfloat noise(vec4 p){\n    return fract(sin(dot(p,vec4(127.1,311.7,19.8,7.2)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x, y, z, w, and t coordinates\nfloat noise(vec4 p){\n    return fract(sin(dot(p,vec4(127.1,311.7,19.8,7.2,15.6)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x, y, z, w, t, and u coordinates\nfloat noise(vec4 p){\n    return fract(sin(dot(p,vec4(127.1,311.7,19.8,7.2,15.6,23.1)))*43758.5453);\n}\n\n// creates a noise function that is a function of the x, y, z, w, t, u, and v coordinates\nfloat noise(", "\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_inclusive_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_inclusive_exclusive_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_inclusive_exclusive_exclusive_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// creates white noise in the range 0", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input p --> is point\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input p --> is point\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to cylinder radius and height\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = vec2(length(p.xz) - r, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input p --> is point\n// input r --> is cone radius\n// input h --> is cone height\n// pretty simple, just compare point to cone radius and height\nfloat sdCone(vec3 p, float r, float h)\n{\n    vec2 d = vec2(length(p.xz) - r, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input p --> is point\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to cylinder radius and height\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = vec2(length(p.xz) - r, abs(p.y) - h);\n    return min(max(d.x, d.y),", "\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for torus caps\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorusCap(vec3 p, vec2 t, float r)\n{\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\tfloat d = length(q)-t.y;\n\tif(d<r)\n\t\treturn d;\n\treturn length(q.xz)-r;\n}\n\n// ~~~~~~~ signed distance function for torus caps\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorusCap(vec3 p, vec2 t, float r, float h)\n{\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\tfloat d = length(q)-t.y;\n\tif(d<r)\n\t\treturn d;\n\tfloat d2 = length(q.xz)-r;\n\tif(d2<h)\n\t\treturn d2;\n\treturn length(q.xz)-r;\n}\n\n// ~~~~~~~ signed distance function for torus caps\n// input t", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/(d2+d1), 0.0, 1.0 );\n    return mix( d2, d1, h ) - 0.001*h*h*h*h*h;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2)\n{\n    float h = clamp( 0.5 - 0.5*(d1-d2)/(d1+d2), 0.0, 1.0 );\n    return mix( d1, d2, h ) + 0.001*h*h*h*h*h;\n}\n\n// ~~~~~~~ smooth step function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat sstep( float d1, float d2)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/(d2+d1), 0.0, 1.0 );\n    return mix( 0.0, 1.0, h ) - 0.001*h*h*h*h*h;\n}\n\n// ~~~~~~~ smooth clamp function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat sclamp( float d1, float d2)\n", "\n  return 1.0 - smoothstep(0.0, 1.0, d1);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k)\n{\n  return 1.0 - smoothstep(0.0, 1.0, d1);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float k2)\n{\n  return 1.0 - smoothstep(0.0, 1.0, d1);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float k2, float k3)\n{\n  return 1.0 - smoothstep(0.0, 1.0, d1);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float k2, float k3, float k4)\n{\n  return 1.0 - smoothstep(0.0, 1.0, d1);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float k2, float k3, float k4, float k5", "\n    vec3 q = p;\n    float s = sin(yaw);\n    float c = cos(yaw);\n    q.xz = mat2(c,s,-s,c)*q.xz;\n    q.xy = mat2(c,-s,s,c)*q.xy;\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t )\n{\n    return opTwist(p,t,0.0);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float roll )\n{\n    vec3 q = p;\n    float s = sin(yaw);\n    float c = cos(yaw);\n    q.xz = mat3(c,s,-s,c,0.0,1.0)*q.xz;\n    q.xy = mat3(c,-s,s,c,0.0,1.0)*q.xy;\n    s = sin(roll);\n    c = cos(roll);\n    q.xz = mat3(1.0,0.0,0.0,0.0,c,-s)*q.xz;\n    q.xy = mat3(1.0,0.0,0.0,0.0,c,s)*q.xy;\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( ve", "\n    if(o1.x < o2.x) return o1;\n    else return o2;\n}\n\n// ~~~~~~~ do Intersection / find the closest object\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x) return o2;\n    else return o1;\n}\n\n// ~~~~~~~ do Subtraction / find the closest object\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x) return o1;\n    else return -o2;\n}\n\n// ~~~~~~~ do Subtraction / find the closest object\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opA(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x) return -o1;\n    else return o2;\n}\n\n// ~~~~~~~ do Subtraction / find the closest object\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opO(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x) return o1;\n    else return -o2;\n}\n\n// ~~~~~~~ do Subtraction / find the closest object\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opN(vec2 o1, vec2 o2)\n{\n    if(o1.x < o", "\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n    // ~~~~~~~\n   ", "\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat t = 0.0;\n\tfloat tmin_id = -1.0;\n\tfloat tmax_id = -1.0;\n\tfloat tmin_dist = tmax;\n\tfloat tmax_dist = tmin;\n\tfloat tmin_dist_id = tmax_id;\n\tfloat tmax_dist_id = tmin_id;\n\tfloat tmin_dist_id_dist = tmax_dist_id;\n\tfloat tmax_dist_id_dist = tmin_dist_id;\n\tfloat tmin_dist_id_dist_dist = tmax_dist_id_dist;\n\tfloat tmax_dist_id_dist_dist = tmin_dist_id_dist_dist;\n\tfloat tmin_dist_id_dist_dist_dist = tmax_dist_id_dist_dist;\n\tfloat tmax_dist_id_dist_dist_dist = tmin_dist_id_dist_dist_dist;\n\tfloat tmin_dist_id_dist_dist_dist_dist = tmax_dist_id_dist_dist_dist;\n\tfloat tmax_dist_id_dist_dist_dist_dist = tmin_dist_id_dist_dist_dist_dist;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist = tmax_dist_id_dist_dist_dist_dist;\n\tfloat tmax_dist_id_dist_dist_dist_dist_dist = tmin_dist_id_dist_dist_dist_dist_dist;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist_dist = tmax_dist_id_dist_dist_dist_dist_dist;\n\tfloat tmax_dist_id_dist_dist_dist_dist_dist_dist = tmin_dist_id_dist_dist_dist_dist_dist_dist;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist_dist_dist = tmax_dist_id_dist_dist_dist_dist_dist_dist", "\n    // raymarching\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dmin = 1000000.0;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        // find closest surface\n        d = map(p);\n        if (d < dmin)\n        {\n            dmin = d;\n            color = vec3(0.0);\n        }\n        // update ray\n        p = ro + rd * t;\n        t += d;\n        // check if ray is outside of scene\n        if (t > 1000.0)\n        {\n            break;\n        }\n    }\n    // apply color\n    return color;\n}\n\n// ~~~~~~~ main --> render scene\nvoid main()\n{\n    // camera\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    // render scene\n    vec3 color = render(ro, rd);\n    // output\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 right = normalize( cross( vec3( 0.0, 1.0, 0.0 ), camDir ) );\n    vec3 up = cross( camDir, right );\n    return mat3( right, up, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 right = normalize( cross( vec3( 0.0, 1.0, 0.0 ), camDir ) );\n    vec3 up = cross( camDir, right );\n    return mat3( right, up, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 right = normalize( cross( vec3( 0.0, 1.0, 0.0 ), camDir ) );\n    vec3 up = cross( camDir, right );\n    return mat3( right, up, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 right", "\n    if (id == 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    else if (id == 1.0)\n        return vec3(1.0, 0.0, 0.0);\n    else if (id == 2.0)\n        return vec3(0.0, 1.0, 0.0);\n    else if (id == 3.0)\n        return vec3(0.0, 0.0, 1.0);\n    else if (id == 4.0)\n        return vec3(1.0, 1.0, 0.0);\n    else if (id == 5.0)\n        return vec3(1.0, 0.0, 1.0);\n    else if (id == 6.0)\n        return vec3(0.0, 1.0, 1.0);\n    else if (id == 7.0)\n        return vec3(1.0, 1.0, 1.0);\n    else\n        return vec3(0.0, 0.0, 0.0);\n}\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(int id)\n{\n    if (id == 0)\n        return vec3(0.0, 0.0, 0.0);\n    else if (id == 1)\n        return vec3(1.0, 0.0, 0.0);\n    else if (id == 2)\n        return vec3(0.0, 1.0, 0.0);\n    else if (id == 3)\n        return vec3(0.0, 0.0, 1.0);\n    else if (id == 4)\n        return vec3(1.0, 1.0, 0.0", "\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for torus caps\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  t.z = torus radius\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorusCap(vec3 p, vec3 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for torus caps\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  t.z = torus radius\n//  t.w = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorusCap(vec4 p, vec4 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for torus caps\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  t.z = torus radius\n//  t.w = torus thickness\n// ", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> center\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdSphere(vec3 p)\n{\n    return length(p.xz) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> center\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdCylinder(vec3 p)\n{\n    vec2 q = vec2(length(p.xz) - ps.x, p.y);\n    return q.y;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> center\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdCone(vec3 p)\n{\n    vec2 q = vec2(length(p.xz) - ps.x, p.y);\n    return length(q.yx) - ps.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> center\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdCapsule(vec3 p)\n{\n    vec2 q = vec2(length(p.xz) - ps.x, p.y);\n    return length(max(q, -q.y)) - ps.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps", "\n    float h = clamp( 0.5 + 0.5*(d2/d1-1.0), 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d1/d2+1.0), 0.0, 1.0 );\n    return mix( d1, d2, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth step function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input x --> distance value of object a\n// input y --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat sstep( float x, float y, float k)\n{\n    float h = clamp( 0.5 + 0.5*(x/y-1.0), 0.0, 1.0 );\n    return mix( y, x, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth clamp function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input x --> distance value of object a\n// input y --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat sclamp( float x, float y, float k)\n{\n    float h = clamp( 0.", "\n    vec4 o;\n    o.x = mix(o1.x, o2.x, bf);\n    o.y = mix(o1.y, o2.y, bf);\n    o.z = mix(o1.z, o2.z, bf);\n    o.w = mix(o1.w, o2.w, bf);\n    return o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 o;\n    o.x = mix(o1.x, o2.x, bf);\n    o.y = mix(o1.y, o2.y, bf);\n    o.z = mix(o1.z, o2.z, bf);\n    o.w = mix(o1.w, o2.w, bf);\n    return o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 o;\n    o.x = mix(o1.x, o2.x, bf);\n    o.y = mix(o1.y, o2.y, bf);\n    o.z = mix(o1.z, o2.z, bf);\n    o.w = mix(o1.w", "\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of", "\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.y = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.z = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos2()\n{\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.y = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.z = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos3()\n{\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.y = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    lightPos.z = (2.0 * rand(gl_FragCoord.xy) - 1.0) * 10.0;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos4()\n{\n    vec3 lightPos =", "\n    // 1. find the closest object\n    // 2. move the object by messing with p\n    // 3. return the blended color\n    // 4. return the distance\n    // 5. return the color\n    // 6. return the distance\n    // 7. return the color\n    // 8. return the distance\n    // 9. return the color\n    // 10. return the distance\n    // 11. return the color\n    // 12. return the distance\n    // 13. return the color\n    // 14. return the distance\n    // 15. return the color\n    // 16. return the distance\n    // 17. return the color\n    // 18. return the distance\n    // 19. return the color\n    // 20. return the distance\n    // 21. return the color\n    // 22. return the distance\n    // 23. return the color\n    // 24. return the distance\n    // 25. return the color\n    // 26. return the distance\n    // 27. return the color\n    // 28. return the distance\n    // 29. return the color\n    // 30. return the distance\n    // 31. return the color\n    // 32. return the distance\n    // 33. return the color\n    // 34. return the distance\n    // 35. return the color\n    // 36. return the distance\n    // 37. return the color\n    // 38. return the distance\n    // 39. return the color\n    // 40. return the distance\n    // 41. return the color\n    // 42. return the distance\n    // 43. return the color\n    // 44. return the distance\n    // 45. return the color\n    // 46. return the distance\n    // 47. return the color\n    // 48. return the distance\n    // 49. return the color\n    // 50. return the distance\n    // 51. return the color\n    //", "\n    // ray origin\n    // ray direction\n    // ray step\n    // ray length\n    // ray hit\n    // ray hit object\n    // ray hit distance\n    // ray hit normal\n    // ray hit position\n    // ray hit color\n    // ray hit material\n    // ray hit material color\n    // ray hit material normal\n    // ray hit material position\n    // ray hit material id\n    // ray hit material type\n    // ray hit material texture\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n    // ray hit material texture coord\n", "\n    // 1.0 is the maximum distance to the light\n    float maxDist = 1.0;\n    // 0.001 is the minimum distance to the light\n    float minDist = 0.001;\n    // 100 is the number of samples\n    float numSamples = 100;\n    // 0.001 is the step size\n    float stepSize = 0.001;\n    // 0.0 is the initial distance\n    float currDist = 0.0;\n    // 0.0 is the initial bias\n    float bias = 0.0;\n    // 0.0 is the initial shadow\n    float shadow = 0.0;\n    // 0.0 is the initial attenuation\n    float atten = 1.0;\n    // 0.0 is the initial attenuation\n    float atten2 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten3 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten4 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten5 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten6 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten7 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten8 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten9 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten10 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten11 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten12 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten13 = 1.0;\n    // 0.0 is the initial attenuation\n    float atten14 = 1.0;\n    // 0.0 is the initial", "\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float occ = 0.0;\n    float bias = 0.1;\n    float steps = 64.0;\n    float inv_steps = 1.0 / steps;\n    for (float i = 0.0; i < steps; i++)\n    {\n        float h = map(sp + nor * t);\n        t += h * inv_steps;\n        if (h < tmin || h > tmax)\n        {\n            break;\n        }\n    }\n    if (t < tmax)\n    {\n        vec3 p = sp + nor * t;\n        float d = map(p);\n        occ += (h - d) * inv_steps;\n    }\n    return clamp(1.0 - (occ * bias), 0.0, 1.0);\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion_2(vec3 sp, vec3 nor)\n{\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float occ = 0.0;\n    float bias = 0.1;\n    float steps = 64.0;\n    float inv_steps = 1.0 / steps;\n    for (float i = 0.0; i < steps; i++)\n    {\n        float h = map(sp + nor * t);\n        t += h * inv_steps;\n        if (h < tmin || h > tmax)\n        {\n            break;\n        }\n    }\n    if (t < tmax)\n    {\n        vec3 p = sp + nor * t;\n        float d = map(p);\n        occ += (h - d) * inv_steps;\n    }", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44 = 0.0;\n    float d45 = 0.0;\n    float d46 = 0.0;\n", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma)\n{\n    return pow(c, vec3(1.0 / gamma));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float exposure)\n{\n    return pow(c, vec3(1.0 / gamma)) * exposure;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float exposure, float gamma2)\n{\n    return pow(c, vec3(1.0 / gamma)) * exposure * gamma2;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float exposure, float gamma2, float gamma3)\n{\n    return pow(c, vec3(1.0 / gamma)) * exposure * gamma2 * gamma3;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/", "\n    float fogDensity = fs.x;\n    float fogColorLerpExp = fs.y;\n    float fogDensityFactor = exp2(-d*d*fogDensity);\n    float fogFactor = clamp(1.0 - exp2(-d*d*fogDensity),0.0,1.0);\n    vec3 fogColor = mix(fc1,fc2,fogFactor);\n    vec3 fogColorLerp = mix(fogColor,c,fogColorLerpExp);\n    return mix(c,fogColorLerp,fogDensityFactor);\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogDensity = fs.x;\n    float fogColorLerpExp = fs.y;\n    float fogDensityFactor = exp2(-d*d*fogDensity);\n    float fogFactor = clamp(1.0 - exp2(-d*d*fogDensity),0.0,1.0);\n    vec3 fogColor = mix(fc1,fc2,fogFactor);\n    vec3 fogColorLerp = mix(fogColor,c,fogColorLerpExp);\n    return mix(c,fogColorLerp,fogDensityFactor);\n}\n\n// ~~~~~~~", "\n    return cF + lF * d + qF * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    return cF + lF * d + qF * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    return cF + lF * d + qF * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    return cF + lF * d + qF * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic", "\n    vec3 rayDir = vec3(0.0);\n    vec3 fCoord3 = vec3(fCoord, 1.0);\n    vec4 fCoord4 = cMatrix * vec4(fCoord3, 1.0);\n    rayDir = normalize(fCoord4.xyz - cMatrix[2]);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = vec3(0.0);\n    vec3 fCoord3 = vec3(fCoord, 1.0);\n    vec4 fCoord4 = cMatrix * vec4(fCoord3, 1.0);\n    rayDir = normalize(fCoord4.xyz - cMatrix[2]);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = vec3(0.0);\n    vec3 fCoord3 = vec3(fCoord, 1.0);\n    vec4 fCoord4 = cMatrix * vec4(fCoord3, 1.0);\n    rayDir = normalize(fCoord4.xyz - cMatrix[2]);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = vec3(0.0);\n    vec3 fCoord3 = vec3", "\n    vec3 color = vec3(0.0);\n    vec2 fCoord_ = fCoord;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    vec3 cPos_ = cPos;\n    vec3 cMat_ = cMat;\n    ve", "\n    // Setup\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 c = p;\n    vec2 z = vec2(0.0);\n    vec2 d = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.0;\n    float r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n    float r4 = 0.0;\n    float r5 = 0.0;\n    float r6 = 0.0;\n    float r7 = 0.0;\n    float r8 = 0.0;\n    float r9 = 0.0;\n    float r10 = 0.0;\n    float r11 = 0.0;\n    float r12 = 0.0;\n    float r13 = 0.0;\n    float r14 = 0.0;\n    float r15 = 0.0;\n    float r16 = 0.0;\n    float r17 = 0.0;\n    float r18 = 0.0;\n    float r19 = 0.0;\n    float r20 = 0.0;\n    float r21 = 0.0;\n    float r22 = 0.0;\n    float r23 = 0.0;\n    float r24 = 0.0;\n    float r25 = 0.0;\n    float r26 = 0.0;\n    float r27 = 0.0;\n    float r28 = 0.0;\n    float r29 = 0.0;\n    float r30 = 0.0;\n    float r31 = 0.0;\n    float r32 = 0.0;\n    float r33 = 0.0;\n    float r34 = 0.0;\n    float r35 = 0.0;\n    float r36 = 0.0;\n    float r37", "\n    vec3 d = abs(p) - radius;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 height)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - height;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec2 height)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - height;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// triangle distance field\nfloat sdTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n\n    float s = sign(dot(cross(ab, ac), ap));\n    float t = sign(dot(cross(ab, bp), bp));\n    float u = sign(dot(cross(ac, cp), cp));\n    return min(min(s + t, s + u), t + u) / 2.0;\n}\n\n// triangle distance field\nfloat sdTriangle(vec3 p, vec3 a, vec3 b, vec3 c, float radius)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n   ", "\n    return length(p.xz - vec2(0.0, r)) - r;\n}\n\n// simple sphere distance field\nfloat sph(vec3 p, float r)\n{\n    return length(p.xz - vec2(0.0, r)) - r;\n}\n\n// simple torus distance field\nfloat tor(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// simple torus distance field\nfloat tor(vec3 p, vec2 t, float r)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y - r;\n}\n\n// simple torus distance field\nfloat tor(vec3 p, vec2 t, float r, float s)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y - r - s;\n}\n\n// simple torus distance field\nfloat tor(vec3 p, vec2 t, float r, float s, float w)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y - r - s - w;\n}\n\n// simple torus distance field\nfloat tor(vec3 p, vec2 t, float r, float s, float w, float h)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y - r - s - w - h;\n}\n\n// simple torus distance field\nfloat tor(vec3 p, vec2 t, float r, float s, float w, float h, float d)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q", "\n    vec2 d = vec2(1000.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = mod(q.x, 1.0);\n        r.y = mod(q.y, 1.0);\n        r.z = mod(q.z, 1.0);\n        if (r.x < 0.5)\n        {\n            r.x += 1.0;\n        }\n        if (r.y < 0.5)\n        {\n            r.y += 1.0;\n        }\n        if (r.z < 0.5)\n        {\n            r.z += 1.0;\n        }\n        float dd = length(r - q);\n        if (dd < d.x)\n        {\n            d.x = dd;\n            d.y = float(i);\n        }\n        q = r;\n    }\n    return d;\n}\n\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject2(vec3 p)\n{\n    vec2 d = vec2(1000.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = mod(q.x, 1.0);\n        r.y = mod(q.y, 1.0);\n        r.z = mod(q.z, 1.0);\n        if (r.x < 0.5)\n        {\n            r.x += 1.0;\n        }\n        if (r.y < 0.5)\n        {\n            r.y += 1.0;\n        }\n        if (r.z < 0.5)\n        {\n            r.z += 1.0;\n        }\n        float", "\n    return vec2(pow(c.x, 5), pow(c.y, 5));\n}\n\n//Function that returns a complex number to power of 10\nvec2 complexPower10(vec2 c)\n{\n    return vec2(pow(c.x, 10), pow(c.y, 10));\n}\n\n//Function that returns a complex number to power of 15\nvec2 complexPower15(vec2 c)\n{\n    return vec2(pow(c.x, 15), pow(c.y, 15));\n}\n\n//Function that returns a complex number to power of 20\nvec2 complexPower20(vec2 c)\n{\n    return vec2(pow(c.x, 20), pow(c.y, 20));\n}\n\n//Function that returns a complex number to power of 25\nvec2 complexPower25(vec2 c)\n{\n    return vec2(pow(c.x, 25), pow(c.y, 25));\n}\n\n//Function that returns a complex number to power of 30\nvec2 complexPower30(vec2 c)\n{\n    return vec2(pow(c.x, 30), pow(c.y, 30));\n}\n\n//Function that returns a complex number to power of 35\nvec2 complexPower35(vec2 c)\n{\n    return vec2(pow(c.x, 35), pow(c.y, 35));\n}\n\n//Function that returns a complex number to power of 40\nvec2 complexPower40(vec2 c)\n{\n    return vec2(pow(c.x, 40), pow(c.y, 40));\n}\n\n//Function that returns a complex number to power of 45\nvec2 complexPower45(vec2 c)\n{\n    return vec2(pow(c.x, 45), pow(c.y, 45));\n}\n\n//Function that returns a complex number to power of 50\nvec2 complexPower5", "\n    vec4 color = vec4(0.0);\n    vec2 coordMorph = coord * morphConstant;\n    float x = coordMorph.x;\n    float y = coordMorph.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float xy = x * y;\n    float x2y = x2 * y;\n    float x2y2 = x2y * y;\n    float x2y2_2 = x2y2 * 2.0;\n    float x2y2_3 = x2y2 * 3.0;\n    float x2y2_4 = x2y2 * 4.0;\n    float x2y2_5 = x2y2 * 5.0;\n    float x2y2_6 = x2y2 * 6.0;\n    float x2y2_7 = x2y2 * 7.0;\n    float x2y2_8 = x2y2 * 8.0;\n    float x2y2_9 = x2y2 * 9.0;\n    float x2y2_10 = x2y2 * 10.0;\n    float x2y2_11 = x2y2 * 11.0;\n    float x2y2_12 = x2y2 * 12.0;\n    float x2y2_13 = x2y2 * 13.0;\n    float x2y2_14 = x2y2 * 14.0;\n    float x2y2_15 = x2y2 * 15.0;\n    float x2y2_16 = x2y2 * 16.0;\n    float x2y2_17 = x2y2 * 17.0;\n    float x2y2_18 = x2y2 * 18.0;\n    float x2y2_19 = x2y2 * 19.0;\n    float x2y2_20 = x2y2 * 20.0;\n    float", "\n\tvec4 color = vec4(0.0);\n\tvec2 offset = vec2(0.0);\n\tfloat weight = 0.0;\n\tfloat weightSum = 0.0;\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\toffset = vec2(0.0);\n\t\tweight = 0.0;\n\t\tweightSum = 0.0;\n\t\t\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\toffset += vec2(i - 2, j - 2) * constant;\n\t\t\tweight = texture2D(tex, uv + offset).r;\n\t\t\tweightSum += weight;\n\t\t}\n\t\t\n\t\tcolor += weight / weightSum * texture2D(tex, uv + offset);\n\t}\n\t\n\treturn color;\n}\n\nvoid main()\n{\n\tvec2 uv = gl_TexCoord[0].xy;\n\t\n\tvec4 color = antiAliasedBiomorph(uv, vec2(0.0, 0.0));\n\t\n\tgl_FragColor = color;\n}", "\n    return fmod(x, 1.0);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(i, vec2(1.0, 0.0)), dot(i, vec2(0.0, 1.0)), u.x),\n               mix(dot(i, vec2(1.0, 1.0)), dot(i, vec2(1.0, 0.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm(vec3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    // Rotate to reduce axial bias\n    mat3 rot = mat3(cos(0.5), sin(0.5), 0.0,\n                    -sin(0.5), cos(0.5), 0.0,\n                    0.0, 0.0, 1.0);\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm(vec4 p) {\n    float v = 0", "\n    vec2 p = pA - pB;\n    float d = length(p);\n    float r = rounded;\n    float t = thick.x;\n    float b = thick.y;\n    float dd = d - t - b;\n    float dp = dot(p, uv - pB);\n    float dd2 = dd * dd;\n    float dp2 = dp * dp;\n    float dd4 = dd2 * dd2;\n    float dp4 = dp2 * dp2;\n    float dd6 = dd4 * dd2;\n    float dp6 = dp4 * dp2;\n    float dd8 = dd6 * dd2;\n    float dp8 = dp6 * dp2;\n    float dd10 = dd8 * dd2;\n    float dp10 = dp8 * dp2;\n    float dd12 = dd10 * dd2;\n    float dp12 = dp10 * dp2;\n    float dd14 = dd12 * dd2;\n    float dp14 = dp12 * dp2;\n    float dd16 = dd14 * dd2;\n    float dp16 = dp14 * dp2;\n    float dd18 = dd16 * dd2;\n    float dp18 = dp16 * dp2;\n    float dd20 = dd18 * dd2;\n    float dp20 = dp18 * dp2;\n    float dd22 = dd20 * dd2;\n    float dp22 = dp20 * dp2;\n    float dd24 = dd22 * dd2;\n    float dp24 = dp22 * dp2;\n    float dd26 = dd24 * dd2;\n    float dp26 = dp24 * dp2;\n    float dd28 = dd26 * dd2;", "\n    vec2 p = mix(pA, pB, uv);\n    vec2 d = pB - pA;\n    float d2 = dot(d, d);\n    float d4 = d2 * d2;\n    float d6 = d2 * d4;\n    float d8 = d2 * d6;\n    float d10 = d2 * d8;\n    float d12 = d2 * d10;\n    float d14 = d2 * d12;\n    float d16 = d2 * d14;\n    float d18 = d2 * d16;\n    float d20 = d2 * d18;\n    float d22 = d2 * d20;\n    float d24 = d2 * d22;\n    float d26 = d2 * d24;\n    float d28 = d2 * d26;\n    float d30 = d2 * d28;\n    float d32 = d2 * d30;\n    float d34 = d2 * d32;\n    float d36 = d2 * d34;\n    float d38 = d2 * d36;\n    float d40 = d2 * d38;\n    float d42 = d2 * d40;\n    float d44 = d2 * d42;\n    float d46 = d2 * d44;\n    float d48 = d2 * d46;\n    float d50 = d2 * d48;\n    float d52 = d2 * d50;\n    float d54 = d2 * d52;\n    float d56 = d2 * d54;\n    float d58 = d2 * d56;\n    float d60 = d2 * d58;\n    float d62 = d2 * d60;\n    float d64 = d2 * d62;\n    float d66 = d2 * d64;\n    float d68 = d2 * d66;\n    float d70 = d2 * d68;", "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dl2 = dl * dl;\n    float dl4 = dl2 * dl2;\n    float dl8 = dl4 * dl4;\n    float dl16 = dl8 * dl8;\n    float dl32 = dl16 * dl16;\n    float dl64 = dl32 * dl32;\n    float dl128 = dl64 * dl64;\n    float dl256 = dl128 * dl128;\n    float dl512 = dl256 * dl256;\n    float dl1024 = dl512 * dl512;\n    float dl2048 = dl1024 * dl1024;\n    float dl4096 = dl2048 * dl2048;\n    float dl8192 = dl4096 * dl4096;\n    float dl16384 = dl8192 * dl8192;\n    float dl32768 = dl16384 * dl16384;\n    float dl65536 = dl32768 * dl32768;\n    float dl131072 = dl65536 * dl65536;\n    float dl262144 = dl131072 * dl131072;\n    float dl524288 = dl262144 * dl262144;\n    float dl1048576 = dl524288 * dl524288;\n    float dl2097152 = dl1048576 * dl104857", "\n    vec2 p = mix(pA, pB, uv);\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dl2 = dl * dl;\n    float dl4 = dl2 * dl2;\n    float dl8 = dl4 * dl4;\n    float dl16 = dl8 * dl8;\n    float dl32 = dl16 * dl16;\n    float dl64 = dl32 * dl32;\n    float dl128 = dl64 * dl64;\n    float dl256 = dl128 * dl128;\n    float dl512 = dl256 * dl256;\n    float dl1024 = dl512 * dl512;\n    float dl2048 = dl1024 * dl1024;\n    float dl4096 = dl2048 * dl2048;\n    float dl8192 = dl4096 * dl4096;\n    float dl16384 = dl8192 * dl8192;\n    float dl32768 = dl16384 * dl16384;\n    float dl65536 = dl32768 * dl32768;\n    float dl131072 = dl65536 * dl65536;\n    float dl262144 = dl131072 * dl131072;\n    float dl524288 = dl262144 * dl262144;\n    float dl1048576 = dl524288 * dl524288;\n    float dl2097152 = dl1048576 *", "\n    vec2 d = pB - pA;\n    float l = length(d);\n    float r = l - thick.x;\n    float t = thick.y;\n    float b = l - t;\n    float c = l - r;\n    float dA = dot(d, uv - pA) / l;\n    float dB = dot(d, uv - pB) / l;\n    float dC = dot(d, uv - pA - pB) / l;\n    float dD = dot(d, uv - pB - pA) / l;\n    float dE = dot(d, uv - pA + pB) / l;\n    float dF = dot(d, uv - pB + pA) / l;\n    float dG = dot(d, uv - pA + pB + pA - pB) / l;\n    float dH = dot(d, uv - pB + pA + pB - pA) / l;\n    float dI = dot(d, uv - pA + pB + pA - pB + pA - pB) / l;\n    float dJ = dot(d, uv - pB + pA + pB - pA + pA - pB) / l;\n    float dK = dot(d, uv - pA + pB + pA - pB + pA - pB + pA - pB) / l;\n    float dL = dot(d, uv - pB + pA + pB - pA + pA - pB + pA - pB + pA - pB) / l;\n    float dM = dot(d, uv - pA + pB + pA - pB + pA - pB + pA - pB + pA - pB + pA - pB) / l;\n    float dN = dot(d, uv - pB + pA + pB - pA + pA - pB + pA - pB + pA - pB + pA - pB + pA - pB) / l;\n    float dO = dot", "\n    vec2 p = pA + (pB - pA) * uv;\n    float d = distance(p, pA);\n    float d2 = distance(p, pB);\n    float d3 = distance(p, pA + (pB - pA) * 0.5);\n    float d4 = distance(p, pA + (pB - pA) * 0.25);\n    float d5 = distance(p, pA + (pB - pA) * 0.125);\n    float d6 = distance(p, pA + (pB - pA) * 0.0625);\n    float d7 = distance(p, pA + (pB - pA) * 0.03125);\n    float d8 = distance(p, pA + (pB - pA) * 0.015625);\n    float d9 = distance(p, pA + (pB - pA) * 0.0078125);\n    float d10 = distance(p, pA + (pB - pA) * 0.00390625);\n    float d11 = distance(p, pA + (pB - pA) * 0.001953125);\n    float d12 = distance(p, pA + (pB - pA) * 0.0009765625);\n    float d13 = distance(p, pA + (pB - pA) * 0.00048828125);\n    float d14 = distance(p, pA + (pB - pA) * 0.000244140625);\n    float d15 = distance(p, pA + (pB - pA) * 0.0001220703125);\n    float d16 = distance(p, pA + (pB - pA) * 0.00006103515625);\n    float d", "\n    col = vec3(0.0);\n    col.r = sin(p.x * 10.0) * 0.5 + 0.5;\n    col.g = sin(p.y * 10.0) * 0.5 + 0.5;\n    col.b = sin(p.x * 10.0 + p.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 p = vec2(0.0);\n    vec3 col = vec3(0.0);\n    DrawPoint(uv, p, col);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 oc = ro - cen;\n    float b = dot( oc, nor );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad )\n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 pnt, in vec3 nor )\n{\n    float b = dot( pnt, nor );\n    float c = dot( ro, nor );\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 pnt0, in vec3 pnt1, in vec3 pnt2 )\n{\n    vec3 e1 = pnt1 - pnt0;\n    vec3 e2 = pnt2 - pnt0;\n    vec3 h = cross( rd, e2 );\n    float a = dot( e1, h );\n    if( a > -0.0001 && a < 0.0001 ) return -1.0;    // ray is parallel to triangle\n    float f = 1.0 / a;\n    vec3 s = ro - pnt0;\n    float u = f * dot( s, h );\n    if( u < 0.0 || u > 1.0 ) return -1.0;\n    vec", "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.", "\n    vec3 ab = pb - pa;\n    float ab2 = dot( ab, ab );\n    float h = length( pa.yz ) - ra;\n    float a = acos( clamp( ra / length( pa.yz ), 0.0, 1.0 ) );\n    float b = acos( clamp( ra / length( pb.yz ), 0.0, 1.0 ) );\n    float s = sin( a );\n    float c = cos( a );\n    vec3 u = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ab ) );\n    vec3 v = normalize( cross( ab, u ) );\n    vec3 r = vec3( 0.0 );\n    r.x = h * c + ra;\n    r.y = h * s;\n    r.z = h * s;\n    return bound3( pa + r * u, pa + r * v );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spherebbox/spherebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box (http://iquilezles.org/www/articles/boxbbox/boxbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 p, in vec3 s )\n{\n    return bound3( p - s, p + s );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a triangle (http://iquilezles.org/www/articles/tribbox/tribbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 TriangleAABB( in vec3 pa, in vec3 pb, in vec3 pc )\n{\n    return bound3( min( pa, pb ), max( pa, pb ) );\n", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 ps, in float ra )\n{\n    vec3 op = ro - ps;\n    float b = dot(op, rd);\n    float c = dot(op, op) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - ps);\n    return vec4(t, n);\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n    float b = dot(n, p - ro);\n    float c = dot(n, n);\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(", "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 p = cen - ro;\n    vec3 t1 = -p - q*dot( p, q );\n    vec3 t2 = -p + q*dot( p, q );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( res.x, max( tmin.x, tmax.x ) );\n    res.y = max( res.y, max( tmin.y, tmax.y ) );\n    return res;\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec2 res = vec2( 1e10 );\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h > 0.0 ) \n    {\n        h = sqrt( h );\n        float t = -b - h;\n        if( t > 0.0 ) \n        {\n            res.x = t;\n            res.y = t;\n        }\n        else \n        {\n            t = -b + h;\n            if( t > 0.0 ) \n            {\n                res.x = t;\n                res.y = t;\n            }\n        }\n    }\n    return res;\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 nor ) \n{\n    vec2 res = vec2( 1e10 );\n    float t = dot( (cen - ro), nor ) / dot( rd, nor );\n    if( t > 0.0 ) \n    {\n        res.x =", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - r*r;\n    float d = dot(ap, ab) * 2.0;\n    float e = dot(ap, ap) - r*r;\n    float h = b*b - c*e;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    float t1 = (-b - h) / e;\n    float t2 = (-b + h) / e;\n    if( t1 < 0.0 ) t1 = -1.0;\n    if( t2 < 0.0 ) t2 = -1.0;\n    if( t1 > t2 ) { float tt = t1; t1 = t2; t2 = tt; }\n    if( t1 < 0.0 ) return -1.0;\n    if( t1 > t2 ) return -1.0;\n    return t1;\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - r*r;\n    float d = dot(ap, ab) * 2.0;\n    float e = dot(ap, ap) - r*r;\n    float h = b*b - c*e;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    float t1 = (-b - h) / e;\n    float t2 = (-b + h) / e;\n    if( t1 < 0.0 ) t1 = -1.0;\n    if( t2 < 0.0 ) t", "\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    vec3 normal = normalize( cross( ab, ap ) );\n    return normal;\n}\n\n// compute normal at a point\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ab = b", "\n    vec2 res = vec2( 1e10 );\n    vec3 rd3 = abs( rd );\n    vec3 q = (ro - rad) / rd3;\n    vec3 m = min( q, q.yzx );\n    vec3 M = max( q, q.yzx );\n    res.x = max( m.x, 0.0 );\n    res.y = max( max( M.x, M.y ), m.z );\n    return res;\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec2 res = vec2( 1e10 );\n    vec3 rd3 = abs( rd );\n    vec3 q = (ro - rad) / rd3;\n    vec3 m = min( q, q.yzx );\n    vec3 M = max( q, q.yzx );\n    res.x = max( m.x, 0.0 );\n    res.y = max( max( M.x, M.y ), m.z );\n    return res;\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec2 res = vec2( 1e10 );\n    vec3 rd3 = abs( rd );\n    vec3 q = (ro - rad) / rd3;\n    vec3 m = min( q, q.yzx );\n    vec3 M = max( q, q.yzx );\n    res.x = max( m.x, 0.0 );\n    res.y = max( max( M.x, M.y ), m.z );\n    return res;\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec2 res = vec2( 1e", "\n    vec4 res = vec4(0.0);\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin_sphere = 0.0;\n    float tmax_sphere = 10000.0;\n    float tmin_plane = 0.0;\n    float tmax_plane = 10000.0;\n    float tmin_cylinder = 0.0;\n    float tmax_cylinder = 10000.0;\n    float tmin_cone = 0.0;\n    float tmax_cone = 10000.0;\n    float tmin_torus = 0.0;\n    float tmax_torus = 10000.0;\n    float tmin_capsule = 0.0;\n    float tmax_capsule = 10000.0;\n    float tmin_triangle = 0.0;\n    float tmax_triangle = 10000.0;\n    float tmin_cube = 0.0;\n    float tmax_cube = 10000.0;\n    float tmin_capsule2 = 0.0;\n    float tmax_capsule2 = 10000.0;\n    float tmin_capsule3 = 0.0;\n    float tmax_capsule3 = 10000.0;\n    float tmin_capsule4 = 0.0;\n    float tmax_capsule4 = 10000.0;\n    float tmin_capsule5 = 0.0;\n    float tmax_capsule5 = 10000.0;\n    float tmin_capsule6 = 0.0;\n    float tmax_capsule6 = 10000.0;\n    float tmin_capsule7 = 0.0;\n    float tmax_capsule7 = 10000.0;\n    float tmin_capsule8 = 0.0;\n    float tmax", "\n    float t = i * 2.0 * PI;\n    float r = sqrt(1.0 - n * n);\n    return vec3(r * cos(t), r * sin(t), n);\n}\n\n// returns the normal of the surface at the given point\nvec3 normalSF( vec3 p )\n{\n    return normalize( vec3(p.x, p.y, 1.0 - p.x - p.y) );\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p )\n{\n    return vec3(0.5, 0.5, 0.5);\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p, vec3 n )\n{\n    return vec3(0.5, 0.5, 0.5);\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p, vec3 n, vec3 t )\n{\n    return vec3(0.5, 0.5, 0.5);\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p, vec3 n, vec3 t, vec3 b )\n{\n    return vec3(0.5, 0.5, 0.5);\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p, vec3 n, vec3 t, vec3 b, vec3 s )\n{\n    return vec3(0.5, 0.5, 0.5);\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p, vec3 n, vec3 t, vec3 b, vec3 s, vec3 d )\n{\n    return vec3(0.5, 0.5, 0.5);\n}\n\n// returns the color of the surface at the given point\nvec3 colorSF( vec3 p, vec3 n,", "\n    vec4 res = vec4( 0.0 );\n    vec3 p = ro;\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin_s = 0.0;\n    float tmax_s = 10000.0;\n    float tmin_t = 0.0;\n    float tmax_t = 10000.0;\n    float tmin_r = 0.0;\n    float tmax_r = 10000.0;\n    float tmin_p = 0.0;\n    float tmax_p = 10000.0;\n    float tmin_q = 0.0;\n    float tmax_q = 10000.0;\n    float tmin_s_s = 0.0;\n    float tmax_s_s = 10000.0;\n    float tmin_t_t = 0.0;\n    float tmax_t_t = 10000.0;\n    float tmin_r_r = 0.0;\n    float tmax_r_r = 10000.0;\n    float tmin_p_p = 0.0;\n    float tmax_p_p = 10000.0;\n    float tmin_q_q = 0.0;\n    float tmax_q_q = 10000.0;\n    float tmin_s_s_s = 0.0;\n    float tmax_s_s_s = 10000.0;\n    float tmin_t_t_t = 0.0;\n    float tmax_t_t_t = 10000.0;\n    float tmin_r_r_r = 0.0;\n    float tmax_r_r_r = 10000.0;\n    float tmin_p_p_p = 0.0;\n    float tmax_p_p_p = 10000.0;\n    float tmin_q_q_", "\n    vec3 q = vec3(p, 0.0);\n    return vec3(fract(sin(dot(q, vec3(127.1, 311.7, 191.9))) * 43758.5453),\n                fract(cos(dot(q, vec3(269.5, 183.3, 772.4))) * 43758.5453));\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec3 q = vec3(p, 0.0);\n    return vec3(fract(sin(dot(q, vec3(127.1, 311.7, 191.9))) * 43758.5453),\n                fract(cos(dot(q, vec3(269.5, 183.3, 772.4))) * 43758.5453));\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec3 q = vec3(p, 0.0);\n    return vec3(fract(sin(dot(q, vec3(127.1, 311.7, 191.9))) * 43758.5453),\n                fract(cos(dot(q, vec3(269.5, 183.3, 772.4))) * 43758.5453));\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec3 q = vec3(p, 0.0);\n    return vec3(fract(sin(dot(q, vec3(127.1, 311.7, 191.", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdRoundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) - r;\n}\n\nfloat sdRoundRect(vec2 p, vec2 a, vec2 b, float r)\n{\n    vec2 d = abs(p) - a;\n    vec2 d1 = abs(p) - b;\n    return length(max(d, 0.0)) - r + min(max(d.x, d.y), 0.0) - min(max(d1.x, d1.y), 0.0) + r;\n}\n\nfloat sdRoundTriangle(vec2 p, vec2 b, float r)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) - r;\n}\n\nfloat sdRoundHexagon(vec2 p, vec2 b, float r)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) - r + min(max(q.x, q.y), 0.0) - min(max(q.y, q.x), 0.0) + r;\n}\n\nfloat sdRoundStar(vec2 p, vec2 b, float r)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) - r", "\n    vec3 color = vec3(0.0);\n    vec2 p = uv;\n    float t = time * 0.01;\n    float a = t * 0.01;\n    float b = t * 0.01;\n    float c = t * 0.01;\n    float d = t * 0.01;\n    float e = t * 0.01;\n    float f = t * 0.01;\n    float g = t * 0.01;\n    float h = t * 0.01;\n    float i = t * 0.01;\n    float j = t * 0.01;\n    float k = t * 0.01;\n    float l = t * 0.01;\n    float m = t * 0.01;\n    float n = t * 0.01;\n    float o = t * 0.01;\n    float p = t * 0.01;\n    float q = t * 0.01;\n    float r = t * 0.01;\n    float s = t * 0.01;\n    float t = t * 0.01;\n    float u = t * 0.01;\n    float v = t * 0.01;\n    float w = t * 0.01;\n    float x = t * 0.01;\n    float y = t * 0.01;\n    float z = t * 0.01;\n    float aa = t * 0.01;\n    float bb = t * 0.01;\n    float cc = t * 0.01;\n    float dd = t * 0.01;\n    float ee = t * 0.01;\n    float ff = t * 0.01;\n    float gg = t * 0.01;\n    float hh = t * 0.01;\n    float ii = t * 0.01;\n    float jj = t * 0.01", "\n    vec2 p = uv;\n    vec2 q = uv;\n    vec2 r = uv;\n    vec2 s = uv;\n    vec2 t = uv;\n    vec2 u = uv;\n    vec2 v = uv;\n    vec2 w = uv;\n    vec2 x = uv;\n    vec2 y = uv;\n    vec2 z = uv;\n\n    p.x *= orient.x;\n    p.y *= orient.y;\n    q.x *= orient.x;\n    q.y *= orient.y;\n    r.x *= orient.x;\n    r.y *= orient.y;\n    s.x *= orient.x;\n    s.y *= orient.y;\n    t.x *= orient.x;\n    t.y *= orient.y;\n    u.x *= orient.x;\n    u.y *= orient.y;\n    v.x *= orient.x;\n    v.y *= orient.y;\n    w.x *= orient.x;\n    w.y *= orient.y;\n    x.x *= orient.x;\n    x.y *= orient.y;\n    y.x *= orient.x;\n    y.y *= orient.y;\n    z.x *= orient.x;\n    z.y *= orient.y;\n\n    return vec3(\n        pat(p.x, p.y),\n        pat(q.x, q.y),\n        pat(r.x, r.y),\n        pat(s.x, s.y),\n        pat(t.x, t.y),\n        pat(u.x, u.y),\n        pat(v.x, v.y),\n        pat(w.x, w.y),\n        pat(x.x, x.y),\n        pat(y.x, y.y),\n        pat(z.x, z.y)\n    );\n}\n\n// Pattern 3\nvec3 pat3(vec", "\n    vec2 d = ddx * ddy;\n    return 0.5 + 0.5 * fract( p.x * d.x + p.y * d.y );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 d = ddx * ddy;\n    return 0.5 + 0.5 * fract( p.x * d.x + p.y * d.y );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    vec2 d = ddx * ddy;\n    return 0.5 + 0.5 * fract( p.x * d.x + p.y * d.y ) * scale;\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float bias )\n{\n    vec2 d = ddx * ddy;\n    return 0.5 + 0.5 * fract( p.x * d.x + p.y * d.y ) * scale + bias;\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float bias, in float falloff )\n{\n    vec2 d = ddx * ddy;\n    return 0.5 + 0.5 * fract( p.x * d.x + p.y * d.y ) * scale + bias * ( 1.0 - gridTextureGradBox( p, ddx, ddy ) );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float bias, in float falloff, in float falloff2 )\n{\n    vec2 d = ddx * ddy;\n    return 0.5 + 0.5 * fract( p.x * d.x + p.y * d.y ) * scale", "\n    vec3 d = vec3( 0.0 );\n    d.x = dmap1( p.x, p.y, p.z );\n    d.y = dmap2( p.x, p.y, p.z );\n    d.z = dmap3( p.x, p.y, p.z );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n )\n{\n    vec3 d = vec3( 0.0 );\n    d.x = dmap1( p.x, p.y, p.z, n.x, n.y, n.z );\n    d.y = dmap2( p.x, p.y, p.z, n.x, n.y, n.z );\n    d.z = dmap3( p.x, p.y, p.z, n.x, n.y, n.z );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 t )\n{\n    vec3 d = vec3( 0.0 );\n    d.x = dmap1( p.x, p.y, p.z, n.x, n.y, n.z, t.x, t.y, t.z );\n    d.y = dmap2( p.x, p.y, p.z, n.x, n.y, n.z, t.x, t.y, t.z );\n    d.z = dmap3( p.x, p.y, p.z, n.x, n.y, n.z, t.x, t.y, t.z );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 t, in vec3 b )\n{\n    vec3 d = vec3( 0.", "\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c = a;\n    a = b;\n    b = c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 add(v33 a,vec3 b){\n    return v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mul(v33 a,vec3 b){\n    return v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 div(v33 a,vec3 b){\n    return v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 cross(v33 a,vec3 b){\n    return v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nfloat dot(v33 a,vec3 b){\n    return a.x*b.x+a.y*b.y+a.z*b.z;\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nfloat length(v33 a){\n    return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 normalize(v33 a){\n    return div(a,length(a));\n}\n\n//swap direction(.b", "\n    v33 c;\n    c.x=a.x-b.x;\n    c.y=a.y-b.y;\n    c.z=a.z-b.z;\n    return c;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 sub(v33  a,v33 b){\n    v33 c;\n    c.x=a.x-b.x;\n    c.y=a.y-b.y;\n    c.z=a.z-b.z;\n    return c;\n}\n\n//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 add(v33  a,v33 b){\n    v33 c;\n    c.x=a.x+b.x;\n    c.y=a.y+b.y;\n    c.z=a.z+b.z;\n    return c;\n}\n\n//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    v33 c;\n    c.x=a.x+b.x;\n    c.y=a.y+b.y;\n    c.z=a.z+b.z;\n    return c;\n}\n\n//multiply b to all ray components\n//component wise ray multiplication(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 mult(v33  a,v33 b){\n    v33 c;\n    c.x=a.x*b.x;\n    c.y=a.y*b.y;\n    c.z=a.z*b.z;\n    return c;\n}\n\n//multiply b to all ray components\n//component wise ray multiplication(this one is a bit", "\n    return (a-b)/dt_step;\n}\n\n//v33-differentials for AA\nvec2 dv(v33 a,v33 b){\n    return (a-b)/v_step;\n}\n\n//v33-differentials for AA\nvec2 dp(v33 a,v33 b){\n    return (a-b)/p_step;\n}\n\n//v33-differentials for AA\nvec2 dq(v33 a,v33 b){\n    return (a-b)/q_step;\n}\n\n//v33-differentials for AA\nvec2 dr(v33 a,v33 b){\n    return (a-b)/r_step;\n}\n\n//v33-differentials for AA\nvec2 ds(v33 a,v33 b){\n    return (a-b)/s_step;\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b){\n    return (a-b)/t_step;\n}\n\n//v33-differentials for AA\nvec2 dv(v33 a,v33 b){\n    return (a-b)/v_step;\n}\n\n//v33-differentials for AA\nvec2 dp(v33 a,v33 b){\n    return (a-b)/p_step;\n}\n\n//v33-differentials for AA\nvec2 dq(v33 a,v33 b){\n    return (a-b)/q_step;\n}\n\n//v33-differentials for AA\nvec2 dr(v33 a,v33 b){\n    return (a-b)/r_step;\n}\n\n//v33-differentials for AA\nvec2 ds(v33 a,v33 b){\n    return (a-b)/s_step;\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b){\n    return (a-b)/t_step;\n", "\n    return vec2(dot(a.xyz,b),dot(a.xyz,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n    return vec2(dot(a.xyz,b.xyz),dot(a.xyz,b.xyz));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n    return vec2(dot(a.xyz,b.xyz),dot(a.xyz,c.xyz));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n    return vec2(dot(a.xyz,b.xyz),dot(a.xyz,c.xyz));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return vec2(dot(a.xyz,b.xyz),dot(a.xyz,c.xyz));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n    return vec2(dot(a.xyz,b.xyz),dot(a.xyz,c.xyz));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n    return vec2(dot(a.xyz,b.xyz),dot(a.xyz,c.xyz));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v", "\n    return vec3(a.x*b.x,a.y*b.x,a.z*b.x);\n}\n\nv33 mul(v33 a,v33 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v32 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v31 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v30 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v23 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v22 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v21 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v20 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v13 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\nv33 mul(v33 a,v12 b){\n   ", "\n    vec3 q=mod(p,w);\n    return step(0.5,mod(q.x+q.y+q.z,2.0));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=mod(p,w);\n    return step(0.5,mod(q.x+q.y+q.z,2.0));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=mod(p,w);\n    return step(0.5,mod(q.x+q.y+q.z,2.0));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=mod(p,w);\n    return step(0.5,mod(q.x+q.y+q.z,2.0));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=mod(p,w);\n    return step(0.5,mod(q.x+q.y+q.z,2.0));\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(ray", "\n    float a=0.0;\n    float b=0.0;\n    float c=0.0;\n    float d=0.0;\n    float e=0.0;\n    float f=0.0;\n    float g=0.0;\n    float h=0.0;\n    float i=0.0;\n    float j=0.0;\n    float k=0.0;\n    float l=0.0;\n    float m=0.0;\n    float n=0.0;\n    float o=0.0;\n    float p=0.0;\n    float q=0.0;\n    float r=0.0;\n    float s=0.0;\n    float t=0.0;\n    float u=0.0;\n    float v=0.0;\n    float w=0.0;\n    float x=0.0;\n    float y=0.0;\n    float z=0.0;\n    float A=0.0;\n    float B=0.0;\n    float C=0.0;\n    float D=0.0;\n    float E=0.0;\n    float F=0.0;\n    float G=0.0;\n    float H=0.0;\n    float I=0.0;\n    float J=0.0;\n    float K=0.0;\n    float L=0.0;\n    float M=0.0;\n    float N=0.0;\n    float O=0.0;\n    float P=0.0;\n    float Q=0.0;\n    float R=0.0;\n    float S=0.0;\n    float T=0.0;\n    float U=0.0;\n    float V=0.0;\n    float W=0.0;\n    float X=0.0;\n    float Y=0.0;\n    float Z=0.0;\n    float aa=0.0;\n    float bb=0.0;\n    float cc=0.0;\n    float dd=0.0;\n    float ee", "\n    float t = dot(r.p,r.d);\n    float d = length(r.p+r.d*t-s.xyz);\n    float r2 = s.w*s.w;\n    return max(0.0, (r2-d*d)/r2);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r.p,r.d);\n    float d = length(r.p+r.d*t-s.xyz);\n    float r2 = s.w*s.w;\n    return max(0.0, (r2-d*d)/r2);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r.p,r.d);\n    float d = length(r.p+r.d*t-s.xyz);\n    float r2 = s.w*s.w;\n    return max(0.0, (r2-d*d)/r2);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r.p,r.d);\n    float d = length(r.p+r.d*t-s.xyz);\n    float r2 = s.w*s.w;\n    return max(0.0, (r2-d*d)/r2);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r.p,r.d);\n    float d = length(r.p+r.d*t-s.xyz);\n    float r2 = s.w*s.w;\n    return max(0.0, (r2-d*d)/r2);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n   ", "\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u-s.xyz);\n    float d = s.w - r;\n    return clamp(d/s.w,0.0,1.0);\n}\n\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    float r = length(u", "\n    vec2 p = p0;\n    vec2 d = p1 - p0;\n    vec2 e = p2 - p1;\n    vec2 f = p - p0;\n    float t = dot(f, f) / dot(d, d);\n    return vec4(mix(p0, p1, t), 0.0, 1.0);\n}\n\n// Approximate BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in float t )\n{\n    return mix(bboxBezier(p0, p1, p2), vec4(p1, 0.0, 1.0), t);\n}\n\n// Approximate BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    return mix(bboxBezier(p0, p1, p2), vec4(p1, 0.0, 1.0), 0.5);\n}\n\n// Approximate BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in float t )\n{\n    return mix(bboxBezier(p0, p1, p2, t), vec4(p1, 0.0, 1.0), t);\n}\n\n// Approximate BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n    return mix(bboxBezier(p0, p1, p2, p3), vec4(p1, 0.0, 1.0), 0.5);\n}\n\n// Approximate BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1", "\n    vec2 p01 = p0 - p1;\n    vec2 p12 = p1 - p2;\n    vec2 p012 = p01 + p12;\n    vec2 p012_2 = p012 * 0.5;\n    vec2 p012_3 = p012_2 * 0.5;\n    vec2 p012_4 = p012_3 * 0.5;\n    vec2 p012_5 = p012_4 * 0.5;\n    vec2 p012_6 = p012_5 * 0.5;\n    vec2 p012_7 = p012_6 * 0.5;\n    vec2 p012_8 = p012_7 * 0.5;\n    vec2 p012_9 = p012_8 * 0.5;\n    vec2 p012_10 = p012_9 * 0.5;\n    vec2 p012_11 = p012_10 * 0.5;\n    vec2 p012_12 = p012_11 * 0.5;\n    vec2 p012_13 = p012_12 * 0.5;\n    vec2 p012_14 = p012_13 * 0.5;\n    vec2 p012_15 = p012_14 * 0.5;\n    vec2 p012_16 = p012_15 * 0.5;\n    vec2 p012_17 = p012_16 * 0.5;\n    vec2 p012_18 = p012_17 * 0.5;\n    vec2 p012_19 = p012_18 * 0.5;\n    vec2 p012_20 = p0", "\n    vec3 min = vec3( min( min( p0.x, p1.x ), p2.x ), min( min( p0.y, p1.y ), p2.y ), min( min( p0.z, p1.z ), p2.z ) );\n    vec3 max = vec3( max( max( p0.x, p1.x ), p2.x ), max( max( p0.y, p1.y ), p2.y ), max( max( p0.z, p1.z ), p2.z ) );\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 min = vec3( min( a.x, b.x ), min( a.y, b.y ), min( a.z, b.z ) );\n    vec3 max = vec3( max( a.x, b.x ), max( a.y, b.y ), max( a.z, b.z ) );\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://www.iquilezles.org/www/articles/conecone/conecone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 min", "\n    vec2 p01 = p0 + (p1 - p0) * 0.5;\n    vec2 p12 = p1 + (p2 - p1) * 0.5;\n    vec2 p23 = p2 + (p3 - p2) * 0.5;\n    vec2 p30 = p3 + (p0 - p3) * 0.5;\n\n    vec2 p012 = p01 + (p12 - p01) * 0.5;\n    vec2 p123 = p12 + (p23 - p12) * 0.5;\n    vec2 p230 = p23 + (p30 - p23) * 0.5;\n    vec2 p301 = p30 + (p01 - p30) * 0.5;\n\n    vec2 p0123 = p012 + (p123 - p012) * 0.5;\n    vec2 p1230 = p123 + (p230 - p123) * 0.5;\n    vec2 p2301 = p230 + (p301 - p230) * 0.5;\n    vec2 p3012 = p301 + (p012 - p301) * 0.5;\n\n    vec2 p01230 = p0123 + (p1230 - p0123) * 0.5;\n    vec2 p12301 = p1230 + (p2301 - p1230) * 0.5;\n    vec2 p23012 = p2301 + (p3012 - p2301) * 0.5;\n    vec2 p30123 = p3012 + (p0123 - p3012) * 0.5;\n\n    vec2 p012301", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return mix(p0123, p123, 0.5);\n}\n\n// fast, do not use in production.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, float t)\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return mix(p0123, p123, 0.5);\n}\n\n// fast, do not use in production.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p0", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross( rd, v0v2 );\n    float det = dot( v0v1, pvec );\n\n    if( abs( det ) < EPS )\n        return vec3( -1.0 );\n\n    vec3 tvec = ro - v0;\n    float u = dot( tvec, pvec );\n    if( u < 0.0 || u > det )\n        return vec3( -1.0 );\n\n    vec3 qvec = cross( tvec, v0v1 );\n    float v = dot( rd, qvec );\n    if( v < 0.0 || u + v > det )\n        return vec3( -1.0 );\n\n    float t = dot( v0v2, qvec );\n    return vec3( t, u / det, v / det );\n}\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross( rd, v0v2 );\n    float det = dot( v0v1, pvec );\n\n    if( abs( det ) < EPS )\n        return vec3( -1.0 );\n\n    vec3 tvec = ro - v0;\n    float u = dot( tvec, pvec );\n    if( u < 0.0 || u > det )\n        return vec3( -1.0 );\n\n    vec3 qvec = cross( tvec, v0v1 );\n    float v = dot( rd, qvec );\n    if( v < 0.0 || u + v > det )\n        return vec3( -1.0 );\n\n    float t = dot( v0v2, qvec", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross(nor, v0v2);\n    float det = dot(v0v1, pvec);\n    if( det == 0.0 )\n        return 0.0;\n\n    vec3 tvec = pos - v0;\n    float u = dot(tvec, pvec);\n    if( u < 0.0 || u > det )\n        return 0.0;\n\n    vec3 qvec = cross(tvec, v0v1);\n    float v = dot(nor, qvec);\n    if( v < 0.0 || u + v > det )\n        return 0.0;\n\n    return 1.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 v0v3 = v3 - v0;\n    vec3 pvec = cross(nor, v0v2);\n    float det = dot(v0v1, pvec);\n    if( det == 0.0 )\n        return 0.0;\n\n    vec3 tvec = pos - v0;\n    float u = dot(tvec, pvec);\n    if( u < 0.0 || u > det )\n        return 0.0;\n\n    vec3 qvec = cross(tvec, v0v1);\n    float v = dot(nor, qvec);\n    if( v < 0.0 || u + v > det )\n        return 0.0;\n\n    vec3 rvec = cross(tvec, v0v3);\n    float w = dot(nor, rvec);\n    if( w < 0.0 || u + v + w > det )\n        return", "\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    float h = clamp( dot(p,ab)/dot(ab,ab), 0.0, 1.0 );\n    float k = clamp( dot(p,bc)/dot(bc,bc), 0.0, 1.0 );\n    return length( mix( mix( p, ab, h ), mix( bc, ab+bc, k ), k ) );\n}\n\n// signed distance to a cubic bezier\nfloat sdCubicBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    vec2 cd = D - C;\n    float h = clamp( dot(p,ab)/dot(ab,ab), 0.0, 1.0 );\n    float k = clamp( dot(p,bc)/dot(bc,bc), 0.0, 1.0 );\n    float m = clamp( dot(p,cd)/dot(cd,cd), 0.0, 1.0 );\n    return length( mix( mix( mix( p, ab, h ), mix( bc, ab+bc, k ), m ), mix( cd, ab+bc+cd, m ), k ) );\n}\n\n// signed distance to a cubic bezier\nfloat sdCubicBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D, in vec2 E )\n{\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    vec2 cd = D - C;\n    vec2 de = E - D;\n    float h = clamp( dot(p,ab)/dot(ab,ab), 0.0, 1.0 );\n    float k = clamp( dot", "\n    vec2 d = abs(p) - vec2(r1,r2);\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - he;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidX( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 d = abs(p) - vec2(r1,r2);\n    return length(max(d,vec2(0.0))) + min(max(d.y,d.x),0.0) - he;\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoidY( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 d = abs(p) - vec2(r1,r2);\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - he;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidX( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 d = abs(p) - vec2(r1,r2);\n    return length(max(d,vec2(0.0))) + min(max(d.y,d.x),0.0) - he;\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoidY( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 d = abs(p) - vec2(r1,r2);\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - he;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidX( in ve", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - ( ra + rb );\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoidCone( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float h )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h2 ) - ( ra + rb + h );\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoidCone( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float h, float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h2 ) - ( ra + rb + h + r );\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoidCone( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float h, float r, float r2 )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h2 ) - ( ra + rb + h + r + r2 );\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoidCone( in vec2 p, in vec2", "\n    vec2 e = vec2( 1.0, -1.0 ) * 0.5773 * 0.0005;\n    return normalize( e.xyy * \n        vec3( \n            texture( iChannel0, pos.yzx ).x - pos.x,\n            texture( iChannel0, pos.yxx ).x - pos.x,\n            texture( iChannel0, pos.yzy ).x - pos.x\n        ) + \n        e.yxy * \n        vec3( \n            texture( iChannel0, pos.zzy ).x - pos.x,\n            texture( iChannel0, pos.zzx ).x - pos.x,\n            texture( iChannel0, pos.zyx ).x - pos.x\n        ) + \n        e.yyx * \n        vec3( \n            texture( iChannel0, pos.zyy ).x - pos.x,\n            texture( iChannel0, pos.zxx ).x - pos.x,\n            texture( iChannel0, pos.zzy ).x - pos.x\n        ) + \n        e.yxy * \n        vec3( \n            texture( iChannel0, pos.xzy ).x - pos.x,\n            texture( iChannel0, pos.xxz ).x - pos.x,\n            texture( iChannel0, pos.xyx ).x - pos.x\n        ) + \n        e.yyx * \n        vec3( \n            texture( iChannel0, pos.xzy ).x - pos.x,\n            texture( iChannel0, pos.xxz ).x - pos.x,\n            texture( iChannel0, pos.xyy ).x - pos.x\n        ) + \n        e.yxy * \n        vec3( \n            texture( iChannel0, pos.xzy ).x - pos.x,\n            texture( iChannel0, pos.xxz ).x - pos.x,\n            texture( iChannel0, pos.xyz ).x - pos.x\n        ) + \n        e.yyx * \n        vec3( \n            texture(", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, k*h/t );\n        t += h;\n        if( h<0.002 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 0.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += h;\n        t += h;\n        if( h<0.002 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k )\n{\n    float res = 0.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += k*h/t;\n        t += h;\n        if( h<0.002 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k, float bias )\n{\n    float res = 0.0;\n    float t = tmin;\n    for( int i=0; i<5", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// 2D Perlin noise\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = hash( i + ivec2( 0, 0 ) );\n    float b = hash( i + ivec2( 1, 0 ) );\n    float c = hash( i + ivec2( 0, 1 ) );\n    float d = hash( i + ivec2( 1, 1 ) );\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 coorners porcentages\n    return mix( a, b, u.x ) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 3D Perlin noise\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    // Four corners in 3D of a tile\n    float a = hash( i + ivec3( 0, 0, 0 ) );\n    float b = hash( i + ivec3( 1, 0, 0 ) );\n    float c = hash( i + ivec3( 0, 1, 0 ) );\n    float d = hash( i + ivec3( 1, 1, 0 ) );\n    float e = hash( i + ivec3( 0, 0, 1 ) );\n    float f = hash( i + ivec3( 1, 0, 1 ) );\n    float g = hash( i + ivec3( 0, 1, 1 ) );\n    float h", "\n    vec2 i = floor( x );\n    vec2 f = fract( x );\n    f = f*f*(3.0-2.0*f);\n    float n = mix( mix( dot( i, vec2(1.0,0.0) ), dot( i, vec2(0.0,1.0) ), f.x ),\n                   mix( dot( i+vec2(1.0,0.0), vec2(1.0,0.0) ),\n                        dot( i+vec2(0.0,1.0), vec2(1.0,0.0) ), f.x ), f.y );\n    return mix( n, n+1.0, abs(f.y-0.5) );\n}\n\n// 2D Perlin noise\nfloat perlin( in vec2 x, in int p )\n{\n    vec2 i = floor( x );\n    vec2 f = fract( x );\n    f = f*f*(3.0-2.0*f);\n    float n = mix( mix( dot( i, vec2(1.0,0.0) ), dot( i, vec2(0.0,1.0) ), f.x ),\n                   mix( dot( i+vec2(1.0,0.0), vec2(1.0,0.0) ),\n                        dot( i+vec2(0.0,1.0), vec2(1.0,0.0) ), f.x ), f.y );\n    return mix( n, n+1.0, abs(f.y-0.5) );\n}\n\n// 3D Perlin noise\nfloat perlin( in vec3 x, in int p )\n{\n    vec3 i = floor( x );\n    vec3 f = fract( x );\n    f = f*f*(3.0-2.0*f);\n    float n = mix( mix( mix( dot( i, vec3(1.0,0.0,0.0) ), dot( i, vec3(0.0,1.0,0.0) ), f", "\n    float f = 0.0;\n    float a = 1.0;\n    float r = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        x *= 2.0;\n        a *= 0.5;\n        r *= 0.5;\n    }\n    return f / a;\n}\n\nfloat fbm( in vec2 x, in int p, in float scale )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float r = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x * scale );\n        x *= 2.0;\n        a *= 0.5;\n        r *= 0.5;\n    }\n    return f / a;\n}\n\nfloat fbm( in vec3 x, in int p )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float r = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        x *= 2.0;\n        a *= 0.5;\n        r *= 0.5;\n    }\n    return f / a;\n}\n\nfloat fbm( in vec3 x, in int p, in float scale )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float r = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x * scale );\n        x *= 2.0;\n        a *= 0.5;\n        r *= 0.5;\n    }\n    return f / a;\n}\n\nfloat fbm( in vec4 x, in int p )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float r = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n       ", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic sphere - approximated distance: https://www.shadertoy.com/view/4dS3zK\nfloat sdSphere( in vec3 p, in float r ) \n{\n    return length(p) - r;\n}\n\n// generic cylinder - approximated distance: https://www.shadertoy.com/view/4dS3zK\nfloat sdCylinder( in vec3 p, in vec2 h ) \n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// generic cone - approximated distance: https://www.shadertoy.com/view/4dS3zK\nfloat sdCone( in vec3 p, in vec2 h ) \n{\n    float q = length(p.xz);\n    return (q-h.x)*(q+h.x) / (2.0*h.y) + h.y;\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/4dS3zK\nfloat sdTorus( in vec3 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q) - t.y;\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/4dS3zK\nfloat sdTorusKnot( in vec3 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q) - t.y;\n}\n\n// generic torus", "\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q-r) - r.x;\n}\n\n// symmetric ellipsoid - EXACT distance from a point to the closest point on the ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec2 r ) \n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q-r) - r.x;\n}\n\n// symmetric ellipsoid - EXACT distance from a point to the closest point on the ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec2 r, in vec2 s ) \n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q-r)-s.x;\n}\n\n// symmetric ellipsoid - EXACT distance from a point to the closest point on the ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec2 r, in vec2 s, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q-r)-s.x;\n}\n\n// symmetric ellipsoid - EXACT distance from a point to the closest point on the ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec2 r, in vec2 s, in vec2 t, in vec2 u ) \n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q-r)-s.x;\n}\n\n// symmetric ellipsoid - EXACT distance from a point to the closest point on the ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec2 r, in vec2 s, in vec2 t, in vec2 u, in vec2 v ) \n{\n    vec2 q = vec2(length(p.", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Bad2( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Bad3( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Bad4( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Bad5( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic sphere - improved approximated distance\nfloat sdSphere( in vec3 p, in vec3 s ) \n{\n    return length(p) - s.x;\n}\n\n// generic cylinder - improved approximated distance\nfloat sdCylinder( in vec3 p, in vec3 c ) \n{\n    vec3 q = vec3(length(p.xz)-c.x,p.y,length(p.yz)-c.y);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic cone - improved approximated distance\nfloat sdCone( in vec3 p, in vec3 c ) \n{\n    vec3 q = vec3(length(p.xz)-c.x,p.y,length(p.yz)-c.y);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - c.z;\n}\n\n// generic torus - improved approximated distance\nfloat sdTorus( in vec3 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - t.y;\n}\n\n// generic torus - improved approximated distance\nfloat sdTorusKnot( in vec3 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - t.y;\n}", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2", "\n    return a + ( 1.0 - a ) * pow( 1.0 - x, 5.0 );\n}\n\n// Schlick approximation of the Fresnel reflectance function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float a, float x )\n{\n    return a + ( 1.0 - a ) * pow( 1.0 - x, 5.0 );\n}\n\n// Schlick approximation of the Fresnel reflectance function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_schlick( float a, float x )\n{\n    return a + ( 1.0 - a ) * pow( 1.0 - x, 5.0 );\n}\n\n// Schlick approximation of the Fresnel reflectance function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_schlick_roughness( float a, float x, float roughness )\n{\n    return a + ( 1.0 - a ) * pow( 1.0 - x, 5.0 ) * ( 1.0 - roughness );\n}\n\n// Schlick approximation of the Fresnel reflectance function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_schlick_roughness_roughness( float a, float x, float roughness )\n{\n    return a + ( 1.0 - a ) * pow( 1.0 - x, 5.0 ) * ( 1.0 - roughness );\n}\n\n// Schlick approximation of the Fresnel reflectance function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_schlick_roughness", "\n    return (x - floor(x)) / p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return abs(fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return (fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased sawtooth wave\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x)) / p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return abs(fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return (fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased sawtooth wave\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x)) / p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return abs(fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return (fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased sawtooth wave\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x)) / p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return abs(fmod(x, 2.0) - 1.0) / p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return (fmod(x, 2.0) - 1.0) / p;\n}\n\n// bi", "\n    float a = h * 1.5707963267948966192313216916398;\n    float b = h * 3.1415926535897932384626433832795;\n    float c = h * 0.52359877559829887307710723054624;\n    float d = h * 1.0471975511965977461542144610934;\n    float e = h * 1.4142135623730950488016887242097;\n    float f = h * 2.8284271247461900950904132708850;\n    float g = h * 4.2426406871192851464109324715490;\n    float h = h * 5.6568542494923811440841647263354;\n    float i = h * 7.0710678118654752440084900629040;\n    float j = h * 8.4852813733333333333333333333333;\n    float k = h * 9.9004035314049513574014934236602;\n    float l = h * 1.1316326530612244897959156289254;\n    float m = h *", "\n    vec3 oc = pa - ro;\n    vec3 ab = pb - pa;\n    float b = dot(ab, ab);\n    float c = dot(oc, ab) * dot(oc, ab);\n    float h = clamp( dot(oc, oc) - r*r / b, 0.0, 1.0 );\n    float d = sqrt( b*b - c );\n    return h / d;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCone( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r1, in float r2 )\n{\n    vec3 oc = pa - ro;\n    vec3 ab = pb - pa;\n    float b = dot(ab, ab);\n    float c = dot(oc, ab) * dot(oc, ab);\n    float h = clamp( dot(oc, oc) - (r1*r1 / b) - (r2*r2 / b), 0.0, 1.0 );\n    float d = sqrt( b*b - c );\n    return h / d;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3 oc = pa - ro;\n    vec3 ab = pb - pa;\n    float b = dot(ab, ab);\n    float c = dot(oc, ab) * dot(oc, ab);\n    float h = clamp( dot(oc, oc) - r*r / b, 0.0, 1.0 );\n    float d = sqrt( b*b - c );\n    return h / d;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCone2( in vec3", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float h = clamp(dot(ab, ap), 0.0, length(ab));\n    float d = length(ap - ab * h / length(ab));\n    float r = (ra + rb) * 0.57735026918962576451;\n    return max(r - d, 0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float h = clamp(dot(ab, ap), 0.0, length(ab));\n    float d = length(ap - ab * h / length(ab));\n    float r = (ra + rb) * 0.57735026918962576451;\n    return max(r - d, 0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float h = clamp(dot(ab, ap), 0.0, length(ab));\n    float d = length(ap - ab * h / length(ab));\n    float r = (ra + rb) * 0.57735026918962576451;\n    return max(r - d, 0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone2(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n   ", "\n    float d = distance( a, b );\n    float t = ( d - r ) / k;\n    if( t < 0.0 ) return 1.0;\n    return 1.0 - smoothstep( 0.0, 1.0, t );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k )\n{\n    float d = distance( a, b );\n    float t = ( d - r ) / k;\n    if( t < 0.0 ) return 1.0;\n    return 1.0 - smoothstep( 0.0, 1.0, t );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k )\n{\n    float d = distance( a, b );\n    float t = ( d - r ) / k;\n    if( t < 0.0 ) return 1.0;\n    return 1.0 - smoothstep( 0.0, 1.0, t );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k )\n{\n    float d = distance( a, b );\n    float t = ( d - r ) / k;\n    if( t < 0.0 ) return 1.0;\n    return 1.0 - smoothstep( 0.0, 1.0, t );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k )\n{\n    float d = distance( a, b );\n    float t = ( d - r ) / k;\n    if( t < 0.0 ) return 1.0;\n    return 1.0 - smoothstep( ", "\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = rad1 + (rad2 - rad1) * (1.0 - smoothstep(0.0, 1.0, d / rad1));\n    float s = smoothstep(rad1, rad2, d);\n    float t = smoothstep(rad2, rad1, d);\n    float a1 = a - 0.5 * th * s;\n    float a2 = a + 0.5 * th * t;\n    return vec2(cos(a1), sin(a1)) * r + vec2(cos(a2), sin(a2)) * r;\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n * amp: Amplitude of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th, float amp)\n{\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = rad1 + (rad2 - rad1) * (1.0 - smoothstep(0.0, 1.0, d / rad1));\n    float s = smoothstep(rad1, rad2, d);\n    float t = smoothstep(rad2, rad1, d);\n    float a1 = a - 0.5 * th * s;\n    float a2 = a + 0.5 * th * t;\n    return vec2(cos(a1), sin(a1)) * r + vec2(cos(a2), sin(a2)) * r + amp * vec2(cos(a1), sin(a1)) * amp;\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs", "\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius.\nfloat sdPie2( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius.\nfloat sdPie3( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius.\nfloat sdPie4( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius.\nfloat sdPie5( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius.\nfloat sdPie6( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius.\nfloat sdPie7( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( dot(p,c), p.y );\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius", "\n    vec3 p = pos;\n    vec3 p2 = p*p;\n    vec3 p3 = p2*p;\n    vec3 p4 = p3*p;\n    vec3 p5 = p4*p;\n    vec3 p6 = p5*p;\n    vec3 p7 = p6*p;\n    vec3 p8 = p7*p;\n    vec3 p9 = p8*p;\n    vec3 p10 = p9*p;\n    vec3 p11 = p10*p;\n    vec3 p12 = p11*p;\n    vec3 p13 = p12*p;\n    vec3 p14 = p13*p;\n    vec3 p15 = p14*p;\n    vec3 p16 = p15*p;\n    vec3 p17 = p16*p;\n    vec3 p18 = p17*p;\n    vec3 p19 = p18*p;\n    vec3 p20 = p19*p;\n    vec3 p21 = p20*p;\n    vec3 p22 = p21*p;\n    vec3 p23 = p22*p;\n    vec3 p24 = p23*p;\n    vec3 p25 = p24*p;\n    vec3 p26 = p25*p;\n    vec3 p27 = p26*p;\n    vec3 p28 = p27*p;\n    vec3 p29 = p28*p;\n    vec3 p30 = p29*p;\n    vec3 p31 = p30*p;\n    vec3 p32 = p31*p;\n    vec3 p33 = p32*p;\n    vec3 p34 = p33*p;\n    vec3 p35 = p34*p;\n    vec3 p36 = p3", "\n    vec2 q = p - sca * ra;\n    float d = dot( q, q );\n    float r = rb * rb;\n    return sqrt( max( d - r, 0.0 ) ) - rb;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc )\n{\n    vec2 q = p - sca * ra;\n    float d = dot( q, q );\n    float r = rb * rb;\n    float r2 = rc * rc;\n    return sqrt( max( d - r, 0.0 ) ) - rc;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc, in float rd )\n{\n    vec2 q = p - sca * ra;\n    float d = dot( q, q );\n    float r = rb * rb;\n    float r2 = rc * rc;\n    float r3 = rd * rd;\n    return sqrt( max( d - r, 0.0 ) ) - rd;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc, in float rd, in float re )\n{\n    vec2 q = p - sca * ra;\n    float d = dot( q, q );\n    float r = rb * rb;\n    float r2 = rc * rc;\n    float r3 = rd * rd;\n    float r4 = re * re;\n    return sqrt", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 0.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += h;\n        t += clamp( h, 0.02, 0.10 );\n        if( res>0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 0.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += h;\n        t += clamp( h, 0.02, 0.10 );\n        if( res>0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        sdfSphere( pos, 0.5, time ) - sdfSphere( pos - eps.xyy, 0.5, time ),\n        sdfSphere( pos, 0.5, time ) - sdfSphere( pos - eps.yxy, 0.5, time ),\n        sdfSphere( pos, 0.5, time ) - sdfSphere( pos - eps.yyx, 0.5, time ) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdfBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\nfloat sdfCylinder( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdfCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    float d = length(p-a) - r;\n    float d2 = length(p-b) - r;\n    return min(d,d2);\n}\n\nfloat sdfCone( in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2 )\n{\n    vec3 pa = p - a, ba = b - a;\n   ", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.1 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 0.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += h;\n        t += clamp( h, 0.02, 0.1 );\n        if( res>0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow2( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 0.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += h;\n        t += clamp( h, 0.02, 0.1 );\n        if( res>0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmsh", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(dpdx,q) + dot(dpdy,q);\n    return 0.25*(1.0+cos(f*5.0+g*10.0))*(1.0+cos(f*5.0+g*10.0))*(1.0+cos(f*5.0+g*10.0))*(1.0+cos(f*5.0+g*10.0));\n}\n\nfloat checkers( in vec2 p )\n{\n    return checkersGradBox(p, dFdx(p), dFdy(p));\n}\n\nfloat checkers( in vec3 p )\n{\n    return checkersGradBox(p.xy, dFdx(p.xy), dFdy(p.xy));\n}\n\nfloat checkers( in vec4 p )\n{\n    return checkersGradBox(p.xy, dFdx(p.xy), dFdy(p.xy));\n}\n\nfloat checkers( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    return checkersGradBox(p, dpdx, dpdy);\n}\n\nfloat checkers( in vec3 p, in vec3 dpdx, in vec3 dpdy )\n{\n    return checkersGradBox(p.xy, dpdx, dpdy);\n}\n\nfloat checkers( in vec4 p, in vec4 dpdx, in vec4 dpdy )\n{\n    return checkersGradBox(p.xy, dpdx, dpdy);\n}\n\nfloat checkers( in vec2 p, in vec2 dpdx, in vec2 dpdy, in vec2 ddpdx, in vec2 ddpdy )\n{\n    return checkersGradBox(p, dpdx, dpdy) + checkersGradBox(p, ddpdx, ddpdy);\n}\n\nfloat checkers( in vec3 p, in vec", "\n    return 1.0 - abs( x - floor( x / k ) );\n}\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2D functions\n//\n\n//\n// 2", "\n    vec3 sky_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 view_dir = normalize(sample_pos - light_dir_norm);\n    float cos_theta = dot(light_dir_norm, view_dir);\n    float cos_theta_sq = cos_theta * cos_theta;\n    float cos_theta_sq_inv = 1.0 - cos_theta_sq;\n    float cos_theta_sq_inv_sq = cos_theta_sq_inv * cos_theta_sq_inv;\n    float cos_theta_sq_inv_sq_inv = cos_theta_sq_inv_sq * cos_theta_sq_inv_sq;\n    float cos_theta_sq_inv_sq_inv_inv = cos_theta_sq_inv_sq_inv * cos_theta_sq_inv_sq_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv * cos_theta_sq_inv_sq_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 light_ambient = vec3(0.0, 0.0, 0.0);\n    vec3 light_diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 light_specular = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_dir = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_color = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_attenuation = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_ambient = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_specular = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_cutoff = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_outercutoff = vec3(0.0, 0.0, 0.0);\n\n    vec3 light_spot_cutoff_color = vec3(0.0, 0.0, 0.0);\n    vec3 light_spot_outercutoff_color = vec3(0.0, 0.0, 0.0);\n\n    vec3 light_spot", "\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (2.0 * (coord.x / resolution.x) - 1.0) * resolution.x / resolution.y;\n    camera_vector.y = (1.0 - 2.0 * (coord.y / resolution.y));\n    camera_vector.z = -1.0;\n    return normalize(camera_vector);\n}\n\n/*\nthe ray direction is the camera vector times the lens radius\n*/\nvec3 get_ray_direction(vec3 camera_vector, float lens_radius) {\n    return normalize(camera_vector - lens_radius * get_camera_vector(resolution, coord));\n}\n\n/*\nthe ray origin is the camera position\n*/\nvec3 get_ray_origin(vec3 camera_vector) {\n    return camera_vector;\n}\n\n/*\nthe ray direction is the camera vector times the lens radius\n*/\nvec3 get_ray_direction(vec3 camera_vector, float lens_radius) {\n    return normalize(camera_vector - lens_radius * get_camera_vector(resolution, coord));\n}\n\n/*\nthe ray origin is the camera position\n*/\nvec3 get_ray_origin(vec3 camera_vector) {\n    return camera_vector;\n}\n\n/*\nthe ray direction is the camera vector times the lens radius\n*/\nvec3 get_ray_direction(vec3 camera_vector, float lens_radius) {\n    return normalize(camera_vector - lens_radius * get_camera_vector(resolution, coord));\n}\n\n/*\nthe ray origin is the camera position\n*/\nvec3 get_ray_origin(vec3 camera_vector) {\n    return camera_vector;\n}\n\n/*\nthe ray direction is the camera vector times the lens radius\n*/\nvec3 get_ray_direction(vec3 camera_vector, float lens_radius) {\n    return normalize(camera_vector - lens_radius * get_camera_vector(resolution, coord));\n}\n\n/*\nthe ray origin is the camera position\n*/\nvec3 get_ray_origin(vec3 camera", "\n    vec2 q = vec2(length(p.xz), p.y);\n    float d = length(q) - ra;\n    float a = atan(q.y, q.x);\n    float b = acos(clamp(p.z / ra, -1.0, 1.0));\n    return d * cos(b) * sin(a);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra, float rb)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d = length(q) - ra;\n    float a = atan(q.y, q.x);\n    float b = acos(clamp(p.z / ra, -1.0, 1.0));\n    return d * cos(b) * sin(a) - (rb - ra) * sin(b);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone2(vec3 p, vec2 c, float ra, float rb)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d = length(q) - ra;\n    float a = atan(q.y, q.x);\n    float b = acos(clamp(p.z / ra, -1.0, 1.0));\n    return d * cos(b) * sin(a) - (rb - ra) * sin(b) - 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 1) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (material == 2) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    if (material == 3) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    if (material == 4) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    if (material == 5) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 6) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 7) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 8) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 9) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 10) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 11) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 12) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 13) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 14) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 15) {\n       ", "\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 0.9;\n    }\n    if (material == 2) {\n        return 0.9;\n    }\n    if (material == 3) {\n        return 0.9;\n    }\n    if (material == 4) {\n        return 0.9;\n    }\n    if (material == 5) {\n        return 0.9;\n    }\n    if (material == 6) {\n        return 0.9;\n    }\n    if (material == 7) {\n        return 0.9;\n    }\n    if (material == 8) {\n        return 0.9;\n    }\n    if (material == 9) {\n        return 0.9;\n    }\n    if (material == 10) {\n        return 0.9;\n    }\n    if (material == 11) {\n        return 0.9;\n    }\n    if (material == 12) {\n        return 0.9;\n    }\n    if (material == 13) {\n        return 0.9;\n    }\n    if (material == 14) {\n        return 0.9;\n    }\n    if (material == 15) {\n        return 0.9;\n    }\n    if (material == 16) {\n        return 0.9;\n    }\n    if (material == 17) {\n        return 0.9;\n    }\n    if (material == 18) {\n        return 0.9;\n    }\n    if (material == 19) {\n        return 0.9;\n    }\n    if (material == 20) {\n        return 0.9;\n    }\n    if (material == 21) {\n        return 0.9;\n    }\n    if (material == 22) {\n        return 0.9;\n    }\n    if (material == 23) {\n        return 0.9;\n    }\n    if (material == 24) {\n        return 0.9;", "\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 0.0;\n    }\n    if (material == 2) {\n        return 0.0;\n    }\n    if (material == 3) {\n        return 0.0;\n    }\n    if (material == 4) {\n        return 0.0;\n    }\n    if (material == 5) {\n        return 0.0;\n    }\n    if (material == 6) {\n        return 0.0;\n    }\n    if (material == 7) {\n        return 0.0;\n    }\n    if (material == 8) {\n        return 0.0;\n    }\n    if (material == 9) {\n        return 0.0;\n    }\n    if (material == 10) {\n        return 0.0;\n    }\n    if (material == 11) {\n        return 0.0;\n    }\n    if (material == 12) {\n        return 0.0;\n    }\n    if (material == 13) {\n        return 0.0;\n    }\n    if (material == 14) {\n        return 0.0;\n    }\n    if (material == 15) {\n        return 0.0;\n    }\n    if (material == 16) {\n        return 0.0;\n    }\n    if (material == 17) {\n        return 0.0;\n    }\n    if (material == 18) {\n        return 0.0;\n    }\n    if (material == 19) {\n        return 0.0;\n    }\n    if (material == 20) {\n        return 0.0;\n    }\n    if (material == 21) {\n        return 0.0;\n    }\n    if (material == 22) {\n        return 0.0;\n    }\n    if (material == 23) {\n        return 0.0;\n    }\n    if (material == 24) {\n        return 0.0;", "\n    return material_opacities[material];\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return material_colors[material];\n}\n\n// Get the color of a material.\nvec3 get_material_color_at(vec3 pos) {\n    return get_material_color(get_material_at(pos));\n}\n\n// Get the color of a material.\nvec3 get_material_color_at_with_opacity(vec3 pos) {\n    return get_material_color(get_material_at(pos)) * get_material_opacity(get_material_at(pos));\n}\n\n// Get the color of a material.\nvec3 get_material_color_at_with_opacity(vec3 pos, float opacity) {\n    return get_material_color(get_material_at(pos)) * opacity;\n}\n\n// Get the color of a material.\nvec3 get_material_color_at_with_opacity(vec3 pos, float opacity, float falloff) {\n    return get_material_color(get_material_at(pos)) * opacity * falloff;\n}\n\n// Get the color of a material.\nvec3 get_material_color_at_with_opacity(vec3 pos, float opacity, float falloff, float falloff_power) {\n    return get_material_color(get_material_at(pos)) * opacity * falloff * pow(falloff_power, falloff);\n}\n\n// Get the color of a material.\nvec3 get_material_color_at_with_opacity(vec3 pos, float opacity, float falloff, float falloff_power, float falloff_power_2) {\n    return get_material_color(get_material_at(pos)) * opacity * falloff * pow(falloff_power, falloff) * pow(falloff_power_2, falloff_power_2);\n}\n\n// Get the color of a material.\nvec3 get_material_color_at_with_opacity(vec3 pos, float opacity, float falloff, float falloff_power, float falloff_power_2,", "\n    vec3 v0 = tri_b - tri_a;\n    vec3 v1 = tri_c - tri_a;\n    vec3 v2 = tri_a - line_a;\n    vec3 v3 = line_b - line_a;\n    vec3 v4 = tri_a - line_b;\n    vec3 v5 = line_a - line_b;\n    vec3 v6 = tri_b - line_b;\n    vec3 v7 = line_a - tri_b;\n    vec3 v8 = tri_a - tri_b;\n    vec3 v9 = line_b - tri_b;\n    vec3 v10 = tri_a - tri_c;\n    vec3 v11 = line_a - tri_c;\n    vec3 v12 = tri_b - tri_c;\n    vec3 v13 = line_b - tri_c;\n    vec3 v14 = tri_a - line_c;\n    vec3 v15 = line_a - line_c;\n    vec3 v16 = tri_b - line_c;\n    vec3 v17 = line_a - line_c;\n    vec3 v18 = tri_a - line_a;\n    vec3 v19 = line_b - line_a;\n    vec3 v20 = tri_b - line_a;\n    vec3 v21 = line_a - line_a;\n    vec3 v22 = tri_b - line_b;\n    vec3 v23 = line_a - line_b;\n    vec3 v24 = tri_a - line_b;\n    vec3 v25 = line_a - line_c;\n    vec3 v26 = tri_b - line_c;\n    vec3 v27 = line_a - line_c;\n    vec3 v28 = tri_a - line_c;\n    vec3 v29 = line_a - line_a;\n    vec3 v30 = line_b", "\n    vec3 a = tri_b - tri_a;\n    vec3 b = tri_c - tri_a;\n    return normalize(cross(a, b));\n}\n\n// Given a triangle and a point, compute the barycentric coordinates of that point\n// in the triangle.\nvec3 get_barycentric_coords(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 point) {\n    vec3 a = tri_b - tri_a;\n    vec3 b = tri_c - tri_a;\n    vec3 c = point - tri_a;\n    float d = dot(cross(a, b), c);\n    float e = dot(cross(b, c), a);\n    float f = dot(cross(c, a), b);\n    return vec3(1.0 - (d + e + f) / dot(a, b), d / dot(a, b), e / dot(a, b));\n}\n\n// Given a triangle and a point, compute the barycentric coordinates of that point\n// in the triangle.\nvec3 get_barycentric_coords_2(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 point) {\n    vec3 a = tri_b - tri_a;\n    vec3 b = tri_c - tri_a;\n    vec3 c = point - tri_a;\n    float d = dot(cross(a, b), c);\n    float e = dot(cross(b, c), a);\n    float f = dot(cross(c, a), b);\n    return vec3(1.0 - (d + e + f) / dot(a, b), d / dot(a, b), e / dot(a, b));\n}\n\n// Given a triangle and a point, compute the barycentric coordinates of that point\n// in the triangle.\nvec3 get_barycentric_coords_3(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 point) {\n    vec3 a =", "\n    vec3 camera_direction = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(vec3(0.0, 1.0, 0.0), camera_direction));\n    vec3 camera_up = cross(camera_direction, camera_right);\n\n    return mat3(\n        camera_right.x, camera_up.x, camera_direction.x,\n        camera_right.y, camera_up.y, camera_direction.y,\n        camera_right.z, camera_up.z, camera_direction.z\n    );\n}\n\n// Generate a perspective projection matrix based on the\n// aspect ratio and field of view.\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(fov / 2.0);\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (far + near) / (near - far), -1.0,\n        0.0, 0.0, (2.0 * far * near) / (near - far), 0.0\n    );\n}\n\n// Generate a orthographic projection matrix based on the\n// aspect ratio and the near and far clipping planes.\nmat4 orthographic_matrix(float aspect, float near, float far) {\n    return mat4(\n        2.0 / aspect, 0.0, 0.0, 0.0,\n        0.0, 2.0 / aspect, 0.0, 0.0,\n        0.0, 0.0, 1.0 / (far - near), 0.0,\n        0.0, 0.0, -(far + near) / (far - near), 1.0\n    );\n}\n\n// Generate a view matrix based on the camera position,\n// camera target, and up vector.\nmat4 view_matrix(vec3 camera_position, vec3 camera_target,", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = -1;\n    result.normal = vec3(0, 0, 0);\n    result.material = material_default;\n    result.color = vec3(0, 0, 0);\n    result.texture = texture_default;\n    result.texture_coord = vec2(0, 0);\n    result.texture_scale = vec2(1, 1);\n    result.texture_offset = vec2(0, 0);\n    result.texture_rotation = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction = 0;\n    result.texture_rotation_speed = 0;\n    result.texture_rotation_direction", "\n    float shadow_distance = 1000.0;\n    float shadow_intensity = 0.0;\n    vec3 shadow_ray_origin = ray_origin;\n    vec3 shadow_ray_target = ray_target;\n    for (int i = 0; i < 10; i++) {\n        vec3 intersection_point = intersect_ray_with_scene(shadow_ray_origin, shadow_ray_target);\n        if (intersection_point.x!= -1.0) {\n            shadow_distance = length(intersection_point - shadow_ray_origin);\n            shadow_intensity = 1.0;\n            break;\n        }\n        shadow_ray_origin = shadow_ray_origin + shadow_ray_target * 0.01;\n    }\n    return shadow_intensity;\n}\n\n// Cast a ray from a surface toward the scene's directional light source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray_with_opacity(vec3 ray_origin, vec3 ray_target) {\n    float shadow_distance = 1000.0;\n    float shadow_intensity = 0.0;\n    vec3 shadow_ray_origin = ray_origin;\n    vec3 shadow_ray_target = ray_target;\n    for (int i = 0; i < 10; i++) {\n        vec3 intersection_point = intersect_ray_with_scene(shadow_ray_origin, shadow_ray_target);\n        if (intersection_point.x!= -1.0) {\n            shadow_distance = length(intersection_point - shadow_ray_origin);\n            shadow_intensity = intersection_point.y;\n            break;\n        }\n        shadow_ray_origin = shadow_ray_origin + shadow_ray_target * 0.01;\n    }\n    return shadow_intensity;\n}\n\n// Cast a ray from a surface toward the scene's directional light source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray_with", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat pnoise( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(mix(dot(u, vec2(1.0, 0.0)), dot(u, vec2(0.0, 1.0)), u.y),\n               mix(dot(u, vec2(1.0, 1.0)), dot(u, vec2(1.0, 0.0)), u.y),\n               u.x);\n}\n\n// 3D Perlin noise\nfloat pnoise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix(dot(u, vec3(1.0, 0.0, 1.0)),\n                       dot(u, vec3(1.0, 1.0, 1.0)), u.y),\n                   mix(dot(u, vec3(1.0, 0.0, 0.0)),\n                       dot(u, vec3(0.0, 1.0, 1.0)), u.y), u.z),\n               mix(mix(dot(u, vec3(0.0, 1.0, 1.0)),\n                       dot(u, vec3(1.0, 1.0, 0.0)), u.y),\n                   mix(dot(u, vec3(0.0, 1.0, 0.0)),\n                       dot(u, vec3(1.0, 0.0, 1.0)), u.y), u.z),\n               u.x);\n}\n\n// 4D Perlin noise\nfloat pnoise( in vec4 x )\n{\n    vec4 f = fract(x);\n    vec4 u = f*f*(3.", "\n    return fract(sin(p)*43758.5453);\n}\n\n// Perlin noise\nfloat pnoise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*157.0;\n    return mix(mix(gnoise(n+  0.0), gnoise(n+  1.0), f.x),\n               mix(gnoise(n+157.0), gnoise(n+158.0), f.x), f.y);\n}\n\n// Perlin noise\nfloat pnoise( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*157.0 + i.z*167.0;\n    return mix(mix(mix(gnoise(n+  0.0), gnoise(n+  1.0), f.x),\n                   mix(gnoise(n+157.0), gnoise(n+158.0), f.x), f.y),\n               mix(mix(gnoise(n+167.0), gnoise(n+168.0), f.x),\n                   mix(gnoise(n+319.0), gnoise(n+320.0), f.x), f.y), f.z);\n}\n\n// Perlin noise\nfloat pnoise( in vec4 p )\n{\n    vec4 i = floor(p);\n    vec4 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*157.0 + i.z*167.0 + i.w*168.0;\n    return mix(mix(mix(mix(gnoise(n+  0.0", "\n    return modf(sin(n) * 43758.5453123);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n ) \n{\n    return modf(sin(n) * 43758.5453123);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec2 n ) \n{\n    return modf(sin(n.x*12.9898 + n.y*78.233) * 43758.5453123);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec3 n ) \n{\n    return modf(sin(n.x*12.9898 + n.y*78.233 + n.z*0.1411201) * 43758.5453123);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec4 n ) \n{\n    return modf(sin(n.x*12.9898 + n.y*78.233 + n.z*0.1411201 + n.w*83.445212) * 43758.5453123);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec2 n, float seed ) \n{\n    return modf(sin(n.x*12.9898 + n.y*78.233 + seed) * 43758.5453123);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec3 n, float seed ) \n{\n    return modf(sin(n.x*12.9898 + n.y*78.233 + n.z*0.1411201 + seed) * 43758.5453123);\n}\n\n// float hash copied from Hugo", "\n    return fract(sin(p)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat pnoise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = gnoise(i);\n    float b = gnoise(i + vec2(1.0, 0.0));\n    float c = gnoise(i + vec2(0.0, 1.0));\n    float d = gnoise(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 3D Perlin noise\nfloat pnoise( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Four corners in 3D of a tile\n    float a = gnoise(i);\n    float b = gnoise(i + vec3(1.0, 0.0, 0.0));\n    float c = gnoise(i + vec3(0.0, 1.0, 0.0));\n    float d = gnoise(i + vec3(0.0, 0.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec3 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages", "\n    float f = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        f += a * fbm( x + b, G );\n        x *= G;\n        b += x;\n        a *= G;\n    }\n    return f;\n}\n\n// fbm2d\nfloat fbm2d( in vec2 p, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        f += a * fbm2d( p + b, G );\n        p *= G;\n        b += p;\n        a *= G;\n    }\n    return f;\n}\n\n// fbm3d\nfloat fbm3d( in vec3 p, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        f += a * fbm3d( p + b, G );\n        p *= G;\n        b += p;\n        a *= G;\n    }\n    return f;\n}\n\n// fbm4d\nfloat fbm4d( in vec4 p, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        f += a * fbm4d( p + b, G );\n        p *= G;\n        b += p;\n        a *= G;\n    }\n    return f;\n}\n\n// fbm5d\nfloat fbm5d( in vec5 p, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    for ( int i = 0; i < ", "\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n        pos = p + vec3( 0.0, 0.0, 1.0 );\n    }\n    color = vec3( 0.5 + 0.5 * sin( 10.0 * t ) );\n    return color;\n}\n\n// For a point in the sphere's surface p, return a color based on the solutions of the associate quadratic polynomial\nvec3 getColor2( in vec3 p )\n{\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n        pos = p + vec3( 0.0, 0.0, 1.0 );\n    }\n    color = vec3( 0.5 + 0.5 * sin( 10.0 * t ) );\n    return color;\n}\n\n// For a point in the sphere's surface p, return a color based on the solutions of the associate quadratic polynomial\nvec3 getColor3( in vec3 p )\n{\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n", "\n    vec3 color = vec3(0.0);\n    vec3 p = pb * 0.5 + 0.5;\n    float a = p.x;\n    float b = p.y;\n    float c = p.z;\n    float d = p.w;\n    float t = time * 0.001;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t", "\n    vec4 res = vec4( 1.0 );\n    vec3 q = abs( rd ) - rad;\n    vec3 m = max( q, 0.0 );\n    res.x = min( max( m.x, m.y ), m.z );\n    vec3 n = rd / res.x;\n    vec3 k = ( cen - ro ) * n;\n    vec3 t1 = k - m;\n    vec3 t2 = k + m;\n    res.y = max( max( t1.x, t1.y ), t1.z );\n    res.z = max( max( t2.x, t2.y ), t2.z );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec3 cen, in float rad )\n{\n    return length( p - cen ) - rad;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 cen, in vec3 rad )\n{\n    vec3 d = abs( p - cen ) - rad;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2( length( p.xz ) - t.x, p.y );\n    return length( q ) - t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a,", "\n    vec3 q = cen - ro;\n    float b = dot(q,q);\n    float r = rad.x;\n    if( b > r*r ) return 0.0;\n    r = rad.y;\n    if( b > r*r ) return 0.0;\n    r = rad.z;\n    if( b > r*r ) return 0.0;\n    return 1.0;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec3 cen, in float rad )\n{\n    return length(p-cen) - rad;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 cen, in vec3 rad )\n{\n    vec3 d = abs(p-cen) - rad;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( in vec3 p, in vec3 cen, in vec3 rad )\n{\n    vec3 q = p - cen;\n    return length(vec2(dot(q.xz,q.xz),q.y)) - rad.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec3 cen, in vec2 rad )", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 10.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if (t > tmax || res < 0.01)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 10.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if (t > tmax || res < 0.01)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int", " return fract(sin(seed++) * 1e4); }\n\n// 2D random number generator\nfloat rand2d(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }\n\n// 3D random number generator\nfloat rand3d(vec3 p) { return fract(sin(dot(p, vec3(12.9898, 78.233, 45.123))) * 43758.5453); }\n\n// 4D random number generator\nfloat rand4d(vec4 p) { return fract(sin(dot(p, vec4(12.9898, 78.233, 45.123, 11.234))) * 43758.5453); }\n\n// 2D random number generator\nfloat rand2d(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }\n\n// 3D random number generator\nfloat rand3d(vec3 p) { return fract(sin(dot(p, vec3(12.9898, 78.233, 45.123))) * 43758.5453); }\n\n// 4D random number generator\nfloat rand4d(vec4 p) { return fract(sin(dot(p, vec4(12.9898, 78.233, 45.123, 11.234))) * 43758.5453); }\n\n// 2D random number generator\nfloat rand2d(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }\n", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//", "\n    vec2 d = abs(vec2(length(p.xz)-ra,p.y))-vec2(lb,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus2(vec3 p, float la, float lb, float h, float ra)\n{\n    vec2 d = abs(vec2(length(p.xz)-ra,p.y))-vec2(lb,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus3(vec3 p, float la, float lb, float h, float ra)\n{\n    vec2 d = abs(vec2(length(p.xz)-ra,p.y))-vec2(lb,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus4(vec3 p, float la, float lb, float h, float ra)\n{\n    vec2 d = abs(vec2(length(p.xz)-ra,p.y))-vec2(lb,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus5(vec3 p, float la, float lb, float h, float ra)\n{\n    vec2 d = abs(vec2(length(p.xz)-ra,p.y))-vec2(lb,h);\n    return min(max(d.x,d.y),", "\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length( pa );\n    float y = length( pb );\n    float z = x + y;\n    float w = length( p - vec2( 0.5, 0.5 ) );\n    float d = ( x + y - z ) / z;\n    float s = smoothstep( 0.0, 1.0, d );\n    float f = smoothstep( 0.0, 1.0, band );\n    return vec4( s, s, s, s );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float w ) \n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length( pa );\n    float y = length( pb );\n    float z = x + y;\n    float w = length( p - vec2( 0.5, 0.5 ) );\n    float d = ( x + y - z ) / z;\n    float s = smoothstep( 0.0, 1.0, d );\n    float f = smoothstep( 0.0, 1.0, band );\n    return vec4( s, s, s, s );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float w, float wb ) \n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length( pa );\n    float y = length( pb );\n    float z = x + y;\n    float w = length( p - vec2( 0.5, 0.5 ) );\n    float d =", "\n    vec2 q = abs(p) - b;\n    return vec4( length(max(q,0.0)) - r, \n                 length(max(q,0.0)) - r + s, \n                 length(max(q,0.0)) - r + s + s, \n                 length(max(q,0.0)) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t )\n{\n    vec2 q = abs(p) - b;\n    return vec4( length(max(q,0.0)) - r, \n                 length(max(q,0.0)) - r + s, \n                 length(max(q,0.0)) - r + s + t, \n                 length(max(q,0.0)) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u )\n{\n    vec2 q = abs(p) - b;\n    return vec4( length(max(q,0.0)) - r, \n                 length(max(q,0.0)) - r + s, \n                 length(max(q,0.0)) - r + s + t, \n                 length(max(q,0.0)) - r + s + t + u );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u, in float v )\n{\n    vec2 q = abs(p) - b;\n", "\n    vec2 d = abs(p) - b;\n    return vec3(\n        min(max(d.x,d.y),0.0),\n        max(d.x,max(d.y,-1.0)),\n        max(d.x,d.y)\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSphere( in vec3 p, in float r )\n{\n    return vec3( length(p)-r, dot(p,p)-r*r, dot(p,p)-r*r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCylinder( in vec3 p, in vec2 h )\n{\n    vec2 q = vec2( length(p.xz)-h.x, p.y );\n    return vec3( length(q)-h.y, dot(q,q)-h.y*h.y, dot(q,q)-h.y*h.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCone( in vec3 p, in vec2 h )\n{\n    vec2 q = vec2( length(p.xz)-h.x, p.y );\n    return vec3( length(q)-h.y, dot(q,q)-h.y*h.y, dot(q,q)-h.y*h.y );\n}\n", "\n    vec2 q = p - vec2(0.5);\n    float d = length(q);\n    float a = atan(q.y, q.x);\n    float w = d - r;\n    float b = band;\n    return vec4( w, a, b, d );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRect( in vec2 p, float w, float h, float band ) \n{\n    vec2 q = abs(p) - vec2(w,h);\n    float d = length(max(q,0.0));\n    float a = atan(q.y, q.x);\n    float ww = d - w;\n    float b = band;\n    return vec4( ww, a, b, d );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paEllipse( in vec2 p, float w, float h, float band ) \n{\n    vec2 q = abs(p) - vec2(w,h);\n    float d = length(q);\n    float a = atan(q.y, q.x);\n    float ww = d - w;\n    float b = band;\n    return vec4( ww, a, b, d );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paTriangle( in vec2 p, float w, float h, float band ) \n{\n    vec2 q = abs(p) - vec2(w,h);\n    float d = length(max(q,0.0));\n    float a = atan(q.y, q.x);\n    float ww = d - w;\n    float b = band;\n    return vec4( ww, a, b, d );\n}\n\n// x = local dist\n// y", "\n    vec2 v0 = verts[0];\n    vec2 v1 = verts[1];\n    vec2 v2 = verts[2];\n    vec2 v3 = verts[3];\n    vec2 v4 = verts[4];\n\n    vec2 v01 = v1 - v0;\n    vec2 v02 = v2 - v0;\n    vec2 v03 = v3 - v0;\n    vec2 v04 = v4 - v0;\n\n    vec2 v12 = v1 - v2;\n    vec2 v13 = v3 - v1;\n    vec2 v14 = v4 - v1;\n\n    vec2 v23 = v2 - v3;\n    vec2 v24 = v4 - v2;\n\n    vec2 v34 = v3 - v4;\n\n    vec2 p01 = p - v01;\n    vec2 p02 = p - v02;\n    vec2 p03 = p - v03;\n    vec2 p04 = p - v04;\n\n    vec2 p12 = p - v12;\n    vec2 p13 = p - v13;\n    vec2 p14 = p - v14;\n\n    vec2 p23 = p - v23;\n    vec2 p24 = p - v24;\n\n    vec2 p34 = p - v34;\n\n    float d01 = dot(p01, v01);\n    float d02 = dot(p02, v02);\n    float d03 = dot(p03, v03);\n    float d04 = dot(p04, v04);\n\n    float d12 = dot(p12, v12);\n    float d13 = dot(p13, v13);\n    float d14 = dot(p14, v14);\n\n    float d23 = dot(p23, v23);", "\n    vec2 p0 = verts[0];\n    vec2 p1 = verts[1];\n    vec2 p2 = verts[2];\n    vec2 p3 = verts[3];\n    vec2 p4 = verts[4];\n\n    vec2 p01 = p0 - p1;\n    vec2 p02 = p0 - p2;\n    vec2 p03 = p0 - p3;\n    vec2 p04 = p0 - p4;\n\n    vec2 p12 = p1 - p2;\n    vec2 p13 = p1 - p3;\n    vec2 p14 = p1 - p4;\n\n    vec2 p23 = p2 - p3;\n    vec2 p24 = p2 - p4;\n\n    vec2 p34 = p3 - p4;\n\n    vec2 p012 = p01 + p12;\n    vec2 p013 = p01 + p13;\n    vec2 p014 = p01 + p14;\n\n    vec2 p023 = p02 + p23;\n    vec2 p024 = p02 + p24;\n\n    vec2 p034 = p03 + p34;\n\n    vec2 p123 = p12 + p23;\n    vec2 p124 = p12 + p24;\n\n    vec2 p134 = p13 + p34;\n\n    vec2 p234 = p23 + p34;\n\n    vec2 p0123 = p012 + p123;\n    vec2 p0124 = p012 + p124;\n\n    vec2 p0134 = p013 + p134;\n\n    vec2 p0234 = p023 + p234;\n\n    vec2 p1234 = p123 + p23", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return vec3( a + ba * h, 0.5 + 0.5 * h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    vec2 v3 = cross( v1, v2 );\n    float d00 = dot( v0, v0 );\n    float d01 = dot( v0, v1 );\n    float d11 = dot( v1, v1 );\n    float d20 = dot( v2, v0 );\n    float d21 = dot( v2, v1 );\n    float denom = d00 * d11 - d01 * d01;\n    float v = ( d11 * d20 - d01 * d21 ) / denom;\n    float w = ( d00 * d21 - d01 * d20 ) / denom;\n    float u = 1.0 - v - w;\n    return vec3( a + v * v0 + w * v1 + u * v2, 0.5 * ( v + w ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTetrahedron( in vec2 p, in vec2 a, in vec2 b, in vec2", "\n    vec2 q = vec2( r, 0.0 );\n    vec2 a = vec2( 0.8660254037844386, 0.5 );\n    vec2 b = vec2( 0.5, 0.8660254037844386 );\n    vec2 c = vec2( 0.5773502691896257, 0.5773502691896257 );\n    vec2 d = vec2( 0.5, 0.5 );\n    vec2 e = vec2( 0.5, 0.5773502691896257 );\n    vec2 f = vec2( 0.5773502691896257, 0.5 );\n    vec2 g = vec2( 0.8660254037844386, 0.8660254037844386 );\n    vec2 h = vec2( 0.5773502691896257, 0.8660254037844386 );\n    vec2 i = vec2( 0.8660254037844386, 0.5773502691896257 );\n    vec2 j = vec2( 0.5, 0.5773502691896257 );\n    vec2 k = vec2( 0.5773502691896257, 0.5 );\n    vec2 l = vec2( 0.5773502691896257, 0.8660254037844386 );\n   ", "\n  vec3 dp = p - X[2];\n  float a = dot(dp, dp);\n  float b = dot(dp, X[0]);\n  float c = dot(X[0], X[0]);\n  float d = b*b - a*c;\n  if (d < 0.0) return false;\n  d = sqrt(d);\n  tan1 = (b*dp - X[1]) / d;\n  tan2 = (b*dp + X[1]) / d;\n  return true;\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2, out float d) {\n  vec3 dp = p - X[2];\n  float a = dot(dp, dp);\n  float b = dot(dp, X[0]);\n  float c = dot(X[0], X[0]);\n  d = b*b - a*c;\n  if (d < 0.0) return false;\n  d = sqrt(d);\n  tan1 = (b*dp - X[1]) / d;\n  tan2 = (b*dp + X[1]) / d;\n  return true;\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2, out float d, out float a) {\n  vec3 dp = p - X[2];\n  a = dot(dp, dp);\n  float b = dot(dp, X[0]);\n  float c = dot(X[0], X[0]);\n  d = b*b - a*c;\n  if (d < 0.0) return false;\n  d = sqrt(d);\n  tan1 = (b*dp - X[1]) / d;\n  tan", "\n    return vec3(a.x / b.x, a.y / b.y, a.z / b.z);\n}\n\n//returns the dot product of two vectors\nfloat dot(vec3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\n//returns the cross product of two vectors\nvec3 cross(vec3 a, vec3 b) {\n    return vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\n//returns the length of a vector\nfloat length(vec3 a) {\n    return sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n}\n\n//returns the normalized vector\nvec3 normalize(vec3 a) {\n    return div(a, length(a));\n}\n\n//returns the reflected vector\nvec3 reflect(vec3 a, vec3 b) {\n    return sub(a, mul(mul(b, dot(a, b)), div(b, dot(b, b))));\n}\n\n//returns the refracted vector\nvec3 refract(vec3 a, vec3 b, float n) {\n    float cosi = dot(a, b);\n    float etai = 1.0;\n    float etat = n;\n    vec3 nhat = normalize(b);\n    if (cosi < 0.0) {\n        cosi = -cosi;\n    } else {\n        float temp = etai;\n        etai = etat;\n        etat = temp;\n        nhat = neg(nhat);\n    }\n    float eta = etai / etat;\n    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    if (k < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Transforms a point by a rotation around the Y axis.\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\n// Transforms a point by a rotation around the Z axis.\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}\n\n// Transforms a point by a rotation around the X axis.\nvec3 RotateY(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\n// Transforms a point by a rotation around the Z axis.\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}\n\n// Transforms a point by a rotation around the X axis.\nvec3 RotateY(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\n// Transforms a point by a rotation around the Z axis.\nvec3 RotateZ(vec3 p, float", "\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0 - x / R;\n}\n\n// Cubic falloff\n// x: distance\n//", "\n    float k = (e - 1.0f) / (R * R);\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R)\n{\n    float k = (e - 1.0f) / (R * R);\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float a)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float a, float b)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float a, float b, float c)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float a, float b, float c, float d)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float a, float b, float c, float d, float eps)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float a, float b, float c, float d, float eps, float f)\n{\n    return k;\n}\n\n// Computes the global lipschitz bound", "\n    float k = (a - b) / (1.0f + R * R);\n    return k * k * e;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat Falloff(float a, float b, float R, float e)\n{\n    float k = (a - b) / (1.0f + R * R);\n    return k * k * e;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat Falloff(float a, float b, float R)\n{\n    float k = (a - b) / (1.0f + R * R);\n    return k * k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat Falloff(float a, float b)\n{\n    float k = (a - b) / 2.0f;\n    return k * k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat Falloff(float a)\n{\n    return a * a;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat Falloff(float a, float b, float R, float e, float k)\n{\n    return k * k * e;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat Falloff(float a, float b, float R, float e, float k, float k2)\n{\n    return k * k * k2 * e;\n}", "\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{", "\n    float d = distance(c, a);\n    float d2 = distance(c, b);\n    float r = R * (d + d2) / (d2 - d);\n    return r * r * e;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t)\n{\n    float d = distance(c, a);\n    float d2 = distance(c, b);\n    float r = R * (d + d2) / (d2 - d);\n    return r * r * e * t;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, vec3 t)\n{\n    float d = distance(c, a);\n    float d2 = distance(c, b);\n    float r = R * (d + d2) / (d2 - d);\n    return r * r * e * dot(t, t);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, vec3 t, float t2)\n{\n    float d = distance(c, a);\n    float d2 = distance(c, b);\n    float r = R * (d + d2) / (d2 - d);\n    return r * r * e * t2;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c:", "\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float d = length(p);\n    return d;\n}", "\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k)\n{\n    return length(a - b) / k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d)\n{\n    return length(a - b) / (k * d);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w)\n{\n    return length(a - b) / (k * d * w);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w, float h)\n{\n    return length(a - b) / (k * d * w * h);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w, float h, float t)\n{\n    return length(a - b) / (k * d * w * h * t);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w, float h, float t, float r)\n{\n    return length(a - b) / (k * d * w * h * t * r);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w, float h, float t, float r, float s)\n{\n    return length(a - b) / (k * d * w * h * t * r * s);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w, float h, float t, float r, float s, float u)\n{\n    return length(a - b) / (k * d * w * h * t * r * s * u);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float d, float w, float h, float t, float r, float s, float u, float v)\n{\n   ", "\n    vec3 n = vec3(0.0);\n    n += ObjectNormal(p + vec3(0.0, 0.001, 0.0));\n    n += ObjectNormal(p + vec3(0.0, -0.001, 0.0));\n    n += ObjectNormal(p + vec3(0.001, 0.0, 0.0));\n    n += ObjectNormal(p + vec3(-0.001, 0.0, 0.0));\n    n += ObjectNormal(p + vec3(0.0, 0.0, 0.001));\n    n += ObjectNormal(p + vec3(0.0, 0.0, -0.001));\n    return normalize(n);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evaluate the normal at a point on the surface of the object\nvec3 ObjectNormal(in vec3 p )\n{\n    return vec3(0.0);\n}\n\n// Evalu", "\n    float tmin = 0.0;\n    float tmax = length(o);\n    float t = 0.0;\n    vec3 p = o;\n    vec3 d = u;\n    vec3 n = vec3(0.0);\n    vec3 c = vec3(0.0);\n    vec3 b = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 r = vec3(0.0);\n    vec3 tc = vec3(0.0);\n    vec3 tb = vec3(0.0);\n    vec3 tr = vec3(0.0);\n    vec3 tl = vec3(0.0);\n    vec3 tn = vec3(0.0);\n    vec3 tp = vec3(0.0);\n    vec3 tq = vec3(0.0);\n    vec3 tb1 = vec3(0.0);\n    vec3 tb2 = vec3(0.0);\n    vec3 tb3 = vec3(0.0);\n    vec3 tb4 = vec3(0.0);\n    vec3 tb5 = vec3(0.0);\n    vec3 tb6 = vec3(0.0);\n    vec3 tb7 = vec3(0.0);\n    vec3 tb8 = vec3(0.0);\n    vec3 tb9 = vec3(0.0);\n    vec3 tb10 = vec3(0.0);\n    vec3 tb11 = vec3(0.0);\n    vec3 tb12 = vec3(0.0);\n    vec3 tb13 = vec3(0.0);\n    vec3 tb14 = vec3(0.0);\n    vec3 tb15 = vec3(0.0);\n    vec3 tb16 = vec3(0.0);", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tmid = 0.0;\n    float tstep = 0.0;\n    float tmaxstep = 0.0;\n    float tminstep = 0.0;\n    float tmaxstep2 = 0.0;\n    float tminstep2 = 0.0;\n    float tmaxstep3 = 0.0;\n    float tminstep3 = 0.0;\n    float tmaxstep4 = 0.0;\n    float tminstep4 = 0.0;\n    float tmaxstep5 = 0.0;\n    float tminstep5 = 0.0;\n    float tmaxstep6 = 0.0;\n    float tminstep6 = 0.0;\n    float tmaxstep7 = 0.0;\n    float tminstep7 = 0.0;\n    float tmaxstep8 = 0.0;\n    float tminstep8 = 0.0;\n    float tmaxstep9 = 0.0;\n    float tminstep9 = 0.0;\n    float tmaxstep10 = 0.0;\n    float tminstep10 = 0.0;\n    float tmaxstep11 = 0.0;\n    float tminstep11 = 0.0;\n    float tmaxstep12 = 0.0;\n    float tminstep12 = 0.0;\n    float tmaxstep13 = 0.0;\n    float tminstep13 = 0.0;\n    float tmaxstep14 = 0.0;\n    float tminstep14 = 0.0;\n    float tmaxstep15 = 0.0;\n    float tminstep15 = 0.0;\n    float tmaxstep16 = 0.0;\n    float tminstep16 = 0.0;\n    float tmaxstep17 = 0.0;\n    float tminstep17 = 0.0;\n    float tmaxstep18 = 0.0;\n    float tminstep18 = 0.0;\n    float tmaxstep19 = 0.0", "\n    float t = dot(rd, vec3(0.0, 0.0, 1.0));\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), smoothstep(0.0, 1.0, t));\n}\n\nvec3 Light(vec3 rd, vec3 n, vec3 ld, vec3 lc)\n{\n    float diff = max(0.0, dot(n, ld));\n    vec3 diffuse = diff * lc;\n    vec3 specular = vec3(0.0);\n    if (diff > 0.0)\n    {\n        vec3 v = normalize(vec3(0.0, 0.0, 1.0) - rd);\n        vec3 h = normalize(ld + v);\n        float spec = pow(max(0.0, dot(n, h)), 32.0);\n        specular = spec * lc;\n    }\n    return (diffuse + specular);\n}\n\nvec3 Ambient(vec3 n, vec3 lc)\n{\n    return lc * 0.2;\n}\n\nvec3 Directional(vec3 rd, vec3 n, vec3 ld, vec3 lc)\n{\n    return Light(rd, n, ld, lc);\n}\n\nvec3 Point(vec3 rd, vec3 n, vec3 p, vec3 ld, vec3 lc)\n{\n    vec3 l = p - ld;\n    float d = length(l);\n    l = normalize(l);\n    vec3 v = normalize(rd);\n    float cos = dot(l, v);\n    if (cos > 0.0)\n    {\n        return Light(rd, n, l, lc);\n    }\n    return vec3(0.0);\n}\n\nvec3 Spot(vec3 rd, vec3 n, vec3 p, vec3 ld, vec3 lc", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - (r1 + r2 * clamp(h, 0.0, 1.0));\n}\n\n// arbitrary orientation\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - (r1 + r2 * clamp(h, 0.0, 1.0));\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2, float h)\n{\n    vec3 pa = p - a, ba = b - a;\n    float k = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * k) - (r1 + r2 * clamp(k,", "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / ro;\n    vec3 q2 = q * q;\n    vec3 q3 = q2 * q;\n    vec3 q4 = q3 * q;\n    vec3 q5 = q4 * q;\n    vec3 q6 = q5 * q;\n    vec3 q7 = q6 * q;\n    vec3 q8 = q7 * q;\n    vec3 q9 = q8 * q;\n    vec3 q10 = q9 * q;\n    vec3 q11 = q10 * q;\n    vec3 q12 = q11 * q;\n    vec3 q13 = q12 * q;\n    vec3 q14 = q13 * q;\n    vec3 q15 = q14 * q;\n    vec3 q16 = q15 * q;\n    vec3 q17 = q16 * q;\n    vec3 q18 = q17 * q;\n    vec3 q19 = q18 * q;\n    vec3 q20 = q19 * q;\n    vec3 q21 = q20 * q;\n    vec3 q22 = q21 * q;\n    vec3 q23 = q22 * q;\n    vec3 q24 = q23 * q;\n    vec3 q25 = q24 * q;\n    vec3 q26 = q25 * q;\n    vec3 q27 = q26 * q;\n    vec3 q28 = q27 * q;\n    vec3 q29 = q28 * q;\n    vec3 q30 = q29 * q;\n    vec3 q31 = q30 * q;\n    vec3 q32 = q31 * q;\n    vec3 q33 = q32 * q;\n    vec3 q34 = q33 * q;\n    vec3 q", "\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.0 + 0.5;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    return coord / 2.", "\n    vec2 d = p - q;\n    float l = length(d);\n    return vec3(d, l);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleEquilateral( in vec2 p, in vec2 q )\n{\n    vec2 d = p - q;\n    float l = length(d);\n    return vec3(d, l);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleRight( in vec2 p, in vec2 q )\n{\n    vec2 d = p - q;\n    float l = length(d);\n    return vec3(d, l);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleLeft( in vec2 p, in vec2 q )\n{\n    vec2 d = p - q;\n    float l = length(d);\n    return vec3(d, l);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleUp( in vec2 p, in vec2 q )\n{\n    vec2 d = p - q;\n    float l = length(d);\n    return vec3", "\n    vec2 q = p - vec2(0.5, 0.5);\n    float a = atan(q.y, q.x);\n    float b = length(q);\n    float c = (b - r) / d;\n    return vec3(c, a, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float w)\n{\n    vec2 q = p - vec2(0.5, 0.5);\n    float a = atan(q.y, q.x);\n    float b = length(q);\n    float c = (b - r) / d;\n    return vec3(c, a, w);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float w, float k)\n{\n    vec2 q = p - vec2(0.5, 0.5);\n    float a = atan(q.y, q.x);\n    float b = length(q);\n    float c = (b - r) / d;\n    return vec3(c, a, w) * k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float w, float k, float s)\n{\n    vec2", "\n    vec2 q = vec2( length(p.xy), atan(p.y,p.x) );\n    float a = atan(q.y,q.x) + TAU;\n    float d = length(q);\n    float s = sin(a);\n    float c = cos(a);\n    float t = (d-r)/(d*c);\n    return vec3( c*t, s*t, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a )\n{\n    vec2 q = vec2( length(p.xy), atan(p.y,p.x) );\n    float d = length(q);\n    float s = sin(a);\n    float c = cos(a);\n    float t = (d-r)/(d*c);\n    return vec3( c*t, s*t, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a, in float s )\n{\n    vec2 q = vec2( length(p.xy), atan(p.y,p.x) );\n    float d = length(q);\n    float c = cos(a);\n    float t = (d-r)/(d*c);\n    return vec3( s*t, c*t, 0.", "\n    vec2 b = v[1] - v[0];\n    vec2 c = v[2] - v[0];\n    vec2 a = v[1] - v[0];\n    vec2 n = cross(b, c);\n    float d = dot(n, a);\n    float e = dot(n, p - v[0]);\n    float f = dot(n, v[2] - v[0]);\n    float g = (e + f) / d;\n    float h = (e * f - d * g) / d;\n    float k = (e * g - d * h) / d;\n    return vec3(g, h, k);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 v[3], in float w )\n{\n    vec2 b = v[1] - v[0];\n    vec2 c = v[2] - v[0];\n    vec2 a = v[1] - v[0];\n    vec2 n = cross(b, c);\n    float d = dot(n, a);\n    float e = dot(n, p - v[0]);\n    float f = dot(n, v[2] - v[0]);\n    float g = (e + f) / d;\n    float h = (e * f - d * g) / d;\n    float k = (e * g - d * h) / d;\n    return vec3(g, h, k) * w;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec", "\n    vec2 q = p - sca;\n    float d = length(q);\n    if( d > ra ) return vec3(0.0);\n    float a = acos(q.x/ra);\n    float b = acos(q.y/rb);\n    float s = sin(a);\n    float c = cos(a);\n    float t = sin(b);\n    float u = cos(b);\n    float x = c*s*t;\n    float y = c*s*u;\n    float z = s*t;\n    return vec3(x,y,z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    vec2 q = p - sca;\n    float d = length(q);\n    if( d > ra ) return vec3(0.0);\n    float a = acos(q.x/ra);\n    float b = acos(q.y/rb);\n    float s = sin(a);\n    float c = cos(a);\n    float t = sin(b);\n    float u = cos(b);\n    float x = c*s*t;\n    float y = c*s*u;\n    float z = s*t;\n    return vec3(x,y,z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the", "\n    return dot( a, b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat dcro( in vec2 a, in vec2 b ) {\n    return cro( a, b ) / length( a );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat ddcro( in vec2 a, in vec2 b ) {\n    return cro( a, b ) / cro( a, a );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat dddcro( in vec2 a, in vec2 b ) {\n    return cro( a, b ) / cro( a, cro( a, a ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat ddddcro( in vec2 a, in vec2 b ) {\n    return cro( a, b ) / cro( a, cro( a, cro( a, a ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat dddddcro( in vec2 a, in vec2", "\n    vec2 q = p - ab;\n    vec2 h = max( dot(q,q), dot(q,q) - dot(ab,ab) );\n    return vec3( length(q) - sqrt(h), dot(q,q) - h, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab, in vec2 cd )\n{\n    vec2 q = p - ab;\n    vec2 r = p - cd;\n    vec2 h = max( dot(q,q), dot(q,q) - dot(ab,ab) );\n    vec2 k = max( dot(r,r), dot(r,r) - dot(cd,cd) );\n    return vec3( length(q) - sqrt(h), dot(q,q) - h, length(r) - sqrt(k), dot(r,r) - k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab, in vec2 cd, in vec2 de )\n{\n    vec2 q = p - ab;\n    vec2 r = p - cd;\n    vec2 s = p - de;\n    vec2 h = max( dot(q,q), dot(q,q) - dot(ab,ab) );\n    vec2 k = max( dot(r,r), dot(r,r) - dot(cd,cd) );\n    vec2 l = max( dot(s,s), dot(s,s) - dot(de,de", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(q,length(q)-rb,1.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4(length(p)-r,1.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float r, float h )\n{\n    vec2 d = vec2(length(p.xz)-r,abs(p.y)-h);\n    return vec4(min(max(d.x,d.y),0.0),1.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float r, float h )\n{\n    vec2 d = vec2(length(p.xz)-r,abs(p.y)-h);\n    return vec4(min(max(d.x,d.y),0.0),1.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec3 proj = a + ba * h;\n    return vec4( proj - p, length( pa ) - r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4( p, length( p ) - r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec3 proj = a + ba * h;\n    return vec4( proj - p, length( pa ) - r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, vec3 a, vec3 b, float r )\n{\n    ve", "\n    vec2 q = abs(p);\n    float hh = clamp(q.y, 0.0, he);\n    float ww = clamp(q.x, 0.0, wi);\n    float d = max(hh,ww);\n    return d - (he + wi) * 0.5;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p);\n    float hh = clamp(q.y, 0.0, he);\n    float ww = clamp(q.x, 0.0, wi);\n    float d = max(hh,ww);\n    return d - (he + wi) * 0.5;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p);\n    float hh = clamp(q.y, 0.0, he);\n    float ww = clamp(q.x, 0.0, wi);\n    float d = max(hh,ww);\n    return d - (he + wi) * 0.5;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p);\n    float hh = clamp(q.y, 0.0, he);\n    float ww = clamp(q.x, 0.0, wi);\n    float d = max(hh,ww);\n    return d - (he + wi) * 0.5;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_5( in vec2 p, float wi,", "\n    vec2 q = p - vec2(0.5, 0.5);\n    float d = length(q);\n    float a = atan(q.y, q.x);\n    float r = (wi + he) * 0.5;\n    float s = (wi - he) * 0.5;\n    float c = cos(a);\n    float s2 = sin(a);\n    float t = (d - r) / s;\n    float u = (d + r) / s;\n    float v = (d - s) / t;\n    float w = (d + s) / t;\n    float x = wi * c - he * s2;\n    float y = wi * s2 + he * c;\n    float z = wi * t - he * u;\n    float wz = wi * w - he * v;\n    return vec3(x, y, z) + vec3(0.0, 0.0, wz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, float wi, float he )\n{\n    vec2 q = p - vec2(0.5, 0.5);\n    float d = length(q);\n    float a = atan(q.y, q.x);\n    float r = (wi + he) * 0.5;\n    float s = (wi - he) * 0.5;\n    float c = cos(a);\n    float s2 = sin(a);\n    float t = (d - r) / s;\n    float u = (d + r) / s;\n    float v = (d - s) / t;\n    float w = (d + s) / t;\n    float x = wi * c - he * s2;\n    float y = wi * s2 + he * c;\n    float z = wi * t - he", "\n\t\tfloat r;\n\t\tr = p + c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep2D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep3D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p / c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep4D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p % c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep5D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p ^ c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep6D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p & c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep7D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p | c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep8D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p << c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep9D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p >> c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep10D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p <<< c;\n\t\treturn r;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep11D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p >>> c;\n\t\treturn r;\n\t}\n\n//----------oPer", "\n    return (a < b)? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return (a > b)? a : b;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) {\n    return (a < b)? b : a;\n}\n\n// IQ's polynominal lerp\nfloat plerp(float a, float b, float k) {\n    return a + (b - a) * k;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)? 1.0 : 0.0;\n}\n\n// IQ's polynominal lerp\nfloat pstep(float a, float b, float k) {\n    return (a < b)?", "\n    return mod(p, size) - 0.5 * size;\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_circle\nfloat circle(inout vec2 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_ellipse\nfloat ellipse(inout vec2 p, vec2 r) {\n    return length(p / r) - 1.0;\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_rectangle\nfloat rectangle(inout vec2 p, vec2 r) {\n    vec2 d = abs(p) - r;\n    return length(max(d.x, d.y)) + min(max(d.x, d.y), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_triangle\nfloat triangle(inout vec2 p, vec2 r) {\n    vec2 q = abs(p) - r;\n    return length(max(q.x, q.y)) + min(max(q.x, q.y), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_triangle_rotated\nfloat triangle_rotated(inout vec2 p, vec2 r) {\n    vec2 q = abs(p) - r;\n    return length(max(q.x, q.y)) + min(max(q.x, q.y), 0.0) - 0.5;\n}\n\n// http://mercury.sexy/hg_sdf/vec2_sdf_triangle_rotated_2\nfloat triangle_rotated_2(inout vec2 p, vec2 r) {\n    vec2 q = abs(p) - r;\n    return length(max(q.x, q.y)) + min(max(q.x, q.y), 0.0", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p -", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection with a sphere\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s, vec4 t) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection with a sphere\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s, vec4 t, float r) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection with a sphere\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s, vec4 t, float r, float t0, float t1) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h < 0.0", "\n    vec3 tmin = (boxSize - abs(ro)) / rd;\n    vec3 tmax = (boxSize + abs(ro)) / rd;\n    vec3 t1 = min(tmin, tmax);\n    vec3 t2 = max(tmin, tmax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if (tNear > tFar || tFar < 0.0) {\n        outNormal = vec3(0.0);\n        return vec2(tFar);\n    }\n    outNormal = sign(rd);\n    return vec2(tNear, tFar);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius, out vec3 outNormal )  {\n    vec3 L = ro - center;\n    float tca = dot(L, rd);\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > radius * radius) {\n        outNormal = vec3(0.0);\n        return vec2(tFar);\n    }\n    float thc = sqrt(radius * radius - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) {\n        t0 = t1;\n        if (t0 < 0.0) {\n            outNormal = vec3(0.0);\n            return vec2(tFar);\n        }\n    }\n    outNormal = normalize(L - t0 * rd);\n    return vec2(t0, t1);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec", "\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p", "\n    vec2 v = b - a;\n    vec2 w = p - a;\n    return dot(w, v) / dot(v, v);\n}\n\nfloat boxdist(vec2 p, vec2 a, vec2 b) {\n    vec2 da = a - p;\n    vec2 db = b - p;\n    return max(max(abs(da.x), abs(da.y)), max(abs(db.x), abs(db.y)));\n}\n\nfloat boxdist(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 da = a - p;\n    vec2 db = b - p;\n    vec2 dc = c - p;\n    return max(max(max(abs(da.x), abs(da.y)), abs(db.x)), abs(dc.y));\n}\n\nfloat boxdist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 da = a - p;\n    vec2 db = b - p;\n    vec2 dc = c - p;\n    vec2 dd = d - p;\n    return max(max(max(max(abs(da.x), abs(da.y)), abs(db.x)), abs(dc.y)), abs(dd.y));\n}\n\nfloat boxdist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n    vec2 da = a - p;\n    vec2 db = b - p;\n    vec2 dc = c - p;\n    vec2 dd = d - p;\n    vec2 de = e - p;\n    return max(max(max(max(max(abs(da.x), abs(da.y)), abs(db.x)), abs(dc.y)), abs(dd.y)), abs(de.y));\n}\n\nfloat boxdist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e,", "\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow head's\n// thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float thickness )\n{\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2 - thickness;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow head's\n// thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float thickness, float head )\n{\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2 - thickness - head;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow head's\n// thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float thickness, float head, float headThickness )\n{\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2 - thickness - head - headThickness;\n}", "\n    vec2 p = vec2(length(ro.xz) - tor.x, ro.y);\n    float d = length(p) - tor.y;\n    float h = clamp(dot(p, p) - tor.y*tor.y, 0.0, length(p));\n    float k = sqrt(abs(d*d/4.0 - h*h));\n    float t = h > 0.0? clamp(d + k, 0.0, length(ro)) : clamp(d - k, 0.0, length(ro));\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, vec3 sph) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    float t = t1 < 0.0? t2 : t1;\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayBox(vec3 ro, vec3 rd, vec3 bx) {\n    vec3 q = abs(ro) - bx;\n    vec3 k = sign(rd);\n    vec3 t1 = min(k.xyz, q.xyz);\n    vec3 t2 = max(k.xyz, q.xyz);\n    vec3 t = max(t1, t2);\n    if (t.x < 0", "\n    vec2 p = vec2(length(pos.xz) - tor.x, pos.y);\n    return normalize(vec3(dFdx(p.x), 1.0, dFdx(p.y)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torusIntersect(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 p = vec2(length(ro.xz) - tor.x, ro.y);\n    float b = dot(p, p) - 0.25;\n    float c = dot(ro.xz, ro.xz) - tor.x * tor.x - tor.y * tor.y;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 < 0.0) t1 = -1.0;\n    if (t2 < 0.0) t2 = -1.0;\n    return min(t1, t2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torusIntersect(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 p = vec2(length(ro.xz) - tor.x, ro.y);\n    float b = dot(p, p) - 0.25;\n    float c = dot(ro.xz, ro.xz) - tor.x * tor.x - tor.y * tor.y;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv(float x) {\n    return 1.0 - tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_2(float x) {\n    return 2.0 * tanh_approx(x) * (1.0 - tanh_approx(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_3(float x) {\n    return 4.0 * tanh_approx(x) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_4(float x) {\n    return 8.0 * tanh_approx(x) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_5(float x) {\n    return 16.0 * tanh_approx(x) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_6(float x) {\n    return 32.0 * tanh_approx(x) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(x)) * (1.0 - tanh_approx(", "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float a = iGlobalTime * 0.1;\n    float b = iGlobalTime * 0.2;\n    float c = iGlobalTime * 0.3;\n    float d = iGlobalTime * 0.4;\n    float e = iGlobalTime * 0.5;\n    float f = iGlobalTime * 0.6;\n    float g = iGlobalTime * 0.7;\n    float h = iGlobalTime * 0.8;\n    float i = iGlobalTime * 0.9;\n    float j = iGlobalTime * 1.0;\n    float k = iGlobalTime * 1.1;\n    float l = iGlobalTime * 1.2;\n    float m = iGlobalTime * 1.3;\n    float n = iGlobalTime * 1.4;\n    float o = iGlobalTime * 1.5;\n    float p = iGlobalTime * 1.6;\n    float q = iGlobalTime * 1.7;\n    float r = iGlobalTime * 1.8;\n    float s = iGlobalTime * 1.9;\n    float t = iGlobalTime * 2.0;\n    float u = iGlobalTime * 2.1;\n    float v = iGlobalTime * 2.2;\n    float w = iGlobalTime * 2.3;\n    float x = iGlobalTime * 2.4;\n    float y = iGlobalTime * 2.5;\n    float z = iGlobalTime * 2.6;\n    float aa = iGlobalTime * 2.7;\n    float bb = iGlobalTime * 2.8;\n    float cc = iGlobalTime * 2.9;\n    float dd = iGlobalTime * 3.0;\n    float ee = iGlobalTime * 3.1;\n    float ff = iGlobalTime * 3.2;\n    float gg = iGlobalTime * 3.3;\n    float hh = iGlobalTime * 3.4;\n   ", "\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf.glsl\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf.glsl\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf.glsl\nfloat sdTorus(in vec3 p, in vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf.glsl\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/hg_sdf.glsl\nfloat sd", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid Grid\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License", "\n    return length(p-c) - r;\n}\n\n// signed distance to a sphere\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// signed distance to a cylinder\nfloat sdCylinder( in vec3 p, in vec3 c, in vec2 r )\n{\n    vec2 q = vec2(length(p.xz)-r.x,p.y);\n    return length(q) - r.y;\n}\n\n// signed distance to a cone\nfloat sdCone( in vec3 p, in vec3 c, in vec2 r )\n{\n    vec2 q = vec2(length(p.xz)-r.x,p.y);\n    return length(q) - r.y;\n}\n\n// signed distance to a cylinder\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// signed distance to a capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// signed distance to a capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// distance to a circle with a hole\nfloat sdCircleHole( in vec2 p, in vec2 c, in float r, in float h )\n{\n    vec2 d = p - c;\n    float dd = dot(d,d);\n    float rr = r*r;\n    return max(length(d)-r,abs(dd-rr)-h*h*h);\n}\n\n// distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 da = abs(p-a), db = abs(p-b);\n    return min(max(da.x,da.y),min(db.x,db.y)) +\n           min(max(da.x,db.y),min(da.y,db.x));\n}\n\n// distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = p - a, ba = b - a, ca = c - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 pb = pa - ba*h, hb = cross(ba,ca);\n    return min(min(length(pb),dot(hb,hb)),dot(ca,hb)) +\n           min(min(length(pa),dot(ba,hb)),dot(ca,pa));\n}\n\n// distance to a triangle with a hole\nfloat sdTriangleHole( in vec2 p, in vec2 a, in ve", "\n    return dot(a, b);\n}\n\nfloat sdTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float d00 = cro(v0, v0);\n    float d01 = cro(v0, v1);\n    float d11 = cro(v1, v1) - d00;\n    float d10 = cro(v1, v0) - d00;\n    float d20 = cro(v2, v0);\n    float d21 = cro(v2, v1) - d01;\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0 - v - w;\n    return u * cro(v0, v2) + v * cro(v1, v2) + w * cro(v0, v1);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdRing(vec2 p, vec2 c, float r1, float r2) {\n    return length(p - c) - (r1 + r2);\n}\n\nfloat sdEllipse(vec2 p, vec2 c, vec2 r) {\n    vec2 q = p - c;\n    float a = dot(q, q) / dot(r, r);\n    float b = cro(q, r) / dot(r, r);\n    float c = cro(r, r) / dot(r, r);\n    float d = b * b - a * c;\n    if (d < 0.0) return length(q) - r.x;\n    float e = sqrt(d);\n    return e *", "\n    vec2 q = vec2(length(p.x*vec2(s,0.0)),p.y);\n    return length(q-vec2(s,0.0))-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in float s, in float r ) \n{\n    vec2 d = abs(p)-vec2(s,s);\n    return length(max(d,0.0))+min(max(d.x,d.y),0.0) - r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundTriangle( in vec2 p, in float s, in float r ) \n{\n    vec2 q = vec2(length(p.x*vec2(s,0.0)),p.y);\n    return length(q-vec2(s,0.0))-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRhombus( in vec2 p, in float s, in float r ) \n{\n    vec2 q = vec2(length(p.x*vec2(s,0.0)),p.y);\n    return length(q-vec2(s,0.0))-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundHexagon( in vec2 p, in float s, in float r ) \n{\n    vec2 q = vec2(length(p.x*vec2(s,0.0)),p.y);\n    return length(q-vec2(s,0.0))-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundOctagon( in vec2 p, in float s, in float r ) \n{\n    vec2 q = vec2(length(p.x*vec2(s,0.0)),p.y);\n    return length(q-vec2(s,0.0))-r;\n}\n\n// s = side length", "\n    return pow(x, vec3(1.0 / 2.2));\n}\n\nvec3 s_curve_inv(vec3 x)\n{\n    return pow(x, vec3(2.2));\n}\n\nvec3 aces_curve(vec3 x)\n{\n    return clamp((x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06), 0.0, 1.0);\n}\n\nvec3 aces_curve_inv(vec3 x)\n{\n    return clamp((x * (6.2 * x + 1.7) + 0.06) / (x * (6.2 * x + 0.5) + 1.0), 0.0, 1.0);\n}\n\nvec3 aces_curve_inv_v(vec3 x)\n{\n    return clamp((x * (6.2 * x + 1.7) + 0.06) / (x * (6.2 * x + 0.5) + 1.0), 0.0, 1.0);\n}\n\nvec3 aces_curve_v(vec3 x)\n{\n    return clamp((x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06), 0.0, 1.0);\n}\n\nvec3 aces_curve_v_inv(vec3 x)\n{\n    return clamp((x * (6.2 * x + 1.7) + 0.06) / (x * (6.2 * x + 0.5) + 1.0), 0.0, 1.0);\n}\n\nvec3 aces_curve_v_inv_v(vec3 x)\n{\n    return clamp((x * (6.2 * x + 1.7) + 0.06) / (x * (6.2 * x + 0.5) + 1.0), 0.0, 1.0);\n}\n\nvec3 aces_curve_", "\n    return vec3(\n        x.y * (x.x * (x.x - 2.0) + x.z * (x.z - 2.0) + 2.0),\n        x.x * (x.x - 2.0) * (x.x - 2.0) + x.y * (x.y - 2.0) * (x.y - 2.0) + x.z * (x.z - 2.0) * (x.z - 2.0),\n        x.x * (x.x - 2.0) * (x.x - 2.0) * (x.x - 2.0) + x.y * (x.y - 2.0) * (x.y - 2.0) * (x.y - 2.0) + x.z * (x.z - 2.0) * (x.z - 2.0) * (x.z - 2.0)\n    );\n}\n\n// derivative of t-curve\nvec3 d_t_curve(vec3 x)\n{\n    return vec3(\n        x.x * (x.x - 2.0) * (x.x - 2.0) + x.y * (x.y - 2.0) * (x.y - 2.0) + x.z * (x.z - 2.0) * (x.z - 2.0),\n        x.x * (x.x - 2.0) * (x.x - 2.0) * (x.x - 2.0) + x.y * (x.y - 2.0) * (x.y - 2.0) * (x.y - 2.0) + x.z * (x.z - 2.0) * (x.z - 2.0) * (x.z - 2.0),\n        x.x * (x.x - 2.0) * (x.x - 2.0) * (x.x - 2.0) * (x.x - ", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = (r-w)/k;\n    return mod(a+c, TWO_PI)-PI;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral2( in vec2 p, float w, in float k )\n{\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = (r-w)/k;\n    return mod(a+c, TWO_PI)-PI;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral3( in vec2 p, float w, in float k )\n{\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = (r-w)/k;\n    return mod(a+c, TWO_PI)-PI;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral4( in vec2 p, float w, in float k )\n{\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = (r-w)/k;\n    return mod(a+c, TWO_PI)-PI;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral5( in vec2 p, float w, in float k )\n{\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = (r-w)/k;\n    return mod(a+c, TWO_PI)-PI;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral6( in vec2 p, float w, in float k )\n{\n    float a = atan(p.y,", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float transmittance)\n{\n    return exp(-opticalDepth) * transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance)\n{\n    return exp(-opticalDepth) * transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, float transmittanceScale)\n{\n    return exp(-opticalDepth) * transmittance * transmittanceScale;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 transmittanceScale)\n{\n    return exp(-opticalDepth) * transmittance * transmittanceScale;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 transmittanceScale, float transmittanceScaleFactor)\n{\n    return exp(-opticalDepth) * transmittance * transmittanceScale * transmittanceScaleFactor;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 transmittanceScale, vec3 transmittanceScaleFactor)\n{\n    return exp(-opticalDepth) * transmittance * transmittanceScale * transmittanceScaleFactor;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 transmittanceScale, vec3 transmittanceScaleFactor, float transmittanceScaleFactorFactor)\n{\n    return exp(-opticalDepth) * transmittance * transmittanceScale * transmittanceScaleFactor * transmittanceScaleFactorFactor;\n}\n\n// Calculate a luminance", "\n    vec3 rayEnd = rayStart + rayDir * rayLength;\n    vec3 rayColor = vec3(0.0);\n    vec3 rayLengths = vec3(0.0);\n    vec3 rayDirs = vec3(0.0);\n    vec3 rayDirsInv = vec3(0.0);\n    vec3 rayDirsSq = vec3(0.0);\n    vec3 rayDirsCos = vec3(0.0);\n    vec3 rayDirsSin = vec3(0.0);\n    vec3 rayDirsCosSq = vec3(0.0);\n    vec3 rayDirsSinSq = vec3(0.0);\n    vec3 rayDirsCosSin = vec3(0.0);\n    vec3 rayDirsCosSinSq = vec3(0.0);\n    vec3 rayDirsCosSinCos = vec3(0.0);\n    vec3 rayDirsCosSinCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCosCos = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosCosCosSq = vec3(0.0);\n    vec3 rayDirsCosSinCosCosCosC", "\n    vec3 p = p2;\n    float r = ra;\n    float rb2 = rb*rb;\n    float d2 = dot(p,p);\n    if( d2 < rb2 )\n    {\n        return length(p) - r;\n    }\n    else\n    {\n        return length(p) - rb;\n    }\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar2( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec3 p = p2;\n    float r = ra;\n    float rb2 = rb*rb;\n    float d2 = dot(p,p);\n    if( d2 < rb2 )\n    {\n        return length(p) - r;\n    }\n    else\n    {\n        return length(p) - rb;\n    }\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar3( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec3 p = p2;\n    float r = ra;\n    float rb2 = rb*rb;\n    float d2 = dot(p,p);\n    if( d2 < rb2 )\n    {\n        return length(p) - r;\n    }\n    else\n    {\n        return length(p) - rb;\n    }\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar4( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec3 p = p2;\n    float r = ra;\n    float rb2 = rb*rb;\n    float d2 = dot(p,p);\n    if( d2 < rb2 )\n    {\n        return length(p) - r;", "\n    vec3 q = vec3(p.x, p.y, p.z - h);\n    return length(p - q) - r - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec3 q = vec3(p.x, p.y, p.z - h);\n    return length(p - q) - r - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec3 q = vec3(p.x, p.y, p.z - h);\n    return length(p - q) - r - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec3 q = vec3(p.x, p.y, p.z - h);\n    return length(p - q) - r - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec3 q = vec3(p.x, p.y, p.z - h);\n    return length(p - q) - r - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec3 q = vec3(p.x, p.y, p.z - h);\n    return length(p - q) - r - t;\n}\n\n// r = sphere's radius\n//", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, k*h/t );\n        t += h;\n        if( h<0.002 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows2/\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 0.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += h;\n        t += h;\n        if( h<0.002 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows3/\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k )\n{\n    float res = 0.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res += k*h/t;\n        t += h;\n        if( h<0.002 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows4/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<5; i++ )\n    {\n        float h = map(ro+rd*t);\n        res =", "\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) -", "\n    vec2 e = vec2( 1.0, -1.0 ) * 0.5773 * 0.0005;\n    return normalize( e.xyy * fwidth( pos ) +\n                      e.yxy * fwidth( pos.yzx ) +\n                      e.yyx * fwidth( pos.zyx ) );\n}\n\n// https://iquilezles.org/articles/sdfdistort/\nfloat sdSphere( vec3 p, float r )\n{\n    return length( p ) - r;\n}\n\n// https://iquilezles.org/articles/sdfdistort/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// https://iquilezles.org/articles/sdfdistort/\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length( vec2( length( p.xz ) - c.x, p.y ) );\n    return min( q, length( vec2( length( p.xz ) + c.x, p.y ) ) - c.y );\n}\n\n// https://iquilezles.org/articles/sdfdistort/\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// https://iquilezles.org/articles/sdfdistort/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q", "\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(q) - r - h;\n}\n\n// r=radius, h=height, s=stroke width\nfloat sdCutDisk( in vec2 p, in float r, in float h, in float s )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(q) - (r + s) - h;\n}\n\n// r=radius, h=height, s=stroke width\nfloat sdCutDisk( in vec2 p, in float r, in float h, in float s, in float k )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(q) - (r + s) - h - k;\n}\n\n// r=radius, h=height, s=stroke width, k=knockout\nfloat sdCutDisk( in vec2 p, in float r, in float h, in float s, in float k, in float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(q) - (r + s) - h - k - t;\n}\n\n// r=radius, h=height, s=stroke width, k=knockout, t=thickness\nfloat sdCutDisk( in vec2 p, in float r, in float h, in float s, in float k, in float t, in float u )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(q) - (r + s) - h - k - t - u;\n}\n\n// r=radius, h=height, s=stroke width, k=knockout, t=thickness, u=knockout\nfloat sdCutDisk( in vec2 p, in float r, in float h, in float s, in float k, in float t, in float u, in float v )\n{\n    vec2 q = vec2( length(p.", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( dot(p, vec3(1.0, 57.0, 113.0)),\n                        dot(p, vec3(57.0, 113.0, 17.0)), f.x),\n                   mix( dot(p, vec3(17.0, 113.0, 57.0)),\n                        dot(p, vec3(57.0, 17.0, 113.0)), f.x), f.y),\n               mix(mix( dot(p, vec3(57.0, 17.0, 113.0)),\n                        dot(p, vec3(17.0, 57.0, 113.0)), f.x),\n                   mix( dot(p, vec3(113.0, 57.0, 17.0)),\n                        dot(p, vec3(57.0, 113.0, 17.0)), f.x), f.y),\n               f.z);\n}\n\n// 3d noise function with perlin noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( dot(p, vec3(1.0, 57.0, 113.0)),\n                        dot(p, vec3(57.0, 113.0, 17.0)), f.x),\n                   mix( dot(p, vec", "\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(a),-sin(a),sin(a),cos(a) );\n    // 2 octaves\n    for (int i = 0; i < 2; i++)\n    {\n        f += a * noise(p);\n        p = rot * p * 2.02;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float scale )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(a),-sin(a),sin(a),cos(a) );\n    // 2 octaves\n    for (int i = 0; i < 2; i++)\n    {\n        f += a * noise(p);\n        p = rot * p * scale;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float scale, float persistence )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(a),-sin(a),sin(a),cos(a) );\n    // 2 octaves\n    for (int i = 0; i < 2; i++)\n    {\n        f += a * noise(p);\n        p = rot * p * scale;\n        a *= persistence;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float scale, float persistence", "\n    p3 = fract(p3 * vec3(127.1, 311.7, 127.1));\n    return -1.0 + 2.0 * fract(sin(dot(p3, vec3(73.1, 246.1, 113.1))) * 43758.5453);\n}\n\n//value noise hash function\nfloat hash31(vec3 p3)\n{\n    p3 = fract(p3 * vec3(127.1, 311.7, 127.1));\n    return -1.0 + 2.0 * fract(sin(dot(p3, vec3(73.1, 246.1, 113.1))) * 43758.5453);\n}\n\n//value noise hash function\nfloat hash31(vec3 p3)\n{\n    p3 = fract(p3 * vec3(127.1, 311.7, 127.1));\n    return -1.0 + 2.0 * fract(sin(dot(p3, vec3(73.1, 246.1, 113.1))) * 43758.5453);\n}\n\n//value noise hash function\nfloat hash31(vec3 p3)\n{\n    p3 = fract(p3 * vec3(127.1, 311.7, 127.1));\n    return -1.0 + 2.0 * fract(sin(dot(p3, vec3(73.1, 246.1, 113.1))) * 43758.5453);\n}\n\n//value noise hash function\nfloat hash31(vec3 p3)\n{\n    p3 = fract(p3 * vec3(127.1, 311.7, 127.1));\n    return -1.0 + 2.0 * fract(sin(dot(p3, vec3(7", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float t = iTime * 0.1;\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 2.0;\n    float f = (d * d) / (0.25 * 0.25);\n    float g = (d * d) / (0.25 * 0.25);\n    float h = (d * d) / (0.25 * 0.25);\n    float i = (d * d) / (0.25 * 0.25);\n    float j = (d * d) / (0.25 * 0.25);\n    float k = (d * d) / (0.25 * 0.25);\n    float l = (d * d) / (0.25 * 0.25);\n    float m = (d * d) / (0.25 * 0.25);\n    float n = (d * d) / (0.25 * 0.25);\n    float o = (d * d) / (0.25 * 0.25);\n    float p = (d * d) / (0.25 * 0.25);\n    float q = (d * d) / (0.25 * 0.25);\n    float r = (d * d) / (0.25 * 0.25);\n    float s = (d * d) / (0.25 * 0.25);\n    float t = (d * d) / (0.25 * 0.25);\n    float u = (d * d) / (0.25 * 0.25);\n    float v = (", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx +", "\n    return p - floor(p / size) * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/float_sdf.glsl\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/float_sdf.glsl\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) +\n        length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/float_sdf.glsl\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/float_sdf.glsl\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/float_sdf.glsl\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r", "\n    return co * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2) {\n    return co * co2 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3) {\n    return co * co2 * co3 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4) {\n    return co * co2 * co3 * co4 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4, float co5) {\n    return co * co2 * co3 * co4 * co5 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4, float co5, float co6) {\n    return co * co2 * co3 * co4 * co5 * co6 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4, float co5, float co6, float co7) {\n    return co * co2 * co3 * co4 * co5 * co6 * co7 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4, float co5, float co6, float co7, float co8) {\n    return co * co2 * co3 * co4 * co5 * co6 * co7 * co8 * 1000.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(", "\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv(float t) {\n    return pow(t, 2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv2(float t) {\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv3(float t) {\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv4(float t) {\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv5(float t) {\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv6(float t) {\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGBInv7(float t) {\n    return pow(t, 1.0/2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www", "\n    return pow(c, vec3(1.0 / 2.4));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverse(in vec3 c) {\n    return pow(c, vec3(2.4));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBGamma(in vec3 c, float gamma) {\n    return pow(c, vec3(1.0 / gamma));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverseGamma(in vec3 c, float gamma) {\n    return pow(c, vec3(gamma));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBLinear(in vec3 c) {\n    return clamp(c, 0.0, 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverseLinear(in vec3 c) {\n    return clamp(c, 0.0, 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBLinearGamma(in vec3 c, float gamma) {\n    return clamp(pow(c, vec3(1.0 / gamma)), 0.0, 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/N", "\n    return max(a, min(b, k));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    return min(a, max(b, k));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k, float t) {\n    return max(a, min(b, k * (1.0 - t) + t));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k, float t) {\n    return min(a, max(b, k * (1.0 - t) + t));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k, float t, float bt) {\n    return max(a, min(b, k * (1.0 - t) * bt + t * bt));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k, float t, float bt) {\n    return min(a, max(b, k * (1.0 - t) * bt + t * bt));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k, float t, float bt, float btt) {\n    return max(a, min(b, k * (1.0 - t) * bt * btt + t * btt));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < dbuffer) t = -b + h;\n    if (t < dbuffer) return -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nfloat sphdist(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < dbuffer) t = -b + h;\n    if (t < dbuffer) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nfloat sphdist(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < 0.0) t = -b + h;\n    if (t < 0.0) return -1.", "\n  vec4 q = vec4(0.0);\n  for (int i = 0; i < 10; i++) {\n    q += sin(p);\n    p = p * 2.0 + vec4(0.5);\n  }\n  return q;\n}\n\n// \"Fractal\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  vec4 q = vec4(0.0);\n  for (int i = 0; i < 10; i++) {\n    q += sin(p);\n    p = p * 2.0 + vec4(0.5);\n  }\n  return q;\n}\n\n// \"Fractal\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  vec4 q = vec4(0.0);\n  for (int i = 0; i < 10; i++) {\n    q += sin(p);\n    p = p * 2.0 + vec4(0.5);\n  }\n  return q;\n}\n\n// \"Fractal\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  vec4 q = vec4(0.0);\n  for (int i = 0; i < 10; i++) {\n    q += sin(p);\n    p = p * 2.0 + vec4(0.5);\n  }\n  return q;\n}\n\n// \"Fractal\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  vec4 q = vec4(0.0);\n  for (int i = 0; i < 10; i++) {\n    q += sin(p);\n    p = p * 2.0 + vec4(0.5);\n  }\n  return q;", "\n    vec4 q = vec4(p,1.0);\n    vec4 r2 = r*r;\n    vec4 s = q*q;\n    vec4 t = s*s;\n    vec4 u = t*t;\n    vec4 v = u*u;\n    vec4 w = v*v;\n    vec4 x = w*w;\n    vec4 y = w*x;\n    vec4 z = x*y;\n    vec4 wz = z*w;\n    vec4 xy = y*x;\n    vec4 yz = z*y;\n    vec4 zw = w*z;\n    vec4 r2x = r2.xxyy;\n    vec4 r2y = r2.yyww;\n    vec4 r2z = r2.zzww;\n    vec4 r2xy = r2x.xyxy;\n    vec4 r2xz = r2x.zzww;\n    vec4 r2yz = r2y.zzww;\n    vec4 r2xyz = r2xy.xyxy;\n    vec4 r2xzy = r2x.zyyy;\n    vec4 r2yzw = r2y.zwzw;\n    vec4 r2xyzw = r2xy.zwzw;\n    vec4 r2xzyw = r2x.zyyy;\n    vec4 r2yzxw = r2y.zwzw;\n    vec4 r2xyzxw = r2xy.zwzw;\n    vec4 r2xzywz = r2x.zyyy;\n    vec4 r2yzxwz = r2y.zwzw;\n    vec4 r2xyzxwy = r2xy.zwzw;\n    vec4 r2xzywzw = r2x.zyyy;\n    vec4 r2yzxwzw = r2y.zwzw;\n    vec4 r2xyzxwyz", "\n    return vec4(back.rgb, back.a * front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return vec4(back.rgb, back.a * alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2) {\n    return vec4(back.rgb, back.a * alpha2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3) {\n    return vec4(back.rgb, back.a * alpha3);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4) {\n    return vec4(back.rgb, back.a * alpha4);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5) {\n    return vec4(back.rgb, back.a * alpha5);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5, float alpha6) {\n    return vec4(back.rgb, back.a * alpha6);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5, float alpha6, float alpha7) {\n    return vec4(back.rgb, back.a * alpha7);\n}\n", "\n    if (front.a == 0.0) {\n        return back;\n    }\n    if (front.a == 1.0) {\n        return front.rgb;\n    }\n    return (back * (1.0 - front.a)) + (front.rgb * front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, float alpha) {\n    if (alpha == 0.0) {\n        return back;\n    }\n    if (alpha == 1.0) {\n        return front.rgb;\n    }\n    return (back * (1.0 - alpha)) + (front.rgb * alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, vec4 alpha) {\n    if (alpha.a == 0.0) {\n        return back;\n    }\n    if (alpha.a == 1.0) {\n        return front.rgb;\n    }\n    return (back * (1.0 - alpha.a)) + (front.rgb * alpha.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, vec4 alpha) {\n    if (alpha.a == 0.0) {\n        return back;\n    }\n    if (alpha.a == 1.0) {\n        return front.rgb;\n    }\n    return (back * (1.0 - alpha.a)) + (front.rgb * alpha.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, vec4 alpha) {\n    if (alpha.a == 0.0) {\n        return back;\n    }\n    if (alpha.a == 1.0) {\n        return front.rgb;\n    }\n    return (back * (1.0 - alpha.a)) + (front.rgb * alpha.a);\n}\n", "\n    return length(p - vec2(r, 0.0));\n}\n\nfloat hex(vec2 p, float r, float h ) {\n    return length(p - vec2(r, 0.0)) - h;\n}\n\nfloat hex(vec2 p, float r, float h, float k ) {\n    return max(length(p - vec2(r, 0.0)) - h, abs(p.y) - k);\n}\n\nfloat hex(vec2 p, float r, float h, float k, float d ) {\n    return max(length(p - vec2(r, 0.0)) - h, abs(p.y) - k) - d;\n}\n\nfloat hex(vec2 p, float r, float h, float k, float d, float b ) {\n    return max(length(p - vec2(r, 0.0)) - h, abs(p.y) - k) - d - b;\n}\n\nfloat hex(vec2 p, float r, float h, float k, float d, float b, float c ) {\n    return max(length(p - vec2(r, 0.0)) - h, abs(p.y) - k) - d - b - c;\n}\n\nfloat hex(vec2 p, float r, float h, float k, float d, float b, float c, float a ) {\n    return max(length(p - vec2(r, 0.0)) - h, abs(p.y) - k) - d - b - c - a;\n}\n\nfloat hex(vec2 p, float r, float h, float k, float d, float b, float c, float a, float n ) {\n    return max(length(p - vec2(r, 0.0)) - h, abs(p.y) - k) - d - b - c - a - n;\n}\n\nfloat hex(vec2 p, float r, float h, float k, float d, float b, float c, float a, float n, float m ) {\n    return max(length(p - vec2(r, 0.", "\n    float a = 2.51f;\n    float b = 0.02f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(v * (a * v + b) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_film(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(v * (a * v + b) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_film_v2(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(v * (a * v + b) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_film_v3(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(v", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float n_ = -1.0;\n    for (int j = 0; j < 2; j++) {\n        for (int i = 0; i < 2; i++) {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(g);\n            vec2 r = o - f + dot(g, o);\n            n_ += dot(r, r);\n        }\n    }\n\n    return 1.0 - sqrt(n_ / 49.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 5; i++) {\n        v += a * noise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    // Rotate to reduce axial bias\n    mat3", "\n    return exp(-1.0 / (Temp * 1.0e-2)) * vec3(0.216, 0.619, 0.060);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp, float lum) {\n    return exp(-1.0 / (Temp * 1.0e-2)) * vec3(lum, lum, lum);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp, float lum, float lum2) {\n    return exp(-1.0 / (Temp * 1.0e-2)) * vec3(lum, lum2, lum);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp, float lum, float lum2, float lum3) {\n    return exp(-1.0 / (Temp * 1.0e-2)) * vec3(lum, lum2, lum3);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp, float lum, float lum2, float lum3, float lum4) {\n    return exp(-1.0", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 191.9))) * 43758.5453);\n}\n\nfloat noise(vec4 p) {\n    return fract(sin(dot(p, vec4(127.1, 311.7, 191.9, 71.4))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float seed) {\n    return fract(sin(dot(p, vec2(127.1, 311.7)) + seed) * 43758.5453);\n}\n\nfloat noise(vec3 p, float seed) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 191.9)) + seed) * 43758.5453);\n}\n\nfloat noise(vec4 p, float seed) {\n    return fract(sin(dot(p, vec4(127.1, 311.7, 191.9, 71.4)) + seed) * 43758.5453);\n}\n\nfloat noise(vec2 p, vec2 seed) {\n    return fract(sin(dot(p, vec2(127.1, 311.7)) + seed.x) * 43758.5453);\n}\n\nfloat noise(vec3 p, vec2 seed) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 191.9)) + seed.x) * 43758.5453);\n}\n\nfloat noise(vec4 p, vec2 seed", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nvec2 raySphere2(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nvec2 raySphere3(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nvec2 raySphere4(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz", "\n    vec2 q = p - vec2(0.5);\n    float k = length(q);\n    if (k > 1.0)\n        return vec3(0.0);\n    float a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n    float b = atan(sqrt(1.0 - k * k), k) / 3.1415926535897932384626433832795;\n    float r = mod(a + b + n, 2.0) - 1.0;\n    return vec3(r, r, r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse(vec2 p, vec2 r)\n{\n    vec2 q = p - vec2(0.5);\n    float k = length(q / r);\n    if (k > 1.0)\n        return vec3(0.0);\n    float a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n    float b = atan(sqrt(1.0 - k * k), k) / 3.1415926535897932384626433832795;\n    float r = mod(a + b, 2.0) - 1.0;\n    return vec3(r, r, r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n", "\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    return 0.5 * ( 1.0 + erf( ( x - t ) / sqrt( 2.0 ) )", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float k = dot(q,q)/dot(r,r);\n    if( k > 1.0 ) return length(q) - dot(r,r);\n    float m = sqrt(1.0-k);\n    vec2 uv = vec2(m,k-m*m);\n    return length(q*uv) - dot(r,uv);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRing( in vec2 p, in vec2 c, in float r1, in float r2 )\n{\n    vec2 q = p - c;\n    float k = dot(q,q)/dot(r1,r1);\n    if( k > 1.0 ) return length(q) - dot(r2,r2);\n    float m = sqrt(1.0-k);\n    vec2 uv = vec2(m,k-m*m);\n    return length(q*uv) - dot(r2,uv);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a, ac = c - a, ap = p - a;\n    float h = clamp(", "\n    float f = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 1.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n    float f2 = 0.0;\n    float f3 = 0.0;\n    float f4 = 0.0;\n    float f5 = 0.0;\n    float f6 = 0.0;\n    float f7 = 0.0;\n    float f8 = 0.0;\n    float f9 = 0.0;\n    float f10 = 0.0;\n    float f11 = 0.0;\n    float f12 = 0.0;\n    float f13 = 0.0;\n    float f14 = 0.0;\n    float f15 = 0.0;\n    float f16 = 0.0;\n    float f17 = 0.0;\n    float f18 = 0.0;\n    float f19 = 0.0;\n    float f20 = 0.0;\n    float f21 = 0.0;\n    float f22 = 0.0;\n    float f23 = 0.0;\n    float f24 = 0.0;\n    float f25 = 0.0;\n    float f26 = 0.0;\n    float f27 = 0.0;\n    float f28 = 0.0;\n    float f29 = 0.0;\n    float f30 = 0.0;\n    float f31 = 0.0;\n    float f32 = 0.0;\n    float f33 = 0.0;\n    float f34 = 0.0;\n    float f35 = 0.0;\n    float f36 = 0.0;\n    float f37 = 0.0;\n    float f38 = 0.0;\n    float f39 = 0.0;\n    float f40 = 0.0;\n    float f41 = 0.0;\n    float f42", "\n    return atan(y, x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(float y, float x) {\n    return atan2(y, x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(vec2 v) {\n    return atan2_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec2 v) {\n    return atan_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(vec3 v) {\n    return atan2_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec4 v) {\n    return atan_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(vec2 v, vec2 w) {\n    return atan2_approx(v.y, v.x) - atan2_approx(w.y, w.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec3 v, vec3 w) {\n    return atan_approx(v.y, v.x) - atan_approx(w.y, w.x);\n}\n\n// License: MIT, author:", "\n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x*w.x+z.y*w.y, z.y*w.x-z.x*w.y)/dot(w,w);\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 cpow(vec2 z, float p) {\n    return vec2(pow(z.x,p), pow(z.y,p));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x), sin(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x), cos(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(tan(z.x), tan(z.y));\n}\n\nvec2 casin(vec2 z) {\n    return vec2(asin(z.x), asin(z.y));\n}\n\nvec2 casinh(vec2 z) {\n    return vec2(asinh(z.x), asinh(z.y));\n}\n\nvec2 cacos(vec2 z) {\n    return vec2(acos(z.x), acos(z.y));\n}\n\nvec2 cacosh(vec2 z) {\n    return vec2(acosh(z.x), acosh(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x), sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return", "\n    return vec2(atanh(z.x), atanh(z.y));\n}\n\n// Inverse hyperbolic tangent 3D\nvec3 catanh(vec3 z) {\n    return vec3(atanh(z.x), atanh(z.y), atanh(z.z));\n}\n\n// Inverse hyperbolic tangent 4D\nvec4 catanh(vec4 z) {\n    return vec4(atanh(z.x), atanh(z.y), atanh(z.z), atanh(z.w));\n}\n\n// Hyperbolic tangent 2D\nvec2 tanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// Hyperbolic tangent 3D\nvec3 tanh(vec3 z) {\n    return vec3(tanh(z.x), tanh(z.y), tanh(z.z));\n}\n\n// Hyperbolic tangent 4D\nvec4 tanh(vec4 z) {\n    return vec4(tanh(z.x), tanh(z.y), tanh(z.z), tanh(z.w));\n}\n\n// Hyperbolic tangent 2D\nvec2 tanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// Hyperbolic tangent 3D\nvec3 tanh(vec3 z) {\n    return vec3(tanh(z.x), tanh(z.y), tanh(z.z));\n}\n\n// Hyperbolic tangent 4D\nvec4 tanh(vec4 z) {\n    return vec4(tanh(z.x), tanh(z.y), tanh(z.z), tanh(z.w));\n}\n\n// Hyperbolic tangent 2D\nvec2 tanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// Hyperbolic tangent", "\n    return vec2(exp(z.x), exp(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\n// My own attempt at an ctanh\nvec2 ctanh(vec2 z) {\n    return vec2(tan", "\n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x*w.x+z.y*w.y, z.y*w.x-z.x*w.y)/dot(w,w);\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 cpow(vec2 z, float p) {\n    return vec2(pow(z.x,p), pow(z.y,p));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x), sin(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x), cos(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(tan(z.x), tan(z.y));\n}\n\nvec2 casin(vec2 z) {\n    return vec2(asin(z.x), asin(z.y));\n}\n\nvec2 casinh(vec2 z) {\n    return vec2(asinh(z.x), asinh(z.y));\n}\n\nvec2 cacos(vec2 z) {\n    return vec2(acos(z.x), acos(z.y));\n}\n\nvec2 cacosh(vec2 z) {\n    return vec2(acosh(z.x), acosh(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x), sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return", "\n    return vec2(exp(z.x), exp(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x), sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x), cosh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(tan(z.x), tan(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x), sin(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x), cos(z.y));\n}\n\nvec2 cacos(vec2 z) {\n    return vec2(acos(z.x), acos(z.y));\n}\n\nvec2 cacosh(vec2 z) {\n    return vec2(acosh(z.x), acosh(z.y));\n}\n\nvec2 casinh(vec2 z) {\n    return vec2(asinh(z.x), asinh(z.y));\n}\n\nvec2 cacosh(vec2 z) {\n    return vec2(acosh(z.x), acosh(z.y));\n}\n\nvec2 cacos(vec2 z) {\n    return vec2(acos(z.x), acos(z.y));\n}\n\nvec2 cacosh(vec2 z) {\n    return vec2(acosh(z.x), acosh(z.y));\n}\n\nvec2 cacos(vec2 z) {\n    return vec2(acos(z.x), acos(z.y));\n}\n\nvec2 cacosh(vec2 z) {\n    return vec2(acosh(z.x), acosh", "\n    float a = alpha.x;\n    float b = alpha.y;\n    float c = alpha.z;\n    float d = alpha.w;\n    float e = max(a, max(b, max(c, d)));\n    float f = min(a, min(b, min(c, d)));\n    float g = e - f;\n    float h = (e + f) / 2.0;\n    float i = (e + h) / 2.0;\n    float j = (h + i) / 2.0;\n    float k = (i + j) / 2.0;\n    float l = (j + k) / 2.0;\n    float m = (k + l) / 2.0;\n    float n = (l + m) / 2.0;\n    float o = (m + n) / 2.0;\n    float p = (n + o) / 2.0;\n    float q = (o + p) / 2.0;\n    float r = (p + q) / 2.0;\n    float s = (q + r) / 2.0;\n    float t = (r + s) / 2.0;\n    float u = (s + t) / 2.0;\n    float v = (t + u) / 2.0;\n    float w = (u + v) / 2.0;\n    float x = (v + w) / 2.0;\n    float y = (w + x) / 2.0;\n    float z = (x + y) / 2.0;\n    float aa = (z + y) / 2.0;\n    float bb = (y + x) / 2.0;\n    float cc = (x + z) / 2.0;\n    float dd = (z + w) / 2.0;\n    float ee = (w + v) / 2.0;\n    float ff = (v + u) / 2.0;\n    float gg = (u + t) / 2.0;\n    float hh = (t", "\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), q.z);\n}\n\n//Distance from the Edge of the Sphere\nfloat sphereDist(vec3 p) {\n    return length(p) - 1.0;\n}\n\n//Distance from the Edge of the Cube\nfloat cubeDist(vec3 p) {\n    vec3 q = abs(p);\n    return min(min(q.x, q.y), q.z) - 1.0;\n}\n\n//Distance from the Edge of the Octahedron\nfloat octaDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), max(q.z, q.w)) - 1.0;\n}\n\n//Distance from the Edge of the Tetrahedron\nfloat tetraDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(max(q.x, q.y), q.z), q.w) - 1.0;\n}\n\n//Distance from the Edge of the Dodecahedron\nfloat dodecaDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(max(max(q.x, q.y), q.z), q.w), max(q.x, q.y)) - 1.0;\n}\n\n//Distance from the Edge of the Icosahedron\nfloat icosaDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(max(max(max(q.x, q.y), q.z), q.w), max(q.x, q.y)), max(q.z, q.w)) - 1.0;\n}\n\n//Distance from the Edge of the Cylinder\nfloat cylDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), max(q.z, q.w)) - 1.0;\n}\n\n//Distance from the", "\n    vec3 uv = uvw.xy;\n    vec3 w = uvw.zxy;\n    vec3 v = vec3(0.0);\n    v.x = fract(uv.x * 0.5) * 2.0 - 1.0;\n    v.y = fract(uv.y * 0.5) * 2.0 - 1.0;\n    v.z = fract(uv.z * 0.5) * 2.0 - 1.0;\n    vec3 wv = v.zyx;\n    vec3 wuv = wv.zyx;\n    vec3 wuvw = wuv.zyx;\n    vec3 wuvwv = wuvw.zyx;\n    vec3 wuvwvw = wuvwv.zyx;\n    vec3 wuvwvwv = wuvwvw.zyx;\n    vec3 wuvwvwvw = wuvwvwv.zyx;\n    vec3 wuvwvwvwv = wuvwvwvw.zyx;\n    vec3 wuvwvwvwvw = wuvwvwvwv.zyx;\n    vec3 wuvwvwvwvwv = wuvwvwvwvw.zyx;\n    vec3 wuvwvwvwvwvw = wuvwvwvwvwv.zyx;\n    vec3 wuvwvwvwvwvwv = wuvwvwvwvwvw.zyx;\n    vec3 wuvwvwvwvwvwvw = wuvwvwvwvwvwv.zyx;\n    vec3 wuvwvwvwvwvwvwv = wuvwvwvwvwvwvw.zyx;\n    vec3 wuvwvwvwvwvwvwvw = wuvwvwvwvwvwvwv.zyx;\n    vec3 wuv", "\n    vec3 uv = uvw.xy;\n    vec3 w = uvw.zxy;\n    vec3 w2 = w*w;\n    vec3 w3 = w2*w;\n    vec3 w4 = w3*w;\n    vec3 w5 = w4*w;\n    vec3 w6 = w5*w;\n    vec3 w7 = w6*w;\n    vec3 w8 = w7*w;\n    vec3 w9 = w8*w;\n    vec3 w10 = w9*w;\n    vec3 w11 = w10*w;\n    vec3 w12 = w11*w;\n    vec3 w13 = w12*w;\n    vec3 w14 = w13*w;\n    vec3 w15 = w14*w;\n    vec3 w16 = w15*w;\n    vec3 w17 = w16*w;\n    vec3 w18 = w17*w;\n    vec3 w19 = w18*w;\n    vec3 w20 = w19*w;\n    vec3 w21 = w20*w;\n    vec3 w22 = w21*w;\n    vec3 w23 = w22*w;\n    vec3 w24 = w23*w;\n    vec3 w25 = w24*w;\n    vec3 w26 = w25*w;\n    vec3 w27 = w26*w;\n    vec3 w28 = w27*w;\n    vec3 w29 = w28*w;\n    vec3 w30 = w29*w;\n    vec3 w31 = w30*w;\n    vec3 w32 = w31*w;\n    vec3 w33 = w32*w;\n    vec3 w34 = w33*w;\n    vec3 w3", "\n    vec3 p = uvw;\n    p.x *= gridRes;\n    p.y *= gridRes;\n    p.z *= gridRes;\n    p.x += gridRes / 2.0;\n    p.y += gridRes / 2.0;\n    p.z += gridRes / 2.0;\n    return p;\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes) {\n    return quadGrid(uvw, gridRes, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw) {\n    return quadGrid(uvw, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec2 uv) {\n    return quadGrid(uv, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec2 uv, float contrast) {\n    return quadGrid(uv, 1.0, contrast);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec2 uv, float gridRes, float contrast) {\n    return quadGrid(uv, gridRes, contrast);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec2 uv, float gridRes) {\n    return quadGrid(uv, gridRes, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec1 uv) {\n    return quadGrid(uv, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec1 uv, float contrast) {\n    return quad", "\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length(p.xy);\n    return d - 0.5;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    float d = length", "\n    return vec3(\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0)\n    );\n}\n\n// makes Cool colormap with polynimal 7\nvec3 Cool7(float t) {\n    return vec3(\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0)\n    );\n}\n\n// makes Cool colormap with polynimal 8\nvec3 Cool8(float t) {\n    return vec3(\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0)\n    );\n}\n\n// makes Cool colormap with polynimal 9\nvec3 Cool9(float t) {\n    return vec3(\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0)\n    );\n}\n\n// makes Cool colormap with polynimal 10\nvec3 Cool10(float t) {\n    return vec3(\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0)\n    );\n}\n\n// makes Cool colormap with polynimal 11\nvec3 Cool11(float t) {\n    return vec3(\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0),\n        clamp(t, 0.0, 1.0)\n    );\n}\n\n// makes Cool colormap with pol", "\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    return m * v;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, vec3 b)\n{\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    return m * (v - b) + b;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c)\n{\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    return m * (v - b) + b + c;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    return m * (v - b) + b + c + d;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a,", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), f.x),\n               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 co) {\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        f += a * noise(co);\n        co = rot * co * 2.0 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec3 co) {\n    float f = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    // Rotate to reduce axial bias\n    mat3 rot = mat3(cos(0.5), sin(0.5), 0.0, -sin(0.5), cos(0.5), 0.0, 0.0, 0.0, 1.0);\n    for (int", "\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p) {\n    return abs(p.x) + abs(p.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec", "\n    vec2 p = uv;\n    vec2 q = vec2(0.5);\n    vec2 r = vec2(0.5);\n    vec2 s = vec2(0.5);\n    vec2 t = vec2(0.5);\n    vec2 u = vec2(0.5);\n    vec2 v = vec2(0.5);\n    vec2 w = vec2(0.5);\n    vec2 x = vec2(0.5);\n    vec2 y = vec2(0.5);\n    vec2 z = vec2(0.5);\n    vec2 a = vec2(0.5);\n    vec2 b = vec2(0.5);\n    vec2 c = vec2(0.5);\n    vec2 d = vec2(0.5);\n    vec2 e = vec2(0.5);\n    vec2 f = vec2(0.5);\n    vec2 g = vec2(0.5);\n    vec2 h = vec2(0.5);\n    vec2 i = vec2(0.5);\n    vec2 j = vec2(0.5);\n    vec2 k = vec2(0.5);\n    vec2 l = vec2(0.5);\n    vec2 m = vec2(0.5);\n    vec2 n = vec2(0.5);\n    vec2 o = vec2(0.5);\n    vec2 p1 = vec2(0.5);\n    vec2 p2 = vec2(0.5);\n    vec2 p3 = vec2(0.5);\n    vec2 p4 = vec2(0.5);\n    vec2 p5 = vec2(0.5);\n    vec2 p6 = vec2(0.5);\n    vec2 p7 = vec2(0.5);\n    vec2 p8 = vec2(0.5", "\n    return mix(vec3(0.267, 0.0048, 1.000), vec3(0.267, 0.0048, 1.000), t) - vec3(0.509, 0.509, 0.509);\n}\n\n// makes plasma colormap with polynimal 6 https://www.shadertoy.com/view/Xds3zK\nvec3 plasma(float t) {\n    return mix(vec3(0.000, 0.000, 0.000), vec3(0.000, 0.000, 0.000), t) - vec3(0.000, 0.000, 0.000);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Xds3zK\nvec3 magma(float t) {\n    return mix(vec3(0.000, 0.000, 0.000), vec3(0.000, 0.000, 0.000), t) - vec3(0.000, 0.000, 0.000);\n}\n\n// makes inferno colormap with polynimal 6 https://www.shadertoy.com/view/Xds3zK\nvec3 inferno(float t) {\n    return mix(vec3(0.000, 0.000, 0.000), vec3(0.000, 0.000, 0.000), t) - vec3(0.000, 0.000, 0.000);\n}\n\n// makes jet colormap with polynimal 6 https://www.shadertoy.com/view/Xds3zK\nvec3 jet(float t) {\n    return mix(vec3(0.000, 0", "\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n  return (x - 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to1(float x) {\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n  return (x - 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to1(float x) {\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n  return (x - 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to1(float x) {\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n  return (x - 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to1(float x) {\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n  return (x - 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make0to1(float x) {\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n", "\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d * 2.0) / len;\n    float f = (sin(a + time) + 1.0) / 2.0;\n    return f * r;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time) {\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d * 2.0) / 1.0;\n    float f = (sin(a + time) + 1.0) / 2.0;\n    return f * r;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes) {\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d * 2.0) / 1.0;\n    float f = (sin(a) + 1.0) / 2.0;\n    return f * r;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset) {\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d * 2.0) / 1.0;\n    float f = (sin(a) + 1.0) / 2.0;\n    return f * r;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv) {\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d * 2", "\n    vec2 p = uv * gridRes;\n    vec2 p2 = p + vec2(0.0, len);\n    vec2 p3 = p + vec2(len, 0.0);\n    vec2 p4 = p + vec2(len, len);\n    vec2 p5 = p + vec2(0.0, len * 2.0);\n    vec2 p6 = p + vec2(len * 2.0, 0.0);\n    vec2 p7 = p + vec2(len * 2.0, len);\n    vec2 p8 = p + vec2(0.0, len * 3.0);\n    vec2 p9 = p + vec2(len * 3.0, 0.0);\n    vec2 p10 = p + vec2(len * 3.0, len);\n    vec2 p11 = p + vec2(0.0, len * 4.0);\n    vec2 p12 = p + vec2(len * 4.0, 0.0);\n    vec2 p13 = p + vec2(len * 4.0, len);\n    vec2 p14 = p + vec2(0.0, len * 5.0);\n    vec2 p15 = p + vec2(len * 5.0, 0.0);\n    vec2 p16 = p + vec2(len * 5.0, len);\n    vec2 p17 = p + vec2(0.0, len * 6.0);\n    vec2 p18 = p + vec2(len * 6.0, 0.0);\n    vec2 p19 = p + vec2(len * 6.0, len);\n    vec2 p20 = p + vec2(0.0, len * 7.0);\n    vec2 p21 = p + vec2(len * 7.0, 0.0);\n    vec2 p2", "\n    vec2 p = point;\n    float r = radius;\n    float t = time;\n    float a = t * 0.001;\n    float b = t * 0.0001;\n    float c = t * 0.00001;\n    float d = t * 0.000001;\n    float e = t * 0.0000001;\n    float f = t * 0.00000001;\n    float g = t * 0.000000001;\n    float h = t * 0.0000000001;\n    float i = t * 0.00000000001;\n    float j = t * 0.000000000001;\n    float k = t * 0.0000000000001;\n    float l = t * 0.00000000000001;\n    float m = t * 0.000000000000001;\n    float n = t * 0.0000000000000001;\n    float o = t * 0.00000000000000001;\n    float p = t * 0.000000000000000001;\n    float q = t * 0.0000000000000000001;\n    float r = t * 0.00000000000000000001;\n    float s = t * 0.000000000000000000001;\n    float t = t * 0.0000000000000000000001;\n    float u = t * 0.000000000", "\n    return vec2(floor(pos.x / 16.0), floor(pos.y / 16.0));\n}\n\n// Computes the center pixel of the tile containing pixel pos and the arrow direction\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir) {\n    return vec2(floor(pos.x / 16.0), floor(pos.y / 16.0)) + dir;\n}\n\n// Computes the center pixel of the tile containing pixel pos and the arrow direction\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 tileSize) {\n    return vec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y)) + dir;\n}\n\n// Computes the center pixel of the tile containing pixel pos and the arrow direction\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 tileSize, vec2 tileOffset) {\n    return vec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y)) + dir + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos and the arrow direction\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 tileSize, vec2 tileOffset, vec2 tileBorder) {\n    return vec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y)) + dir + tileOffset + tileBorder;\n}\n\n// Computes the center pixel of the tile containing pixel pos and the arrow direction\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 tileSize, vec2 tileOffset, vec2 tileBorder, vec2 tileBorderSize) {\n    return vec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y)) + dir + tileOffset + tileBorder + tileBorderSize;\n}\n\n// Computes the center pixel of the tile containing pixel pos and the arrow direction\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 tileSize,", "\n    vec2 v = p - p1;\n    vec2 v1 = p2 - p1;\n    float h = clamp(dot(v, v1), 0.0, length(v1));\n    return length(v - v1 * h / dot(v1, v1)) - length(v1) * 0.5;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    return length(p - c) - r - w;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float w, float k) {\n    return length(p - c) - r - w - k;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float w, float k, float b) {\n    return length(p - c) - r - w - k - b;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float w, float k, float b, float t) {\n    return length(p - c) - r - w - k - b - t;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float w, float k, float b, float t, float s) {\n    return length(p - c) - r - w - k - b - t - s;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float w, float k, float b, float t, float s, float d) {\n    return length(p - c) - r - w - k - b - t - s - d;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r, float", "\n  vec2 q = arrowTileCenterCoord(p);\n  float d = distance(q, p);\n  float l = length(v);\n  return d - l;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float arrowLength) {\n  vec2 q = arrowTileCenterCoord(p);\n  float d = distance(q, p);\n  float l = length(v);\n  return d - l - arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float arrowLength, float arrowWidth) {\n  vec2 q = arrowTileCenterCoord(p);\n  float d = distance(q, p);\n  float l = length(v);\n  return d - l - arrowLength - arrowWidth;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float arrowLength, float arrowWidth, float arrowHeadLength) {\n  vec2 q = arrowTileCenterCoord(p);\n  float d = distance(q, p);\n  float l = length(v);\n  return d - l - arrowLength - arrowWidth - arrowHeadLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float arrowLength, float arrowWidth, float arrowHeadLength, float arrowHeadWidth) {\n  vec2 q = arrowTileCenterCoord(p);\n  float d = distance(q, p);\n  float l = length(v);\n  return d - l - arrowLength - arrowWidth - arrowHeadLength - arrowHeadWidth;\n}\n\n// v = field sampled at arrowTileCenterCoord(p),", "\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n", "\n    vec2 p = point - vec2(0.5);\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = smoothstep(spread, 0.0, r);\n    return vec2(cos(a + offset), sin(a + offset)) * d;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread)\n{\n    return donutFlow(point, spread, 0.0);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point)\n{\n    return donutFlow(point, 0.0);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(float spread)\n{\n    return donutFlow(vec2(0.0));\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow()\n{\n    return donutFlow(vec2(0.0));\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(float spread, float offset)\n{\n    return donutFlow(vec2(0.0), spread, offset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(float spread, float offset, float offset2)\n{\n    return donutFlow(vec2(0.0), spread, offset, offset2);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(float spread, float offset, float offset2, float offset3)\n{\n    return donutFlow(vec2(0.0), spread, offset, offset2, offset3);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(float spread, float offset, float offset2, float offset3, float offset4)\n{\n    return donutFlow(", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float k )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r*clamp(1.0-dot(d,d)/k/k,0.0,1.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float k, in float w )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r*clamp(1.0-(d.x*d.x+d.y*d.y)/k/k,0.0,1.0) - w;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float k, in float w, in float h )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r*clamp(1.0-(d.x*d.", "\n    vec2 q = p - id;\n    return length( q ) - sp;\n}\n\n// the SDF we want to repeat\nfloat sd( in vec2 p, in float time )\n{\n    vec2 q = p;\n    float s = 0.0;\n    float t = 0.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        s += sdBase( q, vec2( 0.0, 0.0 ), 0.01, time );\n        t += sdBase( q, vec2( 0.0, 0.0 ), 0.01, time );\n        q.xz *= 0.8;\n    }\n    return s;\n}\n\n// the SDF we want to repeat\nfloat sd2( in vec2 p, in float time )\n{\n    vec2 q = p;\n    float s = 0.0;\n    float t = 0.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        s += sdBase( q, vec2( 0.0, 0.0 ), 0.01, time );\n        t += sdBase( q, vec2( 0.0, 0.0 ), 0.01, time );\n        q.xz *= 0.8;\n    }\n    return s;\n}\n\n// the SDF we want to repeat\nfloat sd3( in vec2 p, in float time )\n{\n    vec2 q = p;\n    float s = 0.0;\n    float t = 0.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        s += sdBase( q, vec2( 0.0, 0.0 ), 0.01, time );\n        t += sdBase( q, vec2( 0.0, 0.0 ), 0.01, time );\n        q.xz *= 0.8;\n    }\n    return s;\n}\n\n// the SDF we want to repeat", "\n    float d = length(p) - ra;\n    float s = smoothstep(0.0, 1.0, d / sp);\n    return s;\n}\n\n// the point of this shader is to make the circle appear to be a single point\nfloat sdCircularRepetition2( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p) - ra;\n    float s = smoothstep(0.0, 1.0, d / sp);\n    return s;\n}\n\n// the point of this shader is to make the circle appear to be a single point\nfloat sdCircularRepetition3( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p) - ra;\n    float s = smoothstep(0.0, 1.0, d / sp);\n    return s;\n}\n\n// the point of this shader is to make the circle appear to be a single point\nfloat sdCircularRepetition4( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p) - ra;\n    float s = smoothstep(0.0, 1.0, d / sp);\n    return s;\n}\n\n// the point of this shader is to make the circle appear to be a single point\nfloat sdCircularRepetition5( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p) - ra;\n    float s = smoothstep(0.0, 1.0, d / sp);\n    return s;\n}\n\n// the point of this shader is to make the circle appear to be a single point\nfloat sdCircularRepetition6( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p) - ra;\n    float s = smoothstep(0.0, 1.0, d / sp);\n    return s;\n}\n\n// the point of this shader is to make the circle appear to be a single point\nfloat sdCircularRepetition7( in", "\n    return length(uvw);\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw) - 1.0;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    return length(vec2(length(uvw.xz) - 1.0, uvw.y)) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist2(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist3(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist4(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist5(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist6(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist7(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist8(vec3 uvw) {\n    return length(uvw.xz) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist9(vec3 uvw) {\n    return length(uvw.xz) - 1.0;", "\n    vec4 color = vec4(0.0);\n    vec3 uv = uvw.xy;\n    vec3 w = uvw.zw;\n    vec3 i = floor(uv);\n    vec3 f = fract(uv);\n    vec3 w0 = w;\n    vec3 w1 = w + vec3(1.0);\n    vec3 w2 = w + vec3(2.0);\n    vec3 w3 = w + vec3(3.0);\n    vec3 w4 = w + vec3(4.0);\n    vec3 w5 = w + vec3(5.0);\n    vec3 w6 = w + vec3(6.0);\n    vec3 w7 = w + vec3(7.0);\n    vec3 w8 = w + vec3(8.0);\n    vec3 w9 = w + vec3(9.0);\n    vec3 w10 = w + vec3(10.0);\n    vec3 w11 = w + vec3(11.0);\n    vec3 w12 = w + vec3(12.0);\n    vec3 w13 = w + vec3(13.0);\n    vec3 w14 = w + vec3(14.0);\n    vec3 w15 = w + vec3(15.0);\n    vec3 w16 = w + vec3(16.0);\n    vec3 w17 = w + vec3(17.0);\n    vec3 w18 = w + vec3(18.0);\n    vec3 w19 = w + vec3(19.0);\n    vec3 w20 = w + vec3(20.0);\n    vec3 w21 = w + vec3(21.0);\n    vec3 w22 = w + vec3(22.0);\n    vec3 w23 = w + vec3(", "\n    vec3 uv = uvw * gridRes;\n    vec3 ij = floor(uv);\n    vec3 f = fract(uv);\n    vec3 w = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(offset + vec3(0.0, 0.0, 0.0), offset + vec3(1.0, 0.0, 0.0), w.x),\n                   mix(offset + vec3(0.0, 1.0, 0.0), offset + vec3(1.0, 1.0, 0.0), w.x), w.y),\n               mix(mix(offset + vec3(0.0, 0.0, 1.0), offset + vec3(1.0, 0.0, 1.0), w.x),\n                   mix(offset + vec3(0.0, 1.0, 1.0), offset + vec3(1.0, 1.0, 1.0), w.x), w.y), w.z);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes, float scale) {\n    vec3 uv = uvw * gridRes * scale;\n    vec3 ij = floor(uv);\n    vec3 f = fract(uv);\n    vec3 w = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(offset + vec3(0.0, 0.0, 0.0), offset + vec3(1.0, 0.0, 0.0), w.x),\n                   mix(offset + vec3(0.0, 1.0, 0.0), offset + vec3(1.0, 1.0, 0.0), w.x), w.y),\n               mix(mix(offset + vec3(0.0, 0.0, 1.0), offset + vec3(1.", "\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 7 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 8 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 9 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 10 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 11 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0,", "\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    return max(abs(p.x), abs(p.y), abs(p.z));\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetraDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Hexahedron\nfloat hexaDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Heptahedron\nfloat heptaDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    return max(abs(p.x), abs(p.y), abs(p.z));\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n    return max(max(abs", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes night colormap with polynimal 6\nvec3 night(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes day colormap with polynimal 6\nvec3 day(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes night colormap with polynimal 6\nvec3 night(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes day colormap with polynimal 6\nvec3 day(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes night colormap with polynimal 6\nvec3 night(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes day colormap with polynimal 6\nvec3 day(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes night colormap with polynimal 6\nvec3 night(float t) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes day colormap with polynimal 6\nvec3 day(float t) {\n    return vec3", "\n    vec2 texelSize = vec2(1.0) / vec2(16.0);\n    vec2 tile = floor(uv / texelSize);\n    vec2 tileOffset = fract(uv / texelSize);\n    vec2 tileOffset2 = tileOffset * texelSize;\n    vec2 tileOffset3 = tileOffset2 * texelSize;\n    vec2 tileOffset4 = tileOffset3 * texelSize;\n    vec2 tileOffset5 = tileOffset4 * texelSize;\n    vec2 tileOffset6 = tileOffset5 * texelSize;\n    vec2 tileOffset7 = tileOffset6 * texelSize;\n    vec2 tileOffset8 = tileOffset7 * texelSize;\n    vec2 tileOffset9 = tileOffset8 * texelSize;\n    vec2 tileOffset10 = tileOffset9 * texelSize;\n    vec2 tileOffset11 = tileOffset10 * texelSize;\n    vec2 tileOffset12 = tileOffset11 * texelSize;\n    vec2 tileOffset13 = tileOffset12 * texelSize;\n    vec2 tileOffset14 = tileOffset13 * texelSize;\n    vec2 tileOffset15 = tileOffset14 * texelSize;\n    vec2 tileOffset16 = tileOffset15 * texelSize;\n    vec2 tileOffset17 = tileOffset16 * texelSize;\n    vec2 tileOffset18 = tileOffset17 * texelSize;\n    vec2 tileOffset19 = tileOffset18 * texelSize;\n    vec2 tileOffset20 = tileOffset19 * texelSize;\n    vec2 tileOffset21 = tileOffset20 * texelSize;\n    vec2 tileOffset22 = tileOffset21 * texelSize;\n    vec2 tileOffset23 = tileOffset22 * texelSize;\n    vec2 tileOffset24 = tileOffset23 * texelSize;\n    vec2 tileOffset25", "\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float r = atan(p.y, p.x) / 3.1415926535897932384626433832795;\n    return vec3(d, r, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float r = atan(p.y, p.x) / 3.1415926535897932384626433832795;\n    return vec3(d, r, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float r = atan(p.y, p.x) / 3.1415926535897932384626433832795;\n    return vec3(d, r, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n    float r = atan(p.y, p.x) / 3.1415926535897932384626433832795;\n    return vec3(d, r, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 p = uv - vec2(0.5);\n    float d = length(p);\n", "\n    vec2 grid = floor(uv * gridRes) + offset;\n    return vec3(grid.x, grid.y, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes) {\n    return squarePixelizor(uv, gridRes, vec2(0.0));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv) {\n    return squarePixelizor(uv, 1.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, vec2 offset) {\n    return squarePixelizor(uv, 1.0, offset);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, vec2 offset, float gridRes) {\n    return squarePixelizor(uv, gridRes, offset);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, vec2 offset, float gridRes, float scale) {\n    return squarePixelizor(uv, gridRes, offset) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, vec2 offset, float gridRes, float scale, float offsetScale) {\n    return squarePixelizor(uv, gridRes, offset) * scale * offsetScale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, vec2 offset, float gridRes, float scale, float offsetScale, float offsetScale2) {\n    return squarePixelizor(uv, gridRes, offset) * scale * offsetScale * offsetScale2;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, vec2 offset, float gridRes, float scale, float offsetScale, float offsetScale2, float offsetScale3) {\n    return squarePixelizor(uv, gridRes, offset) * scale * offsetScale * offsetScale2 * offset", "\n    vec3 color = vec3(0.0);\n    vec2 uv2 = uv * gridRes;\n    vec2 uv3 = uv2 * gridRes;\n    vec2 uv4 = uv2 * gridRes;\n    vec2 uv5 = uv2 * gridRes;\n    vec2 uv6 = uv2 * gridRes;\n    vec2 uv7 = uv2 * gridRes;\n    vec2 uv8 = uv2 * gridRes;\n    vec2 uv9 = uv2 * gridRes;\n    vec2 uv10 = uv2 * gridRes;\n    vec2 uv11 = uv2 * gridRes;\n    vec2 uv12 = uv2 * gridRes;\n    vec2 uv13 = uv2 * gridRes;\n    vec2 uv14 = uv2 * gridRes;\n    vec2 uv15 = uv2 * gridRes;\n    vec2 uv16 = uv2 * gridRes;\n    vec2 uv17 = uv2 * gridRes;\n    vec2 uv18 = uv2 * gridRes;\n    vec2 uv19 = uv2 * gridRes;\n    vec2 uv20 = uv2 * gridRes;\n    vec2 uv21 = uv2 * gridRes;\n    vec2 uv22 = uv2 * gridRes;\n    vec2 uv23 = uv2 * gridRes;\n    vec2 uv24 = uv2 * gridRes;\n    vec2 uv25 = uv2 * gridRes;\n    vec2 uv26 = uv2 * gridRes;\n    vec2 uv27 = uv2 * gridRes;\n    vec2 uv28 = uv2 * gridRes;\n    vec2 uv29 = uv2 * gridRes;\n    vec2 uv30 = uv2 * gridRes;\n    vec2 uv31 = uv2", "\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - len) / (len * 2.0);\n    float w = r * 2.0 * PI;\n    float t = time * 0.001;\n    float s = sin(w * t);\n    float c = cos(w * t);\n    float x = (c * cos(a) - s * sin(a)) * gridRes;\n    float y = (c * sin(a) + s * cos(a)) * gridRes;\n    return length(vec2(x, y));\n}\n\n// generates pixelated directional waves\nfloat flowSquare(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - len) / (len * 2.0);\n    float w = r * 2.0 * PI;\n    float t = time * 0.001;\n    float s = sin(w * t);\n    float c = cos(w * t);\n    float x = (c * cos(a) - s * sin(a)) * gridRes;\n    float y = (c * sin(a) + s * cos(a)) * gridRes;\n    return length(vec2(x, y));\n}\n\n// generates pixelated directional waves\nfloat flowSquare(vec2 uv, vec2 offset, float gridRes, float time) {\n    vec2 p = uv - offset;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = d / 100.0;\n    float w = r * 2.0 * PI;\n    float t = time * 0.001;\n    float s = sin(w * t);\n    float c = cos(w * t);\n    float x = (c", "\n    vec2 p = uv * gridRes;\n    vec2 q = vec2(p.x, p.y + time);\n    vec2 r = vec2(p.x + time, p.y);\n    vec2 s = vec2(p.x, p.y - time);\n    vec2 t = vec2(p.x - time, p.y);\n    vec2 u = vec2(p.x + time, p.y + time);\n    vec2 v = vec2(p.x - time, p.y - time);\n    vec2 w = vec2(p.x + time, p.y - time);\n    vec2 x = vec2(p.x - time, p.y + time);\n    vec2 y = vec2(p.x, p.y + time);\n    vec2 z = vec2(p.x, p.y - time);\n    vec2 a = vec2(p.x - time, p.y);\n    vec2 b = vec2(p.x, p.y - time);\n    vec2 c = vec2(p.x + time, p.y);\n    vec2 d = vec2(p.x, p.y + time);\n    vec2 e = vec2(p.x + time, p.y + time);\n    vec2 f = vec2(p.x - time, p.y + time);\n    vec2 g = vec2(p.x + time, p.y - time);\n    vec2 h = vec2(p.x - time, p.y - time);\n    vec2 i = vec2(p.x, p.y);\n    vec2 j = vec2(p.x - time, p.y - time);\n    vec2 k = vec2(p.x + time, p.y - time);\n    vec2 l = vec2(p.x - time, p.y + time);\n    vec2 m = vec2(p.x + time,", "\n    vec2 b = sign( ddx );\n    vec2 s = sign( ddy );\n    vec2 f = fract( p );\n    vec2 u = b*f + (s-b)*max(b,s);\n    return length( u - f );\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 b = sign( ddx );\n    vec2 s = sign( ddy );\n    vec2 f = fract( p );\n    vec2 u = b*f + (s-b)*max(b,s);\n    return length( u - f );\n}\n\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 b = sign( ddx );\n    vec2 s = sign( ddy );\n    vec2 f = fract( p );\n    vec2 u = b*f + (s-b)*max(b,s);\n    return length( u - f ) - 0.00001;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 b = sign( ddx );\n    vec2 s = sign( ddy );\n    vec2 f = fract( p );\n    vec2 u = b*f + (s-b)*max(b,s);\n    return length( u - f ) - 0.00001;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    vec2 b = sign( ddx );\n    vec2 s = sign( ddy );\n    vec2 f = fract( p );\n    vec2 u = b*f + (s-b)*max(b,s);\n    return length( u - f ) - 0.00001 * scale;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 d", "\n    float h = distance(p, vec2(0.0, 0.0));\n    return max(h - r, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat diamond(vec2 p, float r) {\n    float h = distance(p, vec2(0.0, 0.0));\n    return max(h - r, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangle(vec2 p, float r) {\n    float h = distance(p, vec2(0.0, 0.0));\n    return max(h - r, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r) {\n    float h = distance(p, vec2(0.0, 0.0));\n    return max(h - r, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat cross(vec2 p, float r) {\n    float h = distance(p, vec2(0.0, 0.0));\n    return max(h - r, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat square(vec2 p, float r) {\n    float h = distance(p, vec2(0.0, 0.0));\n    return max(h - r, 0.0);\n}\n\n// License: MIT, author:", "\n    p = mod(p, 2.0);\n    if (p.x > p.y) {\n        p.xy = p.yx;\n    }\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n    p = mod(p, 2.0);\n    if (p.x > p.y) {\n        p.xy = p.yx;\n    }\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n    p = mod(p, 2.0);\n    if (p.x > p.y) {\n        p.xy = p.yx;\n    }\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n    p = mod(p, 2.0);\n    if (p.x > p.y) {\n        p.xy = p.yx;\n    }\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n    p = mod(p, 2.0);\n    if (p.x > p.y) {\n        p.xy = p.yx;\n    }\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2", "\n    return 0.5 + 0.5*sin( 6.28318530718*x );\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( fun(n+  0.0), fun(n+  1.0),f.x),\n                    mix( fun(n+  57.0), fun(n+  58.0),f.x),f.y),\n               mix(mix( fun(n+113.0), fun(n+114.0),f.x),\n                    mix( fun(n+170.0), fun(n+171.0),f.x),f.y),f.z);\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec2 x )\n{\n    return noise( vec3(x,0.0) );\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec3 x )\n{\n    return noise( vec3(x.x,x.y,0.0) );\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec4 x )\n{\n    return noise( vec3(x.x,x.y,x.z) );\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec2 x, float seed )\n{\n    return noise( vec2(x.x,x.y), seed );\n}\n\n// noise, https://www.shadertoy", "\n    return pow(t, vec3(1.0 / 2.4));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverse(vec3 t) {\n    return pow(t, vec3(2.4));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBGamma(vec3 t) {\n    return pow(t, vec3(1.0 / 1.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverseGamma(vec3 t) {\n    return pow(t, vec3(1.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBLinear(vec3 t) {\n    return t;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverseLinear(vec3 t) {\n    return t;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBLinearGamma(vec3 t) {\n    return pow(t, vec3(1.0 / 1.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGBInverseLinearGamma(vec3 t) {\n    return pow(t, vec3(1.2));\n}\n\n// License: Unknown, author: nmz (twitter: @", "\n    return 0.0;\n}\n\nfloat df1(vec2 p) {\n    return 0.0;\n}\n\nfloat df2(vec2 p) {\n    return 0.0;\n}\n\nfloat df3(vec2 p) {\n    return 0.0;\n}\n\nfloat df4(vec2 p) {\n    return 0.0;\n}\n\nfloat df5(vec2 p) {\n    return 0.0;\n}\n\nfloat df6(vec2 p) {\n    return 0.0;\n}\n\nfloat df7(vec2 p) {\n    return 0.0;\n}\n\nfloat df8(vec2 p) {\n    return 0.0;\n}\n\nfloat df9(vec2 p) {\n    return 0.0;\n}\n\nfloat df10(vec2 p) {\n    return 0.0;\n}\n\nfloat df11(vec2 p) {\n    return 0.0;\n}\n\nfloat df12(vec2 p) {\n    return 0.0;\n}\n\nfloat df13(vec2 p) {\n    return 0.0;\n}\n\nfloat df14(vec2 p) {\n    return 0.0;\n}\n\nfloat df15(vec2 p) {\n    return 0.0;\n}\n\nfloat df16(vec2 p) {\n    return 0.0;\n}\n\nfloat df17(vec2 p) {\n    return 0.0;\n}\n\nfloat df18(vec2 p) {\n    return 0.0;\n}\n\nfloat df19(vec2 p) {\n    return 0.0;\n}\n\nfloat df20(vec2 p) {\n    return 0.0;\n}\n\nfloat df21(vec2 p) {\n    return 0.0;\n}\n\nfloat df22(vec2 p) {\n    return 0.0;\n}\n\nfloat df23(vec2 p) {\n    return 0.0;\n}\n\nfloat df2", "\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df6(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df7(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df8(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df9(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df10(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df11(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df12(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df13(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df14(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df15(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df16(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df17(vec2 p) {\n    return 0.0;\n}\n\n// Multiscale truchet\nfloat df18(vec2 p) {\n    return 0.0;\n}", "\n    vec2 v0 = p1 - p0;\n    vec2 v1 = p2 - p0;\n    vec2 v2 = p - p0;\n    float a = dot(v0,v0);\n    float b = dot(v1,v1);\n    float c = dot(v2,v2);\n    float d = b*a - c*c;\n    if( d < 0.0 ) return length(v2) * sign(c);\n    float e = a*c - b*b;\n    if( e < 0.0 ) return length(v0) * sign(b);\n    float f = a*a - b*c;\n    float sc = (d>0.0)?sqrt(d):0.0;\n    float sd = (f>0.0)?sqrt(f):0.0;\n    float sf = (e>0.0)?sqrt(e):0.0;\n    float m = max(sc,sd);\n    float n = min(sf,m);\n    float p = (sc>sf)?sc:sf;\n    return p*sign(n-p);\n}\n\n// signed distance to a 2D circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// signed distance to a 2D square\nfloat sdSquare( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D rectangle\nfloat sdRect( in vec2 p, in vec2 a )\n{\n    vec2 d = abs(p) - a;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if(t < dbuffer) t = -b + h;\n    if(t < dbuffer) return -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphinv(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b + h;\n    if(t < dbuffer) t = -b - h;\n    if(t < dbuffer) return -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphinv(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float tmin, float tmax) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t =", "\n    return floor(p.x + w * 0.5) - w * 0.5 + r;\n}\n\nfloat roundedY(vec2 p, float h, float r) {\n    return floor(p.y + h * 0.5) - h * 0.5 + r;\n}\n\nfloat roundedXY(vec2 p, float w, float h, float r) {\n    return floor(p.x + w * 0.5) - w * 0.5 + r\n        + floor(p.y + h * 0.5) - h * 0.5 + r;\n}\n\nfloat roundedXYZ(vec3 p, float w, float h, float d, float r) {\n    return floor(p.x + w * 0.5) - w * 0.5 + r\n        + floor(p.y + h * 0.5) - h * 0.5 + r\n        + floor(p.z + d * 0.5) - d * 0.5 + r;\n}\n\nfloat roundedXYZW(vec4 p, float w, float h, float d, float r) {\n    return floor(p.x + w * 0.5) - w * 0.5 + r\n        + floor(p.y + h * 0.5) - h * 0.5 + r\n        + floor(p.z + d * 0.5) - d * 0.5 + r\n        + floor(p.w + r * 0.5) - r * 0.5;\n}\n\nfloat roundedXYZW(vec4 p, float w, float h, float d, float r, float t) {\n    return floor(p.x + w * 0.5) - w * 0.5 + r\n        + floor(p.y + h * 0.5) - h * 0.5 + r\n        + floor(p.z + d * 0.5) - d * 0.5 + r\n        + floor(p.w + r * 0.5) - r * 0.5\n        + floor(p.w + t * ", "\n    return length( p - vec2( k, 0.0 ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicTangent( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicSine( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCosine( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicTangent2( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicSine2( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCosine2( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicTangent3( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicSine3( in vec2 p, float k )\n{\n    return length( p - vec2( 0.0, k ) ) - k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCosine3( in vec2 p, float", "\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.y );\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) + k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) + k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT", "\n    return abs(a) - k;\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float k) {\n    return step(k, a);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float b, float k) {\n    return step(k, a) * step(k, b);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float b, float c, float k) {\n    return step(k, a) * step(k, b) * step(k, c);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float b, float c, float d, float k) {\n    return step(k, a) * step(k, b) * step(k, c) * step(k, d);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float b, float c, float d, float e, float k) {\n    return step(k, a) * step(k, b) * step(k, c) * step(k, d) * step(k, e);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float b, float c, float d, float e, float f, float k) {\n    return step(k, a) * step(k, b) * step(k, c) * step(k, d) * step(k, e) * step(k,", "\n    vec2 q = vec2(length(p.xz), p.y);\n    return length(q - vec2(sin(q.x), cos(q.y))) * 0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r, float w) {\n    return length(p) - r - w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r, float w, float k) {\n    return length(p) - (r + w) - k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r, float w, float k, float b) {\n    return length(p) - (r + w) - k - b;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r, float w, float k, float b, float t) {\n    return length(p) - (r + w) - k - b - t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r, float w, float k, float b, float t, float s", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Cosine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    return fract(cos(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Tangent https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    return fract(tan(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Perlin Noise https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Perlin Noise https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash with Perlin Noise https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 4", "\n    vec2 p = pos - A;\n    vec2 dp = B - A;\n    vec2 dp2 = C - B;\n    float k = dot( dp, dp );\n    float k2 = dot( dp2, dp2 );\n    float t = dot( p, dp ) / k;\n    float t2 = dot( p, dp2 ) / k2;\n    float t3 = t * t;\n    float t4 = t2 * t2;\n    float t5 = t3 * t2;\n    float t6 = t4 * t2;\n    float t7 = t5 * t2;\n    float t8 = t6 * t2;\n    float t9 = t7 * t2;\n    float t10 = t8 * t2;\n    float t11 = t9 * t2;\n    float t12 = t10 * t2;\n    float t13 = t11 * t2;\n    float t14 = t12 * t2;\n    float t15 = t13 * t2;\n    float t16 = t14 * t2;\n    float t17 = t15 * t2;\n    float t18 = t16 * t2;\n    float t19 = t17 * t2;\n    float t20 = t18 * t2;\n    float t21 = t19 * t2;\n    float t22 = t20 * t2;\n    float t23 = t21 * t2;\n    float t24 = t22 * t2;\n    float t25 = t23 * t2;\n    float t26 = t24 * t2;\n    float t27 = t25 * t2;\n    float t28 = t26 * t2;\n    float t29 = t27 * t2;\n    float t30 = t28 * t2;\n    float t31 = t29 * t2;\n    float t32 = t30 * t2;\n    float t33 = t31 * t", "\n    vec2 p = pos;\n    float h = he;\n    float w = wi;\n    float a = w*w;\n    float b = h*h;\n    float c = a*b;\n    float d = a*c;\n    float e = b*c;\n    float f = a*e;\n    float g = b*e;\n    float h = c*e;\n    float i = a*h;\n    float j = b*h;\n    float k = c*h;\n    float l = a*k;\n    float m = b*k;\n    float n = c*k;\n    float o = a*n;\n    float p = b*n;\n    float q = c*n;\n    float r = a*o;\n    float s = b*o;\n    float t = c*o;\n    float u = a*p;\n    float v = b*p;\n    float w = c*p;\n    float x = a*q;\n    float y = b*q;\n    float z = c*q;\n    float aa = a*w;\n    float ab = b*w;\n    float ac = c*w;\n    float ad = a*t;\n    float ae = b*t;\n    float af = c*t;\n    float ag = a*u;\n    float ah = b*u;\n    float ai = c*u;\n    float aj = a*v;\n    float ak = b*v;\n    float al = c*v;\n    float am = a*w;\n    float an = b*w;\n    float ao = c*w;\n    float ap = a*x;\n    float aq = b*x;\n    float ar = c*x;\n    float as = a*y;\n    float at = b*y;\n    float au = c*y;\n    float av = a*z;\n    float aw = b*z;\n    float ax = c*z;\n    float ay = a*a;\n    float ay2 = ay*ay;\n    float ay3 = ay*ay2;\n    float", "\n    vec2 p = pos;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float b = k * d;\n    float c = k * d * d;\n    return vec3(d, a, b + c);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos, in vec2 r )\n{\n    vec2 p = pos;\n    vec2 q = p - r;\n    float a = dot(q, q) / dot(r, r);\n    float b = length(q);\n    float c = a * (1.0 - b * b);\n    return vec3(b, a, c);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos, in vec2 r, in vec2 s )\n{\n    vec2 p = pos;\n    vec2 q = p - r;\n    vec2 rr = r * r;\n    vec2 ss = s * s;\n    float a = dot(q, q) / dot(rr, ss);\n    float b = length(q);\n    float c = a * (1.0 - b * b);\n    return vec3(b, a, c);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos,", "\n    vec2 q = vec2(cos(d), sin(d)) * p;\n    vec2 r = vec2(cos(ra), sin(ra)) * p;\n    vec2 s = vec2(cos(rb), sin(rb)) * p;\n    return vec3(q.x, q.y, 0.0) - vec3(r.x, r.y, 0.0) - vec3(s.x, s.y, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdMoon(vec2 p, float d, float ra, float rb, float rc )\n{\n    vec2 q = vec2(cos(d), sin(d)) * p;\n    vec2 r = vec2(cos(ra), sin(ra)) * p;\n    vec2 s = vec2(cos(rb), sin(rb)) * p;\n    vec2 t = vec2(cos(rc), sin(rc)) * p;\n    return vec3(q.x, q.y, 0.0) - vec3(r.x, r.y, 0.0) - vec3(s.x, s.y, 0.0) - vec3(t.x, t.y, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdMoon(vec2 p, float d, float ra, float rb, float rc, float rd )\n{\n    vec2 q = vec2(cos(d), sin(d)) * p;\n    vec2 r = vec2(cos(ra", "\n    v.x += v.y;\n    v.y = (v.x << 16) ^ v.x;\n    v.x = (v.x << 12) ^ v.y;\n    v.y = (v.y << 8) ^ v.x;\n    v.x = (v.x << 7) ^ v.y;\n    return v;\n}\n\nivec2 Pcg3(ivec2 v)\n{\n    v.x += v.y;\n    v.y = (v.x << 16) ^ v.x;\n    v.x = (v.x << 12) ^ v.y;\n    v.y = (v.y << 8) ^ v.x;\n    v.x = (v.x << 5) ^ v.y;\n    return v;\n}\n\nivec2 Pcg4(ivec2 v)\n{\n    v.x += v.y;\n    v.y = (v.x << 16) ^ v.x;\n    v.x = (v.x << 12) ^ v.y;\n    v.y = (v.y << 8) ^ v.x;\n    v.x = (v.x << 4) ^ v.y;\n    return v;\n}\n\nivec2 Pcg5(ivec2 v)\n{\n    v.x += v.y;\n    v.y = (v.x << 16) ^ v.x;\n    v.x = (v.x << 12) ^ v.y;\n    v.y = (v.y << 8) ^ v.x;\n    v.x = (v.x << 3) ^ v.y;\n    return v;\n}\n\nivec2 Pcg6(ivec2 v)\n{\n    v.x += v.y;\n    v.y = (v.x << 16) ^ v.x;\n    v.x = (v.x << 12) ^ v.y;\n    v.y = (v.y << 8) ^ v.x;\n    v.x = (v.x << 2) ^", "\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.z * 15731u;\n    v.z += v.x * 15731u;\n    v.x += v.y * 15731u;\n    v.y += v.", "\n    vec2 p = pos - A;\n    vec2 ab = B - A;\n    vec2 bc = C - B;\n    float a = dot(p, ab);\n    float b = dot(p, bc);\n    float c = dot(p, p);\n    float d = dot(ab, ab);\n    float e = dot(bc, bc);\n    float f = dot(ab, bc);\n    float g = (a * a) - (d * e) + (b * b) - (c * c);\n    float h = (a * a) - (e * e) + (c * c) - (d * d);\n    float i = (a * a) - (f * f) + (b * b) - (e * e);\n    float j = (a * a) - (g * g) + (c * c) - (f * f);\n    float k = (a * a) - (h * h) + (d * d) - (g * g);\n    float l = (a * a) - (i * i) + (e * e) - (h * h);\n    float m = (a * a) - (j * j) + (f * f) - (i * i);\n    float n = (a * a) - (k * k) + (g * g) - (j * j);\n    float t = (a * a) - (l * l) + (h * h) - (k * k);\n    float u = (a * a) - (m * m) + (i * i) - (l * l);\n    float v = (a * a) - (n * n) + (j * j) - (m * m);\n    float w = (a * a) - (t * t) + (k * k) - (n * n);\n    float x = (a * a) - (u * u) + (l * l) - (t * t);\n    float y = (a * a) - (v * v) + (m * m) - (u * u);\n    float z = (a * a) - (w * w) +", "\n    return (p.x - a.x) * (p.y - b.y) - (p.y - a.y) * (p.x - b.x);\n}\n\n// Source: https://www.shadertoy.com/view/4dXGRW\nfloat sd_circle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// Source: https://www.shadertoy.com/view/4dXGRW\nfloat sd_ellipse(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 d = abs(p) - a;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - b.x;\n}\n\n// Source: https://www.shadertoy.com/view/4dXGRW\nfloat sd_triangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    float s = sign(winding_sign(p, a, b));\n    float t = sign(winding_sign(p, b, c));\n    float u = sign(winding_sign(p, c, a));\n    float w = s + t - u;\n    float d = min(min(winding_sign(ap, ab, ac), winding_sign(bp, ab, ac)), winding_sign(cp, ab, ac));\n    return sqrt(max(0.0, d)) / length(ab);\n}\n\n// Source: https://www.shadertoy.com/view/4dXGRW\nfloat sd_rect(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 d = abs(p) - a;\n    return length(max(d, 0", "\n    vec4 res = vec4( 1e10 );\n    vec3 d = abs(rd.xyz);\n    vec3 q = -ro.xyz + s.xyz;\n    vec3 b = -q.yzx;\n    vec3 c = -q.zxy;\n    vec3 t = max(b,c);\n    vec3 u = min(b,c);\n    vec3 v = max(t,u);\n    vec3 w = min(t,u);\n    vec3 a = v - w;\n    vec3 bb = max(a,0.0);\n    vec3 cc = max(a.yzx,0.0);\n    vec3 dd = max(a.zxy,0.0);\n    vec3 e = min(dd,cc);\n    vec3 f = min(dd,bb);\n    vec3 g = min(e,f);\n    vec3 h = max(g,0.0);\n    vec3 i = max(h,0.0);\n    vec3 j = max(i,0.0);\n    vec3 k = max(j,0.0);\n    vec3 l = max(k,0.0);\n    vec3 m = max(l,0.0);\n    vec3 n = max(m,0.0);\n    vec3 o = max(n,0.0);\n    vec3 p = max(o,0.0);\n    vec3 q = max(p,0.0);\n    vec3 r = max(q,0.0);\n    vec3 s = max(r,0.0);\n    vec3 tt = max(s,0.0);\n    vec3 uu = max(tt,0.0);\n    vec3 vv = max(uu,0.0);\n    vec3 ww = max(vv,0.0);\n    vec3 xx = max(ww,0.0);\n    vec3 yy = max(xx,0.0);\n    vec3", "\n    int a_i24 = a;\n    float b_f32 = b;\n    float x_f32 = x;\n    int a_i12 = a_i24 >> 12;\n    int a_i10 = a_i24 >> 2;\n    int a_i8 = a_i24 >> 1;\n    int a_i6 = a_i24 >> 1;\n    int a_i4 = a_i24 >> 1;\n    int a_i2 = a_i24 >> 1;\n    int a_i0 = a_i24 >> 1;\n    int a_i1 = a_i24 >> 1;\n    int a_i3 = a_i24 >> 1;\n    int a_i5 = a_i24 >> 1;\n    int a_i7 = a_i24 >> 1;\n    int a_i9 = a_i24 >> 1;\n    int a_i11 = a_i24 >> 1;\n    int a_i13 = a_i24 >> 1;\n    int a_i15 = a_i24 >> 1;\n    int a_i17 = a_i24 >> 1;\n    int a_i19 = a_i24 >> 1;\n    int a_i21 = a_i24 >> 1;\n    int a_i23 = a_i24 >> 1;\n    int a_i25 = a_i24 >> 1;\n    int a_i26 = a_i24 >> 1;\n    int a_i27 = a_i24 >> 1;\n    int a_i28 = a_i24 >> 1;\n    int a_i29 = a_i24 >> 1;\n    int a_i30 = a_i24 >> 1;\n    int a_i31 = a_i24 >> 1;\n    int a_i32 = a_i24 >> 1;\n   ", "\n    vec3 d = abs(a-b);\n    return vec3(\n        min(d.x, min(d.y, d.z)),\n        min(d.yz.x, min(d.yz.y, d.yz.z)),\n        min(d.yz.z, min(d.yz.y, d.yz.x))\n    ) / k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    vec3 d = abs(a-b);\n    return vec3(\n        max(d.x, max(d.y, d.z)),\n        max(d.yz.x, max(d.yz.y, d.yz.z)),\n        max(d.yz.z, max(d.yz.y, d.yz.x))\n    ) / k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSAdd( in vec3 a, in vec3 b, in float k )\n{\n    vec3 d = abs(a-b);\n    return vec3(\n        a.x+b.x,\n        a.y+b.y,\n        a.z+b.z\n    ) / k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 un", "\n    vec2 ap = p - ab;\n    float a = length(ap);\n    float b = length(ab);\n    float c = a + b;\n    float d = a - b;\n    float e = a * b;\n    float f = a * d;\n    float g = b * d;\n    float h = c * d;\n    float i = c * e;\n    float j = c * f;\n    float k = c * g;\n    float l = c * h;\n    float m = c * i;\n    float n = c * j;\n    float o = c * k;\n    float p = c * l;\n    float q = c * m;\n    float r = c * n;\n    float s = c * o;\n    float t = c * p;\n    float u = c * q;\n    float v = c * r;\n    float w = c * s;\n    float x = c * t;\n    float y = c * u;\n    float z = c * v;\n    float aa = a * a;\n    float bb = b * b;\n    float cc = c * c;\n    float dd = d * d;\n    float ee = e * e;\n    float ff = f * f;\n    float gg = g * g;\n    float hh = h * h;\n    float ii = i * i;\n    float jj = j * j;\n    float kk = k * k;\n    float ll = l * l;\n    float mm = m * m;\n    float nn = n * n;\n    float oo = o * o;\n    float pp = p * p;\n    float qq = q * q;\n    float rr = r * r;\n    float ss = s * s;\n    float tt = t * t;\n    float uu = u * u;\n    float vv = v * v;\n    float ww = w * w;\n    float xx = x * x;\n    float yy = y * y;\n    float zz = z * z;\n    float aaa = aa * aa;\n    float", "\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_2(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_3(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_4(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_5(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_6(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_7(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_8(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_9(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_10(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_11(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_12(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_ploss_13(in float a, in float b){\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat add_pl", "\n    vec2 p1 = vec2( ab.x, ab.y - s1 );\n    vec2 p2 = vec2( ab.x, ab.y + s1 );\n    vec2 p3 = vec2( ab.x + s2, ab.y );\n    vec2 p4 = vec2( ab.x - s2, ab.y );\n    vec2 p5 = vec2( ab.x, ab.y );\n    vec2 p6 = vec2( ab.x, ab.y );\n    vec2 p7 = vec2( ab.x, ab.y );\n    vec2 p8 = vec2( ab.x, ab.y );\n    vec2 p9 = vec2( ab.x, ab.y );\n    vec2 p10 = vec2( ab.x, ab.y );\n    vec2 p11 = vec2( ab.x, ab.y );\n    vec2 p12 = vec2( ab.x, ab.y );\n    vec2 p13 = vec2( ab.x, ab.y );\n    vec2 p14 = vec2( ab.x, ab.y );\n    vec2 p15 = vec2( ab.x, ab.y );\n    vec2 p16 = vec2( ab.x, ab.y );\n    vec2 p17 = vec2( ab.x, ab.y );\n    vec2 p18 = vec2( ab.x, ab.y );\n    vec2 p19 = vec2( ab.x, ab.y );\n    vec2 p20 = vec2( ab.x, ab.y );\n    vec2 p21 = vec2( ab.x, ab.y );\n    vec2 p22 = vec2( ab.x, ab.y );\n    vec2 p23 = vec2( ab.x, ab.y );\n    vec2 p24 = vec2( ab.x, ab.y );\n    vec2", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0.0)\n        return vec4(0.0);\n    if (t > 1.0)\n        return vec4(0.0);\n    vec3 cp = a + ab * t;\n    float d = length(cp - p);\n    if (d > rb)\n        return vec4(0.0);\n    if (d > ra)\n        return vec4(cp, 1.0);\n    return vec4(cp, 0.0);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float rc)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0.0)\n        return vec4(0.0);\n    if (t > 1.0)\n        return vec4(0.0);\n    vec3 cp = a + ab * t;\n    float d = length(cp - p);\n    if (d > rc)\n        return vec4(0.0);\n    if (d > rb)\n        return vec4(cp, 1.0);\n    if (d > ra)\n        return vec4(cp, 0.0);\n    return vec4(cp, 0.0);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float rc, float rd)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r1, float r2 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ( r1 + (r2-r1)*clamp( (pa.y-a.y)/ba.y, 0.0, 1.0 ) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return length(p/r) - 1.0;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+q.y*0.5,q.y*0.866025+q.z*0.5)-h.x);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdIcosahed", "\n    return length(p-cen) - rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec3 cen, vec3 dir, float rad, float h )\n{\n    vec3 q = p - cen;\n    float b = dot(q,dir);\n    float c = dot(q,q) - rad*rad;\n    float hc = h*h - c;\n    if( hc < 0.0 ) return length(q) - h;\n    float d2 = b*b - hc;\n    if( d2 < 0.0 ) return length(q) - h;\n    return sqrt(d2) - b;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec3 cen, vec3 dir, float rad, float h )\n{\n    vec3 q = p - cen;\n    float b = dot(q,dir);\n    float c = dot(q,q) - rad*rad;\n    float d = b*b - c;\n    if( d < 0.0 ) return length(q) - h;\n    return sqrt(d) - b;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat s", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        sdfSphere( pos + eps.xyy, 0.01 ) - sdfSphere( pos - eps.xyy, 0.01 ),\n        sdfSphere( pos + eps.yxy, 0.01 ) - sdfSphere( pos - eps.yxy, 0.01 ),\n        sdfSphere( pos + eps.yyx, 0.01 ) - sdfSphere( pos - eps.yyx, 0.01 )\n    );\n    if ( showSurface )\n    {\n        n = normalize( n );\n    }\n    else\n    {\n        n = normalize( n - 0.5 * ( sdfSphere( pos + eps.xyy, 0.01 ) - sdfSphere( pos - eps.xyy, 0.01 ) ) );\n    }\n    return n;\n}\n\n// https://iquilezles.org/articles/sdf002/\nfloat sdfBox( vec3 p, vec3 b )\n{\n    vec3 q = abs( p ) - b;\n    return length( max( q, 0.0 ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0 );\n}\n\n// https://iquilezles.org/articles/sdf003/\nfloat sdfCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// https://iquilezles.org/articles/sdf004/\nfloat sdfCone( vec3 p, vec2 h )\n{\n    float", "\n    float res = 1.0;\n    float bias = 0.005;\n    float bias2 = 0.0005;\n    float bias3 = 0.00005;\n    float bias4 = 0.000005;\n    float bias5 = 0.0000005;\n    float bias6 = 0.00000005;\n    float bias7 = 0.000000005;\n    float bias8 = 0.0000000005;\n    float bias9 = 0.00000000005;\n    float bias10 = 0.000000000005;\n    float bias11 = 0.0000000000005;\n    float bias12 = 0.00000000000005;\n    float bias13 = 0.000000000000005;\n    float bias14 = 0.0000000000000005;\n    float bias15 = 0.00000000000000005;\n    float bias16 = 0.000000000000000005;\n    float bias17 = 0.0000000000000000005;\n    float bias18 = 0.00000000000000000005;\n    float bias19 = 0.000000000000000000005;\n    float bias20 = 0.0000000000000000000005;\n    float bias21 = 0.00000000000000000000005;\n    float bias22 = 0.000000000000000000000", "\n    vec2 d = abs(p) - vec2(ra, rb);\n    vec2 q = vec2(max(d.x, 0.0), max(d.y, 0.0));\n    vec2 r = vec2(max(q.x, 0.0), max(q.y, 0.0));\n    vec2 s = vec2(max(r.x, 0.0), max(r.y, 0.0));\n    vec2 t = vec2(max(s.x, 0.0), max(s.y, 0.0));\n    vec2 u = vec2(max(t.x, 0.0), max(t.y, 0.0));\n    vec2 v = vec2(max(u.x, 0.0), max(u.y, 0.0));\n    vec2 w = vec2(max(v.x, 0.0), max(v.y, 0.0));\n    vec2 x = vec2(max(w.x, 0.0), max(w.y, 0.0));\n    vec2 y = vec2(max(x.x, 0.0), max(x.y, 0.0));\n    vec2 z = vec2(max(y.x, 0.0), max(y.y, 0.0));\n    vec2 o = vec2(max(z.x, 0.0), max(z.y, 0.0));\n    vec2 c = vec2(max(o.x, 0.0), max(o.y, 0.0));\n    vec2 dd = vec2(max(c.x, 0.0), max(c.y, 0.0));\n    vec2 e = vec2(max(dd.x, 0.0), max(dd.y, 0.0));\n    vec2 f = vec2(max(e.x, 0.0), max(e.y,", "\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    return vec4(length(q)-rb, 0.0, 0.0, 0.0);\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    return vec4(max(abs(q.x)-rb, q.y), 0.0, 0.0, 0.0);\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCone( vec3 p, float ra, float rb )\n{\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    return vec4(max(abs(q.x)-rb, max(q.y, -q.x)), 0.0, 0.0, 0.0);\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCapsule( vec3 p, float ra, float rb )\n{\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    return vec4(max(abs(q.x)-rb, abs(q.y)-ra), 0.0, 0.0, 0.0);\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCapsule2( vec3 p, float ra, float rb )\n{\n    vec2 q = vec2( length(p.xz) - ra, p.y );\n    return vec4(max(abs(q.x)-rb, abs(q.y)-ra), 0.0, 0.0, 0.0);\n}\n\n//where is major", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdRoundRect( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-a;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdEllipse( in vec2 p, in vec2 a )\n{\n    return length(p/a)*length(a);\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdRhombus( in vec2 p, in vec2 a )\n{\n    return length(p.y/a.y)*length(abs(p.x/a.x)-0.5);\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p", "\n    return dot(v, v);\n}\n\nfloat length2(in vec3 v) {\n    return sqrt(dot2(v));\n}\n\nfloat length2(in vec2 v) {\n    return sqrt(dot2(v));\n}\n\nfloat length2(in vec4 v) {\n    return sqrt(dot2(v));\n}\n\nfloat length2(in vec3 v, in vec3 w) {\n    return sqrt(dot2(v - w));\n}\n\nfloat length2(in vec2 v, in vec2 w) {\n    return sqrt(dot2(v - w));\n}\n\nfloat length2(in vec4 v, in vec4 w) {\n    return sqrt(dot2(v - w));\n}\n\nfloat length2(in vec3 v, in vec2 w) {\n    return sqrt(dot2(v - vec3(w, 0.0)));\n}\n\nfloat length2(in vec2 v, in vec3 w) {\n    return sqrt(dot2(v - vec2(w, 0.0)));\n}\n\nfloat length2(in vec4 v, in vec2 w) {\n    return sqrt(dot2(v - vec4(w, 0.0, 0.0)));\n}\n\nfloat length2(in vec2 v, in vec4 w) {\n    return sqrt(dot2(v - vec2(w, 0.0)));\n}\n\nfloat length2(in vec3 v, in vec4 w) {\n    return sqrt(dot2(v - vec3(w, 0.0)));\n}\n\nfloat length2(in vec4 v, in vec3 w) {\n    return sqrt(dot2(v - vec4(w, 0.0, 0.0)));\n}\n\nfloat length2(in vec4 v, in vec4 w) {\n    return sqrt(dot2(v - w));\n}\n\nfloat length2(in vec4 v, in vec4 w, in", "\n    vec2 d = abs(p - clamp(p, minCorner, maxCorner));\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n    vec3 d = abs(p - clamp(p, minCorner, maxCorner));\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n    vec4 d = abs(p - clamp(p, minCorner, maxCorner));\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 padding ) \n{\n    vec2 d = abs(p - clamp(p, minCorner, maxCorner)) - padding;\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in vec3 padding ) \n{\n    vec3 d = abs(p - clamp(p, minCorner, maxCorner)) - padding;\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner, in vec4 padding ) \n{\n    vec4 d = abs(p - clamp(p, minCorner, maxCorner)) - padding;\n    return dot(d, d);\n}\n\n// Squared distance so you only", "\n    vec3 water = vec3(0.0);\n    vec2 uv2 = uv;\n    uv2.y *= -1.0;\n    float t = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    float t43 = 0.0;\n    float t44 = 0", "\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = sqrt(1.0 - dot(ray.xy, ray.xy));\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = sqrt(1.0 - dot(ray.xy, ray.xy));\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = sqrt(1.0 - dot(ray.xy, ray.xy));\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = sqrt(1.0 - dot(ray.xy, ray.xy));\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = sqrt(1.0 - dot(ray.xy, ray.xy));\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy", "\n    return 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, out vec3 result)\n{\n    result = 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n    return result;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, out vec3 result, out vec3 tangent)\n{\n    result = 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n    tangent = cross(q.xyz, result);\n    return result;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, out vec3 result, out vec3 tangent, out vec3 bitangent)\n{\n    result = 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n    tangent = cross(q.xyz, result);\n    bitangent = cross(tangent, v);\n    return result;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, out vec3 result, out vec3 tangent, out vec3 bitangent, out vec3 normal)\n{\n    result = 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n    tangent = cross(q.xyz, result);\n    bitangent = cross(tangent, v);\n    normal = cross(bitangent, q.xyz);\n    return result;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, out vec3 result, out vec3 tangent, out vec3 bitangent, out vec3 normal, out vec3 hemi)\n{\n", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p-c;\n    return dot(q,q) / dot(r,r) * length(max(dot(q,r),0.0)) + length(max(q,0.0)) - length(r);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundRect( in vec2 p, in vec2 a, in vec2 r )\n{\n    vec2 q = abs(p-a);\n    return length(max(q-r,0.0)) + min(max(q.x,q.y),0.0) - r.x;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 r )\n{\n    vec2 q = abs(p-a);\n    return length(max(q-r,0.0)) + min(max(q.x,q.y),0.0) - r.x;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 r, in float k )\n{\n    vec2 q = abs(p-a);\n    return length(max(q-r-k,0.0)) + min(max(q.x,q.y),0.0) - r.x - k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 r, in float k, in float w )\n{\n    vec2 q = abs(p-a);\n    return length(max(q-r-k-w,0.0)) + min(max(q.x", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float k = dot(q,q)/dot(r,r);\n    if( k > 1.0 ) return length(q) - dot(r,r);\n    float m = sqrt(1.0-k);\n    vec2 uv = vec2(m,k-m*m);\n    return length(q*uv) - dot(r,uv);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRing( in vec2 p, in vec2 c, in float r1, in float r2 )\n{\n    vec2 q = p - c;\n    float k = dot(q,q)/dot(r1,r1);\n    if( k > 1.0 ) return length(q) - dot(r2,r2);\n    float m = sqrt(1.0-k);\n    vec2 uv = vec2(m,k-m*m);\n    return length(q*uv) - dot(r2,uv);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRhombus( in vec2 p, in vec2 c, in float r1, in float r2 )\n{\n    vec2 q = p - c;\n    float k = dot(q,q)/dot(r1,r1);\n    if( k > 1.0 ) return length(", "\n    vec2 h = vec2( 0.5 ) - m;\n    vec2 w = abs( h ) - vec2( a );\n    return vec2( 0.5 ) + sign( h ) * ( w.x < w.y? w.x : w.y );\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return length( max( d, 0.0 ) ) + min( max( d.x, max( d.y, d.z ) ), 0.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2( length( p.xz ) - t.x, p.y );\n    return length( q ) - t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 ab = b - a;\n    vec3 pa = p - a;\n    float h = clamp( dot( pa, ab ) / dot( ab", "\n    vec2 oc = ro - vec2(0.0, 0.0);\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float h = b * b - 4.0 * a * c;\n    if( h < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    h = sqrt( h );\n    float t = (-b - h) / (2.0 * a);\n    if( t < 0.0 )\n    {\n        t = (-b + h) / (2.0 * a);\n    }\n    if( t < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    vec2 pt = ro + t * rd;\n    p1 = vec4( pt, t );\n    p2 = vec4( pt, t + h );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCylinder( in vec2 ro, in vec2 rd, float rad, float h, out vec4 p1, out vec4 p2 )\n{\n    vec2 oc = ro - vec2(0.0, 0.0);\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float h2 = h * h;\n    float h4 = h2 * h2;\n    float D = b * b - 4.0 * a * c;\n    if( D < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    D = sqrt( D", "\n  return vec3( length(p-c) - r, dot(p-c,p-c)-r*r, 0.0 );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCone( in vec2 p, in vec2 c, in float r1, in float r2 ) \n{\n  vec2 q = p-c;\n  float h = clamp( dot(q,q), 0.0, 1.0 );\n  return vec3( length(q) - ( (h<r1)?h:min(q.x*q.x+q.y*q.y, r2*r2) ),\n               sign(q.y)*sqrt(abs(q.x*q.x/r1/r1+q.y*q.y)), 0.0 );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCylinder( in vec2 p, in vec2 c, in float r1, in float r2 ) \n{\n  vec2 q = p-c;\n  float h = clamp( dot(q,q), 0.0, 1.0 );\n  return vec3( length(vec2(q.x,q.y)) - ( (h<r1)?h:min(q.x*q.x+q.y*q.y, r2*r2) ),\n               sign(q.y), 0.0 );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec", "\n  vec2 d = abs(p) - b;\n  return vec3(\n    min(max(d.x,d.y),0.0),\n    max(d.x+d.y-b.x*b.y,0.0),\n    max(max(d.x,d.y)-b.y,0.0)\n  );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSphere( in vec3 p, in float r )\n{\n  return length(p)-r;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCylinder( in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return vec3(\n    min(max(d.x,d.y),0.0),\n    max(d.x+d.y-h.x*h.y,0.0),\n    max(max(d.x,d.y)-h.y,0.0)\n  );\n}\n\n", "\n    vec2 q = vec2(0.0,0.0);\n    q.x = p.x*p.x - p.y*p.y;\n    q.y = 2.0*p.x*p.y;\n    return vec3(q.x,q.y,0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart2( in vec2 p )\n{\n    vec2 q = vec2(0.0,0.0);\n    q.x = p.x*p.x - p.y*p.y;\n    q.y = 2.0*p.x*p.y;\n    return vec3(q.x,q.y,0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart3( in vec2 p )\n{\n    vec2 q = vec2(0.0,0.0);\n    q.x = p.x*p.x - p.y*p.y;\n    q.y = 2.0*p.x*p.y;\n    return vec3(q.x,q.y,0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart4( in vec2 p )\n{\n    vec2 q = vec2(0.0,0.0);\n    q.x = p", "\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gj87222222\nfloat f(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/gj87222222\nfloat h(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (yellow)\n// https://www.desmos.com/calculator/gj87222222\nfloat i(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (orange)\n// https://www.desmos.com/calculator/gj87222222\nfloat j(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (purple)\n// https://www.desmos.com/calculator/gj87222222\nfloat k(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x * x * x;\n}\n\n// Instant push -> wobble (brown)\n// https://www.desmos.com/calcul", "\n  float x2 = x * x;\n  float x4 = x2 * x2;\n  float x6 = x4 * x2;\n  float x8 = x6 * x2;\n  float x10 = x8 * x2;\n  float x12 = x10 * x2;\n  float x14 = x12 * x2;\n  float x16 = x14 * x2;\n  float x18 = x16 * x2;\n  float x20 = x18 * x2;\n  float x22 = x20 * x2;\n  float x24 = x22 * x2;\n  float x26 = x24 * x2;\n  float x28 = x26 * x2;\n  float x30 = x28 * x2;\n  float x32 = x30 * x2;\n  float x34 = x32 * x2;\n  float x36 = x34 * x2;\n  float x38 = x36 * x2;\n  float x40 = x38 * x2;\n  float x42 = x40 * x2;\n  float x44 = x42 * x2;\n  float x46 = x44 * x2;\n  float x48 = x46 * x2;\n  float x50 = x48 * x2;\n  float x52 = x50 * x2;\n  float x54 = x52 * x2;\n  float x56 = x54 * x2;\n  float x58 = x56 * x2;\n  float x60 = x58 * x2;\n  float x62 = x60 * x2;\n  float x64 = x62 * x2;\n  float x66 = x64 * x2;\n  float x68 = x66 * x2;\n  float x70 = x68 * x2;\n  float x72 = x70 * x2;\n  float x74 = x72 * x2;\n  float x7", "\n                float t = time * 0.001;\n                float f = sin(t);\n                float g = cos(t);\n                float h = sin(t * 0.5);\n                float i = cos(t * 0.5);\n                float j = sin(t * 0.25);\n                float k = cos(t * 0.25);\n                float l = sin(t * 0.125);\n                float m = cos(t * 0.125);\n                float n = sin(t * 0.0625);\n                float o = cos(t * 0.0625);\n                float p = sin(t * 0.03125);\n                float q = cos(t * 0.03125);\n                float r = sin(t * 0.015625);\n                float s = cos(t * 0.015625);\n                float tt = sin(t * 0.0078125);\n                float u = cos(t * 0.0078125);\n                float v = sin(t * 0.00390625);\n                float w = cos(t * 0.00390625);\n                float xx = sin(t * 0.001953125);\n                float yy = cos(t * 0.001953125);\n                float zz = sin(t * 0.0009765625);\n                float aa = cos(t * 0.0009765625);\n                float bb = sin(t * 0.00048828125);\n                float cc = cos(t * 0.00048828125);\n                float dd = sin(t * 0.000244140625);\n                float ee = cos(t * 0.000244140625);\n                float ff =", "\n    vec3 color = vec3( 0.0 );\n    vec2 uv = vec2( x, y ) / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iGlobalTime;\n    float a = sin( t * 0.5 );\n    float b = cos( t * 0.5 );\n    float c = sin( t * 0.5 );\n    float d = cos( t * 0.5 );\n\n    float r = ( uv.x + uv.y ) * 0.5;\n    float g = ( uv.x - uv.y ) * 0.5;\n    float bb = ( uv.x + uv.y ) * 0.5;\n\n    float rr = ( r + a ) * 0.5;\n    float gg = ( g - b ) * 0.5;\n    float bb2 = ( bb + c ) * 0.5;\n\n    float rr2 = ( rr + d ) * 0.5;\n    float gg2 = ( gg - a ) * 0.5;\n    float bb3 = ( bb2 + d ) * 0.5;\n\n    float rr3 = ( rr2 + a ) * 0.5;\n    float gg3 = ( gg2 - b ) * 0.5;\n    float bb4 = ( bb3 + c ) * 0.5;\n\n    float rr4 = ( rr3 + d ) * 0.5;\n    float gg4 = ( gg3 - a ) * 0.5;\n    float bb5 = ( bb4 + c ) * 0.5;\n\n    float rr5 = ( rr4 + d ) * 0.5;\n    float gg5 = ( gg4 - a ) * 0.5;\n    float bb6 = ( bb5 + c ) * 0.5;\n\n    float rr6 = ( rr5 + d ) * 0.5;\n   ", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundRect( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = abs(p-a) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = abs(p-a) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 b, in float r, in float k )\n{\n    vec2 d = abs(p-a) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - k;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 b, in float r, in float k, in float w )\n{\n    vec2 d = abs(p-a) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - k - w;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedRect( in vec2 p, in vec2 a, in vec2 b, in float r, in float k, in float w, in float c )\n{\n    vec2 d = abs(", "\n    vec2 d = abs(p-c) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundBox( in vec2 p, in vec2 c, in vec2 b, in float r ) \n{\n    vec2 d = abs(p-c) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundRect( in vec2 p, in vec2 c, in vec2 b, in float r ) \n{\n    vec2 d = abs(p-c) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c ) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float h = clamp( dot(v2,v1) / dot(v0,v1), 0.0, 1.0 );\n    return length( v2 - v0*h ) * sign( dot(v1,v2) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRhombus( in vec2 p, in vec2 c, in vec2 b, in float r ) \n{\n    vec2 d = abs(p-c) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// https://iquilezles.org/art", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqRing( in vec2 p, in vec2 c, in float r1, in float r2 )\n{\n    vec2 q = p - c;\n    return max( length(q) - r2, abs(q.y) - r1 );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a, ac = c - a, ap = p - a,\n         bp = p - b, cp = p - c;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    float k = clamp( dot(bp,ac)/dot(ac,ac), 0.0, 1.0 );\n    return length( cp - (ab*h + ac*k) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqTrapezoid( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 pa = p - a, ba = b - a,\n         pb = p - b, bb = b - b,\n         pc = p - c, bc = c - b,\n         pd = p - d, bd = d - b;\n", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    float h2 = h * h;\n    float d2 = dot( ap, ap ) - h2;\n    float t = clamp( dot( ap, ab ) / h2, 0.0, 1.0 );\n    vec2 q = a + ab * t;\n    float d2q = dot( q - p, q - p );\n    if( d2q > d2min )\n    {\n        float d2r = dot( bp, bp ) - h2;\n        if( d2r > d2 )\n        {\n            float t = clamp( dot( bp, ab ) / h2, 0.0, 1.0 );\n            q = b + ab * t;\n            d2 = dot( q - p, q - p );\n        }\n    }\n    return vec2( sqrt( d2 ), t );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundRect( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - a;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundTri( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return length(max(abs", "\n    float d = 0.0;\n    for( int i = 0; i < kType[0]; i++ )\n    {\n        vec2 a = vec2( kPath[i*2], kPath[i*2+1] );\n        vec2 b = vec2( kPath[i*2+2], kPath[i*2+3] );\n        d += sdLine( p, a, b );\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius )\n{\n    float d = 0.0;\n    for( int i = 0; i < kType[0]; i++ )\n    {\n        vec2 a = vec2( kPath[i*2], kPath[i*2+1] );\n        vec2 b = vec2( kPath[i*2+2], kPath[i*2+3] );\n        d += sdArc( p, a, b, kRadius );\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius, float kAngle )\n{\n    float d = 0.0;\n    for( int i = 0; i < kType[0]; i++ )\n    {\n        vec2 a = vec2( kPath[i*2], kPath[i*2+1] );\n        vec2 b = vec2( kPath[i*2+2], kPath[i*2+3] );\n        d += sdArc( p, a, b, kRadius, kAngle );\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius, float kAngle, float kThickness )\n{\n", "\n    return length(p) - 1.0;\n}\n\n// correct outside, correct inside\nfloat sdO( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdI( in vec2 p )\n{\n    return length(p) - 0.0;\n}\n\n// correct outside, correct inside\nfloat sdC( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdT( in vec2 p )\n{\n    return length(p) - 0.0;\n}\n\n// correct outside, correct inside\nfloat sdF( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdP( in vec2 p )\n{\n    return length(p) - 0.0;\n}\n\n// correct outside, correct inside\nfloat sdB( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdN( in vec2 p )\n{\n    return length(p) - 0.0;\n}\n\n// correct outside, correct inside\nfloat sdJ( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdM( in vec2 p )\n{\n    return length(p) - 0.0;\n}\n\n// correct outside, correct inside\nfloat sdL( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdK( in vec2 p )\n{\n    return length(p) - 0.0;\n}\n\n// correct outside, correct inside\nfloat sdO2( in vec2 p )\n{\n    return length(p) - 0.5;\n}\n\n// correct outside, correct inside\nfloat sdO3(", "\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r.y );\n}\n\n// correct inside, incorrect outside\nfloat sdR( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r.y );\n}\n\n// correct inside, incorrect outside\nfloat sdT( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r.y );\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r.y );\n}\n\n// correct inside, incorrect outside\nfloat sdL( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r.y );\n}\n\n// correct inside, incorrect outside\nfloat sdF( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r.y );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = vec2( 0.5, 0.5 );\n    vec2 r = p - q;\n    return length( r ) * sign( r.x ) * sign( r", "\n    vec3 color = vec3( 0.0 );\n\n    // Generate a pattern based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n    //\n    // The pattern is based on the UV coordinates.\n   ", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return a + ba * h;\n}\n\n// Closest point on line segment\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return a + ba * h;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r, in float th )\n{\n    return c + (p - c) * clamp( dot( p - c, p - c ) / (r * r), 0.0, 1.0 );\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r )\n{\n    return c + (p - c) * clamp( dot( p - c, p - c ) / (r * r), 0.0, 1.0 );\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r, in float th, in float t )\n{\n    return c + (p - c) * clamp( dot( p - c, p - c ) / (r * r), 0.0, 1.0 );\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r, in float th, in float t, in float t2 )\n{\n    return c + (p - c) * clamp( dot( p - c, p - c ) / (r * r), 0.0, 1.0 );\n}\n\n// Closest point on circle\nvec2 cloCircle", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float th )\n{\n    return length(p-c) - r*cos(th);\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float th, in float w )\n{\n    return length(p-c) - r*cos(th) - w;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float th, in float w, in float k )\n{\n    return length(p-c) - r*cos(th) - w*k;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float th, in float w, in float k, in float s )\n{\n    return length(p-c) - r*cos(th) - w*k - s;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float th, in float w, in float k, in float s, in float t )\n{\n    return length(p-c) - r*cos(th) - w*k - s - t;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float th, in float w, in float k, in float s, in float t, in float u )\n{\n    return length(p-c) - r*cos(th) - w*k - s -", "\n    vec2 q = abs(p)-b;\n    return (length(max(q,0.0))-r<0.0)?p:p-sign(p)*r*normalize(q);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float k )\n{\n    vec2 q = abs(p)-b;\n    return (length(max(q,0.0))-r<0.0)?p:p-sign(p)*r*normalize(q)*k;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float k, float t )\n{\n    vec2 q = abs(p)-b;\n    return (length(max(q,0.0))-r<0.0)?p:p-sign(p)*r*normalize(q)*k*t;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float k, float t, float s )\n{\n    vec2 q = abs(p)-b;\n    return (length(max(q,0.0))-r<0.0)?p:p-sign(p)*r*normalize(q)*k*t*s;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float k, float t, float s, float w )\n{\n    vec2 q = abs(p)-b;\n    return (length(max(q,0.0))-r<0.0)?p:p-sign(p)*r*normalize(q)*k*t*s*w;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float k, float t, float s, float w, float h )\n{\n    vec2 q = abs(p)-b;\n    return (length(max(q,0.0))", "\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// distance to rounded box with rounded corners\nfloat sdRoundBoxRounded( in vec2 p, in vec2 b, float r )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// distance to rounded box with rounded corners\nfloat sdRoundBoxRounded( in vec2 p, in vec2 b, float r, float k )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - k;\n}\n\n// distance to rounded box with rounded corners\nfloat sdRoundBoxRounded( in vec2 p, in vec2 b, float r, float k, float w )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - k - w;\n}\n\n// distance to rounded box with rounded corners\nfloat sdRoundBoxRounded( in vec2 p, in vec2 b, float r, float k, float w, float h )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - k - w - h;\n}\n\n// distance to rounded box with rounded corners\nfloat sdRoundBoxRounded( in vec2 p, in vec2 b, float r, float k, float w, float h, float t )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r", "\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to box with center\nfloat sdBoxCenter( in vec2 p, in vec2 b, in vec2 c )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - length(p - c);\n}\n\n// distance to box with center\nfloat sdBoxCenter( in vec2 p, in vec2 b, in vec2 c, in float r )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - length(p - c) - r;\n}\n\n// distance to box with center\nfloat sdBoxCenter( in vec2 p, in vec2 b, in vec2 c, in float r, in float s )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - length(p - c) - r - s;\n}\n\n// distance to box with center\nfloat sdBoxCenter( in vec2 p, in vec2 b, in vec2 c, in float r, in float s, in float t )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - length(p - c) - r - s - t;\n}\n\n// distance to box with center\nfloat sdBoxCenter( in vec2 p, in vec2 b, in vec2 c, in float r, in float s, in float t, in float u )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x", "\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash with Cosine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash with Cubic\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash with Cubic Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash with Cubic Cosine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311", "\n    return fract(sin(dot(x, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// My take on the noise thing\nfloat noise(vec2 x)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec3 x)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec4 x)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec2 x, float y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec3 x, float y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec4 x, float y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec2 x, vec2 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec3 x, vec2 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec4 x, vec2 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec2 x, vec3 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec3 x, vec3 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec4 x, vec3 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec2 x, vec4 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec3 x, vec4 y)\n{\n    return random(x);\n}\n\n// My take on the noise thing\nfloat noise(vec4 x, vec4 y)\n{\n    return random", "\n    return fract(sin(vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Generate some noise\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random2(i);\n    float b = random2(i + vec2(1.0, 0.0));\n    float c = random2(i + vec2(0.0, 1.0));\n    float d = random2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Generate some noise\nfloat noise(vec3 st){\n    vec3 i = floor(st);\n    vec3 f = fract(st);\n\n    // Four corners in 3D of a tile\n    float a = random2(i);\n    float b = random2(i + vec2(1.0, 0.0));\n    float c = random2(i + vec2(0.0, 1.0));\n    float d = random2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec3 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n", "\n    vec2 f = fract(x);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(dot(f, vec2(1.0, 5.0)), dot(f, vec2(5.0, 1.0)), u.x), mix(dot(f, vec2(1.0, 3.0)), dot(f, vec2(3.0, 1.0)), u.x), u.y);\n}\n\nfloat triValueNoise(vec3 x)\n{\n    vec3 f = fract(x);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(f, vec3(1.0, 5.0, 1.0)), dot(f, vec3(5.0, 1.0, 1.0)), u.x), mix(dot(f, vec3(1.0, 3.0, 1.0)), dot(f, vec3(3.0, 1.0, 1.0)), u.x), u.y), mix(mix(dot(f, vec3(1.0, 5.0, 5.0)), dot(f, vec3(5.0, 1.0, 5.0)), u.x), mix(dot(f, vec3(1.0, 3.0, 5.0)), dot(f, vec3(3.0, 1.0, 5.0)), u.x), u.y), u.z);\n}\n\nfloat triValueNoise(vec4 x)\n{\n    vec4 f = fract(x);\n    vec4 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(mix(dot(f, vec4(1.0, 5.0, 1.0, 1.0)), dot(f, vec4(5.0, 1.0, 1.0, 1.0)), u.x", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.02;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.02;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.02;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2", "\n    float t = time * 0.01;\n    float p = sin(t) * 0.5 + 0.5;\n    return fract(p * x.x + p * x.y);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern2(vec2 x)\n{\n    float t = time * 0.01;\n    float p = sin(t) * 0.5 + 0.5;\n    return fract(p * x.x + p * x.y);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern3(vec2 x)\n{\n    float t = time * 0.01;\n    float p = sin(t) * 0.5 + 0.5;\n    return fract(p * x.x + p * x.y);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern4(vec2 x)\n{\n    float t = time * 0.01;\n    float p = sin(t) * 0.5 + 0.5;\n    return fract(p * x.x + p * x.y);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern5(vec2 x)\n{\n    float t = time * 0.01;\n    float p = sin(t) * 0.5 + 0.5;\n    return fract(p * x.x + p * x.y);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern6(vec2 x)\n{\n    float t = time * 0.01;\n    float p = sin(t) * 0.5 + 0.5;\n    return fract(p * x.x + p * x.y);\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/art", "\n    float x2 = x * x;\n    float y2 = y * y;\n    return 1.0f / (x2 + y2 + 1.0f);\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    float x2 = x * x;\n    float y2 = y * y;\n    return 2.0f * (1.0f - x2 - y2);\n}\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//\n\n//\n// Cubemap generation\n//", "\n    p3 = fract(p3 * vec3(123456789.0, 987654321.0, 123456789.0));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(p3 * vec3(43758.5453, 22578.1452, 18330.1929));\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(123456789.0, 987654321.0, 123456789.0));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(p3 * vec3(43758.5453, 22578.1452, 18330.1929));\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(123456789.0, 987654321.0, 123456789.0));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(p3 * vec3(43758.5453, 22578.1452, 18330.1929));\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(123456789.0, 98765432", "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(f.x, f.y, u.x), mix(f.x, f.z, u.x), u.y),\n               mix(mix(f.y, f.z, u.x), mix(f.y, f.w, u.x), u.y), u.z);\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p) {\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(f.x, f.y, u.x), mix(f.x, f.z, u.x), u.y),\n               mix(mix(f.y, f.z, u.x), mix(f.y, f.w, u.x), u.y), u.z);\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p) {\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(f.x, f.y, u.x), mix(f.x, f.z, u.x), u.y),\n               mix(mix(f.y, f.z, u.x), mix(f.y, f.w, u.x), u.y), u.z);\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p) {\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2", "\n    return fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))))*43758.5453);\n}\n\n// ------------------------------------------------------\n// 2D Perlin Noise\n// ------------------------------------------------------\n\nfloat noise( in vec2 st )\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// ------------------------------------------------------\n// 3D Perlin Noise\n// ------------------------------------------------------\n\nfloat noise( in vec3 st )\n{\n    vec3 i = floor(st);\n    vec3 f = fract(st);\n\n    // Four corners in 3D of a cube\n    float a = hash(i);\n    float b = hash(i + vec3(1.0, 0.0, 0.0));\n    float c = hash(i + vec3(0.0, 1.0, 0.0));\n    float d = hash(i + vec3(0.0, 0.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 a, in vec2 b, in float r1, in float r2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - (r1 + r2*h);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 a, in vec2 b, in float r1, in float r2, in float k )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - (r1 + r2*h) - k*h;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 a, in vec2 b, in float r", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form for the 2D case\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form for the 3D case\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form for the 4D case\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    vec4 d = abs(p) - b;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form for the 5D case\nfloat sdBox( in vec5 p, in vec5 b, in vec5 r )\n{\n    vec5 d = abs(p) - b;\n    return min(max(d.x,max(d.y,max(d.z,max(d.w,d.z)))),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form for the 6D case\nfloat sdBox( in vec6 p, in vec6 b, in vec6 r )\n{\n    vec6 d = abs(p) - b;\n    return min(", "\n    float a = dot(normal, normal);\n    float b = dot(normal, center);\n    float c = dot(center, center) - radius*radius;\n    float d = b*b - a*c;\n    if (d < 0.0) {\n        proj_center = vec2(0.0);\n        major = vec2(0.0);\n        minor = vec2(0.0);\n        return;\n    }\n    float sqrt_d = sqrt(d);\n    float e = sqrt_d - b;\n    float f = a - e;\n    float g = a + e;\n    float h = b - e;\n    float i = b + e;\n    float j = sqrt_d + b;\n    float k = sqrt_d - b;\n    float l = sqrt_d + a;\n    float m = sqrt_d - a;\n    float n = sqrt_d + a;\n    float o = sqrt_d - c;\n    float p = sqrt_d + c;\n    float q = sqrt_d + g;\n    float r = sqrt_d - g;\n    float s = sqrt_d + h;\n    float t = sqrt_d - h;\n    float u = sqrt_d + i;\n    float v = sqrt_d - i;\n    float w = sqrt_d + j;\n    float x = sqrt_d - j;\n    float y = sqrt_d + k;\n    float z = sqrt_d - k;\n    float aa = f/a;\n    float bb = g/a;\n    float cc = h/a;\n    float dd = i/a;\n    float ee = j/a;\n    float ff = k/a;\n    float gg = l/a;\n    float hh = m/a;\n    float ii = n/a;\n    float jj = o/a;\n    float kk = p/a;\n    float ll = q/a;\n    float mm = r/a;\n    float nn = s/a;\n    float o", "\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.1136,.1378));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash13(vec3 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.1136,.1378));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash14(vec4 p)\n{\n    vec4 p4  = fract(vec4(p.xyzx) * vec4(.1031,.1136,.1378,.3789));\n    p4 += dot(p4, p4.yzxz + 33.33);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\nfloat Hash15(vec4 p)\n{\n    vec4 p4  = fract(vec4(p.xyzx) * vec4(.1031,.1136,.1378,.3789));\n    p4 += dot(p4, p4.yzxz + 33.33);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\nfloat Hash16(vec4 p)\n{\n    vec4 p4  = fract(vec4(p.xyzx) * vec4(.1031,.1136,.1378,.3789));\n    p4 += dot(p4, p4.yzxz + 33.33);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\nfloat Hash17", "\n    vec2 q = p - acs;\n    float a = atan(q.y, q.x);\n    float b = atan(acs.y, acs.x);\n    float d = length(q);\n    float s = (d - r) / (1.0 - r);\n    float t = (d - bn) / (bn - b);\n    float u = (d - an) / (an - a);\n    float v = (d - m) / (m - acs.x);\n    float w = (d - 1.0) / (1.0 - d);\n    float c = (1.0 - s) * (1.0 - t) * (1.0 - u) * (1.0 - v) * (1.0 - w);\n    float d1 = max(0.0, s - 1.0);\n    float d2 = max(0.0, t - 1.0);\n    float d3 = max(0.0, u - 1.0);\n    float d4 = max(0.0, v - 1.0);\n    float d5 = max(0.0, w - 1.0);\n    return c * (d1 * d2 * d3 * d4 * d5);\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m, in float n) // m=[2,n]\n{\n    vec2 q = p - acs;\n    float a = atan(q.y, q.x);\n    float b = atan(acs.y, acs.x);\n    float d = length(q);\n    float s = (d - r) / (1.0 - r);\n    float t = (d - bn) / (bn - b);\n    float u = (d - an) / (an - a);\n    float v = (d -", "\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        sdf( p + e.yxx ) - sdf( p - e.yxx ),\n        sdf( p + e.xyx ) - sdf( p - e.xyx ),\n        sdf( p + e.xxy ) - sdf( p - e.xxy )\n    ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF octahedron normals\nvec3 normal( vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        sdf( p + e.yxx ) - sdf( p - e.yxx ),\n        sdf( p + e.xyx ) - sdf( p - e.xyx ),\n        sdf( p + e.xxy ) - sdf( p - e.xxy ),\n        sdf( p + e.yyx ) - sdf( p - e.yyx ),\n        sdf( p + e.yxy ) - sdf( p - e.yxy ),\n        sdf( p + e.yyy ) - sdf( p - e.yyy )\n    ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF icosahedron normals\nvec3 normal( vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        sdf( p + e.yxx ) - sdf( p - e.yxx ),\n        sdf( p + e.xyx ) - sdf( p - e.xyx ),\n        sdf( p + e.xxy ) - sdf( p - e.xxy ),\n        sdf( p + e.yyx ) - sdf( p - e.yyx ),\n        sdf( p + e.yxy ) -", "\n    float res = 1.0;\n    for (float t = t0; t < t1; t += SHADOW_STEP)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (d < EPSILON)\n        {\n            res = min(res, 1.0 - t / t1);\n        }\n        else\n        {\n            res = min(res, 1.0 - d / t1);\n        }\n    }\n    return res;\n}\n\n// NOTE: This is the same as shadow but with a different t0 and t1\n//       (t0 is the distance from the surface to the light source)\n//       (t1 is the distance from the surface to the camera)\nfloat shadow_light(vec3 ro, vec3 rd, float t0, float t1)\n{\n    float res = 1.0;\n    for (float t = t0; t < t1; t += SHADOW_STEP)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (d < EPSILON)\n        {\n            res = min(res, 1.0 - t / t1);\n        }\n        else\n        {\n            res = min(res, 1.0 - d / t1);\n        }\n    }\n    return res;\n}\n\n// NOTE: This is the same as shadow but with a different t0 and t1\n//       (t0 is the distance from the surface to the light source)\n//       (t1 is the distance from the surface to the camera)\nfloat shadow_camera(vec3 ro, vec3 rd, float t0, float t1)\n{\n    float res = 1.0;\n    for (float t = t0; t < t1; t += SHADOW_STEP)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (d < EPSILON)\n        {\n            res = min(res, 1.0 - t / t1);\n", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = texture( iChannel0, aopos.yzx, -0.1 ).x;\n        occ += -(dd*dd)*(0.25 + 0.5*dd);\n        sca *= 1.0 - dd;\n        if( sca < 0.01 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = texture( iChannel0, aopos.yzx, -0.1 ).x;\n        occ += -(dd*dd)*(0.25 + 0.5*dd);\n        sca *= 1.0 - dd;\n        if( sca < 0.01 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i);\n        vec3 a", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z *", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 offset = (mouse - uv) * 0.001;\n    vec3 ray = vec3(uv + offset, 1.0);\n    return normalize(ray);\n}\n\n// Helper function that generates a ray from the camera\nvec3 getCameraRay(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 offset = (mouse - uv) * 0.001;\n    vec3 ray = vec3(uv + offset, 1.0);\n    return normalize(ray);\n}\n\n// Helper function that generates a ray from the camera\nvec3 getCameraRay(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 offset = (mouse - uv) * 0.001;\n    vec3 ray = vec3(uv + offset, 1.0);\n    return normalize(ray);\n}\n\n// Helper function that generates a ray from the camera\nvec3 getCameraRay(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 offset = (mouse - uv) * 0.001;\n    vec3 ray = vec3(uv + offset, 1.0);\n    return normalize(ray);\n}\n\n// Helper function that generates a ray from the camera\nvec3 getCameraRay(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n   ", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.145))) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4dTime(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,45.145,3.14159))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.145))) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,45.145,3.14159))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + seed) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co", "\n    return fract(sin(dot(p, vec3(127.1, 311.7, 256.3))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p * 43758.5453) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p){\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p){\n    return fract(sin(dot(p, vec3(127.1, 311.7, 256.3))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p, float q){\n    return fract(sin(dot(vec2(p, q), vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p, vec2 q){\n    return fract(sin(dot(p, q)) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p, vec3 q){\n    return fract(sin(dot(p, q)) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p, vec2 q){\n    return fract(sin(dot(p,", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 17.0)), f.x), mix(dot(p, vec3(17.0, 113.0, 57.0)), dot(p, vec3(57.0, 17.0, 113.0)), f.x), f.y), mix(mix(dot(p, vec3(57.0, 17.0, 113.0)), dot(p, vec3(17.0, 57.0, 113.0)), f.x), mix(dot(p, vec3(113.0, 17.0, 57.0)), dot(p, vec3(57.0, 113.0, 17.0)), f.x), f.z), f.z);\n}\n\n// 2D value noise\nfloat noise2d(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(dot(p, vec2(1.0, 57.0)), dot(p, vec2(57.0, 113.0)), f.x), mix(dot(p, vec2(113.0, 57.0)), dot(p, vec2(57.0, 113.0)), f.x), f.y);\n}\n\n//", "\n    float n = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    for (int i = 0; i < 3; i++){\n        n += amp * abs(perlin3d(p * freq));\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick trick", "\n    float fbm = fbm(p);\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm * 0.5 + 0.5;\n    fbm = fbm *", "\n    vec2 XY;\n    float density = texture(clouds, pos.xy).r;\n    if(density > 0.0){\n        XY.x = density;\n        XY.y = texture(clouds, pos.xy + vec2(0.0, 0.0001)).r;\n    }\n    else{\n        XY.x = 0.0;\n        XY.y = 0.0;\n    }\n    return XY;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity(vec3 pos){\n    vec2 XY;\n    float density = texture(clouds, pos.xy).r;\n    if(density > 0.0){\n        XY.x = density;\n        XY.y = texture(clouds, pos.xy + vec2(0.0, 0.0001)).r;\n    }\n    else{\n        XY.x = 0.0;\n        XY.y = 0.0;\n    }\n    return XY;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity2D(vec2 pos){\n    vec2 XY;\n    float density = texture(clouds, pos).r;\n    if(density > 0.0){\n        XY.x = density;\n        XY.y = texture(clouds, pos + vec2(0.0, 0.0001)).r;\n    }\n    else{\n        XY.x = 0.0;\n        XY.y = 0.0;\n    }\n    return XY;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec", "\n    vec3 color = vec3(0.0);\n    vec3 ray = pointEnd - pointStart;\n    vec3 rayDir = normalize(ray);\n    vec3 rayPos = pointStart;\n    float rayLength = length(ray);\n    float rayLengthSq = rayLength * rayLength;\n    float rayLengthCube = rayLengthSq * rayLength;\n    float rayLengthQuad = rayLengthSq * rayLengthSq;\n    float rayLengthPow = rayLength * rayLength * rayLength;\n    float rayLengthPow2 = rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow3 = rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow4 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow5 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow6 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow7 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow8 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow9 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow10 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow11 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength;\n    float rayLengthPow12 = rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * rayLength * ray", "\n    const vec3 a = vec3(0.0225, 0.0593, 0.112);\n    const vec3 b = vec3(0.0225, 0.0593, 0.112);\n    return clamp(color * (a * color + b), vec3(0.0), vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 aces_tonemap_vivid(vec3 color) {\n    const vec3 a = vec3(0.0225, 0.0593, 0.112);\n    const vec3 b = vec3(0.0225, 0.0593, 0.112);\n    return clamp(color * (a * color + b), vec3(0.0), vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 aces_tonemap_pro(vec3 color) {\n    const vec3 a = vec3(0.0225, 0.0593, 0.112);\n    const vec3 b = vec3(0.0225, 0.0593, 0.112);\n    return clamp(color * (a * color + b), vec3(0.0), vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 aces_tonemap_sapphire(vec3 color) {\n    const vec3 a = vec3(0.0225, 0.0593, 0.112);\n    const vec3 b = vec3(0.0225, 0.0593, 0.112);\n    return clamp(color * (a * color + b), vec3(0.0"]}