{"generations": ["\n  return s.x * s.y * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_1( in vec3 s ) {\n  return s.y * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_2( in vec3 s ) {\n  return s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_3( in vec3 s ) {\n  return s.x * s.y * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_4( in vec3 s ) {\n  return s.y * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_5( in vec3 s ) {\n  return s.z * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_6( in vec3 s ) {\n  return s.x * s.y * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_7( in vec3 s ) {\n  return s.y * s.z * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_8( in vec3 s ) {\n  return s.z * s.z * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_9( in vec3 s ) {\n  return s.x * s.y * s.z * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_10( in vec3 s ) {\n  return s.y * s.z * s.z * s.z * s.z * s.z;\n}\n\n// unrolled version of the above\nfloat SH_0_11( in vec3 s ) {\n  return s.z * s.z", "\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    vec2 pa_ba = pa-ba;\n    return length(pa_ba)/length(ba);\n}\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    vec2 pa_ba = pa-ba;\n    vec2 pa_ba_ba = pa_ba-ba;\n    float t = clamp( dot(pa_ba,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa_ba_ba*t+ba*t);\n}\n\n// distance to a circle\nfloat circle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to a sphere\nfloat sphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to a plane\nfloat plane( in vec3 p, in vec3 n, in vec3 c )\n{\n    return dot(p-c,n);\n}\n\n// distance to a box\nfloat box( in vec3 p, in vec3 b )\n{\n    vec3 q = abs(p)-b;\n    return max(max(max(q.x,q.y),q.z),0.0);\n}\n\n// distance to a box\nfloat box( in vec3 p, in vec3 b, in vec3 c )\n{\n    vec3 q = abs(p-c)-b;\n    return max(max(max(q.x,q.y),q.z),0.0);\n}\n\n// distance to a capsule\nfloat capsule( in vec3 p, in vec3 b, in vec3 c, in float r )\n{\n    vec3 q = abs(p-c)-b;\n    float d = length(q);\n    float h = dot(q,b);\n    return min(d,abs(h)-r);\n}\n\n// distance", "\n    return v.x < 0.0? -v : v;\n}\n\n// Compute the distance from a point to a line\nfloat distToLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float ba_len = length( ba );\n    vec2 ba_unit = ba / ba_len;\n    vec2 pa_proj = dot( pa, ba_unit ) * ba_unit;\n    return length( pa - pa_proj );\n}\n\n// Compute the distance from a point to a line segment\nfloat distToLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    vec2 pa_proj = dot( pa, ba ) * ba;\n    vec2 pa_proj_unit = pa_proj / length( ba );\n    vec2 pa_proj_unit_abs = abs( pa_proj_unit );\n    float pa_proj_len = length( pa_proj );\n    float pa_proj_len_abs = length( pa_proj_unit_abs );\n    float pa_proj_len_abs_sq = pa_proj_len_abs * pa_proj_len_abs;\n    float pa_proj_len_sq = pa_proj_len * pa_proj_len;\n    float pa_proj_len_sq_abs = pa_proj_len_sq * pa_proj_len_sq;\n    float pa_proj_len_sq_abs_sq = pa_proj_len_sq_abs * pa_proj_len_sq_abs;\n    float pa_proj_len_sq_abs_sq_inv = 1.0 / pa_proj_len_sq_abs_sq;\n    float pa_proj_len_sq_abs_sq_inv_pa_proj_len_sq_abs_inv = pa_proj_len_sq_abs_sq_inv * pa_proj_len_sq_abs_inv;\n    float pa_proj_len_sq_abs_sq_inv_pa_proj_len_sq_", "\n    return v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return v + 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v", "\n    return v.x < -r.x? vec2(-r.x, v.y) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v.x > r.x? vec2(r.x, v.y) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    return v.x > r.x? vec3(r.x, v.y, v.z) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    return v.x > r.x? vec4(r.x, v.y, v.z, v.w) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v.x > r.x? vec2(r.x, v.y) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    return v.x > r.x? vec3(r.x, v.y, v.z) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    return v.x > r.x? vec4(r.x, v.y, v.z, v.w) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec", "\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    vec2 ba = b - a;\n    vec2 ba_ = ba * vec2( 1.0 / ba.y, -1.0 / ba.x );\n    vec2 ba_p = ba_ * pa;\n    vec2 ba_p_ = ba_ * pb;\n    vec2 ba_p_p = ba_ * ba_p;\n    vec2 ba_p_p_ = ba_ * ba_p_;\n    vec2 ba_p_p_p = ba_ * ba_p_p;\n    vec2 ba_p_p_p_ = ba_ * ba_p_p_;\n    vec2 ba_p_p_p_p = ba_ * ba_p_p_p;\n    vec2 ba_p_p_p_p_ = ba_ * ba_p_p_p_;\n    vec2 ba_p_p_p_p_p = ba_ * ba_p_p_p_p;\n    vec2 ba_p_p_p_p_p_ = ba_ * ba_p_p_p_p_p;\n    vec2 ba_p_p_p_p_p_p = ba_ * ba_p_p_p_p_p_p;\n    vec2 ba_p_p_p_p_p_p_ = ba_ * ba_p_p_p_p_p_p_p;\n    vec2 ba_p_p_p_p_p_p_p = ba_ * ba_p_p_p_p_p_p_p_p;\n    vec2 ba_p_p_p_p_p_p_p_ = ba_ * ba_p_p_p_p_p_p_p_p_p;\n    vec2 ba_p_p_p_p_p_p_p_p = ba_ * ba_p_p_p_p_p_p_p_p_p_p;\n    vec2 ba_p_p_p_p_p_p_p_p_ = ba_", "\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn sunCol * dot;\n}\n\nvec3 GetSunColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn sunCol * dot;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn sunCol * dot;\n}\n\nvec3 GetSkyColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn skyCol * dot;\n}\n\nvec3 GetGroundColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 Get", "\n    vec4 a = (p2 - p0) * 0.5;\n    vec4 b = (p3 - p1) * 0.5;\n    vec4 c = (p1 - p0) * 0.5;\n    vec4 d = (p2 - p1) * 0.5;\n    return a + (b - a) * t * t * t + c * t * t + d * t + p1;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 a = (p2 - p0) * 0.5;\n    vec4 b = (p3 - p1) * 0.5;\n    vec4 c = (p1 - p0) * 0.5;\n    vec4 d = (p2 - p1) * 0.5;\n    return a + (b - a) * t * t * t + c * t * t + d * t + p1;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 a = (p2 - p0) * 0.5;\n    vec4 b = (p3 - p1) * 0.5;\n    vec4 c = (p1 - p0) * 0.5;\n    vec4 d = (p2 - p1) * 0.5;\n    return a + (b - a) * t * t * t + c * t * t + d * t + p1;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 a = (p2 - p0) * 0.5;\n    vec4 b = (p3 - p1) * 0.5;\n    vec4 c = (p1 - p0", "\n\tfloat f = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f1 = 0.0;\n\tfloat f2 = 0.0;\n\tfloat f3 = 0.0;\n\tfloat f4 = 0.0;\n\tfloat f5 = 0.0;\n\tfloat f6 = 0.0;\n\tfloat f7 = 0.0;\n\tfloat f8 = 0.0;\n\tfloat f9 = 0.0;\n\tfloat f10 = 0.0;\n\tfloat f11 = 0.0;\n\tfloat f12 = 0.0;\n\tfloat f13 = 0.0;\n\tfloat f14 = 0.0;\n\tfloat f15 = 0.0;\n\tfloat f16 = 0.0;\n\tfloat f17 = 0.0;\n\tfloat f18 = 0.0;\n\tfloat f19 = 0.0;\n\tfloat f20 = 0.0;\n\tfloat f21 = 0.0;\n\tfloat f22 = 0.0;\n\tfloat f23 = 0.0;\n\tfloat f24 = 0.0;\n\tfloat f25 = 0.0;\n\tfloat f26 = 0.0;\n\tfloat f27 = 0.0;\n\tfloat f28 = 0.0;\n\tfloat f29 = 0.0;\n\tfloat f30 = 0.0;\n\tfloat f31 = 0.0;\n\tfloat f32 = 0.0;\n\tfloat f33 = 0.0;\n\tfloat f34 = 0.0;\n\tfloat f35 = 0.0;\n\tfloat f36 = 0.0;\n\tfloat f37 = 0.0;\n\tfloat f38 = 0.0;\n\tfloat f3", "\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41", "\n\tu = fract(u * 1234.5678);\n\tu = fract(u * (u * u * 3.9));\n\treturn u * 43758.5453;\n}\n\nfloat Hash2d(float uv[2])\n{\n\tfloat u = uv[0];\n\tfloat v = uv[1];\n\tu = fract(u * 1234.5678);\n\tv = fract(v * 1234.5678);\n\tu = fract(u * (u * u * 3.9));\n\tv = fract(v * (v * v * 3.9));\n\treturn u * uv[1] + v * uv[0] + 635.7531;\n}\n\nfloat Hash3d(float uv[3])\n{\n\tfloat u = uv[0];\n\tfloat v = uv[1];\n\tfloat w = uv[2];\n\tu = fract(u * 1234.5678);\n\tv = fract(v * 1234.5678);\n\tw = fract(w * 1234.5678);\n\tu = fract(u * (u * u * 3.9));\n\tv = fract(v * (v * v * 3.9));\n\tw = fract(w * (w * w * 3.9));\n\treturn u * uv[2] + v * uv[1] + w * uv[0] + 594.7147;\n}\n\nfloat Hash4d(float uv[4])\n{\n\tfloat u = uv[0];\n\tfloat v = uv[1];\n\tfloat w = uv[2];\n\tfloat x = uv[3];\n\tu = fract(u * 1234.5678);\n\tv = fract(v * 1234.5678);\n\tw = fract(w * 1234.5678);\n\tx = fract(x * ", "\n\tfloat f = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f1 = 0.0;\n\tfloat f2 = 0.0;\n\tfloat f3 = 0.0;\n\tfloat f4 = 0.0;\n\tfloat f5 = 0.0;\n\tfloat f6 = 0.0;\n\tfloat f7 = 0.0;\n\tfloat f8 = 0.0;\n\tfloat f9 = 0.0;\n\tfloat f10 = 0.0;\n\tfloat f11 = 0.0;\n\tfloat f12 = 0.0;\n\tfloat f13 = 0.0;\n\tfloat f14 = 0.0;\n\tfloat f15 = 0.0;\n\tfloat f16 = 0.0;\n\tfloat f17 = 0.0;\n\tfloat f18 = 0.0;\n\tfloat f19 = 0.0;\n\tfloat f20 = 0.0;\n\tfloat f21 = 0.0;\n\tfloat f22 = 0.0;\n\tfloat f23 = 0.0;\n\tfloat f24 = 0.0;\n\tfloat f25 = 0.0;\n\tfloat f26 = 0.0;\n\tfloat f27 = 0.0;\n\tfloat f28 = 0.0;\n\tfloat f29 = 0.0;\n\tfloat f30 = 0.0;\n\tfloat f31 = 0.0;\n\tfloat f32 = 0.0;\n\tfloat f33 = 0.0;\n\tfloat f34 = 0.0;\n\tfloat f35 = 0.0;\n\tfloat f36 = 0.0;\n\tfloat f37 = 0.0;\n\tfloat f38 = 0.0;\n\tfloat f3", "\n    float d = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44", "\n    vec3 envColor = vec3(0.0);\n    float sunIntensity = 0.0;\n\n    // The softbox is a 1000x1000x1000 cube.\n    float softbox = 1.0;\n    float softboxIntensity = 0.0;\n    float softboxIntensity2 = 0.0;\n    float softboxIntensity3 = 0.0;\n    float softboxIntensity4 = 0.0;\n    float softboxIntensity5 = 0.0;\n    float softboxIntensity6 = 0.0;\n    float softboxIntensity7 = 0.0;\n    float softboxIntensity8 = 0.0;\n    float softboxIntensity9 = 0.0;\n    float softboxIntensity10 = 0.0;\n    float softboxIntensity11 = 0.0;\n    float softboxIntensity12 = 0.0;\n    float softboxIntensity13 = 0.0;\n    float softboxIntensity14 = 0.0;\n    float softboxIntensity15 = 0.0;\n    float softboxIntensity16 = 0.0;\n    float softboxIntensity17 = 0.0;\n    float softboxIntensity18 = 0.0;\n    float softboxIntensity19 = 0.0;\n    float softboxIntensity20 = 0.0;\n    float softboxIntensity21 = 0.0;\n    float softboxIntensity22 = 0.0;\n    float softboxIntensity23 = 0.0;\n    float softboxIntensity24 = 0.0;\n    float softboxIntensity25 = 0.0;\n    float softboxIntensity26 = 0.0;\n    float softboxIntensity27 = 0.0;\n    float softboxIntensity28 = 0.0;\n    float softboxIntensity29 = 0.0;\n    float softboxIntensity30 = 0.0;\n    float softboxIntensity31", "\n\treturn a < b? a : b;\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n\treturn a > b? a : b;\n}\n\n// polynomial smooth step (k = 0.1);\nfloat sstep( float edge, float x, float k )\n{\n\treturn x < edge? 0.0 : smax( 0.0, k * (x - edge), k );\n}\n\n// polynomial smooth step (k = 0.1);\nfloat sstep( float edge0, float edge1, float x, float k )\n{\n\treturn x < edge0? 0.0 : x < edge1? smax( 0.0, k * (x - edge0), k ) : smax( 0.0, k * (x - edge1), k );\n}\n\n// polynomial smooth step (k = 0.1);\nfloat sstep( float edge0, float edge1, float x0, float x1, float k )\n{\n\treturn x0 < edge0? 0.0 : x0 < edge1? x1 < edge1? smax( 0.0, k * (x1 - edge0), k ) : smax( 0.0, k * (x0 - edge0), k ) : smax( 0.0, k * (x1 - edge1), k );\n}\n\n// polynomial smooth step (k = 0.1);\nfloat sstep( float edge0, float edge1, float x0, float x1, float x2, float k )\n{\n\treturn x0 < edge0? 0.0 : x0 < edge1? x1 < edge1? smax( 0.0, k * (x1 - edge0), k ) : smax( 0.0, k * (x0 - edge0), k ) : x1 < edge1? smax( 0.0, k * (x1 - edge1), k ) : smax( 0.0, k * (x2 - edge1), k", "\n\tvec3 dirVec = normalize(dirVecPLZNormalizeMeFirst);\n\tvec3 dirVecToSphere = spherePos - pos;\n\tfloat t = dot(dirVecToSphere, dirVec);\n\tfloat t2 = t * t - dot(dirVecToSphere, dirVecToSphere);\n\tif (t2 < 0.0)\n\t\treturn -1.0;\n\tfloat t1 = sqrt(t2);\n\tfloat t0 = t - t1;\n\tfloat t3 = t0 * t0 - dot(dirVecToSphere, dirVecToSphere);\n\tif (t3 > rad * rad)\n\t\treturn -1.0;\n\treturn t0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, vec3 sphereDirVec, float rad)\n{\n\tvec3 dirVec = normalize(dirVecPLZNormalizeMeFirst);\n\tvec3 dirVecToSphere = spherePos - pos;\n\tfloat t = dot(dirVecToSphere, dirVec);\n\tfloat t2 = t * t - dot(dirVecToSphere, dirVecToSphere);\n\tif (t2 < 0.0)\n\t\treturn -1.0;\n\tfloat t1 = sqrt(t2);\n\tfloat t0 = t - t1;\n\tfloat t3 = t0 * t0 - dot(dirVecToSphere, dirVecToSphere);\n\tif (t3 > rad * rad)\n\t\treturn -1.0;\n\treturn t0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, vec3 sphereDirVec, float rad, float maxDist)\n{\n\tvec3 dirVec = normalize(dirVecPLZNormalizeMeFirst);\n\tvec3 dirVecToSphere = spherePos - pos;\n\tfloat t = dot(dirVecToSphere, dirVec);\n\tfloat t2 = t * t - dot(dir", "\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n\tvec2 d = p.xy - object.position.xy;\n\treturn d;\n}\n\n// Calculate the distance field that defines", "\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD1(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD2(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD3(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD4(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD5(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD6(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD7(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD8(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD9(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD10(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD11(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD12(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD13(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD14(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD15(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD16(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD17(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec3 mapD18(float t)\n{\n\treturn vec3(t, t, t);\n}\n\nvec", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function\nvec3 map(vec3 p)\n{\n    return p;\n}\n\n// map function derivative\nvec3 mapD(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD2(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD3(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD4(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD5(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD6(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD7(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD8(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD9(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD10(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD11(vec3 p)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// map function derivative\nvec3 mapD12(vec", "\n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t3*t;\n    float t5 = t4*t;\n    float t6 = t5*t;\n    float t7 = t6*t;\n    float t8 = t7*t;\n    float t9 = t8*t;\n    float t10 = t9*t;\n    float t11 = t10*t;\n    float t12 = t11*t;\n    float t13 = t12*t;\n    float t14 = t13*t;\n    float t15 = t14*t;\n    float t16 = t15*t;\n    float t17 = t16*t;\n    float t18 = t17*t;\n    float t19 = t18*t;\n    float t20 = t19*t;\n    float t21 = t20*t;\n    float t22 = t21*t;\n    float t23 = t22*t;\n    float t24 = t23*t;\n    float t25 = t24*t;\n    float t26 = t25*t;\n    float t27 = t26*t;\n    float t28 = t27*t;\n    float t29 = t28*t;\n    float t30 = t29*t;\n    float t31 = t30*t;\n    float t32 = t31*t;\n    float t33 = t32*t;\n    float t34 = t33*t;\n    float t35 = t34*t;\n    float t36 = t35*t;\n    float t37 = t36*t;\n    float t38 = t37*t;\n    float t39 = t38*t;\n    float t40 = t39*t;\n    float t41 = t40*t;\n    float t42 = t41", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 pa_ba = pa * ba;\n    vec2 pa_ba_sq = pa_ba * pa_ba;\n    vec2 ba_sq = ba * ba;\n    vec2 pa_sq = pa * pa;\n    vec2 pa_ba_sq_ba_sq = pa_ba_sq - ba_sq;\n    vec2 pa_ba_sq_ba_sq_pa_sq = pa_ba_sq - pa_sq;\n    vec2 pa_ba_sq_ba_sq_pa_ba = pa_ba_sq - pa_ba;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa = pa_ba_sq - pa_ba;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa_ba = pa_ba_sq - pa_ba_sq_ba_sq_pa_ba;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa_ba_pa = pa_ba_sq - pa_ba_sq_ba_sq_pa_ba_pa;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa_ba_pa_ba = pa_ba_sq - pa_ba_sq_ba_sq_pa_ba_pa_ba;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa_ba_pa_ba_pa = pa_ba_sq - pa_ba_sq_ba_sq_pa_ba_pa_ba_pa;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa_ba_pa_ba_pa_pa = pa_ba_sq - pa_ba_sq_ba_sq_pa_ba_pa_ba_pa_ba;\n    vec2 pa_ba_sq_ba_sq_pa_ba_pa_ba_pa_ba_pa_pa_pa = pa_ba_sq - pa_ba_sq_ba_sq_pa_ba_pa_ba_pa_ba_pa;\n    vec2 pa_ba_sq_ba_sq_pa_", "\n    vec3 ab = b - a;\n    vec3 ac = a - o;\n    vec3 ad = d - o;\n    vec3 abd = cross( ab, ad );\n    vec3 acd = cross( ac, ad );\n    vec3 abd2 = abd * abd;\n    vec3 acd2 = acd * acd;\n    vec3 abdac = abd * acd;\n    vec3 abdac2 = abdac * abdac;\n    vec3 abdacd = abd * acd * d;\n    vec3 abdacd2 = abdacd * abdacd;\n    vec3 abdacd3 = abdacd * abdacd;\n    vec3 abdacd4 = abdacd * abdacd;\n    vec3 abdacd5 = abdacd * abdacd;\n    vec3 abdacd6 = abdacd * abdacd;\n    vec3 abdacd7 = abdacd * abdacd;\n    vec3 abdacd8 = abdacd * abdacd;\n    vec3 abdacd9 = abdacd * abdacd;\n    vec3 abdacd10 = abdacd * abdacd;\n    vec3 abdacd11 = abdacd * abdacd;\n    vec3 abdacd12 = abdacd * abdacd;\n    vec3 abdacd13 = abdacd * abdacd;\n    vec3 abdacd14 = abdacd * abdacd;\n    vec3 abdacd15 = abdacd * abdacd;\n    vec3 abdacd16 = abdacd * abdacd;\n    vec3 abdacd17 = abdacd * abdacd;\n    vec3 abdacd18 = abdacd * abdacd;\n    vec3 abdacd19 = abdacd * abdacd;\n    vec3 abdacd20", "\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return min(min(min(d,r.x),r.y),min(r.z,r.w));\n}\n\nvec3 sdRoundBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return min(min(min(d,r.x),r.y),min(r.z,r.w)) * vec3(1.0,1.0,1.0);\n}\n\nvec3 sdRoundBox( in vec2 p, in vec2 b, in vec4 r, in vec3 c )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return min(min(min(d,r.x),r.y),min(r.z,r.w)) * c;\n}\n\nvec3 sdRoundBox( in vec2 p, in vec2 b, in vec4 r, in vec3 c, in vec3 e )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return min(min(min(d,r.x),r.y),min(r.z,r.w)) * c + e;\n}\n\nvec3 sdRoundBox( in vec2 p, in vec2 b, in vec4 r, in vec3 c, in vec3 e, in vec3 f )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q", "\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn sunCol * dot;\n}\n\nvec3 GetSunColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn sunCol * dot;\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn sunCol * dot;\n}\n\nvec3 GetSkyColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn skyCol * dot;\n}\n\nvec3 GetGroundColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 GetGroundColorRefraction(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = saturate(dot(rayDir, sunDir));\n\treturn groundCol * dot;\n}\n\nvec3 Get", "\n    // First, we need to figure out the direction of the camera.\n    // We'll do that by taking the difference between the two points.\n    vec3 up = normalize( ta - ro );\n    vec3 right = normalize( cross( up, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 forward = normalize( cross( right, up ) );\n\n    // Now, we'll rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    // We'll do that by taking the cross product of the forward vector and the roll.\n    // The roll is the angle we want to rotate the camera around the Y axis.\n    //", "\n\tvec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonDirection = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonSize = vec3( 0.05, 0.05, 0.05 );\n\tvec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotation = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonScale = vec3( 1.0, 1.0, 1.0 );\n\tvec3 balloonTranslation = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotationAxis = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonRotationAngle = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotationAxis2 = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonRotationAngle2 = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotationAxis3 = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonRotationAngle3 = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotationAxis4 = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonRotationAngle4 = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotationAxis5 = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonRotationAngle5 = vec3( 0.0, 0.0, 0.0 );\n\tvec3 balloonRotationAxis6 = vec3( 0.0, 0.0, 1.0 );\n\tvec3 balloonRotationAngle6 = vec3( 0.0, 0.0, 0.", "\n  float distance1 = distance(thing1,vec2(0.0,0.0));\n  float distance2 = distance(thing2,vec2(0.0,0.0));\n  if(distance1 < distance2){\n    return thing1;\n  }else{\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the.x\n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserToX( vec2 thing1, vec2 thing2 ){\n  float distance1 = thing1.x;\n  float distance2 = thing2.x;\n  if(distance1 < distance2){\n    return thing1;\n  }else{\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the.y\n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserToY( vec2 thing1, vec2 thing2 ){\n  float distance1 = thing1.y;\n  float distance2 = thing2.y;\n  if(distance1 < distance2){\n    return thing1;\n  }else{\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the.z\n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserToZ( vec2 thing1, vec2 thing2 ){\n  float distance1 = thing1.z;\n  float distance2 = thing2.z;\n  if(distance1 < distance2){\n    return thing1;\n  }else{\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer", "\n\n\tvec3 closestPoint = vec3( 0.0 );\n\tfloat closestDistance = 1000000.0;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec3 rayDirection = normalize( currentRayPosition );\n\tvec3 rayOrigin = currentRayPosition;\n\n\t// This is the raycast\n\tfloat rayLength = 1000000.0;\n\tvec", "\n    vec3 normal = vec3(0.0);\n    vec3 surfaceNormal = getNormal( positionOfHit );\n    vec3 surfaceNormalNormalized = normalize( surfaceNormal );\n    vec3 surfaceNormalNormalizedInverted = vec3( -1.0 ) * surfaceNormalNormalized;\n    vec3 surfaceNormalNormalizedInvertedNormalized = normalize( surfaceNormalNormalizedInverted );\n    vec3 surfaceNormalNormalizedInvertedNormalizedInverted = vec3( -1.0 ) * surfaceNormalNormalizedInvertedNormalized;\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalized = normalize( surfaceNormalNormalizedInvertedNormalizedInverted );\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInverted = vec3( -1.0 ) * surfaceNormalNormalizedInvertedNormalizedInvertedNormalized;\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalized = normalize( surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInverted );\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted = vec3( -1.0 ) * surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalized;\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted = normalize( surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted );\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted = vec3( -1.0 ) * surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted;\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted = normalize( surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted );\n    vec3 surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted = vec3( -1.0 ) * surfaceNormalNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInvertedNormalizedInverted;\n    vec", "\n    return vec3(0.0);\n}\n\n// This is the main function that does all the work.\n// It takes a vec3 called \"color\" and a vec3 called \"position\".\n// The color is the color of the pixel we're drawing, and the position is\n// the position of the pixel we're drawing.\n//\n// The function returns a vec3.\n//\n// The function should return a vec3 that is the color of the pixel we're drawing.\n//\n// The function should return a vec3 that is the position of the pixel we're drawing.\nvec3 doPixel(vec3 color, vec3 position){\n    // This is a simple example of a function that does nothing.\n    // It returns a vec3 that is the color of the pixel we're drawing.\n    return color;\n}\n\n// This is the main function that does all the work.\n// It takes a vec3 called \"color\" and a vec3 called \"position\".\n// The color is the color of the pixel we're drawing, and the position is\n// the position of the pixel we're drawing.\n//\n// The function returns a vec3.\n//\n// The function should return a vec3 that is the color of the pixel we're drawing.\n//\n// The function should return a vec3 that is the position of the pixel we're drawing.\nvec3 doPixel(vec3 color, vec3 position){\n    // This is a simple example of a function that does nothing.\n    // It returns a vec3 that is the color of the pixel we're drawing.\n    return color;\n}\n\n// This is the main function that does all the work.\n// It takes a vec3 called \"color\" and a vec3 called \"position\".\n// The color is the color of the pixel we're drawing, and the position is\n// the position of the pixel we're drawing.\n//\n// The function returns a vec3.\n//\n// The function should return a vec3 that is the color of the pixel we're drawing.\n//\n// The function should return a vec3 that is the position of the pixel we're drawing.\nvec3 doPixel(vec3 color, vec3 position){\n    // This is a simple example", "\n    vec3 color = vec3(0.0);\n    float distance = length(positionOfHit);\n    float alpha = 1.0 - distance / 1.0;\n    color = vec3(1.0, 0.0, 0.0);\n    color = mix(color, vec3(0.0, 1.0, 0.0), alpha);\n    return color;\n}\n\nvec3 doSphereColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    float distance = length(positionOfHit);\n    float alpha = 1.0 - distance / 1.0;\n    color = vec3(0.0, 0.0, 1.0);\n    color = mix(color, vec3(1.0, 1.0, 1.0), alpha);\n    return color;\n}\n\nvec3 doCylinderColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    float distance = length(positionOfHit);\n    float alpha = 1.0 - distance / 1.0;\n    color = vec3(0.0, 0.0, 1.0);\n    color = mix(color, vec3(1.0, 1.0, 1.0), alpha);\n    return color;\n}\n\nvec3 doConeColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    float distance = length(positionOfHit);\n    float alpha = 1.0 - distance / 1.0;\n    color = vec3(0.0, 0.0, 1.0);\n    color = mix(color, vec3(1.0, 1.0, 1.0), alpha);\n    return color;\n}\n\nvec3 doConeColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    float distance = length(positionOfHit);\n    float alpha = 1", "\n\n    // We'll use the rayHitInfo to figure out\n    // what color the world will be!\n    // and what marvelous colors it will be!\n    vec3 color = vec3(0.0);\n\n    // If the ray hit a sphere, we'll use the\n    // rayHitInfo to figure out what color\n    // the sphere will be!\n    if( rayHitInfo.x == 1.0 ){\n\n        // We'll use the rayHitInfo to figure out\n        // the radius of the sphere!\n        float radius = rayHitInfo.y;\n\n        // We'll use the rayHitInfo to figure out\n        // the position of the sphere!\n        vec3 spherePosition = rayHitInfo.z;\n\n        // We'll use the rayDirection to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 eyePosition = normalize( eyePosition );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        vec3 rayDirection = normalize( rayDirection );\n\n        // We'll use the eyePosition to figure out\n        // the direction of the ray!\n        ", "\n  return smoothstep(0.0, 1.0, b * x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias_inv(float x, float b) {\n  return smoothstep(0.0, 1.0, (1.0 - b) * x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias_inv_inv(float x, float b) {\n  return smoothstep(0.0, 1.0, (1.0 - b) * (1.0 - x));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias_inv_inv_inv(float x, float b) {\n  return smoothstep(0.0, 1.0, (1.0 - b) * (1.0 - (1.0 - x)));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias_inv_inv_inv_inv(float x, float b) {\n  ", "\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p.x*p.y)*43758.5453+p.y*131.072);\n}\n\n// returns a random number in the range 0..1\nfloat rand(vec2 p){\n    return fract(sin(p", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) - 0.5;\n}\n\n// creates white noise in the range -1..1 including 0 including 1\nfloat rand_inclusive_x(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range -1..1 excluding 0 excluding 1\nfloat rand_exclusive_x(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_y(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_y(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range -1..1 including 0 including 1\nfloat rand_inclusive_xy(", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to radius of cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 q = abs(vec2(length(p.xz), p.y));\n    return min(q.x, q.y) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r --> is cone radius\n// input h --> is cone height\n// pretty simple, just compare point to radius of cone\nfloat sdCone(vec3 p, float r, float h)\n{\n    vec2 q = abs(vec2(length(p.xz), p.y));\n    return min(q.x, q.y) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input r --> is box radius\n// pretty simple, just compare point to radius of box\nfloat sdBox(vec3 p, float r)\n{\n    return max(max(max(p.x, p.y), p.z), -r) + r;\n}\n\n// ~~~~~~~ signed fistance fuction for plane\n// input n --> is plane normal\n// input p --> is plane position\n// pretty simple, just compare point to plane\nfloat sdPlane(vec3 p, vec3 n, float d)\n{\n    return dot(p, n) - d;\n}\n\n// ~~~~~~~ signed fistance fuction for triangle\n// input v0 --> is triangle vertex 0\n// input v1 --> is triangle vertex 1\n// input v2 --> is triangle vertex 2\n// pretty simple, just compare point to plane\nfloat sdTriangle(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 e2 = p - v0;\n    float a = dot(e1, e1);\n    float", "\n\tvec2 q = p.xz;\n\tfloat r = length(q);\n\tfloat d = r - t.x;\n\tfloat h = t.y - d;\n\treturn max(d, h);\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n// \tt.x = sphere radius\n//\n// think of the sphere as a circle with a radius\n// first flatten the y axis of p (by using p.xz) and get the distance to 0\n// then simply subtract the sphere radius from that\nfloat sdSphere(vec3 p, vec2 t)\n{\n\tvec2 q = p.xz;\n\tfloat d = length(q);\n\treturn max(d, t.x - d);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input t --> cylinder specs where:\n// \tt.x = cylinder height\n//\tt.y = cylinder radius\n//\n// think of the cylinder as a cylinder with a radius\n// first flatten the y axis of p (by using p.xz) and get the distance to 0\n// then simply subtract the cylinder radius from that\nfloat sdCylinder(vec3 p, vec2 t)\n{\n\tvec2 q = p.xz;\n\tfloat d = length(q);\n\treturn max(d, t.y - d);\n}\n\n// ~~~~~~~ signed distance function for cone\n// input t --> cone specs where:\n// \tt.x = cone height\n//\tt.y = cone radius\n//\n// think of the cone as a cone with a radius\n// first flatten the y axis of p (by using p.xz) and get the distance to 0\n// then simply subtract the cone radius from that\nfloat sdCone(vec3 p, vec2 t)\n{\n\tvec2 q = p.xz;\n\tfloat d = length(q);\n\treturn max(d, t.y - d);\n}\n\n// ~~~~~~~ signed distance function for plane\n// input t --> plane specs where:\n// \tt.x = plane height\n//\tt.y = plane width\n//\n// think of the plane as a rectangle", "\n\tfloat d = min(d1,d2);\n\tfloat s = 0.5*d;\n\tfloat a = 0.5*(d*d*d - s*s);\n\tfloat b = 0.5*(d - s);\n\treturn a*cos(b*PI) + s;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2)\n{\n\tfloat d = max(d1,d2);\n\tfloat s = 0.5*d;\n\tfloat a = 0.5*(d*d*d - s*s);\n\tfloat b = 0.5*(d - s);\n\treturn a*cos(b*PI) + s;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2)\n{\n\tfloat d = max(d1,d2);\n\tfloat s = 0.5*d;\n\tfloat a = 0.5*(d*d*d - s*s);\n\tfloat b = 0.5*(d - s);\n\treturn a*cos(b*PI) + s;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2)\n{\n\tfloat d = max(d1,d2);\n", "\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n\treturn (d1 + d2) / 2.0;\n}\n\n", "\n\tfloat s = sin( yaw );\n\tfloat c = cos( yaw );\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\tfloat t4 = t3*t;\n\tfloat t5 = t4*t;\n\tfloat t6 = t5*t;\n\tfloat t7 = t6*t;\n\tfloat t8 = t7*t;\n\tfloat t9 = t8*t;\n\tfloat t10 = t9*t;\n\tfloat t11 = t10*t;\n\tfloat t12 = t11*t;\n\tfloat t13 = t12*t;\n\tfloat t14 = t13*t;\n\tfloat t15 = t14*t;\n\tfloat t16 = t15*t;\n\tfloat t17 = t16*t;\n\tfloat t18 = t17*t;\n\tfloat t19 = t18*t;\n\tfloat t20 = t19*t;\n\tfloat t21 = t20*t;\n\tfloat t22 = t21*t;\n\tfloat t23 = t22*t;\n\tfloat t24 = t23*t;\n\tfloat t25 = t24*t;\n\tfloat t26 = t25*t;\n\tfloat t27 = t26*t;\n\tfloat t28 = t27*t;\n\tfloat t29 = t28*t;\n\tfloat t30 = t29*t;\n\tfloat t31 = t30*t;\n\tfloat t32 = t31*t;\n\tfloat t33 = t32*t;\n\tfloat t34 = t33*t;\n\tfloat t35 = t34*t;\n\tfloat t36 = t35*t;\n\tfloat t37 = t36*t;\n\tfloat t38 = t37*t;\n\tfloat t39 = t38*t;\n\tfloat t40 = t39*t;\n\tfloat", "\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if()\nvec2 opU(vec2 o1, vec2 o2)\n{\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if()\nvec2 opU(vec2 o1, vec2 o2)\n{\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if()\nvec2 opU(vec2 o1, vec2 o2)\n{\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if()\nvec2 opU(vec2 o1, vec2 o2)\n{\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if()\nvec2 opU(vec2 o1, vec2 o2", "\n    // 1. find the closest object\n    float closest = 1e10;\n    vec3 closest_p = vec3(0.0);\n    for (int i = 0; i < num_objects; i++)\n    {\n        vec3 p_i = objects[i].p;\n        float dist = distance(p, p_i);\n        if (dist < closest)\n        {\n            closest = dist;\n            closest_p = p_i;\n        }\n    }\n    // 2. move the closest object\n    // 3. map the closest object\n    // 4. repeat\n    return closest_p;\n}\n\n// ~~~~~~~ draw the world\nvoid draw()\n{\n    // 1. clear the screen\n    glClear(GL_COLOR_BUFFER_BIT);\n    // 2. draw the objects\n    for (int i = 0; i < num_objects; i++)\n    {\n        // 3. draw the object\n        // 4. repeat\n    }\n    // 5. draw the light\n    // 6. repeat\n    // 7. repeat\n    // 8. repeat\n    // 9. repeat\n    // 10. repeat\n    // 11. repeat\n    // 12. repeat\n    // 13. repeat\n    // 14. repeat\n    // 15. repeat\n    // 16. repeat\n    // 17. repeat\n    // 18. repeat\n    // 19. repeat\n    // 20. repeat\n    // 21. repeat\n    // 22. repeat\n    // 23. repeat\n    // 24. repeat\n    // 25. repeat\n    // 26. repeat\n    // 27. repeat\n    // 28. repeat\n    // 29. repeat\n    // 30. repeat\n    // 31. repeat\n    // 32. repeat\n    // 33. repeat\n    // 34. repeat\n    // 35. repeat\n    // 36. repeat\n    // 37. repeat\n    // 38. repeat\n", "\n\tvec2 res = vec2(0.0, 0.0);\n\tvec3 p = ro;\n\tfloat t = 0.0;\n\tfloat tmin = 1000000.0;\n\tfloat tmax = -1000000.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 =", "\n    vec3 color = vec3(0.0);\n    vec3 p = ro + rd * 0.001;\n    vec3 normal = vec3(0.0);\n    float nos = 0.0;\n    float t = 0.0;\n    float tmin = 1000.0;\n    vec3 c = vec3(0.0);\n    vec3 c1 = vec3(0.0);\n    vec3 c2 = vec3(0.0);\n    vec3 c3 = vec3(0.0);\n    vec3 c4 = vec3(0.0);\n    vec3 c5 = vec3(0.0);\n    vec3 c6 = vec3(0.0);\n    vec3 c7 = vec3(0.0);\n    vec3 c8 = vec3(0.0);\n    vec3 c9 = vec3(0.0);\n    vec3 c10 = vec3(0.0);\n    vec3 c11 = vec3(0.0);\n    vec3 c12 = vec3(0.0);\n    vec3 c13 = vec3(0.0);\n    vec3 c14 = vec3(0.0);\n    vec3 c15 = vec3(0.0);\n    vec3 c16 = vec3(0.0);\n    vec3 c17 = vec3(0.0);\n    vec3 c18 = vec3(0.0);\n    vec3 c19 = vec3(0.0);\n    vec3 c20 = vec3(0.0);\n    vec3 c21 = vec3(0.0);\n    vec3 c22 = vec3(0.0);\n    vec3 c23 = vec3(0.0);\n    vec3 c24 = vec3(0.0);\n    vec3 c25 = vec3(0.0);\n    vec3 c26 = vec3(0.0);\n    vec3 c27 = vec3(0.0);\n    vec3 c28 = vec3(0.0);\n    vec3 c29 = vec", "\n    vec3 up = normalize( cross( targetPos - camPos, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 right = normalize( cross( up, targetPos - camPos ) );\n    vec3 forward = normalize( cross( right, up ) );\n\n    mat3 rot = mat3(\n        right.x, forward.x, forward.y,\n        right.y, right.z, forward.z,\n        right.z, forward.y, forward.x\n    );\n\n    mat3 rot2 = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos( roll ), -sin( roll ),\n        0.0, sin( roll ), cos( roll )\n    );\n\n    return rot * rot2;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat4 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 up = normalize( cross( targetPos - camPos, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 right = normalize( cross( up, targetPos - camPos ) );\n    vec3 forward = normalize( cross( right, up ) );\n\n    mat4 rot = mat4(\n        right.x, forward.x, forward.y, 0.0,\n        right.y, right.z, forward.z, 0.0,\n        right.z, forward.y, forward.x, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    mat4 rot2 = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos( roll ), -sin( roll ), 0.0,\n        0.0, sin( roll ), cos( roll ), 0.0,\n", "\n    if (id < 0.0)\n    {\n        return vec3(0.0);\n    }\n    else if (id < 1.0)\n    {\n        return vec3(1.0);\n    }\n    else if (id < 2.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (id < 3.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (id < 4.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (id < 5.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (id < 6.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (id < 7.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (id < 8.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (id < 9.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 10.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (id < 11.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (id < 12.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (id < 13.0)\n    {\n        return vec3(1.0, 1.0, 0.0);", "\n    vec2 q = p.xz;\n    float r = length(q);\n    float d = r - t.x;\n    float h = clamp(d, 0.0, t.y);\n    return length(q) - h;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n//  t.x = sphere radius\n//\n// think of the sphere as a circle with a radius\n// first flatten the y axis of p (by using p.xz) and get the distance to\n// the sphere radius which is flat on the y axis\n// then simply subtract the sphere radius from that\nfloat sdSphere(vec3 p, vec2 t)\n{\n    vec2 q = p.xz;\n    float d = length(q);\n    float h = clamp(d, 0.0, t.x);\n    return length(q) - h;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input t --> cylinder specs where:\n//  t.x = cylinder height\n//  t.y = cylinder radius\n//\n// think of the cylinder as a cylinder with a radius\n// first flatten the y axis of p (by using p.xz) and get the distance to\n// the cylinder height which is flat on the y axis\n// then simply subtract the cylinder radius from that\nfloat sdCylinder(vec3 p, vec2 t)\n{\n    vec2 q = p.xz;\n    float d = length(q);\n    float h = clamp(d, 0.0, t.x);\n    float r = t.y;\n    float h2 = h*h;\n    float r2 = r*r;\n    float d2 = d*d;\n    float hr = h2 + r2;\n    float dhr = d2 - h2;\n    float dhr2 = dhr*dhr;\n    float dhr3 = dhr2*dhr;\n    float dhr4 = dhr3*dhr;\n    float dhr5 = dhr4*dhr;\n    float dhr6 = dhr5*dhr;\n    float dhr7 = dhr6*dhr;", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// sphere extends indefinately in x and z,\n// so just return distance from center (x,y,z)\nfloat sdSphere(vec3 p)\n{\n    return length(p.xz) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// cylinder extends indefinately in x and z,\n// so just return distance from center (x,y,z)\nfloat sdCylinder(vec3 p)\n{\n    return length(p.xz) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// cone extends indefinately in x and z,\n// so just return distance from center (x,y,z)\nfloat sdCone(vec3 p)\n{\n    return length(p.xz) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// torus extends indefinately in x and z,\n// so just return distance from center (x,y,z)\nfloat sdTorus(vec3 p)\n{\n    return length(p.xz) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n// box extends indefinately in x and z,\n// so just return distance from center (x,y,z)", "\n\tfloat d = d1;\n\tif (d2 < d) d = d2;\n\tif (d < 0.0) d = 0.0;\n\treturn d * (1.0 - k) + d1 * k;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n\tfloat d = d1;\n\tif (d2 > d) d = d2;\n\tif (d > 1.0) d = 1.0;\n\treturn d * (1.0 - k) + d1 * k;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float d3, float k)\n{\n\tfloat d = d1;\n\tif (d2 < d) d = d2;\n\tif (d3 < d) d = d3;\n\tif (d < 0.0) d = 0.0;\n\treturn d * (1.0 - k) + d1 * k;\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float d3, float k)\n{\n\tfloat d", "\n    vec4 ret;\n    ret.xyz = o1.xyz * (1.0 - bf) + o2.xyz * bf;\n    ret.w = o1.w * (1.0 - bf) + o2.w * bf;\n    return ret;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 ret;\n    ret.xyz = o1.xyz * (1.0 - bf) + o2.xyz * bf;\n    ret.w = o1.w * (1.0 - bf) + o2.w * bf;\n    return ret;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 ret;\n    ret.xyz = o1.xyz * (1.0 - bf) + o2.xyz * bf;\n    ret.w = o1.w * (1.0 - bf) + o2.w * bf;\n    return ret;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 ret;\n    ret.xyz = o1.xyz * (1.0 - bf) +", "\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n", "\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    if (lightType == 0)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 1)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 2)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 3)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 4)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 5)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 6)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 7)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 8)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 9)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 10)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 11)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if (lightType == 12)\n    {\n        lightPos", "\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    vec4 closest = vec4(1000000.0, 0.0, 0.0, 0.0);\n    vec4 blended = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i = 0; i < num_objects; i++)\n    {\n        vec4 object = objects[i];\n        vec3 object_pos = object.xyz;\n        vec3 object_normal = object.w;\n        vec3 object_color = object.w;\n        vec3 object_diffuse = object.w;\n        vec3 object_specular = object.w;\n        float object_roughness = object.w;\n        float object_reflection = object.w;\n        float object_refraction = object.w;\n        float object_transparency = object.w;\n        float object_opacity = object.w;\n        float object_refraction_index = object.w;\n        float object_reflection_index = object.w;\n        float object_refraction_factor = object.w;\n        float object_reflection_factor = object.w;\n        float object_transparency_factor = object.w;\n        float object_opacity_factor = object.w;\n        float object_refraction_factor_max = object.w;\n        float object_reflection_factor_max = object.w;\n        float object_transparency_factor_max = object.w;\n        float object_opacity_factor_max = object.w;\n        float object_refraction_factor_min = object.w;\n        float object_reflection_factor_min = object.w;\n        float object_transparency_factor_min = object.w;\n        float object_opacity_factor_min = object.w;\n        float object_refraction_factor_min_max = object.", "\n    vec3 p = ro;\n    float t = 0.0;\n    float tMax = 10000.0;\n    float tInc = 0.0001;\n    float tInc2 = 0.000001;\n    float tInc3 = 0.0000001;\n    float tInc4 = 0.00000001;\n    float tInc5 = 0.000000001;\n    float tInc6 = 0.0000000001;\n    float tInc7 = 0.00000000001;\n    float tInc8 = 0.000000000001;\n    float tInc9 = 0.0000000000001;\n    float tInc10 = 0.00000000000001;\n    float tInc11 = 0.000000000000001;\n    float tInc12 = 0.0000000000000001;\n    float tInc13 = 0.00000000000000001;\n    float tInc14 = 0.000000000000000001;\n    float tInc15 = 0.0000000000000000001;\n    float tInc16 = 0.00000000000000000001;\n    float tInc17 = 0.000000000000000000001;\n    float tInc18 = 0.0000000000000000000001;\n    float tInc19 = 0.00000000000000000000", "\n    float d = 1.0;\n    float t = 0.0;\n    float r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n    float r4 = 0.0;\n    float r5 = 0.0;\n    float r6 = 0.0;\n    float r7 = 0.0;\n    float r8 = 0.0;\n    float r9 = 0.0;\n    float r10 = 0.0;\n    float r11 = 0.0;\n    float r12 = 0.0;\n    float r13 = 0.0;\n    float r14 = 0.0;\n    float r15 = 0.0;\n    float r16 = 0.0;\n    float r17 = 0.0;\n    float r18 = 0.0;\n    float r19 = 0.0;\n    float r20 = 0.0;\n    float r21 = 0.0;\n    float r22 = 0.0;\n    float r23 = 0.0;\n    float r24 = 0.0;\n    float r25 = 0.0;\n    float r26 = 0.0;\n    float r27 = 0.0;\n    float r28 = 0.0;\n    float r29 = 0.0;\n    float r30 = 0.0;\n    float r31 = 0.0;\n    float r32 = 0.0;\n    float r33 = 0.0;\n    float r34 = 0.0;\n    float r35 = 0.0;\n    float r36 = 0.0;\n    float r37 = 0.0;\n    float r38 = 0.0;\n    float r39 = 0.0;\n    float r40 = 0.0;\n    float r41 = 0.0;\n    float r42 = 0.", "\n    float d = 0.0;\n    float t = 0.0;\n    float tmax = 100.0;\n    vec3 dir = normalize(nor);\n    vec3 p = sp;\n    for (int i = 0; i < 100; i++)\n    {\n        p += dir * t;\n        float d0 = distance(p, sp);\n        if (d0 < d)\n        {\n            d = d0;\n            t = tmax;\n        }\n        else\n        {\n            t += 0.01;\n        }\n        if (t > tmax)\n        {\n            break;\n        }\n    }\n    return d;\n}\n\n// ~~~~~~~ shadow\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_Shadow(vec3 sp, vec3 nor, vec3 dir, float d)\n{\n    float t = 0.0;\n    float tmax = 100.0;\n    vec3 p = sp;\n    for (int i = 0; i < 100; i++)\n    {\n        p += dir * t;\n        float d0 = distance(p, sp);\n        if (d0 < d)\n        {\n            d = d0;\n            t = tmax;\n        }\n        else\n        {\n            t += 0.01;\n        }\n        if (t > tmax)\n        {\n            break;\n        }\n    }\n    return d;\n}\n\n// ~~~~~~~ shadow\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_Shadow_AmbientOcclusion(vec3 sp, vec3 nor, vec3 dir, float d)\n{\n    float t = 0.0;\n    float", "\n    vec3 n = oN;\n    vec3 nDiff = vec3(0.0);\n    for(int i = 0; i < 10; i++)\n    {\n        p += n;\n        vec3 oN = getNormal(p);\n        nDiff += oN;\n    }\n    nDiff /= 10.0;\n    return nDiff;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  (with a bit of smoothing)\nvec3 nearbyNormalsDiffSmooth(vec3 p, vec3 oN)\n{\n    vec3 n = oN;\n    vec3 nDiff = vec3(0.0);\n    for(int i = 0; i < 10; i++)\n    {\n        p += n;\n        vec3 oN = getNormal(p);\n        nDiff += oN;\n    }\n    nDiff /= 10.0;\n    return nDiff;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  (with a bit of smoothing)\nvec3 nearbyNormalsDiffSmooth2(vec3 p, vec3 oN)\n{\n    vec3 n = oN;\n    vec3 nDiff = vec3(0.0);\n    for(int i = 0; i < 10; i++)\n    {\n        p += n;\n        vec3 oN = getNormal(p);\n        nDiff += oN;\n    }\n    nDiff /= 10.0;\n    return nDiff;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  (with a bit of smoothing)\nvec3 nearbyNormalsDiff", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2", "\n  vec3 fc = mix(fc1,fc2,fs.x);\n  float f = pow(fs.y,d);\n  return c + fc * (1.0-f) * cRD * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-f) * (1.0-", "\n\tfloat attn = 1.0;\n\tif (d < 0.0)\n\t\treturn attn;\n\tattn = cF + lF * d + qF * d * d;\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n\tfloat attn = 1.0;\n\tif (d < 0.0)\n\t\treturn attn;\n\tattn = cF + lF * d + qF * d * d;\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n\tfloat attn = 1.0;\n\tif (d < 0.0)\n\t\treturn attn;\n\tattn = cF + lF * d + qF * d * d;\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n", "\n    vec3 rayDir = vec3(fCoord, 1.0);\n    rayDir = cMatrix * rayDir;\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = vec3(fCoord, 0.0);\n    rayOrigin = cMatrix * rayOrigin;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = vec3(fCoord, 0.0);\n    rayOrigin = cMatrix * rayOrigin;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = vec3(fCoord, 0.0);\n    rayOrigin = cMatrix * rayOrigin;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = vec3(fCoord, 0.0);\n    rayOrigin = cMatrix * rayOrigin;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = vec3(fCoord, 0.0", "\n    // 1. get pixel's itteration/march count\n    int iIter = int(fCoord.x);\n    // 2. get pixel's color\n    vec3 cColor = vec3(0.0);\n    // 3. get pixel's color\n    for(int i=0;i<iIter;i++)\n    {\n        cColor += render_pixel(fCoord,cPos,cMat);\n    }\n    // 4. return pixel's color\n    return cColor/float(iIter);\n}\n\n// ~~~~~~~ render pixel, based on pixel's itteration/march count\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec3 render_pixel(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    // 1. get pixel's itteration/march count\n    int iIter = int(fCoord.x);\n    // 2. get pixel's color\n    vec3 cColor = vec3(0.0);\n    // 3. get pixel's color\n    for(int i=0;i<iIter;i++)\n    {\n        cColor += render_pixel_march(fCoord,cPos,cMat);\n    }\n    // 4. return pixel's color\n    return cColor/float(iIter);\n}\n\n// ~~~~~~~ render pixel, based on pixel's itteration/march count\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec3 render_pixel_march(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    // 1. get pixel's itteration/march count\n    int iIter = int(fCoord.x);\n    // 2. get pixel's color\n    vec3 cColor = vec3(0.0);\n    // 3. get pixel's color\n    for(int i=0;i<iIter;i++)\n    ", "\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec2 c = vec2(0.0, 0.0);\n    float maxIter = 100.0;\n    float dist = 0.0;\n    float iter = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n\n    for(int i = 0; i < 100; i++)\n    {\n        c = vec2(0.0, 0.0);\n        dist = 0.0;\n        iter = 0.0;\n        r = 0.0;\n        g = 0.0;\n        b = 0.0;\n        a = 0.0;\n\n        while(dist < 2.0 && iter < maxIter)\n        {\n            iter++;\n            dist = dot(c, c);\n            c = c * c + uv;\n        }\n\n        if(iter == maxIter)\n        {\n            r = 0.0;\n            g = 0.0;\n            b = 0.0;\n            a = 0.0;\n        }\n        else\n        {\n            r = 1.0 - (iter / maxIter);\n            g = 1.0 - (iter / maxIter);\n            b = 1.0 - (iter / maxIter);\n            a = 1.0;\n        }\n\n        r = r * 0.5 + 0.5;\n        g = g * 0.5 + 0.5;\n        b = b * 0.5 + 0.5;\n        a = a * 0.5 + 0.5;\n\n        fragColor = vec4(r, g, b, a);\n    }\n}", "\n    return length(p) - radius;\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n{\n    return length(p.xy) - height;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float height)\n", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple plane distance field\nfloat plane(vec2 p, vec2 n, float d)\n{\n    return dot(p, n) - d;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b, vec2 c)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + c.x * dot(p, p) + c.y * dot(p, p);\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b, vec2 c, vec2 d)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + c.x * dot(p, p) + c.y * dot(p, p) + d.x * d.y;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b, vec2 c, vec2 d, vec2 e)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + c.x * dot(p, p) + c.y * dot(p, p) + d.x * d.y + e.x * dot(p, p) + e.y * dot(p, p);\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b, vec2 c, vec2", "\n    vec2 d = vec2(1000000.0, 0.0);\n    float m = 0.0;\n    for (int i = 0; i < numObjects; i++)\n    {\n        vec3 p1 = objects[i].position;\n        vec3 p2 = p1 + objects[i].size;\n        vec3 p3 = p1 - objects[i].size;\n        vec3 p4 = p2 + objects[i].size;\n        vec3 p5 = p2 - objects[i].size;\n        vec3 p6 = p3 + objects[i].size;\n        vec3 p7 = p3 - objects[i].size;\n        vec3 p8 = p4 + objects[i].size;\n        vec3 p9 = p4 - objects[i].size;\n        vec3 p10 = p5 + objects[i].size;\n        vec3 p11 = p5 - objects[i].size;\n        vec3 p12 = p6 + objects[i].size;\n        vec3 p13 = p6 - objects[i].size;\n        vec3 p14 = p7 + objects[i].size;\n        vec3 p15 = p7 - objects[i].size;\n        vec3 p16 = p8 + objects[i].size;\n        vec3 p17 = p8 - objects[i].size;\n        vec3 p18 = p9 + objects[i].size;\n        vec3 p19 = p9 - objects[i].size;\n        vec3 p20 = p10 + objects[i].size;\n        vec3 p21 = p10 - objects[i].size;\n        vec3 p22 = p11 + objects[i].size;\n        vec3 p23 = p11 - objects[i].size;\n        vec3 p24 = p12 + objects[i].size;\n        vec3 p25 = p12 - objects[i].size;\n        vec3 p26 = p13 + objects[", "\n    return pow(c, vec2(0.0, 5.0));\n}\n\n//Function that returns a complex number to power of 10\nvec2 complexPower10(vec2 c)\n{\n    return pow(c, vec2(0.0, 10.0));\n}\n\n//Function that returns a complex number to power of 15\nvec2 complexPower15(vec2 c)\n{\n    return pow(c, vec2(0.0, 15.0));\n}\n\n//Function that returns a complex number to power of 20\nvec2 complexPower20(vec2 c)\n{\n    return pow(c, vec2(0.0, 20.0));\n}\n\n//Function that returns a complex number to power of 25\nvec2 complexPower25(vec2 c)\n{\n    return pow(c, vec2(0.0, 25.0));\n}\n\n//Function that returns a complex number to power of 30\nvec2 complexPower30(vec2 c)\n{\n    return pow(c, vec2(0.0, 30.0));\n}\n\n//Function that returns a complex number to power of 35\nvec2 complexPower35(vec2 c)\n{\n    return pow(c, vec2(0.0, 35.0));\n}\n\n//Function that returns a complex number to power of 40\nvec2 complexPower40(vec2 c)\n{\n    return pow(c, vec2(0.0, 40.0));\n}\n\n//Function that returns a complex number to power of 45\nvec2 complexPower45(vec2 c)\n{\n    return pow(c, vec2(0.0, 45.0));\n}\n\n//Function that returns a complex number to power of 50\nvec2 complexPower50(vec2 c)\n{\n    return pow(c, vec2(0.0, 50.0));\n}\n\n//Function that returns a complex number to power of 55\nvec2 complexPower55(vec2 c)\n{\n    return", "\n    vec2 coords = coord;\n    vec2 morph = morphConstant;\n\n    // The biomorph is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2D shape with a 3D shape inside it.\n    // The 3D shape is a 2", "\n\tvec2 uv2 = uv;\n\tvec2 uv3 = uv;\n\tvec2 uv4 = uv;\n\tvec2 uv5 = uv;\n\tvec2 uv6 = uv;\n\tvec2 uv7 = uv;\n\tvec2 uv8 = uv;\n\tvec2 uv9 = uv;\n\tvec2 uv10 = uv;\n\tvec2 uv11 = uv;\n\tvec2 uv12 = uv;\n\tvec2 uv13 = uv;\n\tvec2 uv14 = uv;\n\tvec2 uv15 = uv;\n\tvec2 uv16 = uv;\n\tvec2 uv17 = uv;\n\tvec2 uv18 = uv;\n\tvec2 uv19 = uv;\n\tvec2 uv20 = uv;\n\tvec2 uv21 = uv;\n\tvec2 uv22 = uv;\n\tvec2 uv23 = uv;\n\tvec2 uv24 = uv;\n\tvec2 uv25 = uv;\n\tvec2 uv26 = uv;\n\tvec2 uv27 = uv;\n\tvec2 uv28 = uv;\n\tvec2 uv29 = uv;\n\tvec2 uv30 = uv;\n\tvec2 uv31 = uv;\n\tvec2 uv32 = uv;\n\tvec2 uv33 = uv;\n\tvec2 uv34 = uv;\n\tvec2 uv35 = uv;\n\tvec2 uv36 = uv;\n\tvec2 uv37 = uv;\n\tvec2 uv38 = uv;\n\tvec2 uv39 = uv;\n\tvec2 uv40 = uv;\n\tvec2 uv41 = uv;\n\tvec2 uv42 = uv;\n\tvec2 uv43 = uv;\n\tvec2 uv44 = uv;\n\tvec2", "\n  return fract(x * 2.0);\n}\n\n// A sine wave\nfloat sine(float x) {\n  return sin(x * 2.0 * PI);\n}\n\n// A sawtooth wave\nfloat sawtooth(float x) {\n  return x - floor(x + 0.5);\n}\n\n// A square wave\nfloat square(float x) {\n  return step(x, 0.5);\n}\n\n// A triangle wave\nfloat triangle(float x) {\n  return 1.0 - abs(x - 0.5);\n}\n\n// A sawtooth wave\nfloat sawtooth(float x) {\n  return x - floor(x + 0.5);\n}\n\n// A square wave\nfloat square(float x) {\n  return step(x, 0.5);\n}\n\n// A triangle wave\nfloat triangle(float x) {\n  return 1.0 - abs(x - 0.5);\n}\n\n// A sawtooth wave\nfloat sawtooth(float x) {\n  return x - floor(x + 0.5);\n}\n\n// A square wave\nfloat square(float x) {\n  return step(x, 0.5);\n}\n\n// A triangle wave\nfloat triangle(float x) {\n  return 1.0 - abs(x - 0.5);\n}\n\n// A sawtooth wave\nfloat sawtooth(float x) {\n  return x - floor(x + 0.5);\n}\n\n// A square wave\nfloat square(float x) {\n  return step(x, 0.5);\n}\n\n// A triangle wave\nfloat triangle(float x) {\n  return 1.0 - abs(x - 0.5);\n}\n\n// A sawtooth wave\nfloat sawtooth(float x) {\n  return x - floor(x + 0.5);\n}\n\n// A square wave\nfloat square(float x) {\n  return step(x, 0.5);\n}\n\n// A triangle wave\nfloat triangle(float x) {\n  return 1.0 - abs(", "\n\tvec2 d = pB - pA;\n\tfloat dist = length(d);\n\tfloat dash = dashOn * dist;\n\tfloat dashDist = dash * 0.5;\n\tfloat dashThick = dashDist * thick.y;\n\tfloat dashThick2 = dashThick * dashThick;\n\tfloat dashThick3 = dashThick2 * dashThick;\n\tfloat dashThick4 = dashThick3 * dashThick;\n\tfloat dashThick5 = dashThick4 * dashThick;\n\tfloat dashThick6 = dashThick5 * dashThick;\n\tfloat dashThick7 = dashThick6 * dashThick;\n\tfloat dashThick8 = dashThick7 * dashThick;\n\tfloat dashThick9 = dashThick8 * dashThick;\n\tfloat dashThick10 = dashThick9 * dashThick;\n\tfloat dashThick11 = dashThick10 * dashThick;\n\tfloat dashThick12 = dashThick11 * dashThick;\n\tfloat dashThick13 = dashThick12 * dashThick;\n\tfloat dashThick14 = dashThick13 * dashThick;\n\tfloat dashThick15 = dashThick14 * dashThick;\n\tfloat dashThick16 = dashThick15 * dashThick;\n\tfloat dashThick17 = dashThick16 * dashThick;\n\tfloat dashThick18 = dashThick17 * dashThick;\n\tfloat dashThick19 = dashThick18 * dashThick;\n\tfloat dashThick20 = dashThick19 * dashThick;\n\tfloat dashThick21 = dashThick20 * dashThick;\n\tfloat dashThick22 = dashThick21 * dashThick;\n\tfloat dashThick23 = dashThick22 * dashThick;\n\tfloat dashThick24 = dashThick23 * dashThick;\n\tfloat dashThick25 = dashThick24 * dashThick;\n\tfloat dashThick26 = dashThick25 * dash", "\n  vec2 d = pB - pA;\n  float len = length(d);\n  float r = len * rounded;\n  float r2 = r * r;\n  float r3 = r * r2;\n  float r4 = r * r3;\n  float r5 = r * r4;\n  float r6 = r * r5;\n  float r7 = r * r6;\n  float r8 = r * r7;\n  float r9 = r * r8;\n  float r10 = r * r9;\n  float r11 = r * r10;\n  float r12 = r * r11;\n  float r13 = r * r12;\n  float r14 = r * r13;\n  float r15 = r * r14;\n  float r16 = r * r15;\n  float r17 = r * r16;\n  float r18 = r * r17;\n  float r19 = r * r18;\n  float r20 = r * r19;\n  float r21 = r * r20;\n  float r22 = r * r21;\n  float r23 = r * r22;\n  float r24 = r * r23;\n  float r25 = r * r24;\n  float r26 = r * r25;\n  float r27 = r * r26;\n  float r28 = r * r27;\n  float r29 = r * r28;\n  float r30 = r * r29;\n  float r31 = r * r30;\n  float r32 = r * r31;\n  float r33 = r * r32;\n  float r34 = r * r33;\n  float r35 = r * r34;\n  float r36 = r * r35;\n  float r37 = r * r36;\n  float r38 = r * r37;\n  float r39 = r * r38;\n  float r40", "\n    vec2 d = pB - pA;\n    float len = length(d);\n    float r = rounded * len;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r;\n    float r40", "\n    vec2 d = pB - pA;\n    float len = length(d);\n    float r = len * rounded;\n    float r2 = r * r;\n    float r3 = r * r2;\n    float r4 = r * r3;\n    float r5 = r * r4;\n    float r6 = r * r5;\n    float r7 = r * r6;\n    float r8 = r * r7;\n    float r9 = r * r8;\n    float r10 = r * r9;\n    float r11 = r * r10;\n    float r12 = r * r11;\n    float r13 = r * r12;\n    float r14 = r * r13;\n    float r15 = r * r14;\n    float r16 = r * r15;\n    float r17 = r * r16;\n    float r18 = r * r17;\n    float r19 = r * r18;\n    float r20 = r * r19;\n    float r21 = r * r20;\n    float r22 = r * r21;\n    float r23 = r * r22;\n    float r24 = r * r23;\n    float r25 = r * r24;\n    float r26 = r * r25;\n    float r27 = r * r26;\n    float r28 = r * r27;\n    float r29 = r * r28;\n    float r30 = r * r29;\n    float r31 = r * r30;\n    float r32 = r * r31;\n    float r33 = r * r32;\n    float r34 = r * r33;\n    float r35 = r * r34;\n    float r36 = r * r35;\n    float r37 = r * r36;\n    float r38 = r * r37;\n    float r39 = r * r38;\n    float r40", "\n  vec2 d = pB - pA;\n  float len = length(d);\n  float dash = len * rounded;\n  float dashLen = dash * 2.0;\n  float dashPos = dashLen * clamp(dot(d, d) / len, 0.0, 1.0);\n  float dashOffset = dashPos - dashLen * 0.5;\n  float dashWidth = dashLen * thick.x;\n  float dashHeight = dashLen * thick.y;\n  float dashX = dashOffset + dashWidth * 0.5;\n  float dashY = dashOffset + dashHeight * 0.5;\n  float dashX2 = dashOffset - dashWidth * 0.5;\n  float dashY2 = dashOffset - dashHeight * 0.5;\n  float dashX3 = dashOffset + dashWidth * 0.5;\n  float dashY3 = dashOffset - dashHeight * 0.5;\n  float dashX4 = dashOffset - dashWidth * 0.5;\n  float dashY4 = dashOffset + dashHeight * 0.5;\n  float dashX5 = dashOffset + dashWidth * 0.5;\n  float dashY5 = dashOffset + dashHeight * 0.5;\n  float dashX6 = dashOffset - dashWidth * 0.5;\n  float dashY6 = dashOffset + dashHeight * 0.5;\n  float dashX7 = dashOffset + dashWidth * 0.5;\n  float dashY7 = dashOffset - dashHeight * 0.5;\n  float dashX8 = dashOffset - dashWidth * 0.5;\n  float dashY8 = dashOffset - dashHeight * 0.5;\n  float dashX9 = dashOffset + dashWidth * 0.5;\n  float dashY9 = dashOffset - dashHeight * 0.5;\n  float dashX10 = dashOffset - dashWidth * 0.5;\n  float dashY10 = dashOffset + dashHeight * 0.5;\n  float dashX11 = dashOffset + dashWidth * 0.5;\n  float dashY11 = dashOffset + dashHeight * 0.", "\n    vec2 d = pB - pA;\n    float len = length(d);\n    float r = rounded * len;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r;\n    float r40", "\n  float d = 0.01;\n  vec2 uv2 = uv + d;\n  vec2 uv3 = uv - d;\n  vec2 uv4 = uv + d * vec2(1, -1);\n  vec2 uv5 = uv - d * vec2(1, -1);\n  vec2 uv6 = uv + d * vec2(-1, 1);\n  vec2 uv7 = uv - d * vec2(-1, 1);\n  vec2 uv8 = uv + d * vec2(-1, -1);\n  vec2 uv9 = uv - d * vec2(-1, -1);\n  vec2 uv10 = uv + d * vec2(1, 1);\n  vec2 uv11 = uv - d * vec2(1, 1);\n  vec2 uv12 = uv + d * vec2(-1, 1);\n  vec2 uv13 = uv - d * vec2(-1, 1);\n  vec2 uv14 = uv + d * vec2(1, -1);\n  vec2 uv15 = uv - d * vec2(1, -1);\n  vec2 uv16 = uv + d * vec2(-1, -1);\n  vec2 uv17 = uv - d * vec2(-1, -1);\n  vec2 uv18 = uv + d * vec2(1, 1);\n  vec2 uv19 = uv - d * vec2(1, 1);\n  vec2 uv20 = uv + d * vec2(-1, -1);\n  vec2 uv21 = uv - d * vec2(-1, -1);\n  vec2 uv22 = uv + d * vec2(1, 1);\n  vec2 uv23 = uv - d * vec2(1, 1);\n  vec2 uv24 = uv + d * vec2(-1, -1);\n  vec2 uv25 = uv - d * vec2(-1,", "\n    vec3  to = ro - cen;\n    float t = dot( to, nor ) / dot( rd, nor );\n    return t < 0.0? -1.0 : t * t - dot( to, to ) + rad * rad;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad )\n{\n    vec3  to = ro - cen;\n    float t = dot( to, rd ) / dot( rd, rd );\n    return t < 0.0? -1.0 : t * t - dot( to, to ) + rad * rad;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n    float t = dot( p - ro, n ) / dot( rd, n );\n    return t < 0.0? -1.0 : t;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 bmin, in vec3 bmax )\n{\n    vec3  to = ro - bmin;\n    float tmin = dot( to, rd );\n    vec3  tmax = tmin;\n    for( int i = 0; i < 3; i++ )\n    {\n        float t1 = dot( bmin[i] - ro, rd );\n        float t2 = dot( bmax[i] - ro, rd );\n        tmin = min( tmin, min( t1, t2 ) );\n        tmax = max( tmax, max( t1, t2 ) );\n    }\n    return tmin < 0.0? -1.0 : tmax;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  e1 = v1 - v0;\n    vec3  e2 = v2 - v0;\n    vec3", "\n    vec3  d = ro - cen;\n    float t = dot( d, rd );\n    vec3  p = cen + rd * t;\n    vec3  pd = p - ro;\n    float d2 = dot( pd, pd );\n    float r2 = dot( rad, rad );\n    if ( d2 > r2 )\n        return vec2( -1.0, -1.0 );\n    float b = r2 - d2;\n    if ( b < 0.0 )\n        return vec2( -1.0, -1.0 );\n    float h = sqrt( b );\n    return vec2( t - h, t + h );\n}\n\n// ray-sphere intersection (simplified)\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad )\n{\n    vec3  d = ro - cen;\n    float t = dot( d, rd );\n    vec3  p = cen + rd * t;\n    vec3  pd = p - ro;\n    float d2 = dot( pd, pd );\n    float r2 = rad * rad;\n    if ( d2 > r2 )\n        return vec2( -1.0, -1.0 );\n    float b = r2 - d2;\n    if ( b < 0.0 )\n        return vec2( -1.0, -1.0 );\n    float h = sqrt( b );\n    return vec2( t - h, t + h );\n}\n\n// ray-plane intersection (simplified)\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n    vec3  d = dot( p - ro, n );\n    float t = dot( d, rd );\n    vec3  p2 = ro + rd * t;\n    vec3  pd = p2 - p;\n    float d2 = dot( pd, pd );\n    if ( d2 > 0.0 )\n        return vec2( -1.0, -1.0 );\n    float h = dot( n, pd );\n    ", "\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tfloat r = ra + h;\n\tvec3 p = pa + d * (r / h);\n\tvec3 q = p + vec3(0.0, 0.0, ra);\n\tvec3 rr = vec3(r, r, ra);\n\tvec3 pp = p - rr;\n\tvec3 qq = q - rr;\n\treturn bound3(pp, rr, qq);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spherebbox/spherebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n\tvec3 pp = p - vec3(r, r, r);\n\tvec3 qq = p + vec3(r, r, r);\n\treturn bound3(pp, vec3(2.0*r), qq);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a capsule (http://iquilezles.org/www/articles/capsulebbox/capsulebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tfloat r = ra + h;\n\tvec3 p = pa + d * (r / h);\n\tvec3 q = p + vec3(0.0, 0.0, ra);\n\tvec3 rr = vec3(r, r, ra);\n\tvec3 pp = p - rr;\n\tvec3 qq = q - r", "\n    vec3 ba = pb - pa;\n    float ba_len = length( ba );\n    float ba_len2 = ba_len * ba_len;\n    float ba_len4 = ba_len2 * ba_len2;\n    float ba_len6 = ba_len4 * ba_len2;\n    float ba_len8 = ba_len6 * ba_len2;\n    float ba_len10 = ba_len8 * ba_len2;\n    float ba_len12 = ba_len10 * ba_len2;\n    float ba_len14 = ba_len12 * ba_len2;\n    float ba_len16 = ba_len14 * ba_len2;\n    float ba_len18 = ba_len16 * ba_len2;\n    float ba_len20 = ba_len18 * ba_len2;\n    float ba_len22 = ba_len20 * ba_len2;\n    float ba_len24 = ba_len22 * ba_len2;\n    float ba_len26 = ba_len24 * ba_len2;\n    float ba_len28 = ba_len26 * ba_len2;\n    float ba_len30 = ba_len28 * ba_len2;\n    float ba_len32 = ba_len30 * ba_len2;\n    float ba_len34 = ba_len32 * ba_len2;\n    float ba_len36 = ba_len34 * ba_len2;\n    float ba_len38 = ba_len36 * ba_len2;\n    float ba_len40 = ba_len38 * ba_len2;\n    float ba_len42 = ba_len40 * ba_len2;\n    float ba_len44 = ba_len42 * ba_len2;\n    float ba_len46 = ba_len44 * ba_len2;\n    float ba_len48 = ba_len46 * ba_len2;\n    float ba_len50 = ba_len48 * ba_len2;\n", "\n    vec3  p = ro + rd * 1e-10;\n    vec3  d = p - cen;\n    vec3  d2 = d * d;\n    vec3  d3 = d2 * d;\n    vec3  d4 = d3 * d;\n    vec3  d5 = d4 * d;\n    vec3  d6 = d5 * d;\n    vec3  d7 = d6 * d;\n    vec3  d8 = d7 * d;\n    vec3  d9 = d8 * d;\n    vec3  d10 = d9 * d;\n    vec3  d11 = d10 * d;\n    vec3  d12 = d11 * d;\n    vec3  d13 = d12 * d;\n    vec3  d14 = d13 * d;\n    vec3  d15 = d14 * d;\n    vec3  d16 = d15 * d;\n    vec3  d17 = d16 * d;\n    vec3  d18 = d17 * d;\n    vec3  d19 = d18 * d;\n    vec3  d20 = d19 * d;\n    vec3  d21 = d20 * d;\n    vec3  d22 = d21 * d;\n    vec3  d23 = d22 * d;\n    vec3  d24 = d23 * d;\n    vec3  d25 = d24 * d;\n    vec3  d26 = d25 * d;\n    vec3  d27 = d26 * d;\n    vec3  d28 = d27 * d;\n    vec3  d29 = d28 * d;\n    vec3  d30 = d29 * d;\n    vec3  d31 = d30 * d;\n    vec3  d32 = d31 * d;\n    vec3  d33 = d32 * d;\n    vec3  d34 = d33 * d;\n    vec3", "\n    vec3 d = pa - ro;\n    float a = dot( rd, rd );\n    float b = dot( d, rd );\n    float c = dot( d, d ) - r*r;\n    float h = b*b - a*c;\n    if( h < 0.0 )\n        return -1.0;\n    return -( b - sqrt( h ) ) / a;\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in float r )\n{\n    vec3 d = pa - ro;\n    float a = dot( rd, rd );\n    float b = dot( d, rd );\n    float c = dot( d, d ) - r*r;\n    float h = b*b - a*c;\n    if( h < 0.0 )\n        return -1.0;\n    return -( b - sqrt( h ) ) / a;\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat triangleIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc, in float r )\n{\n    vec3 d = pa - ro;\n    float a = dot( rd, rd );\n    float b = dot( d, rd );\n    float c = dot( d, d ) - r*r;\n    float h = b*b - a*c;\n    if( h < 0.0 )\n        return -1.0;\n    return -( b - sqrt( h ) ) / a;\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat triangleIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc, in float r )\n{\n    vec3 d = pa - ro;\n    float a = dot", "\n\tvec3 n = normalize( a - b );\n\tvec3 p = normalize( pos - b );\n\tvec3 q = normalize( pos - a );\n\tvec3 rp = cross( p, q );\n\tvec3 rq = cross( q, r );\n\tvec3 rn = cross( n, r );\n\tvec3 rp2 = cross( rp, rn );\n\tvec3 rq2 = cross( rq, rn );\n\tvec3 rp2q = cross( rp2, rq );\n\tvec3 rp2q2 = cross( rp2q, rn );\n\tvec3 rp2q2n = cross( rp2q2, n );\n\tvec3 rp2q2n2 = cross( rp2q2n, n );\n\tvec3 rp2q2n23 = cross( rp2q2n2, n );\n\tvec3 rp2q2n23p = cross( rp2q2n23, p );\n\tvec3 rp2q2n23pq = cross( rp2q2n23p, q );\n\tvec3 rp2q2n23pqn = cross( rp2q2n23pq, n );\n\tvec3 rp2q2n23pqn2 = cross( rp2q2n23pqn, n );\n\tvec3 rp2q2n23pqn2p = cross( rp2q2n23pqn2, p );\n\tvec3 rp2q2n23pqn2pq = cross( rp2q2n23pqn2p, q );\n\tvec3 rp2q2n23pqn2pqn = cross( rp2q2n23pqn2pq, n );\n\tvec3 rp2q2n23pqn2pqn2 = cross( rp2q2n23pqn2pqn, n );\n\tvec3 rp2q2n23pqn2pqn2p = cross( rp2q2n23pqn2pqn2, p );\n\tvec3 r", "\n    vec3 box = ro + rd * 0.5;\n    vec3 dir = rd * 2.0;\n    vec3 min = -rad;\n    vec3 max = rad;\n    vec3 invdir = 1.0 / dir;\n    vec3 tmin = max;\n    vec3 tmax = min;\n    vec3 invdir0 = invdir;\n    vec3 invdir1 = invdir;\n    vec3 invdir2 = invdir;\n    vec3 invdir3 = invdir;\n    vec3 invdir4 = invdir;\n    vec3 invdir5 = invdir;\n    vec3 invdir6 = invdir;\n    vec3 invdir7 = invdir;\n    vec3 invdir8 = invdir;\n    vec3 invdir9 = invdir;\n    vec3 invdir10 = invdir;\n    vec3 invdir11 = invdir;\n    vec3 invdir12 = invdir;\n    vec3 invdir13 = invdir;\n    vec3 invdir14 = invdir;\n    vec3 invdir15 = invdir;\n    vec3 invdir16 = invdir;\n    vec3 invdir17 = invdir;\n    vec3 invdir18 = invdir;\n    vec3 invdir19 = invdir;\n    vec3 invdir20 = invdir;\n    vec3 invdir21 = invdir;\n    vec3 invdir22 = invdir;\n    vec3 invdir23 = invdir;\n    vec3 invdir24 = invdir;\n    vec3 invdir25 = invdir;\n    vec3 invdir26 = invdir;\n    vec3 invdir27 = invdir;\n    vec3 invdir28 = invdir;\n    vec3 invdir29 = invdir;\n    vec3 invdir30 = invdir;\n    vec3 invdir31 = invdir;\n    vec3 invdir32 = invdir;\n    vec3 invdir33 = invdir;\n    vec3 invdir34 = invdir;\n    vec3 invdir35 = invdir;\n    vec3 invdir36 = invdir", "\n    vec3 p = ro;\n    float t = 0.0;\n    float tmin = 100000.0;\n    float tmax = 100000.0;\n    vec3 n = vec3(0.0);\n    vec3 c = vec3(0.0);\n    vec3 c1 = vec3(0.0);\n    vec3 c2 = vec3(0.0);\n    vec3 c3 = vec3(0.0);\n    vec3 c4 = vec3(0.0);\n    vec3 c5 = vec3(0.0);\n    vec3 c6 = vec3(0.0);\n    vec3 c7 = vec3(0.0);\n    vec3 c8 = vec3(0.0);\n    vec3 c9 = vec3(0.0);\n    vec3 c10 = vec3(0.0);\n    vec3 c11 = vec3(0.0);\n    vec3 c12 = vec3(0.0);\n    vec3 c13 = vec3(0.0);\n    vec3 c14 = vec3(0.0);\n    vec3 c15 = vec3(0.0);\n    vec3 c16 = vec3(0.0);\n    vec3 c17 = vec3(0.0);\n    vec3 c18 = vec3(0.0);\n    vec3 c19 = vec3(0.0);\n    vec3 c20 = vec3(0.0);\n    vec3 c21 = vec3(0.0);\n    vec3 c22 = vec3(0.0);\n    vec3 c23 = vec3(0.0);\n    vec3 c24 = vec3(0.0);\n    vec3 c25 = vec3(0.0);\n    vec3 c26 = vec3(0.0);\n    vec3 c27 = vec3(0.0);\n    vec3 c28 = vec3(0.0);\n    vec3 c29 = vec3(0.0);\n    vec3 c30 = vec3", "\n    float a = 1.0/n;\n    float b = 1.0/n;\n    float c = 1.0/n;\n    float d = 1.0/n;\n    float e = 1.0/n;\n    float f = 1.0/n;\n    float g = 1.0/n;\n    float h = 1.0/n;\n    float i1 = 1.0/n;\n    float i2 = 1.0/n;\n    float i3 = 1.0/n;\n    float i4 = 1.0/n;\n    float i5 = 1.0/n;\n    float i6 = 1.0/n;\n    float i7 = 1.0/n;\n    float i8 = 1.0/n;\n    float i9 = 1.0/n;\n    float i10 = 1.0/n;\n    float i11 = 1.0/n;\n    float i12 = 1.0/n;\n    float i13 = 1.0/n;\n    float i14 = 1.0/n;\n    float i15 = 1.0/n;\n    float i16 = 1.0/n;\n    float i17 = 1.0/n;\n    float i18 = 1.0/n;\n    float i19 = 1.0/n;\n    float i20 = 1.0/n;\n    float i21 = 1.0/n;\n    float i22 = 1.0/n;\n    float i23 = 1.0/n;\n    float i24 = 1.0/n;\n    float i25 = 1.0/n;\n    float i26 = 1.0/n;\n    float i27 = 1.0/n;\n    float i28 = 1.0/n;\n    float i29 = 1.0/n;\n    float i30 = 1.0/n;\n    float i3", "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 n = vec3(0.0);\n    float t = 0.0;\n    float tmin = 100000.0;\n    float tmax = -100000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37", "\n    vec3 n = vec3(p.x, p.y, p.x*p.x - p.y*p.y);\n    return n;\n}\n\nvec3 noise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(\n        mix(\n            mix(\n                noised(i),\n                noised(i + vec2(0.0, 1.0)),\n                u.x\n            ),\n            mix(\n                noised(i + vec2(1.0, 0.0)),\n                noised(i + vec2(1.0, 1.0)),\n                u.x\n            ),\n            u.y\n        ),\n        mix(\n            mix(\n                noised(i + vec2(0.0, 0.0)),\n                noised(i + vec2(1.0, 0.0)),\n                u.x\n            ),\n            mix(\n                noised(i + vec2(0.0, 1.0)),\n                noised(i + vec2(1.0, 1.0)),\n                u.x\n            ),\n            u.y\n        ),\n        u.z\n    );\n}\n\nvec3 perlin( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(\n        mix(\n            mix(\n                noise(i),\n                noise(i + vec2(0.0, 1.0)),\n                u.x\n            ),\n            mix(\n                noise(i + vec2(1.0, 0.0)),\n                noise(i + vec2(1.0, 1.0)),\n                u.x\n            ),\n", "\n    vec2 d = abs(p) - size;\n    return length(d) - radius;\n}\n\nfloat sphereDist(vec2 p, vec2 center, float radius)\n{\n    vec2 d = p - center;\n    return length(d) - radius;\n}\n\nfloat circleDist(vec2 p, vec2 center, float radius)\n{\n    vec2 d = p - center;\n    return length(d) - radius;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, float radius)\n{\n    vec2 d = p - center;\n    return length(d) - radius;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, float radius, float thickness)\n{\n    vec2 d = p - center;\n    return length(d) - radius - thickness;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, vec2 radius, float thickness)\n{\n    vec2 d = p - center;\n    return length(d) - radius.x - thickness.x;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, vec2 radius, vec2 thickness)\n{\n    vec2 d = p - center;\n    return length(d) - radius.x - thickness.x;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, vec2 radius, vec2 thickness, float thickness2)\n{\n    vec2 d = p - center;\n    return length(d) - radius.x - thickness.x - thickness2;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, vec2 radius, vec2 thickness, vec2 thickness2)\n{\n    vec2 d = p - center;\n    return length(d) - radius.x - thickness.x - thickness2;\n}\n\nfloat circleDist(vec2 p, vec2 center, vec2 size, vec2 radius, vec2 thickness, vec2 thickness2, float thickness3)\n{\n    vec2 d = p - center;\n    return length(d) - radius.x - thickness.x - thickness2 - thickness3;\n}\n", "\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 8\nvec3 pat8(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float d = dot(p, orient);\n    return vec3(p, d);\n}\n\n// Pattern 9\nvec3 pat9(vec2 u", "\n    vec2 uv2 = uv;\n    uv2.y = -uv2.y;\n    vec2 uv3 = uv2;\n    uv3.x = -uv3.x;\n    vec2 uv4 = uv3;\n    uv4.y = -uv4.y;\n    vec2 uv5 = uv4;\n    uv5.x = -uv5.x;\n    vec2 uv6 = uv5;\n    uv6.y = -uv6.y;\n    vec2 uv7 = uv6;\n    uv7.x = -uv7.x;\n    vec2 uv8 = uv7;\n    uv8.y = -uv8.y;\n    vec2 uv9 = uv8;\n    uv9.x = -uv9.x;\n    vec2 uv10 = uv9;\n    uv10.y = -uv10.y;\n    vec2 uv11 = uv10;\n    uv11.x = -uv11.x;\n    vec2 uv12 = uv11;\n    uv12.y = -uv12.y;\n    vec2 uv13 = uv12;\n    uv13.x = -uv13.x;\n    vec2 uv14 = uv13;\n    uv14.y = -uv14.y;\n    vec2 uv15 = uv14;\n    uv15.x = -uv15.x;\n    vec2 uv16 = uv15;\n    uv16.y = -uv16.y;\n    vec2 uv17 = uv16;\n    uv17.x = -uv17.x;\n    vec2 uv18 = uv17;\n    uv18.y = -uv18.y;\n    vec2 uv19 = uv18;\n    uv19.x = -uv19.x;\n    vec2 uv20 = uv19;\n    uv20.y = -uv", "\n    float g = 0.0;\n    float dx = ddx.x * ddx.x;\n    float dy = ddy.y * ddy.y;\n    float d = dx + dy;\n    float r = dx / d;\n    float gx = ddx.x * ddy.x;\n    float gy = ddx.y * ddy.y;\n    float gxy = ddx.x * ddy.y;\n    float gx2 = ddx.x * ddx.x;\n    float gy2 = ddy.y * ddy.y;\n    float gxy2 = ddx.x * ddy.y;\n    float gxy3 = ddx.x * ddy.y * ddx.y;\n    float gxy4 = ddx.x * ddy.y * ddx.y * ddy.y;\n    float gxy5 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y;\n    float gxy6 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y * ddy.y;\n    float gxy7 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y * ddy.y * ddx.y;\n    float gxy8 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y * ddy.y * ddx.y * ddx.y;\n    float gxy9 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y * ddy.y * ddx.y * ddx.y * ddx.y;\n    float gxy10 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y * ddy.y * ddx.y * ddx.y * ddx.y * ddx.y;\n    float gxy11 = ddx.x * ddy.y * ddx.y * ddy.y * ddx.y * ddy.y * ddx", "\n    return 0.5*vec3(\n        dFdx( p.x ),\n        dFdx( p.y ),\n        dFdx( p.z )\n    );\n}\n\n// map function\nvec3 map( in vec3 p )\n{\n    return p;\n}\n\n// noise function\nfloat noise( in vec3 p )\n{\n    vec3 ip = floor( p );\n    vec3 fp = fract( p );\n\n    // use 2D noise\n    vec3 u = fp*fp*fp*(3.0-2.0*fp);\n    vec3 v = fp*fp*(6.0-10.0*fp);\n\n    // interpolate between points\n    vec3 a = map( ip + u );\n    vec3 b = map( ip + v );\n    vec3 c = map( ip + 1.0 + u );\n    vec3 d = map( ip + 1.0 + v );\n\n    // interpolate between corners\n    return mix( a, b, fp.z ) +\n           mix( c, d, fp.z );\n}\n\n// simplex noise function\nfloat simplexNoise( in vec3 p )\n{\n    vec3 p0 = floor( p );\n    vec3 p1 = p0 + vec3( 1.0 );\n    p0 = p - p0;\n    p1 = p1 - p1;\n\n    vec3 x0 = p0.xzx;\n    vec3 x1 = p1.xzx;\n    vec3 y0 = p0.yyz;\n    vec3 y1 = p1.yyz;\n\n    vec4 w = max( vec4( 0.0 ), -p0.www );\n    vec4 w0 = max( vec4( 0.0 ), w );\n    vec4 w1 = max( vec4( 0.0 ), 1.0 - w );\n\n    vec3 x = x0.xxy + x1.xxy;\n    vec3 y = y0.xyw + y1.xyw;\n\n    vec3 s = ( x.z * y.z", "\n\ta.x = b.y;\n\ta.y = b.z;\n\ta.z = b.x;\n}\n\n//this function is used to rotate a vector by a given angle\nvoid rotate(inout v33 a,inout v33 b,inout v33 c,inout v33 d,inout v33 e,inout v33 f,inout v33 g,inout v33 h,inout v33 i,inout v33 j,inout v33 k,inout v33 l,inout v33 m,inout v33 n,inout v33 o,inout v33 p,inout v33 q,inout v33 r,inout v33 s,inout v33 t,inout v33 u,inout v33 v,inout v33 w,inout v33 x,inout v33 y,inout v33 z,inout v33 aa,inout v33 bb,inout v33 cc,inout v33 dd,inout v33 ee,inout v33 ff,inout v33 gg,inout v33 hh,inout v33 ii,inout v33 jj,inout v33 kk,inout v33 ll,inout v33 mm,inout v33 nn,inout v33 oo,inout v33 pp,inout v33 qq,inout v33 rr,inout v33 ss,inout v33 tt,inout v33 uu,inout v33 vv,inout v33 ww,inout v33 xx,inout v33 yy,inout v33 zz,inout v33 aaa,inout v33 bbb,inout v33 ccc,inout v33 ddd,inout v33 eee,inout v33 fff,inout v33 ggg,inout v33 hhh,inout v33 iii,inout v33 jjj,inout", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\nv33 mul(v33 a,float b){\n\treturn v33(a.x*b,a.y*b,a.z*b);\n}\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 div(v33 a,float b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\nv33 div(v33 a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\nv33 min(v33 a,v33 b){\n\treturn v33(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z));\n}\nv33 max(v33 a,v33 b){\n\treturn v33(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z));\n}\nv33 clamp(v33 a,v33 min,v33 max){\n\treturn v33(clamp(a.x,min.x,max.x),clamp(a.y,min.y,max.y),clamp(a.z,min.z,max.z));\n}\nv33 abs(v33 a){\n\treturn v33(abs(a.x),abs(a.y),abs(a.z));\n}\nv33 floor(v33 a){\n\treturn v33(floor(a.x),floor(a.y),floor(a.z));\n}\nv33 ceil(v33 a){\n\treturn v33(ceil(a.x),ceil(", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//substract a from b\nv33 sub(v33 a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//add a to b\nv33 add(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//add a to b\nv33 addc(v33 a,v33 b){", "\n\treturn (b-a)/2.0;\n}\n\n//v33-differentials for BB\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/3.0;\n}\n\n//v33-differentials for CC\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/5.0;\n}\n\n//v33-differentials for DD\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/7.0;\n}\n\n//v33-differentials for EE\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/9.0;\n}\n\n//v33-differentials for FF\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/11.0;\n}\n\n//v33-differentials for GG\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/13.0;\n}\n\n//v33-differentials for HH\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/15.0;\n}\n\n//v33-differentials for II\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/17.0;\n}\n\n//v33-differentials for JJ\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/19.0;\n}\n\n//v33-differentials for KK\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/21.0;\n}\n\n//v33-differentials for LL\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/23.0;\n}\n\n//v33-differentials for MM\nvec2 dt(v33 a,v33 b){\n\treturn (b-a)/25.0;\n}\n\n//v33-different", "return a.x*b.x+a.y*b.y+a.z*b.z;}\n\n//dotprodiuct on v33s\nvec3 dp(v33 a,vec3 b){return a.x*b.x+a.y*b.y+a.z*b.z;}\n\n//cross product on v33s\nvec3 cp(v33 a,vec3 b){return vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}\n\n//cross product on v33s\nvec3 cp(v33 a,vec3 b){return vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}\n\n//cross product on v33s\nvec3 cp(v33 a,vec3 b){return vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}\n\n//cross product on v33s\nvec3 cp(v33 a,vec3 b){return vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}\n\n//cross product on v33s\nvec3 cp(v33 a,vec3 b){return vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}\n\n//cross product on v33s\nvec3 cp(v33 a,vec3 b){return vec3(a.y*b.z-a.z*b.y,a.z*b", "\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec3 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec4 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,v34 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,v35 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,v36 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,v37 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w*b.w);\n}\n\n//dual mult\nv33 mul(v33 a,v38 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z,a.w", "\n\tvec3 q=p+w;\n\tvec3 r=p-w;\n\tvec3 s=p+w*0.5;\n\tvec3 t=p-w*0.5;\n\tfloat a=length(q-s);\n\tfloat b=length(r-t);\n\treturn min(a,b);\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF3(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\tvec3 r=p-w;\n\tvec3 s=p+w*0.5;\n\tvec3 t=p-w*0.5;\n\tfloat a=length(q-s);\n\tfloat b=length(r-t);\n\tfloat c=length(q-t);\n\treturn min(a,min(b,c));\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\tvec3 r=p-w;\n\tvec3 s=p+w*0.5;\n\tvec3 t=p-w*0.5;\n\tfloat a=length(q-s);\n\tfloat b=length(r-t);\n\tfloat c=length(q-t);\n\tfloat d=length(r-s);\n\treturn min(a,min(b,min(c,d)));\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF5(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\tvec3 r=p-w;\n\tvec3 s=p+w*0.5;\n\tvec3 t=p-w*0.5;\n\tfloat a=length(q-s);\n\tfloat b=length(r-t);\n\tfloat c=length(q-t);\n\tfloat d=length(r-s);\n\tfloat e=length(q-r);", "\n\tvec3 q=p+vec3(0.0,0.0,1.0);\n\tvec3 r=p+vec3(0.0,1.0,0.0);\n\tvec3 s=p+vec3(1.0,0.0,0.0);\n\tvec3 t=p+vec3(0.0,1.0,1.0);\n\tvec3 u=p+vec3(1.0,0.0,1.0);\n\tvec3 v=p+vec3(1.0,1.0,0.0);\n\tvec3 ww=w*0.5;\n\tvec3 a=max(abs(q-p)-ww,vec3(0.0));\n\tvec3 b=max(abs(r-p)-ww,vec3(0.0));\n\tvec3 c=max(abs(s-p)-ww,vec3(0.0));\n\tvec3 d=max(abs(t-p)-ww,vec3(0.0));\n\tvec3 e=max(abs(u-p)-ww,vec3(0.0));\n\tvec3 f=max(abs(v-p)-ww,vec3(0.0));\n\tvec3 g=max(abs(q-r)-ww,vec3(0.0));\n\tvec3 h=max(abs(s-r)-ww,vec3(0.0));\n\tvec3 i=max(abs(t-r)-ww,vec3(0.0));\n\tvec3 j=max(abs(u-r)-ww,vec3(0.0));\n\tvec3 k=max(abs(v-r)-ww,vec3(0.0));\n\tvec3 l=max(abs(q-s)-ww,vec3(0.0));\n\tvec3 m=max(abs(r-s)-ww,vec3(0.0));\n\tvec3 n=max(abs(t-s)-ww,vec3(0.0));\n\tvec3 o=max(abs(u-s)-ww,vec3(0.0));\n\tvec3 p=max(abs(v-s)-ww,", "\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow of(ray,sphere)\nfloat ssp(v33 r,vec4 s){\n\treturn dot(r,s.xyz);\n}\n\n//sphere shadow", "\n\tfloat d = dot(u,n);\n\tfloat r = s.w;\n\treturn 1.0-smoothstep(r,r+0.001,d);\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n);\n\tfloat r = s.w;\n\treturn 1.0-smoothstep(r,r+0.001,d);\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n);\n\tfloat r = s.w;\n\tfloat h = s.z;\n\tfloat r2 = r*r;\n\tfloat h2 = h*h;\n\tfloat d2 = d*d;\n\tfloat r2h2 = r2-h2;\n\tfloat d2h2 = d2-h2;\n\tfloat d2r2 = d2-r2;\n\tfloat d2r2h2 = d2r2-h2;\n\tfloat d2r2h2_ = d2r2h2*d2r2h2;\n\tfloat d2r2h2_2 = d2r2h2_*d2r2h2;\n\tfloat d2r2h2_3 = d2r2h2_*d2r2h2*d2r2h2;\n\tfloat d2r2h2_4 = d2r2h2_*d2r2h2*d2r2h2*d2r2h2;\n\tfloat d2r2h2_5 = d2r2h2_*d2r2h2*d2r2h2*d2r2h2*d2r2h2;\n\tfloat d2r2h2_6 = d2r2h2_*d2r2h2*d2r2h2*d2r2h2*d2r2h2*d2r2h2;\n\tfloat d2r2h2_7 = d2r2h2_*d2r2h2*d2r2", "\n    vec2 p0p1 = p0 - p1;\n    vec2 p1p2 = p1 - p2;\n    vec2 p0p2 = p0 - p2;\n\n    vec2 p0p1p2 = p0p1 + p1p2;\n    vec2 p0p2p1 = p0p2 + p1p1;\n\n    vec2 p0p1p2p1 = p0p1p2 + p1p2p1;\n    vec2 p0p2p1p2 = p0p2p1 + p1p2p2;\n\n    vec2 p0p1p2p1p2 = p0p1p2p1 + p1p2p2p1;\n\n    vec2 p0p1p2p1p2p1 = p0p1p2p1p2 + p1p2p2p1p2;\n\n    vec2 p0p1p2p1p2p1p2 = p0p1p2p1p2p1 + p1p2p2p1p2p1;\n\n    vec2 p0p1p2p1p2p1p2p1 = p0p1p2p1p2p1p2 + p1p2p2p1p2p1p2;\n\n    vec2 p0p1p2p1p2p1p2p1p1 = p0p1p2p1p2p1p2p1 + p1p2p2p1p2p1p2p1;\n\n    vec2 p0p1p2p1p2p1p2p1p1p1 = p0p1p2p1p2p1p2p1p1 + p1p2p2p1p2p1p2p1p1;\n\n    vec2 p0p1p2p1p2p1p2p1p1p1p1 = p0p1p2p1p2p1p2p1p1p1 + p1p2p2p1p2p1p2p1p1p1;\n\n    vec2", "\n    vec2 p0p1 = p0 - p1;\n    vec2 p1p2 = p1 - p2;\n    vec2 p0p2 = p0 - p2;\n\n    vec2 p0p1p2 = p0p1 + p1p2;\n    vec2 p0p2p1 = p0p2 + p1p1;\n\n    vec2 p0p1p2p1 = p0p1p2 + p0p2p1;\n\n    vec2 p0p1p2p1p0 = p0p1p2p1 + p0;\n\n    vec2 p0p1p2p1p0p1 = p0p1p2p1p0 + p1;\n\n    vec2 p0p1p2p1p0p1p2 = p0p1p2p1p0p1 + p2;\n\n    vec2 p0p1p2p1p0p1p2p0 = p0p1p2p1p0p1p2 + p0;\n\n    vec2 p0p1p2p1p0p1p2p0p1 = p0p1p2p1p0p1p2p0 + p1;\n\n    vec2 p0p1p2p1p0p1p2p0p1p2 = p0p1p2p1p0p1p2p0p1 + p2;\n\n    vec2 p0p1p2p1p0p1p2p0p1p2p0 = p0p1p2p1p0p1p2p0p1p2 + p0;\n\n    vec2 p0p1p2p1p0p1p2p0p1p2p0p1 = p0p1p2p1p0p1p2p0p1p2p0 + p1;\n\n    vec2 p0p1p2p1p0p1p2p0p1p2p0p1p2 = p0p1p2p1p0p1p2p0p1p2p0p1 + p2;", "\n\tvec3 p01 = p1 - p0;\n\tvec3 p02 = p2 - p0;\n\tvec3 p12 = p2 - p1;\n\tvec3 p03 = p3 - p0;\n\tvec3 p13 = p3 - p1;\n\tvec3 p23 = p3 - p2;\n\n\tvec3 p012 = p01 + p02;\n\tvec3 p0123 = p012 + p03;\n\tvec3 p01234 = p0123 + p13;\n\tvec3 p012345 = p01234 + p23;\n\n\tvec3 p0123456 = p012345 + p03;\n\n\tvec3 p01234567 = p0123456 + p13;\n\n\tvec3 p012345678 = p01234567 + p23;\n\n\tvec3 p0123456789 = p012345678 + p3;\n\n\tvec3 p01234567890 = p0123456789 + p03;\n\n\tvec3 p012345678901 = p01234567890 + p13;\n\n\tvec3 p0123456789012 = p012345678901 + p23;\n\n\tvec3 p01234567890123 = p0123456789012 + p3;\n\n\tvec3 p012345678901234 = p01234567890123 + p03;\n\n\tvec3 p0123456789012345 = p012345678901234 + p13", "\n    vec2 p0p1 = p0 - p1;\n    vec2 p1p2 = p1 - p2;\n    vec2 p2p3 = p2 - p3;\n    vec2 p0p2 = p0 - p2;\n    vec2 p1p3 = p1 - p3;\n\n    vec2 p0p1p2 = p0p1 + p1p2;\n    vec2 p1p2p3 = p1p2 + p2p3;\n    vec2 p0p2p3 = p0p2 + p2p3;\n    vec2 p0p1p3 = p0p1 + p1p3;\n\n    vec2 p0p1p2p3 = p0p1p2 + p1p2p3;\n    vec2 p0p2p3p3 = p0p2p3 + p2p3p3;\n    vec2 p0p1p3p3 = p0p1p3 + p1p3p3;\n\n    vec2 p0p1p2p3p3 = p0p1p2p3 + p1p2p3p3;\n    vec2 p0p2p3p3p3 = p0p2p3p3 + p2p3p3p3;\n    vec2 p0p1p3p3p3 = p0p1p3p3 + p1p3p3p3;\n\n    vec2 p0p1p2p3p3p3 = p0p1p2p3p3 + p1p2p3p3p3;\n    vec2 p0p2p3p3p3p3 = p0p2p3p3p3 + p2p3p3p3p3;\n    vec2 p0p1p3p3p3p3 = p0p1p3p3p3 + p1p3p3p3p3;\n\n    vec2 p0p1p2p3p3p3p3 = p0p1p2p3p3p3 + p1p2p3p3p3p3;\n    vec2 p0", "\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p12 = mix(p1, p2, pos.x);\n    vec2 p23 = mix(p2, p3, pos.x);\n    vec2 p012 = mix(p01, p12, pos.y);\n    vec2 p123 = mix(p12, p23, pos.y);\n    return mix(p012, p123, pos.x);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p12 = mix(p1, p2, pos.x);\n    vec2 p23 = mix(p2, p3, pos.x);\n    vec2 p012 = mix(p01, p12, pos.y);\n    vec2 p123 = mix(p12, p23, pos.y);\n    return mix(p012, p123, pos.x);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p12 = mix(p1, p2, pos.x);\n    vec2 p23 = mix(p2, p3, pos.x);\n    vec2 p012 = mix(p01, p12, pos.y);\n    vec2 p123 = mix(p12, p23, pos.y);\n    return mix(p012, p123, pos.x);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p1", "\n    vec3 e0 = v0 - ro;\n    vec3 e1 = v1 - ro;\n    vec3 e2 = v2 - ro;\n\n    vec3 p = cross( e1, e2 );\n    vec3 q = cross( e2, e0 );\n\n    float det = dot( p, rd );\n\n    if ( det > 0.0 )\n    {\n        return vec3( 0.0 );\n    }\n\n    float invDet = 1.0 / det;\n\n    vec3 tvec = cross( rd, e2 );\n    vec3 u = cross( p, tvec ) * invDet;\n\n    tvec = cross( e1, tvec );\n    vec3 v = cross( p, tvec ) * invDet;\n\n    float t = dot( q, tvec ) * invDet;\n\n    return vec3( t, u, v );\n}\n\n// Triangle normal.\nvec3 triNormal( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    return normalize( cross( v1 - v0, v2 - v0 ) );\n}\n\n// Triangle barycentric coordinates.\nvec3 triBarycentric( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e0 = v0 - ro;\n    vec3 e1 = v1 - ro;\n    vec3 e2 = v2 - ro;\n\n    vec3 p = cross( e1, e2 );\n    vec3 q = cross( e2, e0 );\n\n    float det = dot( p, rd );\n\n    if ( det > 0.0 )\n    {\n        return vec3( 0.0 );\n    }\n\n    float invDet = 1.0 / det;\n\n    vec3 tvec = cross( rd, e2 );\n    vec3 u = cross( p, tvec ) * invDet;\n\n    tvec = cross( e1, tvec );\n    vec3 v = cross( p, tvec ) * invDet;\n\n    float t = dot( q", "\n    vec3 n0 = normalize( v0 - pos );\n    vec3 n1 = normalize( v1 - pos );\n    vec3 n2 = normalize( v2 - pos );\n\n    float d0 = dot( n0, nor );\n    float d1 = dot( n1, nor );\n    float d2 = dot( n2, nor );\n\n    float d = max( d0, max( d1, d2 ) );\n\n    return d;\n}\n\n// Triangle occlusion (if partially visible)\nfloat triOcclusionPartial( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 n0 = normalize( v0 - pos );\n    vec3 n1 = normalize( v1 - pos );\n    vec3 n2 = normalize( v2 - pos );\n\n    float d0 = dot( n0, nor );\n    float d1 = dot( n1, nor );\n    float d2 = dot( n2, nor );\n\n    float d = max( d0, max( d1, d2 ) );\n\n    return d;\n}\n\n// Triangle occlusion (if partially visible)\nfloat triOcclusionPartial( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 n0 = normalize( v0 - pos );\n    vec3 n1 = normalize( v1 - pos );\n    vec3 n2 = normalize( v2 - pos );\n    vec3 n3 = normalize( v3 - pos );\n\n    float d0 = dot( n0, nor );\n    float d1 = dot( n1, nor );\n    float d2 = dot( n2, nor );\n    float d3 = dot( n3, nor );\n\n    float d = max( d0, max( d1, max( d2, d3 ) ) );\n\n    return d;\n}\n\n// Triangle occlusion (if partially visible)\nfloat triOcclusionPartial( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in", "\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    vec2 BC = C - B;\n\n    vec2 v = pos - A;\n\n    float a = dot( AB, AB );\n    float b = dot( AB, AC );\n    float c = dot( AC, AC );\n    float d = dot( AB, BC );\n    float e = dot( AC, BC );\n\n    float three_a = 3.0 * a;\n    float three_b = 3.0 * b;\n    float three_c = 3.0 * c;\n    float three_d = 3.0 * d;\n    float three_e = 3.0 * e;\n\n    float three_a_b = three_a + three_b;\n    float three_c_e = three_c + three_e;\n\n    float a_b_c = a + b + c;\n    float a_b_c_d = a_b_c + d;\n    float a_b_c_d_e = a_b_c_d + e;\n\n    float t = clamp( ( three_a_b * v.y - three_c_e * v.x ) / ( three_a_b * e - three_c_e * d ), 0.0, 1.0 );\n\n    float s = ( three_a * t * t + three_b * t + three_c ) / a_b_c_d_e;\n\n    return s;\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    vec2 BC = C - B;\n\n    vec2 v = pos - A;\n\n    float a = dot( AB, AB );\n    float b = dot( AB, AC );\n    float c = dot( AC, AC );\n    float d = dot( AB, BC );\n    float e = dot( AC, BC );\n\n    float three_a = 3.0 *", "\n    float h = length( p );\n    float d = max( 0.0, he - h );\n    float s = clamp( d / he, 0.0, 1.0 );\n    float r = mix( r1, r2, s );\n    return r * r * ( h - he );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float h = length( p );\n    float d = max( 0.0, he - h );\n    float s = clamp( d / he, 0.0, 1.0 );\n    float r = mix( r1, r2, s );\n    return r * r * ( h - he );\n}\n\n// trapezoid / capped cone, specialized for Z alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float h = length( p );\n    float d = max( 0.0, he - h );\n    float s = clamp( d / he, 0.0, 1.0 );\n    float r = mix( r1, r2, s );\n    return r * r * ( h - he );\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, in vec3 he )\n{\n    float h = length( p );\n    float d = max( 0.0, he.y - h );\n    float s = clamp( d / he.y, 0.0, 1.0 );\n    float r = mix( r1, r2, s );\n    return r * r * ( h - he.y );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, in vec3 he )\n{\n    float h = length( p );\n    float d = max( 0.0, he.x - h );\n    float s = clamp(", "\n    vec2 pa = (a-p);\n    vec2 pb = (b-p);\n    float d = length(pa) + length(pb);\n    float h = clamp(dot(pa,pb)/(length(a)-length(b)),0.0,1.0);\n    float r = ra + (rb-ra)*h;\n    return r-d;\n}\n\n// trapezoid / capped cylinder\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb )\n{\n    vec2 pa = (a-p);\n    vec2 pb = (b-p);\n    float d = length(pa) + length(pb);\n    float h = clamp(dot(pa,pb)/(length(a)-length(b)),0.0,1.0);\n    float r = ra + (rb-ra)*h;\n    return r-d;\n}\n\n// trapezoid / capped cylinder\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb )\n{\n    vec2 pa = (a-p);\n    vec2 pb = (b-p);\n    float d = length(pa) + length(pb);\n    float h = clamp(dot(pa,pb)/(length(a)-length(b)),0.0,1.0);\n    float r = ra + (rb-ra)*h;\n    return r-d;\n}\n\n// trapezoid / capped cylinder\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb )\n{\n    vec2 pa = (a-p);\n    vec2 pb = (b-p);\n    float d = length(pa) + length(pb);\n    float h = clamp(dot(pa,pb)/(length(a)-length(b)),0.0,1.0);\n    float r = ra + (rb-ra)*h;\n    return r-d;\n}\n\n// trapezoid / capped cylinder\nfloat sdTrapezoid( in vec", "\n    vec3 n = dFdx( pos ) + dFdy( pos );\n    return normalize( n );\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2 )\n{\n    vec3 n = normalize( cross( pos2 - pos1, pos - pos1 ) );\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2, in vec3 pos3 )\n{\n    vec3 n = normalize( cross( pos3 - pos2, pos2 - pos1 ) );\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2, in vec3 pos3, in vec3 pos4 )\n{\n    vec3 n = normalize( cross( pos4 - pos3, pos3 - pos2 ) );\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2, in vec3 pos3, in vec3 pos4, in vec3 pos5 )\n{\n    vec3 n = normalize( cross( pos5 - pos4, pos4 - pos3 ) );\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2, in vec3 pos3, in vec3 pos4, in vec3 pos5, in vec3 pos6 )\n{\n    vec3 n = normalize( cross( pos6 - pos5, pos5 - pos4 ) );\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2, in vec3 pos3, in vec3 pos4, in vec3 pos5, in vec3 pos6, in vec3 pos7 )\n{\n    vec3 n = normalize( cross( pos7 - pos6, pos6 - pos5 ) );\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 pos1, in vec3 pos2, in vec3 pos3, in vec3 pos4, in vec3 pos5, in vec3 pos6, in vec3 pos7, in vec3 pos8", "\n    float d = 1.0;\n    float t = tmin;\n    float tau = 0.0;\n    float dtau = 0.0;\n    float dtau2 = 0.0;\n    float dtau3 = 0.0;\n    float dtau4 = 0.0;\n    float dtau5 = 0.0;\n    float dtau6 = 0.0;\n    float dtau7 = 0.0;\n    float dtau8 = 0.0;\n    float dtau9 = 0.0;\n    float dtau10 = 0.0;\n    float dtau11 = 0.0;\n    float dtau12 = 0.0;\n    float dtau13 = 0.0;\n    float dtau14 = 0.0;\n    float dtau15 = 0.0;\n    float dtau16 = 0.0;\n    float dtau17 = 0.0;\n    float dtau18 = 0.0;\n    float dtau19 = 0.0;\n    float dtau20 = 0.0;\n    float dtau21 = 0.0;\n    float dtau22 = 0.0;\n    float dtau23 = 0.0;\n    float dtau24 = 0.0;\n    float dtau25 = 0.0;\n    float dtau26 = 0.0;\n    float dtau27 = 0.0;\n    float dtau28 = 0.0;\n    float dtau29 = 0.0;\n    float dtau30 = 0.0;\n    float dtau31 = 0.0;\n    float dtau32 = 0.0;\n    float dtau33 = 0.0;\n    float dtau34 = 0.0;\n    float dtau35 = 0.0;\n    float dtau36 = 0.0;\n    float dtau37 = 0.0;\n    float dtau38 = 0.0", "\n    return fract( dot( q, vec3( 12.9898, 78.233, 151.718 )) );\n}\n\n// returns a random number between 0 and 1\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 x0 = i.xy0;\n    vec2 x1 = i.xy1;\n    vec2 x2 = i.xy2;\n    vec2 x3 = i.xy3;\n    p = fract( p );\n    vec2 u = p * p * 3.0 - 2.0;\n    vec2 v = p * 3.0 - 2.0;\n    vec3 a = mix( vec3( x0.xy ), vec3( x1.xy ), u.x );\n    vec3 b = mix( vec3( x0.zw ), vec3( x1.zw ), u.x );\n    vec3 c = mix( a, b, u.y );\n    vec3 d = mix( a, b, u.z );\n    return mix( c, d, v.x ).x;\n}\n\n// returns a random number between 0 and 1\nfloat random( in vec2 p )\n{\n    return fract( sin( dot( p, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\n// returns a random number between 0 and 1\nfloat random( in vec3 p )\n{\n    return fract( sin( dot( p, vec3( 12.9898, 78.233, 151.718 ) ) ) * 43758.5453 );\n}\n\n// returns a random number between 0 and 1\nfloat random( in vec4 p )\n{\n    return fract( sin( dot( p, vec4( 12.9898, 78.233, 151.718, 54.453 ) ) ) * 437", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners\n    float a = dot(f, f);\n    float b = dot(f - 1.0, f - 1.0);\n    float c = dot(f - 2.0, f - 2.0);\n    float d = dot(f - 3.0, f - 3.0);\n\n    // Sum and scale the result\n    return mix(a, b, p.x) +\n           mix(c, d, p.x) +\n           p.y * (6.0 * a - 12.0 * b + 6.0 * c);\n}\n\n// Perlin noise\nfloat perlin( in vec2 x, in int p )\n{\n    vec3 p3 = floor(x);\n    vec3 f = fract(x);\n\n    // Four corners\n    float a = dot(f, f);\n    float b = dot(f - 1.0, f - 1.0);\n    float c = dot(f - 2.0, f - 2.0);\n    float d = dot(f - 3.0, f - 3.0);\n\n    // Wrap the integer coordinates (& their squared gradient)\n    p3 = mod(p3, 289.0);\n    p3 = (p3 * p3 * 31.0) * (p3 * p3 * p3 * 157.0);\n\n    // Gradients\n    float ga = dot(gradP[p % 12 + 0], vec3(p3.x, p3.y, f.x));\n    float gb = dot(gradP[p % 12 + 1], vec3(p3.x, p3.y, f.y));\n    float gc = dot(gradP[p % 12 + 2], vec3(p3.x, p3.z, f.z));\n    float gd = dot(gradP[p % 12 + 3], vec3(p3.y, p3.z, f.w", "\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( b * x );\n        x = x * 2.0;\n        a = a * 0.5;\n        b = b * 2.0;\n    }\n    return f;\n}\n\n// 3D noise\nfloat noise3d( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    f = f * f * ( 3.0 - 2.0 * f );\n    float n = p.x + p.y + p.z;\n    return mix(\n        mix(\n            mix(\n                fbm( p + vec3( 0.0, 0.0, 0.0 ), 8.0 ),\n                fbm( p + vec3( 1.0, 0.0, 0.0 ), 8.0 ),\n                f.x ),\n            mix(\n                fbm( p + vec3( 0.0, 1.0, 0.0 ), 8.0 ),\n                fbm( p + vec3( 0.0, 2.0, 0.0 ), 8.0 ),\n                f.x ),\n            n.x ) +\n        mix(\n            mix(\n                fbm( p + vec3( 0.0, 0.0, 0.0 ), 8.0 ),\n                fbm( p + vec3( 0.0, 0.0, 1.0 ), 8.0 ),\n                f.y ),\n            mix(\n                fbm( p + vec3( 0.0, 1.0, 1.0 ), 8.0 ),\n                fbm( p + vec3( 0.0, 2.0, 2.0 ), 8.0 ),\n                f.y ),\n            n.y ) +\n        ", "\n    return length( p ) - length( r );\n}\n\n// generic cylinder - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCylinder( in vec3 p, in vec3 r, in float h )\n{\n    return length( p.yzx - r.yzx ) - h;\n}\n\n// generic cone - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCone( in vec3 p, in vec3 r, in float h )\n{\n    return length( p.yzx - r.yzx ) - h;\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdTorus( in vec3 p, in vec2 r )\n{\n    return length( p.xz - r.xy ) - r.y;\n}\n\n// generic sphere - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length( p ) - r;\n}\n\n// generic plane - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdPlane( in vec3 p, in vec3 n )\n{\n    return dot( p, n );\n}\n\n// generic box - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    return length( max( abs( p ) - b, 0.0 ) );\n}\n\n// generic capsule - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCapsule( in vec3 p, in vec3 r, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 ba_pa = ba - pa;\n    vec3 ba_pa_ba = ba_pa - ba;\n    vec3 ba_pa_ba_pa = ba", "\n    vec3 q = p - vec3( 0.0, 0.0, 0.0 );\n    float a = r.x;\n    float b = r.y;\n    float c = r.z;\n    float A = a*a;\n    float B = b*b;\n    float C = c*c;\n    float D = A + B - 2.0*A*B;\n    float E = 4.0*A*C;\n    float F = A*C - B*C;\n    float G = sqrt( D*D - E*F );\n    float h = sqrt( ( D + G ) / ( 2.0*A ) );\n    float i = sqrt( ( D - G ) / ( 2.0*A ) );\n    float j = sqrt( ( E + F ) / ( 2.0*C ) );\n    float k = sqrt( ( E - F ) / ( 2.0*C ) );\n    float l = sqrt( ( D + G ) / ( 2.0*B ) );\n    float m = sqrt( ( D - G ) / ( 2.0*B ) );\n    float n = sqrt( ( E + F ) / ( 2.0*A*C ) );\n    float o = sqrt( ( E - F ) / ( 2.0*A*C ) );\n    float p = sqrt( ( D + G ) / ( 2.0*B*C ) );\n    float q = sqrt( ( D - G ) / ( 2.0*B*C ) );\n    float r = sqrt( ( E + F ) / ( 2.0*A*B ) );\n    float s = sqrt( ( E - F ) / ( 2.0*A*B ) );\n    float t = sqrt( ( D + G ) / ( 2.0*A*C*B ) );\n    float u = sqrt( ( D - G ) / ( 2.0*A*C*B ) );\n    float v = sqrt( ( E + F ) / ( 2.0*A*B*C ) );\n    float w = sqrt( ( E - F ) / ( 2.0", "\n    vec3 q = p - r;\n    float a = length( r.xy );\n    float b = length( r.zw );\n    float c = length( q );\n    float d = a*a + b*b - c*c;\n    return d;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Good( in vec3 p, in vec3 r ) \t// r = center, a = x, b = y, c = z\n{\n    vec3 q = p - r;\n    float a = length( r.xy );\n    float b = length( r.zw );\n    float c = length( q );\n    float d = a*a + b*b - c*c;\n    return d;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Good2( in vec3 p, in vec3 r ) \t// r = center, a = x, b = y, c = z\n{\n    vec3 q = p - r;\n    float a = length( r.xy );\n    float b = length( r.zw );\n    float c = length( q );\n    float d = a*a + b*b - c*c;\n    return d;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Good3( in vec3 p, in vec3 r ) \t// r = center, a = x, b = y, c = z\n{\n    vec3 q = p - r;\n    float a = length( r.xy );\n    float b = length( r.zw );\n    float c = length( q );\n    float d = a*a + b*b - c*c;\n    return d;\n}\n\n// generic ellipsoid - simple but good approximated distance\nfloat sdEllipsoid_Good4( in vec3 p, in vec3 r ) \t// r = center, a = x, b = y, c = z\n{\n    vec3 q = p - r;\n    float a = length( r.xy );\n    float b = length( r.zw );\n", "\n    vec3 q = p / r;\n    float a = dot( q, q );\n    float b = dot( q, q, q );\n    float c = dot( q, q, q, q );\n    float d = dot( q, q, q, q, q );\n    float e = dot( q, q, q, q, q, q );\n    float f = dot( q, q, q, q, q, q, q );\n    float g = dot( q, q, q, q, q, q, q, q );\n    float h = dot( q, q, q, q, q, q, q, q, q );\n    float i = dot( q, q, q, q, q, q, q, q, q, q );\n    float j = dot( q, q, q, q, q, q, q, q, q, q, q );\n    float k = dot( q, q, q, q, q, q, q, q, q, q, q, q );\n    float l = dot( q, q, q, q, q, q, q, q, q, q, q, q, q );\n    float m = dot( q, q, q, q, q, q, q, q, q, q, q, q, q, q );\n    float n = dot( q, q, q, q, q, q, q, q, q, q, q, q, q, q, q );\n    float o = dot( q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q );\n    float p = dot( q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q );\n    float q = dot( q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q );\n    float r = dot( q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q,", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCircle( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - distance( f, vec2( 0.5 ) );\n    return d;\n}\n\nfloat checkersGradSquare( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCross( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCross2( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCross3( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCross4( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCross5( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    float d = 1.0 - abs( f.x - f.y );\n    return d;\n}\n\nfloat checkersGradCross6( in vec2 p )\n{\n    vec2 i = floor", "\n  return 1.0 - exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias_inv( float a, float x )\n{\n  return exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias_inv_inv( float a, float x )\n{\n  return 1.0 - exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias_inv_inv_inv( float a, float x )\n{\n  return exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias_inv_inv_inv_inv( float a, float x )\n{\n  return 1.0 - exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias_inv_inv_inv_inv_inv( float a, float x )\n{\n  return exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias_inv_inv_inv_inv_inv_inv( float a, float x )\n{\n  return 1.0 - exp( -a * x );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz", "\n    return ( x - p ) * ( x + p );\n}\n\n// biased triangle\nfloat my_triangle( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased sawtooth\nfloat my_sawtooth( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased triangle\nfloat my_triangle( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased sawtooth\nfloat my_sawtooth( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased triangle\nfloat my_triangle( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased sawtooth\nfloat my_sawtooth( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased triangle\nfloat my_triangle( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased sawtooth\nfloat my_sawtooth( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased triangle\nfloat my_triangle( float x, float p )\n{\n    return ( x - p ) * ( x + p );\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n    ", "\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_2( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_3( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_4( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_5( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_6( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_7( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_8( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f * ( 1.0 - f ) * ( 1.0 - f ) );\n}\n\nvec3 smooth_dlmf_9( float h )\n{\n    float f = 1.0 / ( h + 1.0 );\n    return ( f", "\n    vec3 d = pa - pb;\n    float a = dot( rd, d );\n    float b = dot( rd, ro - pa );\n    float c = dot( ro - pa, ro - pa );\n    float h = b*b - a*c;\n    if( h < 0.0 )\n        return 1.0;\n    return 1.0 - h/r/r;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc, in vec3 pd, in float r )\n{\n    vec3 d = pa - pb;\n    vec3 e = pc - pd;\n    float a = dot( rd, d );\n    float b = dot( rd, ro - pa );\n    float c = dot( ro - pa, ro - pa );\n    float h = b*b - a*c;\n    if( h < 0.0 )\n        return 1.0;\n    return 1.0 - h/r/r;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc, in vec3 pd, in vec3 pe, in float r )\n{\n    vec3 d = pa - pb;\n    vec3 e = pc - pd;\n    vec3 f = pe - pc;\n    float a = dot( rd, d );\n    float b = dot( rd, ro - pa );\n    float c = dot( ro - pa, ro - pa );\n    float h = b*b - a*c;\n    if( h < 0.0 )\n        return 1.0;\n    return 1.0 - h/r/r;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule", "\n    vec3 pa = normalize(a - p);\n    vec3 pb = normalize(b - p);\n    float d = dot(pa, pb);\n    float r = ra + rb;\n    float r2 = r * r;\n    float r2a = ra * ra;\n    float r2b = rb * rb;\n    float d2 = d * d;\n    float d2a = d2 - r2a;\n    float d2b = d2 - r2b;\n    float d2a2 = d2a * d2a;\n    float d2b2 = d2b * d2b;\n    float d2a3 = d2a2 * d2a;\n    float d2b3 = d2b2 * d2b;\n    float d2a4 = d2a3 * d2a;\n    float d2b4 = d2b3 * d2b;\n    float d2a5 = d2a4 * d2a;\n    float d2b5 = d2b4 * d2b;\n    float d2a6 = d2a5 * d2a;\n    float d2b6 = d2b5 * d2b;\n    float d2a7 = d2a6 * d2a;\n    float d2b7 = d2b6 * d2b;\n    float d2a8 = d2a7 * d2a;\n    float d2b8 = d2b7 * d2b;\n    float d2a9 = d2a8 * d2a;\n    float d2b9 = d2b8 * d2b;\n    float d2a10 = d2a9 * d2a;\n    float d2b10 = d2b9 * d2b;\n    float d2a11 = d2a10 * d2a;\n    float d2b11 = d2b10 * d2b;\n    float d2a12 = d2a11 * d2a;\n    float d2b12 = d2b11 * d2b;\n    float d2a13 = d2", "\n    float d = dot( a, rd );\n    float e = dot( b, rd );\n    float f = dot( a, ro );\n    float g = dot( b, ro );\n    float h = d - f;\n    float i = e - g;\n    float j = h * h + i * i;\n    float k = sqrt( j );\n    float l = k * k * k;\n    float m = l * l * l;\n    float n = m * m * m;\n    float o = n * n * n;\n    float p = o * o * o;\n    float q = p * p * p;\n    float r = q * q * q;\n    float s = r * r * r;\n    float t = s * s * s;\n    float u = t * t * t;\n    float v = u * u * u;\n    float w = v * v * v;\n    float x = w * w * w;\n    float y = x * x * x;\n    float z = y * y * y;\n    float aa = z * z * z;\n    float bb = aa * aa;\n    float cc = bb * bb;\n    float dd = cc * cc;\n    float ee = dd * dd;\n    float ff = ee * ee;\n    float gg = ff * ff;\n    float hh = gg * gg;\n    float ii = hh * hh;\n    float jj = ii * ii;\n    float kk = jj * jj;\n    float ll = kk * kk;\n    float mm = ll * ll;\n    float nn = mm * mm;\n    float oo = nn * nn;\n    float pp = oo * oo;\n    float qq = pp * pp;\n    float rr = qq * qq;\n    float ss = rr * rr;\n    float tt = ss * ss;\n    float uu = tt * tt;\n    float vv = uu * uu;\n    float ww = vv * vv;\n    float xx = ww * ww;\n", "\n    float t = 0.0;\n    float r = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r1 = 0.0;\n    float r2 = 0.0;\n    float s = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a1 = 0.0;\n    float a2 = 0.0;\n    float a3 = 0.0;\n    float a4 = 0.0;\n    float a5 = 0.0;\n    float a6 = 0.0;\n    float a7 = 0.0;\n    float a8 = 0.0;\n    float a9 = 0.0;\n    float a10 = 0.0;\n    float a11 = 0.0;\n    float a12 = 0.0;\n    float a13 = 0.0;\n    float a14 = 0.0;\n    float a15 = 0.0;\n    float a16 = 0.0;\n    float a17 = 0.0;\n    float a18 = 0.0;\n", "\n    float a = atan( p.y, p.x );\n    float d = length( p );\n    float s = sin( a );\n    float c = cos( a );\n    float x = c * d;\n    float y = s * d;\n    float x2 = x * x;\n    float y2 = y * y;\n    float r2 = r * r;\n    float r22 = r2 * r2;\n    float xy = x * y;\n    float xy2 = xy * xy;\n    float xy22 = xy2 * xy2;\n    float xy2r2 = xy2 * r2;\n    float xy2r22 = xy2r2 * xy2r2;\n    float xy2r222 = xy2r22 * xy2r22;\n    float xy2r2222 = xy2r222 * xy2r222;\n    float xy2r22222 = xy2r2222 * xy2r2222;\n    float xy2r222222 = xy2r22222 * xy2r22222;\n    float xy2r2222222 = xy2r222222 * xy2r222222;\n    float xy2r22222222 = xy2r2222222 * xy2r2222222;\n    float xy2r222222222 = xy2r22222222 * xy2r22222222;\n    float xy2r2222222222 = xy2r222222222 * xy2r222222222;\n    float xy2r22222222222 = xy2r2222222222 * xy2r222222222", "\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r );\n}\n\nvec3 nSphere5( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r );\n}\n\nvec3 nSphere6( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r*r );\n}\n\nvec3 nSphere7( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r*r*r );\n}\n\nvec3 nSphere8( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r*r*r*r );\n}\n\nvec3 nSphere9( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r*r*r*r*r );\n}\n\nvec3 nSphere10( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r*r*r*r*r*r );\n}\n\nvec3 nSphere11( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n * ( 1.0 - r*r*r*r*r*r*r*r*r*r );\n}\n\nvec3 nSphere12( in vec3 pos )\n{\n    vec3 n = normalize( pos );\n    float r = length( pos );\n    return n", "\n    vec2 q = p * sca;\n    float d = length( q );\n    float r = ra + rb;\n    float r2 = r * r;\n    float rb2 = rb * rb;\n    float r22 = r2 * r2;\n    float rb22 = rb2 * rb2;\n    float r222 = r22 * r22;\n    float rb222 = rb22 * rb22;\n    float r2222 = r222 * r222;\n    float rb2222 = rb222 * rb222;\n    float r22222 = r2222 * r2222;\n    float rb22222 = rb2222 * rb2222;\n    float r222222 = r22222 * r22222;\n    float rb222222 = rb22222 * rb22222;\n    float r2222222 = r222222 * r222222;\n    float rb2222222 = rb222222 * rb222222;\n    float r22222222 = r2222222 * r2222222;\n    float rb22222222 = rb2222222 * rb2222222;\n    float r222222222 = r22222222 * r22222222;\n    float rb222222222 = rb222222222 * rb222222222;\n    float r2222222222 = r222222222 * r222222222;\n    float rb2222222222 = rb22", "\n    float d = 1.0;\n    float t = 0.0;\n    float tau = 0.0;\n    float tau2 = 0.0;\n    float tau3 = 0.0;\n    float tau4 = 0.0;\n    float tau5 = 0.0;\n    float tau6 = 0.0;\n    float tau7 = 0.0;\n    float tau8 = 0.0;\n    float tau9 = 0.0;\n    float tau10 = 0.0;\n    float tau11 = 0.0;\n    float tau12 = 0.0;\n    float tau13 = 0.0;\n    float tau14 = 0.0;\n    float tau15 = 0.0;\n    float tau16 = 0.0;\n    float tau17 = 0.0;\n    float tau18 = 0.0;\n    float tau19 = 0.0;\n    float tau20 = 0.0;\n    float tau21 = 0.0;\n    float tau22 = 0.0;\n    float tau23 = 0.0;\n    float tau24 = 0.0;\n    float tau25 = 0.0;\n    float tau26 = 0.0;\n    float tau27 = 0.0;\n    float tau28 = 0.0;\n    float tau29 = 0.0;\n    float tau30 = 0.0;\n    float tau31 = 0.0;\n    float tau32 = 0.0;\n    float tau33 = 0.0;\n    float tau34 = 0.0;\n    float tau35 = 0.0;\n    float tau36 = 0.0;\n    float tau37 = 0.0;\n    float tau38 = 0.0;\n    float tau39 =", "\n    vec3 n = vec3(0.0);\n    n += normalize( dFdx( pos ) );\n    n += normalize( dFdy( pos ) );\n    n += normalize( dFdx( dFdy( pos ) ) );\n    n += normalize( dFdx( dFdx( pos ) ) );\n    n += normalize( dFdy( dFdx( pos ) ) );\n    n += normalize( dFdx( dFdx( dFdy( pos ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( pos ) ) ) );\n    n += normalize( dFdy( dFdx( dFdx( pos ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdy( pos ) ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdx( pos ) ) ) ) );\n    n += normalize( dFdy( dFdx( dFdx( dFdx( pos ) ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdx( dFdy( pos ) ) ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdx( dFdx( pos ) ) ) ) ) );\n    n += normalize( dFdy( dFdx( dFdx( dFdx( dFdx( pos ) ) ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdx( dFdx( dFdy( pos ) ) ) ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdx( dFdx( dFdx( pos ) ) ) ) ) ) );\n    n += normalize( dFdy( dFdx( dFdx( dFdx( dFdx( dFdx( pos ) ) ) ) ) ) );\n    n += normalize( dFdx( dFdx( dFdx( dFdx( dFdx( dFdx( dFdy( pos ) ) ) ) ) ) ) );\n    n += normalize( dFdx(", "\n    float d = 1.0;\n    float t = 0.0;\n    float tau = 0.0;\n    float d0 = 1.0;\n    float d1 = 1.0;\n    float d2 = 1.0;\n    float d3 = 1.0;\n    float d4 = 1.0;\n    float d5 = 1.0;\n    float d6 = 1.0;\n    float d7 = 1.0;\n    float d8 = 1.0;\n    float d9 = 1.0;\n    float d10 = 1.0;\n    float d11 = 1.0;\n    float d12 = 1.0;\n    float d13 = 1.0;\n    float d14 = 1.0;\n    float d15 = 1.0;\n    float d16 = 1.0;\n    float d17 = 1.0;\n    float d18 = 1.0;\n    float d19 = 1.0;\n    float d20 = 1.0;\n    float d21 = 1.0;\n    float d22 = 1.0;\n    float d23 = 1.0;\n    float d24 = 1.0;\n    float d25 = 1.0;\n    float d26 = 1.0;\n    float d27 = 1.0;\n    float d28 = 1.0;\n    float d29 = 1.0;\n    float d30 = 1.0;\n    float d31 = 1.0;\n    float d32 = 1.0;\n    float d33 = 1.0;\n    float d34 = 1.0;\n    float d35 = 1.0;\n    float d36 = 1.0;\n    float d37 = 1.0;\n    float d38 = 1.0;\n    float d39 = 1.0;\n    float d40 = 1.0", "\n    vec2 d = abs(p) - 0.5;\n    float r = dot(d,d);\n    float g = dot(d,dpdx) + dot(d,dpdy);\n    return r*r*g*g;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 d = abs(p) - 0.5;\n    float r = dot(d,d);\n    float g = dot(d,dpdx) + dot(d,dpdy);\n    return r*r*g*g;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 d = abs(p) - 0.5;\n    float r = dot(d,d);\n    float g = dot(d,dpdx) + dot(d,dpdy);\n    return r*r*g*g;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 d = abs(p) - 0.5;\n    float r = dot(d,d);\n    float g = dot(d,dpdx) + dot(d,dpdy);\n    return r*r*g*g;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 d = abs(p) - 0.5;\n    float r = dot(d,d);\n    float g = dot(d,dpdx) + dot(d,dpdy);\n    return r*r*g*g;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 d = abs(p) - 0.5;\n    float r = dot(d,d);\n    float g = dot(d,dpdx) + dot(d,dpdy);\n    return r*r*g*g;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dp", "\n  return 1.0/k*x;\n}\n\n//\n// The function f(x) = x^2\n//\nfloat square( in float x )\n{\n  return x*x;\n}\n\n//\n// The function f(x) = x^2 + 1\n//\nfloat square_plus_one( in float x )\n{\n  return square(x) + 1.0;\n}\n\n//\n// The function f(x) = x^2 - 1\n//\nfloat square_minus_one( in float x )\n{\n  return square(x) - 1.0;\n}\n\n//\n// The function f(x) = x^2 + 2\n//\nfloat square_plus_two( in float x )\n{\n  return square(x) + 2.0;\n}\n\n//\n// The function f(x) = x^2 - 2\n//\nfloat square_minus_two( in float x )\n{\n  return square(x) - 2.0;\n}\n\n//\n// The function f(x) = x^2 + 3\n//\nfloat square_plus_three( in float x )\n{\n  return square(x) + 3.0;\n}\n\n//\n// The function f(x) = x^2 - 3\n//\nfloat square_minus_three( in float x )\n{\n  return square(x) - 3.0;\n}\n\n//\n// The function f(x) = x^2 + 4\n//\nfloat square_plus_four( in float x )\n{\n  return square(x) + 4.0;\n}\n\n//\n// The function f(x) = x^2 - 4\n//\nfloat square_minus_four( in float x )\n{\n  return square(x) - 4.0;\n}\n\n//\n// The function f(x) = x^2 + 5\n//\nfloat square_plus_five( in float x )\n{\n  return square(x) + 5.0;\n}\n\n//\n// The function f(x) = x^2 - 5\n//\n", "\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 sample_pos_norm = normalize(sample_pos);\n    vec3 surface_normal_norm = normalize(surface_normal);\n\n    // We're going to use the dot product to determine how much of the light is reflected\n    float dot_product = dot(light_dir_norm, surface_normal_norm);\n\n    // If the dot product is negative, the light is reflected, otherwise it's not\n    float reflected_amount = clamp(dot_product, 0.0, 1.0);\n\n    // We're going to use the dot product to determine how much of the light is reflected\n    float dot_product2 = dot(light_dir_norm, sample_pos_norm);\n\n    // If the dot product is negative, the light is reflected, otherwise it's not\n    float reflected_amount2 = clamp(dot_product2, 0.0, 1.0);\n\n    // We're going to use the dot product to determine how much of the light is reflected\n    float dot_product3 = dot(light_dir_norm, background_col);\n\n    // If the dot product is negative, the light is reflected, otherwise it's not\n    float reflected_amount3 = clamp(dot_product3, 0.0, 1.0);\n\n    // We're going to use the dot product to determine how much of the light is reflected\n    float dot_product4 = dot(light_dir_norm, surface_normal_norm);\n\n    // If the dot product is negative, the light is reflected, otherwise it's not\n    float reflected_amount4 = clamp(dot_product4, 0.0, 1.0);\n\n    // We're going to use the dot product to determine how much of the light is reflected\n    float dot_product5 = dot(light_dir_norm, surface_normal_norm);\n\n    // If the dot product is negative, the light is reflected, otherwise it's not\n    float reflected_amount5 = clamp(dot_product5, 0.0, 1.0);\n\n    // We're going to use the dot product to determine how much of the", "\n    // get the normal of the surface\n    vec3 normal = normalize(normal_at(pos, dir));\n\n    // get the distance to the surface\n    float dist = distance_at(pos, dir);\n\n    // get the color of the surface\n    vec3 color = vec3(0.0);\n\n    // get the color of the light\n    vec3 light_color = vec3(1.0);\n\n    // get the color of the sky\n    vec3 sky_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the ground\n    vec3 ground_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the water\n    vec3 water_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, 0.0);\n\n    // get the color of the cloud\n    vec3 cloud_color = vec3(0.0, 0.0, ", "\n    vec2 uv = (2.0 * coord / resolution) - 1.0;\n    vec2 vuv = (2.0 * coord / resolution) - 1.0;\n    vec2 uv_ = uv * (resolution.x / resolution.y);\n    vec2 vuv_ = vuv * (resolution.x / resolution.y);\n    vec2 uv_2 = uv_ * uv_;\n    vec2 vuv_2 = vuv_ * vuv_;\n    vec2 uv_3 = uv_2 * uv_;\n    vec2 vuv_3 = vuv_2 * vuv_;\n    vec2 uv_4 = uv_3 * uv_;\n    vec2 vuv_4 = vuv_3 * vuv_;\n    vec2 uv_5 = uv_4 * uv_;\n    vec2 vuv_5 = vuv_4 * vuv_;\n    vec2 uv_6 = uv_5 * uv_;\n    vec2 vuv_6 = vuv_5 * vuv_;\n    vec2 uv_7 = uv_6 * uv_;\n    vec2 vuv_7 = vuv_6 * vuv_;\n    vec2 uv_8 = uv_7 * uv_;\n    vec2 vuv_8 = vuv_7 * vuv_;\n    vec2 uv_9 = uv_8 * uv_;\n    vec2 vuv_9 = vuv_8 * vuv_;\n    vec2 uv_10 = uv_9 * uv_;\n    vec2 vuv_10 = vuv_9 * vuv_;\n    vec2 uv_11 = uv_10 * uv_;\n    vec2 vuv_11 = vuv_10 * vuv_;\n    vec2 uv_12 = uv_11 * uv_;\n    vec2 vuv_12 = vuv_11 * vuv_;\n    vec2 uv_13 = uv_12 * uv_;\n    vec2", "\n    float a = length(p);\n    float b = length(p.xz);\n    float c2 = c.x * c.x + c.y * c.y;\n    float d = c2 * b * b + c2 * a * a - 2.0 * c2 * a * b * cos(atan2(p.y, p.x));\n    return clamp(d, 0.0, ra * ra);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb)\n{\n    float a = length(p);\n    float b = length(p.xz);\n    float c2 = c.x * c.x + c.y * c.y;\n    float d = c2 * b * b + c2 * a * a - 2.0 * c2 * a * b * cos(atan2(p.y, p.x));\n    return clamp(d, 0.0, ra * ra + rb * rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc)\n{\n    float a = length(p);\n    float b = length(p.xz);\n    float c2 = c.x * c.x + c.y * c.y;\n    float d = c2 * b * b + c2 * a * a - 2.0 * c2 * a * b * cos(atan2(p.y, p.x));\n    return clamp(d, 0.0, ra * ra + rb * rb + rc * rc);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd)\n{\n    float a = length(p);\n    float b = length(p.xz);\n    float c2 = c.x * c.x + c.y * c.y;\n    float d = c2 * b * b + c2 *", "\n  vec3 color = vec3(1.0);\n  if (material == 0) {\n    color = vec3(0.5);\n  } else if (material == 1) {\n    color = vec3(1.0);\n  } else if (material == 2) {\n    color = vec3(1.0);\n  } else if (material == 3) {\n    color = vec3(1.0);\n  } else if (material == 4) {\n    color = vec3(1.0);\n  } else if (material == 5) {\n    color = vec3(1.0);\n  } else if (material == 6) {\n    color = vec3(1.0);\n  } else if (material == 7) {\n    color = vec3(1.0);\n  } else if (material == 8) {\n    color = vec3(1.0);\n  } else if (material == 9) {\n    color = vec3(1.0);\n  } else if (material == 10) {\n    color = vec3(1.0);\n  } else if (material == 11) {\n    color = vec3(1.0);\n  } else if (material == 12) {\n    color = vec3(1.0);\n  } else if (material == 13) {\n    color = vec3(1.0);\n  } else if (material == 14) {\n    color = vec3(1.0);\n  } else if (material == 15) {\n    color = vec3(1.0);\n  } else if (material == 16) {\n    color = vec3(1.0);\n  } else if (material == 17) {\n    color = vec3(1.0);\n  } else if (material == 18) {\n    color = vec3(1.0);\n  } else if (material == 19) {\n    color = vec3(1.0);\n  } else if (material == 20) {\n    color = vec3(1.0);\n  } else if (material", "\n    switch (material) {\n        case 0:\n            return 0.0;\n        case 1:\n            return 0.2;\n        case 2:\n            return 0.3;\n        case 3:\n            return 0.4;\n        case 4:\n            return 0.5;\n        case 5:\n            return 0.6;\n        case 6:\n            return 0.7;\n        case 7:\n            return 0.8;\n        case 8:\n            return 0.9;\n        case 9:\n            return 1.0;\n        default:\n            return 0.0;\n    }\n}\n\n// Get the material of a block.\nint get_material(int block) {\n    return block / 16;\n}\n\n// Get the block type of a block.\nint get_block_type(int block) {\n    return block % 16;\n}\n\n// Get the block color of a block.\nint get_block_color(int block) {\n    return block / 16 / 16;\n}\n\n// Get the block light level of a block.\nint get_block_light_level(int block) {\n    return block / 16 / 16 / 16;\n}\n\n// Get the block light level of a block.\nint get_block_light_level(int block) {\n    return block / 16 / 16 / 16;\n}\n\n// Get the block light level of a block.\nint get_block_light_level(int block) {\n    return block / 16 / 16 / 16;\n}\n\n// Get the block light level of a block.\nint get_block_light_level(int block) {\n    return block / 16 / 16 / 16;\n}\n\n// Get the block light level of a block.\nint get_block_light_level(int block) {\n    return block / 16 / 16 / 16;\n}\n\n// Get the block light level of a block.\nint get_block_light_", "\n    return get_material_property(material, \"refraction\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_reflection(int material) {\n    return get_material_property(material, \"reflection\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_transparency(int material) {\n    return get_material_property(material, \"transparency\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_transmission(int material) {\n    return get_material_property(material, \"transmission\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_ior(int material) {\n    return get_material_property(material, \"ior\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_roughness(int material) {\n    return get_material_property(material, \"roughness\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_color(int material) {\n    return get_material_property(material, \"specular_color\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_power(int material) {\n    return get_material_property(material, \"specular_power\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_reflectance(int material) {\n    return get_material_property(material, \"specular_reflectance\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_reflection(int material) {\n    return get_material_property(material, \"specular_reflection\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_refraction(int material) {\n    return get_material_property(material, \"specular_refraction\");\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_transmission(int material) {\n    return get_material_property(material, \"", "\n    return get_material_property(material, \"opacity\");\n}\n\n// Get the material's color.\n// The color is a 3-tuple of floats between 0.0 and 1.0.\n// The color is in the order of red, green, blue.\nvec3 get_material_color(int material) {\n    return get_material_property(material, \"color\");\n}\n\n// Get the material's specular color.\n// The color is a 3-tuple of floats between 0.0 and 1.0.\n// The color is in the order of red, green, blue.\nvec3 get_material_specular_color(int material) {\n    return get_material_property(material, \"specular_color\");\n}\n\n// Get the material's specular power.\n// The specular power is a float between 0.0 and 100.0.\nfloat get_material_specular_power(int material) {\n    return get_material_property(material, \"specular_power\");\n}\n\n// Get the material's shininess.\n// The shininess is a float between 0.0 and 100.0.\nfloat get_material_shininess(int material) {\n    return get_material_property(material, \"shininess\");\n}\n\n// Get the material's refraction index.\n// The refraction index is a float between 1.0 and 1.0001.\nfloat get_material_refraction_index(int material) {\n    return get_material_property(material, \"refraction_index\");\n}\n\n// Get the material's refraction index.\n// The refraction index is a float between 1.0 and 1.0001.\nfloat get_material_refraction_index(int material) {\n    return get_material_property(material, \"refraction_index\");\n}\n\n// Get the material's refraction index.\n// The refraction index is a float between 1.0 and 1.0001.\nfloat get_material_refraction_index(int material) {\n    return get_", "\n    vec3 line_ab = line_b - line_a;\n    vec3 line_ac = line_a - tri_a;\n    vec3 line_bc = line_b - tri_b;\n    vec3 line_ca = line_a - tri_c;\n    vec3 line_cb = line_b - tri_c;\n    vec3 line_ca_cb = cross(line_ca, line_cb);\n    vec3 line_ab_ac = cross(line_ab, line_ac);\n    vec3 line_ab_bc = cross(line_ab, line_bc);\n    vec3 line_ab_ca = cross(line_ab, line_ca);\n    vec3 line_ab_cb = cross(line_ab, line_cb);\n    vec3 line_ab_ca_cb = cross(line_ab_ca, line_cb);\n    vec3 line_ab_ac_cb = cross(line_ab_ac, line_cb);\n    vec3 line_ab_ac_ca = cross(line_ab_ac, line_ca);\n    vec3 line_ab_ac_ca_cb = cross(line_ab_ac_ca, line_cb);\n    vec3 line_ab_ac_ca_cb_line_ab = cross(line_ab_ac_ca_cb, line_ab);\n    vec3 line_ab_ac_ca_cb_line_ab_line_ac = cross(line_ab_ac_ca_cb_line_ab, line_ac);\n    vec3 line_ab_ac_ca_cb_line_ab_line_bc = cross(line_ab_ac_ca_cb_line_ab, line_bc);\n    vec3 line_ab_ac_ca_cb_line_ab_line_ca = cross(line_ab_ac_ca_cb_line_ab, line_ca);\n    vec3 line_ab_ac_ca_cb_line_ab_line_cb = cross(line_ab_ac_ca_cb_line_ab, line_cb);\n    vec3 line_ab_ac_ca_cb_line_ab_line_ca_cb = cross(line_ab_", "\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 tri_bc = tri_b - tri_c;\n    return normalize(cross(tri_ab, tri_ac));\n}\n\n// Given a triangle, compute the barycentric coordinates of the point\n// p with respect to the triangle.\nvec3 get_tri_barycentric_coords(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 p) {\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 tri_bc = tri_b - tri_c;\n    vec3 tri_ap = p - tri_a;\n    vec3 tri_bp = p - tri_b;\n    vec3 tri_cp = p - tri_c;\n    vec3 tri_ap_cross_tri_ac = cross(tri_ap, tri_ac);\n    vec3 tri_bp_cross_tri_bc = cross(tri_bp, tri_bc);\n    vec3 tri_cp_cross_tri_ab = cross(tri_cp, tri_ab);\n    return normalize(tri_ap_cross_tri_ac + tri_bp_cross_tri_bc + tri_cp_cross_tri_ab) /\n        dot(tri_ab, tri_ac);\n}\n\n// Given a triangle, compute the barycentric coordinates of the point\n// p with respect to the triangle.\nvec3 get_tri_barycentric_coords_2(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 p) {\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 tri_bc = tri_b - tri_c;\n    vec3 tri_ap = p - tri_a;\n    vec3 tri_bp = p - tri_b;\n    vec3 tri_cp = p - tri_c;\n    vec3 tri_ap_cross_tri_ac = cross(tri_ap, tri", "\n  vec3 camera_up = vec3(0.0, 1.0, 0.0);\n  vec3 camera_right = cross(camera_up, camera_target);\n  vec3 camera_forward = cross(camera_right, camera_target);\n  return mat3(\n    camera_right,\n    camera_forward,\n    camera_up\n  );\n}\n\n// Generate a perspective projection matrix based on a field of view\n// and aspect ratio.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/perspective-projection-matrix/perspective-projection-matrix-formula\nmat3 perspective_matrix(float fov, float aspect_ratio, float near, float far) {\n  float fov_rad = fov * DEG_TO_RAD;\n  float fov_cos = cos(fov_rad / 2.0);\n  float fov_sin = sin(fov_rad / 2.0);\n  float near_far_ratio = far / (far - near);\n  float far_cos = cos(fov_rad - DEG_TO_RAD);\n  float far_sin = sin(fov_rad - DEG_TO_RAD);\n  return mat3(\n    near_far_ratio * far_cos / fov_cos,\n    0.0,\n    0.0,\n    0.0,\n    near_far_ratio * far_sin / fov_sin,\n    0.0,\n    0.0,\n    near * far_cos / fov_cos,\n    near * far_sin / fov_sin\n  );\n}\n\n// Generate a perspective projection matrix based on a field of view\n// and aspect ratio.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/perspective-projection-matrix/perspective-projection-matrix-formula\nmat3 perspective_matrix(float fov, float aspect_ratio, float near, float far) {\n  float fov_rad = fov * DEG_TO_RAD;\n  float fov_cos = cos(fov_", "\n  cast_ray_result result;\n  result.t = -1.0;\n  result.normal = vec3(0.0);\n  result.material = 0;\n  result.color = vec3(0.0);\n  result.material_color = vec3(0.0);\n  result.material_specular = vec3(0.0);\n  result.material_roughness = 0.0;\n  result.material_metallic = 0.0;\n  result.material_clearcoat = 0.0;\n  result.material_clearcoat_roughness = 0.0;\n  result.material_clearcoat_gloss = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_roughness = 0.0;\n  result.material_clearcoat_gloss_", "\n  float shadow_distance = 0.0;\n  float shadow_distance_squared = 0.0;\n  float shadow_distance_squared_max = 1000000.0;\n  float shadow_distance_squared_min = 0.0;\n  float shadow_distance_squared_mid = 0.0;\n  float shadow_distance_squared_mid_max = 0.0;\n  float shadow_distance_squared_mid_min = 0.0;\n  float shadow_distance_squared_mid_mid = 0.0;\n  float shadow_distance_squared_mid_mid_max = 0.0;\n  float shadow_distance_squared_mid_mid_min = 0.0;\n  float shadow_distance_squared_mid_mid_mid = 0.0;\n  float shadow_distance_squared_mid_mid_mid_max = 0.0;\n  float shadow_distance_squared_mid_mid_mid_min = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_max = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_min = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid_max = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid_min = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid_mid = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid_mid_max = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid_mid_min = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid_mid_mid = 0.0;\n  float shadow_distance_squared_mid_mid_mid_mid_mid", "\n\treturn 0.5 - abs( sin( x ) );\n}\n\n// Perlin noise\nfloat pnoise( in float x, in float y )\n{\n\treturn 0.5 - abs( sin( x + y ) );\n}\n\n// Perlin noise\nfloat pnoise( in float x, in float y, in float z )\n{\n\treturn 0.5 - abs( sin( x + y + z ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec3 x )\n{\n\treturn 0.5 - abs( sin( x.x + x.y + x.z ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec3 x, in vec3 y )\n{\n\treturn 0.5 - abs( sin( x.x + y.x + y.y + y.z ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec3 x, in vec3 y, in vec3 z )\n{\n\treturn 0.5 - abs( sin( x.x + y.x + y.y + z.z ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec3 x, in vec3 y, in vec3 z, in vec3 w )\n{\n\treturn 0.5 - abs( sin( x.x + y.x + y.y + z.z + w.x + w.y + w.z ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec3 x, in vec3 y, in vec3 z, in vec3 w, in vec3 v )\n{\n\treturn 0.5 - abs( sin( x.x + y.x + y.y + z.z + w.x + w.y + w.z + v.x + v.y + v.z ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec3 x, in vec3 y, in vec3 z, in vec3 w, in vec3 v, in vec3 u )\n{\n\treturn 0.5 - abs( sin( x.x + y.x + y.y + z.z + w.x + w.y + w.z", "\n\treturn 0.5 - abs( sin( p ) );\n}\n\n// Perlin noise\nfloat pnoise( in vec2 p )\n{\n\treturn 0.5 - abs( sin( p.x + p.y ) );\n}\n\n// Simplex noise\nfloat snoise( in vec2 p )\n{\n\tvec2 i = floor( p );\n\tvec2 x = p - i;\n\tvec4 a = pnoise( i );\n\tvec4 b = pnoise( i + vec2( 1.0, 0.0 ) );\n\tvec4 c = pnoise( i + vec2( 0.0, 1.0 ) );\n\tvec4 d = pnoise( i + vec2( 1.0, 1.0 ) );\n\treturn mix( a, b, x.x ) +\n\t\t   mix( c, d, x.x ) - a - b + c + d;\n}\n\n// Simplex noise with octaves\nfloat snoiseOct( in vec2 p )\n{\n\tfloat n = 0.0;\n\tfloat o = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tn += o * snoise( p );\n\t\to *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn n;\n}\n\n// Simplex noise with octaves and persistence\nfloat snoiseOctPers( in vec2 p, in float pers )\n{\n\tfloat n = 0.0;\n\tfloat o = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tn += o * snoise( p );\n\t\to *= pers;\n\t\tp *= 2.0;\n\t}\n\treturn n;\n}\n\n// Simplex noise with octaves and persistence and lacunarity\nfloat snoiseOctPersLac( in vec2 p, in float pers, in float lac )\n{\n\tfloat n = 0.0;\n\tfloat o = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{", "\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( float n ) ///< hash function for float\n{\n    return n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( double n ) ///< hash function for double\n{\n    return n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( long double n ) ///< hash function for long double\n{\n    return n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( unsigned int n ) ///< hash function for unsigned int\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( unsigned long n ) ///< hash function for unsigned long\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( unsigned long long n ) ///< hash function for unsigned long long\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( unsigned short n ) ///< hash function for unsigned short\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( unsigned char n ) ///< hash function for unsigned char\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( signed char n ) ///< hash function for signed char\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( signed short n ) ///< hash function for signed short\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\nfloat hash( signed long n ) ///< hash function for signed long\n{\n    return (float)n / (float)INT_MAX;\n}\n\n// integer hash copied from Hugo Elias\n", "\n\treturn fract(sin(p)*43748.0);\n}\n\n// random noise\nfloat rnoise( in float p )\n{\n\treturn fract(sin(p)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec2 p )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec3 p )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec4 p )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec2 p, in vec2 scale )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec3 p, in vec3 scale )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec4 p, in vec4 scale )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec2 p, in vec2 scale, in vec2 offset )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec3 p, in vec3 scale, in vec3 offset )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec4 p, in vec4 scale, in vec4 offset )\n{\n\treturn fract(sin(p.x*p.y)*43748.0);\n}\n\n// random noise\nfloat rnoise( in vec2 p, in vec2 scale, in vec2 offset, in vec2 seed )\n{\n\treturn", "\n\tfloat f = 0.0f;\n\tfloat s = 0.5f;\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += s * sin( G * x );\n\t\ts *= 0.5f;\n\t}\n\treturn f;\n}\n\n// fbm2\nfloat fbm2( in float x, in float G )\n{\n\tfloat f = 0.0f;\n\tfloat s = 0.5f;\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += s * sin( G * x );\n\t\ts *= 0.5f;\n\t}\n\treturn f;\n}\n\n// fbm3\nfloat fbm3( in float x, in float G )\n{\n\tfloat f = 0.0f;\n\tfloat s = 0.5f;\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += s * sin( G * x );\n\t\ts *= 0.5f;\n\t}\n\treturn f;\n}\n\n// fbm4\nfloat fbm4( in float x, in float G )\n{\n\tfloat f = 0.0f;\n\tfloat s = 0.5f;\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += s * sin( G * x );\n\t\ts *= 0.5f;\n\t}\n\treturn f;\n}\n\n// fbm5\nfloat fbm5( in float x, in float G )\n{\n\tfloat f = 0.0f;\n\tfloat s = 0.5f;\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += s * sin( G * x );\n\t\ts *= 0.5f;\n\t}\n\treturn f;\n}\n\n// fbm6\nfloat fbm6( in float x, in float G )\n{\n\tfloat f = 0.0f;\n\tfloat s = 0.5f;", "\n    vec3 c = vec3(0.0);\n    float d = dot(p,p);\n    if (d < 1.0)\n    {\n        float f = sqrt(1.0 - d);\n        c = vec3(f,f,f);\n    }\n    return c;\n}\n\n// The main program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the pixel coordinates in the range [-1,1]\n    vec2 uv = (2.0 * fragCoord.xy) / iResolution.xy - 1.0;\n\n    // Get the point in the sphere's surface\n    vec3 p = vec3(uv, 1.0);\n\n    // Get the color of the point\n    vec3 c = getColor(p);\n\n    // Set the color\n    fragColor = vec4(c,1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4l337d';\n  }\n  name(): string {\n    return 'Sphere';\n  }\n  webgl() {\n    return WEBGL_2;\n  }\n  sort() {\n    return 100;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment(): string {\n    return fragment;\n  }\n  fragmentPrecision?(): string {\n    return PRECISION_MEDIUMP;\n  }\n  destory(): void {}\n  initial?(gl: WebGLRenderingContext, program: WebGLProgram): Function {\n    return () => {};\n  }\n  channels() {\n    return [webglUtils.DEFAULT_NOISE];\n  }\n}<|endoftext|>import {\n  createCanvas,\n  createImageData,\n  loadImage,\n  ImageData,\n  ImageLoader,\n} from 'canvas';\nimport {\n  createImage,\n  createImageDataFromImage,\n  createImageDataFromImageData,\n  createImageDataFromImageDataArray,\n  createImageDataFromImageData", "\n    vec3 p = pb * 2.0;\n    vec3 c = p * p * p;\n    vec3 d = c * c * c;\n    vec3 e = d * c * c;\n    vec3 f = e * c * c;\n    vec3 g = f * c * c;\n    vec3 h = g * c * c;\n    vec3 i = h * c * c;\n    vec3 j = i * c * c;\n    vec3 k = j * c * c;\n    vec3 l = k * c * c;\n    vec3 m = l * c * c;\n    vec3 n = m * c * c;\n    vec3 o = n * c * c;\n    vec3 p = o * c * c;\n    vec3 q = p * c * c;\n    vec3 r = q * c * c;\n    vec3 s = r * c * c;\n    vec3 t = s * c * c;\n    vec3 u = t * c * c;\n    vec3 v = u * c * c;\n    vec3 w = v * c * c;\n    vec3 x = w * c * c;\n    vec3 y = x * c * c;\n    vec3 z = y * c * c;\n    vec3 a = z * c * c;\n    vec3 b = a * c * c;\n    vec3 c = b * c * c;\n    vec3 d = c * c * c;\n    vec3 e = d * c * c;\n    vec3 f = e * c * c;\n    vec3 g = f * c * c;\n    vec3 h = g * c * c;\n    vec3 i = h * c * c;\n    vec3 j = i * c * c;\n    vec3 k = j * c * c;\n    vec3 l = k * c * c;\n    vec3 m = l * c * c;\n    vec3 n = m * c * c;\n    vec3 o = n * c * c;\n    vec3 p = o * c * c;\n    vec3 q = p * c * c;\n    vec3 r =", "\n    vec3 d = ro - cen;\n    vec3 q = d - rd * dot( d, rd );\n    vec3 r = vec3( length( q ), q.y, q.z );\n    vec3 s = vec3( dot( r, r ), r.y, r.z );\n    vec3 t = vec3( dot( s, s ), s.y, s.z );\n    vec3 u = vec3( dot( t, t ), t.y, t.z );\n    vec3 v = vec3( dot( u, u ), u.y, u.z );\n    vec3 w = vec3( dot( v, v ), v.y, v.z );\n    vec3 x = vec3( dot( w, w ), w.y, w.z );\n    vec3 y = vec3( dot( x, x ), x.y, x.z );\n    vec3 z = vec3( dot( y, y ), y.y, y.z );\n    vec3 a = vec3( dot( z, z ), z.y, z.z );\n    vec3 b = vec3( dot( a, a ), a.y, a.z );\n    vec3 c = vec3( dot( b, b ), b.y, b.z );\n    vec3 d = vec3( dot( c, c ), c.y, c.z );\n    vec3 e = vec3( dot( d, d ), d.y, d.z );\n    vec3 f = vec3( dot( e, e ), e.y, e.z );\n    vec3 g = vec3( dot( f, f ), f.y, f.z );\n    vec3 h = vec3( dot( g, g ), g.y, g.z );\n    vec3 i = vec3( dot( h, h ), h.y, h.z );\n    vec3 j = vec3( dot( i, i ), i.y, i.z );\n    vec3 k = vec3( dot( j, j ), j.y, j.z );\n    vec3 l", "\n    vec3 d = ro - cen;\n    float t = dot( d, rd );\n    float h = length( d );\n    float r = h - rad;\n    return clamp( r, 0.0, t );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad )\n{\n    vec3 d = ro - cen;\n    float t = dot( d, rd );\n    float h = length( d );\n    return clamp( h - rad, 0.0, t );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat cylinder( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float h )\n{\n    vec3 d = ro - cen;\n    float t = dot( d, rd );\n    float hh = length( d );\n    float ht = h - hh;\n    return clamp( ht, 0.0, t );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat cone( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float h )\n{\n    vec3 d = ro - cen;\n    float t = dot( d, rd );\n    float hh = length( d );\n    float ht = h - hh;\n    return clamp( ht, 0.0, t );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat disc( in vec3 ro, in vec3 rd, in vec3 cen, in float rad )\n{\n    vec3 d = ro - cen;\n    float t = dot( d, rd );\n    float h = length( d );\n    return clamp( h - rad, 0.0, t );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float t = mint;\n    float d = 1.0;\n    float d0 = 1.0;\n    float d1 = 1.0;\n    float d2 = 1.0;\n    float d3 = 1.0;\n    float d4 = 1.0;\n    float d5 = 1.0;\n    float d6 = 1.0;\n    float d7 = 1.0;\n    float d8 = 1.0;\n    float d9 = 1.0;\n    float d10 = 1.0;\n    float d11 = 1.0;\n    float d12 = 1.0;\n    float d13 = 1.0;\n    float d14 = 1.0;\n    float d15 = 1.0;\n    float d16 = 1.0;\n    float d17 = 1.0;\n    float d18 = 1.0;\n    float d19 = 1.0;\n    float d20 = 1.0;\n    float d21 = 1.0;\n    float d22 = 1.0;\n    float d23 = 1.0;\n    float d24 = 1.0;\n    float d25 = 1.0;\n    float d26 = 1.0;\n    float d27 = 1.0;\n    float d28 = 1.0;\n    float d29 = 1.0;\n    float d30 = 1.0;\n    float d31 = 1.0;\n    float d32 = 1.0;\n    float d33 = 1.0;\n    float d34 = 1.0;\n    float d35 = 1.0;\n    float d36 = 1.0;\n    float d37 = 1.0;\n    float d38 = 1.0;\n    float d39 = 1.0;\n    float d40 = 1.0;\n    float d41 = 1.0;\n", " seed = 131 * seed; return (seed * 1.0) / 4294967296.0; }\n\n// compute the dot product of two vectors\nfloat dot(vec3 a, vec3 b) { return dot(a, b); }\n\n// compute the cross product of two vectors\nvec3 cross(vec3 a, vec3 b) { return a ^ b; }\n\n// compute the length of a vector\nfloat length(vec3 v) { return sqrt(dot(v, v)); }\n\n// compute the distance between two points\nfloat distance(vec3 a, vec3 b) { return length(a - b); }\n\n// compute the distance squared between two points\nfloat distanceSq(vec3 a, vec3 b) { return dot(a - b, a - b); }\n\n// compute the angle in radians between two vectors, normalized\nfloat angle(vec3 a, vec3 b) { return acos(dot(a, b)); }\n\n// compute the reflection of a vector\nvec3 reflect(vec3 v, vec3 n) { return v - 2.0 * dot(v, n) * n; }\n\n// compute the refraction of a vector\nvec3 refract(vec3 v, vec3 n, float eta) {\n  float cosTheta = dot(n, v);\n  float k = 1.0 - eta * eta * (1.0 - cosTheta * cosTheta);\n  return eta * v - (eta * cosTheta - sqrt(k)) * n;\n}\n\n// compute the sine of an angle\nfloat sin(float x) { return abs(x) < EPSILON? x : sin(x) / abs(x); }\n\n// compute the cosine of an angle\nfloat cos(float x) { return abs(x) < EPSILON? x : cos(x) / abs(x); }\n\n// compute the tangent of an angle\nfloat tan(float x) { return abs(x) < EPSILON? x : sin(x) / cos(x); }\n\n// compute the arc sine of a value\nfloat asin(float x) { return abs(x) < 1.0 ", "\n    return a + (b-a)*t*t*t*t +\n           3.0*(c-a)*t*t*t +\n           3.0*(b-c)*t*t*t +\n           (d-c)*t*t*t*t;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e )\n{\n    return a + (b-a)*t*t*t*t*t +\n           6.0*(c-a)*t*t*t*t +\n           12.0*(b-c)*t*t*t*t +\n           6.0*(d-c)*t*t*t*t*t +\n           (e-d)*t*t*t*t*t*t;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f )\n{\n    return a + (b-a)*t*t*t*t*t*t +\n           12.0*(c-a)*t*t*t*t*t +\n           24.0*(b-c)*t*t*t*t*t +\n           12.0*(d-c)*t*t*t*t*t*t +\n           6.0*(e-d)*t*t*t*t*t*t*t +\n           (f-e)*t*t*t*t*t*t*t*t;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f, in vec3 g )\n{\n    return a + (b-a)*t*t*t*t*t*t*t +\n           12.0*(c-a)*t*t*t*t*t*t +\n           24.0*(b-c)*t*t*t*t*t*t +\n           12.0*(d-c)*t*t*", "\n    float d = length(p.xz);\n    float h2 = h*h;\n    float d2 = d*d;\n    float a2 = la*la;\n    float b2 = lb*lb;\n    float r2 = ra*ra;\n    float r22 = r2*r2;\n    float a2b2 = a2*b2;\n    float a2h2 = a2*h2;\n    float b2h2 = b2*h2;\n    float a2b2h2 = a2b2*h2;\n    float a2b2h2r2 = a2b2h2*r2;\n    float a2b2h2r22 = a2b2h2r2*r2;\n    float a2b2h2r222 = a2b2h2r22*r2;\n    float a2b2h2r2222 = a2b2h2r222*r2;\n    float a2b2h2r22222 = a2b2h2r2222*r2;\n    float a2b2h2r222222 = a2b2h2r22222*r2;\n    float a2b2h2r2222222 = a2b2h2r222222*r2;\n    float a2b2h2r22222222 = a2b2h2r2222222*r2;\n    float a2b2h2r222222222 = a2b2h2r22222222*r2;\n    float a2b2h2r2222222222 = a2b2h2r222222222*r2;\n    float a2b2h2r22222222222 = a2b2h2r2222222222*r2;\n    float a2b2h2r222222", "\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length(pa);\n    float y = length(pa + pb);\n    float z = length(pa + pb + pb);\n    float w = length(pa + pb + pb + pb);\n    return vec4(x, y, z, w);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r )\n{\n    return paSegment(p, a, b, r, 0.0);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band )\n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length(pa);\n    float y = length(pa + pb);\n    float z = length(pa + pb + pb);\n    float w = length(pa + pb + pb + pb);\n    return vec4(x, y, z, w);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float t )\n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length(pa);\n    float y = length(pa + pb);\n    float z = length(pa + pb + pb);\n    float w = length(pa + pb + pb + pb);\n    return vec4(x, y, z, w);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float t, float t2 )\n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float x = length(pa);\n    float y = length(pa + pb);\n    float z = length(pa + pb + pb);\n    float w = length(pa + pb + pb + pb);\n    return vec4(x, y, z, w);\n}\n\nvec4 paSegment( in", "\n    vec2 x = abs(p) - b;\n    float y = length(x);\n    float z = y + r;\n    float w = sdf(z);\n    return vec4(x, y, z, w);\n}\n\nvec4 paSphere( in vec2 p,\n               in vec2 b, in float r,\n               in float s )\n{\n    vec2 x = abs(p) - b;\n    float y = length(x);\n    float z = y - r;\n    float w = sdf(z);\n    return vec4(x, y, z, w);\n}\n\nvec4 paCylinder( in vec2 p,\n                 in vec2 b, in float r,\n                 in float s )\n{\n    vec2 x = abs(p) - b;\n    float y = length(x);\n    float z = y - r;\n    float w = sdf(z);\n    return vec4(x, y, z, w);\n}\n\nvec4 paCone( in vec2 p,\n             in vec2 b, in float r,\n             in float s )\n{\n    vec2 x = abs(p) - b;\n    float y = length(x);\n    float z = y - r;\n    float w = sdf(z);\n    return vec4(x, y, z, w);\n}\n\nvec4 paCapsule( in vec2 p,\n                in vec2 b, in float r,\n                in float s )\n{\n    vec2 x = abs(p) - b;\n    float y = length(x);\n    float z = y - r;\n    float w = sdf(z);\n    return vec4(x, y, z, w);\n}\n\nvec4 paCone( in vec2 p,\n             in vec2 b, in float r,\n             in float s )\n{\n    vec2 x = abs(p) - b;\n    float y = length(x);\n    float z = y - r;\n    float w = sdf(z);\n    return vec4(x, y, z, w);\n}\n\nvec4 paCone(", "\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.0, b);\n}\n\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    return vec3(length(p) - r);\n}\n\nvec3 sdgCapsule( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.0, b) - r;\n}\n\nvec3 sdgCylinder( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.0, b) - r;\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.0, b) - r;\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.0, b) - r;\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in vec2 r, in float a )\n{\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.0, b) - r;\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in vec2 r, in float a, in float c )\n{\n    vec2 d = abs(p) - b;\n    return min(d, max(d, 0.0)) + clamp(d, 0.", "\n    float x = length(p);\n    float y = x - r;\n    float z = y - band;\n    float w = z - band;\n    return vec4(x,y,z,w);\n}\n\nvec4 paSquare( in vec2 p, float r, float band )\n{\n    float x = length(p);\n    float y = x - r;\n    float z = y - band;\n    float w = z - band;\n    return vec4(x,y,z,w);\n}\n\nvec4 paRectangle( in vec2 p, float w, float h, float band )\n{\n    float x = length(p);\n    float y = x - w;\n    float z = y - h;\n    float w = z - band;\n    return vec4(x,y,z,w);\n}\n\nvec4 paTriangle( in vec2 p, float a, float b, float c, float band )\n{\n    float x = length(p);\n    float y = x - a;\n    float z = y - b;\n    float w = z - c;\n    return vec4(x,y,z,w);\n}\n\nvec4 paTrapezoid( in vec2 p, float a, float b, float c, float d, float band )\n{\n    float x = length(p);\n    float y = x - a;\n    float z = y - b;\n    float w = z - c;\n    float w2 = w - d;\n    return vec4(x,y,z,w2);\n}\n\nvec4 paParallelogram( in vec2 p, float a, float b, float c, float d, float band )\n{\n    float x = length(p);\n    float y = x - a;\n    float z = y - b;\n    float w = z - c;\n    float w2 = w - d;\n    return vec4(x,y,z,w2);\n}\n\nvec4 paPentagon( in vec2 p, float a, float b, float c, float d, float e, float band )\n{\n    float x = length(p", "\n    vec2 d = p - verts[0];\n    float t = dot( d, d );\n    for( int i = 1; i < 5; i++ )\n    {\n        d = p - verts[i];\n        float s = dot( d, d );\n        if( s > t )\n            return sdLine( p, verts[i-1], verts[i], r );\n        t = s;\n    }\n    return sdLine( p, verts[4], verts[0], r );\n}\n\nvec3 sdPoly3( in vec2 p, vec2 verts[5], in float r )\n{\n    vec2 d = p - verts[0];\n    float t = dot( d, d );\n    for( int i = 1; i < 5; i++ )\n    {\n        d = p - verts[i];\n        float s = dot( d, d );\n        if( s > t )\n            return sdLine3( p, verts[i-1], verts[i], r );\n        t = s;\n    }\n    return sdLine3( p, verts[4], verts[0], r );\n}\n\nvec3 sdPoly3( in vec2 p, vec2 verts[5], in float r, in vec3 col )\n{\n    vec2 d = p - verts[0];\n    float t = dot( d, d );\n    for( int i = 1; i < 5; i++ )\n    {\n        d = p - verts[i];\n        float s = dot( d, d );\n        if( s > t )\n            return sdLine3( p, verts[i-1], verts[i], r, col );\n        t = s;\n    }\n    return sdLine3( p, verts[4], verts[0], r, col );\n}\n\nvec3 sdPoly3( in vec2 p, vec2 verts[5], in float r, in vec3 col, in vec3 col2 )\n{\n    ", "\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n\n    float a1 = 0.0;\n    float b1 = 0.0;\n    float c1 = 0.0;\n    float d1 = 0.0;\n    float e1 = 0.0;\n    float f1 = 0.0;\n    float g1 = 0.0;\n    float h1 = 0.0;\n    float i1 = 0.0;\n    float j1 = 0.0;\n    float k1 = 0.0;\n    float l1 = 0.0;\n    float m1 = 0.0;\n    float n1 = 0.0;\n    float o1 = 0.0;\n    float p1 = 0.0;\n    float q1 = 0.0;\n    float r1 = 0.0;\n    ", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ba_ba = ba / length(ba);\n    vec2 ba_pa = ba_pa / length(ba_pa);\n    vec2 ba_pa_ba = ba_pa_ba / length(ba_pa_ba);\n    vec2 ba_pa_ba_pa = ba_pa_ba_pa / length(ba_pa_ba_pa);\n    vec2 ba_pa_ba_pa_pa = ba_pa_ba_pa_pa / length(ba_pa_ba_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa = ba_pa_ba_pa_pa_pa / length(ba_pa_ba_pa_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa_pa = ba_pa_ba_pa_pa_pa_pa / length(ba_pa_ba_pa_pa_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa_pa_pa = ba_pa_ba_pa_pa_pa_pa_pa / length(ba_pa_ba_pa_pa_pa_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa_pa_pa_pa = ba_pa_ba_pa_pa_pa_pa_pa_pa / length(ba_pa_ba_pa_pa_pa_pa_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa_pa_pa_pa_pa = ba_pa_ba_pa_pa_pa_pa_pa_pa_pa / length(ba_pa_ba_pa_pa_pa_pa_pa_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa_pa_pa_pa_pa_pa = ba_pa_ba_pa_pa_pa_pa_pa_pa_pa_pa / length(ba_pa_ba_pa_pa_pa_pa_pa_pa_pa_pa);\n    vec2 ba_pa_ba_pa_pa_pa_pa_pa_pa_pa_pa_pa =", "\n    vec2 q = abs(p.x)-abs(p.y);\n    float d = length(q);\n    float s = clamp(d,0.0,r);\n    float t = clamp(d-r,0.0,r);\n    float u = clamp(d+r,0.0,r);\n    float v = clamp(d+r,0.0,r);\n    float w = clamp(d-r,0.0,r);\n    float x = clamp(d-r,0.0,r);\n    float y = clamp(d+r,0.0,r);\n    float z = clamp(d+r,0.0,r);\n    float a = clamp(d-r,0.0,r);\n    float b = clamp(d+r,0.0,r);\n    float c = clamp(d+r,0.0,r);\n    float d = clamp(d-r,0.0,r);\n    float e = clamp(d+r,0.0,r);\n    float f = clamp(d+r,0.0,r);\n    float g = clamp(d-r,0.0,r);\n    float h = clamp(d+r,0.0,r);\n    float i = clamp(d+r,0.0,r);\n    float j = clamp(d-r,0.0,r);\n    float k = clamp(d+r,0.0,r);\n    float l = clamp(d-r,0.0,r);\n    float m = clamp(d+r,0.0,r);\n    float n = clamp(d-r,0.0,r);\n    float o = clamp(d+r,0.0,r);\n    float p = clamp(d-r,0.0,r);\n    float q = clamp(d+r,0.0,r);\n    float r = clamp(d-r,0.0,r);\n    float s = clamp(d+r,0.0,r);\n    float t = clamp(d-r,0.0,r);\n    float u = clamp(d+r,", "\n  vec3 q = X * p;\n  vec3 v = q.xyz - p.xyz;\n  vec3 w = vec3(0.0, 0.0, 1.0);\n  vec3 u = cross(w, v);\n  vec3 v2 = cross(v, u);\n  vec3 u2 = cross(u, v);\n  vec3 v3 = cross(v, v2);\n  vec3 u3 = cross(u, u2);\n  vec3 v4 = cross(v, v3);\n  vec3 u4 = cross(u, u3);\n  vec3 v5 = cross(v, v4);\n  vec3 u5 = cross(u, u4);\n  vec3 v6 = cross(v, v5);\n  vec3 u6 = cross(u, u5);\n  vec3 v7 = cross(v, v6);\n  vec3 u7 = cross(u, u6);\n  vec3 v8 = cross(v, v7);\n  vec3 u8 = cross(u, u7);\n  vec3 v9 = cross(v, v8);\n  vec3 u9 = cross(u, u8);\n  vec3 v10 = cross(v, v9);\n  vec3 u10 = cross(u, u9);\n  vec3 v11 = cross(v, v10);\n  vec3 u11 = cross(u, u10);\n  vec3 v12 = cross(v, v11);\n  vec3 u12 = cross(u, u11);\n  vec3 v13 = cross(v, v12);\n  vec3 u13 = cross(u, u12);\n  vec3 v14 = cross(v, v13);\n  vec3 u14 = cross(u, u13);\n  vec3 v15 = cross(v, v14);\n  vec3 u15 = cross(u, u14);\n  vec3 v16 = cross(v, v15);\n  vec3 u16 = cross(u, u15);\n  vec3 v17 = cross", "\n    return a / b;\n}\n\n//multiply a by b\nvec3 mul(vec3 a, vec3 b) {\n    return a * b;\n}\n\n//add a to b\nvec3 add(vec3 a, vec3 b) {\n    return a + b;\n}\n\n//subtract b from a\nvec3 sub(vec3 a, vec3 b) {\n    return a - b;\n}\n\n//return the dot product of a and b\nfloat dot(vec3 a, vec3 b) {\n    return dot(a, b);\n}\n\n//return the cross product of a and b\nvec3 cross(vec3 a, vec3 b) {\n    return cross(a, b);\n}\n\n//return the length of a\nfloat length(vec3 a) {\n    return length(a);\n}\n\n//return the squared length of a\nfloat lengthSq(vec3 a) {\n    return length(a) * length(a);\n}\n\n//return the distance between a and b\nfloat distance(vec3 a, vec3 b) {\n    return length(sub(b, a));\n}\n\n//return the squared distance between a and b\nfloat distanceSq(vec3 a, vec3 b) {\n    return lengthSq(sub(b, a));\n}\n\n//return the angle between a and b\nfloat angle(vec3 a, vec3 b) {\n    return acos(dot(a, b) / (length(a) * length(b)));\n}\n\n//return the squared angle between a and b\nfloat angleSq(vec3 a, vec3 b) {\n    return dot(a, b) * dot(a, b) / (length(a) * length(b));\n}\n\n//return the cross product of a and b\nvec3 cross(vec3 a, vec3 b) {\n    return cross(a, b);\n}\n\n//return the cross product of a and b\nvec3 cross(vec3 a, vec3 b) {\n    return cross(a, b);\n}\n\n//return the cross product of a and b\nvec3 cross(vec3 a, vec3 b) {\n", "\n\treturn vec3(p.x, cos(a) * p.y, sin(a) * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n\treturn vec3(cos(a) * p.x, -sin(a) * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 axis, float a)\n{\n\treturn RotateX(RotateY(RotateZ(p, a), a), a);\n}\n\nvec3 Rotate(vec3 p, vec3 axis, vec3 a)\n{\n\treturn RotateX(RotateY(RotateZ(p, a.x), a.y), a.z);\n}\n\nvec3 Rotate(vec3 p, vec3 axis, vec3 a, vec3 b)\n{\n\treturn RotateX(RotateY(RotateZ(p, a.x), a.y), a.z) + b;\n}\n\nvec3 Rotate(vec3 p, vec3 axis, vec3 a, vec3 b, vec3 c)\n{\n\treturn RotateX(RotateY(RotateZ(p, a.x), a.y), a.z) + b + c;\n}\n\nvec3 Rotate(vec3 p, vec3 axis, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\treturn RotateX(RotateY(RotateZ(p, a.x), a.y), a.z) + b + c + d;\n}\n\nvec3 Rotate(vec3 p, vec3 axis, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n\treturn RotateX(RotateY(RotateZ(p, a.x), a.y), a.z) + b + c + d + e;\n}\n\nvec3 Rotate(vec3 p, vec3 axis, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f)\n{\n\treturn RotateX(RotateY(Rot", "\n    return 1.0f - pow(x / R, 3.0f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 3.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0f);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat ExponentialFalloff(float x, float R)\n{\n    return 1.0f - pow(x / R, 2.0", "\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R", "\n\tfloat f = 1.0f / (1.0f + e * (R * R));\n\treturn f * (a + b * f);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k)\n{\n\tfloat f = 1.0f / (1.0f + e * (R * R));\n\treturn f * (a + b * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f * f", "\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * (1.0 - d / R);\n}\n\n// Primitives", "\n    float d = length(a - b);\n    float d2 = d * d;\n    float d4 = d2 * d2;\n    float d6 = d4 * d2;\n    float d8 = d6 * d2;\n    float d10 = d8 * d2;\n    float d12 = d10 * d2;\n    float d14 = d12 * d2;\n    float d16 = d14 * d2;\n    float d18 = d16 * d2;\n    float d20 = d18 * d2;\n    float d22 = d20 * d2;\n    float d24 = d22 * d2;\n    float d26 = d24 * d2;\n    float d28 = d26 * d2;\n    float d30 = d28 * d2;\n    float d32 = d30 * d2;\n    float d34 = d32 * d2;\n    float d36 = d34 * d2;\n    float d38 = d36 * d2;\n    float d40 = d38 * d2;\n    float d42 = d40 * d2;\n    float d44 = d42 * d2;\n    float d46 = d44 * d2;\n    float d48 = d46 * d2;\n    float d50 = d48 * d2;\n    float d52 = d50 * d2;\n    float d54 = d52 * d2;\n    float d56 = d54 * d2;\n    float d58 = d56 * d2;\n    float d60 = d58 * d2;\n    float d62 = d60 * d2;\n    float d64 = d62 * d2;\n    float d66 = d64 * d2;\n    float d68 = d66 * d2;\n    float d70 = d68 * d2;\n    float d72 = d70 * d2;\n    float d74 = d", "\n    float d = length(p);\n    return -1.0 / d;\n}\n\n// Sphere\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Torus\nfloat Torus(vec3 p, float R, float r)\n{\n    float z = length(p.xz);\n    float d = length(p.y);\n    return length(vec2(z, d)) - r;\n}\n\n// Cylinder\nfloat Cylinder(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n{\n    float d = length(p.y);\n    return length(p.xz) - r;\n}\n\n// Cone\nfloat Cone(vec3 p, float h, float r)\n", "\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    return length(cross(ab, ac)) / length(ab);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    return length(cross(ab, cross(ac, ad))) / length(ab);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    vec3 ae = e - a;\n    return length(cross(ab, cross(ac, cross(ad, ae)))) / length(ab);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    vec3 ae = e - a;\n    vec3 af = f - a;\n    return length(cross(ab, cross(ac, cross(ad, cross(ae, af))))) / length(ab);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    vec3 ae = e - a;\n    vec3 af = f - a;\n    vec3 ag = g - a;\n    return length(cross(ab, cross(ac, cross(ad, cross(ae, cross(af, ag)))))) / length(ab);\n}\n\n//", "\n\tvec3 n = vec3(0.0);\n\tvec3 e = vec3(0.0);\n\tvec3 e1 = vec3(0.0);\n\tvec3 e2 = vec3(0.0);\n\tvec3 e3 = vec3(0.0);\n\tvec3 e4 = vec3(0.0);\n\tvec3 e5 = vec3(0.0);\n\tvec3 e6 = vec3(0.0);\n\tvec3 e7 = vec3(0.0);\n\tvec3 e8 = vec3(0.0);\n\tvec3 e9 = vec3(0.0);\n\tvec3 e10 = vec3(0.0);\n\tvec3 e11 = vec3(0.0);\n\tvec3 e12 = vec3(0.0);\n\tvec3 e13 = vec3(0.0);\n\tvec3 e14 = vec3(0.0);\n\tvec3 e15 = vec3(0.0);\n\tvec3 e16 = vec3(0.0);\n\tvec3 e17 = vec3(0.0);\n\tvec3 e18 = vec3(0.0);\n\tvec3 e19 = vec3(0.0);\n\tvec3 e20 = vec3(0.0);\n\tvec3 e21 = vec3(0.0);\n\tvec3 e22 = vec3(0.0);\n\tvec3 e23 = vec3(0.0);\n\tvec3 e24 = vec3(0.0);\n\tvec3 e25 = vec3(0.0);\n\tvec3 e26 = vec3(0.0);\n\tvec3 e27 = vec3(0.0);\n\tvec3 e28 = vec3(0.0);\n\tvec3 e29 = vec3(0.0);\n\tvec3 e30 = vec3(0.0);\n\tvec3 e31 = vec3(0.0);\n\tvec3 e32 = vec3(0.0);\n\tvec3 e33 = vec3(0.0);", "\n\th = false;\n\ts = 0;\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat r = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat r2 = 0.0;\n\tfloat r3 = 0.0;\n\tfloat r4 = 0.0;\n\tfloat r5 = 0.0;\n\tfloat r6 = 0.0;\n\tfloat r7 = 0.0;\n\tfloat r8 = 0.0;\n\tfloat r9 = 0.0;\n\tfloat r10 = 0.0;\n\tfloat r11 = 0.0;\n\tfloat r12 = 0.0;\n\tfloat r13 = 0.0;\n\tfloat r14 = 0.0;\n\tfloat r15 = 0.0;\n\tfloat r16 = 0.0;\n\tfloat r17 = 0.0;\n\tfloat r18 = 0.0;\n\tfloat r19 = 0.0;\n\tfloat r20 = 0.0;\n\tfloat r21 = 0.0;\n\tfloat r22 = 0.0;\n\tfloat r23 = 0.0;\n\tfloat r24 = 0.0;\n\tfloat r25 = 0.0;\n\tfloat r26 = 0.0;\n\tfloat r27 = 0.0;\n\tfloat r28 = 0.0;\n\tfloat r29 = 0.0;\n\tfloat r30 = 0.0;\n\tfloat r31 = 0.0;\n\tfloat r32 = 0.0;\n\tfloat r33 = 0.0;\n\tfloat r34 = 0.0;\n\tfloat r35 = 0.0;\n\tfloat r36 = 0.0;\n\tfloat r37 =", "\n    h = false;\n    s = 0;\n    float t = 0.0;\n    float d = 0.0;\n    float ht = 0.0;\n    float hdt = 0.0;\n    float hdt2 = 0.0;\n    float hdt3 = 0.0;\n    float hdt4 = 0.0;\n    float hdt5 = 0.0;\n    float hdt6 = 0.0;\n    float hdt7 = 0.0;\n    float hdt8 = 0.0;\n    float hdt9 = 0.0;\n    float hdt10 = 0.0;\n    float hdt11 = 0.0;\n    float hdt12 = 0.0;\n    float hdt13 = 0.0;\n    float hdt14 = 0.0;\n    float hdt15 = 0.0;\n    float hdt16 = 0.0;\n    float hdt17 = 0.0;\n    float hdt18 = 0.0;\n    float hdt19 = 0.0;\n    float hdt20 = 0.0;\n    float hdt21 = 0.0;\n    float hdt22 = 0.0;\n    float hdt23 = 0.0;\n    float hdt24 = 0.0;\n    float hdt25 = 0.0;\n    float hdt26 = 0.0;\n    float hdt27 = 0.0;\n    float hdt28 = 0.0;\n    float hdt29 = 0.0;\n    float hdt30 = 0.0;\n    float hdt31 = 0.0;\n    float hdt32 = 0.0;\n    float hdt33 = 0.0;\n    float hdt34 = 0.0;\n    float hdt35 = 0.0;\n    float hdt36 = 0.0;\n    float hdt37 = 0", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float n = 0.0;\n    float d = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float f = 0.0;\n    float f2 = 0.0;\n    float f3 = 0.0;\n    float f4 = 0.0;\n    float f5 = 0.0;\n    float f6 = 0.0;\n    float f7 = 0.0;\n    float f8 = 0.0;\n    float f9 = 0.0;\n    float f10 = 0.0;\n    float f11 = 0.0;\n    float f12 = 0.0;\n    float f13 = 0.0;\n    float f14 = 0.0;\n    float f15 = 0.0;\n    float f16 = 0.0;\n    float f17 = 0.0;\n    float f18 = 0.0;\n    float f19 = 0.0;\n    float f20 = 0.0;\n    float f21 = 0.0;\n    float f22 = 0.0;\n    float f23 = 0.0;\n    float f24 = 0.0;\n    float f25 = 0.0;\n    float f26 = 0.0;\n    float f27 = 0.0;\n    float f28 = 0.0;\n    float f29 = 0.0;\n    float f30 = 0.0;\n    float f31 = 0.0;\n    float f32 = 0.0;\n    float f33 = 0.0;\n    float f34 = 0.0;\n    float f35 = 0.0;\n    float f36 = 0.0;\n    float f37 =", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = dot(pa, ba) / dot(ba, ba);\n    return length(pa) - r - h;\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = dot(pa, ba) / dot(ba, ba);\n    return length(pa) - r - h;\n}\n\n// arbitrary orientation\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    vec3 pa = p - a;\n    return length(pa) - r;\n}\n\n// arbitrary orientation\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = dot(pa, ba) / dot(ba, ba);\n    return length(pa) - r - h;\n}\n\n// arbitrary orientation\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, vec3 c, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    float h = dot(pa, ba) / dot(ba, ba);\n    float h2 = dot(pa, ca) / dot(ca, ca);\n    return length(pa) - r - h - h2;\n}\n\n// arbitrary orientation\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 da = d - a;\n    float h = dot(pa, ba) / dot(ba, ba);\n    float h2 = dot(pa, ca) / dot(ca, ca);\n    float h3 = dot(pa, da) / dot(da,", "\n    vec3 d = ro + rd * dot( rad, rd );\n    vec3 r = d - ro;\n    vec3 b = r - rad;\n    vec3 c = r - rad * 2.0;\n    vec3 e = c - b;\n    vec3 f = c - b * 2.0;\n    vec3 g = c - b * 3.0;\n    vec3 h = c - b * 4.0;\n    vec3 i = c - b * 5.0;\n    vec3 j = c - b * 6.0;\n    vec3 k = c - b * 7.0;\n    vec3 l = c - b * 8.0;\n    vec3 m = c - b * 9.0;\n    vec3 n = c - b * 10.0;\n    vec3 o = c - b * 11.0;\n    vec3 p = c - b * 12.0;\n    vec3 q = c - b * 13.0;\n    vec3 r = c - b * 14.0;\n    vec3 s = c - b * 15.0;\n    vec3 t = c - b * 16.0;\n    vec3 u = c - b * 17.0;\n    vec3 v = c - b * 18.0;\n    vec3 w = c - b * 19.0;\n    vec3 x = c - b * 20.0;\n    vec3 y = c - b * 21.0;\n    vec3 z = c - b * 22.0;\n    vec3 aa = c - b * 23.0;\n    vec3 ab = c - b * 24.0;\n    vec3 ac = c - b * 25.0;\n    vec3 ad = c - b * 26.0;\n    vec3 ae = c - b * 27.0;\n    vec3 af = c - b * 28.0;\n    vec3 ag = c - b * 29.0;\n    vec3 ah = c", "\n  return coord * 0.5 + 0.5;\n}\n\n// compute the distance between two points\nfloat distance(vec2 a, vec2 b) {\n  return length(a - b);\n}\n\n// compute the distance between a point and a line\nfloat distance_line_point(vec2 line_point, vec2 line_dir, vec2 point) {\n  vec2 line_dir_normalized = normalize(line_dir);\n  vec2 line_point_to_point = point - line_point;\n  vec2 closest_point_on_line = line_point + line_dir_normalized * dot(line_dir_normalized, line_point_to_point);\n  return distance(point, closest_point_on_line);\n}\n\n// compute the distance between a point and a line segment\nfloat distance_line_segment_point(vec2 line_point_a, vec2 line_point_b, vec2 point) {\n  vec2 line_dir = normalize(line_point_b - line_point_a);\n  vec2 line_point_to_point = point - line_point_a;\n  vec2 closest_point_on_line = line_point_a + line_dir * dot(line_dir, line_point_to_point);\n  vec2 closest_point_on_line_to_point = closest_point_on_line - line_point_to_point;\n  float closest_point_on_line_to_point_length = length(closest_point_on_line_to_point);\n  float closest_point_on_line_to_point_length_squared = closest_point_on_line_to_point_length * closest_point_on_line_to_point_length;\n  float closest_point_on_line_to_point_length_squared_squared = closest_point_on_line_to_point_length_squared * closest_point_on_line_to_point_length_squared;\n  float closest_point_on_line_to_point_length_squared_squared_squared = closest_point_on_line_to_point_length_squared_squared * closest_point_on_line_to", "\n    vec2 d = p - q;\n    float a = length(d);\n    float b = length(p - q.xy);\n    float c = length(p - q.zw);\n    float s = (a + b + c) * 0.5;\n    float A = a * a * (b + c - a) * 0.5;\n    float B = b * b * (a + c - b) * 0.5;\n    float C = c * c * (a + b - c) * 0.5;\n    float s2 = s * s;\n    float s3 = s * s * s;\n    float A2 = A * A;\n    float B2 = B * B;\n    float C2 = C * C;\n    float A3 = A * A2;\n    float B3 = B * B2;\n    float C3 = C * C2;\n    float A4 = A3 * A;\n    float B4 = B3 * B;\n    float C4 = C3 * C;\n    float A5 = A4 * A;\n    float B5 = B4 * B;\n    float C5 = C4 * C;\n    float A6 = A5 * A;\n    float B6 = B5 * B;\n    float C6 = C5 * C;\n    float A7 = A6 * A;\n    float B7 = B6 * B;\n    float C7 = C6 * C;\n    float A8 = A7 * A;\n    float B8 = B7 * B;\n    float C8 = C7 * C;\n    float A9 = A8 * A;\n    float B9 = B8 * B;\n    float C9 = C8 * C;\n    float A10 = A9 * A;\n    float B10 = B9 * B;\n    float C10 = C9 * C;\n    float A11 = A10 * A;\n    float B11 = B10 * B;\n    float C11 = C10 * C;\n    float A12 = A11 * A;\n    float B12 = B11 * B", "\n    float s = 1.0 - r * r;\n    float t = s * s;\n    float u = s * s;\n    float v = s * s;\n    float w = s * s;\n    float x = s * s;\n    float y = s * s;\n    float z = s * s;\n    float a = s * s;\n    float b = s * s;\n    float c = s * s;\n    float d = s * s;\n    float e = s * s;\n    float f = s * s;\n    float g = s * s;\n    float h = s * s;\n    float i = s * s;\n    float j = s * s;\n    float k = s * s;\n    float l = s * s;\n    float m = s * s;\n    float n = s * s;\n    float o = s * s;\n    float p = s * s;\n    float q = s * s;\n    float r = s * s;\n    float s = s * s;\n    float t = s * s;\n    float u = s * s;\n    float v = s * s;\n    float w = s * s;\n    float x = s * s;\n    float y = s * s;\n    float z = s * s;\n    float a = s * s;\n    float b = s * s;\n    float c = s * s;\n    float d = s * s;\n    float e = s * s;\n    float f = s * s;\n    float g = s * s;\n    float h = s * s;\n    float i = s * s;\n    float j = s * s;\n    float k = s * s;\n    float l = s * s;\n    float m = s * s;\n    float n = s * s;\n    float o = s * s;\n    float p = s * s;\n    float q = s * s;\n    float r = s * s;\n    float s = s * s;\n    float t = s * s;\n    float u = s * s;\n    float v = s * s;\n    float", "\n    vec2 q = p - c;\n    float d = length(q);\n    float a = atan(q.y, q.x);\n    float s = sin(a);\n    float c = cos(a);\n    float t = c * r;\n    float u = s * r;\n    return vec3(t, u, d);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a )\n{\n    vec2 q = p - c;\n    float d = length(q);\n    float s = sin(a);\n    float c = cos(a);\n    float t = c * r;\n    float u = s * r;\n    return vec3(t, u, d);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a, in float b )\n{\n    vec2 q = p - c;\n    float d = length(q);\n    float s = sin(a);\n    float c = cos(a);\n    float t = c * r;\n    float u = s * r;\n    return vec3(t, u, d);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202", "\n    vec2 d = p - v[0];\n    vec2 d1 = v[1] - v[0];\n    vec2 d2 = v[2] - v[0];\n    vec2 d12 = d1 + d2;\n    vec2 d1d2 = d1 - d2;\n    vec2 d1d = d1 - d;\n    vec2 d2d = d2 - d;\n    vec2 d1d2d = d1d2 + d;\n    vec2 d1d2d1 = d1d2d + d1;\n    vec2 d1d2d2 = d1d2d + d2;\n    vec2 d1d2d12 = d1d2d1 + d1;\n    vec2 d1d2d12d = d1d2d12 + d;\n    vec2 d1d2d12d1 = d1d2d12d + d1;\n    vec2 d1d2d12d2 = d1d2d12d + d2;\n    vec2 d1d2d12d12 = d1d2d12d1 + d1;\n    vec2 d1d2d12d12d = d1d2d12d12 + d;\n    vec2 d1d2d12d12d1 = d1d2d12d12d + d1;\n    vec2 d1d2d12d12d2 = d1d2d12d12d + d2;\n    vec2 d1d2d12d12d12 = d1d2d12d12d1 + d1;\n    vec2 d1d2d12d12d12d = d1d2d12d12d12 + d1;\n    vec2 d1d2d12d12d12d2 = d1d2d12d12d12 + d2;\n    vec2 d1d2d12d12d12d1 = d1d2d12d12d", "\n    vec2 q = vec2( p.x, p.y );\n    vec2 r = vec2( ra, rb );\n    vec2 s = vec2( sca.x, sca.y );\n    vec2 t = vec2( scb.x, scb.y );\n    vec2 u = vec2( s.x * t.x, s.y * t.y );\n    vec2 v = vec2( s.x * t.y, s.y * t.x );\n    vec2 w = vec2( s.x * t.y, s.y * t.y );\n    vec2 x = vec2( q.x, q.y );\n    vec2 y = vec2( q.x, q.y );\n    vec2 z = vec2( q.x, q.y );\n    vec2 a = vec2( 0.0, 0.0 );\n    vec2 b = vec2( 0.0, 0.0 );\n    vec2 c = vec2( 0.0, 0.0 );\n    vec2 d = vec2( 0.0, 0.0 );\n    vec2 e = vec2( 0.0, 0.0 );\n    vec2 f = vec2( 0.0, 0.0 );\n    vec2 g = vec2( 0.0, 0.0 );\n    vec2 h = vec2( 0.0, 0.0 );\n    vec2 i = vec2( 0.0, 0.0 );\n    vec2 j = vec2( 0.0, 0.0 );\n    vec2 k = vec2( 0.0, 0.0 );\n    vec2 l = vec2( 0.0, 0.0 );\n    vec2 m = vec2( 0.0, 0.0 );\n    vec2 n = vec2( 0.0, 0.0 );\n    vec2 o = vec2( 0.0, 0.0 );\n    vec2 p = vec2( 0.0, 0.0 );\n    vec2 q = vec2( 0.0", "\n    return dot( a, b );\n}\n\nfloat cro( in vec3 a, in vec3 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec4 a, in vec4 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec2 a, in vec3 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec3 a, in vec2 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec2 a, in vec4 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec4 a, in vec2 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec3 a, in vec3 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec4 a, in vec4 b ) {\n    return dot( a, b );\n}\n\nfloat cro( in vec2 a, in vec3 b, in vec3 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec3 a, in vec2 b, in vec3 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec4 a, in vec2 b, in vec3 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec2 a, in vec4 b, in vec3 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec3 a, in vec4 b, in vec3 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec4 a, in vec2 b, in vec4 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec2 a, in vec4 b, in vec4 c ) {\n    return dot( a, b ) + dot( a, c );\n}\n\nfloat cro( in vec3 a, in vec", "\n    vec2 q = p / ab;\n    vec2 r = q * q;\n    vec2 r2 = r * r;\n    vec2 r3 = r2 * r;\n    vec2 r4 = r3 * r;\n    vec2 r5 = r4 * r;\n    vec2 r6 = r5 * r;\n    vec2 r7 = r6 * r;\n    vec2 r8 = r7 * r;\n    vec2 r9 = r8 * r;\n    vec2 r10 = r9 * r;\n    vec2 r11 = r10 * r;\n    vec2 r12 = r11 * r;\n    vec2 r13 = r12 * r;\n    vec2 r14 = r13 * r;\n    vec2 r15 = r14 * r;\n    vec2 r16 = r15 * r;\n    vec2 r17 = r16 * r;\n    vec2 r18 = r17 * r;\n    vec2 r19 = r18 * r;\n    vec2 r20 = r19 * r;\n    vec2 r21 = r20 * r;\n    vec2 r22 = r21 * r;\n    vec2 r23 = r22 * r;\n    vec2 r24 = r23 * r;\n    vec2 r25 = r24 * r;\n    vec2 r26 = r25 * r;\n    vec2 r27 = r26 * r;\n    vec2 r28 = r27 * r;\n    vec2 r29 = r28 * r;\n    vec2 r30 = r29 * r;\n    vec2 r31 = r30 * r;\n    vec2 r32 = r31 * r;\n    vec2 r33 = r32 * r;\n    vec2 r34 = r33 * r;\n    vec2 r35 = r34 * r;\n    vec2 r36 = r35 * r;\n    vec2 r37 = r36 * r;\n    vec2 r3", "\n    vec3 q = vec3( length( p.xz ) - ra, p.y, p.z );\n    float s = length( q );\n    float t = dot( q, q );\n    float d = s - rb;\n    float e = 1.0 - clamp( d, 0.0, 1.0 );\n    float f = 1.0 - clamp( t, 0.0, 1.0 );\n    float g = 1.0 - clamp( s, 0.0, 1.0 );\n    float h = 1.0 - clamp( d * d, 0.0, 1.0 );\n    float i = 1.0 - clamp( t * t, 0.0, 1.0 );\n    float j = 1.0 - clamp( s * s, 0.0, 1.0 );\n    float k = 1.0 - clamp( d * d * d, 0.0, 1.0 );\n    float l = 1.0 - clamp( t * t * t, 0.0, 1.0 );\n    float m = 1.0 - clamp( s * s * s, 0.0, 1.0 );\n    float n = 1.0 - clamp( d * d * d * d, 0.0, 1.0 );\n    float o = 1.0 - clamp( t * t * t * t, 0.0, 1.0 );\n    float p = 1.0 - clamp( s * s * s * s, 0.0, 1.0 );\n    float q = 1.0 - clamp( d * d * d * d * d, 0.0, 1.0 );\n    float r = 1.0 - clamp( t * t * t * t * t, 0.0, 1.0 );\n    float s = 1.0 - clamp( s * s * s * s * s, 0.0, 1.0 );\n    float t = 1.0 - clamp( d * d * d * d * d * d, 0.0, 1.0 );\n    ", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float d = dot( pa, ba );\n    float r2 = r * r;\n    float r2ba = r2 * dot( ba, ba );\n    float r2pa = r2 * dot( pa, pa );\n    float r2ab = r2 * dot( ba, ba );\n    float r2paab = r2 * dot( pa, ba );\n    float r2paba = r2 * dot( ba, pa );\n    float r2paabba = r2 * dot( ba, ba );\n    float r2paabbaab = r2 * dot( ba, ba );\n    float r2paabbaaba = r2 * dot( ba, pa );\n    float r2paabbaabba = r2 * dot( ba, ba );\n    float r2paabbaabbaab = r2 * dot( ba, ba );\n    float r2paabbaabbaaba = r2 * dot( ba, pa );\n    float r2paabbaabbaabba = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaab = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaaba = r2 * dot( ba, pa );\n    float r2paabbaabbaabbaabba = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaabbaab = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaabbaaba = r2 * dot( ba, pa );\n    float r2paabbaabbaabbaabbaabba = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaabbaabbaab = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaabbaabbaaba = r2 * dot( ba, pa );\n    float r2paabbaabbaabbaabbaabbaabba = r2 * dot( ba, ba );\n    float r2paabbaabbaabbaabbaabbaabbaab = r", "\n    vec2 q = abs(p) - vec2(wi,he);\n    float d = min(q.x,q.y);\n    float s = max(0.0,d);\n    return s;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p) - vec2(wi,he);\n    float d = min(q.x,q.y);\n    float s = max(0.0,d);\n    return s;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p) - vec2(wi,he);\n    float d = min(q.x,q.y);\n    float s = max(0.0,d);\n    return s;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p) - vec2(wi,he);\n    float d = min(q.x,q.y);\n    float s = max(0.0,d);\n    return s;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_5( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs(p) - vec2(wi,he);\n    float d = min(q.x,q.y);\n    float s = max(0.0,d);\n    return s;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_6( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs", "\n    vec2 w = vec2( wi, he );\n    vec2 w2 = w * w;\n    vec2 w3 = w2 * w;\n    vec2 w4 = w3 * w;\n    vec2 w5 = w4 * w;\n    vec2 w6 = w5 * w;\n    vec2 w7 = w6 * w;\n    vec2 w8 = w7 * w;\n    vec2 w9 = w8 * w;\n    vec2 w10 = w9 * w;\n    vec2 w11 = w10 * w;\n    vec2 w12 = w11 * w;\n    vec2 w13 = w12 * w;\n    vec2 w14 = w13 * w;\n    vec2 w15 = w14 * w;\n    vec2 w16 = w15 * w;\n    vec2 w17 = w16 * w;\n    vec2 w18 = w17 * w;\n    vec2 w19 = w18 * w;\n    vec2 w20 = w19 * w;\n    vec2 w21 = w20 * w;\n    vec2 w22 = w21 * w;\n    vec2 w23 = w22 * w;\n    vec2 w24 = w23 * w;\n    vec2 w25 = w24 * w;\n    vec2 w26 = w25 * w;\n    vec2 w27 = w26 * w;\n    vec2 w28 = w27 * w;\n    vec2 w29 = w28 * w;\n    vec2 w30 = w29 * w;\n    vec2 w31 = w30 * w;\n    vec2 w32 = w31 * w;\n    vec2 w33 = w32 * w;\n    vec2 w34 = w33 * w;\n    vec2 w35 = w34 * w;\n    vec2 w36 = w35 * w;\n    vec2 w37 = w36 * w;\n    vec2 w38 = w37 * w", "\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep2D( float p, float c )\n\t{\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep3D( float p, float c )\n\t{\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep4D( float p, float c )\n\t{\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep5D( float p, float c )\n\t{\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep6D( float p, float c )\n\t{\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep7D( float p, float c )\n\t{\n\tfloat r;\n\tr = p;\n\twhile( r < c )\n\t\t{\n\t\tr = r + p;\n\t\t}\n\treturn( r );\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep8D( float p, float c )\n\t{\n", "\n    return a < b? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return a > b? a : b;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float k) {\n    return a < b? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float k) {\n    return a > b? a : b;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float k) {\n    return a < b? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float k) {\n    return a > b? a : b;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float e, float k) {\n    return a < b? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float e, float k) {\n    return a > b? a : b;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float e, float f, float k) {\n    return a < b? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float e, float f, float k) {\n    return a > b? a : b;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float e, float f, float g, float k) {\n    return a < b? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float e, float f,", "\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset) {\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size + offset;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset, vec2 scale) {\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size + offset * scale;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset, vec2 scale, vec2 rot) {\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size + offset * scale * rot;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset, vec2 scale, vec2 rot, vec2 rot2) {\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size + offset * scale * rot + rot2 * rot;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset, vec2 scale, vec2 rot, vec2 rot2, vec2 rot3) {\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size + offset * scale * rot + rot2 * rot + rot3 * rot3;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset, vec2 scale, vec2 rot, vec2 rot2, vec2 rot3, vec2 rot4) {\n  p = fract(p / size);\n  p = p - floor(p / 2.0);\n  return p * size + offset * scale * rot + rot2 * rot + rot3 * rot3 + rot4 * rot4;\n}\n\nvec2 mod2(inout vec2 p,", "\n  vec3 rgb = clamp(abs(mod(c.z + c.y, 1.0) * 6.0 - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * c.x;\n  return c.z < 1.0? rgb : vec3(1.0);\n}\n\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xyw), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 0.0, 3.0);\n  vec4 p = mix(vec4(c.z, K.yw), vec4(c.y, c.zw), step(c.x, c.y));\n  vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), step(p.x, c.x));\n  float d = q.x - min(q.w, q.y);\n  return vec3(q.z + (q.w - q.y) / (6.0 * d + 1.0e-10));\n}\n\nvec3 hsv2rgb(vec", "\n  vec3 o = s.xyz;\n  float r = s.w;\n  vec3 p = ro - o;\n  float b = dot(rd, p);\n  float c = dot(p, p) - r*r;\n  float d = b*b - c;\n  if (d < 0.0) {\n    return vec2(0.0, 0.0);\n  } else {\n    float h = sqrt(d);\n    float t1 = b - h;\n    float t2 = b + h;\n    if (t1 < 0.0) {\n      return vec2(0.0, 0.0);\n    } else if (t2 < 0.0) {\n      return vec2(t1, 0.0);\n    } else {\n      return vec2(min(t1, t2), max(t1, t2));\n    }\n  }\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n  vec3 e0 = v1 - v0;\n  vec3 e1 = v2 - v0;\n  vec3 p = cross(rd, e1);\n  float d = dot(e0, p);\n  if (d < 0.0) {\n    return vec2(0.0, 0.0);\n  }\n  vec3 q = cross(p, rd);\n  float s = dot(q, e1);\n  if (s < 0.0) {\n    return vec2(0.0, 0.0);\n  }\n  float t = dot(q, e0);\n  if (t < 0.0) {\n    return vec2(0.0, 0.0);\n  }\n  float h = s*s - d*t;\n  if (h < 0.0) {\n    return vec2(0.0, 0.0);\n  }\n  return vec2(t, s);\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec", "\n\tvec3 boxMin = -boxSize * 0.5;\n\tvec3 boxMax = boxSize * 0.5;\n\tvec3 tmin = vec3(0.0);\n\tvec3 tmax = vec3(1.0);\n\tvec3 invRd = vec3(1.0) / rd;\n\tvec3 t0 = (boxMin - ro) * invRd;\n\tvec3 t1 = (boxMax - ro) * invRd;\n\ttmin = min(t0, t1);\n\ttmax = max(t0, t1);\n\tvec3 t2 = tmax - tmin;\n\tvec3 t3 = t2 * invRd;\n\tvec3 t = min(t3, vec3(1.0));\n\tvec3 tminInv = vec3(1.0) / tmin;\n\tvec3 t2Inv = t2 * tminInv;\n\tvec3 t3Inv = t3 * tminInv;\n\tvec3 tInv = t3Inv * tminInv;\n\tvec3 tInv2 = tInv * tInv;\n\tvec3 tInv3 = tInv2 * tInv;\n\tvec3 tInv4 = tInv2 * tInv2;\n\tvec3 tInv5 = tInv2 * tInv3;\n\tvec3 tInv6 = tInv3 * tInv3;\n\tvec3 tInv7 = tInv3 * tInv4;\n\tvec3 tInv8 = tInv4 * tInv4;\n\tvec3 tInv9 = tInv4 * tInv5;\n\tvec3 tInv10 = tInv5 * tInv5;\n\tvec3 tInv11 = tInv5 * tInv6;\n\tvec3 tInv12 = tInv6 * tInv6;\n\tvec3 tInv13 = tInv6 * tInv7;\n\tvec3 tInv14 = tInv7 * tInv7;\n\tvec3 tInv15 = tInv7 * tInv8;\n\tvec3 tInv16 = tInv8 * tInv8;\n\tvec3 tInv17 = tInv8 * tInv9;\n\t", "\n\tvec2 e = d/2.0;\n\te1 = p-e;\n\te2 = p+e;\n\te3 = p+vec2(-e.x,e.y);\n\te4 = p+vec2(e.x,-e.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n\tvec2 e = d/2.0;\n\te1 = p-e;\n\te2 = p+e;\n\te3 = p+vec2(-e.x,e.y);\n\te4 = p+vec2(e.x,-e.y);\n\te5 = p+vec2(e.y,e.x);\n\te6 = p+vec2(-e.y,-e.x);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n\tvec2 e = d/2.0;\n\te1 = p-e;\n\te2 = p+e;\n\te3 = p+vec2(-e.x,e.y);\n\te4 = p+vec2(e.x,-e.y);\n\te5 = p+vec2(e.y,e.x);\n\te6 = p+vec2(-e.y,-e.x);\n\te7 = p+vec2(e.x,-e.y);\n\te8 = p+vec2(-e.x,e.y);\n}\n\n", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    return length(pa - ba * t);\n}\n\nvec2 closest_edge(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    return a + ba * t;\n}\n\nvec2 closest_edge(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    float u = dot(pa, ca) / dot(ca, ca);\n    return a + ba * t + ca * u;\n}\n\nvec2 closest_edge(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 da = d - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    float u = dot(pa, ca) / dot(ca, ca);\n    float v = dot(pa, da) / dot(da, da);\n    return a + ba * t + ca * u + da * v;\n}\n\nvec2 closest_edge(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 da = d - a;\n    vec2 ea = e - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    float u = dot(pa, ca) / dot(ca, ca);\n    float v = dot(pa, da) / dot(da, da);\n    float w =", "\n\tvec2 pa = a - p;\n\tvec2 pb = b - p;\n\tfloat d = length(pa) + length(pb);\n\tfloat h = clamp(dot(pa, pb) / d, 0.0, 1.0);\n\tfloat r = length(pa - h * pb);\n\treturn r - w1;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, vec2 c, float w1, float w2 )\n{\n\tvec2 pa = a - p;\n\tvec2 pb = b - p;\n\tvec2 pc = c - p;\n\tfloat d = length(pa) + length(pb) + length(pc);\n\tfloat h = clamp(dot(pa, pb) / d, 0.0, 1.0);\n\tfloat r = length(pa - h * pb);\n\treturn r - w1;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, float w1, float w2 )\n{\n\tvec2 pa = a - p;\n\tvec2 pb = b - p;\n\tvec2 pc = c - p;\n\tvec2 pd = d - p;\n\tfloat d = length(pa) + length(pb) + length(pc) + length(pd);\n\tfloat h = clamp(dot(pa, pb) / d, 0.0, 1.0);\n\tfloat r = length(pa - h * pb);\n\treturn r - w1;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, float w1, float w2 )\n{\n\t", "\n  vec2 p = vec2(dot(ro.xz, tor.xy), length(ro.xy));\n  vec2 q = vec2(dot(rd.xz, tor.xy), length(rd.xy));\n  float a = dot(tor.zw, tor.zw);\n  float b = dot(tor.zw, p) - dot(tor.xy, q);\n  float c = dot(p, p) - a*a - 2.0*a*b + dot(q, q) - a;\n  float h = b*b - 4.0*c;\n  float t = -(b + sqrt(h)) / 2.0;\n  return t;\n}\n\nvec3 raySphere(vec3 ro, vec3 rd, vec2 s) {\n  vec2 p = vec2(dot(ro.xz, s.xy), length(ro.xy));\n  vec2 q = vec2(dot(rd.xz, s.xy), length(rd.xy));\n  float a = dot(s.zw, s.zw);\n  float b = dot(s.zw, p) - dot(s.xy, q);\n  float c = dot(p, p) - a*a - 2.0*a*b + dot(q, q) - a;\n  float h = b*b - 4.0*c;\n  float t = -(b + sqrt(h)) / 2.0;\n  return ro + t*rd;\n}\n\nvec3 rayPlane(vec3 ro, vec3 rd, vec2 p) {\n  vec2 q = vec2(dot(rd.xz, p.xy), length(rd.xy));\n  float a = dot(p.zw, p.zw);\n  float b = dot(p.zw, ro.xy) - dot(p.xy, q);\n  float c = dot(ro.xy, ro.xy) - a*a - 2.0*a*b + dot(q, q) - a;\n  float h = b*b - 4.0*c;\n  float t = -(b + sqrt(h)) / 2", "\n  vec3 n = vec3(0.0);\n  vec3 p = pos;\n  vec2 q = vec2(p.x, p.z);\n  vec2 r = vec2(tor.x, tor.y);\n  vec2 d = q - r;\n  float dsq = dot(d, d);\n  float rsq = dot(r, r);\n  float rsqsq = rsq * rsq;\n  float rsqsqsq = rsqsq * rsqsq;\n  float rsqsqsqsq = rsqsqsq * rsqsqsq;\n  float rsqsqsqsqsq = rsqsqsqsq * rsqsqsqsq;\n  float rsqsqsqsqsqsq = rsqsqsqsqsq * rsqsqsqsqsq;\n  float rsqsqsqsqsqsqsq = rsqsqsqsqsqsq * rsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsq * rsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsqsq * rsqsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsqsqsq * rsqsqsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsqsqsqsq * rsqsqsqsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsqsqsqsqsq * rsqsqsqsqsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsqsqsqsqsqsq * rsqsqsqsqsqsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsqsqsqsqsqsq = rsqsqsqsqsqsqsqsqsqsqsqsqsq * rsqsqsqsqsqsqsqsqsqsqsqsqsq;\n  float rsqsqsqsqsqsqsqsqsqsqsqsqsqsqsq =", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.7615941559557645\n// tanh_approx(x) = 0.76159415", "\n  vec3 col = vec3(0.0);\n  col += texture(iChannel0, q).rgb;\n  col += texture(iChannel1, q).rgb;\n  col += texture(iChannel2, q).rgb;\n  col += texture(iChannel3, q).rgb;\n  return col;\n}\n`;\n\nexport const fragmentShader = `\nprecision highp float;\n\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\nuniform sampler2D iChannel4;\nuniform sampler2D iChannel5;\nuniform sampler2D iChannel6;\nuniform sampler2D iChannel7;\nuniform sampler2D iChannel8;\nuniform sampler2D iChannel9;\nuniform sampler2D iChannel10;\nuniform sampler2D iChannel11;\nuniform sampler2D iChannel12;\nuniform sampler2D iChannel13;\nuniform sampler2D iChannel14;\nuniform sampler2D iChannel15;\nuniform sampler2D iChannel16;\nuniform sampler2D iChannel17;\nuniform sampler2D iChannel18;\nuniform sampler2D iChannel19;\nuniform sampler2D iChannel20;\nuniform sampler2D iChannel21;\nuniform sampler2D iChannel22;\nuniform sampler2D iChannel23;\nuniform sampler2D iChannel24;\nuniform sampler2D iChannel25;\nuniform sampler2D iChannel26;\nuniform sampler2D iChannel27;\nuniform sampler2D iChannel28;\nuniform sampler2D iChannel29;\nuniform sampler2D iChannel30;\nuniform sampler2D iChannel31;\nuniform sampler2D iChannel32;\nuniform sampler2D iChannel33;\nuniform sampler2D iChannel34;\nuniform sampler2D iChannel35;\nuniform sampler2D iChannel36;\nuniform sampler2D iChannel37;\nuniform sampler2D iChannel38;\nuniform sampler2D iChannel39;\nuniform sampler2D iChannel40;\nuniform sampler2D iChannel41;\nuniform sampler2", "\n    p = p - floor(p / size) * size;\n    return p;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, float k) {\n    p = p - floor(p / size) * size;\n    p = p - floor(p / k) * k;\n    return p;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 k) {\n    p = p - floor(p / size) * size;\n    p = p - floor(p / k) * k;\n    return p;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 k, float k2) {\n    p = p - floor(p / size) * size;\n    p = p - floor(p / k) * k;\n    p = p - floor(p / k2) * k2;\n    return p;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 k, vec2 k2) {\n    p = p - floor(p / size) * size;\n    p = p - floor(p / k) * k;\n    p = p - floor(p / k2) * k2;\n    return p;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 k, vec2 k2, float k3) {\n    p = p - floor(p / size) * size;\n    p = p - floor(p / k) * k;\n    p = p - floor(p / k2) * k2;\n    p = p - floor(p / k3) * k3;\n    return p;\n}\n\nvec2 mod2(inout vec2 p, vec2 size, vec2 k, vec2 k2, vec2 k3) {\n    p = p - floor(p / size) * size;\n    p = p - floor(p / k) * k;\n    p = p - floor(p / k2) * k2;\n    p = p - floor(p / k3) * k3;\n    return p;\n}\n\nvec2 mod2(", "\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Grid\nfloat grid(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid2(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid3(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid4(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid5(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid6(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid7(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid8(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid9(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid10(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid11(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid12(vec2 uv, float size) {\n    return 1.0 - step(size, length(uv));\n}\n\n// Grid\nfloat grid13(vec2 uv, float size) {\n    return 1.0 - step(size,", "\n    return length(p - c) - r;\n}\n\n// signed distance to a sphere\nfloat sdSphere( in vec2 p, in vec2 c, in float r )\n{\n    return length(p - c) - r;\n}\n\n// signed distance to a torus\nfloat sdTorus( in vec2 p, in vec2 c, in float r, in float R )\n{\n    vec2 d = p - c;\n    float a = dot(d,d);\n    float b = dot(d,c);\n    float s = b - r;\n    float t = b - R;\n    float d = s*s - a*t*t;\n    return d > 0.0? -s : -t;\n}\n\n// signed distance to a bezier curve\nfloat sdBezier( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 q = p - a;\n    vec2 r = b - a;\n    vec2 s = c - b;\n    vec2 t = d - c;\n    vec2 u = q - r*2.0 + s*2.0 - t;\n    float a = dot(r,r);\n    float b = dot(r,s);\n    float c = dot(r,t);\n    float d = dot(s,s);\n    float e = dot(s,t);\n    float f = dot(t,t);\n    float A = 2.0*(d*f - e*e);\n    float B = 2.0*(a*e - b*d);\n    float C = b*b - a*d - c*c + d*c;\n    float D = B*B - 4.0*A*C;\n    float e1 = (-B - sqrt(D))/(2.0*A);\n    float e2 = (-B + sqrt(D))/(2.0*A);\n    float e = e1;\n    if( e1 < 0.0 || e2 < 0.0 )\n        e = e2;\n    float s = length(u) - e;", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ab = ba * -1.0;\n    vec2 pa_ba = pa * ab;\n    vec2 pa_ab = pa * ab;\n    vec2 pa_ba_pa = pa_ba * pa;\n    vec2 pa_ab_pa = pa_ab * pa;\n    vec2 pa_ba_pa_ab = pa_ba_pa * ab;\n    vec2 pa_ba_pa_ab_pa = pa_ba_pa_ab * pa;\n    vec2 pa_ba_pa_ab_pa_ab = pa_ba_pa_ab_pa * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab = pa_ba_pa_pa_ab_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab = pa_ba_pa_pa_ab_pa_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab_ab = pa_ba_pa_pa_ab_pa_ab_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab_ab_ab = pa_ba_pa_pa_ab_pa_ab_ab_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab_ab_ab_ab = pa_ba_pa_pa_ab_pa_ab_ab_ab_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab_ab_ab_ab_ab = pa_ba_pa_pa_ab_pa_ab_ab_ab_ab_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab_ab_ab_ab_ab_ab = pa_ba_pa_pa_ab_pa_ab_ab_ab_ab_ab_ab * ab;\n    vec2 pa_ba_pa_ab_pa_ab_ab_ab_ab_ab_ab_ab_ab_ab = pa_ba_pa_pa_ab_pa", "\n    return length(a-b);\n}\n\n// signed distance to a 3D triangle\nfloat cro(in vec3 a, in vec3 b ) {\n    return length(a-b);\n}\n\n// signed distance to a 4D triangle\nfloat cro(in vec4 a, in vec4 b ) {\n    return length(a-b);\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c ) {\n    return min(cro(a,b),min(cro(a,c),cro(b,c)));\n}\n\n// signed distance to a 3D triangle\nfloat cro(in vec3 a, in vec3 b, in vec3 c ) {\n    return min(cro(a,b),min(cro(a,c),cro(b,c)));\n}\n\n// signed distance to a 4D triangle\nfloat cro(in vec4 a, in vec4 b, in vec4 c ) {\n    return min(cro(a,b),min(cro(a,c),cro(b,c)));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d ) {\n    return min(cro(a,b),min(cro(a,c),min(cro(b,c),cro(c,d))))\n}\n\n// signed distance to a 3D triangle\nfloat cro(in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return min(cro(a,b),min(cro(a,c),min(cro(b,c),cro(c,d))))\n}\n\n// signed distance to a 4D triangle\nfloat cro(in vec4 a, in vec4 b, in vec4 c, in vec4 d ) {\n    return min(cro(a,b),min(cro(a,c),min(cro(b,c),cro(c,d))))\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a", "\n    float d = length(p);\n    float h = clamp(d-r,0.0,s);\n    return length(p)-h;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r ) \t// r = [rx,ry]\n{\n    float d = length(p);\n    float h = clamp(d-r.x,0.0,s.x);\n    float v = clamp(d-r.y,0.0,s.y);\n    return length(p)-min(h,v);\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in float a ) \t// r = [rx,ry]\n{\n    float d = length(p);\n    float h = clamp(d-r.x,0.0,s.x);\n    float v = clamp(d-r.y,0.0,s.y);\n    return length(p)-min(h,v)-a;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in vec2 a ) \t// r = [rx,ry]\n{\n    float d = length(p);\n    float h = clamp(d-r.x,0.0,s.x);\n    float v = clamp(d-r.y,0.0,s.y);\n    return length(p)-min(h,v)-a.x-a.y;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in vec2 a, in vec2 b ) \t// r = [rx,ry]\n{\n    float d = length(p);\n    float h = clamp(d-r.x,0.0,s.x);\n    float v = clamp(d-r.y,0.0,s.y);\n    return length(p)-min(", "\n    return 1.0 - exp(-10.0 * x);\n}\n\nvec3 s_curve_inv(vec3 x)\n{\n    return -log(1.0 - x);\n}\n\nvec3 s_curve_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -log(1.0 - x) / 10.0;\n}\n\nvec3 s_curve_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv(vec3 x)\n{\n    return -", "\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 1.0 - x * x;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(", "\n    float d = length(p);\n    float r = d/w;\n    float a = atan(p.y,p.x);\n    float s = sin(a*k);\n    float c = cos(a*k);\n    return r*s - c;\n}\n\n// sdSpiral2 is a variant of sdSpiral that uses a different\n// formula for the spiral.  It is a little more complex, but\n// it has a nice shape.\nfloat sdSpiral2( in vec2 p, float w, in float k )\n{\n    float d = length(p);\n    float r = d/w;\n    float a = atan(p.y,p.x);\n    float s = sin(a*k);\n    float c = cos(a*k);\n    return r*s - c;\n}\n\n// sdSpiral3 is a variant of sdSpiral that uses a different\n// formula for the spiral.  It is a little more complex, but\n// it has a nice shape.\nfloat sdSpiral3( in vec2 p, float w, in float k )\n{\n    float d = length(p);\n    float r = d/w;\n    float a = atan(p.y,p.x);\n    float s = sin(a*k);\n    float c = cos(a*k);\n    return r*s - c;\n}\n\n// sdSpiral4 is a variant of sdSpiral that uses a different\n// formula for the spiral.  It is a little more complex, but\n// it has a nice shape.\nfloat sdSpiral4( in vec2 p, float w, in float k )\n{\n    float d = length(p);\n    float r = d/w;\n    float a = atan(p.y,p.x);\n    float s = sin(a*k);\n    float c = cos(a*k);\n    return r*s - c;\n}\n\n// sdSpiral5 is a variant of sdSpiral that uses a different\n// formula for the spiral.  It is a little more complex, but\n// it has a nice shape.\nfloat", "\n    return vec3(1.0) - vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Reflect(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.0 + opticalDepth);\n}\n\n// Calculate a reflectance transmittance value from optical depth.\nvec3 Transmit(vec3 opticalDepth)\n{\n    return vec3(1.0) / (1.", "\n    vec3 rayEnd = rayStart + rayDir * rayLength;\n    vec3 rayDirNormalized = normalize(rayDir);\n    vec3 lightDirNormalized = normalize(lightDir);\n    vec3 rayDirPerp = normalize(cross(rayDirNormalized, lightDirNormalized));\n    vec3 rayDirPerpNormalized = normalize(rayDirPerp);\n\n    vec3 rayDirPerpDot = dot(rayDirPerpNormalized, rayDirNormalized);\n    vec3 lightDirPerpDot = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot2 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot2 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot3 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot3 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot4 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot4 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot5 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot5 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot6 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot6 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot7 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot7 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDirPerpDot8 = dot(rayDirPerpNormalized, rayDirPerpNormalized);\n    vec3 lightDirPerpDot8 = dot(rayDirPerpNormalized, lightDirNormalized);\n\n    vec3 rayDir", "\n    vec3 p1 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p3 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p4 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p5 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p6 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p7 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p8 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p9 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p10 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p11 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p12 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p13 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p14 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p15 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p16 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p17 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p18 = p2 + vec3( 0.0, 0.0, 0.0 );\n    vec3 p19 = p2 + vec3( 0.0, 0.0, 0.", "\n    vec3 q = p - h;\n    float d = length( q );\n    float d2 = d - r;\n    float d3 = d - t;\n    float d4 = d - t - r;\n    float d5 = d - t - r - t;\n    float d6 = d - t - r - t - r;\n    float d7 = d - t - r - t - r - t;\n    float d8 = d - t - r - t - r - t - r;\n    float d9 = d - t - r - t - r - t - r - t;\n    float d10 = d - t - r - t - r - t - r - t - r;\n    float d11 = d - t - r - t - r - t - r - t - r - t;\n    float d12 = d - t - r - t - r - t - r - t - r - t - r;\n    float d13 = d - t - r - t - r - t - r - t - r - t - r - t;\n    float d14 = d - t - r - t - r - t - r - t - r - t - r - t - r;\n    float d15 = d - t - r - t - r - t - r - t - r - t - r - t - r - t;\n    float d16 = d - t - r - t - r - t - r - t - r - t - r - t - r - t - r;\n    float d17 = d - t - r - t - r - t - r - t - r - t - r - t - r - t - r - t;\n    float d18 = d - t - r - t - r - t - r - t - r - t - r - t - r - t - r - t - r;\n    float d19 = d - t - r - t - r - t - r - t - r - t - r - t - r - t - r - t - r - t;\n    float d20 = d - t - r - t - r - t - r - t - r - t - r - t -", "\n    float d = 1.0;\n    float d0 = 1.0;\n    float d1 = 1.0;\n    float d2 = 1.0;\n    float d3 = 1.0;\n    float d4 = 1.0;\n    float d5 = 1.0;\n    float d6 = 1.0;\n    float d7 = 1.0;\n    float d8 = 1.0;\n    float d9 = 1.0;\n    float d10 = 1.0;\n    float d11 = 1.0;\n    float d12 = 1.0;\n    float d13 = 1.0;\n    float d14 = 1.0;\n    float d15 = 1.0;\n    float d16 = 1.0;\n    float d17 = 1.0;\n    float d18 = 1.0;\n    float d19 = 1.0;\n    float d20 = 1.0;\n    float d21 = 1.0;\n    float d22 = 1.0;\n    float d23 = 1.0;\n    float d24 = 1.0;\n    float d25 = 1.0;\n    float d26 = 1.0;\n    float d27 = 1.0;\n    float d28 = 1.0;\n    float d29 = 1.0;\n    float d30 = 1.0;\n    float d31 = 1.0;\n    float d32 = 1.0;\n    float d33 = 1.0;\n    float d34 = 1.0;\n    float d35 = 1.0;\n    float d36 = 1.0;\n    float d37 = 1.0;\n    float d38 = 1.0;\n    float d39 = 1.0;\n    float d40 = 1.0;\n    float d41 = 1.0;\n    float d42 = ", "\n    vec3 q = p - h * vec3( 0.0, 0.0, 1.0 );\n    float d = length( q );\n    return min( d, r );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h )\n{\n    vec3 q = p - h;\n    float d = length( q );\n    return min( d, r );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n )\n{\n    vec3 q = p - h;\n    float d = length( q );\n    return min( d, r ) - dot( n, q );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n, in vec3 v )\n{\n    vec3 q = p - h;\n    float d = length( q );\n    return min( d, r ) - dot( n, q ) - dot( v, q );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n, in vec3 v, in vec3 w )\n{\n    vec3 q = p - h;\n    float d = length( q );\n    return min( d, r ) - dot( n, q ) - dot( v, q ) - dot( w, q );\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n, in vec3 v, in vec3 w, in vec3 u )\n{\n    vec3 q = p - h;\n    float d = length( q );\n    return min( d, r ) - dot( n, q ) - dot( v, q )", "\n    vec3 eps = vec3( 0.0001 );\n    return normalize( vec3(\n        dFdx( pos.x ) + eps.x,\n        dFdx( pos.y ) + eps.y,\n        dFdx( pos.z ) + eps.z ) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.0001 );\n    return normalize( vec3(\n        dFdx( pos.x ) + eps.x,\n        dFdx( pos.y ) + eps.y,\n        dFdx( pos.z ) + eps.z ) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.0001 );\n    return normalize( vec3(\n        dFdx( pos.x ) + eps.x,\n        dFdx( pos.y ) + eps.y,\n        dFdx( pos.z ) + eps.z ) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.0001 );\n    return normalize( vec3(\n        dFdx( pos.x ) + eps.x,\n        dFdx( pos.y ) + eps.y,\n        dFdx( pos.z ) + eps.z ) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.0001 );\n    return normalize( vec3(\n        dFdx( pos.x ) + eps.x,\n        dFdx( pos.y ) + eps.y,\n        dFdx( pos.z ) + eps.z ) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.0001 );\n    return normalize( vec3(\n        dFdx( pos.x ) + eps.x,\n        dFdx( pos.y ) + eps.y", "\n    float d = length(p);\n    float h2 = h*h;\n    float r2 = r*r;\n    float d2 = d*d;\n    float hd = h2-d2;\n    float dh = d-r;\n    float dh2 = dh*dh;\n    float dhd = dh*hd;\n    float dhd2 = dhd*dhd;\n    float dhd3 = dhd2*dhd;\n    float dhd4 = dhd3*dhd;\n    float dhd5 = dhd4*dhd;\n    float dhd6 = dhd5*dhd;\n    float dhd7 = dhd6*dhd;\n    float dhd8 = dhd7*dhd;\n    float dhd9 = dhd8*dhd;\n    float dhd10 = dhd9*dhd;\n    float dhd11 = dhd10*dhd;\n    float dhd12 = dhd11*dhd;\n    float dhd13 = dhd12*dhd;\n    float dhd14 = dhd13*dhd;\n    float dhd15 = dhd14*dhd;\n    float dhd16 = dhd15*dhd;\n    float dhd17 = dhd16*dhd;\n    float dhd18 = dhd17*dhd;\n    float dhd19 = dhd18*dhd;\n    float dhd20 = dhd19*dhd;\n    float dhd21 = dhd20*dhd;\n    float dhd22 = dhd21*dhd;\n    float dhd23 = dhd22*dhd;\n    float dhd24 = dhd23*dhd;\n    float dhd25 = dhd24*dhd;\n    float dhd26 = dhd25*dhd;\n    float dhd27 = dhd26*dhd;\n    float dhd28 = dhd27*dhd;\n    float dhd29 = dhd28*d", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(\n        mix(\n            mix( dot(p.xzx, vec3(1.0, 0.0, 0.0)),\n                mix( dot(p.xyx, vec3(1.0, 1.0, 0.0)),\n                     dot(p.yzx, vec3(1.0, 0.0, 1.0)),\n                     f.x),\n                f.y),\n        mix(\n            mix( dot(p.xxy, vec3(1.0, 1.0, 1.0)),\n                mix( dot(p.xyx, vec3(1.0, 1.0, 1.0)),\n                     dot(p.yzy, vec3(1.0, -1.0, 1.0)),\n                     f.x),\n                f.y),\n            dot(p.xyz, vec3(1.0, -1.0, -1.0)),\n            f.z),\n        f.z);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(\n        mix(\n            mix( dot(p.xzx, vec3(1.0, 0.0, 0.0)),\n                mix( dot(p.xyx, vec3(1.0, 1.0, 0.0)),\n                     dot(p.yzx, vec3(1.0, 0.0, 1.0)),\n                     f.x),\n                f.y),\n            mix(\n                mix( dot(p.xxy, vec3(1.0, 1.0, 1.0)),\n                    mix( dot(p.xyx, vec3(1.0", "\n    float amp = 1.0;\n    float freq = 1.0;\n    float sum = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        sum += amp * noise( p );\n        p *= 2.0;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm2( vec3 p )\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float sum = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        sum += amp * noise( p );\n        p *= 2.0;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm3( vec3 p )\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float sum = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        sum += amp * noise( p );\n        p *= 2.0;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm4( vec3 p )\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float sum = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        sum += amp * noise( p );\n        p *= 2.0;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm noise for 2-4 octaves including", "\n    return fract(dot(p3, vec3(12.9898, 78.233, 151.718)));\n}\n\n//value noise hash\nfloat hash31(vec2 p2)\n{\n    return fract(dot(p2, vec2(12.9898, 78.233)));\n}\n\n//value noise hash\nfloat hash31(float p)\n{\n    return fract(p * 131.071);\n}\n\n//value noise hash\nfloat hash31(vec4 p4)\n{\n    return fract(dot(p4, vec4(12.9898, 78.233, 151.718, 131.071)));\n}\n\n//value noise hash\nfloat hash31(vec3 p3, vec3 p3_offset)\n{\n    return fract(dot(p3 + p3_offset, vec3(12.9898, 78.233, 151.718)));\n}\n\n//value noise hash\nfloat hash31(vec2 p2, vec2 p2_offset)\n{\n    return fract(dot(p2 + p2_offset, vec2(12.9898, 78.233)));\n}\n\n//value noise hash\nfloat hash31(float p, vec3 p3_offset)\n{\n    return fract(dot(p + p3_offset, vec3(12.9898, 78.233, 151.718)));\n}\n\n//value noise hash\nfloat hash31(vec4 p4, vec3 p3_offset)\n{\n    return fract(dot(p4 + p3_offset, vec4(12.9898, 78.233, 151.718, 131.071)));\n}\n\n//value noise hash\nfloat hash31(vec3 p3, vec3 p3_offset, vec3 p3_scale)", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 uv3 = uv2 * uv2 * uv2 * uv2;\n    vec2 uv4 = uv3 * uv3 * uv3 * uv3;\n    vec2 uv5 = uv4 * uv4 * uv4 * uv4;\n    vec2 uv6 = uv5 * uv5 * uv5 * uv5;\n    vec2 uv7 = uv6 * uv6 * uv6 * uv6;\n    vec2 uv8 = uv7 * uv7 * uv7 * uv7;\n    vec2 uv9 = uv8 * uv8 * uv8 * uv8;\n    vec2 uv10 = uv9 * uv9 * uv9 * uv9;\n    vec2 uv11 = uv10 * uv10 * uv10 * uv10;\n    vec2 uv12 = uv11 * uv11 * uv11 * uv11;\n    vec2 uv13 = uv12 * uv12 * uv12 * uv12;\n    vec2 uv14 = uv13 * uv13 * uv13 * uv13;\n    vec2 uv15 = uv14 * uv14 * uv14 * uv14;\n    vec2 uv16 = uv15 * uv15 * uv15 * uv15;\n    vec2 uv17 = uv16 * uv16 * uv16 * uv16;\n    vec2 uv18 = uv17 * uv17 * uv17 * uv17;\n    vec2 uv19 = uv18 * uv18 * uv18 * uv18;\n    vec2 uv20 = uv19 * uv19 *", "\n  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0, 2.0, 4.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xyw), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z - q.w) / (q.w + e), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsv2(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xyw), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z - q.w) / (q.w + e), d / (q.x +", "\n    p = p - floor(p / size) * size;\n    return p;\n}\n\nvec3 mod2(inout vec3 p, vec2 size) {\n    p.x = mod1(p.x, size.x);\n    p.y = mod1(p.y, size.y);\n    return p;\n}\n\nvec3 mod3(inout vec3 p, vec3 size) {\n    p.x = mod1(p.x, size.x);\n    p.y = mod1(p.y, size.y);\n    p.z = mod1(p.z, size.z);\n    return p;\n}\n\nvec3 mod4(inout vec3 p, vec4 size) {\n    p.x = mod1(p.x, size.x);\n    p.y = mod1(p.y, size.y);\n    p.z = mod1(p.z, size.z);\n    p.w = mod1(p.w, size.w);\n    return p;\n}\n\nvec3 mod5(inout vec3 p, vec5 size) {\n    p.x = mod1(p.x, size.x);\n    p.y = mod1(p.y, size.y);\n    p.z = mod1(p.z, size.z);\n    p.w = mod1(p.w, size.w);\n    p.z = mod1(p.z, size.z);\n    return p;\n}\n\nvec3 mod6(inout vec3 p, vec6 size) {\n    p.x = mod1(p.x, size.x);\n    p.y = mod1(p.y, size.y);\n    p.z = mod1(p.z, size.z);\n    p.w = mod1(p.w, size.w);\n    p.z = mod1(p.z, size.z);\n    p.z = mod1(p.z, size.z);\n    return p;\n}\n\nvec3 mod7(inout vec3 p, vec7 size) {\n    p.x = mod", "\n\treturn fract(sin(co) * 1e3);\n}\n\n// 2D noise\nfloat noise(vec2 co) {\n\tvec2 i = floor(co);\n\tvec2 f = fract(co);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tfloat u = f.x * f.y * (d - b) + f.y * (c - a) + f.x * (b - a);\n\tfloat v = f.y * (d - c) + f.x * (d - b) + f.y * (c - a);\n\n\treturn mix(u, v, f.x);\n}\n\n// 3D noise\nfloat noise(vec3 co) {\n\tvec3 s = floor(co);\n\tvec3 x = fract(co);\n\n\tfloat a = hash(s);\n\tfloat b = hash(s + vec3(1.0, 0.0, 0.0));\n\tfloat c = hash(s + vec3(0.0, 1.0, 0.0));\n\tfloat d = hash(s + vec3(1.0, 1.0, 0.0));\n\tfloat e = hash(s + vec3(0.0, 0.0, 1.0));\n\tfloat f = hash(s + vec3(1.0, 0.0, 1.0));\n\tfloat g = hash(s + vec3(0.0, 1.0, 1.0));\n\tfloat h = hash(s + vec3(1.0, 1.0, 1.0));\n\n\tfloat u = mix(mix(mix(a, b, x.x), mix(c, d, x.x), x.y),\n\t\tmix(mix(e, f, x.x), mix(g, h, x.x), x.y), x", "\n    return pow(t, 2.2);\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGBToLinear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 t)", "\n    return c <= vec3(0.0031303)? 12.92 * c : (1.0 + 0.055) * c / 1.055 - 0.055;\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return c * c * c;\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return c <= vec3(0.0031303)? c * 12.92 : (1.055 * c) / (1.0 + 0.055);\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return sRGBToLinear(c.rgb);\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return linearTosRGB(c.rgb);\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return sRGBToLinear(c.rgb);\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return linearTosRGB(c.rgb);\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return sRGBToLinear(c.rgb);\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return linearTosRGB(c.rgb);\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return sRGBToLinear(c.rgb);\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return linearTosRGB(c.rgb);\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return sRGBToLinear(c.rgb);\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return linearTosRGB(c.rgb);\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    return sRGBToLinear(c.rgb);\n}\n\nvec3 linearTosRGB(in vec3 c) {\n    return linearTosRGB(c.rgb);\n}\n\nvec3 sRGBToLinear(in", "\n  return min(a, b) * k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n  return max(a, b) * k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pabs(float a) {\n  return abs(a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat psign(float a) {\n  return sign(a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmod(float a, float b) {\n  return mod(a, b);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmodf(float a, float b) {\n  return modf(a, b);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pfloor(float a) {\n  return floor(a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pceil(float a) {\n  return ceil(a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pround(float a) {\n  return round(a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat proundf(float a) {\n  return roundf(a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pfrac(float a) {\n", "\n  vec3 oc = ro - sph.xyz;\n  float b = dot(rd, oc);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) {\n    return dbuffer;\n  }\n  return -b - sqrt(h);\n}\n\n// Sphere intersection\nvec3 sphereIntersect(vec3 ro, vec3 rd, vec4 sph) {\n  float d = sphered(ro, rd, sph, 1.0);\n  if (d < 0.0) {\n    return vec3(0.0);\n  }\n  return ro + rd*d;\n}\n\n// Sphere intersection\nvec3 sphereIntersect(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float d = sphered(ro, rd, sph, dbuffer);\n  if (d < 0.0) {\n    return vec3(0.0);\n  }\n  return ro + rd*d;\n}\n\n// Sphere intersection\nvec3 sphereIntersect(vec3 ro, vec3 rd, vec4 sph, vec3 normal, float dbuffer) {\n  float d = sphered(ro, rd, sph, dbuffer);\n  if (d < 0.0) {\n    return vec3(0.0);\n  }\n  return ro + rd*d;\n}\n\n// Sphere intersection\nvec3 sphereIntersect(vec3 ro, vec3 rd, vec4 sph, vec3 normal, float dbuffer) {\n  float d = sphered(ro, rd, sph, dbuffer);\n  if (d < 0.0) {\n    return vec3(0.0);\n  }\n  return ro + rd*d;\n}\n\n// Sphere intersection\nvec3 sphereIntersect(vec3 ro, vec3 rd, vec4 sph, vec3 normal, vec3 light, float dbuffer) {\n  float d = sphered(ro, rd, sph, dbuffer);\n  ", "\n  vec4 q = p;\n  q.x = fract(p.x * 1.103125);\n  q.y = fract(p.y * 1.103125);\n  q.z = fract(p.z * 1.103125);\n  q.w = fract(p.w * 1.103125);\n  return q;\n}\n\nvec4 formula2(vec4 p) {\n  vec4 q = p;\n  q.x = fract(p.x * 1.103125);\n  q.y = fract(p.y * 1.103125);\n  q.z = fract(p.z * 1.103125);\n  q.w = fract(p.w * 1.103125);\n  return q;\n}\n\nvec4 formula3(vec4 p) {\n  vec4 q = p;\n  q.x = fract(p.x * 1.103125);\n  q.y = fract(p.y * 1.103125);\n  q.z = fract(p.z * 1.103125);\n  q.w = fract(p.w * 1.103125);\n  return q;\n}\n\nvec4 formula4(vec4 p) {\n  vec4 q = p;\n  q.x = fract(p.x * 1.103125);\n  q.y = fract(p.y * 1.103125);\n  q.z = fract(p.z * 1.103125);\n  q.w = fract(p.w * 1.103125);\n  return q;\n}\n\nvec4 formula5(vec4 p) {\n  vec4 q = p;\n  q.x = fract(p.x * 1.103125);\n  q.y = fract(p.y * 1.103125);", "\n    vec3 q = p / r;\n    vec3 q2 = q * q;\n    vec3 q3 = q2 * q;\n    vec3 q4 = q3 * q;\n    vec3 q5 = q4 * q;\n    vec3 q6 = q5 * q;\n    vec3 q7 = q6 * q;\n    vec3 q8 = q7 * q;\n    vec3 q9 = q8 * q;\n    vec3 q10 = q9 * q;\n    vec3 q11 = q10 * q;\n    vec3 q12 = q11 * q;\n    vec3 q13 = q12 * q;\n    vec3 q14 = q13 * q;\n    vec3 q15 = q14 * q;\n    vec3 q16 = q15 * q;\n    vec3 q17 = q16 * q;\n    vec3 q18 = q17 * q;\n    vec3 q19 = q18 * q;\n    vec3 q20 = q19 * q;\n    vec3 q21 = q20 * q;\n    vec3 q22 = q21 * q;\n    vec3 q23 = q22 * q;\n    vec3 q24 = q23 * q;\n    vec3 q25 = q24 * q;\n    vec3 q26 = q25 * q;\n    vec3 q27 = q26 * q;\n    vec3 q28 = q27 * q;\n    vec3 q29 = q28 * q;\n    vec3 q30 = q29 * q;\n    vec3 q31 = q30 * q;\n    vec3 q32 = q31 * q;\n    vec3 q33 = q32 * q;\n    vec3 q34 = q33 * q;\n    vec3 q35 = q34 * q;\n    vec3 q36 = q35 * q;\n    vec3 q37 = q36 * q;\n    vec3 q38 = q37 * q;\n    ", "\n  return front * back.a + back * (1.0 - back.a);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n  return front * alpha + back * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha) {\n  return front * alpha + back * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 color) {\n  return color * alpha + back * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 color, vec4 color2) {\n  return color * alpha + back * (1.0 - alpha) + color2 * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 color, vec4 color2, vec4 color3) {\n  return color * alpha + back * (1.0 - alpha) + color2 * (1.0 - alpha) + color3 * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 color, vec4 color2, vec4 color3, vec4 color4) {\n  return color * alpha + back * (1.0 - alpha) + color2 * (1.0 - alpha) + color3 * (1.0 - alpha) + color4 * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 color, vec4 color2, vec4 color3, vec4 color4, vec4 color5) {\n  return color * alpha + back * (1.0 - alpha) + color2 * (1.0 - alpha) + color3 * (1.0 - alpha) + color4 * (1.0 - alpha) + color5 * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 color, vec4 color2, vec4 color3, vec4 color4", "\n  return back + front.rgb * front.a;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front) {\n  return back + front * front.a;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 backAlpha, vec3 frontAlpha) {\n  return back + front * (backAlpha + frontAlpha - backAlpha * frontAlpha);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 backAlpha, vec3 frontAlpha, vec3 backAlpha2, vec3 frontAlpha2) {\n  return back + front * (backAlpha + frontAlpha - backAlpha * frontAlpha - backAlpha2 + frontAlpha2);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 backAlpha, vec3 frontAlpha, vec3 backAlpha2, vec3 frontAlpha2, vec3 backAlpha3, vec3 frontAlpha3) {\n  return back + front * (backAlpha + frontAlpha - backAlpha * frontAlpha - backAlpha2 + frontAlpha2 - backAlpha3 + frontAlpha3);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 backAlpha, vec3 frontAlpha, vec3 backAlpha2, vec3 frontAlpha2, vec3 backAlpha3, vec3 frontAlpha3, vec3 backAlpha4, vec3 frontAlpha4) {\n  return back + front * (backAlpha + frontAlpha - backAlpha * frontAlpha - backAlpha2 + frontAlpha2 - backAlpha3 + frontAlpha3 - backAlpha4 + frontAlpha4);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 backAlpha, vec3 frontAlpha, vec3 backAlpha2, vec3 frontAlpha2, vec3 backAlpha3, vec3 frontAlpha3, vec3 backAlpha4, vec3 frontAlpha4, vec3 backAlpha5, vec3 frontAlpha5) {\n  return back + front * (backAlpha + frontAlpha - backAlpha * frontAlpha - backAlpha2 + frontAlpha2 - backAlpha3 + frontAlpha3 - backAlpha4 + frontAlpha4 - backAlpha5 + frontAlpha5);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 backAlpha, vec", "\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex2(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex3(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex4(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex5(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex6(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex7(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d*d/r/r;\n    return f*f*f;\n}\n\nfloat hex8(vec2 p, float r ) {\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = 1.0 - d", "\n  return v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v * (v *", "\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nvec3 hash3(vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 269.5)), dot(p, vec3(269.5, 183.3, 43758.5453)), dot(p, vec3(43758.5453, 183.3, 269.5)))) * 43758.5453);\n}\n\nvec3 hash4(vec4 p) {\n  return fract(sin(vec4(dot(p, vec4(127.1, 311.7, 269.5, 43758.5453)), dot(p, vec4(269.5, 183.3, 43758.5453, 127.1)), dot(p, vec4(43758.5453, 183.3, 269.5, 311.7)), dot(p, vec4(311.7, 269.5, 43758.5453, 127.1)))) * 43758.5453;\n}\n\nvec3 hash5(vec5 p) {\n  return fract(sin(vec5(dot(p, vec5(127.1, 311.7, 269.5, 43758.5453, 127.1)), dot(p, vec5(269.5, 183.3, 43758.5453, 127.1, 311.7)), dot", "\n    float k = 1.0/3.0;\n    float c = 1.0/2.0;\n    float f = 1.0/2.0;\n    float g = 1.0/2.0;\n    float h = 1.0/2.0;\n    float i = 1.0/2.0;\n    float j = 1.0/2.0;\n    float kk = 1.0/2.0;\n    float ll = 1.0/2.0;\n    float mm = 1.0/2.0;\n    float nn = 1.0/2.0;\n    float oo = 1.0/2.0;\n    float pp = 1.0/2.0;\n    float qq = 1.0/2.0;\n    float rr = 1.0/2.0;\n    float ss = 1.0/2.0;\n    float tt = 1.0/2.0;\n    float uu = 1.0/2.0;\n    float vv = 1.0/2.0;\n    float ww = 1.0/2.0;\n    float xx = 1.0/2.0;\n    float yy = 1.0/2.0;\n    float zz = 1.0/2.0;\n    float aa = 1.0/2.0;\n    float bb = 1.0/2.0;\n    float cc = 1.0/2.0;\n    float dd = 1.0/2.0;\n    float ee = 1.0/2.0;\n    float ff = 1.0/2.0;\n    float gg = 1.0/2.0;\n    float hh = 1.0/2.0;\n    float ii = 1.0/2.0;\n    float jj = 1.0/2.0;\n    float kk = 1.0/2.0;\n    float ll = 1.0/2.0;\n    float mm =", "\n  return fract(sin(p.x*p.y)*13.0);\n}\n\nfloat turbulence(vec3 p) {\n  float t = 0.0;\n  float d = 1.0;\n  for (int i = 0; i < 4; i++) {\n    float n = noise(vec2(p.x/d, p.y/d));\n    t += n;\n    d *= 2.0;\n  }\n  return t;\n}\n\nvec3 color(vec3 p) {\n  float t = turbulence(p);\n  return vec3(t);\n}\n\nvec3 main(vec3 p) {\n  return color(p);\n}\n`;\n\nexport default class extends Phaser.Scene {\n  constructor() {\n    super({\n      key: 'examples',\n    });\n  }\n\n  preload() {}\n\n  create() {\n    var shader = this.add.shader(0, 0, 100, 100, shaderSource, {\n      uniforms: {\n        u_time: { value: 0 },\n      },\n    });\n\n    this.input.on('gameobjectover', function (pointer) {\n      if (pointer.gameObject.hasOwnProperty('shader')) {\n        shader.setUniform('u_time', { value: 0 });\n      }\n    });\n\n    this.input.on('gameobjectout', function (pointer) {\n      if (pointer.gameObject.hasOwnProperty('shader')) {\n        shader.setUniform('u_time', { value: 0 });\n      }\n    });\n  }\n\n  update() {\n    this.cameras.main.setTint(0x000000);\n    this.cameras.main.setAlpha(0.5);\n\n    this.cameras.main.setShader(shader);\n    shader.setUniform('u_time', { value: Date.now() / 1000 });\n  }\n}<|endoftext|>import {\n  ShaderMaterial,", "\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) {\n    return vec2(b, -1.0);\n  } else {\n    float t = -b - sqrt(h);\n    if (t < 0.0) {\n      return vec2(b, -1.0);\n    } else {\n      return vec2(t, 1.0);\n    }\n  }\n}\n\nvec3 raySphereIntersection(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) {\n    return vec3(b, -1.0);\n  } else {\n    float t = -b - sqrt(h);\n    if (t < 0.0) {\n      return vec3(b, -1.0);\n    } else {\n      return ro + rd*t;\n    }\n  }\n}\n\nvec3 raySphereNormal(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) {\n    return vec3(0.0);\n  } else {\n    float t = -b - sqrt(h);\n    if (t < 0.0) {\n      return vec3(0.0);\n    } else {\n      return (ro + rd*t - sph.xyz)/sph.w;\n    }\n  }\n}\n\nvec3 ray", "\n    float r = length(p);\n    float a = r * r;\n    float b = a * a;\n    float c = b * b;\n    float d = c * c;\n    float e = d * d;\n    float f = e * e;\n    float g = f * f;\n    float h = g * g;\n    float i = h * h;\n    float j = i * i;\n    float k = j * j;\n    float l = k * k;\n    float m = l * l;\n    float n = m * m;\n    float o = n * n;\n    float p = o * o;\n    float q = p * p;\n    float r = q * q;\n    float s = r * r;\n    float t = s * s;\n    float u = t * t;\n    float v = u * u;\n    float w = v * v;\n    float x = w * w;\n    float y = x * x;\n    float z = y * y;\n    float aa = z * z;\n    float ab = aa * aa;\n    float ac = ab * ab;\n    float ad = ac * ac;\n    float ae = ad * ad;\n    float af = ae * ae;\n    float ag = af * af;\n    float ah = ag * ag;\n    float ai = ah * ah;\n    float aj = ai * ai;\n    float ak = aj * aj;\n    float al = ak * ak;\n    float am = al * al;\n    float an = am * am;\n    float ao = an * an;\n    float ap = ao * ao;\n    float aq = ap * ap;\n    float ar = aq * aq;\n    float as = ar * ar;\n    float at = as * as;\n    float au = at * at;\n    float av = au * au;\n    float aw = av * av;\n    float ax = aw * aw;\n    float ay = ax * ax;\n    float az = ay * ay;\n    float aaa = az * az;\n", "\n\treturn 1.0f - 2.0f * ( x * x * ( 1.0f - t ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_inv( float x, float t )\n{\n\treturn 1.0f - 2.0f * ( ( 1.0f - x ) * ( 1.0f - x ) * ( 1.0f - t ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_inv_inv( float x, float t )\n{\n\treturn 1.0f - 2.0f * ( ( 1.0f - x ) * ( 1.0f - x ) * ( 1.0f - t ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_inv_inv_inv( float x, float t )\n{\n\treturn 1.0f - 2.0f * ( ( 1.0f - x ) * ( 1.0f - x ) * ( 1.0f - t ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_inv_inv_inv_inv( float x, float t )\n{\n\treturn 1.0f - 2.0f * ( ( 1.0f - x ) * ( 1.0f - x ) * ( 1.0f - t ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_inv_inv_inv_inv_inv( float x, float t )\n{\n\treturn 1.0f - 2.0f * ( ( 1.0f - x ) * ( 1.0f - x ) * ( 1.0f - t ) );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_inv_inv_inv_inv_inv_inv( float x, float t )\n{\n\treturn 1.0f - 2.0f * ( ( 1.0f - x ) * ( 1.0f - x ) * ( 1.0f - t ) );\n}\n\n// generalization of Devil", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h );\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c, in vec3 n, in float r )\n{\n    vec3 d = p - c;\n    float h = dot( d, n );\n    float s = length( d - n * h );\n    return s - r;\n}\n\nfloat sdCylinder( in vec3 p, in vec3 c, in vec3 n, in float r )\n{\n    vec3 d = p - c;\n    float h = dot( d, n );\n    float s = length( d - n * h );\n    return s - r;\n}\n\nfloat sdCapsule( in vec3 p, in vec3 c, in vec3 n, in float r )\n{\n    vec3 d = p - c;\n    float h = dot( d, n );\n    float s = length( d - n * h );\n    return s - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c, in vec3 n, in float r, in float h )\n{\n    vec3 d = p - c;\n    float hh = dot( d, n );\n    float s = length( d - n * hh );\n    return s - r;\n}\n\nfloat sdCylinder( in vec3 p, in vec3 c, in vec3 n, in float r, in float h )\n{\n    vec3 d = p - c;\n    float hh = dot( d, n );\n    float s = length( d - n * hh );\n    return s - r;\n}\n\nfloat sdCapsule( in vec3 p, in vec3 c, in vec3 n, in float r, in float h )\n{\n    vec3 d = p -", "\n  float a = 0.0;\n  float b = 0.0;\n  float c = 0.0;\n  float d = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  float p = 0.0;\n  float q = 0.0;\n  float r = 0.0;\n  float s = 0.0;\n  float t = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float w = 0.0;\n  float x = 0.0;\n  float y = 0.0;\n  float z = 0.0;\n  float aa = 0.0;\n  float bb = 0.0;\n  float cc = 0.0;\n  float dd = 0.0;\n  float ee = 0.0;\n  float ff = 0.0;\n  float gg = 0.0;\n  float hh = 0.0;\n  float ii = 0.0;\n  float jj = 0.0;\n  float kk = 0.0;\n  float ll = 0.0;\n  float mm = 0.0;\n  float nn = 0.0;\n  float oo = 0.0;\n  float pp = 0.0;\n  float qq = 0.0;\n  float rr = 0.0;\n  float ss = 0.0;\n  float tt = 0.0;\n  float uu = 0.0;\n  float vv = 0.0;\n  float ww = 0.0;\n  float xx = 0.", "\n    float a = x / (y + 1.0);\n    float b = y / (y + 1.0);\n    float c = y / (y + 1.0);\n    float d = y / (y + 1.0);\n    float e = y / (y + 1.0);\n    float f = y / (y + 1.0);\n    float g = y / (y + 1.0);\n    float h = y / (y + 1.0);\n    float i = y / (y + 1.0);\n    float j = y / (y + 1.0);\n    float k = y / (y + 1.0);\n    float l = y / (y + 1.0);\n    float m = y / (y + 1.0);\n    float n = y / (y + 1.0);\n    float o = y / (y + 1.0);\n    float p = y / (y + 1.0);\n    float q = y / (y + 1.0);\n    float r = y / (y + 1.0);\n    float s = y / (y + 1.0);\n    float t = y / (y + 1.0);\n    float u = y / (y + 1.0);\n    float v = y / (y + 1.0);\n    float w = y / (y + 1.0);\n    float x = y / (y + 1.0);\n    float y = y / (y + 1.0);\n    float z = y / (y + 1.0);\n    float aa = y / (y + 1.0);\n    float ab = y / (y + 1.0);\n    float ac = y / (y + 1.0);\n    float ad = y / (y + 1.0);\n    float ae = y / (y + 1.0);\n    float af = y / (y + 1.0);\n    float ag = y / (y + 1.0);\n    float ah = y / (y + 1.0);", "\n  return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return vec2(z.x / w.x - z.y / w.y, z.x / w.x + z.y / w.y);\n}\n\nvec2 csqrt(vec2 z) {\n  return cdiv(vec2(z.x + z.y, z.x - z.y), vec2(1.0, 2.0));\n}\n\nvec2 csin(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, -1.0) - z * z));\n}\n\nvec2 ccos(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, 1.0) - z * z));\n}\n\nvec2 ctan(vec2 z) {\n  return cdiv(csin(z), ccos(z));\n}\n\nvec2 csinh(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, 1.0) + z * z));\n}\n\nvec2 ccosh(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, -1.0) + z * z));\n}\n\nvec2 ctanh(vec2 z) {\n  return cdiv(csinh(z), ccosh(z));\n}\n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.x) * ccos(z.y), sin(z.x) * csin(z.y));\n}\n\nvec2 clog(vec2 z) {\n  return vec2(atan(z.y, z.x), atan(z.y, z.x));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(w * clog(z));\n}\n\nvec2 csqrt(vec2 z) {", "\n  return 0.5 * log(1.0 + z) - 0.5 * log(1.0 - z);\n}\n\n// Hyperbolic tangent\nvec2 tanh(vec2 z) {\n  return 0.5 * (1.0 + exp(z)) / (1.0 - exp(z));\n}\n\n// Hyperbolic cosine\nvec2 cosh(vec2 z) {\n  return (1.0 + exp(z)) / 2.0;\n}\n\n// Hyperbolic sine\nvec2 sinh(vec2 z) {\n  return (1.0 + exp(z)) / 2.0;\n}\n\n// Hyperbolic tangent\nvec2 tan(vec2 z) {\n  return z / (1.0 + exp(-z));\n}\n\n// Hyperbolic cosine\nvec2 acosh(vec2 z) {\n  return log(z + sqrt(z * z - 1.0));\n}\n\n// Hyperbolic sine\nvec2 asinh(vec2 z) {\n  return log(z + sqrt(z * z + 1.0));\n}\n\n// Hyperbolic tangent\nvec2 atanh(vec2 z) {\n  return log((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\n// Hyperbolic cosine\nvec2 acos(vec2 z) {\n  return acosh(z);\n}\n\n// Hyperbolic sine\nvec2 asin(vec2 z) {\n  return asinh(z);\n}\n\n// Hyperbolic tangent\nvec2 atan(vec2 z) {\n  return atanh(z);\n}\n\n// Hyperbolic cosine\nvec2 cot(vec2 z) {\n  return 1.0 / tan(z);\n}\n\n// Hyperbolic sine\nvec2 csc(vec2 z) {\n  return 1.0 / sin(z);\n}\n\n// Hyperbolic tangent\nvec2 sec(vec2 z) {\n  return 1.0 / cos(z);\n}\n\n// Hyperbolic cosine\nvec2 cosec(vec2 z) {\n  return 1.0 / sinh(", "\n    return vec2(exp(z.x), exp(z.y));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(z.x), log(z.y));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x), sin(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x), cos(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(tan(z.x), tan(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x), sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x), cosh(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), tanh(z.y));\n}\n\nvec2 cpow(vec2 z, vec2 p) {\n    return vec2(pow(z.x, p.x), pow(z.y, p.y));\n}\n\nvec2 cpow(vec2 z, float p) {\n    return vec2(pow(z.x, p), pow(z.y, p));\n}\n\nvec2 cpow(float z, vec2 p) {\n    return vec2(pow(z, p.x), pow(z, p.y));\n}\n\nvec2 cpow(float z, float p) {\n    return vec2(pow(z, p));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 csqrt(float z) {\n    return vec2(sqrt(z));\n}\n\nvec2 csqrt(vec2 z, float p) {", "\n  return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return vec2(z.x / w.x - z.y / w.y, z.x / w.x + z.y / w.y);\n}\n\nvec2 csqrt(vec2 z) {\n  return cdiv(vec2(z.x + z.y, z.x - z.y), vec2(1.0, 2.0));\n}\n\nvec2 csin(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, -1.0) - z * z));\n}\n\nvec2 ccos(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, 1.0) - z * z));\n}\n\nvec2 ctan(vec2 z) {\n  return cdiv(csin(z), ccos(z));\n}\n\nvec2 csinh(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, 1.0) + z * z));\n}\n\nvec2 ccosh(vec2 z) {\n  return cmul(z, csqrt(vec2(1.0, 1.0) - z * z));\n}\n\nvec2 ctanh(vec2 z) {\n  return cdiv(csinh(z), ccosh(z));\n}\n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.x) * ccos(z.y), sin(z.x) * csin(z.y));\n}\n\nvec2 clog(vec2 z) {\n  return vec2(atan(z.y, z.x), atan(z.y, z.x));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(w * log(z));\n}\n\nvec2 csqrt(vec2 z) {\n", "\n  return vec2(exp(z.x), exp(z.y));\n}\n\nvec2 clog(vec2 z) {\n  return vec2(log(z.x), log(z.y));\n}\n\nvec2 csqrt(vec2 z) {\n  return vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 csin(vec2 z) {\n  return vec2(sin(z.x), sin(z.y));\n}\n\nvec2 ccos(vec2 z) {\n  return vec2(cos(z.x), cos(z.y));\n}\n\nvec2 ctan(vec2 z) {\n  return vec2(tan(z.x), tan(z.y));\n}\n\nvec2 csinh(vec2 z) {\n  return vec2(sinh(z.x), sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n  return vec2(cosh(z.x), cosh(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  return vec2(tanh(z.x), tanh(z.y));\n}\n\nvec2 cpow(vec2 z, vec2 p) {\n  return vec2(pow(z.x, p.x), pow(z.y, p.y));\n}\n\nvec2 cpow(vec2 z, float p) {\n  return vec2(pow(z.x, p), pow(z.y, p));\n}\n\nvec2 cpow(float z, vec2 p) {\n  return vec2(pow(z, p.x), pow(z, p.y));\n}\n\nvec2 cpow(float z, float p) {\n  return vec2(pow(z, p));\n}\n\nvec2 csqrt(vec2 z) {\n  return vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 csqrt(float z) {\n  return vec2(sqrt(z));\n}\n\nvec2 csin(vec2 z) {\n  return", "\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the contrast of Alpha while preserving 0-1 range and 1 sum\nvec4 smoothContrast(vec4 alpha, float contrast) {\n  return (alpha - 0", "\n    float d = length(p);\n    float d2 = d*d;\n    float d3 = d2*d;\n    float d4 = d3*d;\n    float d5 = d4*d;\n    float d6 = d5*d;\n    float d7 = d6*d;\n    float d8 = d7*d;\n    float d9 = d8*d;\n    float d10 = d9*d;\n    float d11 = d10*d;\n    float d12 = d11*d;\n    float d13 = d12*d;\n    float d14 = d13*d;\n    float d15 = d14*d;\n    float d16 = d15*d;\n    float d17 = d16*d;\n    float d18 = d17*d;\n    float d19 = d18*d;\n    float d20 = d19*d;\n    float d21 = d20*d;\n    float d22 = d21*d;\n    float d23 = d22*d;\n    float d24 = d23*d;\n    float d25 = d24*d;\n    float d26 = d25*d;\n    float d27 = d26*d;\n    float d28 = d27*d;\n    float d29 = d28*d;\n    float d30 = d29*d;\n    float d31 = d30*d;\n    float d32 = d31*d;\n    float d33 = d32*d;\n    float d34 = d33*d;\n    float d35 = d34*d;\n    float d36 = d35*d;\n    float d37 = d36*d;\n    float d38 = d37*d;\n    float d39 = d38*d;\n    float d40 = d39*d;\n    float d41 = d40*d;\n", "\n    vec3 uvw2 = uvw;\n    uvw2.x = uvw.x + uvw.y;\n    uvw2.y = uvw.y + uvw.z;\n    uvw2.z = uvw.z + uvw.x;\n    vec3 uvw3 = uvw;\n    uvw3.x = uvw.x - uvw.y;\n    uvw3.y = uvw.y - uvw.z;\n    uvw3.z = uvw.z - uvw.x;\n    vec3 uvw4 = uvw;\n    uvw4.x = uvw.x + uvw.y - uvw.z;\n    uvw4.y = uvw.y + uvw.z - uvw.x;\n    uvw4.z = uvw.z + uvw.x - uvw.y;\n    vec3 uvw5 = uvw;\n    uvw5.x = uvw.x - uvw.y + uvw.z;\n    uvw5.y = uvw.y - uvw.z + uvw.x;\n    uvw5.z = uvw.z - uvw.x + uvw.y;\n    vec3 uvw6 = uvw;\n    uvw6.x = uvw.x + uvw.y + uvw.z;\n    uvw6.y = uvw.y + uvw.z + uvw.x;\n    uvw6.z = uvw.z + uvw.x + uvw.y;\n    vec3 uvw7 = uvw;\n    uvw7.x = uvw.x - uvw.y + uvw.z - uvw.x;\n    uvw7.y = uvw.y - uvw.z + uvw.x - uvw.y;\n    uvw7.z = uvw.z - uvw.x + uvw.y - uvw.z;\n    vec3 uvw8 = uvw;\n    uvw8.x = uvw.x + uvw.y - uvw.z - uvw.x;\n    uvw8.y =", "\n    vec3 uvw2 = uvw + offset;\n    vec3 uvw3 = uvw2 + offset;\n    vec3 uvw4 = uvw3 + offset;\n    vec3 uvw5 = uvw4 + offset;\n    vec3 uvw6 = uvw5 + offset;\n    vec3 uvw7 = uvw6 + offset;\n    vec3 uvw8 = uvw7 + offset;\n    vec3 uvw9 = uvw8 + offset;\n    vec3 uvw10 = uvw9 + offset;\n    vec3 uvw11 = uvw10 + offset;\n    vec3 uvw12 = uvw11 + offset;\n    vec3 uvw13 = uvw12 + offset;\n    vec3 uvw14 = uvw13 + offset;\n    vec3 uvw15 = uvw14 + offset;\n    vec3 uvw16 = uvw15 + offset;\n    vec3 uvw17 = uvw16 + offset;\n    vec3 uvw18 = uvw17 + offset;\n    vec3 uvw19 = uvw18 + offset;\n    vec3 uvw20 = uvw19 + offset;\n    vec3 uvw21 = uvw20 + offset;\n    vec3 uvw22 = uvw21 + offset;\n    vec3 uvw23 = uvw22 + offset;\n    vec3 uvw24 = uvw23 + offset;\n    vec3 uvw25 = uvw24 + offset;\n    vec3 uvw26 = uvw25 + offset;\n    vec3 uvw27 = uvw26 + offset;\n    vec3 uvw28 = uvw27 + offset;\n    vec3 uvw29 = uvw28 + offset;\n    vec3 uvw30 = uvw29 + offset;\n    vec3 uvw31 = uvw30 + offset;\n    vec3 uvw32 = uvw31 + offset;\n    vec3 uvw33 = uvw32 + offset;\n    vec3 uvw34 = uvw33 + offset;\n    ", "\n  vec3 uvw0 = uvw;\n  uvw0.z = 0.0;\n  vec3 uvw1 = uvw;\n  uvw1.z = 1.0;\n  vec3 uvw2 = uvw;\n  uvw2.z = 2.0;\n  vec3 uvw3 = uvw;\n  uvw3.z = 3.0;\n  vec3 uvw4 = uvw;\n  uvw4.z = 4.0;\n  vec3 uvw5 = uvw;\n  uvw5.z = 5.0;\n  vec3 uvw6 = uvw;\n  uvw6.z = 6.0;\n  vec3 uvw7 = uvw;\n  uvw7.z = 7.0;\n  vec3 uvw8 = uvw;\n  uvw8.z = 8.0;\n  vec3 uvw9 = uvw;\n  uvw9.z = 9.0;\n  vec3 uvw10 = uvw;\n  uvw10.z = 10.0;\n  vec3 uvw11 = uvw;\n  uvw11.z = 11.0;\n  vec3 uvw12 = uvw;\n  uvw12.z = 12.0;\n  vec3 uvw13 = uvw;\n  uvw13.z = 13.0;\n  vec3 uvw14 = uvw;\n  uvw14.z = 14.0;\n  vec3 uvw15 = uvw;\n  uvw15.z = 15.0;\n  vec3 uvw16 = uvw;\n  uvw16.z = 16.0;\n  vec3 uvw17 = uvw;\n  uvw17.z = 17.0;\n  vec3 uvw18 = uvw;\n  uvw18.z = 18.0;\n  vec3 uvw19 = uvw;\n  uvw19.z = 19.0;\n  ", "\n    return length(p) * 0.5773502691896257;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 c) {\n    return length(p - c) * 0.5773502691896257;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 c, vec3 o) {\n    return length(p - c) * 0.5773502691896257 - length(o - c) * 0.5773502691896257;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 c, vec3 o, vec3 d) {\n    return length(p - c) * 0.5773502691896257 - length(o - c) * 0.5773502691896257 - length(d - c) * 0.5773502691896257;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 c, vec3 o, vec3 d, vec3 e) {\n    return length(p - c) * 0.5773502691896257 - length(o - c) * 0.5773502691896257 - length(d - c) * 0.5773502691896257 - length(e - c) * 0.5773502691896257;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 c, vec3 o, vec3 d, vec3 e, vec3 f) {\n    return length(p - c) * 0.57735026918962", "\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Dark(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Light colormap with polynimal 6\nvec3 Light(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Darker(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Light colormap with polynimal 6\nvec3 Lighter(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Darkest(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Light colormap with polynimal 6\nvec3 Lightest(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Darkest2(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Light colormap with polynimal 6\nvec3 Lightest2(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Darkest3(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Light colormap with polynimal 6\nvec3 Lightest3(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Darkest4(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Light colormap with polynimal 6\nvec3 Lightest4(float t) {\n  return vec3(t, t, t);\n}\n\n// makes Dark colormap with polynimal 6\nvec3 Darkest5(float t) {\n  return vec3(t, t, t);\n", "\n    return v + cross(a, cross(a, v)) / dot(a, a);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b)\n{\n    return rotate(rotate(v, a), b);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c)\n{\n    return rotate(rotate(v, a), b), rotate(c);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return rotate(rotate(v, a), b), rotate(c, d);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n    return rotate(rotate(v, a), b), rotate(c, d), rotate(e);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f)\n{\n    return rotate(rotate(v, a), b), rotate(c, d), rotate(e, f);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g)\n{\n    return rotate(rotate(v, a), b), rotate(c, d), rotate(e, f), rotate(g);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g, vec3 h)\n{\n    return rotate(rotate(v, a), b), rotate(c, d), rotate(e, f), rotate(g, h);\n}\n\nvec3 rotate(vec3 v, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g, vec3 h, vec3 i)\n{\n    return rotate(rotate(v, a), b), rotate(c, d), rotate(e,", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    return length(p) + length(abs(p.x) - abs(p.y));\n}\n\n// Hexagonal grid\nvec2 hexGrid(float i) {\n    return vec2(cos(i), sin(i));\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p) {\n    return vec2(p.x, p.y);\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p, float i) {\n    return vec2(p.x, p.y) + vec2(cos(i), sin(i));\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p, vec2 i) {\n    return vec2(p.x, p.y) + vec2(i.x, i.y);\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p, vec2 i, float j) {\n    return vec2(p.x, p.y) + vec2(i.x, i.y) * j;\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p, vec2 i, vec2 j) {\n    return vec2(p.x, p.y) + vec2(i.x, i.y) * j.x + vec2(j.y, j.x) * j.y;\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p, vec2 i, vec2 j, vec2 k) {\n    return vec2(p.x, p.y) + vec2(i.x, i.y) * j.x + vec2(j.y, j.x) * j.y + vec2(k.x, k.y) * k.x * k.y;\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p, vec2 i, vec2 j, vec2 k, vec2 l) {\n    return vec2(p.x, p.y) + vec2(i.x, i.y) * j.x + vec2(j.y, j.x) * j.y + vec2(k.x, k", "\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 p = abs(uv2) - 0.5;\n    vec2 q = abs(p) - 0.5;\n    vec2 r = abs(q) - 0.5;\n    vec2 s = abs(r) - 0.5;\n    vec2 t = abs(s) - 0.5;\n    vec2 u = abs(t) - 0.5;\n    vec2 v = abs(u) - 0.5;\n    vec2 w = abs(v) - 0.5;\n    vec2 x = abs(w) - 0.5;\n    vec2 y = abs(x) - 0.5;\n    vec2 z = abs(y) - 0.5;\n    vec2 a = abs(z) - 0.5;\n    vec2 b = abs(a) - 0.5;\n    vec2 c = abs(b) - 0.5;\n    vec2 d = abs(c) - 0.5;\n    vec2 e = abs(d) - 0.5;\n    vec2 f = abs(e) - 0.5;\n    vec2 g = abs(f) - 0.5;\n    vec2 h = abs(g) - 0.5;\n    vec2 i = abs(h) - 0.5;\n    vec2 j = abs(i) - 0.5;\n    vec2 k = abs(j) - 0.5;\n    vec2 l = abs(k) - 0.5;\n    vec2 m = abs(l) - 0.5;\n    vec2 n = abs(m) - 0.5;\n    vec2 o = abs(n) - 0.5;\n    vec2 p = abs(o) - 0.5;\n    vec2 q = abs(p) - 0.5;\n    vec2 r = abs(q) - 0.5;\n    vec2 s = abs(r) - 0.5;\n    vec2 t = abs(s)", "\n  float a = 1.0 - pow(t, 2.0);\n  float b = 1.0 - pow(t, 3.0);\n  float c = 1.0 - pow(t, 4.0);\n  float d = 1.0 - pow(t, 5.0);\n  return vec3(a, b, c) * vec3(1.0, 1.0, 1.0) +\n         vec3(d, d, d) * vec3(0.0, 0.0, 0.0);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0, 0.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.zy, K.wz), vec4(c.zw, K.xy), step(c.z, c.y));\n  vec4 q = mix(vec4(p.xyw, K.xyw), p.yzx, step(p.y, c.x));\n  float d = q.x - min(q.w, q.y);\n  return vec3(abs(q.z - q.x) / (q.w - q.x + 1e-6), d / (1.0 - abs(d)), q.x);\n}\n\nvec3 rgb2hsv2(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.", "\n\treturn (x + 1.0f) / 2.0f;\n}\n\n//returns a random number between min and max\nfloat random(float min, float max) {\n\treturn min + (max - min) * randomf();\n}\n\n//returns a random number between 0 and 1\nfloat randomf() {\n\treturn rand() / (float)RAND_MAX;\n}\n\n//returns a random number between min and max\nint random(int min, int max) {\n\treturn min + (max - min) * randomf();\n}\n\n//returns a random number between 0 and 1\nint randomf(int min, int max) {\n\treturn min + (max - min) * randomf();\n}\n\n//returns a random number between min and max\nint random(int min, int max, int seed) {\n\tsrand(seed);\n\treturn min + (max - min) * randomf();\n}\n\n//returns a random number between min and max\nint randomf(int min, int max, int seed) {\n\tsrand(seed);\n\treturn min + (max - min) * randomf();\n}\n\n//returns a random number between min and max\nint random(int min, int max, int seed, int mod) {\n\tsrand(seed);\n\treturn min + (max - min) * randomf(mod);\n}\n\n//returns a random number between min and max\nint randomf(int min, int max, int seed, int mod) {\n\tsrand(seed);\n\treturn min + (max - min) * randomf(mod);\n}\n\n//returns a random number between min and max\nint random(int min, int max, int seed, int mod, int mod2) {\n\tsrand(seed);\n\treturn min + (max - min) * randomf(mod, mod2);\n}\n\n//returns a random number between min and max\nint randomf(int min, int max, int seed, int mod, int mod2) {\n\tsrand(seed);\n\treturn min + (max - min) * randomf(mod, mod2);\n}\n\n//returns a random number between min and max\nint random", "\n    vec2 p = fract(uv * gridRes);\n    vec2 q = floor(uv * gridRes);\n    vec2 r = p - q;\n    vec2 s = r * r * r * (1.0 - r);\n    vec2 t = s * s * s * (1.0 - s);\n    vec2 u = t * t * t * (1.0 - t);\n    vec2 v = u * u * u * (1.0 - u);\n    vec2 w = v * v * v * (1.0 - v);\n    vec2 x = w * w * w * (1.0 - w);\n    vec2 y = x * x * x * (1.0 - x);\n    vec2 z = y * y * y * (1.0 - y);\n    vec2 a = z * z * z * (1.0 - z);\n    vec2 b = a * a * a * (1.0 - a);\n    vec2 c = b * b * b * (1.0 - b);\n    vec2 d = c * c * c * (1.0 - c);\n    vec2 e = d * d * d * (1.0 - d);\n    vec2 f = e * e * e * (1.0 - e);\n    vec2 g = f * f * f * (1.0 - f);\n    vec2 h = g * g * g * (1.0 - g);\n    vec2 i = h * h * h * (1.0 - h);\n    vec2 j = i * i * i * (1.0 - i);\n    vec2 k = j * j * j * (1.0 - j);\n    vec2 l = k * k * k * (1.0 - k);\n    vec2 m = l * l * l * (1.0 - l);\n    vec2 n = m * m * m * (1.0 - m);\n    vec2 o = n * n * n * (1.0 - n);\n    vec2 p = o * o * o * (1.0 - o);\n    vec2 q = p * p * p * (1.0 - p);\n", "\n    vec2 uv0 = uv;\n    vec2 uv1 = uv + vec2(0.0, len);\n    vec2 uv2 = uv + vec2(len, 0.0);\n    vec2 uv3 = uv + vec2(len, len);\n\n    vec2 uv00 = uv0 + vec2(-gridRes, -gridRes);\n    vec2 uv01 = uv0 + vec2(-gridRes, gridRes);\n    vec2 uv02 = uv0 + vec2(gridRes, -gridRes);\n    vec2 uv03 = uv0 + vec2(gridRes, gridRes);\n\n    vec2 uv10 = uv1 + vec2(-gridRes, -gridRes);\n    vec2 uv11 = uv1 + vec2(-gridRes, gridRes);\n    vec2 uv12 = uv1 + vec2(gridRes, -gridRes);\n    vec2 uv13 = uv1 + vec2(gridRes, gridRes);\n\n    vec2 uv20 = uv2 + vec2(-gridRes, -gridRes);\n    vec2 uv21 = uv2 + vec2(-gridRes, gridRes);\n    vec2 uv22 = uv2 + vec2(gridRes, -gridRes);\n    vec2 uv23 = uv2 + vec2(gridRes, gridRes);\n\n    vec2 uv30 = uv3 + vec2(-gridRes, -gridRes);\n    vec2 uv31 = uv3 + vec2(-gridRes, gridRes);\n    vec2 uv32 = uv3 + vec2(gridRes, -gridRes);\n    vec2 uv33 = uv3 + vec2(gridRes, gridRes);\n\n    vec2 uv000 = uv00 + vec2(-gridRes, -gridRes);\n    vec2 uv001 = uv00 + vec2(-gridRes, gridRes);\n    vec2 uv002 = uv00 + vec2(gridRes, -gridRes);\n    vec", "\n    vec2 flow = vec2(0.0);\n    float dist = distance(point, vec2(0.0));\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float flowAngle = angle + time * 0.5;\n        flow.x = cos(flowAngle) * 0.5;\n        flow.y = sin(flowAngle) * 0.5;\n    }\n    return flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    vec2 flow = vec2(0.0);\n    float dist = distance(point, vec2(0.0));\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float flowAngle = angle + time * 0.5;\n        flow.x = cos(flowAngle) * 0.5;\n        flow.y = sin(flowAngle) * 0.5;\n    }\n    return flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    vec2 flow = vec2(0.0);\n    float dist = distance(point, vec2(0.0));\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float flowAngle = angle + time * 0.5;\n        flow.x = cos(flowAngle) * 0.5;\n        flow.y = sin(flowAngle) * 0.5;\n    }\n    return flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    vec2 flow = vec2(0.0);\n    float dist = distance(point, vec2(0.0));\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float flowAngle = angle + time * 0.5;\n        flow.x = cos(flowAngle) * 0", "\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n  return vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2", "\n    vec2 d = p2 - p1;\n    vec2 v = p - p1;\n    float a = dot(d, d);\n    float b = dot(d, v);\n    float c = dot(v, v) - 0.25 * a;\n    float discr = b * b - a * c;\n    return discr < 0.0? -1.0 : -(b + sqrt(discr)) / a;\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 d1 = p1 - p;\n    vec2 d2 = p2 - p;\n    vec2 d3 = p3 - p;\n    vec2 v1 = d2 - d1;\n    vec2 v2 = d3 - d1;\n    float a1 = dot(d1, d1);\n    float a2 = dot(d2, d2);\n    float a3 = dot(d3, d3);\n    float a12 = dot(d1, d2);\n    float a13 = dot(d1, d3);\n    float a23 = dot(d2, d3);\n    float a123 = dot(d1, d23);\n    float a231 = dot(d2, d31);\n    float a312 = dot(d3, d12);\n    float a132 = dot(d1, d32);\n    float a213 = dot(d2, d13);\n    float a321 = dot(d3, d21);\n    float a121 = dot(d1, d21);\n    float a232 = dot(d2, d32);\n    float a313 = dot(d3, d13);\n    float a131 = dot(d1, d31);\n    float a212 = dot(d2, d12);\n    float a323 = dot(d3, d23);\n    float a122 = dot(d1, d", "\n  float d = length(v);\n  float a = atan(v.y, v.x);\n  float r = 0.0;\n  if (d > 0.0) {\n    r = 0.5 * d * sin(a);\n  }\n  return r;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float desired) {\n  float d = length(v);\n  float a = atan(v.y, v.x);\n  float r = 0.0;\n  if (d > 0.0) {\n    r = 0.5 * d * sin(a);\n  }\n  return r - desired;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float desired, float scale) {\n  float d = length(v);\n  float a = atan(v.y, v.x);\n  float r = 0.0;\n  if (d > 0.0) {\n    r = 0.5 * d * sin(a);\n  }\n  return r - desired * scale;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float desired, float scale, float offset) {\n  float d = length(v);\n  float a = atan(v.y, v.x);\n  float r = 0.0;\n  if (d > 0.0) {\n    r = 0.5 * d * sin(a);\n  }\n  return r - desired * scale + offset;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float desired, float scale, float offset, float alpha) {\n  float d = length(v);\n  float a = atan(v.y, v.x);\n  float r = 0.0;\n  if (d > 0.0) {\n    r = 0.5 * d * sin(a);\n  }\n  return r - desired * scale + offset * alpha;\n}\n\n// Returns a signed distance from the arrow", "\n    return (x + 1.0) / 2.0;\n}\n\n//returns a random number between 0 and 1\nfloat random() {\n    return fract(sin(dot(vec2(12.9898, 78.233), vec2(v.x, v.y))) * 43758.5453);\n}\n\n//returns a random number between 0 and 1\nvec2 random2() {\n    return vec2(random(), random());\n}\n\n//returns a random number between 0 and 1\nvec3 random3() {\n    return vec3(random(), random(), random());\n}\n\n//returns a random number between 0 and 1\nvec4 random4() {\n    return vec4(random(), random(), random(), random());\n}\n\n//returns a random number between 0 and 1\nfloat randomFloat() {\n    return random();\n}\n\n//returns a random number between 0 and 1\nvec2 randomVec2() {\n    return random2();\n}\n\n//returns a random number between 0 and 1\nvec3 randomVec3() {\n    return random3();\n}\n\n//returns a random number between 0 and 1\nvec4 randomVec4() {\n    return random4();\n}\n\n//returns a random number between 0 and 1\nfloat randomFloat() {\n    return random();\n}\n\n//returns a random number between 0 and 1\nvec2 randomVec2() {\n    return random2();\n}\n\n//returns a random number between 0 and 1\nvec3 randomVec3() {\n    return random3();\n}\n\n//returns a random number between 0 and 1\nvec4 randomVec4() {\n    return random4();\n}\n\n//returns a random number between 0 and 1\nfloat randomFloat() {\n    return random();\n}\n\n//returns a random number between 0 and 1\nvec2 randomVec2() {\n    return random2();\n}\n\n//returns a random number between 0 and 1\nvec3 randomVec3() {\n    return random3();\n", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float flow = 0.0;\n    float flowAngle = 0.0;\n    float flowRadius = 0.0;\n    float flowSpread = 0.0;\n    float flowOffset = 0.0;\n    float flowAngleStep = 0.0;\n    float flowRadiusStep = 0.0;\n    float flowSpreadStep = 0.0;\n    float flowOffsetStep = 0.0;\n    float flowAngleStepSize = 0.0;\n    float flowRadiusStepSize = 0.0;\n    float flowSpreadStepSize = 0.0;\n    float flowOffsetStepSize = 0.0;\n    float flowAngleStepSizeMax = 0.0;\n    float flowRadiusStepSizeMax = 0.0;\n    float flowSpreadStepSizeMax = 0.0;\n    float flowOffsetStepSizeMax = 0.0;\n    float flowAngleStepSizeMax = 0.0;\n    float flowRadiusStepSizeMax = 0.0;\n    float flowSpreadStepSizeMax = 0.0;\n    float flowOffsetStepSizeMax = 0.0;\n    float flowAngleStepSizeMax = 0.0;\n    float flowRadiusStepSizeMax = 0.0;\n    float flowSpreadStepSizeMax = 0.0;\n    float flowOffsetStepSizeMax = 0.0;\n    float flowAngleStepSizeMax = 0.0;\n    float flowRadiusStepSizeMax = 0.0;\n    float flowSpreadStepSizeMax = 0.0;\n    float flowOffsetStepSizeMax = 0.0;\n    float flowAngleStepSizeMax = 0.0;\n    float flowRadiusStepSizeMax = 0.0;\n    float flowSpreadStepSizeMax = 0.0;\n    float flowOffsetStepSizeMax = 0.0;\n    float flowAngleStepSizeMax = 0.0;\n    float flowRadiusStepSizeMax = 0.0;\n    float flowSpreadStepSizeMax = 0.0;\n    ", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCylinder( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdCone( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - min(max(d.x,d.y),0.0);\n}\n\nfloat sdCone( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdCone( in vec2 p, in vec2 b, in float r, in float h )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - min(max(d.x,d.y),0.0) - r - h*0.5;\n}\n\nfloat sdCone( in vec2 p, in vec2 b, in float r, in float h, in float k )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - min(max(d.x,d.y),0.0) - r - h*0.5 - k*0.5;\n}\n\nfloat sdCone( in vec2 p, in vec2 b, in float r, in float h, in float k, in float a )\n{\n    vec2 d = abs(p) - b;\n    return length", "\n    float s = 0.0;\n    float d = 0.0;\n    float t = 0.0;\n    float r = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    ", "\n    float t = time * 0.001;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float ww", "\n    return length(uvw);\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw) - 1.0;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw.xy);\n    return h - d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float h = length(uvw.yz);\n    float d = length(uvw", "\n  vec3 uvw0 = mod(uvw, 1.0);\n  vec3 uvw1 = mod(uvw + vec3(1.0), 1.0);\n  vec3 uvw2 = mod(uvw + vec3(2.0), 1.0);\n  vec3 uvw3 = mod(uvw + vec3(3.0), 1.0);\n  vec3 uvw4 = mod(uvw + vec3(4.0), 1.0);\n  vec3 uvw5 = mod(uvw + vec3(5.0), 1.0);\n  vec3 uvw6 = mod(uvw + vec3(6.0), 1.0);\n  vec3 uvw7 = mod(uvw + vec3(7.0), 1.0);\n  vec3 uvw8 = mod(uvw + vec3(8.0), 1.0);\n  vec3 uvw9 = mod(uvw + vec3(9.0), 1.0);\n  vec3 uvw10 = mod(uvw + vec3(10.0), 1.0);\n  vec3 uvw11 = mod(uvw + vec3(11.0), 1.0);\n  vec3 uvw12 = mod(uvw + vec3(12.0), 1.0);\n  vec3 uvw13 = mod(uvw + vec3(13.0), 1.0);\n  vec3 uvw14 = mod(uvw + vec3(14.0), 1.0);\n  vec3 uvw15 = mod(uvw + vec3(15.0), 1.0);\n  vec3 uvw16 = mod(uvw + vec3(16.0), 1.0);\n  vec3 uvw17 = mod(uvw + vec3(17.0), 1.0);\n  vec3 uvw18 = mod(uvw + vec3(18.0), 1.0);\n  vec3 uvw19", "\n  vec3 uvw0 = uvw - offset;\n  vec3 uvw1 = uvw + offset;\n  vec3 uvw2 = uvw + vec3(1.0, 0.0, 0.0) * offset;\n  vec3 uvw3 = uvw + vec3(0.0, 1.0, 0.0) * offset;\n  vec3 uvw4 = uvw + vec3(0.0, 0.0, 1.0) * offset;\n  vec3 uvw5 = uvw - vec3(1.0, 0.0, 0.0) * offset;\n  vec3 uvw6 = uvw - vec3(0.0, 1.0, 0.0) * offset;\n  vec3 uvw7 = uvw - vec3(0.0, 0.0, 1.0) * offset;\n  vec3 uvw8 = uvw0 + vec3(1.0, 0.0, 0.0) * gridRes;\n  vec3 uvw9 = uvw0 + vec3(0.0, 1.0, 0.0) * gridRes;\n  vec3 uvw10 = uvw0 + vec3(0.0, 0.0, 1.0) * gridRes;\n  vec3 uvw11 = uvw1 + vec3(1.0, 0.0, 0.0) * gridRes;\n  vec3 uvw12 = uvw1 + vec3(0.0, 1.0, 0.0) * gridRes;\n  vec3 uvw13 = uvw1 + vec3(0.0, 0.0, 1.0) * gridRes;\n  vec3 uvw14 = uvw2 + vec3(1.0, 0.0, 0.0) * gridRes;\n  vec3 uvw15 = uvw2 + vec3(0.0, 1.0, 0.0) * gridRes;\n  vec3 uvw16 = uvw2 + vec3(0.0, 0.0, 1.0)", "\n  return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), t);\n}\n\nvec3 RdYlBu_g(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), t);\n}\n\nvec3 RdYlBu_b(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\nvec3 RdYlBu_r_g(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t);\n}\n\nvec3 RdYlBu_r_b(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), t);\n}\n\nvec3 RdYlBu_g_b(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), t);\n}\n\nvec3 RdYlBu_r_g_b(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), t);\n}\n\nvec3 RdYlBu_r_g_b_a(float t) {\n  return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), t);\n}\n\nvec3 RdYlBu_r_g_b_a_r(float t) {\n  return mix(vec3(", "\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    float d = 0.0;\n    for (int i = 0; i < 8; i++) {\n        q = p - vec3(i, i, i);\n        d = max(d, length(q));\n    }\n    return d;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecDist(vec3 p) {\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    float d = 0.0;\n    for (int i = 0; i < 20; i++) {\n        q = p - vec3(i, i, i);\n        d = max(d, length(q));\n    }\n    return d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosDist(vec3 p) {\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    float d = 0.0;\n    for (int i = 0; i < 12; i++) {\n        q = p - vec3(i, i, i);\n        d = max(d, length(q));\n    }\n    return d;\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    float d = 0.0;\n    for (int i = 0; i < 6; i++) {\n        q = p - vec3(i, i, i);\n        d = max(d, length(q));\n    }\n    return d;\n}\n\n//Distance from the Edge of Pyramid\nfloat pyramidDist(vec3 p) {\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    float d = 0.0;\n    for (int i = 0; i < 3; i++) {\n        q = p - vec3(i, i, i);\n        d = max", "\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 summer(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 autumn(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 winter2(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 summer2(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 autumn2(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 winter3(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 summer3(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 autumn3(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t);\n  return vec3(c, c, c);\n}\n\nvec3 winter4(float t) {\n  float c = 0.5 + 0.5 * sin(6.2831853 * t", "\n  vec2 uv2 = uv * 2.0;\n  vec2 uv3 = uv2 * 2.0;\n  vec2 uv4 = uv3 * 2.0;\n  vec2 uv5 = uv4 * 2.0;\n  vec2 uv6 = uv5 * 2.0;\n  vec2 uv7 = uv6 * 2.0;\n  vec2 uv8 = uv7 * 2.0;\n  vec2 uv9 = uv8 * 2.0;\n  vec2 uv10 = uv9 * 2.0;\n  vec2 uv11 = uv10 * 2.0;\n  vec2 uv12 = uv11 * 2.0;\n  vec2 uv13 = uv12 * 2.0;\n  vec2 uv14 = uv13 * 2.0;\n  vec2 uv15 = uv14 * 2.0;\n  vec2 uv16 = uv15 * 2.0;\n  vec2 uv17 = uv16 * 2.0;\n  vec2 uv18 = uv17 * 2.0;\n  vec2 uv19 = uv18 * 2.0;\n  vec2 uv20 = uv19 * 2.0;\n  vec2 uv21 = uv20 * 2.0;\n  vec2 uv22 = uv21 * 2.0;\n  vec2 uv23 = uv22 * 2.0;\n  vec2 uv24 = uv23 * 2.0;\n  vec2 uv25 = uv24 * 2.0;\n  vec2 uv26 = uv25 * 2.0;\n  vec2 uv27 = uv26 * 2.0;\n  vec2 uv28 = uv27 * 2.0;\n  vec2 uv29 = uv28 * 2.", "\n  vec2 uv2 = uv * 2.0;\n  vec2 uv3 = uv * 3.0;\n  vec2 uv4 = uv * 4.0;\n  vec2 uv5 = uv * 5.0;\n  vec2 uv6 = uv * 6.0;\n  vec2 uv7 = uv * 7.0;\n  vec2 uv8 = uv * 8.0;\n  vec2 uv9 = uv * 9.0;\n  vec2 uv10 = uv * 10.0;\n  vec2 uv11 = uv * 11.0;\n  vec2 uv12 = uv * 12.0;\n  vec2 uv13 = uv * 13.0;\n  vec2 uv14 = uv * 14.0;\n  vec2 uv15 = uv * 15.0;\n  vec2 uv16 = uv * 16.0;\n  vec2 uv17 = uv * 17.0;\n  vec2 uv18 = uv * 18.0;\n  vec2 uv19 = uv * 19.0;\n  vec2 uv20 = uv * 20.0;\n  vec2 uv21 = uv * 21.0;\n  vec2 uv22 = uv * 22.0;\n  vec2 uv23 = uv * 23.0;\n  vec2 uv24 = uv * 24.0;\n  vec2 uv25 = uv * 25.0;\n  vec2 uv26 = uv * 26.0;\n  vec2 uv27 = uv * 27.0;\n  vec2 uv28 = uv * 28.0;\n  vec2 uv29 = uv * 29.0;\n  vec2 uv30 = uv * 30.0;\n  vec2 uv", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 uvGrid = uv - grid;\n    vec2 uvGrid2 = uvGrid * uvGrid * (3.0 - 2.0 * uvGrid);\n    vec2 uvGrid3 = uvGrid2 * uvGrid * (3.0 - 2.0 * uvGrid2);\n    vec2 uvGrid4 = uvGrid3 * uvGrid * (3.0 - 2.0 * uvGrid3);\n    vec2 uvGrid5 = uvGrid4 * uvGrid * (3.0 - 2.0 * uvGrid4);\n    vec2 uvGrid6 = uvGrid5 * uvGrid * (3.0 - 2.0 * uvGrid5);\n    vec2 uvGrid7 = uvGrid6 * uvGrid * (3.0 - 2.0 * uvGrid6);\n    vec2 uvGrid8 = uvGrid7 * uvGrid * (3.0 - 2.0 * uvGrid7);\n    vec2 uvGrid9 = uvGrid8 * uvGrid * (3.0 - 2.0 * uvGrid8);\n    vec2 uvGrid10 = uvGrid9 * uvGrid * (3.0 - 2.0 * uvGrid9);\n    vec2 uvGrid11 = uvGrid10 * uvGrid * (3.0 - 2.0 * uvGrid10);\n    vec2 uvGrid12 = uvGrid11 * uvGrid * (3.0 - 2.0 * uvGrid11);\n    vec2 uvGrid13 = uvGrid12 * uvGrid * (3.0 - 2.0 * uvGrid12);\n    vec2 uvGrid14 = uvGrid13 * uvGrid * (3.0 - 2.0 * uvGrid13);\n    vec2 uvGrid15 = uvGrid14 * uvGrid * (3.0 - 2.0 * uvGrid14);\n    vec2 uvGrid16 =", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 uvGrid = fract(uv * gridRes);\n    vec2 uvGrid2 = uvGrid * uvGrid * (3.0 - 2.0 * uvGrid);\n    vec2 uvGrid3 = uvGrid2 * uvGrid * (3.0 - 2.0 * uvGrid2);\n    vec2 uvGrid4 = uvGrid3 * uvGrid * (3.0 - 2.0 * uvGrid3);\n    vec2 uvGrid5 = uvGrid4 * uvGrid * (3.0 - 2.0 * uvGrid4);\n    vec2 uvGrid6 = uvGrid5 * uvGrid * (3.0 - 2.0 * uvGrid5);\n    vec2 uvGrid7 = uvGrid6 * uvGrid * (3.0 - 2.0 * uvGrid6);\n    vec2 uvGrid8 = uvGrid7 * uvGrid * (3.0 - 2.0 * uvGrid7);\n    vec2 uvGrid9 = uvGrid8 * uvGrid * (3.0 - 2.0 * uvGrid8);\n    vec2 uvGrid10 = uvGrid9 * uvGrid * (3.0 - 2.0 * uvGrid9);\n    vec2 uvGrid11 = uvGrid10 * uvGrid * (3.0 - 2.0 * uvGrid10);\n    vec2 uvGrid12 = uvGrid11 * uvGrid * (3.0 - 2.0 * uvGrid11);\n    vec2 uvGrid13 = uvGrid12 * uvGrid * (3.0 - 2.0 * uvGrid12);\n    vec2 uvGrid14 = uvGrid13 * uvGrid * (3.0 - 2.0 * uvGrid13);\n    vec2 uvGrid15 = uvGrid14 * uvGrid * (3.0 - 2.0 * uvGrid14);\n    vec2 uvGrid1", "\n    vec2 uvOffset = uv + offset;\n    vec2 uvGrid = floor(uvOffset / gridRes);\n    vec2 uvRemainder = fract(uvOffset / gridRes);\n    vec2 uvGridRemainder = fract(uvGrid / gridRes);\n    vec2 uvGridOffset = uvGrid + uvRemainder;\n    vec2 uvGridOffsetRemainder = fract(uvGridOffset / gridRes);\n    vec2 uvGridOffsetRemainder2 = uvGridOffsetRemainder * 2.0;\n    vec2 uvGridOffsetRemainder3 = uvGridOffsetRemainder * 3.0;\n    vec2 uvGridOffsetRemainder4 = uvGridOffsetRemainder * 4.0;\n    vec2 uvGridOffsetRemainder5 = uvGridOffsetRemainder * 5.0;\n    vec2 uvGridOffsetRemainder6 = uvGridOffsetRemainder * 6.0;\n    vec2 uvGridOffsetRemainder7 = uvGridOffsetRemainder * 7.0;\n    vec2 uvGridOffsetRemainder8 = uvGridOffsetRemainder * 8.0;\n    vec2 uvGridOffsetRemainder9 = uvGridOffsetRemainder * 9.0;\n    vec2 uvGridOffsetRemainder10 = uvGridOffsetRemainder * 10.0;\n    vec2 uvGridOffsetRemainder11 = uvGridOffsetRemainder * 11.0;\n    vec2 uvGridOffsetRemainder12 = uvGridOffsetRemainder * 12.0;\n    vec2 uvGridOffsetRemainder13 = uvGridOffsetRemainder * 13.0;\n    vec2 uvGridOffsetRemainder14 = uvGridOffsetRemainder * 14.0;\n    vec2 uvGridOffsetRemainder15 = uvGridOffsetRemainder * 15.0;\n    vec2 uvGridOffsetRemainder16 = uvGridOffsetRemainder * 16.0;\n    ", "\n    float x = uv.x;\n    float y = uv.y;\n    float xi = x * gridRes;\n    float yi = y * gridRes;\n    float xi2 = xi * xi;\n    float yi2 = yi * yi;\n    float xi3 = xi2 * xi;\n    float yi3 = yi2 * yi;\n    float xi4 = xi3 * xi;\n    float yi4 = yi3 * yi;\n    float xi5 = xi4 * xi;\n    float yi5 = yi4 * yi;\n    float xi6 = xi5 * xi;\n    float yi6 = yi5 * yi;\n    float xi7 = xi6 * xi;\n    float yi7 = yi6 * yi;\n    float xi8 = xi7 * xi;\n    float yi8 = yi7 * yi;\n    float xi9 = xi8 * xi;\n    float yi9 = yi8 * yi;\n    float xi10 = xi9 * xi;\n    float yi10 = yi9 * yi;\n    float xi11 = xi10 * xi;\n    float yi11 = yi10 * yi;\n    float xi12 = xi11 * xi;\n    float yi12 = yi11 * yi;\n    float xi13 = xi12 * xi;\n    float yi13 = yi12 * yi;\n    float xi14 = xi13 * xi;\n    float yi14 = yi13 * yi;\n    float xi15 = xi14 * xi;\n    float yi15 = yi14 * yi;\n    float xi16 = xi15 * xi;\n    float yi16 = yi15 * yi;\n    float xi17 = xi16 * xi;\n    float yi17 = yi", "\n    vec2 f = fract( p );\n    vec2 i = floor( p );\n    vec2 e = ddx * ddy;\n    return mix( e, e - ddx, f.y ) + mix( e - ddy, e - ddx, f.x );\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGradCircle( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 f = fract( p );\n    vec2 i = floor( p );\n    vec2 e = ddx * ddy;\n    return mix( e, e - ddx, f.y ) + mix( e - ddy, e - ddx, f.x );\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGradSquare( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 f = fract( p );\n    vec2 i = floor( p );\n    vec2 e = ddx * ddy;\n    return mix( e, e - ddx, f.y ) + mix( e - ddy, e - ddx, f.x );\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float size )\n{\n    vec2 f = fract( p );\n    vec2 i = floor( p );\n    vec2 e = ddx * ddy;\n    return mix( e, e - ddx, f.y ) + mix( e - ddy, e - ddx, f.x );\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float size, in float size2 )\n{\n    vec2 f = fract( p );\n    vec2 i = floor( p );\n    vec2 e = ddx * ddy;\n    return mix( e, e - ddx,", "\n  float a = 0.57735026918962576450;\n  float b = 0.57735026918962576450;\n  float c = 0.57735026918962576450;\n  float d = 0.57735026918962576450;\n  float e = 0.57735026918962576450;\n  float f = 0.57735026918962576450;\n  float g = 0.57735026918962576450;\n  float h = 0.57735026918962576450;\n  float i = 0.57735026918962576450;\n  float j = 0.57735026918962576450;\n  float k = 0.57735026918962576450;\n  float l = 0.57735026918962576450;\n  float m = 0.57735026918962576450;\n  float n = 0.57735026918962576450;\n  float o = 0.57735026918962576450;\n  float p = 0.57735026918962576450;\n  float q = 0.57735026918962576450;\n  float r = 0.57735026918", "\n    p = fract(p * 0.5);\n    p = p * p * (3.0 - 2.0 * p);\n    return p;\n}\n\nvec2 hexgrid(inout vec2 p, inout vec2 c) {\n    p = fract(p * 0.5);\n    p = p * p * (3.0 - 2.0 * p);\n    c = c * 0.5 + 0.5;\n    return p + c;\n}\n\nvec2 hexgrid(inout vec2 p, inout vec2 c, in vec2 s) {\n    p = fract(p * 0.5);\n    p = p * p * (3.0 - 2.0 * p);\n    c = c * 0.5 + 0.5;\n    return p + c * s;\n}\n\nvec2 hexgrid(inout vec2 p, inout vec2 c, in vec2 s, in vec2 t) {\n    p = fract(p * 0.5);\n    p = p * p * (3.0 - 2.0 * p);\n    c = c * 0.5 + 0.5;\n    return p + c * s + t;\n}\n\nvec2 hexgrid(inout vec2 p, inout vec2 c, in vec2 s, in vec2 t, in vec2 u) {\n    p = fract(p * 0.5);\n    p = p * p * (3.0 - 2.0 * p);\n    c = c * 0.5 + 0.5;\n    return p + c * s + t + u;\n}\n\nvec2 hexgrid(inout vec2 p, inout vec2 c, in vec2 s, in vec2 t, in vec2 u, in vec2 v) {\n    p = fract(p * 0.5);\n    p = p * p * (3.0 - 2.0 * p);\n    c = c * 0.5 + 0.5;\n    return p + c * s + t + u + v;\n}\n\nvec2 hexgrid(inout vec2 p", "\n    return 1.0 - abs( x );\n}\n\nvec3 fun( in vec3 x )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z, in vec3 w )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z, in vec3 w, in vec3 v )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z, in vec3 w, in vec3 v, in vec3 u )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z, in vec3 w, in vec3 v, in vec3 u, in vec3 t )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z, in vec3 w, in vec3 v, in vec3 u, in vec3 t, in vec3 s )\n{\n    return vec3( fun( x.x ), fun( x.y ), fun( x.z ) );\n}\n\nvec3 fun( in vec3 x, in vec3 y, in vec3 z, in", "\n    return pow(t, vec3(1.0/2.2));\n}\n\nvec3 sRGB_to_linear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 sRGB_to_gamma(vec3 t) {\n    return pow(t, vec3(1.0/2.2));\n}\n\nvec3 gamma_to_sRGB(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 gamma_to_sRGB_linear(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 gamma_to_sRGB_linear_in_place(vec3 t) {\n    t = pow(t, vec3(2.2));\n    return t;\n}\n\nvec3 gamma_to_sRGB_linear_in_place_with_clamp(vec3 t) {\n    t = pow(t, vec3(2.2));\n    return clamp(t, vec3(0.0), vec3(1.0));\n}\n\nvec3 gamma_to_sRGB_linear_in_place_with_clamp_and_clamp_to_linear(vec3 t) {\n    t = pow(t, vec3(2.2));\n    return clamp(t, vec3(0.0), vec3(1.0));\n}\n\nvec3 gamma_to_sRGB_linear_in_place_with_clamp_and_clamp_to_linear_in_place(vec3 t) {\n    t = pow(t, vec3(2.2));\n    return clamp(t, vec3(0.0), vec3(1.0));\n}\n\nvec3 gamma_to_sRGB_linear_in_place_with_clamp_and_clamp_to_linear_in_place_with_clamp(vec3 t) {\n    t = pow(t, vec3(2.2));\n    return clamp(t, vec3(0.0), vec3(1.0));\n}\n\nvec3 gamma_to_sRGB", "\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df6(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df7(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Classic truchet pattern\nfloat df8(vec2 p) {\n  return fract(sin(dot(p, vec2(12", "\n  float a = 0.0;\n  float b = 0.0;\n  float c = 0.0;\n  float d = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  float p = 0.0;\n  float q = 0.0;\n  float r = 0.0;\n  float s = 0.0;\n  float t = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float w = 0.0;\n  float x = 0.0;\n  float y = 0.0;\n  float z = 0.0;\n  float aa = 0.0;\n  float bb = 0.0;\n  float cc = 0.0;\n  float dd = 0.0;\n  float ee = 0.0;\n  float ff = 0.0;\n  float gg = 0.0;\n  float hh = 0.0;\n  float ii = 0.0;\n  float jj = 0.0;\n  float kk = 0.0;\n  float ll = 0.0;\n  float mm = 0.0;\n  float nn = 0.0;\n  float oo = 0.0;\n  float pp = 0.0;\n  float qq = 0.0;\n  float rr = 0.0;\n  float ss = 0.0;\n  float tt = 0.0;\n  float uu = 0.0;\n  float vv = 0.0;\n  float ww = 0.0;\n  float xx = 0.", "\n    vec2 d = abs(p - p0) - abs(p - p1) - abs(p - p2);\n    return min(d.x, min(d.y, 0.0)) + max(d.x, max(d.y, 0.0));\n}\n\n// signed distance to a 3D triangle\nfloat sdTriangle( in vec3 p, in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 d = abs(p - p0) - abs(p - p1) - abs(p - p2);\n    return min(d.x, min(d.y, d.z)) + max(d.x, max(d.y, d.z));\n}\n\n// signed distance to a 4D triangle\nfloat sdTriangle( in vec4 p, in vec4 p0, in vec4 p1, in vec4 p2 )\n{\n    vec4 d = abs(p - p0) - abs(p - p1) - abs(p - p2);\n    return min(d.x, min(d.y, min(d.z, d.w))) + max(d.x, max(d.y, max(d.z, d.w)));\n}\n\n// signed distance to a 2D box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(d.x, min(d.y, max(d.x, d.y)));\n}\n\n// signed distance to a 3D box\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(d.x, min(d.y, d.z)) + max(d.x, max(d.y, d.z));\n}\n\n// signed distance to a 4D box\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min(d.x, min(d.y, min(d", "\n  vec3 ro_to_sph = rd - sph.xyz;\n  float d = length(ro_to_sph);\n  float r = sph.w;\n  float h = d - r;\n  float h2 = h*h;\n  float h4 = h2*h2;\n  float h6 = h4*h2;\n  float h8 = h4*h4;\n  float h10 = h4*h4*h2;\n  float h12 = h4*h4*h4;\n  float h14 = h4*h4*h4;\n  float h16 = h4*h4*h4*h2;\n  float h18 = h4*h4*h4*h4;\n  float h20 = h4*h4*h4*h4*h2;\n  float h22 = h4*h4*h4*h4*h4;\n  float h24 = h4*h4*h4*h4*h4*h2;\n  float h26 = h4*h4*h4*h4*h4*h4;\n  float h28 = h4*h4*h4*h4*h4*h4*h2;\n  float h30 = h4*h4*h4*h4*h4*h4*h4;\n  float h32 = h4*h4*h4*h4*h4*h4*h4*h2;\n  float h34 = h4*h4*h4*h4*h4*h4*h4*h4;\n  float h36 = h4*h4*h4*h4*h4*h4*h4*h4*h2;\n  float h38 = h4*h4*h4*h4*h4*h4*h4*h4*h4;\n  float h40 = h4*h4*h4*h4*h4*h4*h4*h4*h4*h2;\n  float h42 = h4*h", "\n  float d = distance(p, vec2(0.0, 0.0));\n  return smoothstep(r, r + w, d) * smoothstep(r, r + w, d + w);\n}\n\nfloat roundedY(vec2 p, float h, float r) {\n  float d = distance(p, vec2(0.0, 0.0));\n  return smoothstep(r, r + h, d) * smoothstep(r, r + h, d + h);\n}\n\nfloat rounded(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedCircle(vec2 p, float r) {\n  return rounded(p, 2.0 * r, 2.0 * r, r);\n}\n\nfloat roundedRect(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedRectangle(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedRectangle2(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedRectangle3(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedRectangle4(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedRectangle5(vec2 p, float w, float h, float r) {\n  return min(roundedX(p, w, r), roundedY(p, h, r));\n}\n\nfloat roundedRectangle6(vec2 p, float w, float h, float r) {\n  ", "\n    float a = 1.0 / k;\n    float b = 1.0 / (1.0 - k);\n    float c = 1.0 / (1.0 + k);\n    float d = 1.0 / (1.0 - k);\n    float e = 1.0 / (1.0 + k);\n    float f = 1.0 / (1.0 - k);\n    float g = 1.0 / (1.0 + k);\n    float h = 1.0 / (1.0 - k);\n    float i = 1.0 / (1.0 + k);\n    float j = 1.0 / (1.0 - k);\n    float k = 1.0 / (1.0 + k);\n    float l = 1.0 / (1.0 - k);\n    float m = 1.0 / (1.0 + k);\n    float n = 1.0 / (1.0 - k);\n    float o = 1.0 / (1.0 + k);\n    float p = 1.0 / (1.0 - k);\n    float q = 1.0 / (1.0 + k);\n    float r = 1.0 / (1.0 - k);\n    float s = 1.0 / (1.0 + k);\n    float t = 1.0 / (1.0 - k);\n    float u = 1.0 / (1.0 + k);\n    float v = 1.0 / (1.0 - k);\n    float w = 1.0 / (1.0 + k);\n    float x = 1.0 / (1.0 - k);\n    float y = 1.0 / (1.0 + k);\n    float z = 1.0 / (1.0 - k);\n    float aa = 1.0 / (1.0 + k);\n    float bb = 1.0 / (1.0 - k);\n    float cc = 1.0 / (1.0 + k);\n    float dd = 1.0 / (1.0 - k);\n    float ee", "\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOOY( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOOZ( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n    return length(p);\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )", "\n  float c = clamp(k, 0.0, 1.0);\n  return mix(a, b, c);\n}\n\n// float pmax(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(b, a, c);\n// }\n\n// float pmed(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c);\n// }\n\n// float pmed2(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c * c);\n// }\n\n// float pmed3(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c * c * c);\n// }\n\n// float pmed4(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c * c * c * c);\n// }\n\n// float pmed5(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c * c * c * c * c);\n// }\n\n// float pmed6(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c * c * c * c * c * c);\n// }\n\n// float pmed7(float a, float b, float k) {\n//   float c = clamp(k, 0.0, 1.0);\n//   return mix(a, b, c * c * c * c * c * c * c * c);\n// }\n\n", "\n  return a < 0.0? -a : a;\n}\n\nfloat pabs(vec2 a, vec2 k) {\n  return a.x < 0.0? -a.x : a.x, a.y < 0.0? -a.y : a.y;\n}\n\nfloat pabs(vec3 a, vec3 k) {\n  return a.x < 0.0? -a.x : a.x, a.y < 0.0? -a.y : a.y, a.z < 0.0? -a.z : a.z;\n}\n\nfloat pabs(vec4 a, vec4 k) {\n  return a.x < 0.0? -a.x : a.x, a.y < 0.0? -a.y : a.y, a.z < 0.0? -a.z : a.z, a.w < 0.0? -a.w : a.w;\n}\n\nfloat pabs(vec4 a, vec2 k) {\n  return a.x < 0.0? -a.x : a.x, a.y < 0.0? -a.y : a.y, a.z < 0.0? -a.z : a.z, a.w < 0.0? -a.w : a.w;\n}\n\nfloat pabs(vec4 a, vec3 k) {\n  return a.x < 0.0? -a.x : a.x, a.y < 0.0? -a.y : a.y, a.z < 0.0? -a.z : a.z, a.w < 0.0? -a.w : a.w;\n}\n\nfloat pabs(vec4 a, vec4 k) {\n  return a.x < 0.0? -a.x : a.x, a.y < 0.0? -a.y : a.y, a.z < 0.0? -a.z :", "\n  float a = 0.5;\n  float b = 0.5;\n  float c = 0.5;\n  float d = 0.5;\n  float e = 0.5;\n  float f = 0.5;\n  float g = 0.5;\n  float h = 0.5;\n  float i = 0.5;\n  float j = 0.5;\n  float k = 0.5;\n  float l = 0.5;\n  float m = 0.5;\n  float n = 0.5;\n  float o = 0.5;\n  float p = 0.5;\n  float q = 0.5;\n  float r = 0.5;\n  float s = 0.5;\n  float t = 0.5;\n  float u = 0.5;\n  float v = 0.5;\n  float w = 0.5;\n  float x = 0.5;\n  float y = 0.5;\n  float z = 0.5;\n  float aa = 0.5;\n  float bb = 0.5;\n  float cc = 0.5;\n  float dd = 0.5;\n  float ee = 0.5;\n  float ff = 0.5;\n  float gg = 0.5;\n  float hh = 0.5;\n  float ii = 0.5;\n  float jj = 0.5;\n  float kk = 0.5;\n  float ll = 0.5;\n  float mm = 0.5;\n  float nn = 0.5;\n  float oo = 0.5;\n  float pp = 0.5;\n  float qq = 0.5;\n  float rr = 0.5;\n  float ss = 0.5;\n  float tt = 0.5;\n  float uu = 0.5;\n  float vv = 0.5;\n  float ww = 0.5;\n  float xx = 0.", "\n  p = fract(p * vec2(123.456789, 987.654321));\n  p += dot(p, p + 3.14159265);\n  return fract(p.x * p.y * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec2 p) {\n  p = fract(p * vec2(123.456789, 987.654321));\n  p += dot(p, p + 3.14159265);\n  return fract(sin(p.x * p.y) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec2 p) {\n  p = fract(p * vec2(123.456789, 987.654321));\n  p += dot(p, p + 3.14159265);\n  return fract(sin(p.x * p.y) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec2 p) {\n  p = fract(p * vec2(123.456789, 987.654321));\n  p += dot(p, p + 3.14159265);\n  return fract(sin(p.x * p.y) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec2 p) {\n  p = fract(p * vec2(123.456789, 987.6543", "\n    vec2 p = pos;\n    vec2 a = A;\n    vec2 b = B;\n    vec2 c = C;\n    vec2 ab = b-a;\n    vec2 ac = c-a;\n    vec2 bc = c-b;\n    vec2 abc = ac*bc.y-ab*bc.x;\n    vec2 abc2 = abc*abc.y-abc.x*abc.x;\n    vec2 abc3 = abc2*abc.y-abc2.x*abc2.x;\n    vec2 abc4 = abc3*abc.y-abc3.x*abc3.x;\n    vec2 abc5 = abc4*abc.y-abc4.x*abc4.x;\n    vec2 abc6 = abc5*abc.y-abc5.x*abc5.x;\n    vec2 abc7 = abc6*abc.y-abc6.x*abc6.x;\n    vec2 abc8 = abc7*abc.y-abc7.x*abc7.x;\n    vec2 abc9 = abc8*abc.y-abc8.x*abc8.x;\n    vec2 abc10 = abc9*abc.y-abc9.x*abc9.x;\n    vec2 abc11 = abc10*abc.y-abc10.x*abc10.x;\n    vec2 abc12 = abc11*abc.y-abc11.x*abc11.x;\n    vec2 abc13 = abc12*abc.y-abc12.x*abc12.x;\n    vec2 abc14 = abc13*abc.y-abc13.x*abc13.x;\n    vec2 abc15 = abc14*abc.y-abc14.x*abc14.x;\n    vec2 abc16 = abc15*abc.y-abc15.x*abc15.x;\n    vec2 abc17 = abc16*abc.y-abc", "\n    vec2 p = pos;\n    vec2 w = vec2(wi,he);\n    vec2 q = p/w;\n    vec2 r = q*q;\n    vec2 s = 2.0*q;\n    vec2 t = 3.0*r;\n    vec2 u = 4.0*s;\n    vec2 v = 5.0*t;\n    vec2 w = 6.0*u;\n    vec2 x = 7.0*v;\n    vec2 y = 8.0*w;\n    vec2 z = 9.0*x;\n    vec2 a = 10.0*y;\n    vec2 b = 11.0*z;\n    vec2 c = 12.0*a;\n    vec2 d = 13.0*b;\n    vec2 e = 14.0*c;\n    vec2 f = 15.0*d;\n    vec2 g = 16.0*e;\n    vec2 h = 17.0*f;\n    vec2 i = 18.0*g;\n    vec2 j = 19.0*h;\n    vec2 k = 20.0*i;\n    vec2 l = 21.0*j;\n    vec2 m = 22.0*k;\n    vec2 n = 23.0*l;\n    vec2 o = 24.0*m;\n    vec2 p = 25.0*n;\n    vec2 q = 26.0*o;\n    vec2 r = 27.0*p;\n    vec2 s = 28.0*q;\n    vec2 t = 29.0*r;\n    vec2 u = 30.0*s;\n    vec2 v = 31.0*t;\n    vec2 w = 32.0*u;\n    vec2 x = 33.0*v;\n    vec2 y = 34.0*w;\n    vec2 z = 35.0*x;\n    vec", "\n    vec2 p = abs(pos.xy);\n    vec2 q = p - vec2(k,k);\n    vec2 r = q*q;\n    vec2 s = r*r;\n    vec2 t = s*s;\n    vec2 u = t*t;\n    vec2 v = u*u;\n    vec2 w = v*v;\n    vec2 x = w*w;\n    vec2 y = x*x;\n    vec2 z = y*y;\n    vec2 a = z*z;\n    vec2 b = a*a;\n    vec2 c = b*b;\n    vec2 d = c*c;\n    vec2 e = d*d;\n    vec2 f = e*e;\n    vec2 g = f*f;\n    vec2 h = g*g;\n    vec2 i = h*h;\n    vec2 j = i*i;\n    vec2 k = j*j;\n    vec2 l = k*k;\n    vec2 m = l*l;\n    vec2 n = m*m;\n    vec2 o = n*n;\n    vec2 p = o*o;\n    vec2 q = p*p;\n    vec2 r = q*q;\n    vec2 s = r*r;\n    vec2 t = s*s;\n    vec2 u = t*t;\n    vec2 v = u*u;\n    vec2 w = v*v;\n    vec2 x = w*w;\n    vec2 y = x*x;\n    vec2 z = y*y;\n    vec2 a = z*z;\n    vec2 b = a*a;\n    vec2 c = b*b;\n    vec2 d = c*c;\n    vec2 e = d*d;\n    vec2 f = e*e;\n    vec2 g = f*f;\n    vec2 h = g*g;\n    vec2 i = h*h;\n    vec2 j = i*i;\n    vec2 k = j*j;\n    vec2 l = k*k;\n    vec2 m = l*l;\n    vec2 n", "\n    float r = length(p);\n    float f = r - d;\n    float g = r - ra;\n    float h = r - rb;\n    float h2 = h*h;\n    float h3 = h2*h;\n    float h4 = h3*h;\n    float h5 = h4*h;\n    float h6 = h5*h;\n    float h7 = h6*h;\n    float h8 = h7*h;\n    float h9 = h8*h;\n    float h10 = h9*h;\n    float h11 = h10*h;\n    float h12 = h11*h;\n    float h13 = h12*h;\n    float h14 = h13*h;\n    float h15 = h14*h;\n    float h16 = h15*h;\n    float h17 = h16*h;\n    float h18 = h17*h;\n    float h19 = h18*h;\n    float h20 = h19*h;\n    float h21 = h20*h;\n    float h22 = h21*h;\n    float h23 = h22*h;\n    float h24 = h23*h;\n    float h25 = h24*h;\n    float h26 = h25*h;\n    float h27 = h26*h;\n    float h28 = h27*h;\n    float h29 = h28*h;\n    float h30 = h29*h;\n    float h31 = h30*h;\n    float h32 = h31*h;\n    float h33 = h32*h;\n    float h34 = h33*h;\n    float h35 = h34*h;\n    float h36 = h35*h;\n    float h37 = h36*h;\n    float h38 = h37*h;\n    float h39 = h38*h", "\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    return v;\n}\n\nivec2 Pcg3(ivec2 v)\n{\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    return v;\n}\n\nivec2 Pcg4(ivec2 v)\n{\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    return v;\n}\n\nivec2 Pcg5(ivec2 v)\n{\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    return v;\n}\n\nivec2 Pcg6(ivec2 v)\n{\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    v = v * 277 + 269;\n    return v;\n}\n\nivec2 Pcg7(ivec2 v", "\n    v = v * 1103515245 + 12345;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 w)\n{\n    v = v * 1103515245 + 12345;\n    w = w * 1103515245 + 12345;\n    return v + w;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 w, ivec3 x)\n{\n    v = v * 1103515245 + 12345;\n    w = w * 1103515245 + 12345;\n    x = x * 1103515245 + 12345;\n    return v + w + x;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 w, ivec3 x, ivec3 y)\n{\n    v = v * 1103515245 + 12345;\n    w = w * 1103515245 + 12345;\n    x = x * 1103515245 + 12345;\n    y = y * 1103515245 + 12345;\n    return v + w + x + y;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 w, ivec3 x, ivec3 y, ivec3 z)\n{\n    v = v * 1103515245 + 12345;\n    w = w * 1103515245 + 12345;\n    x = x * 1103515245 + 12345;\n    y = y * 1103515245 + 12345;\n    z = z * 1", "\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    vec2 AP = pos - A;\n    float a = dot(AB, AB);\n    float b = dot(AB, AC);\n    float c = dot(AC, AC);\n    float d = dot(AB, AP);\n    float e = dot(AC, AP);\n    float f = a*c - b*b;\n    float g = 2.0*(a*e - b*d);\n    float h = a*d*d - b*c*e + a*e*e;\n    float i = sqrt(g*g - 4.0*f*h);\n    float t1 = (-g - i)/(2.0*f);\n    float t2 = (-g + i)/(2.0*f);\n    float t = max(t1, t2);\n    return max(0.0, t);\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    vec2 AD = D - A;\n    vec2 AP = pos - A;\n    float a = dot(AB, AB);\n    float b = dot(AB, AC);\n    float c = dot(AC, AC);\n    float d = dot(AB, AD);\n    float e = dot(AC, AD);\n    float f = dot(AB, AP);\n    float g = dot(AC, AP);\n    float h = dot(AD, AP);\n    float i = a*c - b*b;\n    float j = 2.0*(a*e - b*d);\n    float k = a*d*d - b*c*e + a*e*e;\n    float l = 3.0*(a*f - b*g);\n    float m = 3.0*(a*g - b*h);\n    float n = 3.0*(a*h - b*i);\n    float o = 3.0*(a*i -", "\n    return (a.y - b.y) * (p.x - b.x) - (a.x - b.x) * (p.y - b.y);\n}\n\n// Source: https://www.shadertoy.com/view/Md33zr\nfloat winding_angle(in vec2 p, in vec2 a, in vec2 b) {\n    return acos(dot(normalize(a - b), normalize(p - b)));\n}\n\n// Source: https://www.shadertoy.com/view/Md33zr\nfloat winding_angle_signed(in vec2 p, in vec2 a, in vec2 b) {\n    return sign(winding_sign(p, a, b)) * winding_angle(p, a, b);\n}\n\n// Source: https://www.shadertoy.com/view/Md33zr\nfloat winding_angle_signed_signed(in vec2 p, in vec2 a, in vec2 b) {\n    return sign(winding_sign(p, a, b)) * sign(winding_sign(p, b, a)) * winding_angle(p, a, b);\n}\n\n// Source: https://www.shadertoy.com/view/Md33zr\nfloat winding_angle_signed_signed_signed(in vec2 p, in vec2 a, in vec2 b) {\n    return sign(winding_sign(p, a, b)) * sign(winding_sign(p, b, a)) * sign(winding_sign(p, a, b)) * winding_angle(p, a, b);\n}\n\n// Source: https://www.shadertoy.com/view/Md33zr\nfloat winding_angle_signed_signed_signed_signed(in vec2 p, in vec2 a, in vec2 b) {\n    return sign(winding_sign(p, a, b)) * sign(winding_sign(p, b, a)) * sign(winding_sign(p, a, b)) * sign(winding_sign(p, b, a)) * winding_angle(p", "\n  vec3  p = ro + rd * s.x;\n  vec3  q = ro + rd * s.y;\n  vec3  r = ro + rd * s.z;\n\n  vec3  v = q - p;\n  vec3  w = r - p;\n\n  float a = dot( v, v );\n  float b = dot( v, w );\n  float c = dot( w, w );\n  float d = b * b - a * c;\n\n  if( d < 0.0 )\n    return vec4( 0.0 );\n\n  float s1 = -b - sqrt( d );\n  float s2 = -b + sqrt( d );\n\n  float t1 = s1 / a;\n  float t2 = s2 / a;\n\n  if( t1 > t2 )\n    return vec4( 0.0 );\n\n  vec3  n = normalize( cross( v, w ) );\n\n  return vec4( t1, t2, n, 1.0 );\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec3 s, in vec3 t )\n{\n  vec3  p = ro + rd * s.x;\n  vec3  q = ro + rd * s.y;\n  vec3  r = ro + rd * s.z;\n\n  vec3  v = q - p;\n  vec3  w = r - p;\n\n  float a = dot( v, v );\n  float b = dot( v, w );\n  float c = dot( w, w );\n  float d = b * b - a * c;\n\n  if( d < 0.0 )\n    return vec4( 0.0 );\n\n  float s1 = -b - sqrt( d );\n  float s2 = -b + sqrt( d );\n\n  float t1 = s", "\n  float ret = a*b+x;\n  ret_n = floor(ret);\n  return fract(ret);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f64 (out int ret_n, int a, float b, double x) {\n  double ret = a*b+x;\n  ret_n = floor(ret);\n  return fract(ret);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f128 (out int ret_n, int a, float b, __float128 x) {\n  __float128 ret = a*b+x;\n  ret_n = floor(__float128_as_int(ret));\n  return fract(__float128_as_int(ret));\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f256 (out int ret_n, int a, float b, __float256 x) {\n  __float256 ret = a*b+x;\n  ret_n = floor(__float256_as_int(ret));\n  return fract(__float256_as_int(ret));\n}\n\n// https://www.shadertoy.com/", "\n    vec3 c = a + b;\n    vec3 d = a - b;\n    vec3 e = c * c;\n    vec3 f = d * d;\n    vec3 g = e + f;\n    vec3 h = 2.0 * ( c * d );\n    vec3 i = g * k;\n    vec3 j = h * k;\n    vec3 k = i + j;\n    vec3 l = g - f;\n    vec3 m = l * k;\n    vec3 n = 2.0 * ( h * m );\n    vec3 o = l * n;\n    vec3 p = g - e;\n    vec3 q = p * k;\n    vec3 r = p * n;\n    vec3 s = g - f;\n    vec3 t = s * k;\n    vec3 u = s * n;\n    vec3 v = s * r;\n    vec3 w = g - e;\n    vec3 x = w * k;\n    vec3 y = w * n;\n    vec3 z = w * r;\n    vec3 aa = m + o;\n    vec3 ab = m - o;\n    vec3 ac = n + r;\n    vec3 ad = n - r;\n    vec3 ae = aa + ab;\n    vec3 af = aa - ab;\n    vec3 ag = ac + ad;\n    vec3 ah = ac - ad;\n    vec3 ai = ae + ag;\n    vec3 aj = ae - ag;\n    vec3 ak = af + ah;\n    vec3 al = af - ah;\n    vec3 am = ai + aj;\n    vec3 an = ai - aj;\n    vec3 ao = ak + al;\n    vec3 ap = ak - al;\n    vec3 aq = am + ao;\n    vec3 ar = am - ao;\n    vec3 as = aq + ar;\n    vec3 at = aq - ar;\n    vec3 au = as + at;\n    vec3 av = as - at;\n    vec3 aw = au + av;\n    vec3 ax = au - av", "\n\tvec2 a = ab/length(ab);\n\tvec2 b = ab*a;\n\tvec2 c = ab*a*a;\n\tvec2 d = ab*a*a*a;\n\tvec2 e = ab*a*a*a*a;\n\tvec2 f = ab*a*a*a*a*a;\n\tvec2 g = ab*a*a*a*a*a*a;\n\tvec2 h = ab*a*a*a*a*a*a*a;\n\tvec2 i = ab*a*a*a*a*a*a*a*a;\n\tvec2 j = ab*a*a*a*a*a*a*a*a*a;\n\tvec2 k = ab*a*a*a*a*a*a*a*a*a*a;\n\tvec2 l = ab*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 m = ab*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 n = ab*a*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 o = ab*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 p = ab*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 q = ab*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 r = ab*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 s = ab*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a;\n\tvec2 t = ab*a*a*a*", "\n\treturn a + b;\n}\n\n//precision loss testing\nfloat sub_ploss(in float a, in float b){\n\treturn a - b;\n}\n\n//precision loss testing\nfloat mul_ploss(in float a, in float b){\n\treturn a * b;\n}\n\n//precision loss testing\nfloat div_ploss(in float a, in float b){\n\treturn a / b;\n}\n\n//precision loss testing\nfloat mod_ploss(in float a, in float b){\n\treturn a % b;\n}\n\n//precision loss testing\nfloat pow_ploss(in float a, in float b){\n\treturn pow(a, b);\n}\n\n//precision loss testing\nfloat sqrt_ploss(in float a){\n\treturn sqrt(a);\n}\n\n//precision loss testing\nfloat sin_ploss(in float a){\n\treturn sin(a);\n}\n\n//precision loss testing\nfloat cos_ploss(in float a){\n\treturn cos(a);\n}\n\n//precision loss testing\nfloat tan_ploss(in float a){\n\treturn tan(a);\n}\n\n//precision loss testing\nfloat asin_ploss(in float a){\n\treturn asin(a);\n}\n\n//precision loss testing\nfloat acos_ploss(in float a){\n\treturn acos(a);\n}\n\n//precision loss testing\nfloat atan_ploss(in float a){\n\treturn atan(a);\n}\n\n//precision loss testing\nfloat atan2_ploss(in float a, in float b){\n\treturn atan2(a, b);\n}\n\n//precision loss testing\nfloat exp_ploss(in float a){\n\treturn exp(a);\n}\n\n//precision loss testing\nfloat log_ploss(in float a){\n\treturn log(a);\n}\n\n//precision loss testing\nfloat log10_ploss(in float a){\n\treturn log10(a);\n}\n\n//precision loss testing\nfloat log2_ploss(in float a){\n\treturn log2(a);\n}\n\n//precision loss testing\nfloat ceil_ploss(in float a", "\n\tvec2 p1 = p + ab * s1;\n\tvec2 p2 = p + ab * s2;\n\tvec2 p3 = p + ab * (s1 + s2);\n\tvec2 p4 = p + ab * (s1 - s2);\n\tvec2 p5 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p6 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p7 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p8 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p9 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p10 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p11 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p12 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p13 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p14 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p15 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p16 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p17 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p18 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p19 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p20 = p + ab * (s1 - s2) * 0.5;\n\tvec2 p21 = p + ab * (s1 + s2) * 0.5;\n\tvec2 p22 = p + ab * (s1 - s2) * 0.5;\n\tvec", "\n    vec3 d = b - a;\n    float h = length(d);\n    float r = ra + rb;\n    float r2 = r * r;\n    float r2h = r2 - h * h;\n    float r2h2 = r2h * r2h;\n    float r2h3 = r2h2 * r2h;\n    float r2h4 = r2h3 * r2h2;\n    float r2h5 = r2h4 * r2h2;\n    float r2h6 = r2h5 * r2h2;\n    float r2h7 = r2h6 * r2h2;\n    float r2h8 = r2h7 * r2h2;\n    float r2h9 = r2h8 * r2h2;\n    float r2h10 = r2h9 * r2h2;\n    float r2h11 = r2h10 * r2h2;\n    float r2h12 = r2h11 * r2h2;\n    float r2h13 = r2h12 * r2h2;\n    float r2h14 = r2h13 * r2h2;\n    float r2h15 = r2h14 * r2h2;\n    float r2h16 = r2h15 * r2h2;\n    float r2h17 = r2h16 * r2h2;\n    float r2h18 = r2h17 * r2h2;\n    float r2h19 = r2h18 * r2h2;\n    float r2h20 = r2h19 * r2h2;\n    float r2h21 = r2h20 * r2h2;\n    float r2h22 = r2h21 * r2h2;\n    float r2h23 = r2h22 * r2h2;\n    float r2h24 = r2h23 * r2h2;\n    float r2h25 = r2h24 * r2h2", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 da = d - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    float k = clamp( dot( pa, ca ) / dot( ca, ca ), 0.0, 1.0 );\n    float l = clamp( dot( pa, da ) / dot( da, da ), 0.0, 1.0 );\n    return min( min( length( pa - ba * h ), length( pa - ca * k ) ), length( pa - da * l ) ) - 0.5;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 da = d - a;\n    vec3 ea = e - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    float k = clamp( dot( pa, ca ) / dot( ca, ca ), 0.0, 1.0 );\n    float l = clamp( dot( pa, da ) / dot( da, da ), 0.0, 1.0 );\n    float m = clamp( dot( pa, ea ) / dot( ea, ea ), 0.", "\n    return length( p - cen ) - rad;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 ab = b - a;\n    float h = clamp( dot( pa, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    vec3 c = a + h * ab;\n    return length( p - c ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 ab = b - a;\n    float h = clamp( dot( pa, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    vec3 c = a + h * ab;\n    return length( p - c ) - r;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 ab = b - a;\n    float h = clamp( dot( pa, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    vec3 c = a + h * ab;\n    return length( p - c ) - r;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, vec3 c, float r )\n{\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 ab = b - a;\n    float h = clamp( dot( pa, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    vec3 c = a + h * ab;\n    return length( p - c ) - r;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, float r )\n{\n    vec3 pa =", "\n    vec3 n = vec3(0.0);\n    if( showSurface )\n    {\n        n = normalize( vec3(\n            dFdx( pos.x ),\n            dFdx( pos.y ),\n            dFdx( pos.z )\n        ) );\n    }\n    else\n    {\n        n = normalize( vec3(\n            dFdx( pos.x ) + dFdx( pos.y ) + dFdx( pos.z ),\n            dFdx( pos.x ) + dFdx( pos.y ) - dFdx( pos.z ),\n            dFdx( pos.x ) - dFdx( pos.y ) + dFdx( pos.z )\n        ) );\n    }\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec3 n = vec3(0.0);\n    if( showSurface )\n    {\n        n = normalize( vec3(\n            dFdx( pos.x ),\n            dFdx( pos.y ),\n            dFdx( pos.z )\n        ) );\n    }\n    else\n    {\n        n = normalize( vec3(\n            dFdx( pos.x ) + dFdx( pos.y ) + dFdx( pos.z ),\n            dFdx( pos.x ) + dFdx( pos.y ) - dFdx( pos.z ),\n            dFdx( pos.x ) - dFdx( pos.y ) + dFdx( pos.z )\n        ) );\n    }\n    return n;\n}\n\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec3 n = vec3(0.0);\n    if( showSurface )\n    {\n        n = normalize( vec3(\n            dFdx( pos.x ),\n            dFdx( pos.y ),\n            dFdx( pos.z )\n        ) );\n    }\n    else\n    {\n        n = normalize( vec3(\n            dFdx(", "\n    float shadow = 0.0;\n    float maxShadow = 0.0;\n    float maxShadow2 = 0.0;\n    float maxShadow3 = 0.0;\n    float maxShadow4 = 0.0;\n    float maxShadow5 = 0.0;\n    float maxShadow6 = 0.0;\n    float maxShadow7 = 0.0;\n    float maxShadow8 = 0.0;\n    float maxShadow9 = 0.0;\n    float maxShadow10 = 0.0;\n    float maxShadow11 = 0.0;\n    float maxShadow12 = 0.0;\n    float maxShadow13 = 0.0;\n    float maxShadow14 = 0.0;\n    float maxShadow15 = 0.0;\n    float maxShadow16 = 0.0;\n    float maxShadow17 = 0.0;\n    float maxShadow18 = 0.0;\n    float maxShadow19 = 0.0;\n    float maxShadow20 = 0.0;\n    float maxShadow21 = 0.0;\n    float maxShadow22 = 0.0;\n    float maxShadow23 = 0.0;\n    float maxShadow24 = 0.0;\n    float maxShadow25 = 0.0;\n    float maxShadow26 = 0.0;\n    float maxShadow27 = 0.0;\n    float maxShadow28 = 0.0;\n    float maxShadow29 = 0.0;\n    float maxShadow30 = 0.0;\n    float maxShadow31 = 0.0;\n    float maxShadow32 = 0.0;\n    float maxShadow33 = 0.0;\n    float maxShadow34 = 0.0;\n    float maxShadow35 = 0.0;\n    float maxShadow36 = 0.0;\n    float maxShadow37 = 0.0;\n    float maxShadow38 = 0.0;\n    float maxShadow39 = 0.0;\n    float maxShadow", "\n    vec2 d = p - vec2(ra, rb);\n    float h = he;\n    float r = ra + rb;\n    float r2 = r * r;\n    float r2h = r2 - h * h;\n    float r2h2 = r2h * r2h;\n    float r2h3 = r2h2 * r2h;\n    float r2h4 = r2h3 * r2h;\n    float r2h5 = r2h4 * r2h;\n    float r2h6 = r2h5 * r2h;\n    float r2h7 = r2h6 * r2h;\n    float r2h8 = r2h7 * r2h;\n    float r2h9 = r2h8 * r2h;\n    float r2h10 = r2h9 * r2h;\n    float r2h11 = r2h10 * r2h;\n    float r2h12 = r2h11 * r2h;\n    float r2h13 = r2h12 * r2h;\n    float r2h14 = r2h13 * r2h;\n    float r2h15 = r2h14 * r2h;\n    float r2h16 = r2h15 * r2h;\n    float r2h17 = r2h16 * r2h;\n    float r2h18 = r2h17 * r2h;\n    float r2h19 = r2h18 * r2h;\n    float r2h20 = r2h19 * r2h;\n    float r2h21 = r2h20 * r2h;\n    float r2h22 = r2h21 * r2h;\n    float r2h23 = r2h22 * r2h;\n    float r2h24 = r2h23 * r2h;\n    float r2h25 = r2h24 * r2h;\n    float r2h26 = r2h25 * r2", "\n\tvec3 q = normalize( p );\n\tfloat d = length( p );\n\tfloat r = ra + rb * d;\n\tfloat s = sqrt( 1.0 - d*d );\n\tfloat t = atan2( s, d );\n\tfloat u = atan2( q.y, q.x );\n\treturn vec4( r * cos( t ) * cos( u ), r * sin( t ) * cos( u ), r * sin( u ), s );\n}\n\nvec4 sdgSphere( vec3 p, float r )\n{\n\tvec3 q = normalize( p );\n\tfloat d = length( p );\n\tfloat s = sqrt( 1.0 - d*d );\n\treturn vec4( s, s, s, d );\n}\n\nvec4 sdgPlane( vec3 p, vec3 n )\n{\n\tvec3 q = normalize( p );\n\tfloat d = dot( n, q );\n\treturn vec4( d, d, d, 0.0 );\n}\n\nvec4 sdgBox( vec3 p, vec3 b )\n{\n\tvec3 q = normalize( p );\n\tfloat d = dot( q, b );\n\treturn vec4( d, d, d, 0.0 );\n}\n\nvec4 sdgCapsule( vec3 p, vec3 b, float r )\n{\n\tvec3 q = normalize( p );\n\tfloat d = dot( q, b );\n\tfloat s = sqrt( 1.0 - d*d );\n\treturn vec4( s, s, s, d );\n}\n\nvec4 sdgCylinder( vec3 p, vec3 b, float r )\n{\n\tvec3 q = normalize( p );\n\tfloat d = dot( q, b );\n\tfloat s = sqrt( 1.0 - d*d );\n\treturn vec4( s, s, s, d );\n}\n\nvec4 sdgCone( vec3 p, vec3 b, float r )\n{\n\tvec3 q = normalize( p );\n\tfloat d = dot( q, b );\n\tfloat s = sqrt( 1.0 - d*", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float d = dot( pa, ba );\n    float l = length( ba );\n    return clamp( d, 0.0, l*l );\n}\n\nfloat udCircle( in vec2 p, in vec2 c, float r )\n{\n    vec2 pc = p - c;\n    return length( pc ) - r;\n}\n\nfloat udEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 pc = p - c;\n    float a = dot( pc, pc ) / dot( r, r );\n    return sqrt( a );\n}\n\nfloat udPolygon( in vec2 p, in vec2* v, int n )\n{\n    float d = 0.0;\n    for( int i = 0; i < n; i++ )\n    {\n        d += udSegment( p, v[i], v[i+1] );\n    }\n    return d;\n}\n\nfloat udPolygon( in vec2 p, in vec2* v, int n, in vec2 c )\n{\n    float d = 0.0;\n    for( int i = 0; i < n; i++ )\n    {\n        d += udSegment( p, v[i], v[i+1] );\n    }\n    return d;\n}\n\nfloat udPolygon( in vec2 p, in vec2* v, int n, in vec2 c, in vec2 r )\n{\n    float d = 0.0;\n    for( int i = 0; i < n; i++ )\n    {\n        d += udSegment( p, v[i], v[i+1] );\n    }\n    return d;\n}\n\nfloat udPolygon( in vec2 p, in vec2* v, int n, in vec2 c, in vec2 r, in vec2 s )\n{\n    float d = 0.0;\n    for( int i = 0; i < n; i++ )\n    {\n        d += ", "\n    return dot(v, v);\n}\n\nfloat dot3(in vec3 v) {\n    return dot(v, v);\n}\n\nfloat dot4(in vec4 v) {\n    return dot(v, v);\n}\n\nfloat dot5(in vec5 v) {\n    return dot(v, v);\n}\n\nfloat dot6(in vec6 v) {\n    return dot(v, v);\n}\n\nfloat dot7(in vec7 v) {\n    return dot(v, v);\n}\n\nfloat dot8(in vec8 v) {\n    return dot(v, v);\n}\n\nfloat dot9(in vec9 v) {\n    return dot(v, v);\n}\n\nfloat dot10(in vec10 v) {\n    return dot(v, v);\n}\n\nfloat dot11(in vec11 v) {\n    return dot(v, v);\n}\n\nfloat dot12(in vec12 v) {\n    return dot(v, v);\n}\n\nfloat dot13(in vec13 v) {\n    return dot(v, v);\n}\n\nfloat dot14(in vec14 v) {\n    return dot(v, v);\n}\n\nfloat dot15(in vec15 v) {\n    return dot(v, v);\n}\n\nfloat dot16(in vec16 v) {\n    return dot(v, v);\n}\n\nfloat dot17(in vec17 v) {\n    return dot(v, v);\n}\n\nfloat dot18(in vec18 v) {\n    return dot(v, v);\n}\n\nfloat dot19(in vec19 v) {\n    return dot(v, v);\n}\n\nfloat dot20(in vec20 v) {\n    return dot(v, v);\n}\n\nfloat dot21(in vec21 v) {\n    return dot(v, v);\n}\n\nfloat dot22(in vec22 v) {\n    return dot(v, v);\n}\n\nfloat dot23(in vec23 v) {\n", "\n    vec2 d = p - minCorner;\n    vec2 e = maxCorner - minCorner;\n    return dot(d,d) + dot(e,e);\n}\n\n// Returns true if the point is inside the box\nbool isInside( in vec2 p, in vec2 minCorner, in vec2 maxCorner )\n{\n    vec2 d = p - minCorner;\n    vec2 e = maxCorner - minCorner;\n    return dot(d,d) < dot(e,e);\n}\n\n// Returns true if the point is inside the box\nbool isInside( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size )\n{\n    vec2 d = p - minCorner;\n    vec2 e = maxCorner - minCorner;\n    return dot(d,d) < dot(e,e) && dot(d,d) < dot(size,size);\n}\n\n// Returns true if the point is inside the box\nbool isInside( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size, in vec2 offset )\n{\n    vec2 d = p - minCorner;\n    vec2 e = maxCorner - minCorner;\n    return dot(d,d) < dot(e,e) && dot(d,d) < dot(size,size) && dot(d,d) < dot(offset,offset);\n}\n\n// Returns true if the point is inside the box\nbool isInside( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size, in vec2 offset, in vec2 scale )\n{\n    vec2 d = p - minCorner;\n    vec2 e = maxCorner - minCorner;\n    return dot(d,d) < dot(e,e) && dot(d,d) < dot(size,size) && dot(d,d) < dot(offset,offset) && dot(d,d) < dot(scale,scale);\n}\n\n// Returns true if the point is inside the box\nbool isInside( in vec2 p", "\n    vec3 c = vec3(0.0);\n    vec3 n = vec3(0.0);\n    vec3 d = vec3(0.0);\n    vec3 p = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 wn = vec3(0.0);\n    vec3 wd = vec3(0.0);\n    vec3 wdp = vec3(0.0);\n    vec3 wdpn = vec3(0.0);\n    vec3 wdpdn = vec3(0.0);\n    vec3 wdpdnd = vec3(0.0);\n    vec3 wdpdndn = vec3(0.0);\n    vec3 wdpdnddn = vec3(0.0);\n    vec3 wdpdnddnd = vec3(0.0);\n    vec3 wdpdnddndn = vec3(0.0);\n    vec3 wdpdnddnddn = vec3(0.0);\n    vec3 wdpdnddnddnd = vec3(0.0);\n    vec3 wdpdnddnddndn = vec3(0.0);\n    vec3 wdpdnddnddnddn = vec3(0.0);\n    vec3 wdpdnddnddnddnd = vec3(0.0);\n    vec3 wdpdnddnddnddndn = vec3(0.0);\n    vec3 wdpdnddnddnddnddn = vec3(0.0);\n    vec3 wdpdnddnddnddnddnd = vec3(0.0);\n    vec3 wdpdnddnddnddnddndn = vec3(0.0);\n    vec3 wdpdnddnddnddnddnddn = vec3(0.0);\n    vec3 wdpdnddnddnddnddnddnd = vec3(0.0);\n    vec3 wdpdnddnddnddnddnddndn = vec3(0.0);\n    vec3 wdpdnddnddnd", "\n    vec2 uv0 = uv;\n    uv0.y = 1.0 - uv0.y;\n    vec2 uv1 = uv;\n    uv1.y = 1.0 - uv1.y;\n    vec2 uv2 = uv;\n    uv2.y = 1.0 - uv2.y;\n    vec2 uv3 = uv;\n    uv3.y = 1.0 - uv3.y;\n    vec2 uv4 = uv;\n    uv4.y = 1.0 - uv4.y;\n    vec2 uv5 = uv;\n    uv5.y = 1.0 - uv5.y;\n    vec2 uv6 = uv;\n    uv6.y = 1.0 - uv6.y;\n    vec2 uv7 = uv;\n    uv7.y = 1.0 - uv7.y;\n    vec2 uv8 = uv;\n    uv8.y = 1.0 - uv8.y;\n    vec2 uv9 = uv;\n    uv9.y = 1.0 - uv9.y;\n    vec2 uv10 = uv;\n    uv10.y = 1.0 - uv10.y;\n    vec2 uv11 = uv;\n    uv11.y = 1.0 - uv11.y;\n    vec2 uv12 = uv;\n    uv12.y = 1.0 - uv12.y;\n    vec2 uv13 = uv;\n    uv13.y = 1.0 - uv13.y;\n    vec2 uv14 = uv;\n    uv14.y = 1.0 - uv14.y;\n    vec2 uv15 = uv;\n    uv15.y = 1.0 - uv15.y;\n    vec2 uv16 = uv;\n    uv16.y = 1.0 - uv16.", "\n    return q.xyz * 2.0 * cross(q.w * v, q.xyz) + v;\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(cross(q1.xyz, q2.xyz) + q1.w * q2.w * vec4(q1.xyz, q2.w), q1.w * q2.w);\n}\n\n// Quaternion-quaternion dot product\nfloat quatdot(vec4 q1, vec4 q2)\n{\n    return dot(q1.xyz, q2.xyz) + q1.w * q2.w;\n}\n\n// Quaternion-quaternion length\nfloat quatlen(vec4 q)\n{\n    return length(q.xyz) + q.w * q.w;\n}\n\n// Quaternion-quaternion inverse\nvec4 quatinv(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n// Quaternion-quaternion conjugate\nvec4 quatconj(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n// Quaternion-quaternion normalization\nvec4 quatnorm(vec4 q)\n{\n    return q / quatlen(q);\n}\n\n// Quaternion-quaternion interpolation\nvec4 quatlerp(vec4 q1, vec4 q2, float t)\n{\n    return q1 * (1.0 - t) + q2 * t;\n}\n\n// Quaternion-quaternion interpolation with blending\nvec4 quatblend(vec4 q1, vec4 q2, float t, float blend)\n{\n    return q1 * (1.0 - t) + q2 * t * (1.0 - blend) + q2 * blend * t;\n}\n\n// Quaternion-quaternion interpolation with blending and blending weight\nvec4 quatblend(vec4 q1, vec4 q2, float t, float blend, float weight)\n{\n    return", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    return length(q) - r.x - r.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipse2( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float a = length(q);\n    return a - r.x - r.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipse3( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float a = length(q);\n    float b = r.x - r.y;\n    return a - b;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipse4( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float a = length(q);\n    float b = r.x - r.y;\n    return a - b;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipse5( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float a = length(q);\n    float b = r.x - r.y;\n    return a - b;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipse6( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float a = length(q);\n    float b = r.x - r.y;\n    return a - b;\n}\n\n// https://iquilezles.org/articles/dist", "\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa)-h*length(ba);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0))+min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa)-h*length(ba);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length(pa)-h*length(ba);\n    return min(d,r);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1", "\n\tfloat r = a + d;\n\tfloat r2 = r*r;\n\tfloat r2m = r2 - m.x*m.x;\n\tfloat r2a = r2 - a*a;\n\tfloat r2m2 = r2m*r2m;\n\tfloat r2a2 = r2a*r2a;\n\tfloat r2m2a = r2m2 - r2a2;\n\tfloat r2m2a2 = r2m2a*r2m2a;\n\tfloat r2m2a2m = r2m2a2 - m.y*m.y;\n\tfloat r2m2a2m2 = r2m2a2m*r2m2a2m;\n\tfloat r2m2a2m2a = r2m2a2m2 - a*a;\n\tfloat r2m2a2m2a2 = r2m2a2m2a - m.x*m.x;\n\tfloat r2m2a2m2a2a = r2m2a2m2a2 - a*a;\n\tfloat r2m2a2m2a2a2 = r2m2a2m2a2a - m.y*m.y;\n\tfloat r2m2a2m2a2a2a = r2m2a2m2a2a2 - a*a;\n\tfloat r2m2a2m2a2a2a2 = r2m2a2m2a2a2a - m.x*m.x;\n\tfloat r2m2a2m2a2a2a2a = r2m2a2m2a2a2a2 - m.y*m.y;\n\tfloat r2m2a2m2a2a2a2a2 = r2m2a2m2a2a2a2a - a*a;\n\tfloat r2m2a2m2a2a2a2a2a = r2m2a2m2a2a2a2a2 - m.x*m.x;\n\tfloat r2m2a", "\n    vec2 o = ro - rd*rad;\n    float a = dot( rd, rd );\n    float b = dot( o, rd );\n    float c = dot( o, o ) - rad*rad;\n    float d = b*b - a*c;\n    if( d < 0.0 )\n        return;\n    d = sqrt( d );\n    p1.x = (-b - d) / a;\n    p1.y = (-b + d) / a;\n    p2.x = (-b + d) / a;\n    p2.y = (-b - d) / a;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCapsule( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n    vec2 o = ro - rd*rad;\n    float a = dot( rd, rd );\n    float b = dot( o, rd );\n    float c = dot( o, o ) - rad*rad;\n    float d = b*b - a*c;\n    if( d < 0.0 )\n        return;\n    d = sqrt( d );\n    p1.x = (-b - d) / a;\n    p1.y = (-b + d) / a;\n    p2.x = (-b + d) / a;\n    p2.y = (-b - d) / a;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCylinder( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n    vec2 o = ro - rd*rad;\n    float a = dot( rd, rd );\n    float b = dot( o, rd );\n    float c = dot( o, o ) - rad*rad;\n    float d = b*b - a*c;\n    if( d < 0.0 )\n        return;\n    d = sqrt( d );\n    p1.x = (-b - d)", "\n    vec2 d = p - c;\n    return vec3( d.x, d.y, dot( d, d ) - r*r );\n}\n\nvec3 sdgSphere( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    return vec3( d.x, d.y, dot( d, d ) - r*r );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 c )\n{\n    vec2 d = p - c;\n    vec2 m = abs( d ) - b;\n    return vec3( m.x, m.y, dot( d, d ) );\n}\n\nvec3 sdgCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = p - ( a + b ) * 0.5;\n    vec2 m = abs( d ) - ( abs( a - b ) * 0.5 );\n    return vec3( m.x, m.y, dot( d, d ) - r*r );\n}\n\nvec3 sdgCylinder( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = p - ( a + b ) * 0.5;\n    vec2 m = abs( d ) - ( abs( a - b ) * 0.5 );\n    return vec3( m.x, m.y, dot( d, d ) - r*r );\n}\n\nvec3 sdgCone( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = p - ( a + b ) * 0.5;\n    vec2 m = abs( d ) - ( abs( a - b ) * 0.5 );\n    return vec3( m.x, m.y, dot( d, d ) - r*r );\n}\n\nvec3 sdgCone( in vec2 p, in vec2 a, in vec2 b, in float r, in float h )\n{\n    vec2 d =", "\n    vec2 q = abs(p) - b;\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    vec2 q = p - vec2(r, r);\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgCapsule( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgCylinder( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in float r, in float h )\n{\n    vec2 q = abs(p) - b;\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgCone( in vec2 p, in vec2 b, in float r, in float h, in float a )\n{\n    vec2 q = abs(p) - b;\n    return vec3(q.x > q.y? q.y : q.x, 0.0, 0.0);\n}\n\nvec3 sdgCone( in vec2 p, in", "\n    vec2 q = p.yxyy;\n    vec2 r = p.xyxy;\n    vec2 s = p.xyxy;\n    vec2 t = p.xyxy;\n    vec2 u = p.xyxy;\n    vec2 v = p.xyxy;\n    vec2 w = p.xyxy;\n    vec2 x = p.xyxy;\n    vec2 y = p.xyxy;\n    vec2 z = p.xyxy;\n    vec2 a = p.xyxy;\n    vec2 b = p.xyxy;\n    vec2 c = p.xyxy;\n    vec2 d = p.xyxy;\n    vec2 e = p.xyxy;\n    vec2 f = p.xyxy;\n    vec2 g = p.xyxy;\n    vec2 h = p.xyxy;\n    vec2 i = p.xyxy;\n    vec2 j = p.xyxy;\n    vec2 k = p.xyxy;\n    vec2 l = p.xyxy;\n    vec2 m = p.xyxy;\n    vec2 n = p.xyxy;\n    vec2 o = p.xyxy;\n    vec2 p = p.xyxy;\n    vec2 q = p.xyxy;\n    vec2 r = p.xyxy;\n    vec2 s = p.xyxy;\n    vec2 t = p.xyxy;\n    vec2 u = p.xyxy;\n    vec2 v = p.xyxy;\n    vec2 w = p.xyxy;\n    vec2 x = p.xyxy;\n    vec2 y = p.xyxy;\n    vec2 z = p.xyxy;\n    vec2 a = p.xyxy;\n    vec2 b = p.xyxy;\n    vec2 c = p.xyxy;\n    vec2 d = p.xyxy;\n    vec2 e = p.xyxy;\n    vec2 f = p.xyxy;\n    vec2 g = p.xyxy;\n    vec2 h = p.xyxy;\n    vec2 i = p.xyxy;\n    vec2 j = p.xyxy;\n    vec2 k", "\n    return a1 * x + b1;\n}\n\nfloat f(float a1, float b1, float a2, float b2, float x) {\n    return a1 * x * x + b1 * x + a2 * x + b2;\n}\n\nfloat f_prime(float a1, float b1, float a2, float b2, float x) {\n    return 2 * a1 * x + b1;\n}\n\nfloat f_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 2 * a1;\n}\n\nfloat f_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime_prime_prime_prime_prime(float a1, float b1, float a2, float b2, float x) {\n    return 0;\n}\n\nfloat f_prime_prime_prime_prime_prime_prime_prime", "\n  return a * pow(x, n) + b;\n}\n\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat g(float a, float b, float n, float x) {\n  return a * pow(x, n) - b;\n}\n\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat f(float a, float b, float n, float x) {\n  return a * pow(x, n) - b;\n}\n\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat e(float a, float b, float n, float x) {\n  return a * pow(x, n) + b;\n}\n\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat d(float a, float b, float n, float x) {\n  return a * pow(x, n) - b;\n}\n\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat c(float a, float b, float n, float x) {\n  return a * pow(", "\n                return texture2D(noiseTex, uv).x;\n            }\n\n            float noise(vec2 uv){\n                return texture2D(noiseTex, uv).x;\n            }\n\n            float fbm(vec2 uv, float freq, float amp, float lacunarity, float persistence){\n                float val = 0.0;\n                float amp_ = amp;\n                float freq_ = freq;\n                for(int i = 0; i < 8; i++){\n                    val += noise(uv) * amp_;\n                    uv *= lacunarity;\n                    amp_ *= persistence;\n                    freq_ *= lacunarity;\n                }\n                return val;\n            }\n\n            float fbm2(vec2 uv, float freq, float amp, float lacunarity, float persistence){\n                float val = 0.0;\n                float amp_ = amp;\n                float freq_ = freq;\n                for(int i = 0; i < 8; i++){\n                    val += noise(uv) * amp_;\n                    uv *= lacunarity;\n                    amp_ *= persistence;\n                    freq_ *= lacunarity;\n                }\n                return val;\n            }\n\n            float fbm3(vec2 uv, float freq, float amp, float lacunarity, float persistence){\n                float val = 0.0;\n                float amp_ = amp;\n                float freq_ = freq;\n                for(int i = 0; i < 8; i++){\n                    val += noise(uv) * amp_;\n                    uv *= lacunarity;\n                    amp_ *= persistence;\n                    freq_ *= lacunarity;\n                }\n                return val;\n            }\n\n            float fbm4(vec2 uv, float freq, float amp, float lacunarity, float persistence){\n                float val = 0.0;\n                float amp_ = amp;\n                float freq_ = freq;\n                for(int i = 0; i < 8; i++){\n                    val += noise", "\n    vec3 result;\n    result.x = 6.0 * x + 1.0 * y;\n    result.y = 6.0 * y + 1.0 * x;\n    result.z = 6.0 * x + 1.0 * y;\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 result;\n    result.x = 6.0 * x + 1.0 * y;\n    result.y = 6.0 * y + 1.0 * x;\n    result.z = 6.0 * x + 1.0 * y;\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 result;\n    result.x = 6.0 * x + 1.0 * y;\n    result.y = 6.0 * y + 1.0 * x;\n    result.z = 6.0 * x + 1.0 * y;\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 result;\n    result.x = 6.0 * x + 1.0 * y;\n    result.y = 6.0 * y + 1.0 * x;\n    result.z = 6.0 * x + 1.0 * y;\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 result;\n    result.x = 6.0 * x + 1.0 * y;\n    result.y = 6.0 * y + 1.0 * x;\n    result.z = 6.0 * x + 1.0 * y;\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)", "\n    return length(p-c) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p - c;\n    float a = dot(q,r);\n    float b = dot(r,r);\n    float d = sqrt(b*b-a*a);\n    return d - b;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r, in float a )\n{\n    vec2 q = p - c;\n    float a = dot(q,r);\n    float b = dot(r,r);\n    float d = sqrt(b*b-a*a);\n    return d - b;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r, in float a, in float b )\n{\n    vec2 q = p - c;\n    float a = dot(q,r);\n    float b = dot(r,r);\n    float d = sqrt(b*b-a*a);\n    return d - b;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r, in vec2 a, in vec2 b )\n{\n    vec2 q = p - c;\n    float a = dot(q,r);\n    float b = dot(r,r);\n    float d = sqrt(b*b-a*a);\n    return d - b;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r, in vec2 a, in vec2 b, in float aa, in float bb )\n{\n    vec2 q = p - c;\n    float a = dot(q,r);\n    float b = dot(r,r);\n    float d = sqrt(b*b-a*a);\n    return d - b;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r, in vec2 a, in vec2 b, in float aa, in float bb, in float", "\n    vec2 d = abs(p) - c;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) + min(b.x,b.y);\n}\n\nvec3 box( in vec3 p, in vec3 c, in vec3 b )\n{\n    vec3 d = abs(p) - c;\n    return min(max(d,0.0),b);\n}\n\nvec3 sphere( in vec3 p, in vec3 c, in float r )\n{\n    vec3 d = p - c;\n    return length(d) - r;\n}\n\nvec3 cylinder( in vec3 p, in vec3 c, in vec3 b, in float r )\n{\n    vec3 d = abs(p) - c;\n    vec3 d2 = d*d;\n    vec3 d3 = d2*d;\n    vec3 d4 = d3*d;\n    vec3 d5 = d4*d;\n    vec3 d6 = d5*d;\n    vec3 d7 = d6*d;\n    vec3 d8 = d7*d;\n    vec3 d9 = d8*d;\n    vec3 d10 = d9*d;\n    vec3 d11 = d10*d;\n    vec3 d12 = d11*d;\n    vec3 d13 = d12*d;\n    vec3 d14 = d13*d;\n    vec3 d15 = d14*d;\n    vec3 d16 = d15*d;\n    vec3 d17 = d16*d;\n    vec3 d18 = d17*d;\n    vec3 d19 = d18*d;\n    vec3 d20 = d19*d;\n    vec3 d21 = d20*d;\n    vec3 d22 = d21*d;\n    vec3 d23 = d22*d;\n    vec3 d24 = d23*d;\n    vec3 d25 = d24*d", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    return abs( pa - ba * t );\n}\n\nvec2 sdSqCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 pc = p - c;\n    return length( pc ) - r;\n}\n\nvec2 sdSqBox( in vec2 p, in vec2 b )\n{\n    vec2 pp = abs( p ) - b;\n    return min( pp, max( pp, 0.0 ) );\n}\n\nvec2 sdSqCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    vec2 pc = abs( pa - ba * t );\n    return min( pc, max( pc, 0.0 ) ) + r;\n}\n\nvec2 sdSqCylinder( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    vec2 pc = abs( pa - ba * t );\n    return min( pc, max( pc, 0.0 ) ) + r;\n}\n\nvec2 sdSqSphere( in vec2 p, in vec2 c, in float r )\n{\n    vec2 pc = p - c;\n    return length( pc ) - r;\n}\n\nvec2 sdSqCone( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    vec2 pc = abs( pa - ba * t );\n    return min( pc, max( pc, ", "\n    vec2 d = p - a;\n    float d1 = dot( d, d );\n    float d2 = dot( d, b - a );\n    float h1 = clamp( h, 0.0, d2 );\n    float h2 = clamp( h - d2, 0.0, d2 );\n    float h3 = clamp( h + d2, 0.0, d2 );\n    float h4 = clamp( h - d1, 0.0, d1 );\n    float h5 = clamp( h + d1, 0.0, d1 );\n    float h6 = clamp( h - d2min, 0.0, d2min );\n    float h7 = clamp( h + d2min, 0.0, d2min );\n    float h8 = clamp( h - d1, 0.0, d1 );\n    float h9 = clamp( h + d1, 0.0, d1 );\n    float h10 = clamp( h - d2min, 0.0, d2min );\n    float h11 = clamp( h + d2min, 0.0, d2min );\n    float h12 = clamp( h - d1, 0.0, d1 );\n    float h13 = clamp( h + d1, 0.0, d1 );\n    float h14 = clamp( h - d2min, 0.0, d2min );\n    float h15 = clamp( h + d2min, 0.0, d2min );\n    float h16 = clamp( h - d1, 0.0, d1 );\n    float h17 = clamp( h + d1, 0.0, d1 );\n    float h18 = clamp( h - d2min, 0.0, d2min );\n    float h19 = clamp( h + d2min, 0.0, d2min );\n    float h20 = clamp( h - d1, 0.0, d1 );\n    float h21 = clamp( h + d1, 0.0, d1 );\n    float h22 = clamp( h", "\n    float sd = 0.0;\n    float sd_tmp = 0.0;\n    float sd_tmp2 = 0.0;\n    float sd_tmp3 = 0.0;\n    float sd_tmp4 = 0.0;\n    float sd_tmp5 = 0.0;\n    float sd_tmp6 = 0.0;\n    float sd_tmp7 = 0.0;\n    float sd_tmp8 = 0.0;\n    float sd_tmp9 = 0.0;\n    float sd_tmp10 = 0.0;\n    float sd_tmp11 = 0.0;\n    float sd_tmp12 = 0.0;\n    float sd_tmp13 = 0.0;\n    float sd_tmp14 = 0.0;\n    float sd_tmp15 = 0.0;\n    float sd_tmp16 = 0.0;\n    float sd_tmp17 = 0.0;\n    float sd_tmp18 = 0.0;\n    float sd_tmp19 = 0.0;\n    float sd_tmp20 = 0.0;\n    float sd_tmp21 = 0.0;\n    float sd_tmp22 = 0.0;\n    float sd_tmp23 = 0.0;\n    float sd_tmp24 = 0.0;\n    float sd_tmp25 = 0.0;\n    float sd_tmp26 = 0.0;\n    float sd_tmp27 = 0.0;\n    float sd_tmp28 = 0.0;\n    float sd_tmp29 = 0.0;\n    float sd_tmp30 = 0.0;\n    float sd_tmp31 = 0.0;\n    float sd_tmp32 = 0.0;\n    float sd_tmp33 = 0.0;\n    float sd_tmp34 = 0.0;\n", "\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n", "\n    float s = 0.0;\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    ", "\n    vec3 p = vec3( uv, 0.0 );\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.z = 0.0;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( uv, 0.0 );\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.z = 0.0;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( uv, 0.0 );\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.z = 0.0;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( uv, 0.0 );\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.z = 0.0;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( uv, 0.0 );\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.z = 0.0;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( uv, 0.0 );\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.z = 0.0;\n    return p;\n}\n\n//", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float d = dot( pa, ba );\n    if ( d < 0.0 )\n        return a;\n    if ( d > dot( ba, ba ) )\n        return b;\n    return a + ba * d / dot( ba, ba );\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float d = dot( pa, ba );\n    if ( d < 0.0 )\n        return a;\n    if ( d > dot( ba, ba ) )\n        return b;\n    return a + ba * d / dot( ba, ba );\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 pa = p - c;\n    return c + pa * r / dot( pa, pa );\n}\n\n// Closest point on sphere\nvec2 cloSphere( in vec2 p, in vec2 c, in float r )\n{\n    vec2 pa = p - c;\n    float d = dot( pa, pa );\n    if ( d > r * r )\n        return c;\n    return c + pa * r / sqrt( d );\n}\n\n// Closest point on box\nvec2 cloBox( in vec2 p, in vec2 b, in vec2 c )\n{\n    vec2 pa = p - c;\n    vec2 ba = b - c;\n    vec2 d = abs( pa ) - ba;\n    if ( d.x > d.y )\n        d.y = d.x;\n    if ( d.y > d.x )\n        d.x = d.y;\n    if ( d.x > d.y )\n        d.y = d.x;\n    return c + min( d, vec2( 0.0 ) );\n}\n\n// Closest point on capsule\nvec2 cloCapsule( in vec2 p, in vec2 a, in vec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ba_ = ba * vec2( 1.0 / length( ba ) );\n    vec2 pa_ = pa * vec2( 1.0 / length( pa ) );\n    vec2 ba_ba_ = ba_ * ba_;\n    vec2 ba_pa_ = ba_ * pa_;\n    vec2 ba_pa_ba_ = ba_pa_ * ba_;\n    vec2 ba_pa_ba_ba_ = ba_pa_ba_ * ba_;\n    vec2 ba_pa_ba_ba_ba_ = ba_pa_ba_ba_ * ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ * ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ba_ * ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ba_ba_ * ba_pa_ba_ba_ba_ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ba_ba_ba_ * ba_pa_ba_ba_ba_ba_ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ba_ba_ba_ba_ * ba_pa_ba_ba_ba_ba_ba_ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ba_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ba_ba_ba_ba_ba_ * ba_pa_ba_ba_ba_ba_ba_ba_ba_;\n    vec2 ba_pa_ba_ba_ba_ba_ba_ba_ba_ba_ba_ba_ = ba_pa_ba_ba_ba_ba_ba_ba_ba_ba_ba_", "\n    vec2 d = p - b;\n    float d2 = dot( d, d );\n    float r2 = r * r;\n    if( d2 > r2 )\n    {\n        vec2 q = d * sqrt( r2 / d2 );\n        return b + q;\n    }\n    return p;\n}\n\n// closest point on sphere\nvec2 cloSphere( in vec2 p, in vec2 c, float r )\n{\n    vec2 d = p - c;\n    float d2 = dot( d, d );\n    if( d2 > r * r )\n    {\n        vec2 q = d * ( r / sqrt( d2 ) );\n        return c + q;\n    }\n    return p;\n}\n\n// closest point on cylinder\nvec2 cloCylinder( in vec2 p, in vec2 c, in vec2 b, float r )\n{\n    vec2 d = p - c;\n    float d2 = dot( d, d );\n    float r2 = r * r;\n    if( d2 > r2 )\n    {\n        vec2 q = d * sqrt( r2 / d2 );\n        vec2 q2 = q * ( b - c );\n        return c + q2;\n    }\n    return p;\n}\n\n// closest point on cone\nvec2 cloCone( in vec2 p, in vec2 c, in vec2 b, float r )\n{\n    vec2 d = p - c;\n    float d2 = dot( d, d );\n    float r2 = r * r;\n    if( d2 > r2 )\n    {\n        vec2 q = d * sqrt( r2 / d2 );\n        vec2 q2 = q * ( b - c );\n        return c + q2;\n    }\n    return p;\n}\n\n// closest point on torus\nvec2 cloTorus( in vec2 p, in vec2 c, in vec2 b, float r )\n{\n    vec2 d = p - c;\n    float d2 = dot( d, d );\n    float r2 = r * r;\n    if( d2 > r2 )\n    {\n", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r )\n{\n    vec4 d = abs(p) - b;\n    return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - r.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    vec4 d = abs(p) - b;\n    return length(max(d,0.0)) - r.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 t )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - r.x - t.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r, in vec3 t )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r.x - t.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x;\n}\n\n// distance to sphere\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// distance to cylinder\nfloat sdCylinder( in vec2 p, in vec2 b, in float h )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x + h;\n}\n\n// distance to cone\nfloat sdCone( in vec2 p, in vec2 b, in float h )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x + h;\n}\n\n// distance to torus\nfloat sdTorus( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x + r;\n}\n\n// distance to plane\nfloat sdPlane( in vec2 p, in vec2 n, in float d )\n{\n    return dot(p,n) - d;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x + r;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x + r.x;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec2 p, in vec2 b, in vec2 r, in vec2 c )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) - b.x", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx +.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash23(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx +.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sin and Cos\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash34(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx +.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sin and Cos\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash45(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx +.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sin and Cos\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash56(vec2 p){\n", "\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the noise thing\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n    return mix(\n        mix(\n            mix(\n                mix(\n                    mix(\n                        mix(\n                            mix(\n                                mix(\n                                    mix(\n                                        mix(\n                                            mix(\n                                                mix(\n                                                    mix(\n                                                        mix(\n                                                            mix(\n                                                                mix(\n                                                                    mix(\n                                                                        mix(\n                                                                            mix(\n                                                                                mix(\n                                                                                    mix(\n                                                                                        mix(\n                                                                                            mix(\n                                                                                                mix(\n                                                                                                    mix(\n                                                                                                        mix(\n                                                                                                            mix(\n                                                                                                                mix(\n                                                                                                                    mix(\n                                                                                                                        mix(\n                                                                                                                            mix(\n                                                                                                                                mix(\n                                                                                                                                    mix(\n                                                                                                                                        mix(\n                                                                                                                                            mix(\n                                                                                                                                                mix(\n                                                                                                                                                    mix(\n                                                                                                                                                        mix(\n                                                                                                                                                            mix(\n                                                                                                                                                                mix(\n                                                                                                                                                                    mix(\n                                                                                                                                                                        mix(\n                                                                                                                                                                            mix(\n                                                                                                ", "\n    return fract(sin(vec2(st.x*3.0, st.y*5.0))*43758.5453);\n}\n\n// From iq\nfloat random(vec2 st){\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// From iq\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(\n        mix(\n            mix(\n                mix(\n                    mix(\n                        mix(\n                            mix(\n                                mix(\n                                    mix(\n                                        mix(\n                                            mix(\n                                                mix(\n                                                    mix(\n                                                        mix(\n                                                            mix(\n                                                                mix(\n                                                                    mix(\n                                                                        mix(\n                                                                            mix(\n                                                                                mix(\n                                                                                    mix(\n                                                                                        mix(\n                                                                                            mix(\n                                                                                                mix(\n                                                                                                    mix(\n                                                                                                        mix(\n                                                                                                            mix(\n                                                                                                                mix(\n                                                                                                                    mix(\n                                                                                                                        mix(\n                                                                                                                            mix(\n                                                                                                                                mix(\n                                                                                                                                    mix(\n                                                                                                                                        mix(\n                                                                                                                                            mix(\n                                                                                                                                                mix(\n                                                                                                                                                    mix(\n                                                                                                                                                        mix(\n                                                                                                                                                            mix(\n                                                                                                                                                                mix(\n                                                                ", "\n    float n = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x0 = x.x;\n    float y0 = x.y;\n    float x1 = x0 + 1.0;\n    float y1 = y0 + 1.0;\n    float x2 = x0 + 2.0;\n    float y2 = y0 + 2.0;\n    float x3 = x0 + 3.0;\n    float y3 = y0 + 3.0;\n    float x4 = x0 + 4.0;\n    float y4 = y0 + 4.0;\n    float x5 = x0 + 5.0;\n    float y5 = y0 + 5.0;\n    float x6 = x0 + 6.0;\n    float y6 = y0 + 6.0;\n    float x7 = x0 + 7.0;\n    float y7 = y0 + 7.0;\n    float x8 = x0 + 8.0;\n    float y8 = y0 + 8.0;\n    float x9 = x0 + 9.0;\n    float y9 = y0 + 9.0;\n    float x10 = x0 + 10.0;\n    float y10 = y0 + 10.0;\n    float x11 = x0 + 11.0;\n    float y11 = y0 + 11.0;\n    float x12 = x0 + 12.0;\n    float y12 = y0 + 12.0;\n    float x13 = x0 + 13.0;\n    float y13 = y0 + 13.0;\n    float x14 = x0 + 14.0;\n    float y14", "\n    float v = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float s = 1.0;\n    float n = 40.0;\n    for(int i=0; i<n; i++)\n    {\n        v += s * noise(vec2(x.x * a, x.y * b));\n        s *= b;\n        a *= 2.0;\n        b *= 2.0;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the 2-octave noise function\nfloat fbm2(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float s = 1.0;\n    float n = 40.0;\n    for(int i=0; i<n; i++)\n    {\n        v += s * noise(vec2(x.x * a, x.y * b));\n        s *= b;\n        a *= 2.0;\n        b *= 2.0;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the 3-octave noise function\nfloat fbm3(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float s = 1.0;\n    float n = 40.0;\n    for(int i=0; i<n; i++)\n    {\n        v += s * noise(vec2(x.x * a, x.y * b));\n        s *= b;\n        a *= 2.0;\n        b *= 2.0;\n    }\n    return v;\n}\n\n// Fractional Brownian Motion noise to test the 4-octave noise function\nfloat fbm4(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    ", "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x0 = 0.0;\n    float y0 = 0.0;\n    float z0 = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float z2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float z3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float z4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float z5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float z6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float z7 = 0.0;\n    float x8 = 0.0;\n    float y8 = ", "\n    float a = 1.0 - x * x - y * y;\n    return a > 0.0? a : 0.0;\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    float a = areaElement(x, y);\n    return a > 0.0? 1.0 / a : 0.0;\n}\n\n//\n// Generate a cubemap texture from a set of 6 images.\n//\n// The images are assumed to be in the order:\n//\n// +x\n// -x\n// +y\n// -y\n// +z\n// -z\n//\n// The images are assumed to be in the order:\n//\n// +x\n// +y\n// +z\n// -x\n// -y\n// -z\n//\n// The images are assumed to be in the order:\n//\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// -x\n// -y\n// -z\n// -x\n// -y\n// -z\n//\n// The images are assumed to be in the order:\n//\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// -x\n// -y\n// -z\n// -x\n// -y\n// -z\n// -x\n// -y\n// -z\n//\n// The images are assumed to be in the order:\n//\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// +x\n// +y\n// +z\n// -x\n// -y\n// -z\n// -x\n// -y\n// -z\n// -x\n// -y\n// -z\n// -x\n// -y\n// -z\n//\n// The images are assumed to be in the order:\n//\n// +x\n// +y\n// +z\n// +x\n", "\n  p3 += dot(p3, vec3(1e3));\n  return fract(sin(p3) * 43758.5453123);\n}\n\nvec3 hash33(vec2 p2) {\n  p2 += dot(p2, vec2(1e3));\n  return fract(sin(p2) * 43758.5453123);\n}\n\nvec3 hash33(float p) {\n  p += dot(p, vec3(1e3));\n  return fract(sin(p) * 43758.5453123);\n}\n\nvec3 hash33(vec4 p4) {\n  p4 += dot(p4, vec4(1e3));\n  return fract(sin(p4) * 43758.5453123);\n}\n\nvec3 hash33(vec2 p2, vec2 p3) {\n  p2 += dot(p2, vec2(1e3));\n  p3 += dot(p3, vec2(1e3));\n  return fract(sin(p2 + p3) * 43758.5453123);\n}\n\nvec3 hash33(vec2 p2, vec3 p3) {\n  p2 += dot(p2, vec2(1e3));\n  p3 += dot(p3, vec3(1e3));\n  return fract(sin(p2 + p3) * 43758.5453123);\n}\n\nvec3 hash33(vec3 p3, vec3 p4) {\n  p3 += dot(p3, vec3(1e3));\n  p4 += dot(p4, vec3(1e3));\n  return fract(sin(p3 + p4) * 43758.5453123);\n}\n\nvec3 hash33(vec3 p3, vec4 p4) {\n  p3 += dot(p3, vec3(1e3));\n  p4 += dot(", "\n  vec3 p0 = floor(p);\n  vec3 p1 = p0 + vec3(1.0);\n  vec3 p2 = p0 + vec3(2.0);\n  p = p - p0;\n  vec3 f = p * p * p * (1.0 - p3 + p2 * (-0.5 + p * 0.5));\n  return f.x + f.y + f.z;\n}\n\nfloat simplex2d(vec2 p) {\n  vec2 p0 = floor(p);\n  vec2 p1 = p0 + vec2(1.0);\n  p = p - p0;\n  vec2 f = p * p * (1.0 - p2 + p1 * (-0.5 + p * 0.5));\n  return f.x + f.y;\n}\n\nfloat simplex1d(vec2 p) {\n  vec2 p0 = floor(p);\n  vec2 p1 = p0 + vec2(1.0);\n  p = p - p0;\n  vec2 f = p * p * (1.0 - p2 + p1 * (-0.5 + p * 0.5));\n  return f.x + f.y;\n}\n\nfloat simplex(vec2 p) {\n  vec2 p0 = floor(p);\n  vec2 p1 = p0 + vec2(1.0);\n  p = p - p0;\n  vec2 f = p * p * (1.0 - p2 + p1 * (-0.5 + p * 0.5));\n  return f.x + f.y;\n}\n\nfloat simplex3(vec3 p) {\n  vec3 p0 = floor(p);\n  vec3 p1 = p0 + vec3(1.0);\n  vec3 p2 = p0 + vec3(2.0);\n  p = p - p0;\n  vec3 f = p * p * p * (1.0 - p3 + p2 * (-0.5 + p * 0.5));\n  return f.x + f.y + f.z;\n}\n\n", "\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    return x - h;\n}\n\nvec2 hash( in vec2 x )\n{\n    vec2 h = fract( x.x*x.y );\n    ", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    return length( pa ) - t * length( ba );\n}\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    float u = dot( pa, ca ) / dot( ca, ca );\n    return length( pa ) - t * length( ba ) - u * length( ca );\n}\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 da = d - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    float u = dot( pa, ca ) / dot( ca, ca );\n    float v = dot( pa, da ) / dot( da, da );\n    return length( pa ) - t * length( ba ) - u * length( ca ) - v * length( da );\n}\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 da = d - a;\n    vec2 ea = e - a;\n    float t = dot( pa, ba ) / dot( ba, ba );\n    float u = dot( pa, ca ) / dot( ca, ca );\n    float v = dot( pa, da ) / dot( da, da );\n    float w = dot( pa, ea ) / dot( ea, ea", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) + r.x;\n}\n\n// This is the final form\nfloat sdCylinder( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) + r.x;\n}\n\n// This is the final form\nfloat sdSphere( in vec2 p, in vec2 r )\n{\n    return length(p) - r.x;\n}\n\n// This is the final form\nfloat sdCone( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) + r.x;\n}\n\n// This is the final form\nfloat sdCone( in vec2 p, in vec2 b, in vec2 r, in float h )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) + r.x + h;\n}\n\n// This is the final form\nfloat sdCone( in vec2 p, in vec2 b, in vec2 r, in float h, in float a )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) + r.x + h + a;\n}\n\n// This is the final form\nfloat sdCone( in vec2 p, in vec2 b, in vec2 r, in float h, in float a, in float c )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0", "\n    // https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    float a = radius;\n    float b = radius * sqrt(1.0 - normal.y * normal.y);\n    float c = radius * sqrt(1.0 - normal.x * normal.x);\n    float d = radius * sqrt(1.0 - normal.z * normal.z);\n    float e = a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash13(vec3 p)\n{\n    return fract(sin(dot(p, vec3(19.5156, 31.875, 16.5625))) * 43758.5453);\n}\n\nfloat Hash14(vec4 p)\n{\n    return fract(sin(dot(p, vec4(19.5156, 31.875, 16.5625, 10.125))) * 43758.5453);\n}\n\nfloat Hash15(vec5 p)\n{\n    return fract(sin(dot(p, vec5(19.5156, 31.875, 16.5625, 10.125, 5.0625))) * 43758.5453);\n}\n\nfloat Hash16(vec6 p)\n{\n    return fract(sin(dot(p, vec6(19.5156, 31.875, 16.5625, 10.125, 5.0625, 2.53125))) * 43758.5453);\n}\n\nfloat Hash17(vec7 p)\n{\n    return fract(sin(dot(p, vec7(19.5156, 31.875, 16.5625, 10.125, 5.0625, 2.53125, 1.265625))) * 43758.5453);\n}\n\nfloat Hash18(vec8 p)\n{\n    return fract(sin(dot(p, vec8(19.5156, 31.875, 16.5", "\n    float d = 0.0;\n    float a = an;\n    float b = bn;\n    float c = acs.x;\n    float d = acs.y;\n    float e = acs.x + acs.y;\n    float f = acs.x - acs.y;\n    float g = acs.x * acs.y;\n    float h = acs.x * acs.x + acs.y * acs.y;\n    float i = acs.x * acs.x - acs.y * acs.y;\n    float j = acs.x * acs.x + acs.y * acs.y;\n    float k = acs.x * acs.x - acs.y * acs.y;\n    float l = acs.x * acs.x + acs.y * acs.y;\n    float m = acs.x * acs.x - acs.y * acs.y;\n    float n = acs.x * acs.x + acs.y * acs.y;\n    float o = acs.x * acs.x - acs.y * acs.y;\n    float p = acs.x * acs.x + acs.y * acs.y;\n    float q = acs.x * acs.x - acs.y * acs.y;\n    float r = acs.x * acs.x + acs.y * acs.y;\n    float s = acs.x * acs.x - acs.y * acs.y;\n    float t = acs.x * acs.x + acs.y * acs.y;\n    float u = acs.x * acs.x - acs.y * acs.y;\n    float v = acs.x * acs.x + acs.y * acs.y;\n    float w = acs.x * acs.x - acs.y * acs.y;\n    float x = acs.x * acs.x + acs.y * acs", "\n    vec3 e = vec3( 1.0, 0.0, 0.0 );\n    vec3 f = vec3( 0.0, 1.0, 0.0 );\n    vec3 g = vec3( 0.0, 0.0, 1.0 );\n    vec3 n = cross( e, f ) + cross( f, g ) + cross( g, e );\n    return normalize( n );\n}\n\nvec3 normal( vec3 p )\n{\n    vec3 n = vec3( 0.0, 0.0, 0.0 );\n    vec3 e = vec3( 1.0, 0.0, 0.0 );\n    vec3 f = vec3( 0.0, 1.0, 0.0 );\n    vec3 g = vec3( 0.0, 0.0, 1.0 );\n    vec3 h = cross( e, f ) + cross( f, g ) + cross( g, e );\n    vec3 i = cross( e, g ) + cross( f, g ) + cross( f, e );\n    n = normalize( h + i );\n    return n;\n}\n\nvec3 normal( vec3 p )\n{\n    vec3 n = vec3( 0.0, 0.0, 0.0 );\n    vec3 e = vec3( 1.0, 0.0, 0.0 );\n    vec3 f = vec3( 0.0, 1.0, 0.0 );\n    vec3 g = vec3( 0.0, 0.0, 1.0 );\n    vec3 h = cross( e, f ) + cross( f, g ) + cross( g, e );\n    vec3 i = cross( e, g ) + cross( f, g ) + cross( f, e );\n    vec3 j = cross( f, g ) + cross( g, e ) + cross( e, f );\n    n = normalize( h + i + j );\n    return n;\n}\n\nvec3 normal( vec3 p )\n{\n    vec3 n = vec3( 0", "\n    float h = clamp(t1 - t0, 0.0, 1.0);\n    float h2 = h * h;\n    float h3 = h2 * h;\n    float h4 = h3 * h;\n    float h5 = h4 * h;\n    float h6 = h5 * h;\n    float h7 = h6 * h;\n    float h8 = h7 * h;\n    float h9 = h8 * h;\n    float h10 = h9 * h;\n    float h11 = h10 * h;\n    float h12 = h11 * h;\n    float h13 = h12 * h;\n    float h14 = h13 * h;\n    float h15 = h14 * h;\n    float h16 = h15 * h;\n    float h17 = h16 * h;\n    float h18 = h17 * h;\n    float h19 = h18 * h;\n    float h20 = h19 * h;\n    float h21 = h20 * h;\n    float h22 = h21 * h;\n    float h23 = h22 * h;\n    float h24 = h23 * h;\n    float h25 = h24 * h;\n    float h26 = h25 * h;\n    float h27 = h26 * h;\n    float h28 = h27 * h;\n    float h29 = h28 * h;\n    float h30 = h29 * h;\n    float h31 = h30 * h;\n    float h32 = h31 * h;\n    float h33 = h32 * h;\n    float h34 = h33 * h;\n    float h35 = h34 * h;\n    float h36 = h35 * h;\n    float h37 = h36 * h;\n    float h38 = h37 * h;\n    float h39 = h38 * h;\n    float h40 = h39 * h;", "\n    float ao = 0.0;\n    float d = 0.0;\n    float r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n    float r4 = 0.0;\n    float r5 = 0.0;\n    float r6 = 0.0;\n    float r7 = 0.0;\n    float r8 = 0.0;\n    float r9 = 0.0;\n    float r10 = 0.0;\n    float r11 = 0.0;\n    float r12 = 0.0;\n    float r13 = 0.0;\n    float r14 = 0.0;\n    float r15 = 0.0;\n    float r16 = 0.0;\n    float r17 = 0.0;\n    float r18 = 0.0;\n    float r19 = 0.0;\n    float r20 = 0.0;\n    float r21 = 0.0;\n    float r22 = 0.0;\n    float r23 = 0.0;\n    float r24 = 0.0;\n    float r25 = 0.0;\n    float r26 = 0.0;\n    float r27 = 0.0;\n    float r28 = 0.0;\n    float r29 = 0.0;\n    float r30 = 0.0;\n    float r31 = 0.0;\n    float r32 = 0.0;\n    float r33 = 0.0;\n    float r34 = 0.0;\n    float r35 = 0.0;\n    float r36 = 0.0;\n    float r37 = 0.0;\n    float r38 = 0.0;\n    float r39 = 0.0;\n    float r40 = 0.0;\n    float r41 = 0.0;\n    float r42 = 0", "\n  float sinAngle = sin(angle);\n  float cosAngle = cos(angle);\n  float oneMinusCosAngle = 1.0 - cosAngle;\n  float x = axis.x;\n  float y = axis.y;\n  float z = axis.z;\n  return mat3(\n    x * x * oneMinusCosAngle + cosAngle,\n    y * x * oneMinusCosAngle - z * sinAngle,\n    z * x * oneMinusCosAngle + y * sinAngle,\n    x * y * oneMinusCosAngle + z * sinAngle,\n    y * y * oneMinusCosAngle + cosAngle,\n    z * y * oneMinusCosAngle - x * sinAngle,\n    x * z * oneMinusCosAngle - y * sinAngle,\n    y * z * oneMinusCosAngle + x * sinAngle,\n    z * z * oneMinusCosAngle + cosAngle\n  );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixXAngle(float angle) {\n  float sinAngle = sin(angle);\n  float cosAngle = cos(angle);\n  float oneMinusCosAngle = 1.0 - cosAngle;\n  return mat3(\n    cosAngle,\n    0.0,\n    -sinAngle,\n    0.0,\n    oneMinusCosAngle,\n    0.0,\n    0.0,\n    0.0,\n    sinAngle\n  );\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixYAngle(float angle) {\n  float sinAngle = sin(angle);\n  float cosAngle = cos(angle);\n  float oneMinusCosAngle = 1.0 - cosAngle;\n  return mat3(\n    cosAngle,\n    0.0,\n    sinAngle,\n    sinAngle,\n    oneMinusCosAngle,\n    0.0,\n    0.0,\n    0.0,\n    cosAngle\n  );\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZAngle(float angle", "\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  vec3 rayDir = normalize(vec3(uv, -1.0));\n  return rayDir;\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(float n) {\n  return fract(sin(n) * 43758.5453);\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates a random number between 0 and 1\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 151.719))) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4dTime(vec4 co){\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 151.719, 119.742))) * 43758.5453);\n}\n\n// Standard 5d noise\nfloat rand5dTime(vec5 co){\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 151.719, 119.742))) * 43758.5453);\n}\n\n// Standard 6d noise\nfloat rand6dTime(vec6 co){\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 151.719, 119.742))) * 43758.5453);\n}\n\n// Standard 7d noise\nfloat rand7dTime(vec7 co){\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 151.719, 119.742))) * 43758.5453);\n}\n\n// Standard 8d noise\nfloat rand8dTime(vec8 co){\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.23", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 151.719))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(131.224, 74.656))) * 43758.5453);\n}\n\n// Simplex noise\nfloat noise(vec3 p){\n    vec3 p0 = floor(p);\n    vec3 p1 = p0 + vec3(1.0);\n    p0 = p - p0;\n    p1 = 1.0 - p1;\n    vec3 x0 = p0.xzx;\n    vec3 x1 = p1.xzx;\n    vec3 y0 = p0.yyz;\n    vec3 y1 = p1.yyz;\n    vec4 ix = floor(x0);\n    vec4 iy = floor(y0);\n    vec4 ixy = ix + iy;\n    vec4 iyx = iy + ix;\n    vec4 i = floor(p + dot(p, vec3(1.5)));\n    vec4 i0 = i - 1.0;\n    vec4 i1 = i - 0.0;\n    vec3 f = fract(p + dot(p, vec3(1.5)));\n    f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    vec3 c = vec3(0.0);\n    vec3 x = x0;\n    vec3 y = y0;\n    vec3 n0 = 0.0;\n    vec3 n1 = 0.0;\n    vec2 ixy0 = vec2(ix.x, iy.y);\n    vec2 ixy1 = vec2(ix.y, iy.x);\n    vec2 iyx0 = vec2(iyx.x, iyx.y);\n", "\n    vec3 p = floor(x);\n    vec3 xp = fract(x);\n    vec3 u = xp*xp*xp*(3.0-2.0*xp);\n\n    vec3 p0 = p;\n    vec3 p1 = p+vec3(1.0,0.0,0.0);\n    vec3 p2 = p+vec3(0.0,1.0,0.0);\n    vec3 p3 = p+vec3(0.0,0.0,1.0);\n\n    vec4 v;\n    v.x = texture3D(uTexture, p0.xzx, u.x).x;\n    v.y = texture3D(uTexture, p1.xzx, u.x).y;\n    v.z = texture3D(uTexture, p2.xzx, u.x).z;\n    v.w = texture3D(uTexture, p3.xzx, u.x).w;\n    return mix(v.x, v.y, u.z) + (1.0-u.z)*mix(v.z, v.w, u.z);\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 xp = fract(x);\n    vec3 u = xp*xp*xp*(3.0-2.0*xp);\n\n    vec3 p0 = p;\n    vec3 p1 = p+vec3(1.0,0.0,0.0);\n    vec3 p2 = p+vec3(0.0,1.0,0.0);\n    vec3 p3 = p+vec3(0.0,0.0,1.0);\n\n    vec4 v;\n    v.x = texture3D(uTexture, p0.xzx, u.x).x;\n    v.y = texture3D(uTexture, p1.xzx, u.x).y;\n    v.z = texture3D(uTexture, p2.xzx, u.x).z;\n    v", "\n\tvec3 p0 = floor(p);\n\tvec3 p1 = p0 + vec3(1.0);\n\tvec3 p2 = p0 + vec3(2.0);\n\tvec3 p3 = p0 + vec3(3.0);\n\n\tp = p - p0;\n\tp = p*p*(3.0-2.0*p.z-p.y);\n\n\tvec3 x0 = p3.x-p0.x;\n\tvec3 x1 = p2.x-p1.x;\n\tvec3 x2 = p1.x-p0.x;\n\tvec3 x3 = p3.x-p3.x;\n\tvec3 x4 = p2.x-p2.x;\n\tvec3 x5 = p1.x-p1.x;\n\tvec3 x6 = p0.x-p0.x;\n\n\tvec3 y0 = p3.y-p0.y;\n\tvec3 y1 = p2.y-p1.y;\n\tvec3 y2 = p1.y-p0.y;\n\tvec3 y3 = p3.y-p3.y;\n\tvec3 y4 = p2.y-p2.y;\n\tvec3 y5 = p1.y-p1.y;\n\tvec3 y6 = p0.y-p0.y;\n\n\tvec3 z0 = p3.z-p0.z;\n\tvec3 z1 = p2.z-p1.z;\n\tvec3 z2 = p1.z-p0.z;\n\tvec3 z3 = p3.z-p3.z;\n\tvec3 z4 = p2.z-p2.z;\n\tvec3 z5 = p1.z-p1.z;\n\tvec3 z6 = p0.z-p0.z;\n\n\tvec3 xyz0 = x0*y0*z0;\n\tvec3 xyz1 = x1*y1*z1;\n\tvec3 xyz2 = x2*y2*z2;\n\tvec3", "\n    float f = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float fbm = 0.0;\n    float amp = 0.0;\n    float freq = 0.0;\n    float lacunarity = 0.0;\n    float gain = 0.0;\n    float lacunarity2 = 0.0;\n    float gain2 = 0.0;\n    float lacunarity3 = 0.0;\n    float gain3 = 0.0;\n    float lacunarity4 = 0.0;\n    float gain4 = 0.0;\n    float lacunarity5 = 0.0;\n    float gain5 = 0.0;\n    float lacunarity6 = 0.0;\n    float gain6 = 0.0;\n    float lacunarity7 = 0.0;\n    float gain7 = 0.0;\n    float lacunarity8 = 0.0;\n    float gain8 = 0.0;\n    float lacunarity9 = 0.0;\n    float gain9 = 0.0;\n    float lacunarity10 = 0.0;\n    float gain10 = 0.0;\n    float lacunarity11 = 0.0;\n    float gain11 = 0.0;\n    float lacunarity12 = 0.0;\n    float gain12 = 0.0;\n    float lacunarity13 = 0.0;\n    float gain13 = 0.0;\n    float lacunarity14 = 0.0;\n    float gain14 = 0.0;\n    float lacunarity15 = 0.0;\n    float gain15 = 0.0;\n    float lacunarity16 = 0.0;\n    float gain16 = 0.0;\n    float lacunarity17 = 0.0;\n    float gain17 = 0.", "\n\tfloat density = 0.0;\n\tfloat color = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat x2 = 0.0;\n\tfloat y2 = 0.0;\n\tfloat z2 = 0.0;\n\tfloat x3 = 0.0;\n\tfloat y3 = 0.0;\n\tfloat z3 = 0.0;\n\tfloat x4 = 0.0;\n\tfloat y4 = 0.0;\n\tfloat z4 = 0.0;\n\tfloat x5 = 0.0;\n\tfloat y5 = 0.0;\n\tfloat z5 = 0.0;\n\tfloat x6 = 0.0;\n\tfloat y6 = 0.0;\n\tfloat z6 = 0.0;\n\tfloat x7 = 0.0;\n\tfloat y7 = 0.0;\n\tfloat z7 = 0.0;\n\tfloat x8 = 0.0;\n\tfloat y8 = 0.0;\n\tfloat z8 = 0.0;\n\tfloat x9 = 0.0;\n\tfloat y9 = 0.0;\n\tfloat z9 = 0.0;\n\tfloat x10 = 0.0;\n\tfloat y10 = 0.0;\n\tfloat z10 = 0.0;\n\tfloat x11 = 0.0;\n\tfloat y11 = 0.0;\n\tfloat z11 = 0.0;\n\tfloat x12 = 0.0;\n\tfloat y12 = 0.0;\n\tfloat z12 = 0.0;\n\tfloat x13 = 0.0;\n\tfloat y13 = 0.0;\n\tfloat z13 = 0.0;\n\tfloat x14 = 0.0;\n\tfloat y14 = 0.0;\n\tfloat z14 = 0.0;\n\tfloat x15 = 0.0;\n\tfloat y15", "\n\tfloat coverage = 0.0;\n\tfloat step = 0.0;\n\tfloat stepSize = 0.01;\n\tfloat stepSize2 = 0.001;\n\tfloat stepSize3 = 0.0001;\n\tfloat stepSize4 = 0.00001;\n\tfloat stepSize5 = 0.000001;\n\tfloat stepSize6 = 0.0000001;\n\tfloat stepSize7 = 0.00000001;\n\tfloat stepSize8 = 0.000000001;\n\tfloat stepSize9 = 0.0000000001;\n\tfloat stepSize10 = 0.00000000001;\n\tfloat stepSize11 = 0.000000000001;\n\tfloat stepSize12 = 0.0000000000001;\n\tfloat stepSize13 = 0.00000000000001;\n\tfloat stepSize14 = 0.000000000000001;\n\tfloat stepSize15 = 0.0000000000000001;\n\tfloat stepSize16 = 0.00000000000000001;\n\tfloat stepSize17 = 0.000000000000000001;\n\tfloat stepSize18 = 0.0000000000000000001;\n\tfloat stepSize19 = 0.00000000000000000001;\n\tfloat stepSize20 = 0.000000000000000000001;\n\tfloat stepSize21 = 0.000000000000000000000", "\n    vec3 color = vec3(0.0);\n    float fog = 0.0;\n    float alpha = 1.0;\n    float distFog = 0.0;\n    float distFog2 = 0.0;\n    float distFog3 = 0.0;\n    float distFog4 = 0.0;\n    float distFog5 = 0.0;\n    float distFog6 = 0.0;\n    float distFog7 = 0.0;\n    float distFog8 = 0.0;\n    float distFog9 = 0.0;\n    float distFog10 = 0.0;\n    float distFog11 = 0.0;\n    float distFog12 = 0.0;\n    float distFog13 = 0.0;\n    float distFog14 = 0.0;\n    float distFog15 = 0.0;\n    float distFog16 = 0.0;\n    float distFog17 = 0.0;\n    float distFog18 = 0.0;\n    float distFog19 = 0.0;\n    float distFog20 = 0.0;\n    float distFog21 = 0.0;\n    float distFog22 = 0.0;\n    float distFog23 = 0.0;\n    float distFog24 = 0.0;\n    float distFog25 = 0.0;\n    float distFog26 = 0.0;\n    float distFog27 = 0.0;\n    float distFog28 = 0.0;\n    float distFog29 = 0.0;\n    float distFog30 = 0.0;\n    float distFog31 = 0.0;\n    float distFog32 = 0.0;\n    float distFog33 = 0.0;\n    float distFog34 = 0.0;\n    float distFog35 = 0.0", "\n    vec3 luminance = vec3(0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b);\n    vec3 white = vec3(0.95047, 1.0, 1.08883);\n    vec3 white_ref = vec3(0.95047, 1.0, 1.08883);\n    vec3 white_ref_luminance = vec3(0.2126 * white_ref.r + 0.7152 * white_ref.g + 0.0722 * white_ref.b);\n    vec3 white_luminance = vec3(0.2126 * white.r + 0.7152 * white.g + 0.0722 * white.b);\n    vec3 gamma = vec3(1.0 / white_luminance.r, 1.0 / white_luminance.g, 1.0 / white_luminance.b);\n    vec3 gamma_luminance = vec3(1.0 / white_ref_luminance.r, 1.0 / white_ref_luminance.g, 1.0 / white_ref_luminance.b);\n    vec3 gamma_inv = vec3(1.0 / gamma.r, 1.0 / gamma.g, 1.0 / gamma.b);\n    vec3 gamma_inv_luminance = vec3(1.0 / gamma_luminance.r, 1.0 / gamma_luminance.g, 1.0 / gamma_luminance.b);\n    vec3 gamma_inv_luminance_sqrt = vec3(sqrt(gamma_inv_luminance.r), sqrt(gamma_inv_luminance.g), sqrt(gamma_inv_luminance.b));\n    vec3 gamma_inv_luminance_sqrt_gamma = vec3(pow(gamma_inv_luminance_sqrt.r, gamma.r), pow(gamma_inv_luminance_sqrt."]}