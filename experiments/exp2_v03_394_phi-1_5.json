{"generations": ["\n    vec3 v = vec3( s.x, s.y, s.z );\n    vec3 v_0 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_1 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_2 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_3 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_4 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_5 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_6 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_7 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_8 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_9 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_10 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_11 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_12 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_13 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_14 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_15 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_16 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_17 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_18 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_19 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_20 = vec3( 0.0, 0.0, 0.0 );\n    vec3 v_21 =", "\n    float d = b - a;\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n    float d31 = d30 * d;\n    float d32 = d31 * d;\n    float d33 = d32 * d;\n    float d34 = d33 * d;\n    float d35 = d34 * d;\n    float d36 = d35 * d;\n    float d37 = d36 * d;\n    float d38 = d37 * d;\n    float d39 = d38 * d;\n    float d40 = d39 * d;\n    float d41 = d40 * d;\n    float d42 = d41 * d;\n    float d43 = d42 * d;\n    float d44 = d43 * d;\n    float d45 = d44 * d;\n    float d46 = d45 * d;\n    float d47 = d46 *", "\n    vec2 out = v;\n    if( r.x < 0 )\n        out.x = -out.x;\n    if( r.y < 0 )\n        out.y = -out.y;\n    if( r.z < 0 )\n        out.z = -out.z;\n    return out;\n}\n\nvec2 rotate( vec2 v, vec2 r )\n{\n    vec2 out = v;\n    out.x = r.x * out.x - r.y * out.y - r.z * out.z;\n    out.y = r.x * out.y + r.y * out.x + r.z * out.z;\n    out.z = r.x * out.z - r.y * out.y - r.z * out.x;\n    return out;\n}\n\nvec2 rotateAround( vec2 v, vec2 r, vec2 theta )\n{\n    vec2 out = v;\n    out.x = r.x * out.x - r.y * out.y - r.z * out.z;\n    out.y = r.x * out.y + r.y * out.x + r.z * out.z;\n    out.z = r.x * out.z - r.y * out.y - r.z * out.x;\n    out.x = out.x * cos(theta) - out.y * sin(theta);\n    out.y = out.x * sin(theta) + out.y * cos(theta);\n    out.z = out.z * cos(theta) - out.y * sin(theta);\n    return out;\n}\n\nvec2 rotateAround3D( vec2 v, vec2 r, vec2 theta, vec3 up )\n{\n    vec2 out = v;\n    out.x = r.x * out.x - r.y * out.y - r.z * out.z;\n    out.y = r.x * out.y + r.y * out.x + r.z * out.z;\n    out.z = r.x * out.z - r", "\n    vec2 refl = v;\n    if ( r.x < 0 )\n        refl.x = -refl.x;\n    if ( r.y < 0 )\n        refl.y = -refl.y;\n    if ( r.z < 0 )\n        refl.z = -refl.z;\n    return refl;\n}\n\nvec2 reflect( in vec2 v, in vec2 r )\n{\n    vec2 refl = reflectIfNeg( v, r );\n    return refl;\n}\n\nvec2 reflectIfNeg( in vec2 v, in vec2 r )\n{\n    vec2 refl = v;\n    if ( r.x < 0 )\n        refl.x = -refl.x;\n    if ( r.y < 0 )\n        refl.y = -refl.y;\n    if ( r.z < 0 )\n        refl.z = -refl.z;\n    return refl;\n}\n\nvec2 reflect( in vec2 v, in vec2 r )\n{\n    vec2 refl = reflectIfNeg( v, r );\n    return refl;\n}\n\nvec2 reflect( in vec2 v, in vec2 r )\n{\n    vec2 refl = v;\n    if ( r.x < 0 )\n        refl.x = -refl.x;\n    if ( r.y < 0 )\n        refl.y = -refl.y;\n    if ( r.z < 0 )\n        refl.z = -refl.z;\n    return refl;\n}\n\nvec2 reflect( in vec2 v, in vec2 r )\n{\n    vec2 refl = reflectIfNeg( v, r );\n    return refl;\n}\n\nvec2 reflect( in vec2 v, in vec2 r )\n{\n    vec2 refl = v;\n    if ( r.x < 0 )\n        refl.x = -refl.x;\n    if ( r.y < 0 )\n        refl.y = -refl.y;\n    if ( r.z < 0 )\n        refl.z = -refl", "\n    vec2 clip = vec2(0,0);\n    if( v.x < 0 )\n        clip.x = -v.x;\n    if( v.y < 0 )\n        clip.y = -v.y;\n    return clip;\n}\n\nvec2 clip( in vec2 v, in vec2 r )\n{\n    vec2 clip = vec2(0,0);\n    if( v.x < 0 )\n        clip.x = clipIfNeg( v.x, r );\n    if( v.y < 0 )\n        clip.y = clipIfNeg( v.y, r );\n    return clip;\n}\n\nvec2 clip2( in vec2 v, in vec2 r )\n{\n    vec2 clip = vec2(0,0);\n    if( v.x < 0 )\n        clip.x = clipIfNeg( v.x, r );\n    if( v.y < 0 )\n        clip.y = clipIfNeg( v.y, r );\n    return clip;\n}\n\nvec2 clip3( in vec2 v, in vec2 r )\n{\n    vec2 clip = vec2(0,0);\n    if( v.x < 0 )\n        clip.x = clipIfNeg( v.x, r );\n    if( v.y < 0 )\n        clip.y = clipIfNeg( v.y, r );\n    if( v.z < 0 )\n        clip.z = clipIfNeg( v.z, r );\n    return clip;\n}\n\nvec2 clip4( in vec2 v, in vec2 r )\n{\n    vec2 clip = vec2(0,0);\n    if( v.x < 0 )\n        clip.x = clipIfNeg( v.x, r );\n    if( v.y < 0 )\n        clip.y = clipIfNeg( v.y, r );\n    if( v.z < 0 )\n        clip.z = clipIfNeg( v.z, r );\n    if( v.w < 0 )\n        clip.w = clipIfNeg( v.w, r );\n    return clip;\n}\n\nvec2 clip5( in vec", "\n    vec2 p1 = p + a;\n    vec2 p2 = p + b;\n    vec2 p3 = p - a;\n    vec2 p4 = p - b;\n    vec2 p5 = p - p1;\n    vec2 p6 = p - p2;\n    vec2 p7 = p - p3;\n    vec2 p8 = p - p4;\n    vec2 p9 = p - p5;\n    vec2 p10 = p - p6;\n    vec2 p11 = p - p7;\n    vec2 p12 = p - p8;\n    vec2 p13 = p - p9;\n    vec2 p14 = p - p10;\n    vec2 p15 = p - p11;\n    vec2 p16 = p - p12;\n    vec2 p17 = p - p13;\n    vec2 p18 = p - p14;\n    vec2 p19 = p - p15;\n    vec2 p20 = p - p16;\n    vec2 p21 = p - p17;\n    vec2 p22 = p - p18;\n    vec2 p23 = p - p19;\n    vec2 p24 = p - p20;\n    vec2 p25 = p - p21;\n    vec2 p26 = p - p22;\n    vec2 p27 = p - p23;\n    vec2 p28 = p - p24;\n    vec2 p29 = p - p25;\n    vec2 p30 = p - p26;\n    vec2 p31 = p - p27;\n    vec2 p32 = p - p28;\n    vec2 p33 = p - p29;\n    vec2 p34 = p - p30;\n    vec2 p35 = p - p31;\n    vec2 p36 = p - p32;\n    vec2 p37 = p - p33;\n    vec2 p38 = p - p34;\n    vec2 p39 = p - p35;\n    vec2 p40 = p - p36;\n    vec2 p41 = p - p37;\n    vec2 p42 = p - p38;\n    vec2 p43 = p - p39;", "\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSun", "\n    vec4 p = p0;\n    vec4 q = p1;\n    vec4 r = p2;\n    vec4 s = p3;\n\n    float c = (1.0 - t) * (1.0 - t);\n    float d = (1.0 - t) * t;\n    float e = t * (1.0 - t);\n    float f = t * t;\n\n    p = p0 + c * (q - p0) + d * (r - q);\n    q = p1 + c * (p - p1) + d * (r - p1);\n    r = p2 + c * (p - p2) + d * (r - p2);\n    s = p3 + c * (p - p3) + d * (r - p3);\n\n    return p;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 p = p0;\n    vec4 q = p1;\n    vec4 r = p2;\n    vec4 s = p3;\n\n    float c = (1.0 - t) * (1.0 - t);\n    float d = (1.0 - t) * t;\n    float e = t * (1.0 - t);\n    float f = t * t;\n\n    p = p0 + c * (q - p0) + d * (r - q);\n    q = p1 + c * (p - p1) + d * (r - p1);\n    r = p2 + c * (p - p2) + d * (r - p2);\n    s = p3 + c * (p - p3) + d * (r - p3);\n\n    return p;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 p = p0;\n    vec4 q = p1;\n    vec4 r = p2;\n", "\n    vec3 v = p - vec3(0,0,0);\n    float r = normalizer * sin(2*M_PI*(float)rand()/float(M_PI*2));\n    vec3 vn = vec3(0,0,0);\n    vec3 vn2 = vec3(0,0,0);\n    vec3 vn3 = vec3(0,0,0);\n    vec3 vn4 = vec3(0,0,0);\n    vec3 vn5 = vec3(0,0,0);\n    vec3 vn6 = vec3(0,0,0);\n    vec3 vn7 = vec3(0,0,0);\n    vec3 vn8 = vec3(0,0,0);\n    vec3 vn9 = vec3(0,0,0);\n    vec3 vn10 = vec3(0,0,0);\n    vec3 vn11 = vec3(0,0,0);\n    vec3 vn12 = vec3(0,0,0);\n    vec3 vn13 = vec3(0,0,0);\n    vec3 vn14 = vec3(0,0,0);\n    vec3 vn15 = vec3(0,0,0);\n    vec3 vn16 = vec3(0,0,0);\n    vec3 vn17 = vec3(0,0,0);\n    vec3 vn18 = vec3(0,0,0);\n    vec3 vn19 = vec3(0,0,0);\n    vec3 vn20 = vec3(0,0,0);\n    vec3 vn21 = vec3(0,0,0);\n    vec3 vn22 = vec3(0,0,0);\n    vec3 vn23 = vec3(0,0,0);\n    vec3 vn24 = vec3(0,0,0);\n    vec3 vn25 = vec3(0,0,0);\n    vec3 vn26 = vec3(0,0,0);\n    vec3 vn27 = vec3(0,0,0);\n    vec3 vn28", "\n    vec4 p = vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p += vec4(0.0, 0.0, 0.0, 0.0);\n    p +=", "\n    float h = 0.0;\n    for (int i = 0; i < N; ++i)\n    {\n        h += u * exp(-i * log(u));\n    }\n    return h;\n}\n\nfloat Hash2d(float u[N][N])\n{\n    float h = 0.0;\n    for (int i = 0; i < N; ++i)\n    {\n        for (int j = 0; j < N; ++j)\n        {\n            h += u[i][j] * exp(-i * log(u[i][j]) - j * log(u[j][i]));\n        }\n    }\n    return h;\n}\n\nfloat Hash3d(float u[N][N][N])\n{\n    float h = 0.0;\n    for (int i = 0; i < N; ++i)\n    {\n        for (int j = 0; j < N; ++j)\n        {\n            for (int k = 0; k < N; ++k)\n            {\n                h += u[i][j][k] * exp(-i * log(u[i][j][k]) - j * log(u[j][i][k]) - k * log(u[k][i][j]));\n            }\n        }\n    }\n    return h;\n}\n\nfloat Hash4d(float u[N][N][N][N])\n{\n    float h = 0.0;\n    for (int i = 0; i < N; ++i)\n    {\n        for (int j = 0; j < N; ++j)\n        {\n            for (int k = 0; k < N; ++k)\n            {\n                for (int l = 0; l < N; ++l)\n                {\n                    h += u[i][j][k][l] * exp(-i * log(u[i][j][k][l]) - j * log(u[j][i][k][l]) - k * log(u[k][i][j][l]) - l * log(u[l][i][j][k]));\n                }\n            }\n        }\n    }\n", "\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float t = 0.0;\n    float rt = 0.0;\n    float rt2 = 0.0;\n    float rt3 = 0.0;\n    float rt4 = 0.0;\n    float rt5 = 0.0;\n    float rt6 = 0.0;\n    float rt7 = 0.0;\n    float rt8 = 0.0;\n    float rt9 = 0.0;\n    float rt10 = 0.0;\n    float rt11 = 0.0;\n    float rt12 = 0.0;\n    float rt13 = 0.0;\n    float rt14 = 0.0;\n    float rt15 = 0.0;\n    float rt16 = 0.0;\n    float rt17 = 0.0;\n    float rt18 = 0.0;\n    float rt19 = 0.0;\n    float rt20 = 0.0;\n    float rt21 = 0.0;\n    float rt22 = 0.0;\n    float rt23 = 0.0;\n    float rt24 = 0.0;\n    float rt25 = 0.0;\n    float rt26 = 0.0;\n    float rt27 = 0.0;\n    float rt28 = 0.0;\n    float rt29 = 0.0;\n    float rt30 = 0.0;\n    float rt31 = 0.0;\n    float rt32 = 0.0;\n    float rt33 = 0.0;\n    float rt34 = 0.0;\n    float rt35 = 0.0;\n    float rt36 = 0.0;\n    float rt37 = 0.0;\n    float rt38 = 0.0;\n    float rt39 = 0.0;\n    float rt40 = 0.0;\n    float rt41 = 0.0;\n    float rt", "\n    float d = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        d += (p[i] - obj[i]) * (p[i] - obj[i]);\n    }\n    return sqrt(d);\n}\n\n// This is the function that makes the fractal shape\nvoid DrawFractal(vec3 p)\n{\n    vec3 d = vec3(0, 0, 0);\n    for (int i = 0; i < 3; i++)\n    {\n        d += (p[i] - obj[i]) * (p[i] - obj[i]);\n    }\n    vec3 r = vec3(0, 0, 0);\n    r += d;\n    vec3 p1 = vec3(p - r, p - r, p - r);\n    vec3 p2 = vec3(p + r, p + r, p + r);\n    vec3 p3 = vec3(p - r, p - r, p - r);\n    vec3 p4 = vec3(p + r, p + r, p + r);\n    vec3 p5 = vec3(p - r, p - r, p - r);\n    vec3 p6 = vec3(p + r, p + r, p + r);\n    vec3 p7 = vec3(p - r, p - r, p - r);\n    vec3 p8 = vec3(p + r, p + r, p + r);\n    vec3 p9 = vec3(p - r, p - r, p - r);\n    vec3 p10 = vec3(p + r, p + r, p + r);\n    vec3 p11 = vec3(p - r, p - r, p - r);\n    vec3 p12 = vec3(p + r, p + r, p + r);\n    vec3 p13 = vec3(p - r, p - r, p - r);\n    vec3 p14 = vec3(p + r, p + r, p + r);\n    vec3 p15 = vec3(p - r, p - r, p - r);\n    vec3 p16 = vec3(p", "\n    vec3 lightDir = rayDir - sunDir;\n    vec3 lightDirLen = lightDir.length();\n    vec3 lightDirLenSq = lightDirLen * lightDirLen;\n    vec3 lightDirLenSqSq = lightDirLenSq * lightDirLenSq;\n    vec3 lightDirLenSqSqSq = lightDirLenSqSq * lightDirLenSqSq;\n    vec3 lightDirLenSqSqSqSq = lightDirLenSqSqSq * lightDirLenSqSqSq;\n    vec3 lightDirLenSqSqSqSqSq = lightDirLenSqSqSqSq * lightDirLenSqSqSqSq;\n    vec3 lightDirLenSqSqSqSqSqSq = lightDirLenSqSqSqSqSq * lightDirLenSqSqSqSqSq;\n    vec3 lightDirLenSqSqSqSqSqSqSq = lightDirLenSqSqSqSqSqSq * lightDirLenSqSqSqSqSqSqSq;\n    vec3 lightDirLenSqSqSqSqSqSqSqSq = lightDirLenSqSqSqSqSqSqSq * lightDirLenSqSqSqSqSqSqSqSqSqSq;\n    vec3 lightDirLenSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqS", "\n    float x = a;\n    float y = b;\n    float z = 0;\n    float w = 0;\n    float x2 = 0;\n    float y2 = 0;\n    float z2 = 0;\n    float x3 = 0;\n    float y3 = 0;\n    float z3 = 0;\n    float x4 = 0;\n    float y4 = 0;\n    float z4 = 0;\n    float x5 = 0;\n    float y5 = 0;\n    float z5 = 0;\n    float x6 = 0;\n    float y6 = 0;\n    float z6 = 0;\n    float x7 = 0;\n    float y7 = 0;\n    float z7 = 0;\n    float x8 = 0;\n    float y8 = 0;\n    float z8 = 0;\n    float x9 = 0;\n    float y9 = 0;\n    float z9 = 0;\n    float x10 = 0;\n    float y10 = 0;\n    float z10 = 0;\n    float x11 = 0;\n    float y11 = 0;\n    float z11 = 0;\n    float x12 = 0;\n    float y12 = 0;\n    float z12 = 0;\n    float x13 = 0;\n    float y13 = 0;\n    float z13 = 0;\n    float x14 = 0;\n    float y14 = 0;\n    float z14 = 0;\n    float x15 = 0;\n    float y15 = 0;\n    float z15 = 0;\n    float x16 = 0;\n    float y16 = 0;\n    float z16 = 0;\n    float x17 = 0;\n    float y17 = 0;\n    float z17 = 0;\n    float x18 = 0;\n    float y18 = 0;\n    float z18 = 0;\n    float x19 = 0;\n    float y19 = 0;\n    float z19 = 0;\n    float x20 = 0;\n    float y20 = 0;\n    float z20 = 0;\n    float x21 = 0;\n    float y21 = 0;\n    float z21 = 0;\n    float x", "\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst));\n    vec3 dirVecPLZNormalizeMeFirst = dirVecPLZNormalizeMeFirst / (float)sqrt(dot(dirVecPLZNormalizeMeFirst, dirV", "\n    vec2 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{\n    vec3 d = p - ObjectPosition;\n    return d;\n}\n\nvec3 DistanceToObject(vec3 p)\n{", "\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(t, 1, 0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(t, 0, 1);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD14(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD15(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD16(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD17(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD18(float t)\n{\n    return vec3(t, 0, 0);\n}\n\nvec3 mapD19(float t)\n", "\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = v.x + (1.0 - t) * dt * v.x;\n    v.y = v.y + (1.0 - t) * dt * v.y;\n    v.z = v.z + (1.0 - t) * dt * v.z;\n    return v;\n}\n\nvec3 mapD2(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = v.x + (1.0 - t) * dt * v.x;\n    v.y = v.y + (1.0 - t) * dt * v.y;\n    v.z = v.z + (1.0 - t) * dt * v.z;\n    return v;\n}\n\nvec3 mapD3(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = v.x + (1.0 - t) * dt * v.x;\n    v.y = v.y + (1.0 - t) * dt * v.y;\n    v.z = v.z + (1.0 - t) * dt * v.z;\n    return v;\n}\n\nvec3 mapD4(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = v.x + (1.0 - t) * dt * v.x;\n    v.y = v.y + (1.0 - t) * dt * v.y;\n    v.z = v.z + (1.0 - t) * dt * v.z;\n    return v;\n}\n\nvec3 mapD5(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = v.x + (1.0 - t) * dt * v.x;\n    ", "\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 1.0 - t;\n    v.y = 0.0;\n    v.z = 0.0;\n    return v;\n}\n\nvec3 mapD3(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 0.0;\n    v.y = 1.0 - t;\n    v.z = 0.0;\n    return v;\n}\n\nvec3 mapD4(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 0.0;\n    v.y = 0.0;\n    v.z = 1.0 - t;\n    return v;\n}\n\nvec3 mapD5(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 0.0;\n    v.y = 0.0;\n    v.z = 0.0;\n    return v;\n}\n\nvec3 mapD6(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 0.0;\n    v.y = 0.0;\n    v.z = 0.0;\n    return v;\n}\n\nvec3 mapD7(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 0.0;\n    v.y = 0.0;\n    v.z = 0.0;\n    return v;\n}\n\nvec3 mapD8(float t)\n{\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    v.x = 0.0;\n    v.y = 0.0;\n    v.z = 0.0;\n    return v;\n}\n\nvec3 mapD9(float t)\n{\n    vec3 v = vec3(", "\n    vec2 usqdPoint = usqdPointSegment( p, a, b );\n    return usqdPoint.x * usqdPoint.x + usqdPoint.y * usqdPoint.y;\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqdPoint = usqdPointSegment( p, a, b );\n    return usqdPoint.x * usqdPoint.x + usqdPoint.y * usqdPoint.y;\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqdPoint = usqdPointSegment( p, a, b );\n    return usqdPoint.x * usqdPoint.x + usqdPoint.y * usqdPoint.y;\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqdPoint = usqdPointSegment( p, a, b );\n    return usqdPoint.x * usqdPoint.x + usqdPoint.y * usqdPoint.y;\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqdPoint = usqdPointSegment( p, a, b );\n    return usqdPoint.x * usqdPoint.x + usqdPoint.y * usqdPoint.y;\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqdPoint = usqdPointSegment( p, a, b );\n    return usqdPoint.x * usqdPoint.x + usqdPoint.y * usqdPoint.y;\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqdPoint = usqdPointSeg", "\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return usqd.x * usqd.x + usqd.y * usqd.y;\n}\n\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return usqd.x * usqd.x + usqd.y * usqd.y;\n}\n\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return usqd.x * usqd.x + usqd.y * usqd.y;\n}\n\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return usqd.x * usqd.x + usqd.y * usqd.y;\n}\n\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return usqd.x * usqd.x + usqd.y * usqd.y;\n}\n\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return usqd.x * usqd.x + usqd.y * usqd.y;\n}\n\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return", "\n    float x = p.x - b.x;\n    float y = p.y - b.y;\n    float z = p.z - b.z;\n    float w = p.w - b.w;\n    float s = sqrt(x*x + y*y + z*z);\n    float r = sqrt(r.x*r.x + r.y*r.y + r.z*r.z);\n    float t = s/r;\n    return t;\n}\n\nvec3 normalize( vec3 p )\n{\n    vec3 n = p;\n    n.x /= sqrt(n.x*n.x + n.y*n.y + n.z*n.z);\n    n.y /= sqrt(n.x*n.x + n.y*n.y + n.z*n.z);\n    n.z /= sqrt(n.x*n.x + n.y*n.y + n.z*n.z);\n    return n;\n}\n\nvec3 normalize( vec3 p, vec3 q )\n{\n    vec3 n = normalize(p);\n    vec3 nq = normalize(q);\n    return nq.cross(n);\n}\n\nvec3 normalize( vec3 p, vec3 q, vec3 r )\n{\n    vec3 n = normalize(p);\n    vec3 nq = normalize(q);\n    vec3 nr = normalize(r);\n    return nq.cross(nr);\n}\n\nvec3 normalize( vec3 p, vec3 q, vec3 r, vec3 s )\n{\n    vec3 n = normalize(p);\n    vec3 nq = normalize(q);\n    vec3 nr = normalize(r);\n    vec3 ns = normalize(s);\n    return nq.cross(nr).cross(ns);\n}\n\nvec3 normalize( vec3 p, vec3 q, vec3 r, vec3 s, vec3 t )\n{\n    vec3 n = normalize(p);\n    vec3 nq = normalize(q);\n    vec", "\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 reflection = rayDir.dot(sunDir);\n    if (reflection < 0.0) reflection = 0.0;\n    if (reflection > 1.0) reflection = 1.0;\n    return reflection;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSun", "\n    vec3 r = vec3(0, 0, 1);\n    vec3 t = vec3(0, 0, 1);\n    vec3 r_dot = vec3(0, 0, 0);\n    vec3 t_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 t_dot_dot_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0, 0);\n    vec3 r_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot = vec3(0, 0", "\n    vec3 rayPosition = currentRayPosition;\n    vec3 normal = normalize( cross( vec3(0,0,1), vec3(rayPosition.x, rayPosition.y, rayPosition.z) ) );\n    vec3 distance = normalize( cross( vec3(0,0,1), vec3(normal.x, normal.y, normal.z) ) );\n    vec3 direction = normalize( cross( vec3(0,0,1), vec3(normal.x, normal.y, -normal.z) ) );\n    vec3 normalDirection = normalize( cross( vec3(0,0,1), vec3(direction.x, direction.y, direction.z) ) );\n    vec3 normalDirection2 = normalize( cross( vec3(0,0,1), vec3(normalDirection.x, normalDirection.y, -normalDirection.z) ) );\n    vec3 normalDirection3 = normalize( cross( vec3(0,0,1), vec3(normalDirection.x, -normalDirection.y, normalDirection.z) ) );\n    vec3 normalDirection4 = normalize( cross( vec3(0,0,1), vec3(normalDirection3.x, -normalDirection3.y, -normalDirection3.z) ) );\n    vec3 normalDirection5 = normalize( cross( vec3(0,0,1), vec3(normalDirection4.x, -normalDirection4.y, normalDirection4.z) ) );\n    vec3 normalDirection6 = normalize( cross( vec3(0,0,1), vec3(normalDirection5.x, -normalDirection5.y, -normalDirection5.z) ) );\n    vec3 normalDirection7 = normalize( cross( vec3(0,0,1), vec3(normalDirection6.x, -normalDirection6.y, normalDirection6.z) ) );\n    vec3 normalDirection8 = normalize( cross( vec3(0,0,1), vec3(normalDirection7.x, -normalDirection7.y, -normalDirection7.z) ) );", "\n    vec2 distanceToThing1 = distanceTo( thing1, thing2 );\n    vec2 distanceToThing2 = distanceTo( thing2, thing1 );\n    if( distanceToThing1 < distanceToThing2 ){\n        return thing1;\n    }\n    else{\n        return thing2;\n    }\n}\n\n// This function takes in a vec2 and returns a vec2\n// that is the same as the input vec2, but with the\n// distance to the origin (0,0) removed\nvec2 removeDistanceToOrigin( vec2 vec2 ){\n    vec2 newVec2 = vec2( vec2.x, vec2.y );\n    newVec2.x = newVec2.x - vec2.x;\n    newVec2.y = newVec2.y - vec2.y;\n    return newVec2;\n}\n\n// This function takes in a vec2 and returns a vec2\n// that is the same as the input vec2, but with the\n// distance to the origin (0,0) removed\nvec2 distanceToOrigin( vec2 vec2 ){\n    vec2 newVec2 = vec2( vec2.x, vec2.y );\n    newVec2.x = newVec2.x - vec2.x;\n    newVec2.y = newVec2.y - vec2.y;\n    return newVec2;\n}\n\n// This function takes in a vec2 and returns a vec2\n// that is the same as the input vec2, but with the\n// distance to the origin (0,0) removed\nvec2 distanceToLine( vec2 vec2, vec2 line ){\n    vec2 newVec2 = vec2( vec2.x, vec2.y );\n    newVec2.x = newVec2.x - vec2.x;\n    newVec2.y = newVec2.y - vec2.y;\n    newVec2.x = newVec2.x - line.x;\n    newVec2.y = newVec2.y - line.y;\n    return newVec2;\n}\n", "\n    vec2 closest = vec2(0,0);\n    vec2 closestDistance = vec2(0,0);\n    for( vec2 rayPosition : world ){\n        if( distance( currentRayPosition, rayPosition ) < closestDistance ){\n            closestDistance = distance( currentRayPosition, rayPosition );\n            closest = rayPosition;\n        }\n    }\n    return closest;\n}\n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n    vec2 closest = vec2(0,0);\n    vec2 closestDistance = vec2(0,0);\n    for( vec2 rayPosition : world ){\n        if( distance( currentRayPosition, rayPosition ) < closestDistance ){\n            closestDistance = distance( currentRayPosition, rayPosition );\n            closest = rayPosition;\n        }\n    }\n    return closest;\n}\n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n    vec2 closest = vec2(0,0);\n    vec2 closestDistance = vec2(0,0);\n    for( vec2 rayPosition : world ){\n        if( distance( currentRayPosition, rayPosition ) < closestDistance ){\n            closestDistance = distance( currentRayPosition, rayPosition );\n            closest = rayPosition;\n        }\n    }\n    return closest;\n}\n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n    vec2 closest = vec2(0,0);\n    vec2 closestDistance = vec2(0,0);\n    for( vec2 rayPosition : world ){\n        if( distance( currentRayPosition, rayPosition ) < closestDistance ){\n            closestDistance = distance", "\n    vec3 normal = normalize( positionOfHit - hit.position );\n    normal.x = normal.y = normal.z = 0;\n    return normal;\n}\n\n// This function is used to calculate the normal of the surface\n// based on the hit.position and the hit.position of the\n// surface.\nvec3 getNormalOfSurface( in vec3 positionOfHit, in vec3 positionOfSurface ){\n    vec3 normal = normalize( positionOfSurface - positionOfHit );\n    normal.x = normal.y = normal.z = 0;\n    return normal;\n}\n\n// This function is used to calculate the normal of the surface\n// based on the hit.position and the hit.position of the\n// surface.\nvec3 getNormalOfSurface( in vec3 positionOfHit, in vec3 positionOfSurface, in vec3 normal ){\n    vec3 normal = normalize( positionOfSurface - positionOfHit );\n    normal.x = normal.y = normal.z = 0;\n    return normal;\n}\n\n// This function is used to calculate the normal of the surface\n// based on the hit.position and the hit.position of the\n// surface.\nvec3 getNormalOfSurface( in vec3 positionOfHit, in vec3 positionOfSurface, in vec3 normal, in vec3 normal2 ){\n    vec3 normal = normalize( positionOfSurface - positionOfHit );\n    normal.x = normal.y = normal.z = 0;\n    normal2.x = normal2.y = normal2.z = 0;\n    return normal;\n}\n\n// This function is used to calculate the normal of the surface\n// based on the hit.position and the hit.position of the\n// surface.\nvec3 getNormalOfSurface( in vec3 positionOfHit, in vec3 positionOfSurface, in vec3 normal, in vec3 normal2 ){\n    vec3 normal = normalize( positionOfSurface - positionOfHit );\n    normal.x = normal.y = normal.z = 0;\n    normal2.x = normal2.y = normal2.z = 0;\n    return normal;\n}\n\n// This function is used to calculate the normal", "\n    vec3 color = vec3(0, 0, 0);\n    return color;\n}\n\n// this is the function that draws the background\nvoid drawBackground(){\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_TEXTURE_2D);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, background);\n    glEnable(GL_TEXTURE_2D);\n    glDisable(GL_BLEND);\n}\n\n// this is the function that draws the background\nvoid drawBackground2(){\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_TEXTURE_2D);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, background);\n    glEnable(GL_TEXTURE_2D);\n    glDisable(GL_BLEND);\n}\n\n// this is the function that draws the background\nvoid drawBackground3(){\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glEnable(GL_BLEND);\n    glBlendFunc(", "\n    vec3 color = normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize(normalize", "\n    vec3 worldColor = vec3(0,0,0);\n    vec3 worldColor2 = vec3(0,0,0);\n    vec3 worldColor3 = vec3(0,0,0);\n    vec3 worldColor4 = vec3(0,0,0);\n    vec3 worldColor5 = vec3(0,0,0);\n    vec3 worldColor6 = vec3(0,0,0);\n    vec3 worldColor7 = vec3(0,0,0);\n    vec3 worldColor8 = vec3(0,0,0);\n    vec3 worldColor9 = vec3(0,0,0);\n    vec3 worldColor10 = vec3(0,0,0);\n    vec3 worldColor11 = vec3(0,0,0);\n    vec3 worldColor12 = vec3(0,0,0);\n    vec3 worldColor13 = vec3(0,0,0);\n    vec3 worldColor14 = vec3(0,0,0);\n    vec3 worldColor15 = vec3(0,0,0);\n    vec3 worldColor16 = vec3(0,0,0);\n    vec3 worldColor17 = vec3(0,0,0);\n    vec3 worldColor18 = vec3(0,0,0);\n    vec3 worldColor19 = vec3(0,0,0);\n    vec3 worldColor20 = vec3(0,0,0);\n    vec3 worldColor21 = vec3(0,0,0);\n    vec3 worldColor22 = vec3(0,0,0);\n    vec3 worldColor23 = vec3(0,0,0);\n    vec3 worldColor24 = vec3(0,0,0);\n    vec3 worldColor25 = vec3(0,0,0);\n    vec3 worldColor26 = vec3(0,0,0);\n    vec3 worldColor27 = vec3(0,0,0);\n    vec3 worldColor28 = vec3(0,0,0);\n    vec3 worldColor29 = vec3(0,0,0);\n    vec3 worldColor30 = vec3(0,0,0);\n    vec", "\n    return (b - x) / (b - x + 1.0);\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat smoothstep(float x, float b, float c) {\n    return (b - x) / (b - x + 1.0) + c;\n}\n\n// returns a value between 0 and 1\nfloat", "\n    return rand() / (float)RAND_MAX;\n}\n\n// creates a vector of random floats in the range 0..1 excluding 0\nvec2 randvec(vec2 p){\n    vec2 r = vec2(0.0, 0.0);\n    for(int i = 0; i < p.size(); ++i){\n        r += rand(p[i]);\n    }\n    return r;\n}\n\n// creates a vector of random floats in the range 0..1 excluding 0\nvec2 randvec2(vec2 p){\n    vec2 r = vec2(0.0, 0.0);\n    for(int i = 0; i < p.size(); ++i){\n        r += randvec(p[i]);\n    }\n    return r;\n}\n\n// creates a vector of random floats in the range 0..1 excluding 0\nvec2 randvec3(vec2 p){\n    vec2 r = vec2(0.0, 0.0);\n    for(int i = 0; i < p.size(); ++i){\n        r += randvec2(p[i]);\n    }\n    return r;\n}\n\n// creates a vector of random floats in the range 0..1 excluding 0\nvec2 randvec4(vec2 p){\n    vec2 r = vec2(0.0, 0.0);\n    for(int i = 0; i < p.size(); ++i){\n        r += randvec3(p[i]);\n    }\n    return r;\n}\n\n// creates a vector of random floats in the range 0..1 excluding 0\nvec2 randvec5(vec2 p){\n    vec2 r = vec2(0.0, 0.0);\n    for(int i = 0; i < p.size(); ++i){\n        r += randvec4(p[i]);\n    }\n    return r;\n}\n\n// creates a vector of random floats in the range 0..1 excluding 0\nvec2 randvec6(vec2 p){\n    vec2 r = vec2(0.0, 0.0);\n    for(int i = 0; i < p.size(); ++i){\n        r += randvec5(p[i]);", "\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_outliers(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_inclusive_outliers(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_outliers_inclusive(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_inclusive_outliers_inclusive(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_inclusive_outliers_outliers(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_outliers_inclusive_outliers(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_outliers_outliers_inclusive(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_inclusive_outliers_outliers(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_outliers_outliers_inclusive(vec2 p){\n    vec2 r = vec2(rand(1.0f), rand(1.0f));\n    return p + r;\n}\n\nvec2 rand_inclusive_outliers_outliers_inclusive", "\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    if (d < r)\n        return d;\n    else\n        return r;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> is point\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    if (d < r)\n        return d;\n    else\n        return r;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> is point\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    if (d < r)\n        return d;\n    else\n        return r;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> is point\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    if (d < r)\n        return d;\n    else\n        return r;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> is point\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    float d = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    if (d < r)\n        return d;\n    else\n        return r;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> is point\n// input r --> is", "\n    vec3 px = p.xz;\n    vec3 pz = p.z;\n    vec3 pz2 = pz * pz;\n    vec3 pz3 = pz2 * pz;\n    vec3 pz4 = pz3 * pz;\n    vec3 pz5 = pz4 * pz;\n    vec3 pz6 = pz5 * pz;\n    vec3 pz7 = pz6 * pz;\n    vec3 pz8 = pz7 * pz;\n    vec3 pz9 = pz8 * pz;\n    vec3 pz10 = pz9 * pz;\n    vec3 pz11 = pz10 * pz;\n    vec3 pz12 = pz11 * pz;\n    vec3 pz13 = pz12 * pz;\n    vec3 pz14 = pz13 * pz;\n    vec3 pz15 = pz14 * pz;\n    vec3 pz16 = pz15 * pz;\n    vec3 pz17 = pz16 * pz;\n    vec3 pz18 = pz17 * pz;\n    vec3 pz19 = pz18 * pz;\n    vec3 pz20 = pz19 * pz;\n    vec3 pz21 = pz20 * pz;\n    vec3 pz22 = pz21 * pz;\n    vec3 pz23 = pz22 * pz;\n    vec3 pz24 = pz23 * pz;\n    vec3 pz25 = pz24 * pz;\n    vec3 pz26 = pz25 * pz;\n    vec3 pz27 = pz26 * pz;\n    vec3 pz28 = pz27 * pz;\n    vec3 pz29 = pz28 * pz;\n    vec3 pz30 = pz29 * pz;\n    vec3 pz31 = pz30 * pz;\n    vec3 pz32 = pz31 * pz;\n    vec3 pz33 = pz32 * pz;\n    vec3 pz34 = pz", "\n    float d = d1 + d2;\n    float s = 0.0;\n    float s1 = 0.0;\n    float s2 = 0.0;\n    float s3 = 0.0;\n    float s4 = 0.0;\n    float s5 = 0.0;\n    float s6 = 0.0;\n    float s7 = 0.0;\n    float s8 = 0.0;\n    float s9 = 0.0;\n    float s10 = 0.0;\n    float s11 = 0.0;\n    float s12 = 0.0;\n    float s13 = 0.0;\n    float s14 = 0.0;\n    float s15 = 0.0;\n    float s16 = 0.0;\n    float s17 = 0.0;\n    float s18 = 0.0;\n    float s19 = 0.0;\n    float s20 = 0.0;\n    float s21 = 0.0;\n    float s22 = 0.0;\n    float s23 = 0.0;\n    float s24 = 0.0;\n    float s25 = 0.0;\n    float s26 = 0.0;\n    float s27 = 0.0;\n    float s28 = 0.0;\n    float s29 = 0.0;\n    float s30 = 0.0;\n    float s31 = 0.0;\n    float s32 = 0.0;\n    float s33 = 0.0;\n    float s34 = 0.0;\n    float s35 = 0.0;\n    float s36 = 0.0;\n    float s37 = 0.0;\n    float s38 = 0.0;\n    float s39 = 0.0;\n    float s40 = 0.0;\n    float s41 = 0.0;\n    float s42 = 0.0;\n    float s43 = 0.0;\n    float s44 = 0.0;\n    float s45 = 0.0;\n    float s46 = 0.0;\n    float s47 = 0.0;\n    float s48 = 0.0;\n    float s49 = 0.0;\n    ", "\n    float d = d1 + d2;\n    if (d < 0)\n        d = 0;\n    if (d > 1)\n        d = 1;\n    return d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 + d2;\n    if (d < 0)\n        d = 0;\n    if (d > 1)\n        d = 1;\n    return d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 + d2;\n    if (d < 0)\n        d = 0;\n    if (d > 1)\n        d = 1;\n    return d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 + d2;\n    if (d < 0)\n        d = 0;\n    if (d > 1)\n        d = 1;\n    return d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 + d2;\n    if (d < 0)\n        d = 0;\n    if (d > 1)\n        d = 1;\n    return d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output -->", "\n    vec3 r = p + t * vec3(cosf(yaw), sinf(yaw), 0);\n    return r;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    vec3 r = p + t * vec3(cosf(yaw), sinf(yaw), 0);\n    return r;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    vec3 r = p + t * vec3(cosf(yaw), sinf(yaw), 0);\n    return r;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    vec3 r = p + t * vec3(cosf(yaw), sinf(yaw), 0);\n    return r;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    vec3 r = p + t * vec3(cosf(yaw), sinf(yaw), 0);\n    return r;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t", "\n    vec2 d = o1.x - o2.x;\n    vec2 d2 = o1.y - o2.y;\n    if (d.x < d2.x)\n        return o1;\n    else if (d.x > d2.x)\n        return o2;\n    else if (d.y < d2.y)\n        return o1;\n    else if (d.y > d2.y)\n        return o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    vec2 d = o1.x - o2.x;\n    vec2 d2 = o1.y - o2.y;\n    if (d.x < d2.x)\n        return o1;\n    else if (d.x > d2.x)\n        return o2;\n    else if (d.y < d2.y)\n        return o1;\n    else if (d.y > d2.y)\n        return o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    vec2 d = o1.x - o2.x;\n    vec2 d2 = o1.y - o2.y;\n    if (d.x < d2.x)\n        return o1;\n    else if (d.x > d2.x)\n        return o2;\n    else if (d.y < d2.y)\n        return o1;\n    else if (d.y > d2.y)\n        return o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID", "\n    vec2 r = p - ray;\n    vec2 d = map(r);\n    return d;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// return the object/point\nvec2 map(vec3 p)\n{\n    vec2 r = p - ray;\n    vec2 d = map(r);\n    return d;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// return the object/point\nvec2 map(vec3 p)\n{\n    vec2 r = p - ray;\n    vec2 d = map(r);\n    return d;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// return the object/point\nvec2 map(vec3 p)\n{\n    vec2 r = p - ray;\n    vec2 d = map(r);\n    return d;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// return the object/point\nvec2 map(vec3 p)\n{\n    vec2 r = p - ray;\n    vec2 d = map(r);\n    return d;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// return the object/point\nvec2 map(vec3 p)\n{\n    vec2 r = p - ray;\n    vec2 d = map(r);\n    ", "\n\tvec2 p = ro + rd;\n\tvec2 p1 = p - p.cross(ro);\n\tvec2 p2 = p - p1;\n\tvec2 p3 = p - p2;\n\tvec2 p4 = p - p3;\n\tvec2 p5 = p - p4;\n\tvec2 p6 = p - p5;\n\tvec2 p7 = p - p6;\n\tvec2 p8 = p - p7;\n\tvec2 p9 = p - p8;\n\tvec2 p10 = p - p9;\n\tvec2 p11 = p - p10;\n\tvec2 p12 = p - p11;\n\tvec2 p13 = p - p12;\n\tvec2 p14 = p - p13;\n\tvec2 p15 = p - p14;\n\tvec2 p16 = p - p15;\n\tvec2 p17 = p - p16;\n\tvec2 p18 = p - p17;\n\tvec2 p19 = p - p18;\n\tvec2 p20 = p - p19;\n\tvec2 p21 = p - p20;\n\tvec2 p22 = p - p21;\n\tvec2 p23 = p - p22;\n\tvec2 p24 = p - p23;\n\tvec2 p25 = p - p24;\n\tvec2 p26 = p - p25;\n\tvec2 p27 = p - p26;\n\tvec2 p28 = p - p27;\n\tvec2 p29 = p - p28;\n\tvec2 p30 = p - p29;\n\tvec2 p31 = p - p30;\n\tvec2 p32 = p - p31;\n\tvec2 p33 = p - p32;\n\tvec2 p34 = p - p33;\n\tvec2 p35 = p - p34;\n\tvec2 p36 = p - p35;\n\tvec2 p37 = p - p36;\n\tvec2 p38 = p - p37;\n\tvec2 p39 = p - p38;\n\tvec2 p40 = p - p39;\n\tvec2 p41 = p - p40;\n\tvec2 p42", "\n    vec3 p = ro + rd;\n    vec3 d = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 d = d / d.length();\n    vec3 p = p - d * d.length();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p - gl_ModelViewProjectionMatrix * gl_ModelViewProjectionMatrix.inverse();\n    vec3 p = p / p.length();\n    vec3 p = p", "\n    mat3 mat = mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat = mat * mat3(\n        cos(roll), -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat = mat * mat3(\n        camPos.x, camPos.y, camPos.z,\n        0.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    return mat;\n}\n\n// ~~~~~~~ creates camera projection matrix used to transform\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera projection matrix used to transform\nmat3 setCameraProjection( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    mat3 mat = mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat = mat * mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat = mat * mat3(\n        camPos.x, camPos.y, camPos.z,\n        0.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat = mat * mat3(\n        targetPos.x, targetPos.y, targetPos.z,\n        0.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat = mat * mat3(\n        0.0, 0.0, 0.0,\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (id < 0 || id >= numColors)\n        return color;\n    return vec3(a[id], a[id + 1], a[id + 2]);\n}\n\n// ~~~~~~~ silly function to access array member \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (id < 0 || id >= numColors)\n        return color;\n    return vec3(a[id], a[id + 1], a[id + 2]);\n}\n\n// ~~~~~~~ silly function to access array member \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (id < 0 || id >= numColors)\n        return color;\n    return vec3(a[id], a[id + 1], a[id + 2]);\n}\n\n// ~~~~~~~ silly function to access array member \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (id < 0 || id >= numColors)\n        return color;\n    return vec3(a[id], a[id + 1], a[id + 2]);\n}\n\n// ~~~~~~~ silly function to access array member \n// because webgl needs const index for array acess\n// TODO :", "\n    vec3 pTorus = p.xyz;\n    vec3 pTorusFlat = pTorus.xyz;\n    vec3 pTorusFlatFlat = pTorusFlat.xyz;\n    vec3 pTorusFlatFlatFlat = pTorusFlatFlat.xyz;\n    vec3 pTorusFlatFlatFlatFlat = pTorusFlatFlatFlat.xyz;\n    vec3 pTorusFlatFlatFlatFlatFlat = pTorusFlatFlatFlatFlat.xyz;\n    vec3 pTorusFlatFlatFlatFlatFlatFlat = pTorusFlatFlatFlatFlatFlatFlat.xyz;\n    vec3 pTorusFlatFlatFlatFlatFlatFlatFlat = pTorusFlatFlatFlatFlatFlatFlatFlatFlat.xyz;\n    vec3 pTorusFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlat = pTorusFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFlatFl", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.r --> radius\n//        ps.c --> center\n//        ps.h --> height\n// sphere extends indefinitely in x and y, \n// so just return height from floor (y)\nfloat sdSphere(vec3 p)\n{\n    return sdPlane(p) - sdPlane(p - p.r);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.r --> radius\n//        ps.h --> height\n//        ps.c --> center\n//        ps.l --> length\n// cylinder extends indefinitely in x and y, \n// so just return height from floor (y)\nfloat sdCylinder(vec3 p)\n{\n    return sdPlane(p) - sdPlane(p - p.r) - sdPlane(p - p.c);\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.r --> radius\n//        ps.h --> height\n//        ps.c --> center\n//        ps.l --> length\n// cone extends indefinitely in x and y, \n// so just return height from floor (y)\nfloat sdCone(vec3 p)\n{\n    return sdPlane(p) - sdPlane(p - p.r) - sdPlane(p - p.c);\n}\n\n// ~~~~~~~ signed distance function for pyramid\n//  input ps --> specs of pyramid\n//        ps.r --> radius\n//        ps.h --> height\n//        ps.c --> center\n//        ps.l --> length\n// pyramid extends indefinitely in x and y, \n// so just return height from floor (y)\nfloat sdPyramid(vec3 p)\n{\n    return sdPlane(p) - sdPlane(p - p.r) - sdPlane(p - p.c);\n}\n\n// ~~~~~~~ signed distance function for ellipse\n//  input ps --> specs of ellipse\n//        ps.a --> semi-major axis\n//", "\n    float d = d1 + d2;\n    float s = d1 * k + d2 * (1 - k);\n    return s;\n}\n\nA:\n\nI think you are looking for something like this:\nfloat smooth(float d1, float d2, float k)\n{\n    float s = d1 + d2;\n    s = s * k;\n    s = s + (1 - k) * d1;\n    s = s + (1 - k) * d2;\n    return s;\n}\n\nA:\n\nI think you are looking for something like this:\nfloat smooth(float d1, float d2, float k)\n{\n    float s = d1 + d2;\n    s = s * k;\n    s = s + (1 - k) * d1;\n    s = s + (1 - k) * d2;\n    return s;\n}\n\nA:\n\nI think you are looking for something like this:\nfloat smooth(float d1, float d2, float k)\n{\n    float s = d1 + d2;\n    s = s * k;\n    s = s + (1 - k) * d1;\n    s = s + (1 - k) * d2;\n    return s;\n}\n\nA:\n\nI think you are looking for something like this:\nfloat smooth(float d1, float d2, float k)\n{\n    float s = d1 + d2;\n    s = s * k;\n    s = s + (1 - k) * d1;\n    s = s + (1 - k) * d2;\n    return s;\n}\n\nA:\n\nI think you are looking for something like this:\nfloat smooth(float d1, float d2, float k)\n{\n    float s = d1 + d2;\n    s = s * k;\n    s = s + (1 - k) * d1;\n    s = s + (1 - k) * d2;\n    return s;\n}\n\nA:\n\nI think you are looking for something like this:\nfloat smooth(float d1, float d2, float k)", "\n    vec4 o1_color = o1.rgb;\n    vec4 o2_color = o2.rgb;\n    vec4 o1_dist = o1.dist;\n    vec4 o2_dist = o2.dist;\n    vec4 o1_blend = o1_color;\n    vec4 o2_blend = o2_color;\n    vec4 o1_blend_dist = o1_dist;\n    vec4 o2_blend_dist = o2_dist;\n    vec4 o1_blend_color = o1_color;\n    vec4 o2_blend_color = o2_color;\n    vec4 o1_blend_dist_blend = o1_dist;\n    vec4 o2_blend_dist_blend = o2_dist;\n    vec4 o1_blend_color_blend = o1_color;\n    vec4 o2_blend_color_blend = o2_color;\n    vec4 o1_blend_dist_blend_blend = o1_dist;\n    vec4 o2_blend_dist_blend_blend = o2_dist;\n    vec4 o1_blend_color_blend_blend = o1_color;\n    vec4 o2_blend_color_blend_blend = o2_color;\n    vec4 o1_blend_dist_blend_blend_blend = o1_dist;\n    vec4 o2_blend_dist_blend_blend_blend = o2_dist;\n    vec4 o1_blend_color_blend_blend_blend = o1_color;\n    vec4 o2_blend_color_blend_blend_blend = o2_color;\n    vec4 o1_blend_dist_blend_blend_blend_blend = o1_dist;\n    vec4 o2_blend_dist_blend_blend_blend_blend = o2_dist;\n    vec4 o1_blend_color_blend_blend_blend_bl", "\n    float d = d1 - d2;\n    return d;\n}\n\n// ~~~~~~~ do shape add, cuts d2 out of d1\n// by using  the positive of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opAdd(float d1,float d2)\n{\n    float d = d1 + d2;\n    return d;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    float d = d1 - d2;\n    return d;\n}\n\n// ~~~~~~~ do shape add, cuts d2 out of d1\n// by using  the positive of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opAdd(float d1,float d2)\n{\n    float d = d1 + d2;\n    return d;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    float d = d1 - d2;\n    return d;\n}\n\n// ~~~~~~~ do shape add, cuts d2 out of d1\n// by using  the positive of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opAdd(float d1,float d2)\n{\n    float d = d1 + d2;\n    return d;\n}\n\n// ~~~~~~~ do shape", "\n    vec3 pos = vec3(0, 0, 0);\n    pos += lightPos;\n    return pos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos(vec3 lightPos)\n{\n    vec3 pos = vec3(0, 0, 0);\n    pos += lightPos;\n    return pos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos(vec3 lightPos, vec3 lightDir)\n{\n    vec3 pos = vec3(0, 0, 0);\n    pos += lightPos;\n    pos += lightDir;\n    return pos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos(vec3 lightPos, vec3 lightDir, vec3 lightDir2)\n{\n    vec3 pos = vec3(0, 0, 0);\n    pos += lightPos;\n    pos += lightDir;\n    pos += lightDir2;\n    return pos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos(vec3 lightPos, vec3 lightDir, vec3 lightDir2, vec3 lightDir3)\n{\n    vec3 pos = vec3(0, 0, 0);\n    pos += lightPos;\n    pos += lightDir;\n    pos += lightDir2;\n    pos += lightDir3;\n    return pos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos(vec3 lightPos, vec3 lightDir, vec3 lightDir2, vec3 lightDir3, vec3 lightDir4)\n{\n    vec3 pos = vec3(0, 0, 0);\n    pos += lightPos;\n    pos += lightDir;\n    pos += lightDir2;\n    pos += lightDir3;\n    pos += lightDir4;\n    return pos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generate", "\n    vec4 out;\n    for (vec3 obj : world)\n    {\n        if (obj.distance(p) < obj.distance(out))\n        {\n            out = obj;\n        }\n    }\n    return out;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    vec4 out;\n    for (vec3 obj : world)\n    {\n        if (obj.distance(p) < obj.distance(out))\n        {\n            out = obj;\n        }\n    }\n    return out;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    vec4 out;\n    for (vec3 obj : world)\n    {\n        if (obj.distance(p) < obj.distance(out))\n        {\n            out = obj;\n        }\n    }\n    return out;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    vec4 out;\n    for (vec3 obj : world)\n    {\n        if (obj.distance(p) < obj.distance(out))\n        {\n            out = obj;\n        }\n    }\n    return out;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n", "\n    vec3 p = ro + rd * itterRatio;\n    vec3 d = p - ro;\n    vec3 n = normalize(d);\n    vec3 nn = cross(n, n);\n    vec3 nn1 = cross(nn, n);\n    vec3 nn2 = cross(nn1, n);\n    vec3 nn3 = cross(nn2, n);\n    vec3 nn4 = cross(nn3, n);\n    vec3 nn5 = cross(nn4, n);\n    vec3 nn6 = cross(nn5, n);\n    vec3 nn7 = cross(nn6, n);\n    vec3 nn8 = cross(nn7, n);\n    vec3 nn9 = cross(nn8, n);\n    vec3 nn10 = cross(nn9, n);\n    vec3 nn11 = cross(nn10, n);\n    vec3 nn12 = cross(nn11, n);\n    vec3 nn13 = cross(nn12, n);\n    vec3 nn14 = cross(nn13, n);\n    vec3 nn15 = cross(nn14, n);\n    vec3 nn16 = cross(nn15, n);\n    vec3 nn17 = cross(nn16, n);\n    vec3 nn18 = cross(nn17, n);\n    vec3 nn19 = cross(nn18, n);\n    vec3 nn20 = cross(nn19, n);\n    vec3 nn21 = cross(nn20, n);\n    vec3 nn22 = cross(nn21, n);\n    vec3 nn23 = cross(nn22, n);\n    vec3 nn24 = cross(nn23, n);\n    vec3 nn25 = cross(nn24, n);\n    vec3 nn26 = cross(nn25, n);\n    vec3 nn27 = cross(nn26, n);\n    vec3 nn28 = cross(nn27, n);\n    vec3 nn29 = cross(nn28, n);\n    vec3 nn30 = cross(nn29, n);\n    vec3 nn31 = cross(nn30,", "\n    float r = lp.x - sp.x;\n    float s = lp.y - sp.y;\n    float t = lp.z - sp.z;\n    float d = sqrt(r*r + s*s + t*t);\n    float a = 1.0f / d;\n    float b = d * a;\n    float c = -s * b;\n    float d = r * b;\n    float e = s * b;\n    float f = t * b;\n    float g = r * b;\n    float h = s * b;\n    float i = t * b;\n    float j = r * b;\n    float k = s * b;\n    float l = t * b;\n    float m = r * b;\n    float n = s * b;\n    float o = t * b;\n    float p = r * b;\n    float q = s * b;\n    float r = t * b;\n    float s = r * b;\n    float t = r * b;\n    float u = r * b;\n    float v = r * b;\n    float w = r * b;\n    float x = r * b;\n    float y = r * b;\n    float z = r * b;\n    float d = r * b;\n    float e = r * b;\n    float f = r * b;\n    float g = r * b;\n    float h = r * b;\n    float i = r * b;\n    float j = r * b;\n    float k = r * b;\n    float l = r * b;\n    float m = r * b;\n    float n = r * b;\n    float o = r * b;\n    float p = r * b;\n    float q = r * b;\n    float r = r * b;\n    float s = r * b;\n    float t = r * b;\n    float u = r * b;\n    float v = r * b;\n    float w = r * b;\n    float x = r * b;\n    float y = r * b;\n    float z = r * b;\n    float d =", "\n    vec3 n = normalize(nor);\n    vec3 p = sp - n * 0.5f;\n    float d = dot(p, n);\n    if (d < 0.0f)\n        return 0.0f;\n    return (float)sqrt(d);\n}\n\n// ~~~~~~~ raymarching\n// raymarching is a simple algorithm that finds the intersection of a ray with a\n// surface.\n// ~~~~~~~ raymarching_distance_fields\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat raymarching_distance_fields(vec3 sp, vec3 nor, vec3 p)\n{\n    vec3 n = normalize(nor);\n    vec3 p = sp - n * 0.5f;\n    float d = dot(p, n);\n    if (d < 0.0f)\n        return 0.0f;\n    return (float)sqrt(d);\n}\n\n// ~~~~~~~ raymarching_distance_fields_2\n// raymarching_distance_fields_2 is a slightly more efficient version of\n// raymarching_distance_fields.\n// ~~~~~~~ raymarching_distance_fields_2\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat raymarching_distance_fields_2(vec3 sp, vec3 nor, vec3 p)\n{\n    vec3 n = normalize(nor);\n    vec3 p = sp - n * 0.5f;\n    float d = dot(p, n);\n    if (d < 0.0f)\n        return 0.0f;\n    return (float)sqrt(d);\n}\n\n// ~~~~~~~ raymarching_distance_fields_3\n// raymarching_distance_fields_3 is a slightly more efficient version of\n// raymarching_distance_fields.\n// ~~~~~~~ raymarching_distance_fields_3\n// basic concept from:\n// http://", "\n    vec3 n = normalize(oN);\n    vec3 nd = dot(n, p);\n    vec3 nd2 = dot(n, n);\n    vec3 nd3 = dot(n, nd);\n    vec3 nd4 = dot(n, nd2);\n    vec3 nd5 = dot(n, nd3);\n    vec3 nd6 = dot(n, nd4);\n    vec3 nd7 = dot(n, nd5);\n    vec3 nd8 = dot(n, nd6);\n    vec3 nd9 = dot(n, nd7);\n    vec3 nd10 = dot(n, nd8);\n    vec3 nd11 = dot(n, nd9);\n    vec3 nd12 = dot(n, nd10);\n    vec3 nd13 = dot(n, nd11);\n    vec3 nd14 = dot(n, nd12);\n    vec3 nd15 = dot(n, nd13);\n    vec3 nd16 = dot(n, nd14);\n    vec3 nd17 = dot(n, nd15);\n    vec3 nd18 = dot(n, nd16);\n    vec3 nd19 = dot(n, nd17);\n    vec3 nd20 = dot(n, nd18);\n    vec3 nd21 = dot(n, nd19);\n    vec3 nd22 = dot(n, nd20);\n    vec3 nd23 = dot(n, nd21);\n    vec3 nd24 = dot(n, nd22);\n    vec3 nd25 = dot(n, nd23);\n    vec3 nd26 = dot(n, nd24);\n    vec3 nd27 = dot(n, nd25);\n    vec3 nd28 = dot(n, nd26);\n    vec3 nd29 = dot(n, nd27);\n    vec3 nd30 = dot(n, nd28);\n    vec3 nd31 = dot(n, nd29);\n    vec3 nd32 = dot(", "\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    g.x = c.x;\n    g.y = c.y;\n    g.z = c.z;\n    g.a = 1.0;\n\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    d.x = c.x;\n    d.y = c.y;\n    d.z = c.z;\n    d.a = 1.0;\n\n    vec3 e = vec3(0.0, 0.0, 0.0);\n    e.x = c.x;\n    e.y = c.y;\n    e.z = c.z;\n    e.a = 1.0;\n\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    f.x = c.x;\n    f.y = c.y;\n    f.z = c.z;\n    f.a = 1.0;\n\n    vec3 g = g.x * d.x + g.y * d.y + g.z * d.z;\n    vec3 h = g.x * e.x + g.y * e.y + g.z * e.z;\n    vec3 i = g.x * f.x + g.y * f.y + g.z * f.z;\n    vec3 j = g.x * g.x + g.y * g.y + g.z * g.z;\n    vec3 k = g.x * g.x + g.y * g.y + g.z * g.z;\n\n    vec3 l = g.x * l.x + g.y * l.y + g.z * l.z;\n    vec3 m = g.x * m.x + g.y * m.y + g.z * m.z;\n    vec3 n = g.x * n.x + g.y * n.y + g.z * n.z;\n    vec3 o = g.x * o.x + g.y * o.y + g.z * o.", "\n    vec3 c_fog = c + (d * fs.x * fc1 + (1.0 - d) * fs.x * fc2);\n    vec3 c_fog_lerp = c_fog + (d * fs.y * fc1 + (1.0 - d) * fs.y * fc2);\n    vec3 c_fog_lerp_lerp = c_fog_lerp + (d * fs.z * fc1 + (1.0 - d) * fs.z * fc2);\n    return c_fog_lerp;\n}\n\nvec3 applyFog_l(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    vec3 c_fog = c + (d * fs.x * fc1 + (1.0 - d) * fs.x * fc2);\n    vec3 c_fog_lerp = c_fog + (d * fs.y * fc1 + (1.0 - d) * fs.y * fc2);\n    vec3 c_fog_lerp_lerp = c_fog_lerp + (d * fs.z * fc1 + (1.0 - d) * fs.z * fc2);\n    return c_fog_lerp_lerp;\n}\n\nvec3 applyFog_r(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    vec3 c_fog = c + (d * fs.x * fc1 + (1.0 - d) * fs.x * fc2);\n    vec3 c_fog_lerp = c_fog + (d * fs.y * fc1 + (1.0 - d) * fs.y * fc2);\n    vec3 c_fog_lerp_lerp = c_fog_lerp + (d * fs.z * fc1 + (1.0 - d) * fs.z * f", "\n    float attenuation = 0;\n    if (cF > 0)\n    {\n        if (lF > 0)\n        {\n            if (qF > 0)\n            {\n                attenuation = (cF * lF) / (lF * lF + qF * qF);\n            }\n            else\n            {\n                attenuation = (cF * lF) / (lF * lF);\n            }\n        }\n        else\n        {\n            if (qF > 0)\n            {\n                attenuation = (cF * lF) / (lF * lF + qF * qF);\n            }\n            else\n            {\n                attenuation = (cF * lF) / (lF * lF);\n            }\n        }\n    }\n    else\n    {\n        if (lF > 0)\n        {\n            if (qF > 0)\n            {\n                attenuation = (cF * lF) / (lF * lF + qF * qF);\n            }\n            else\n            {\n                attenuation = (cF * lF) / (lF * lF);\n            }\n        }\n        else\n        {\n            if (qF > 0)\n            {\n                attenuation = (cF * lF) / (lF * lF + qF * qF);\n            }\n            else\n            {\n                attenuation = (cF * lF) / (lF * lF);\n            }\n        }\n    }\n    return attenuation;\n}\n\nA:\n\nI think you are looking for the inverse square law.\nThe formula is:\nattenuation = cF * lF / (lF * lF + qF * qF)\n\nA:\n\nThe formula is:\nattenuation = cF * lF / (lF * lF + qF * qF)\n\nThe first term is the constant factor, the second term is the linear factor, and the third term is the quadratic factor.\n\nA:\n\nThe formula is:\nattenuation = cF * lF / (lF * lF + qF * qF)\n\nThe first", "\n    vec3 rayDir = cMatrix * vec2(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec2(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec2(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec2(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec2(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec2(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n", "\n    vec3 p = cPos - fCoord;\n    vec3 p1 = p.cross(cMat);\n    vec3 p2 = p.cross(cMat.cross(p1));\n    vec3 p3 = p.cross(cMat.cross(p2));\n    vec3 p4 = p.cross(cMat.cross(p3));\n    vec3 p5 = p.cross(cMat.cross(p4));\n    vec3 p6 = p.cross(cMat.cross(p5));\n    vec3 p7 = p.cross(cMat.cross(p6));\n    vec3 p8 = p.cross(cMat.cross(p7));\n    vec3 p9 = p.cross(cMat.cross(p8));\n    vec3 p10 = p.cross(cMat.cross(p9));\n    vec3 p11 = p.cross(cMat.cross(p10));\n    vec3 p12 = p.cross(cMat.cross(p11));\n    vec3 p13 = p.cross(cMat.cross(p12));\n    vec3 p14 = p.cross(cMat.cross(p13));\n    vec3 p15 = p.cross(cMat.cross(p14));\n    vec3 p16 = p.cross(cMat.cross(p15));\n    vec3 p17 = p.cross(cMat.cross(p16));\n    vec3 p18 = p.cross(cMat.cross(p17));\n    vec3 p19 = p.cross(cMat.cross(p18));\n    vec3 p20 = p.cross(cMat.cross(p19));\n    vec3 p21 = p.cross(cMat.cross(p20));\n    vec3 p22 = p.cross(cMat.cross(p21));\n    vec3 p23 = p.cross(cMat.cross(p22));\n    vec3 p24 = p.cross(cMat.cross(p23));\n    vec3 p25 = p.cross(cMat.cross(p24));\n    vec3 p26 = p.cross(cMat.cross(p25));\n    vec3 p27 = p.cross", "\n    vec2 fragCoord = fragCoord;\n    vec2 fragCoord2 = fragCoord;\n    vec2 fragCoord3 = fragCoord;\n    vec2 fragCoord4 = fragCoord;\n    vec2 fragCoord5 = fragCoord;\n    vec2 fragCoord6 = fragCoord;\n    vec2 fragCoord7 = fragCoord;\n    vec2 fragCoord8 = fragCoord;\n    vec2 fragCoord9 = fragCoord;\n    vec2 fragCoord10 = fragCoord;\n    vec2 fragCoord11 = fragCoord;\n    vec2 fragCoord12 = fragCoord;\n    vec2 fragCoord13 = fragCoord;\n    vec2 fragCoord14 = fragCoord;\n    vec2 fragCoord15 = fragCoord;\n    vec2 fragCoord16 = fragCoord;\n    vec2 fragCoord17 = fragCoord;\n    vec2 fragCoord18 = fragCoord;\n    vec2 fragCoord19 = fragCoord;\n    vec2 fragCoord20 = fragCoord;\n    vec2 fragCoord21 = fragCoord;\n    vec2 fragCoord22 = fragCoord;\n    vec2 fragCoord23 = fragCoord;\n    vec2 fragCoord24 = fragCoord;\n    vec2 fragCoord25 = fragCoord;\n    vec2 fragCoord26 = fragCoord;\n    vec2 fragCoord27 = fragCoord;\n    vec2 fragCoord28 = fragCoord;\n    vec2 fragCoord29 = fragCoord;\n    vec2 fragCoord30 = fragCoord;\n    vec2 fragCoord31 = fragCoord;\n    vec2 fragCoord32 = fragCoord;\n    vec2 fragCoord33 = fragCoord;\n    vec2 fragCoord34 = fragCoord;\n    vec2 fragCoord35 = fragCoord;\n    vec2 fragCoord36 = fragCoord;\n    vec2 fragCoord37 = fragCoord;\n    vec2 fragCoord38 = fragCoord;\n    vec2 fragCoord39 = fragCoord;\n    vec2 fragCo", "\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, vec3 radius)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// cube distance field\nfloat sdCube(vec3 p, vec3 radius)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 radius, vec3 height)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 radius, vec3 height)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// sphere-cone distance field\nfloat sdSphereCone(vec3 p, vec3 radius, vec3 height)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// cube-sphere distance field\nfloat sdCubeSphere(vec3 p, vec3 radius, vec3 height)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// cylinder-sphere distance field\nfloat sdCylinderSphere(vec3 p, vec3 radius, vec3 height)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// cone-sphere distance field\nfloat sdConeSphere(vec3 p, vec3 radius, vec3 height)\n{\n    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n// sphere-cone distance field\nfloat", "\n    return r * r;\n}\n\n// simple cylinder volume field\nfloat vol(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r * cyl(p, r);\n}\n\n// simple cylinder volume field\nfloat v(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r * cyl(p, r);\n}\n\n// simple cylinder volume field\nfloat v(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r * cyl(p, r);\n}\n\n// simple cylinder volume field\nfloat v(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r * cyl(p, r);\n}\n\n// simple cylinder volume field\nfloat v(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r * cyl(p, r);\n}\n\n// simple cylinder volume field\nfloat v(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r * cyl(p, r);\n}\n\n// simple cylinder volume field\nfloat v(vec2 p, float r)\n{\n    return r * r * r;\n}\n\n// simple cylinder surface area field\nfloat sa(vec2 p, float r)\n{\n    return 2 * r * r + 2 * r *", "\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface2(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface3(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface4(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface5(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface6(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This is the function that makes the geometry\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToSurface7(vec3 p)\n{\n    vec2 d = p - self.position;\n    return d;\n}\n\n// This", "\n    vec2 temp;\n    temp.x = c.x * c.x;\n    temp.y = c.y * c.y;\n    temp.z = c.z * c.z;\n    temp.w = c.w * c.w;\n    temp.x = temp.x * c.x;\n    temp.y = temp.y * c.y;\n    temp.z = temp.z * c.z;\n    temp.w = temp.w * c.w;\n    return temp;\n}\n\nint main()\n{\n    vec2 a = vec2(1, 2, 3);\n    vec2 b = vec2(4, 5, 6);\n    vec2 c = vec2(7, 8, 9);\n    vec2 d = vec2(10, 11, 12);\n    vec2 e = vec2(13, 14, 15);\n    vec2 f = vec2(16, 17, 18);\n    vec2 g = vec2(19, 20, 21);\n    vec2 h = vec2(22, 23, 24);\n    vec2 i = vec2(25, 26, 27);\n    vec2 j = vec2(28, 29, 30);\n    vec2 k = vec2(31, 32, 33);\n    vec2 l = vec2(34, 35, 36);\n    vec2 m = vec2(37, 38, 39);\n    vec2 n = vec2(40, 41, 42);\n    vec2 o = vec2(43, 44, 45);\n    vec2 p = vec2(46, 47, 48);\n    vec2 q = vec2(49, 50, 51);\n    vec2 r = vec2(52, 53, 54);\n    vec2 s = vec2(55, 56, 57);\n    vec2 t = vec2(58, 59, 60);\n    vec2 u = vec2(61, 62, 63);\n    vec2 v = vec2(64, 65, 66);\n    vec2 w = vec2(67, 68, 69);\n    vec2 x = vec2(70, 71, 72);\n    vec2 y = vec2(73, 74, 75);\n    vec2 z", "\n    vec2 coord2 = coord + morphConstant;\n    vec2 coord3 = coord2 + vec2(0.5, 0.5);\n    vec2 coord4 = coord3 + vec2(0.5, 0.5);\n    vec2 coord5 = coord4 + vec2(0.5, 0.5);\n    vec2 coord6 = coord5 + vec2(0.5, 0.5);\n    vec2 coord7 = coord6 + vec2(0.5, 0.5);\n    vec2 coord8 = coord7 + vec2(0.5, 0.5);\n    vec2 coord9 = coord8 + vec2(0.5, 0.5);\n    vec2 coord10 = coord9 + vec2(0.5, 0.5);\n    vec2 coord11 = coord10 + vec2(0.5, 0.5);\n    vec2 coord12 = coord11 + vec2(0.5, 0.5);\n    vec2 coord13 = coord12 + vec2(0.5, 0.5);\n    vec2 coord14 = coord13 + vec2(0.5, 0.5);\n    vec2 coord15 = coord14 + vec2(0.5, 0.5);\n    vec2 coord16 = coord15 + vec2(0.5, 0.5);\n    vec2 coord17 = coord16 + vec2(0.5, 0.5);\n    vec2 coord18 = coord17 + vec2(0.5, 0.5);\n    vec2 coord19 = coord18 + vec2(0.5, 0.5);\n    vec2 coord20 = coord19 + vec2(0.5, 0.5);\n    vec2 coord21 = coord20 + vec2(0.5, 0.5);\n    vec2 coord22 = coord21 + vec2(0.5, 0.5);\n    vec2 coord23 = coord22 + vec2(0.5, 0.5);\n    vec2 coord24 = coord23 + vec2(0.5, 0.5);\n    vec2 coord25 = coord24 + vec2(0.5, 0.5);\n    vec2 coord26 = coord25 + vec2(0.5", "\n    vec2 uv_new = uv;\n    uv_new.x = uv.x + constant.x;\n    uv_new.y = uv.y + constant.y;\n    return uv_new;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec2 uv_new = uv;\n    uv_new.x = uv.x - constant.x;\n    uv_new.y = uv.y - constant.y;\n    return uv_new;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec2 uv_new = uv;\n    uv_new.x = uv.x - constant.x;\n    uv_new.y = uv.y - constant.y;\n    return uv_new;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec2 uv_new = uv;\n    uv_new.x = uv.x + constant.x;\n    uv_new.y = uv.y + constant.y;\n    return uv_new;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec2 uv_new = uv;\n    uv_new.x = uv.x - constant.x;\n    uv_new.y = uv.y - constant.y;\n    return uv_new;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec2 uv_new = uv;\n    uv_new.x = uv.x + constant.x;\n    uv_new.y = uv.y + constant.y;\n    return uv_new;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec2 uv_new = uv;\n    uv_new.x = uv.x - constant.x;\n    uv_new.y = uv.y - constant.y;\n    return u", "\n    return x * (1 - cos(2 * M_PI * x / T));\n}\n\n// This is the main function\nint main() {\n    int n = 10;\n    float x = 0;\n    float y = 0;\n    float z = 0;\n    float t = 0;\n    float t_max = 0;\n    float t_min = 0;\n    float t_step = 0;\n    float t_end = 0;\n    float t_end_min = 0;\n    float t_end_max = 0;\n    float t_end_min_max = 0;\n    float t_end_min_max_max = 0;\n    float t_end_min_max_max_max = 0;\n    float t_end_min_max_max_max_max = 0;\n    float t_end_min_max_max_max_max_max = 0;\n    float t_end_min_max_max_max_max_max_max = 0;\n    float t_end_min_max_max_max_max_max_max_max = 0;\n    float t_end_min_max_max_max_max_max_max_max_max_max = 0;\n    float t_end_min_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n    float t_end_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_", "\n    float x = pA.x - pB.x;\n    float y = pA.y - pB.y;\n    float d = sqrt(x*x + y*y);\n    float d2 = d*d;\n    float d3 = d*d*d;\n    float d4 = d*d*d*d;\n    float d5 = d*d*d*d*d;\n    float d6 = d*d*d*d*d*d;\n    float d7 = d*d*d*d*d*d*d;\n    float d8 = d*d*d*d*d*d*d*d;\n    float d9 = d*d*d*d*d*d*d*d*d;\n    float d10 = d*d*d*d*d*d*d*d*d*d;\n    float d11 = d*d*d*d*d*d*d*d*d*d*d;\n    float d12 = d*d*d*d*d*d*d*d*d*d*d*d;\n    float d13 = d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d14 = d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d15 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d16 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d17 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d18 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    ", "\n    float pA_x = pA.x;\n    float pA_y = pA.y;\n    float pB_x = pB.x;\n    float pB_y = pB.y;\n    float pA_r = pA.r;\n    float pB_r = pB.r;\n    float pA_c = pA.c;\n    float pB_c = pB.c;\n    float pA_h = pA.h;\n    float pB_h = pB.h;\n    float pA_w = pA.w;\n    float pB_w = pB.w;\n    float pA_r_pix = pA_r / pA_w;\n    float pB_r_pix = pB_r / pB_w;\n    float pA_c_pix = pA_c / pA_h;\n    float pB_c_pix = pB_c / pB_h;\n    float pA_h_pix = pA_h / pA_w;\n    float pB_h_pix = pB_h / pB_w;\n    float pA_w_pix = pA_w / pA_h;\n    float pB_w_pix = pB_w / pB_h;\n    float pA_r_pix_pix = pA_r_pix * pA_w_pix;\n    float pB_r_pix_pix = pB_r_pix * pB_w_pix;\n    float pA_c_pix_pix = pA_c_pix * pA_h_pix;\n    float pB_c_pix_pix = pB_c_pix * pB_h_pix;\n    float pA_h_pix_pix_pix = pA_h_pix * pA_w_pix;\n    float pB_h_pix_pix_pix = pB_h_pix * pB_w_pix;\n    ", "\n    float x = pA.x - pB.x;\n    float y = pA.y - pB.y;\n    float dx = x * thick;\n    float dy = y * thick;\n    float r = sqrt(dx * dx + dy * dy);\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r;\n    float r40 = r39 * r;\n    float r41 = r40 * r;\n    float r42 = r41 *", "\n    float u = pA.x - pB.x;\n    float v = pA.y - pB.y;\n    float d = sqrt(u*u + v*v);\n    float t = d / thick;\n    if (t < 0.0f) {\n        t = 0.0f;\n    }\n    if (t > 1.0f) {\n        t = 1.0f;\n    }\n    float uv_t = t * u + (1.0f - t) * v;\n    float uv_t_rounded = round(uv_t);\n    if (uv_t_rounded < 0.0f) {\n        uv_t_rounded = 0.0f;\n    }\n    if (uv_t_rounded > 1.0f) {\n        uv_t_rounded = 1.0f;\n    }\n    return uv_t_rounded;\n}\n\nA:\n\nI think you are looking for the following:\nfloat GetLine(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float x5, float y5, float x6, float y6, float x7, float y7, float x8, float y8, float x9, float y9, float x10, float y10, float x11, float y11, float x12, float y12, float x13, float y13, float x14, float y14, float x15, float y15, float x16, float y16, float x17, float y17, float x18, float y18, float x19, float y19, float x20, float y20, float x21, float y21, float x22, float y22, float x23, float y23, float x24, float y24, float x25, float y25, float x26, float y26, float x27, float y27, float x28, float y28, float x29, float y29, float x30, float y30, float x31, float y31, float x32, float y32, float x33, float y33, float x34, float y34, float x", "\n    float uv_thick = thickness * rounded;\n    float uv_thick_pA = thickness * pA;\n    float uv_thick_pB = thickness * pB;\n    float uv_thick_pA_pB = thickness * pA + thickness * pB;\n    float uv_thick_pA_pA = thickness * pA + thickness * pA;\n    float uv_thick_pB_pB = thickness * pB + thickness * pB;\n    float uv_thick_pA_pA_pB = thickness * pA + thickness * pA + thickness * pB;\n    float uv_thick_pA_pB_pB = thickness * pA + thickness * pB + thickness * pB;\n    float uv_thick_pB_pB_pB = thickness * pB + thickness * pB + thickness * pB;\n    float uv_thick_pA_pA_pA_pB = thickness * pA + thickness * pA + thickness * pA + thickness * pA;\n    float uv_thick_pA_pA_pB_pB = thickness * pA + thickness * pA + thickness * pA + thickness * pA;\n    float uv_thick_pB_pB_pB_pB = thickness * pB + thickness * pB + thickness * pB + thickness * pB;\n    float uv_thick_pA_pA_pB_pB_pB = thickness * pA + thickness * pA + thickness * pA + thickness * pA + thickness * pA;\n    float uv_thick_pA_pA_pB_pB_pB_pB = thickness * pA + thickness * pA + thickness * pA + thickness * pA + thickness * pA;\n    float uv_thick_pB_pB_pB_pB_pB_pB = thickness * pB + thickness * pB + thickness * pB + thickness * pB + thickness * pB;\n    float uv_thick_pA_pA_", "\n    float uvOutline = 0.0f;\n    if (pA.x < pB.x) {\n        uvOutline = (float)((pB.x - pA.x) / (pB.x - pA.x + rounded));\n    } else {\n        uvOutline = (float)((pA.x - pB.x) / (pA.x - pB.x - rounded));\n    }\n    if (pA.y < pB.y) {\n        uvOutline = (float)((pB.y - pA.y) / (pB.y - pA.y + rounded));\n    } else {\n        uvOutline = (float)((pA.y - pB.y) / (pA.y - pB.y - rounded));\n    }\n    if (uvOutline < 0.0f) {\n        uvOutline = 0.0f;\n    }\n    if (uvOutline > 1.0f) {\n        uvOutline = 1.0f;\n    }\n    return uvOutline;\n}\n\nA:\n\nI think you're looking for the following:\nfloat GetOutline(float x, float y, float width, float height, float rounded, float outlineThick)\n{\n    float uvOutline = 0.0f;\n    if (x < width) {\n        uvOutline = (float)((x - width) / (width - rounded));\n    } else {\n        uvOutline = (float)((width - x) / (width - rounded));\n    }\n    if (y < height) {\n        uvOutline = (float)((y - height) / (height - rounded));\n    } else {\n        uvOutline = (float)((height - y) / (height - rounded));\n    }\n    if (uvOutline < 0.0f) {\n        uvOutline = 0.0f;\n    }\n    if (uvOutline > 1.0f) {\n        uvOutline = 1.0f;\n    }\n    return uvOutline;\n}\n\nA:\n\nI think you're looking for the following:", "\n    vec3 p_uv = p - uv;\n    col = vec3(0.0, 0.0, 0.0);\n    col += p_uv;\n    gl_Position = vec4(uv, 1.0);\n}\n\nvoid main() {\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n    glEnable(GL_LIGHT1);\n    glEnable(GL_LIGHT2);\n    glEnable(GL_LIGHT3);\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, 1.0, 0.1, 100.0);\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n\n    glEnable(GL_LIGHT0);\n    glEnable(GL_LIGHT1);\n    glEnable(GL_LIGHT2);\n    glEnable(GL_LIGHT3);\n\n    glEnable(GL_LIGHT0_POSITION);\n    glEnable(GL_LIGHT1_POSITION);\n    glEnable(GL_LIGHT2_POSITION);\n    glEnable(GL_LIGHT3_POSITION);\n\n    glEnable(GL_LIGHT0_COLOR);\n    glEnable(GL_LIGHT1_COLOR);\n    glEnable(GL_LIGHT2_COLOR);\n    glEnable(GL_LIGHT3_COLOR);\n\n    glEnable(GL_LIGHT0_DIFFUSE);\n    glEnable(GL_LIGHT1_DIFFUSE);\n    glEnable(GL_LIGHT2_DIFFUSE);\n    glEnable(GL_LIGHT3_DIFFUSE);\n\n    glEnable(GL_LIGHT0_SPECULAR);\n    glEnable(GL_LIGHT1_SPECULAR);\n    glEnable(GL_LIGHT2_SPECULAR);\n    glEnable(GL_LIGHT3_SPECULAR);\n\n    glEnable(GL_LIGHT0_NORMALIZE);\n    glEnable(GL_LIGHT1_NORMALIZE);\n    glEnable(GL_LIGHT2_NORMALIZE);\n    glEnable(GL", "\n    float d = dot( rd - cen, nor );\n    if ( d < 0.0 ) return 0.0;\n    float t = ( rad - d ) / d;\n    return t * t;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, float rad )\n{\n    float d = dot( p - ro, n );\n    if ( d < 0.0 ) return 0.0;\n    float t = ( rad - d ) / d;\n    return t * t;\n}\n\n// ray-ray intersection\nfloat iRay( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, float rad )\n{\n    float d = dot( p - ro, n );\n    if ( d < 0.0 ) return 0.0;\n    float t = ( rad - d ) / d;\n    return t * t;\n}\n\n// ray-ray intersection\nfloat iRayRay( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, float rad )\n{\n    float d = dot( p - ro, n );\n    if ( d < 0.0 ) return 0.0;\n    float t = ( rad - d ) / d;\n    return t * t;\n}\n\n// ray-ray intersection\nfloat iRayRayRay( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, float rad )\n{\n    float d = dot( p - ro, n );\n    if ( d < 0.0 ) return 0.0;\n    float t = ( rad - d ) / d;\n    return t * t;\n}\n\n// ray-ray intersection\nfloat iRayRayRayRay( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, float rad )\n{\n    float d = dot( p - ro, n );\n    if ( d < 0.0 ) return 0.0;\n    float t = ( rad - d ) / d;\n    return t * t;\n}\n\n// ray-ray intersection\nfloat iRayRayRay", "\n    vec2 i = (rd - cen).cross(ro - cen);\n    return i / (i.length() - rad.length() - rad.dot(i));\n}\n\nvec3 ray_box( in vec3 p, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6, in vec3 p7, in vec3 p8, in vec3 p9, in vec3 p10, in vec3 p11, in vec3 p12, in vec3 p13, in vec3 p14, in vec3 p15, in vec3 p16, in vec3 p17, in vec3 p18, in vec3 p19, in vec3 p20, in vec3 p21, in vec3 p22, in vec3 p23, in vec3 p24, in vec3 p25, in vec3 p26, in vec3 p27, in vec3 p28, in vec3 p29, in vec3 p30, in vec3 p31, in vec3 p32, in vec3 p33, in vec3 p34, in vec3 p35, in vec3 p36, in vec3 p37, in vec3 p38, in vec3 p39, in vec3 p40, in vec3 p41, in vec3 p42, in vec3 p43, in vec3 p44, in vec3 p45, in vec3 p46, in vec3 p47, in vec3 p48, in vec3 p49, in vec3 p50, in vec3 p51, in vec3 p52, in vec3 p53, in vec3 p54, in vec3 p55, in vec3 p56, in vec3 p57, in vec3 p58, in vec3 p59, in vec3 p60, in vec3 p61, in vec3 p62, in vec3 p63, in vec3 p64, in vec3 p65, in vec3 p66, in vec3 p67, in vec3 p68, in vec3 p69, in vec3 p70, in vec3 p71, in vec3 p72, in vec3 p73, in vec3 p74, in vec3 p75,", "\n    // calculate the radius of the cylinder\n    float r = sqrt( (pa.x - pb.x) * (pa.x - pb.x) + (pa.y - pb.y) * (pa.y - pb.y) + (pa.z - pb.z) * (pa.z - pb.z) );\n\n    // calculate the center of the cylinder\n    vec3 c = pa + (pb - pa) / 2.0;\n\n    // calculate the bounding box\n    vec3 b = CylinderAABB( pa, pb, ra );\n\n    // calculate the bounding box for the cylinder\n    vec3 a = CylinderAABB( c, pb, ra );\n\n    // return the bounding box\n    return a + b - c;\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    // calculate the radius of the sphere\n    float r = sqrt( (pa.x - pb.x) * (pa.x - pb.x) + (pa.y - pb.y) * (pa.y - pb.y) + (pa.z - pb.z) * (pa.z - pb.z) );\n\n    // calculate the center of the sphere\n    vec3 c = pa + (pb - pa) / 2.0;\n\n    // calculate the bounding box\n    vec3 b = SphereAABB( pa, pb, ra );\n\n    // calculate the bounding box for the sphere\n    vec3 a = SphereAABB( c, pb, ra );\n\n    // return the bounding box\n    return a + b - c;\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    // calculate the radius of the cone", "\n    vec3 p = pb - rd;\n    vec3 n = cross(pa - rd, p);\n    vec3 t = cross(n, p);\n    return t + ra * n;\n}\n\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cylinder intersection (returns t and normal)\nvec3 ray_cylinder( in vec3 p, in vec3 rd, in vec3 pa, in vec3 pb, in float ra ) // ray-cyl", "\n    vec2 i = (rd - cen).cross(ro - cen);\n    return i / (i.length() - rad.length() - rad.dot(rd - cen));\n}\n\nvec3 ray_box( in vec3 p, in vec3 r, in vec3 c, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 i = ray_box_intersection( p, r, c, rd, cen, rad );\n    return i;\n}\n\nvec3 ray_box_intersection( in vec3 p, in vec3 r, in vec3 c, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 i = ray_box_intersection_vector( p, r, c, rd, cen, rad );\n    return i;\n}\n\nvec3 ray_box_intersection_vector( in vec3 p, in vec3 r, in vec3 c, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 i = ray_box_intersection_vector_vector( p, r, c, rd, cen, rad );\n    return i;\n}\n\nvec3 ray_box_intersection_vector_vector( in vec3 p, in vec3 r, in vec3 c, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 i = ray_box_intersection_vector_vector_vector( p, r, c, rd, cen, rad );\n    return i;\n}\n\nvec3 ray_box_intersection_vector_vector_vector( in vec3 p, in vec3 r, in vec3 c, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 i = ray_box_intersection_vector_vector_vector_vector( p, r, c, rd, cen, rad );\n    return i;\n}\n\nvec3 ray_box_intersection_vector_vector_vector_vector( in vec3 p, in vec3 r, in vec3 c, in vec3", "\n    vec3 p = (pa - rd).normalize();\n    vec3 q = (pb - rd).normalize();\n    vec3 r = (r - rd).normalize();\n    float d = p.dot(q);\n    if (d < 0.0f)\n        return 0.0f;\n    float t = p.dot(r);\n    if (t < 0.0f)\n        return 0.0f;\n    float u = p.dot(q);\n    if (u < 0.0f)\n        return 0.0f;\n    float v = p.dot(r);\n    if (v < 0.0f)\n        return 0.0f;\n    float w = p.dot(q);\n    if (w < 0.0f)\n        return 0.0f;\n    float x = p.dot(r);\n    if (x < 0.0f)\n        return 0.0f;\n    float y = p.dot(q);\n    if (y < 0.0f)\n        return 0.0f;\n    float z = p.dot(r);\n    if (z < 0.0f)\n        return 0.0f;\n    return (d + t + u + v + w + x + y + z) / 6.0f;\n}\n\nA:\n\nI think you are looking for the intersection of two lines.\nThe lines are defined by two points, and the intersection is the point where the two lines meet.\nThe point where the two lines meet is the point where the two lines are parallel.\nThe point where the two lines meet is the point where the two lines are perpendicular.\nThe point where the two lines meet is the point where the two lines are parallel and perpendicular.\nThe point where the two lines meet is the point where the two lines are parallel and perpendicular.\nThe point where the two lines meet is the point where the two lines are parallel and perpendicular.\nThe point where the two lines meet is the point where the two lines are parallel and perpendicular.\nThe point where the two lines meet is the point where the two lines are parallel and perpendicular.\nThe point where the two lines meet is the point where the two lines are parallel and perpendicular.\nThe point where", "\n    vec3 n = a - b;\n    n.normalize();\n    return n;\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 cross( in vec3 a, in vec3 b )\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec3 dot( in vec3 a, in vec3 b )\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( in vec3 v )\n{\n    return v / length( v );\n}\n\n", "\n    vec2 i = {0,0};\n    i.x = (rd.x - ro.x) * rad.x + (rd.y - ro.y) * rad.y;\n    i.y = (rd.z - ro.z) * rad.z + (rd.w - ro.w) * rad.w;\n    return i;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 rb ) \n{\n    vec2 i = {0,0};\n    i.x = (rd.x - ro.x) * rad.x + (rd.y - ro.y) * rad.y + (rd.z - ro.z) * rad.z;\n    i.y = (rd.w - ro.w) * rad.w + (rd.z - ro.z) * rad.z + (rd.y - ro.y) * rad.y;\n    return i;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 rb, in vec3 rb2 ) \n{\n    vec2 i = {0,0};\n    i.x = (rd.x - ro.x) * rad.x + (rd.y - ro.y) * rad.y + (rd.z - ro.z) * rad.z + (rd.w - ro.w) * rad.w + (rd.z - ro.z) * rad.z + (rd.y - ro.y) * rad.y;\n    i.y = (rd.w - ro.w) * rad.w + (rd.z - ro.z) * rad.z + (rd.y - ro.y) * rad.y + (rd.x - ro.x) * rad.x + (rd.z - ro.z) * rad.z + (rd.y - ro.y) * rad.y;\n    return i;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 r", "\n    vec3 p = rd - ro;\n    vec3 q = -rd + ro;\n    vec3 r = p + q;\n    return p + q;\n}\n\nvec3 intersect( in vec3 p, in vec3 q, in vec3 r )\n{\n    vec3 p1 = p - q;\n    vec3 p2 = p - r;\n    vec3 p3 = q - r;\n    vec3 p4 = q - p;\n    vec3 p5 = p - q;\n    vec3 p6 = p - r;\n    vec3 p7 = q - r;\n    vec3 p8 = q - p;\n    vec3 p9 = p - q;\n    vec3 p10 = p - r;\n    vec3 p11 = q - r;\n    vec3 p12 = q - p;\n    vec3 p13 = p - q;\n    vec3 p14 = q - p;\n    vec3 p15 = p - r;\n    vec3 p16 = q - r;\n    vec3 p17 = q - p;\n    vec3 p18 = p - q;\n    vec3 p19 = q - p;\n    vec3 p20 = p - r;\n    vec3 p21 = q - r;\n    vec3 p22 = q - p;\n    vec3 p23 = q - p;\n    vec3 p24 = q - r;\n    vec3 p25 = p - q;\n    vec3 p26 = p - r;\n    vec3 p27 = q - r;\n    vec3 p28 = q - p;\n    vec3 p29 = p - q;\n    vec3 p30 = q - p;\n    vec3 p31 = p - r;\n    vec3 p32 = q - r;\n    vec3 p33 = q - p;\n    vec3 p34 = q - p;\n    vec3 p35 = q - r;\n    vec3 p36 = q - p;\n    vec3 p37 = q - p;\n    vec3 p38 = q - p;\n    vec3 p39 = q - p;\n    vec3 p40 = q - p;\n    vec3 p41 = q", "\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    f.x = 1.0 - cosf(i / n);\n    f.y = 1.0 - sindf(i / n);\n    f.z = 1.0 - cosf(2.0 * i / n);\n    return f;\n}\n\nvec3 backwardSF( float i, float n) \n{\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    f.x = 1.0 - cosf(i / n);\n    f.y = 1.0 - sindf(i / n);\n    f.z = 1.0 - cosf(2.0 * i / n);\n    return f;\n}\n\nvec3 normalSF( float i, float n) \n{\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    f.x = 1.0 - cosf(i / n);\n    f.y = 1.0 - sindf(i / n);\n    f.z = 1.0 - cosf(2.0 * i / n);\n    return f;\n}\n\nvec3 rotateSF( vec3 f, vec3 g, vec3 h) \n{\n    vec3 fg = f.cross(g);\n    vec3 fh = f.cross(h);\n    vec3 fg2 = fg.cross(fg);\n    vec3 fh2 = fh.cross(h);\n    vec3 fg3 = fg.cross(fg2);\n    vec3 fh3 = fh.cross(fh2);\n    vec3 fg4 = fg.cross(fg3);\n    vec3 fh4 = fh.cross(fh3);\n    vec3 fg5 = fg.cross(fg4);\n    vec3 fh5 = fh.cross(fh4);\n    vec3 fg6 = fg.cross(fg5);\n    vec3 fh6 = fh.cross(fh5);\n    vec3 fg7 = fg.cross(fg6);\n    ", "\n    vec3 p = rd - ro;\n    resS = mat3(0,0,0,1);\n    resS.x = p.x;\n    resS.y = p.y;\n    resS.z = p.z;\n    resS.w = 1;\n    return resS;\n}\n\nvec3 intersect( in vec3 rd, in vec3 rd1, in vec3 rd2, in vec3 rd3, in vec3 rd4, in vec3 rd5, in vec3 rd6, in vec3 rd7, in vec3 rd8, in vec3 rd9, in vec3 rd10, in vec3 rd11, in vec3 rd12, in vec3 rd13, in vec3 rd14, in vec3 rd15, in vec3 rd16, in vec3 rd17, in vec3 rd18, in vec3 rd19, in vec3 rd20, in vec3 rd21, in vec3 rd22, in vec3 rd23, in vec3 rd24, in vec3 rd25, in vec3 rd26, in vec3 rd27, in vec3 rd28, in vec3 rd29, in vec3 rd30, in vec3 rd31, in vec3 rd32, in vec3 rd33, in vec3 rd34, in vec3 rd35, in vec3 rd36, in vec3 rd37, in vec3 rd38, in vec3 rd39, in vec3 rd40, in vec3 rd41, in vec3 rd42, in vec3 rd43, in vec3 rd44, in vec3 rd45, in vec3 rd46, in vec3 rd47, in vec3 rd48, in vec3 rd49, in vec3 rd50, in vec3 rd51, in vec3 rd52, in vec3 rd53, in vec3 rd54, in vec3 rd55, in vec3 rd56, in vec3 rd57, in vec3 rd58, in vec3 rd59, in vec3 rd60, in vec3", "\n    vec3 v = vec3( p.x, p.y, p.z );\n    vec3 dv = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvz = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx2 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy2 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvz2 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx3 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy3 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvz3 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx4 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy4 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvz4 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx5 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy5 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvz5 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx6 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy6 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvz6 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvx7 = vec3( 0.0, 0.0, 0.0 );\n    vec3 dvy7 = vec3( 0.0, 0.0, 0.0", "\n    return sqrt(pow(p.x - size.x, 2) + pow(p.y - size.y, 2));\n}\n\nvec2 smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    vec2 p = p1 + p2;\n    p.x = p.x + (p.x - p1.x) * radius;\n    p.y = p.y + (p.y - p1.y) * radius;\n    return p;\n}\n\nvec2 smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    vec2 p = p1 + p2;\n    p.x = p.x + (p.x - p1.x) * radius;\n    p.y = p.y + (p.y - p1.y) * radius;\n    return p;\n}\n\nvec2 smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    vec2 p = p1 + p2;\n    p.x = p.x + (p.x - p1.x) * radius;\n    p.y = p.y + (p.y - p1.y) * radius;\n    return p;\n}\n\nvec2 smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    vec2 p = p1 + p2;\n    p.x = p.x + (p.x - p1.x) * radius;\n    p.y = p.y + (p.y - p1.y) * radius;\n    return p;\n}\n\nvec2 smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    vec2 p = p1 + p2;\n    p.x = p.x + (p.x - p1.x) * radius;\n    p.y = p.y + (p.y - p1.y) * radius;\n    return p;\n}\n\nvec2 smoothMerge(vec2 p1, vec2 p2, float radius)\n{\n    vec2 p = p1 + p2;\n    p", "\n    vec3 v = uv;\n    vec3 v1 = orient;\n    vec3 v2 = -orient;\n    vec3 v3 = -orient;\n    vec3 v4 = -orient;\n    vec3 v5 = -orient;\n    vec3 v6 = -orient;\n    vec3 v7 = -orient;\n    vec3 v8 = -orient;\n    vec3 v9 = -orient;\n    vec3 v10 = -orient;\n    vec3 v11 = -orient;\n    vec3 v12 = -orient;\n    vec3 v13 = -orient;\n    vec3 v14 = -orient;\n    vec3 v15 = -orient;\n    vec3 v16 = -orient;\n    vec3 v17 = -orient;\n    vec3 v18 = -orient;\n    vec3 v19 = -orient;\n    vec3 v20 = -orient;\n    vec3 v21 = -orient;\n    vec3 v22 = -orient;\n    vec3 v23 = -orient;\n    vec3 v24 = -orient;\n    vec3 v25 = -orient;\n    vec3 v26 = -orient;\n    vec3 v27 = -orient;\n    vec3 v28 = -orient;\n    vec3 v29 = -orient;\n    vec3 v30 = -orient;\n    vec3 v31 = -orient;\n    vec3 v32 = -orient;\n    vec3 v33 = -orient;\n    vec3 v34 = -orient;\n    vec3 v35 = -orient;\n    vec3 v36 = -orient;\n    vec3 v37 = -orient;\n    vec3 v38 = -orient;\n    vec3 v39 = -orient;\n    vec3 v40 = -orient;\n    vec3 v41 = -orient;\n    vec3 v42 = -orient;\n    vec3 v43 = -orient;\n    vec3 v44 = -orient;\n    vec3 v45 = -orient;\n    vec3 v46 = -orient;\n    vec3 v47 = -orient;\n    vec3 v48 = -orient;\n    vec3 v49 = -orient;\n    vec3 v50 = -orient;\n    vec3", "\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat8(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat9(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat10(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat11(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat12(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat13(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat14(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;\n}\n\nvec3 pat15(vec2 uv, vec2 orient)\n{\n    vec3 v = uv.cross(orient);\n    return v;", "\n    vec2 px = p + ddx;\n    vec2 py = p + ddy;\n    vec2 px2 = p + ddx * 2;\n    vec2 py2 = p + ddy * 2;\n    vec2 px3 = p + ddx * 3;\n    vec2 py3 = p + ddy * 3;\n    vec2 px4 = p + ddx * 4;\n    vec2 py4 = p + ddy * 4;\n    vec2 px5 = p + ddx * 5;\n    vec2 py5 = p + ddy * 5;\n    vec2 px6 = p + ddx * 6;\n    vec2 py6 = p + ddy * 6;\n    vec2 px7 = p + ddx * 7;\n    vec2 py7 = p + ddy * 7;\n    vec2 px8 = p + ddx * 8;\n    vec2 py8 = p + ddy * 8;\n    vec2 px9 = p + ddx * 9;\n    vec2 py9 = p + ddy * 9;\n    vec2 px10 = p + ddx * 10;\n    vec2 py10 = p + ddy * 10;\n    vec2 px11 = p + ddx * 11;\n    vec2 py11 = p + ddy * 11;\n    vec2 px12 = p + ddx * 12;\n    vec2 py12 = p + ddy * 12;\n    vec2 px13 = p + ddx * 13;\n    vec2 py13 = p + ddy * 13;\n    vec2 px14 = p + ddx * 14;\n    vec2 py14 = p + ddy * 14;\n    vec2 px15 = p + ddx * 15;\n    vec2 py15 = p + ddy * 15;\n    vec2 px16 = p + ddx * 16;\n    vec2 py16 = p + ddy * 16;\n    vec2 px17 = p + ddx * 17;\n    vec2 py17 = p + ddy * 17;\n    vec2 px18 = p + ddx * 18;\n    vec2 py18 = p + d", "\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    d.x = p.x - p.y;\n    d.y = p.z - p.x;\n    d.z = p.x - p.y;\n    return d;\n}\n\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    d.x = p.x - p.y;\n    d.y = p.z - p.x;\n    d.z = p.x - p.y;\n    return d;\n}\n\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    d.x = p.x - p.y;\n    d.y = p.z - p.x;\n    d.z = p.x - p.y;\n    return d;\n}\n\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    d.x = p.x - p.y;\n    d.y = p.z - p.x;\n    d.z = p.x - p.y;\n    return d;\n}\n\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    d.x = p.x - p.y;\n    d.y = p.z - p.x;\n    d.z = p.x - p.y;\n    return d;\n}\n\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    d.x = p.x - p.y;\n    d.y = p.z - p.x;\n    d.z = p.x - p.y;\n    return d;\n}\n\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3", "\n    v33 c = a;\n    for(int i = 0; i < 3; i++){\n        c[i] = b[i] - c[i]*a[i];\n    }\n}\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross", "\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv34 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv35 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv36 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv37 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv38 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv39 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv40 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv41 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv42 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv43 sub(vec3 a,vec3 b){\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\nv44 sub(vec3 a,vec3 b){\n    return vec3(", "\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n//", "\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 v33(vec3 a,vec3 b){\n    return a + b;\n}\n\nvec3 v33_dot(vec3 a,vec3 b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nvec3 v33_cross(vec3 a,vec3 b){\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 v33_cross_dot(vec3 a,vec3 b){\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 v33_cross_cross(vec3 a,vec3 b){\n    return a.x*b.z - a.y*b.z;\n}\n\nvec3 v33_cross_dot_dot(vec3 a,vec3 b){\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 v33_cross_cross_dot(vec3 a,vec3 b){\n    return a.x*b.z - a.y*b.z;\n}\n\nvec3 v33_cross_cross_cross(vec3 a,vec3 b){\n    return a.x*b.x - a.y*b.y - a.z*b.z;\n}\n\nvec3 v33_cross_cross_cross_dot(vec3 a,vec3 b){\n    return a.x*b.y - a.y*b.x - a.z*b.z;\n}\n\nvec3 v33_cross_cross_cross_cross(vec3 a,vec3 b){\n    return a.x*b.z - a.y*b.y - a.z*b.x;\n}\n\nvec3 v33_cross_cross_cross_cross_dot(vec3 a,vec3 b){\n    return a.x*b.y - a.y*b.x - a.z*b.z;\n}\n\nvec3 v33_cross_cross_", "\n    return a*b;\n}\n\nvec3 v33(vec3 a,vec3 b,vec3 c){\n    return a+b+c;\n}\n\nvec3 v33s(vec3 a,vec3 b,vec3 c,vec3 d){\n    return a+b+c+d;\n}\n\nvec3 v33d(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e){\n    return a+b+c+d+e;\n}\n\nvec3 v33d2(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f){\n    return a+b+c+d+e+f;\n}\n\nvec3 v33d3(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g){\n    return a+b+c+d+e+f+g;\n}\n\nvec3 v33d4(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h){\n    return a+b+c+d+e+f+g+h;\n}\n\nvec3 v33d5(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i){\n    return a+b+c+d+e+f+g+h+i;\n}\n\nvec3 v33d6(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i,vec3 j){\n    return a+b+c+d+e+f+g+h+i+j;\n}\n\nvec3 v33d7(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i,vec3 j,vec3 k){\n    return a+b+c+d+e+f+g+h+i+j+k;\n}\n\nvec", "\n    vec2 c = vec2(0,0);\n    c.x = a.x*b.x + a.y*b.y;\n    c.y = a.x*b.y + a.y*b.x;\n    return c;\n}\n\nvec2 dot(vec2 a,vec2 b){\n    return a.x*b.x + a.y*b.y;\n}\n\nvec2 cross(vec2 a,vec2 b){\n    vec2 c = vec2(0,0);\n    c.x = a.y*b.z - a.z*b.y;\n    c.y = a.z*b.x - a.x*b.z;\n    c.z = a.x*b.y - a.y*b.x;\n    return c;\n}\n\nvec2 normalize(vec2 a){\n    vec2 n = vec2(0,0,0);\n    n.x = a.x/sqrt(dot(a,a));\n    n.y = a.y/sqrt(dot(a,a));\n    n.z = a.z/sqrt(dot(a,a));\n    return n;\n}\n\nvec2 rotate(vec2 a,vec2 b,vec2 c){\n    vec2 d = cross(b,c);\n    vec2 e = normalize(cross(a,d));\n    vec2 f = normalize(cross(b,e));\n    vec2 g = normalize(cross(c,f));\n    return e*f*g;\n}\n\nvec2 translate(vec2 a,vec2 b){\n    vec2 c = vec2(0,0,0);\n    c.x = a.x + b.x;\n    c.y = a.y + b.y;\n    c.z = a.z + b.z;\n    return c;\n}\n\nvec2 rotate_around_axis(vec2 a,vec2 b,vec2 c,vec2 d,vec2 e,vec2 f,vec2 g,vec2 h,vec2 i,vec2 j,vec2 k,vec2 l,vec", "\n    return (p.x*w.x + p.y*w.y + p.z*w.z) > 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF3(vec3 p,vec3 w){\n    return (p.x*w.x + p.y*w.y + p.z*w.z) < 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF4(vec3 p,vec3 w){\n    return (p.x*w.x + p.y*w.y + p.z*w.z) > 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF5(vec3 p,vec3 w){\n    return (p.x*w.x + p.y*w.y + p.z*w.z) < 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF6(vec3 p,vec3 w){\n    return (p.x*w.x + p.y*w.y + p.z*w.z) > 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF7(vec3 p,vec3 w){\n    return (p.x*w.x + p.y*w.y + p.z*w.z) < 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF8(vec3 p,vec3 w){\n    return (p.x*w.x + p.y*w.y + p.z*w.z) > 0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF9(vec3 p,vec3 w){\n    return (p.x*w.x + p.y", "\n    vec3 a = p - w;\n    vec3 b = w - p;\n    vec3 c = p + w;\n    vec3 d = w + p;\n    vec3 e = p - w;\n    vec3 f = w - p;\n    vec3 g = p + w;\n    vec3 h = w + p;\n    vec3 i = p - w;\n    vec3 j = w - p;\n    vec3 k = p + w;\n    vec3 l = w + p;\n    vec3 m = p - w;\n    vec3 n = w - p;\n    vec3 o = p + w;\n    vec3 p1 = a + b;\n    vec3 p2 = c + d;\n    vec3 p3 = e + f;\n    vec3 p4 = g + h;\n    vec3 p5 = i + j;\n    vec3 p6 = k + l;\n    vec3 p7 = m + n;\n    vec3 p8 = o + p;\n    vec3 p9 = p1 + p2;\n    vec3 p10 = p3 + p4;\n    vec3 p11 = p5 + p6;\n    vec3 p12 = p7 + p8;\n    vec3 p13 = p9 + p10;\n    vec3 p14 = p11 + p12;\n    vec3 p15 = p13 + p14;\n    vec3 p16 = p15 + p14;\n    vec3 p17 = p16 + p14;\n    vec3 p18 = p17 + p14;\n    vec3 p19 = p18 + p14;\n    vec3 p20 = p19 + p14;\n    vec3 p21 = p20 + p14;\n    vec3 p22 = p21 + p14;\n    vec3 p23 = p22 + p14;\n    vec3 p24 = p23 + p14;\n    vec3 p25 = p24 + p14;\n    vec3 p26 = p25 + p14;\n    vec3 p27 = p26 + p14;\n    vec3 p28 = p27 + p14;\n    vec3 p29 = p28 + p14;\n", "\n    return (s.x*s.x + s.y*s.y + s.z*s.z + s.w*s.w) / (s.x*s.x + s.y*s.y + s.z*s.z + s.w*s.w);\n}\n\nfloat sssp(vec4 p,vec4 q){\n    return (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w) / (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w);\n}\n\nfloat sssp(vec4 p,vec4 q,vec4 r){\n    return (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w) / (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w);\n}\n\nfloat sssp(vec4 p,vec4 q,vec4 r,vec4 s){\n    return (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w) / (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w);\n}\n\nfloat sssp(vec4 p,vec4 q,vec4 r,vec4 s,vec4 t){\n    return (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w) / (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w);\n}\n\nfloat sssp(vec4 p,vec4 q,vec4 r,vec4 s,vec4 t,vec4 u){\n    return (p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w) /", "\n    vec3 v = n - u;\n    float r = sqrt(dot(v,v));\n    float d = dot(n,s);\n    float c = dot(v,s);\n    float t = d - c;\n    if(t < 0){\n        t = 0;\n    }\n    return t;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;\n}\n\nvec3 normalize(vec3 v){\n    vec3 n = normalize(v);\n    return n;", "\n    vec2 p = p1 - p0;\n    vec2 p2 = p2 - p0;\n    vec2 p3 = p - p2;\n    vec2 p4 = p - p3;\n    vec2 p5 = p - p4;\n    vec2 p6 = p - p5;\n    vec2 p7 = p - p6;\n    vec2 p8 = p - p7;\n    vec2 p9 = p - p8;\n    vec2 p10 = p - p9;\n    vec2 p11 = p - p10;\n    vec2 p12 = p - p11;\n    vec2 p13 = p - p12;\n    vec2 p14 = p - p13;\n    vec2 p15 = p - p14;\n    vec2 p16 = p - p15;\n    vec2 p17 = p - p16;\n    vec2 p18 = p - p17;\n    vec2 p19 = p - p18;\n    vec2 p20 = p - p19;\n    vec2 p21 = p - p20;\n    vec2 p22 = p - p21;\n    vec2 p23 = p - p22;\n    vec2 p24 = p - p23;\n    vec2 p25 = p - p24;\n    vec2 p26 = p - p25;\n    vec2 p27 = p - p26;\n    vec2 p28 = p - p27;\n    vec2 p29 = p - p28;\n    vec2 p30 = p - p29;\n    vec2 p31 = p - p30;\n    vec2 p32 = p - p31;\n    vec2 p33 = p - p32;\n    vec2 p34 = p - p33;\n    vec2 p35 = p - p34;\n    vec2 p36 = p - p35;\n    vec2 p37 = p - p36;\n    vec2 p38 = p - p37;\n    vec2 p39 = p - p38;\n    vec2 p40 = p - p39;\n    vec2 p41 = p - p40;\n    vec2 p42 = p - p41;\n    vec2 p43 =", "\n    vec2 p = p1 - p0;\n    vec2 p2 = p2 - p0;\n    vec2 p3 = p2 - p;\n    vec2 p4 = p - p0;\n    vec2 p5 = p - p1;\n    vec2 p6 = p - p2;\n    vec2 p7 = p - p3;\n    vec2 p8 = p - p4;\n    vec2 p9 = p - p5;\n    vec2 p10 = p - p6;\n    vec2 p11 = p - p7;\n    vec2 p12 = p - p8;\n    vec2 p13 = p - p9;\n    vec2 p14 = p - p10;\n    vec2 p15 = p - p11;\n    vec2 p16 = p - p12;\n    vec2 p17 = p - p13;\n    vec2 p18 = p - p14;\n    vec2 p19 = p - p15;\n    vec2 p20 = p - p16;\n    vec2 p21 = p - p17;\n    vec2 p22 = p - p18;\n    vec2 p23 = p - p19;\n    vec2 p24 = p - p20;\n    vec2 p25 = p - p21;\n    vec2 p26 = p - p22;\n    vec2 p27 = p - p23;\n    vec2 p28 = p - p24;\n    vec2 p29 = p - p25;\n    vec2 p30 = p - p26;\n    vec2 p31 = p - p27;\n    vec2 p32 = p - p28;\n    vec2 p33 = p - p29;\n    vec2 p34 = p - p30;\n    vec2 p35 = p - p31;\n    vec2 p36 = p - p32;\n    vec2 p37 = p - p33;\n    vec2 p38 = p - p34;\n    vec2 p39 = p - p35;\n    vec2 p40 = p - p36;\n    vec2 p41 = p - p37;\n    vec2 p42 = p - p38;\n    vec2 p43 =", "\n    vec3 a = p0 - p1;\n    vec3 b = p2 - p1;\n    vec3 c = p3 - p1;\n    vec3 d = p0 - p3;\n    vec3 e = p1 - p3;\n    vec3 f = p2 - p3;\n    vec3 g = p0 - p2;\n    vec3 h = p3 - p0;\n    vec3 i = p1 - p0;\n    vec3 j = p2 - p1;\n    vec3 k = p3 - p2;\n    vec3 l = p0 - p3;\n    vec3 m = p1 - p0;\n    vec3 n = p2 - p1;\n    vec3 o = p3 - p2;\n    vec3 p = p0 - p1;\n    vec3 q = p2 - p1;\n    vec3 r = p3 - p2;\n    vec3 s = p0 - p3;\n    vec3 t = p1 - p3;\n    vec3 u = p2 - p1;\n    vec3 v = p3 - p2;\n    vec3 w = p0 - p3;\n    vec3 x = p1 - p0;\n    vec3 y = p2 - p1;\n    vec3 z = p3 - p2;\n    vec3 ab = a + b;\n    vec3 bc = c + d;\n    vec3 cd = e + f;\n    vec3 de = g + h;\n    vec3 ef = i + j;\n    vec3 gf = k + l;\n    vec3 hf = m + n;\n    vec3 af = o + p;\n    vec3 bf = q + r;\n    vec3 cf = s + t;\n    vec3 df = u + v;\n    vec3 gf = w + x;\n    vec3 hf = y + z;\n    vec3 af = z + w;\n    vec3 bf = x + y;\n    vec3 cf = y + z;\n    vec3 df = z + w;\n    vec3 gf = x + z;\n    vec3 hf = y + z;\n", "\n    vec4 bbox = vec4(p0, p1, p2, p3);\n    vec2 p0p1 = p1 - p0;\n    vec2 p0p2 = p2 - p0;\n    vec2 p0p3 = p3 - p0;\n    vec2 p1p2 = p2 - p1;\n    vec2 p1p3 = p3 - p1;\n    vec2 p2p3 = p3 - p2;\n    vec2 p0p1p2 = p0 - p1;\n    vec2 p0p1p3 = p0 - p2;\n    vec2 p0p2p3 = p0 - p3;\n    vec2 p1p2p3 = p1 - p2;\n    vec2 p1p2p0 = p1 - p0;\n    vec2 p1p2p1 = p1 - p1;\n    vec2 p1p2p2 = p1 - p2;\n    vec2 p1p2p3 = p1 - p3;\n    vec2 p1p2p0 = p1 - p0;\n    vec2 p1p2p1 = p1 - p1;\n    vec2 p1p2p2 = p1 - p2;\n    vec2 p1p2p3 = p1 - p3;\n    vec2 p1p2p0 = p1 - p0;\n    vec2 p1p2p1 = p1 - p1;\n    vec2 p1p2p2 = p1 - p2;\n    vec2 p1p2p3 = p1 - p3;\n    vec2 p1p2p0 = p1 - p0;\n    vec2 p1p2p1 = p1 - p1;\n    vec2 p1p2p2 = p1 - p2;\n    vec2 p1p2p3 = p1 - p3;\n    vec2 p1p2p0 = p1 - p0;\n    vec2 p1p2p1 = p1 - p1;\n    vec2 p1p2p2 = p1 - p2;\n    vec2 p1p2p", "\n    vec2 ud = p3 - p0;\n    vec2 ud2 = p2 - p0;\n    vec2 ud3 = p1 - p0;\n    vec2 ud4 = p2 - p0;\n    vec2 ud5 = p3 - p0;\n    vec2 ud6 = p1 - p0;\n    vec2 ud7 = p2 - p0;\n    vec2 ud8 = p3 - p0;\n    vec2 ud9 = p1 - p0;\n    vec2 ud10 = p2 - p0;\n    vec2 ud11 = p3 - p0;\n    vec2 ud12 = p1 - p0;\n    vec2 ud13 = p2 - p0;\n    vec2 ud14 = p3 - p0;\n    vec2 ud15 = p1 - p0;\n    vec2 ud16 = p2 - p0;\n    vec2 ud17 = p3 - p0;\n    vec2 ud18 = p1 - p0;\n    vec2 ud19 = p2 - p0;\n    vec2 ud20 = p3 - p0;\n    vec2 ud21 = p1 - p0;\n    vec2 ud22 = p2 - p0;\n    vec2 ud23 = p3 - p0;\n    vec2 ud24 = p1 - p0;\n    vec2 ud25 = p2 - p0;\n    vec2 ud26 = p3 - p0;\n    vec2 ud27 = p1 - p0;\n    vec2 ud28 = p2 - p0;\n    vec2 ud29 = p3 - p0;\n    vec2 ud30 = p1 - p0;\n    vec2 ud31 = p2 - p0;\n    vec2 ud32 = p3 - p0;\n    vec2 ud33 = p1 - p0;\n    vec2 ud34 = p2 - p0;\n    vec2 ud35 = p3 - p0;\n    vec2 ud36 = p1 - p0;\n    vec2 ud37 = p", "\n    vec3 t = cross(rd - ro, v0 - ro);\n    vec3 u = cross(v1 - ro, v0 - ro);\n    vec3 v = cross(v2 - ro, v0 - ro);\n    return { t, u, v };\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 t = cross(rd - ro, v0 - ro);\n    vec3 u = cross(v1 - ro, v0 - ro);\n    vec3 v = cross(v2 - ro, v0 - ro);\n    return { t, u, v };\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 t = cross(rd - ro, v0 - ro);\n    vec3 u = cross(v1 - ro, v0 - ro);\n    vec3 v = cross(v2 - ro, v0 - ro);\n    return { t, u, v };\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 t = cross(rd - ro, v0 - ro);\n    vec3 u = cross(v1 - ro, v0 - ro);\n    vec3 v = cross(v2 - ro, v0 - ro);\n    return { t, u, v };\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 t = cross(rd - ro, v0 - ro);\n    vec3 u = cross(v1 - ro, v0 - ro);\n    vec3 v = cross(v2 - ro, v0 - ro);\n    return { t, u, v };\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1,", "\n    vec3 v = v0 + v1 + v2;\n    float triOcclusion = 0.0f;\n    if ( v.length() > 0.0f )\n    {\n        float triOcclusion = ( v.dot( nor ) - pos.dot( nor ) ) / ( v.length() - pos.length() );\n    }\n    return triOcclusion;\n}\n\n// Triangle intersection (if fully visible)\nfloat triIntersection( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v = v0 + v1 + v2;\n    float triIntersection = 0.0f;\n    if ( v.length() > 0.0f )\n    {\n        float triIntersection = ( v.dot( nor ) - pos.dot( nor ) ) / ( v.length() - pos.length() );\n    }\n    return triIntersection;\n}\n\n// Triangle intersection (if partially visible)\nfloat triIntersection( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v = v0 + v1 + v2;\n    float triIntersection = 0.0f;\n    if ( v.length() > 0.0f )\n    {\n        float triIntersection = ( v.dot( nor ) - pos.dot( nor ) ) / ( v.length() - pos.length() );\n    }\n    return triIntersection;\n}\n\n// Triangle intersection (if fully visible)\nfloat triIntersection( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v = v0 + v1 + v2;\n    float triIntersection = 0.0f;\n    if ( v.length() > 0.0f )\n    {\n        float triIntersection = ( v.dot( nor ) - pos.dot( nor ) ) / ( v.length() - pos.length() );\n    }\n    return triIntersection;\n}\n\n// Triangle intersection (if partially visible)\n", "\n    vec2 d = A - B;\n    vec2 e = B - C;\n    vec2 f = C - A;\n    float d2 = d.dot(d);\n    float e2 = e.dot(e);\n    float f2 = f.dot(f);\n    float d3 = d.dot(d);\n    float e3 = e.dot(e);\n    float f3 = f.dot(f);\n    float d4 = d.dot(d);\n    float e4 = e.dot(e);\n    float f4 = f.dot(f);\n    float d5 = d.dot(d);\n    float e5 = e.dot(e);\n    float f5 = f.dot(f);\n    float d6 = d.dot(d);\n    float e6 = e.dot(e);\n    float f6 = f.dot(f);\n    float d7 = d.dot(d);\n    float e7 = e.dot(e);\n    float f7 = f.dot(f);\n    float d8 = d.dot(d);\n    float e8 = e.dot(e);\n    float f8 = f.dot(f);\n    float d9 = d.dot(d);\n    float e9 = e.dot(e);\n    float f9 = f.dot(f);\n    float d10 = d.dot(d);\n    float e10 = e.dot(e);\n    float f10 = f.dot(f);\n    float d11 = d.dot(d);\n    float e11 = e.dot(e);\n    float f11 = f.dot(f);\n    float d12 = d.dot(d);\n    float e12 = e.dot(e);\n    float f12 = f.dot(f);\n    float d13 = d.dot(d);\n    float e13 = e.dot(e);\n    float f13 = f.dot(f);\n    float d14 = d.dot(d);\n    float e14 = e.dot(e);\n    float f14 = f.dot(f);\n    float d15 = d.dot(d);\n    ", "\n    float h = r2 - r1;\n    float s = (r1 + r2) / 2;\n    float d = sqrt( h * h + s * s );\n    float t = s / d;\n    return (t * he);\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float h = r2 - r1;\n    float s = (r1 + r2) / 2;\n    float d = sqrt( h * h + s * s );\n    float t = s / d;\n    return (t * he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float h = r2 - r1;\n    float s = (r1 + r2) / 2;\n    float d = sqrt( h * h + s * s );\n    float t = s / d;\n    return (t * he);\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float h = r2 - r1;\n    float s = (r1 + r2) / 2;\n    float d = sqrt( h * h + s * s );\n    float t = s / d;\n    return (t * he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float h = r2 - r1;\n    float s = (r1 + r2) / 2;\n    float d = sqrt( h * h + s * s );\n    float t = s / d;\n    return (t * he);\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    ", "\n    vec2 p1 = p - a;\n    vec2 p2 = p - b;\n    vec2 p3 = p - a;\n    vec2 p4 = p - b;\n    vec2 p5 = p - a;\n    vec2 p6 = p - b;\n    vec2 p7 = p - a;\n    vec2 p8 = p - b;\n    vec2 p9 = p - a;\n    vec2 p10 = p - b;\n    vec2 p11 = p - a;\n    vec2 p12 = p - b;\n    vec2 p13 = p - a;\n    vec2 p14 = p - b;\n    vec2 p15 = p - a;\n    vec2 p16 = p - b;\n    vec2 p17 = p - a;\n    vec2 p18 = p - b;\n    vec2 p19 = p - a;\n    vec2 p20 = p - b;\n    vec2 p21 = p - a;\n    vec2 p22 = p - b;\n    vec2 p23 = p - a;\n    vec2 p24 = p - b;\n    vec2 p25 = p - a;\n    vec2 p26 = p - b;\n    vec2 p27 = p - a;\n    vec2 p28 = p - b;\n    vec2 p29 = p - a;\n    vec2 p30 = p - b;\n    vec2 p31 = p - a;\n    vec2 p32 = p - b;\n    vec2 p33 = p - a;\n    vec2 p34 = p - b;\n    vec2 p35 = p - a;\n    vec2 p36 = p - b;\n    vec2 p37 = p - a;\n    vec2 p38 = p - b;\n    vec2 p39 = p - a;\n    vec2 p40 = p - b;\n    vec2 p41 = p - a;\n    vec2 p42 = p - b;\n    vec2 p43 = p - a;\n    vec2 p44 = p - b;\n    vec2 p45 = p - a;\n    vec2 p46 = p - b;\n    vec2 p47", "\n    vec3 n = normalize( cross( pos.xyz, vec3( 0.0, 0.0, 1.0 ) ) );\n    return n;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 v = n;\n    v.x /= sqrt( dot( n.xyz, n.xyz ) );\n    v.y /= sqrt( dot( n.xyz, n.xyz ) );\n    v.z /= sqrt( dot( n.xyz, n.xyz ) );\n    return v;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 v = n;\n    v.x /= sqrt( dot( n.xyz, n.xyz ) );\n    v.y /= sqrt( dot( n.xyz, n.xyz ) );\n    v.z /= sqrt( dot( n.xyz, n.xyz ) );\n    return v;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 v = n;\n    v.x /= sqrt( dot( n.xyz, n.xyz ) );\n    v.y /= sqrt( dot( n.xyz, n.xyz ) );\n    v.z /= sqrt( dot( n.xyz, n.xyz ) );\n    return v;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 v = n;\n    v.x /= sqrt( dot( n.xyz, n.xyz ) );\n    v.y /= sqrt( dot( n.xyz, n.xyz ) );\n    v.z /= sqrt( dot( n.xyz, n.xyz ) );\n    return v;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 v = n;\n    v.x /= sqrt( dot( n.xyz, n.xyz ) );\n    v.y /= sqrt( dot( n.xyz, n.xyz ) );\n    v.z /= sqrt( dot( n.xyz,", "\n    float s = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float sigma = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n    float tt = 0.0f;\n    float uu = 0.0f;\n    float vv = 0.0f;\n    float ww = 0.0f;\n    float xx = 0.0f;\n    float yy = 0.0f;\n    float zz = 0.0f;\n    float tt2 = 0.0f;\n    float uu2 = 0.0f;\n    float vv2 = 0.0f;\n    float ww2 = 0.0f;\n    float xx2 = 0.0f;\n    float yy2 = 0.0f;\n    float zz2 = 0.0f;\n    float tt3 = 0.0f;\n    float uu3 = 0.0f;\n    float vv3 = 0.0f;\n    float ww3 = 0.0f;\n    float xx3 = 0.0f;\n    float yy3 = 0.0f;\n    float zz3 = 0.0f;\n    float tt4 = 0.0f;\n    float uu4 = 0.0f;\n    ", "\n    return (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4] + q[5]*q[5] + q[6]*q[6] + q[7]*q[7] + q[8]*q[8] + q[9]*q[9] + q[10]*q[10] + q[11]*q[11] + q[12]*q[12] + q[13]*q[13] + q[14]*q[14] + q[15]*q[15] + q[16]*q[16] + q[17]*q[17] + q[18]*q[18] + q[19]*q[19] + q[20]*q[20] + q[21]*q[21] + q[22]*q[22] + q[23]*q[23] + q[24]*q[24] + q[25]*q[25] + q[26]*q[26] + q[27]*q[27] + q[28]*q[28] + q[29]*q[29] + q[30]*q[30] + q[31]*q[31] + q[32]*q[32] + q[33]*q[33] + q[34]*q[34] + q[35]*q[35] + q[36]*q[36] + q[37]*q[37] + q[38]*q[38] + q[39]*q[39] + q[40]*q[40] + q[41]*q[41] + q[42]*q[42] + q[43]*q[43] + q[44]*q[44] + q[45]*q[45] + q[46]*q[46] + q[47]*q[47] + q[48]*q[48] + q[49]*q[49] + q[50]*q[50", "\n    return ( float )( 1.0f - exp( -p * log( x.x ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.y ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.z ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.w ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vx ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vy ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vz ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vw ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vx ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vy ) ) );\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    return ( float )( 1.0f - exp( -p * log( x.vz ) ) );\n}", "\n    vec2 y = vec2( x.x, x.y );\n    vec2 z = vec2( x.x, x.y );\n    vec2 w = vec2( x.x, x.y );\n    vec2 u = vec2( x.x, x.y );\n    vec2 v = vec2( x.x, x.y );\n    vec2 w2 = vec2( x.x, x.y );\n    vec2 u2 = vec2( x.x, x.y );\n    vec2 v2 = vec2( x.x, x.y );\n    vec2 w3 = vec2( x.x, x.y );\n    vec2 u3 = vec2( x.x, x.y );\n    vec2 v3 = vec2( x.x, x.y );\n    vec2 w4 = vec2( x.x, x.y );\n    vec2 u4 = vec2( x.x, x.y );\n    vec2 v4 = vec2( x.x, x.y );\n    vec2 w5 = vec2( x.x, x.y );\n    vec2 u5 = vec2( x.x, x.y );\n    vec2 v5 = vec2( x.x, x.y );\n    vec2 w6 = vec2( x.x, x.y );\n    vec2 u6 = vec2( x.x, x.y );\n    vec2 v6 = vec2( x.x, x.y );\n    vec2 w7 = vec2( x.x, x.y );\n    vec2 u7 = vec2( x.x, x.y );\n    vec2 v7 = vec2( x.x, x.y );\n    vec2 w8 = vec2( x.x, x.y );\n    vec2 u8 = vec2( x.x, x.y );\n    vec2 v8 = vec2( x.x, x.y );\n    vec2 w9 = vec2( x.x, x.y );\n    vec2 u9 = vec2( x.x, x.y );\n    vec2 v9 = vec2( x.x", "\n    vec3 a = r - p;\n    vec3 b = p - r;\n    vec3 c = p + r;\n    vec3 d = p - r;\n    vec3 e = p + r;\n    vec3 f = p - r;\n    vec3 g = p + r;\n    vec3 h = p - r;\n    vec3 i = p + r;\n    vec3 j = p - r;\n    vec3 k = p + r;\n    vec3 l = p - r;\n    vec3 m = p + r;\n    vec3 n = p - r;\n    vec3 o = p + r;\n    vec3 p1 = a + b;\n    vec3 p2 = c + d;\n    vec3 p3 = e + f;\n    vec3 p4 = g + h;\n    vec3 p5 = i + j;\n    vec3 p6 = k + l;\n    vec3 p7 = m + n;\n    vec3 p8 = o + p;\n    vec3 p9 = p1 + p2;\n    vec3 p10 = p3 + p4;\n    vec3 p11 = p5 + p6;\n    vec3 p12 = p7 + p8;\n    vec3 p13 = p9 + p10;\n    vec3 p14 = p11 + p12;\n    vec3 p15 = p13 + p14;\n    vec3 p16 = p15 + p16;\n    vec3 p17 = p16 + p17;\n    vec3 p18 = p17 + p18;\n    vec3 p19 = p18 + p19;\n    vec3 p20 = p19 + p20;\n    vec3 p21 = p20 + p21;\n    vec3 p22 = p21 + p22;\n    vec3 p23 = p22 + p23;\n    vec3 p24 = p23 + p24;\n    vec3 p25 = p24 + p25;\n    vec3 p26 = p25 + p26;\n    vec3 p27 = p26 + p27;\n    vec3 p28 = p27 + p28;\n    vec3 p29 = p28 + p29;\n", "\n    vec3 p2 = p + r;\n    vec3 p3 = p - r;\n    vec3 p4 = p - p2;\n    vec3 p5 = p - p3;\n    vec3 p6 = p - p4;\n    vec3 p7 = p - p5;\n    vec3 p8 = p - p6;\n    vec3 p9 = p - p7;\n    vec3 p10 = p - p8;\n    vec3 p11 = p - p9;\n    vec3 p12 = p - p10;\n    vec3 p13 = p - p11;\n    vec3 p14 = p - p12;\n    vec3 p15 = p - p13;\n    vec3 p16 = p - p14;\n    vec3 p17 = p - p15;\n    vec3 p18 = p - p16;\n    vec3 p19 = p - p17;\n    vec3 p20 = p - p18;\n    vec3 p21 = p - p19;\n    vec3 p22 = p - p20;\n    vec3 p23 = p - p21;\n    vec3 p24 = p - p22;\n    vec3 p25 = p - p23;\n    vec3 p26 = p - p24;\n    vec3 p27 = p - p25;\n    vec3 p28 = p - p26;\n    vec3 p29 = p - p27;\n    vec3 p30 = p - p28;\n    vec3 p31 = p - p29;\n    vec3 p32 = p - p30;\n    vec3 p33 = p - p31;\n    vec3 p34 = p - p32;\n    vec3 p35 = p - p33;\n    vec3 p36 = p - p34;\n    vec3 p37 = p - p35;\n    vec3 p38 = p - p36;\n    vec3 p39 = p - p37;\n    vec3 p40 = p - p38;\n    vec3 p41 = p - p39;\n    vec3 p42 = p - p40;\n    vec3 p43 = p - p41;\n    vec3 p44 = p - p", "\n    vec3 p0 = p - r;\n    vec3 p1 = p + r;\n    vec3 p2 = p - r;\n    vec3 p3 = p + r;\n    vec3 p4 = p - r;\n    vec3 p5 = p + r;\n    vec3 p6 = p - r;\n    vec3 p7 = p + r;\n    vec3 p8 = p - r;\n    vec3 p9 = p + r;\n    vec3 p10 = p - r;\n    vec3 p11 = p + r;\n    vec3 p12 = p - r;\n    vec3 p13 = p + r;\n    vec3 p14 = p - r;\n    vec3 p15 = p + r;\n    vec3 p16 = p - r;\n    vec3 p17 = p + r;\n    vec3 p18 = p - r;\n    vec3 p19 = p + r;\n    vec3 p20 = p - r;\n    vec3 p21 = p + r;\n    vec3 p22 = p - r;\n    vec3 p23 = p + r;\n    vec3 p24 = p - r;\n    vec3 p25 = p + r;\n    vec3 p26 = p - r;\n    vec3 p27 = p + r;\n    vec3 p28 = p - r;\n    vec3 p29 = p + r;\n    vec3 p30 = p - r;\n    vec3 p31 = p + r;\n    vec3 p32 = p - r;\n    vec3 p33 = p + r;\n    vec3 p34 = p - r;\n    vec3 p35 = p + r;\n    vec3 p36 = p - r;\n    vec3 p37 = p + r;\n    vec3 p38 = p - r;\n    vec3 p39 = p + r;\n    vec3 p40 = p - r;\n    vec3 p41 = p + r;\n    vec3 p42 = p - r;\n    vec3 p43 = p + r;\n    vec3 p44 = p - r;\n    vec3 p45 = p + r;\n    vec3 p46", "\n    vec3 a = r - p;\n    vec3 b = p - r;\n    vec3 c = p + r;\n    vec3 d = p - r;\n    vec3 e = p + r;\n    vec3 f = p - r;\n    vec3 g = p + r;\n    vec3 h = p - r;\n    vec3 i = p + r;\n    vec3 j = p - r;\n    vec3 k = p + r;\n    vec3 l = p - r;\n    vec3 m = p + r;\n    vec3 n = p - r;\n    vec3 o = p + r;\n    vec3 p1 = a + b;\n    vec3 p2 = c + d;\n    vec3 p3 = e + f;\n    vec3 p4 = g + h;\n    vec3 p5 = i + j;\n    vec3 p6 = k + l;\n    vec3 p7 = m + n;\n    vec3 p8 = o + p;\n    vec3 p9 = p1 + p2;\n    vec3 p10 = p3 + p4;\n    vec3 p11 = p5 + p6;\n    vec3 p12 = p7 + p8;\n    vec3 p13 = p9 + p10;\n    vec3 p14 = p11 + p12;\n    vec3 p15 = p13 + p14;\n    vec3 p16 = p15 + p16;\n    vec3 p17 = p16 + p17;\n    vec3 p18 = p17 + p18;\n    vec3 p19 = p18 + p19;\n    vec3 p20 = p19 + p20;\n    vec3 p21 = p20 + p21;\n    vec3 p22 = p21 + p22;\n    vec3 p23 = p22 + p23;\n    vec3 p24 = p23 + p24;\n    vec3 p25 = p24 + p25;\n    vec3 p26 = p25 + p26;\n    vec3 p27 = p26 + p27;\n    vec3 p28 = p27 + p28;\n    vec3 p29 = p28 + p29;\n", "\n    float x = p.x;\n    float y = p.y;\n    float dx = x - p.x;\n    float dy = y - p.y;\n    float sx = x * x;\n    float sy = y * y;\n    float sxy = x * y;\n    float sxx = x * x;\n    float sxyy = x * y * y;\n    float sxyyy = x * y * y * y;\n    float sxxyy = x * x * x * x;\n    float sxxyyy = x * x * x * x * x;\n    float sxxyyyy = x * x * x * x * x * x;\n    float sxxyyyyy = x * x * x * x * x * x * x;\n    float sxxyyyyyy = x * x * x * x * x * x * x * x;\n    float sxxyyyyyyy = x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x;\n    float sxxyyyyyyyy = x * x * x * x * x * x * x *", "\n    return a + (x - a) * 0.5f;\n}\n\nint main( int argc, char *argv[] )\n{\n    int n = atoi( argv[1] );\n    float x = atof( argv[2] );\n    float y = atof( argv[3] );\n    float z = atof( argv[4] );\n    float a = atof( argv[5] );\n    float b = atof( argv[6] );\n    float c = atof( argv[7] );\n    float d = atof( argv[8] );\n    float e = atof( argv[9] );\n    float f = atof( argv[10] );\n    float g = atof( argv[11] );\n    float h = atof( argv[12] );\n    float i = atof( argv[13] );\n    float j = atof( argv[14] );\n    float k = atof( argv[15] );\n    float l = atof( argv[16] );\n    float m = atof( argv[17] );\n    float n = atof( argv[18] );\n    float o = atof( argv[19] );\n    float p = atof( argv[20] );\n    float q = atof( argv[21] );\n    float r = atof( argv[22] );\n    float s = atof( argv[23] );\n    float t = atof( argv[24] );\n    float u = atof( argv[25] );\n    float v = atof( argv[26] );\n    float w = atof( argv[27] );\n    float x = atof( argv[28] );\n    float y = atof( argv[29] );\n    float z = atof( argv[30] );\n    float a = atof( argv[31] );\n    float b = atof( argv[32] );\n    float c = atof( argv[33] );\n    float d = atof( argv[34] );\n", "\n    return p * ( 1.0 - pow( x, 2.0 ) ) / 2.0;\n}\n\nint main( void )\n{\n    float x = 0.0;\n    float p = 0.5;\n\n    for ( int i = 0; i < 10; i++ )\n    {\n        x += my_saw( x, p );\n    }\n\n    printf( \"x = %f\\n\", x );\n}\n\nThe output is\nx = 0.000000\nx = 0.000000\nx = 0.000000\nx = 0.000000\nx = 0.000000\nx = 0.000000\nx = 0.000000\nx = 0.000000\nx = 0.000000\n\nA:\n\nYou are not using the return value of my_saw.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou are not using the return value of pow.\nYou", "\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = vec3(0.0, 0.0, 0.0);\n    vec3 dlmf_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_", "\n    vec3 rd2 = rd - rd;\n    vec3 rd3 = rd2 * rd2;\n    vec3 rd4 = rd3 * rd3;\n    vec3 rd5 = rd4 * rd4;\n    vec3 rd6 = rd5 * rd5;\n    vec3 rd7 = rd6 * rd6;\n    vec3 rd8 = rd7 * rd7;\n    vec3 rd9 = rd8 * rd8;\n    vec3 rd10 = rd9 * rd9;\n    vec3 rd11 = rd10 * rd10;\n    vec3 rd12 = rd11 * rd11;\n    vec3 rd13 = rd12 * rd12;\n    vec3 rd14 = rd13 * rd13;\n    vec3 rd15 = rd14 * rd14;\n    vec3 rd16 = rd15 * rd15;\n    vec3 rd17 = rd16 * rd16;\n    vec3 rd18 = rd17 * rd17;\n    vec3 rd19 = rd18 * rd18;\n    vec3 rd20 = rd19 * rd19;\n    vec3 rd21 = rd20 * rd20;\n    vec3 rd22 = rd21 * rd21;\n    vec3 rd23 = rd22 * rd22;\n    vec3 rd24 = rd23 * rd23;\n    vec3 rd25 = rd24 * rd24;\n    vec3 rd26 = rd25 * rd25;\n    vec3 rd27 = rd26 * rd26;\n    vec3 rd28 = rd27 * rd27;\n    vec3 rd29 = rd28 * rd28;\n    vec3 rd30 = rd29 * rd29;\n    vec3 rd31 = rd30 * rd30;\n    vec3 rd32 = rd31 * rd31;\n    vec3 rd33 = rd32 * rd32;\n    ", "\n    vec3 p1 = p - a;\n    vec3 p2 = p - b;\n    vec3 p3 = p - a;\n    vec3 p4 = p - b;\n    vec3 p5 = p - a;\n    vec3 p6 = p - b;\n    vec3 p7 = p - a;\n    vec3 p8 = p - b;\n    vec3 p9 = p - a;\n    vec3 p10 = p - b;\n    vec3 p11 = p - a;\n    vec3 p12 = p - b;\n    vec3 p13 = p - a;\n    vec3 p14 = p - b;\n    vec3 p15 = p - a;\n    vec3 p16 = p - b;\n    vec3 p17 = p - a;\n    vec3 p18 = p - b;\n    vec3 p19 = p - a;\n    vec3 p20 = p - b;\n    vec3 p21 = p - a;\n    vec3 p22 = p - b;\n    vec3 p23 = p - a;\n    vec3 p24 = p - b;\n    vec3 p25 = p - a;\n    vec3 p26 = p - b;\n    vec3 p27 = p - a;\n    vec3 p28 = p - b;\n    vec3 p29 = p - a;\n    vec3 p30 = p - b;\n    vec3 p31 = p - a;\n    vec3 p32 = p - b;\n    vec3 p33 = p - a;\n    vec3 p34 = p - b;\n    vec3 p35 = p - a;\n    vec3 p36 = p - b;\n    vec3 p37 = p - a;\n    vec3 p38 = p - b;\n    vec3 p39 = p - a;\n    vec3 p40 = p - b;\n    vec3 p41 = p - a;\n    vec3 p42 = p - b;\n    vec3 p43 = p - a;\n    vec3 p44 = p - b;\n    vec3 p45 = p - a;\n    vec3 p46 = p - b;\n    vec3 p47", "\n    vec3 d = a - b;\n    float d2 = d.dot(d);\n    float d3 = d.dot(d);\n    float d4 = d.dot(d);\n    float d5 = d.dot(d);\n    float d6 = d.dot(d);\n    float d7 = d.dot(d);\n    float d8 = d.dot(d);\n    float d9 = d.dot(d);\n    float d10 = d.dot(d);\n    float d11 = d.dot(d);\n    float d12 = d.dot(d);\n    float d13 = d.dot(d);\n    float d14 = d.dot(d);\n    float d15 = d.dot(d);\n    float d16 = d.dot(d);\n    float d17 = d.dot(d);\n    float d18 = d.dot(d);\n    float d19 = d.dot(d);\n    float d20 = d.dot(d);\n    float d21 = d.dot(d);\n    float d22 = d.dot(d);\n    float d23 = d.dot(d);\n    float d24 = d.dot(d);\n    float d25 = d.dot(d);\n    float d26 = d.dot(d);\n    float d27 = d.dot(d);\n    float d28 = d.dot(d);\n    float d29 = d.dot(d);\n    float d30 = d.dot(d);\n    float d31 = d.dot(d);\n    float d32 = d.dot(d);\n    float d33 = d.dot(d);\n    float d34 = d.dot(d);\n    float d35 = d.dot(d);\n    float d36 = d.dot(d);\n    float d37 = d.dot(d);\n    float d38 = d.dot(d);\n    float d39 = d.dot(d);\n    float d40 = d.dot(d);\n    float d41 = d.dot(d);\n    float d42 = d.dot(d);\n    float d43 = d.dot(", "\n    vec2 r = rad1 + rad2;\n    vec2 r1 = rad1 - rad2;\n    vec2 r2 = rad1 + rad2;\n    vec2 r3 = rad1 - rad2;\n    vec2 r4 = rad1 + rad2;\n    vec2 r5 = rad1 - rad2;\n    vec2 r6 = rad1 + rad2;\n    vec2 r7 = rad1 - rad2;\n    vec2 r8 = rad1 + rad2;\n    vec2 r9 = rad1 - rad2;\n    vec2 r10 = rad1 + rad2;\n    vec2 r11 = rad1 - rad2;\n    vec2 r12 = rad1 + rad2;\n    vec2 r13 = rad1 - rad2;\n    vec2 r14 = rad1 + rad2;\n    vec2 r15 = rad1 - rad2;\n    vec2 r16 = rad1 + rad2;\n    vec2 r17 = rad1 - rad2;\n    vec2 r18 = rad1 + rad2;\n    vec2 r19 = rad1 - rad2;\n    vec2 r20 = rad1 + rad2;\n    vec2 r21 = rad1 - rad2;\n    vec2 r22 = rad1 + rad2;\n    vec2 r23 = rad1 - rad2;\n    vec2 r24 = rad1 + rad2;\n    vec2 r25 = rad1 - rad2;\n    vec2 r26 = rad1 + rad2;\n    vec2 r27 = rad1 - rad2;\n    vec2 r28 = rad1 + rad2;\n    vec2 r29 = rad1 - rad2;\n    vec2 r30 = rad1 + rad2;\n    vec2 r31 = rad1 - rad2;\n    vec2 r32 = rad1 + rad2;\n    vec2 r33 = rad1 - rad2;\n    vec2 r34 = rad1 + rad2;\n    vec2 r35 = rad1 - rad2;\n    vec2 r36 = rad1 + rad2;\n    vec2 r37 = rad1 - rad2;\n    vec2 r38 = rad1 + rad2;\n    vec2 r39", "\n    float d = sqrt( pow(p.x - c.x, 2) + pow(p.y - c.y, 2) );\n    float s = pow(r, 2) - pow(d, 2);\n    float t = pow(r, 2) + pow(d, 2);\n    float u = pow(r, 2) - pow(s, 2);\n    float v = pow(r, 2) + pow(s, 2);\n    float w = pow(r, 2) - pow(u, 2);\n    float x = pow(r, 2) + pow(u, 2);\n    float y = pow(r, 2) - pow(v, 2);\n    float z = pow(r, 2) + pow(v, 2);\n    float a = pow(r, 2) - pow(w, 2);\n    float b = pow(r, 2) + pow(w, 2);\n    float c = pow(r, 2) - pow(x, 2);\n    float d = pow(r, 2) + pow(x, 2);\n    float e = pow(r, 2) - pow(y, 2);\n    float f = pow(r, 2) + pow(y, 2);\n    float g = pow(r, 2) - pow(z, 2);\n    float h = pow(r, 2) + pow(z, 2);\n    float i = pow(r, 2) - pow(a, 2);\n    float j = pow(r, 2) + pow(a, 2);\n    float k = pow(r, 2) - pow(b, 2);\n    float l = pow(r, 2) + pow(b, 2);\n    float m = pow(r, 2) - pow(c, 2);\n    float n = pow(r, 2) + pow(c, 2);\n    float o = pow(r, 2) - pow(d, 2);\n    float p = pow(r, 2) + pow(d, 2);\n    float q = pow(r, 2) - pow(e, 2);\n    float r = pow(r, 2) + pow(e, 2);\n    float s = pow(r, 2", "\n    vec3 n = vec3(0,0,0);\n    nSphere4 = vec3(0,0,0);\n    nSphere4.x = pos.x;\n    nSphere4.y = pos.y;\n    nSphere4.z = pos.z;\n    nSphere4.w = 1;\n    return nSphere4;\n}\n\nvec3 nSphere5( in vec3 pos )\n{\n    vec3 n = vec3(0,0,0);\n    nSphere5 = vec3(0,0,0);\n    nSphere5.x = pos.x;\n    nSphere5.y = pos.y;\n    nSphere5.z = pos.z;\n    nSphere5.w = 1;\n    return nSphere5;\n}\n\nvec3 nSphere6( in vec3 pos )\n{\n    vec3 n = vec3(0,0,0);\n    nSphere6 = vec3(0,0,0);\n    nSphere6.x = pos.x;\n    nSphere6.y = pos.y;\n    nSphere6.z = pos.z;\n    nSphere6.w = 1;\n    return nSphere6;\n}\n\nvec3 nSphere7( in vec3 pos )\n{\n    vec3 n = vec3(0,0,0);\n    nSphere7 = vec3(0,0,0);\n    nSphere7.x = pos.x;\n    nSphere7.y = pos.y;\n    nSphere7.z = pos.z;\n    nSphere7.w = 1;\n    return nSphere7;\n}\n\nvec3 nSphere8( in vec3 pos )\n{\n    vec3 n = vec3(0,0,0);\n    nSphere8 = vec3(0,0,0);\n    nSphere8.x = pos.x;\n    nSphere8.y = pos.y;\n    nSphere8.z = pos.z;\n    nSphere8.w = 1;\n    return nSphere8;\n}\n\nvec3 nSphere9( in vec3 pos )\n{\n    vec3 n = vec3(0,0", "\n    float s = ra * ra + rb * rb;\n    float c = ra * ra + sca * sca;\n    float d = ra * ra + scb * scb;\n    float e = ra * ra + sca * sca;\n    float f = ra * ra + scb * scb;\n    float g = ra * ra + c * c;\n    float h = ra * ra + d * d;\n    float i = ra * ra + e * e;\n    float j = ra * ra + f * f;\n    float k = ra * ra + g * g;\n    float l = ra * ra + h * h;\n    float m = ra * ra + i * i;\n    float n = ra * ra + j * j;\n    float o = ra * ra + k * k;\n    float p = ra * ra + l * l;\n    float q = ra * ra + m * m;\n    float r = ra * ra + n * n;\n    float s = ra * ra + o * o;\n    float t = ra * ra + p * p;\n    float u = ra * ra + q * q;\n    float v = ra * ra + r * r;\n    float w = ra * ra + s * s;\n    float x = ra * ra + c * c;\n    float y = ra * ra + d * d;\n    float z = ra * ra + e * e;\n    float a = ra * ra + f * f;\n    float b = ra * ra + g * g;\n    float c = ra * ra + h * h;\n    float d = ra * ra + i * i;\n    float e = ra * ra + j * j;\n    float f = ra * ra + k * k;\n    float g = ra * ra + l * l;\n    float h = ra * ra + m * m;\n    float i = ra * ra + n * n;\n    float j = ra * ra + o * o;\n    float k = ra * ra + p * p;\n    float l = ra * ra + q * q;\n    float m = ra * ra + r * r;\n    float n = ra * ra", "\n    float s = 0.0f;\n    float d = 0.0f;\n    float c = 0.0f;\n    float a = 0.0f;\n    float b = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float s = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n    float d1 = 0.0f;\n    float d2 = 0.0f;\n    float d3 = 0.0f;\n    float d4 = 0.0f;\n    float d5 = 0.0f;\n    float d6 = 0.0f;\n    float d7 = 0.0f;\n    float d8 = 0.0f;\n    float d9 = 0.0f;\n    float d10 = 0.0f;\n    float d11 = 0.0f;\n    float d12 = 0.0f;\n    float d13 = 0.0f;\n    float d14 = 0.0f;\n    float d15 = 0.0f;\n    float d16 = 0.0f;\n    float d17 = 0.0f;\n    float d18 = 0.0f;\n    float d19 = 0.0f;\n    float d20 = 0.0f;\n    float d21 = 0.0f;\n    float d22 = 0.0f;", "\n    vec3 n = normalize( cross( pos, vec3( 0.0, 0.0, 1.0 ) ) );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 cross( vec3 a, vec3 b )\n{\n    vec3 c = a.x * b.y - a.y * b.x;\n    return c;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return n;\n}\n\nvec3 normalize( vec3 v )\n{\n    vec3 n = normalize( v );\n    return", "\n    float s = 0.0f;\n    float d = 0.0f;\n    float c = 0.0f;\n    float a = 0.0f;\n    float b = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float s = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n    float dt = 0.0f;\n    float tt = 0.0f;\n    float tt2 = 0.0f;\n    float tt3 = 0.0f;\n    float tt4 = 0.0f;\n    float tt5 = 0.0f;\n    float tt6 = 0.0f;\n    float tt7 = 0.0f;\n    float tt8 = 0.0f;\n    float tt9 = 0.0f;\n    float tt10 = 0.0f;\n    float tt11 = 0.0f;\n    float tt12 = 0.0f;\n    float tt13 = 0.0f;\n    float tt14 = 0.0f;\n    float tt15 = 0.0f;\n    float tt16 = 0.0f;\n    float tt17 = 0.0f;\n    float tt18 = 0.0f;\n    float tt19 = 0.0f;\n    float t", "\n    float d = sqrt( dpdx.x*dpdx.x + dpdx.y*dpdy.y );\n    float d2 = d*d;\n    float d3 = d*d*d;\n    float d4 = d*d*d*d;\n    float d5 = d*d*d*d*d;\n    float d6 = d*d*d*d*d*d;\n    float d7 = d*d*d*d*d*d*d;\n    float d8 = d*d*d*d*d*d*d*d;\n    float d9 = d*d*d*d*d*d*d*d*d;\n    float d10 = d*d*d*d*d*d*d*d*d*d;\n    float d11 = d*d*d*d*d*d*d*d*d*d*d;\n    float d12 = d*d*d*d*d*d*d*d*d*d*d*d;\n    float d13 = d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d14 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d15 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d16 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d17 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d;\n    float d18 = d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*", "\n    if ( k == 1 )\n        return x;\n    else\n        return staircase( x, k/2 );\n}\n\n// The inverse function y=f^-1(y) is just the function itselft\n// with parameter 1/k instead of k.\nfloat inverse_staircase( in float y, in float k )\n{\n    if ( k == 1 )\n        return y;\n    else\n        return inverse_staircase( y, k/2 );\n}\n\n// The inverse function z=f^-1(z) is just the function itselft\n// with parameter 1/k instead of k.\nfloat inverse_inverse_staircase( in float z, in float k )\n{\n    if ( k == 1 )\n        return z;\n    else\n        return inverse_inverse_staircase( z, k/2 );\n}\n\n// The inverse function w=f^-1(w) is just the function itselft\n// with parameter 1/k instead of k.\nfloat inverse_inverse_inverse_staircase( in float w, in float k )\n{\n    if ( k == 1 )\n        return w;\n    else\n        return inverse_inverse_inverse_staircase( w, k/2 );\n}\n\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat inverse_inverse_inverse_inverse_staircase( in float x, in float k )\n{\n    if ( k == 1 )\n        return x;\n    else\n        return inverse_inverse_inverse_inverse_staircase( x, k/2 );\n}\n\n// The inverse function y=f^-1(y) is just the function itselft\n// with parameter 1/k instead of k.\nfloat inverse_inverse_inverse_inverse_inverse_staircase( in float y, in float k )\n{\n    if ( k == 1 )\n        return y;\n    else\n        return inverse_inverse_inverse_inverse_inverse_staircase( y, k/2 );\n}\n\n//", "\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 light_dir_pos = sample_pos + light_dir_norm * 0.5;\n    vec3 light_dir_pos_norm = normalize(light_dir_pos);\n    vec3 light_dir_pos_norm_dot_normal = dot(light_dir_pos_norm, surface_normal);\n    if (light_dir_pos_norm_dot_normal < 0) {\n        light_dir_pos_norm = -light_dir_pos_norm;\n        light_dir_pos_norm_dot_normal = -light_dir_pos_norm_dot_normal;\n    }\n    vec3 light_dir_pos_norm_dot_light_dir = dot(light_dir_pos_norm, light_dir);\n    if (light_dir_pos_norm_dot_light_dir < 0) {\n        light_dir_pos_norm = -light_dir_pos_norm;\n        light_dir_pos_norm_dot_light_dir = -light_dir_pos_norm_dot_light_dir;\n    }\n    vec3 light_dir_pos_norm_dot_light_dir_norm = dot(light_dir_pos_norm, light_dir_norm);\n    if (light_dir_pos_norm_dot_light_dir_norm < 0) {\n        light_dir_pos_norm = -light_dir_pos_norm;\n        light_dir_pos_norm_dot_light_dir_norm = -light_dir_pos_norm_dot_light_dir_norm;\n    }\n    vec3 light_dir_pos_norm_dot_light_dir_norm_dot_light_dir = dot(light_dir_pos_norm, light_dir_norm, light_dir_pos_norm_dot_light_dir);\n    if (light_dir_pos_norm_dot_light_dir_norm_dot_light_dir < 0) {\n        light_dir_pos_norm = -light_dir_pos_norm;\n        light_dir_pos_norm_dot_light_dir_norm_dot_light_dir = -light", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 depth = vec3(0.0, 0.0, 0.0);\n    vec3 light_color = vec3(0.0, 0.0, 0.0);\n    vec3 light_dir = vec3(0.0, 0.0, 0.0);\n    vec3 light_dir_normalized = normalize(light_dir);\n    vec3 light_dir_normalized_dot_dir = dot(light_dir_normalized, dir);\n    vec3 light_dir_normalized_dot_color = dot(light_dir_normalized, light_color);\n    vec3 light_dir_normalized_dot_depth = dot(light_dir_normalized, depth);\n    vec3 light_dir_normalized_dot_dir_normalized = normalize(light_dir_normalized_dot_dir);\n    vec3 light_dir_normalized_dot_dir_dot_color = dot(light_dir_normalized_dot_dir, light_color);\n    vec3 light_dir_normalized_dot_dir_dot_depth = dot(light_dir_normalized_dot_dir, depth);\n    vec3 light_dir_normalized_dot_dir_dot_dir_normalized = normalize(light_dir_normalized_dot_dir_dot_dir);\n    vec3 light_dir_normalized_dot_dir_dot_dir_dot_color = dot(light_dir_normalized_dot_dir_dot_dir, light_color);\n    vec3 light_dir_normalized_dot_dir_dot_dir_dot_depth = dot(light_dir_normalized_dot_dir_dot_dir, depth);\n    vec3 light_dir_normalized_dot_dir_dot_dir_dot_dot_color = dot(light_dir_normalized_dot_dir_dot_dir, light_color);\n    vec3 light_dir_normalized_dot_dir_dot_dir_dot_dot_depth = dot(light_dir_normalized_dot_dir_dot_dir, depth);\n    vec3 light_dir_", "\n    vec3 camera_vector = vec3(0, 0, 0);\n    camera_vector.x = coord.x - resolution.x/2;\n    camera_vector.y = coord.y - resolution.y/2;\n    camera_vector.z = coord.z - resolution.z/2;\n    return camera_vector;\n}\n\n/*\nwe need a way to calculate the distance between the camera and the pixel\nthis function calculates it\n*/\nvec3 get_pixel_distance(vec3 camera_vector, vec3 pixel_vector) {\n    vec3 pixel_distance = vec3(0, 0, 0);\n    pixel_distance.x = camera_vector.x * pixel_vector.x + camera_vector.y * pixel_vector.y + camera_vector.z * pixel_vector.z;\n    pixel_distance.y = camera_vector.x * pixel_vector.y + camera_vector.y * pixel_vector.z + camera_vector.z * pixel_vector.x;\n    pixel_distance.z = camera_vector.x * pixel_vector.z + camera_vector.y * pixel_vector.x + camera_vector.z * pixel_vector.y;\n    return pixel_distance;\n}\n\n/*\nwe need a way to calculate the distance between the camera and the pixel\nthis function calculates it\n*/\nvec3 get_pixel_distance_to_camera(vec3 camera_vector, vec3 pixel_vector) {\n    vec3 pixel_distance = vec3(0, 0, 0);\n    pixel_distance.x = camera_vector.x * pixel_vector.x + camera_vector.y * pixel_vector.y + camera_vector.z * pixel_vector.z;\n    pixel_distance.y = camera_vector.x * pixel_vector.y + camera_vector.y * pixel_vector.z + camera_vector.z * pixel_vector.x;\n    pixel_distance.z = camera_vector.x * pixel_vector.z + camera_vector.y * pixel_vector.x + camera_vector.z * pixel_vector.y;\n    return pixel_distance;\n}\n\n/*\nwe need a way to calculate the distance between the camera and the pixel", "\n    float s = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p1 = 0.0f;\n    float p2 = 0.0f;\n    float p3 = 0.0f;\n    float p4 = 0.0f;\n    float p5 = 0.0f;\n    float p6 = 0.0f;\n    float p7 = 0.0f;\n    float p8 = 0.0f;\n    float p9 = 0.0f;\n    float p10 = 0.0f;\n    float p11 = 0.0f;\n    float p12 = 0.0f;\n    float p13 = 0.0f;\n    float p14 = 0.0f;\n    float p15 = 0.0f;\n    float p16 = 0.0f;\n    float p17 = 0.0f;\n    float p18 = 0.0f;\n    float p19 = 0.0f;\n    float p20 = 0.0f;\n    float p21 = 0.0f;\n    float p22 = 0.0f;\n    float p23 = 0.0f;\n    float p24 = 0.0f;\n    float p25 = 0.0f;\n    float p26 = 0.0f;\n    float p27 = 0.0f;\n    float p28 = 0.0f;\n    float p29 = 0.0f;\n    float p30 = 0.0f;\n    float p31 = 0.0f;\n    float p32 = 0.0f;\n    float p33 = 0.0f;\n    float p34 = 0.0f;\n    float p35 = 0.", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (material == 0) {\n        color = vec3(1.0, 1.0, 1.0);\n    } else if (material == 1) {\n        color = vec3(0.0, 1.0, 1.0);\n    } else if (material == 2) {\n        color = vec3(1.0, 0.0, 1.0);\n    } else if (material == 3) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else if (material == 4) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else if (material == 5) {\n        color = vec3(0.0, 1.0, 0.0);\n    } else if (material == 6) {\n        color = vec3(0.0, 0.0, 1.0);\n    } else if (material == 7) {\n        color = vec3(1.0, 1.0, 1.0);\n    } else if (material == 8) {\n        color = vec3(1.0, 0.0, 1.0);\n    } else if (material == 9) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else if (material == 10) {\n        color = vec3(1.0, 0.0, 1.0);\n    } else if (material == 11) {\n        color = vec3(1.0, 1.0, 1.0);\n    } else if (material == 12) {\n        color = vec3(0.0, 1.0, 1.0);\n    } else if (material == 13) {\n        color = vec3(0.0, 0.0, 1.0);\n    } else if (material == 14) {\n        color = vec3(1.0, 0.0, 1.0);\n    } else if (material == 15) {\n        color = vec3(1.0, 1.0, 1.0);\n    } else if (material == 16) {\n        ", "\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 1.0;\n    }\n    return 0.5f * (1.0f - pow(0.5f, material));\n}\n\n// Get the reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity_vector(int material, float *reflectivity) {\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 1.0;\n    }\n    reflectivity[0] = get_material_reflectivity(material);\n    reflectivity[1] = get_material_reflectivity(material);\n    return 0.5f * (1.0f - pow(0.5f, material));\n}\n\n// Get the reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity_matrix(int material, float *reflectivity) {\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 1.0;\n    }\n    reflectivity[0][0] = get_material_reflectivity(material);\n    reflectivity[0][1] = get_material_reflectivity(material);\n    reflectivity[1][0] = get_material_reflectivity(material);\n    reflectivity[1][1] = get_material_reflectivity(material);\n    return 0.5f * (1.0f - pow(0.5f, material));\n}\n\n// Get the reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity_matrix_vector(int material, float *reflectivity) {\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 1.0;\n    }\n    reflect", "\n    if (material == 0) {\n        return 0.0;\n    }\n    if (material == 1) {\n        return 1.0;\n    }\n    if (material == 2) {\n        return 2.0;\n    }\n    if (material == 3) {\n        return 3.0;\n    }\n    if (material == 4) {\n        return 4.0;\n    }\n    if (material == 5) {\n        return 5.0;\n    }\n    if (material == 6) {\n        return 6.0;\n    }\n    if (material == 7) {\n        return 7.0;\n    }\n    if (material == 8) {\n        return 8.0;\n    }\n    if (material == 9) {\n        return 9.0;\n    }\n    if (material == 10) {\n        return 10.0;\n    }\n    if (material == 11) {\n        return 11.0;\n    }\n    if (material == 12) {\n        return 12.0;\n    }\n    if (material == 13) {\n        return 13.0;\n    }\n    if (material == 14) {\n        return 14.0;\n    }\n    if (material == 15) {\n        return 15.0;\n    }\n    if (material == 16) {\n        return 16.0;\n    }\n    if (material == 17) {\n        return 17.0;\n    }\n    if (material == 18) {\n        return 18.0;\n    }\n    if (material == 19) {\n        return 19.0;\n    }\n    if (material == 20) {\n        return 20.0;\n    }\n    if (material == 21) {\n        return 21.0;\n    }\n    if (material == 22) {\n        return 22.0;\n    }\n    if (material == 23) {\n        return 23.0;\n    }\n    if (material == 24) {\n        return 24.0;\n    }\n    if (material == 25) {\n        return 25.0;\n    }\n    if (material == 26) {\n        return 26.0;\n    ", "\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl_h(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl_s(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl_l(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl_a(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl_b(int material) {\n    return (float)material;\n}\n\n// Get the color of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_color_rgb_hsl_c(int material) {\n    return (float", "\n    vec3 a = tri_a - tri_b;\n    vec3 b = tri_b - tri_c;\n    vec3 c = tri_c - tri_a;\n    vec3 d = line_a - line_b;\n    vec3 e = line_b - line_c;\n    vec3 f = line_c - line_a;\n    vec3 g = cross(a, b);\n    vec3 h = cross(b, c);\n    vec3 i = cross(c, d);\n    vec3 j = cross(d, e);\n    vec3 k = cross(e, f);\n    vec3 l = cross(f, g);\n    vec3 m = cross(g, h);\n    vec3 n = cross(h, i);\n    vec3 o = cross(i, j);\n    vec3 p = cross(j, k);\n    vec3 q = cross(k, l);\n    vec3 r = cross(l, m);\n    vec3 s = cross(m, n);\n    vec3 t = cross(n, o);\n    vec3 u = cross(o, p);\n    vec3 v = cross(p, q);\n    vec3 w = cross(q, r);\n    vec3 x = cross(r, s);\n    vec3 y = cross(s, t);\n    vec3 z = cross(t, u);\n    if (dot(a, b) == 0 || dot(b, c) == 0 || dot(c, d) == 0 || dot(d, e) == 0 || dot(e, f) == 0 || dot(f, g) == 0 || dot(g, h) == 0 || dot(h, i) == 0 || dot(i, j) == 0 || dot(j, k) == 0 || dot(k, l) == 0 || dot(l, m) == 0 || dot(m, n) == 0 || dot(n, o) == 0 || dot(o, p) == 0 || dot(p, q) == 0 || dot(q, r) == 0 || dot(r, s) == 0 || dot(s, t) == 0 || dot(t, u) == 0 || dot(u,", "\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 tri_bc = tri_b - tri_c;\n    vec3 tri_ca = tri_c - tri_a;\n    vec3 tri_ab_norm = tri_ab / (norm(tri_ab) + 1e-6);\n    vec3 tri_ac_norm = tri_ac / (norm(tri_ac) + 1e-6);\n    vec3 tri_bc_norm = tri_bc / (norm(tri_bc) + 1e-6);\n    vec3 tri_ca_norm = tri_ca / (norm(tri_ca) + 1e-6);\n    vec3 tri_ab_norm_cross_tri_ac = tri_ab_norm.cross(tri_ac_norm);\n    vec3 tri_ac_norm_cross_tri_bc = tri_ac_norm.cross(tri_bc_norm);\n    vec3 tri_bc_norm_cross_tri_ca = tri_bc_norm.cross(tri_ca_norm);\n    vec3 tri_ca_norm_cross_tri_ab = tri_ca_norm.cross(tri_ab_norm);\n    vec3 tri_ab_norm_cross_tri_bc = tri_ab_norm.cross(tri_bc_norm);\n    vec3 tri_ac_norm_cross_tri_ca = tri_ac_norm.cross(tri_ca_norm);\n    vec3 tri_bc_norm_cross_tri_ab = tri_bc_norm.cross(tri_ab_norm);\n    vec3 tri_ca_norm_cross_tri_bc = tri_ca_norm.cross(tri_bc_norm);\n    vec3 tri_ab_norm_cross_tri_ca = tri_ab_norm.cross(tri_ca_norm);\n    vec3 tri_ac_norm_cross_tri_ab = tri_ac_norm.cross(tri_ab_norm);\n    vec3 tri_bc_norm_cross_tri_ac = tri_bc_norm.cross(tri_ac_norm);\n    vec3 tri_ca_norm_", "\n    vec3 normal = normalize(camera_target - camera_position);\n    vec3 up = normalize(cross(normal, camera_position));\n    mat3 rotation = mat3(\n        0.0,\n        -up.y,\n        up.x,\n        0.0,\n        0.0,\n        0.0,\n        1.0\n    );\n    mat3 translation = mat3(\n        0.0,\n        0.0,\n        0.0,\n        camera_position.x,\n        camera_position.y,\n        camera_position.z\n    );\n    return rotation * translation;\n}\n\n// Generate a look-at projection matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_projection_matrix(vec3 camera_position, vec3 camera_target) {\n    mat3 normal = normalize(camera_target - camera_position);\n    vec3 up = normalize(cross(normal, camera_position));\n    mat3 rotation = mat3(\n        0.0,\n        -up.y,\n        up.x,\n        0.0,\n        0.0,\n        0.0,\n        1.0\n    );\n    mat3 translation = mat3(\n        0.0,\n        0.0,\n        0.0,\n        camera_position.x,\n        camera_position.y,\n        camera_position.z\n    );\n    mat3 projection = mat3(\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        1.0\n    );\n    return rotation * translation * projection;\n}\n\n// Generate a look-at view frustum based on a camera\n// position, view target, and frustum height.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 frustum_matrix(vec3 camera_position, vec3 camera_target,", "\n    vec3 ray_dir = ray_target - ray_origin;\n    vec3 normal = normalize(ray_dir);\n    vec3 intersection_dir = cross(normal, ray_dir);\n    if (intersection_dir.length() < 0.0) {\n        return ray_origin;\n    }\n    vec3 intersection_pos = ray_origin + intersection_dir * ray_dir.length();\n    return intersection_pos;\n}\n\n// Check all triangles in the scene for intersection with a line.\n// Return information about the intersection nearest to line_origin,\n// if there was any intersection.\nvec3 line_intersection(vec3 line_origin, vec3 line_target, vec3 ray_origin, vec3 ray_target) {\n    vec3 ray_dir = ray_target - ray_origin;\n    vec3 normal = normalize(ray_dir);\n    vec3 intersection_dir = cross(normal, line_dir);\n    if (intersection_dir.length() < 0.0) {\n        return line_origin;\n    }\n    vec3 intersection_pos = ray_origin + intersection_dir * ray_dir.length();\n    return intersection_pos;\n}\n\n// Check all triangles in the scene for intersection with a plane.\n// Return information about the intersection nearest to plane_origin,\n// if there was any intersection.\nvec3 plane_intersection(vec3 plane_origin, vec3 plane_target, vec3 ray_origin, vec3 ray_target) {\n    vec3 ray_dir = ray_target - ray_origin;\n    vec3 normal = normalize(ray_dir);\n    vec3 intersection_dir = cross(normal, plane_dir);\n    if (intersection_dir.length() < 0.0) {\n        return plane_origin;\n    }\n    vec3 intersection_pos = ray_origin + intersection_dir * ray_dir.length();\n    return intersection_pos;\n}\n\n// Check all triangles in the scene for intersection with a sphere.\n// Return information about the intersection nearest to sphere_origin,\n// if there was any intersection.\nvec3 sphere_intersection(vec3 sphere_origin, vec3 sphere_target, vec3 ray_origin, vec3 ray", "\n    vec3 light_dir = normalize(light_dir);\n    vec3 light_pos = normalize(light_pos);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 light_pos_norm = normalize(light_pos);\n    vec3 light_dir_dot_light_pos_norm = dot(light_dir_norm, light_pos_norm);\n    vec3 light_dir_dot_light_dir_norm = dot(light_dir_norm, light_dir);\n    vec3 light_dir_dot_light_dir_dot_light_pos_norm = dot(light_dir_dot_light_pos_norm, light_dir_dot_light_dir_norm);\n    float light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm = light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm;\n    float light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm = light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm;\n    float light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm = light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm;\n    float light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm = light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm;\n    float light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm = light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_dir_dot_light_pos_norm;\n    float", "\n    return x + ( rand() % 10 );\n}\n\nint main( void )\n{\n    int n = 100;\n    float x[n];\n    float y[n];\n    float sum = 0;\n    float sum2 = 0;\n    float sum3 = 0;\n    float sum4 = 0;\n    float sum5 = 0;\n    float sum6 = 0;\n    float sum7 = 0;\n    float sum8 = 0;\n    float sum9 = 0;\n    float sum10 = 0;\n    float sum11 = 0;\n    float sum12 = 0;\n    float sum13 = 0;\n    float sum14 = 0;\n    float sum15 = 0;\n    float sum16 = 0;\n    float sum17 = 0;\n    float sum18 = 0;\n    float sum19 = 0;\n    float sum20 = 0;\n    float sum21 = 0;\n    float sum22 = 0;\n    float sum23 = 0;\n    float sum24 = 0;\n    float sum25 = 0;\n    float sum26 = 0;\n    float sum27 = 0;\n    float sum28 = 0;\n    float sum29 = 0;\n    float sum30 = 0;\n    float sum31 = 0;\n    float sum32 = 0;\n    float sum33 = 0;\n    float sum34 = 0;\n    float sum35 = 0;\n    float sum36 = 0;\n    float sum37 = 0;\n    float sum38 = 0;\n    float sum39 = 0;\n    float sum40 = 0;\n    float sum41 = 0;\n    float sum42 = 0;\n    float sum43 = 0;\n    float sum44 = 0;\n    float sum45 = 0;\n    float sum46 = 0;\n    float sum47 = 0;\n    float sum48 = 0;\n    float sum49 = 0;\n    float sum50 = 0;\n    float sum51 = 0;\n    float sum52 = 0;\n    float sum53 = 0;\n    float sum54 = 0;\n    float sum55 = 0;\n    float sum56 = 0;\n    float sum57 = 0;\n    float sum58 = 0;\n    float sum59 =", "\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{\n    return p * ( 1.0 - p );\n}\n\n// Gradient noise\nfloat gnoise( in float p )\n{", "\n    return n % 10;\n}\n\nint main()\n{\n    int n;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n1;\n    int n2;\n    int n3;\n    int n4;\n    int n5;\n    int n6;\n    int n7;\n    int n8;\n    int n9;\n    int n10;\n    int n11;\n    int n12;\n    int n13;\n    int n14;\n    int n15;\n    int n16;\n    int n17;\n    int n18;\n    int n19;\n    int n20;\n    int n21;\n    int n22;\n    int n23;\n    int n24;\n    int n25;\n    int n26;\n    int n27;\n    int n28;\n    int n29;\n    int n30;\n    int n31;\n    int n32;\n    int n33;\n    int n34;\n    int n35;\n    int n36;\n    int n37;\n    int n38;\n    int n39;\n    int n40;\n    int n41;\n    int n42;\n    int n43;\n    int n44;\n    int n45;\n    int n46;\n    int n47;\n    int n48;\n    int n49;\n    int n50;\n    int n51;\n    int n52;\n    int n53;\n    int n54;\n    int n55;\n    int n56;\n    int n57;\n    int n58;\n    int n59;\n    int n60;\n    int n61;\n    int n62;\n    int n63;\n    int n64;\n    int n65;\n    int n66;\n    int n67;\n    int n68;\n    int n69;\n    int n70;\n    int n71;\n    int n72;\n    int n73;\n    int n74;\n    int n75;\n    int n76;\n    int n77;\n    int n", "\n    return p * ( 1.0 - p );\n}\n\n// gradient magnitude\nfloat mag( in float p )\n{\n    return sqrt( p.x * p.x + p.y * p.y );\n}\n\n// gradient angle\nfloat ang( in float p )\n{\n    return acos( p.x / mag( p ) );\n}\n\n// gradient direction\nfloat dir( in float p )\n{\n    return p.y / mag( p );\n}\n\n// gradient unit vector\nfloat unit( in float p )\n{\n    return { p.x / mag( p ), p.y / mag( p ) };\n}\n\n// gradient dot product\nfloat dot( in float p1, in float p2 )\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\n// gradient cross product\nfloat cross( in float p1, in float p2 )\n{\n    return { p1.y * p2.z - p1.z * p2.y,\n              p1.z * p2.x - p1.x * p2.z,\n              p1.x * p2.y - p1.y * p2.x };\n}\n\n// gradient angle between two vectors\nfloat angle( in float p1, in float p2 )\n{\n    return acos( dot( p1, p2 ) / ( mag( p1 ) * mag( p2 ) ) );\n}\n\n// gradient angle between two vectors\nfloat angle( in float p1, in float p2, in float p3 )\n{\n    return acos( dot( p1, p2 ) / ( mag( p1 ) * mag( p2 ) ) +\n                 dot( p2, p3 ) / ( mag( p2 ) * mag( p3 ) ) );\n}\n\n// gradient angle between two vectors\nfloat angle( in float p1, in float p2, in float p3, in float p4 )\n{\n    return acos( dot( p1, p2 ) / ( mag( p1 ) * mag( p2 ) ) +\n                 dot( p2, p3 ) / ( mag( p2 ) *", "\n    return G * exp( -x * x / (2 * G * G) );\n}\n\nint main( void )\n{\n    const int N = 100;\n    const int M = 100;\n    const int K = 100;\n    const int N_f = 100;\n    const int M_f = 100;\n    const int K_f = 100;\n\n    float x[N], G[N][N], G_f[N][N], G_f_f[N][N];\n    float fbm_f[N][N], fbm_f_f[N][N];\n\n    for ( int i = 0; i < N; i++ )\n    {\n        x[i] = i;\n        G[i][i] = 1;\n        G_f[i][i] = 1;\n        G_f_f[i][i] = 1;\n    }\n\n    for ( int i = 0; i < N; i++ )\n    {\n        for ( int j = 0; j < N; j++ )\n        {\n            G[i][j] = exp( -x[i] * x[j] / (2 * G[i][j]) );\n        }\n    }\n\n    for ( int i = 0; i < N; i++ )\n    {\n        for ( int j = 0; j < N; j++ )\n        {\n            G_f[i][j] = exp( -x[i] * x[j] / (2 * G_f[i][j]) );\n        }\n    }\n\n    for ( int i = 0; i < N; i++ )\n    {\n        for ( int j = 0; j < N; j++ )\n        {\n            G_f_f[i][j] = exp( -x[i] * x[j] / (2 * G_f_f[i][j]) );\n        }\n    }\n\n    for ( int i = 0; i < N; i++ )\n    {\n        for ( int j = 0; j < N; j++ )\n        {\n            fbm_f[i][j] = fbm( x[i], G[i][j]", "\n    vec3 r = p.xyz;\n    vec3 s = p.xyz;\n    vec3 t = p.xyz;\n    vec3 u = p.xyz;\n    vec3 v = p.xyz;\n    vec3 w = p.xyz;\n    vec3 x = p.xyz;\n    vec3 y = p.xyz;\n    vec3 z = p.xyz;\n\n    vec3 a = (r.x - s.x) * (r.x - s.x) + (r.y - s.y) * (r.y - s.y) + (r.z - s.z) * (r.z - s.z);\n    vec3 b = 2 * (r.x - s.x) * (r.y - s.y) + 2 * (r.y - s.y) * (r.z - s.z) + 2 * (r.z - s.z) * (r.x - s.x);\n    vec3 c = (r.x - s.x) * (r.z - s.z) + (r.y - s.y) * (r.z - s.z) + (r.z - s.z) * (r.x - s.x);\n    vec3 d = 2 * (r.x - s.x) * (r.y - s.y) + 2 * (r.y - s.y) * (r.z - s.z) + 2 * (r.z - s.z) * (r.x - s.x);\n    vec3 e = (r.x - s.x) * (r.z - s.z) + (r.y - s.y) * (r.z - s.z) + (r.z - s.z) * (r.x - s.x);\n    vec3 f = 2 * (r.x - s.x) * (r.y - s.y) + 2 * (r.y - s.y) * (r.z - s.z) + 2 * (r.z - s.z) * (r.x - s.x);\n\n    vec3 color", "\n    vec3 r = pb.xyz;\n    vec3 r2 = r.xyz;\n    vec3 r3 = r2.xyz;\n    vec3 r4 = r3.xyz;\n    vec3 r5 = r4.xyz;\n    vec3 r6 = r5.xyz;\n    vec3 r7 = r6.xyz;\n    vec3 r8 = r7.xyz;\n    vec3 r9 = r8.xyz;\n    vec3 r10 = r9.xyz;\n    vec3 r11 = r10.xyz;\n    vec3 r12 = r11.xyz;\n    vec3 r13 = r12.xyz;\n    vec3 r14 = r13.xyz;\n    vec3 r15 = r14.xyz;\n    vec3 r16 = r15.xyz;\n    vec3 r17 = r16.xyz;\n    vec3 r18 = r17.xyz;\n    vec3 r19 = r18.xyz;\n    vec3 r20 = r19.xyz;\n    vec3 r21 = r20.xyz;\n    vec3 r22 = r21.xyz;\n    vec3 r23 = r22.xyz;\n    vec3 r24 = r23.xyz;\n    vec3 r25 = r24.xyz;\n    vec3 r26 = r25.xyz;\n    vec3 r27 = r26.xyz;\n    vec3 r28 = r27.xyz;\n    vec3 r29 = r28.xyz;\n    vec3 r30 = r29.xyz;\n    vec3 r31 = r30.xyz;\n    vec3 r32 = r31.xyz;\n    vec3 r33 = r32.xyz;\n    vec3 r34 = r33.xyz;\n    vec3 r35 = r34.xyz;\n    vec3 r36 = r35.xyz;\n    vec3 r37 = r36.xyz;\n    vec3 r38 = r37.xyz;\n    vec3 r39 = r38.xyz;\n    vec3 r40 =", "\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 r = rd - cen;\n    vec3 d = r.cross(r);\n    vec3 n = r.cross(d);\n    vec3 nn = n.cross(n);\n    vec3 nn1 = nn.cross(n);\n    vec3 nn2 = nn.cross(d);\n    vec3 nn3 = nn.cross(r);\n    vec3 nn4 = nn.cross(r.cross(d));\n    vec3 nn5 = nn.cross(r.cross(r.cross(d)));\n    vec3 nn6 = nn.cross(r.cross(r.cross(d)));\n    vec3 nn7 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn8 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn9 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn10 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn11 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn12 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn13 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn14 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn15 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn16 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn17 = nn.cross(r.cross(r.cross(r.cross(d))));\n    vec3 nn18 = nn.cross(r.cross(r", "\n    vec3 d = rd - cen;\n    float s = dot(d, d);\n    float c = dot(d, cen);\n    float r = dot(d, rd);\n    float t = dot(d, cen);\n    float u = dot(d, rd);\n    float v = dot(d, cen);\n    float w = dot(d, rd);\n    float x = s*s;\n    float y = 2*(c*c - s*s*s);\n    float z = 2*(r*r - c*c*c - s*s*s*s);\n    float sx = 2*(u*u - v*v);\n    float sy = 2*(w*w - x*x);\n    float sz = 2*(y*y - z*z);\n    float sxy = 2*(u*v - w*x);\n    float sxz = 2*(u*z - v*w);\n    float syz = 2*(v*w - u*x);\n    float sxw = 2*(u*w - v*x);\n    float szx = 2*(v*x - u*z);\n    float szy = 2*(u*z - v*y);\n    float szx = 2*(v*y - u*x);\n    float szy = 2*(u*x - v*y);\n    float szz = 2*(v*y - u*z);\n    return (x + y + z + sx + sy + sz + sxy + sxz + syz + sxw + szx + szy + szx + szy + szz);\n}\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for the cross product.\n\nA:\n\nI think you are looking for", "\n    float r = (rd - ro).length();\n    float t = (tmax - mint).length();\n    float s = (tmax + mint).length();\n    float rms = rmshadow(r, t, s, w);\n    float rms2 = rmshadow(r, t, s, w, w);\n    float rms3 = rmshadow(r, t, s, w, w, w);\n    float rms4 = rmshadow(r, t, s, w, w, w, w);\n    float rms5 = rmshadow(r, t, s, w, w, w, w, w);\n    float rms6 = rmshadow(r, t, s, w, w, w, w, w, w);\n    float rms7 = rmshadow(r, t, s, w, w, w, w, w, w, w);\n    float rms8 = rmshadow(r, t, s, w, w, w, w, w, w, w, w);\n    float rms9 = rmshadow(r, t, s, w, w, w, w, w, w, w, w, w);\n    float rms10 = rmshadow(r, t, s, w, w, w, w, w, w, w, w, w, w);\n    float rms11 = rmshadow(r, t, s, w, w, w, w, w, w, w, w, w, w, w);\n    float rms12 = rmshadow(r, t, s, w, w, w, w, w, w, w, w, w, w, w, w);\n    float rms13 = rmshadow(r, t, s, w, w, w, w, w, w, w, w, w, w, w, w, w);\n    float rms14 = rmshadow(r, t, s, w, w, w, w, w, w, w, w, w, w, w, w, w, w);\n    float rms15 = rmshadow(r", "\n    srand(seed);\n    return rand();\n}\n\nint main(void) {\n    int n = 100;\n    int n_samples = 100;\n    int n_classes = 2;\n    int n_features = 10;\n    int n_samples_per_class = n / n_classes;\n    int n_samples_per_class_per_feature = n_samples_per_class / n_features;\n\n    float *x = malloc(n * sizeof(float));\n    float *y = malloc(n * sizeof(float));\n    float *y_pred = malloc(n * sizeof(float));\n    float *y_true = malloc(n * sizeof(float));\n\n    for (int i = 0; i < n; i++) {\n        x[i] = i;\n        y[i] = i % n_classes;\n        y_pred[i] = rand();\n        y_true[i] = rand();\n    }\n\n    float *x_true = malloc(n * sizeof(float));\n    float *y_true_pred = malloc(n * sizeof(float));\n\n    for (int i = 0; i < n; i++) {\n        x_true[i] = x[i];\n        y_true_pred[i] = y[i];\n        y_pred[i] = y_true[i];\n    }\n\n    float *x_pred = malloc(n * sizeof(float));\n    float *y_pred_true = malloc(n * sizeof(float));\n\n    for (int i = 0; i < n; i++) {\n        x_pred[i] = x[i];\n        y_pred_true[i] = y[i];\n        y_pred[i] = y_true[i];\n    }\n\n    float *x_true_pred = malloc(n * sizeof(float));\n    float *y_true_pred_pred = malloc(n * sizeof(float));\n\n    for (int i = 0; i < n; i++) {\n        x_true_pred[i] = x_true[i];\n        y_true_pred_pred[i]", "\n    vec3 p = a + t * (b - a);\n    vec3 q = b + t * (c - b);\n    vec3 r = c + t * (d - c);\n    return p + q + r;\n}\n\n//Inigo Quilez's Color Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 color( in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + b + c + d;\n    vec3 q = a + b - c - d;\n    vec3 r = a - b + c - d;\n    vec3 s = a - b + c + d;\n    return p + q + r + s;\n}\n\n//Inigo Quilez's Color Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 color( in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + b + c + d;\n    vec3 q = a + b - c - d;\n    vec3 r = a - b + c - d;\n    vec3 s = a - b + c + d;\n    return p + q + r + s;\n}\n\n//Inigo Quilez's Color Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 color( in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + b + c + d;\n    vec3 q = a + b - c - d;\n    vec3 r = a - b + c - d;\n    vec3 s = a - b + c + d;\n    return p + q + r + s;\n}\n\n//Inigo Quilez's Color Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 color( in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 p = a + b + c + d;\n    vec3 q = a", "\n    vec3 p1 = p + vec3(0,0,1);\n    vec3 p2 = p - vec3(0,0,1);\n    vec3 p3 = p - vec3(0,0,1);\n    vec3 p4 = p + vec3(0,0,1);\n    vec3 p5 = p - vec3(0,0,1);\n    vec3 p6 = p - vec3(0,0,1);\n    vec3 p7 = p - vec3(0,0,1);\n    vec3 p8 = p + vec3(0,0,1);\n    vec3 p9 = p - vec3(0,0,1);\n    vec3 p10 = p - vec3(0,0,1);\n    vec3 p11 = p + vec3(0,0,1);\n    vec3 p12 = p - vec3(0,0,1);\n    vec3 p13 = p - vec3(0,0,1);\n    vec3 p14 = p - vec3(0,0,1);\n    vec3 p15 = p + vec3(0,0,1);\n    vec3 p16 = p - vec3(0,0,1);\n    vec3 p17 = p - vec3(0,0,1);\n    vec3 p18 = p + vec3(0,0,1);\n    vec3 p19 = p - vec3(0,0,1);\n    vec3 p20 = p - vec3(0,0,1);\n    vec3 p21 = p - vec3(0,0,1);\n    vec3 p22 = p + vec3(0,0,1);\n    vec3 p23 = p - vec3(0,0,1);\n    vec3 p24 = p - vec3(0,0,1);\n    vec3 p25 = p + vec3(0,0,1);\n    vec3 p26 = p - vec3(0,0,1);\n    vec3 p27 = p - vec3(0,0,1);\n    vec3 p28 = p + vec3(0,0,1);\n    vec3 p29 = p", "\n    vec4 pSegment = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    pSegment.x = a.x + (b.x - a.x) * (r - band);\n    pSegment.y = a.y + (b.y - a.y) * (r - band);\n    pSegment.z = a.z + (b.z - a.z) * (r - band);\n    pSegment.w = p.z - p.x;\n    return pSegment;\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec4 pSegment = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    pSegment.x = a.x + (b.x - a.x) * (r - band);\n    pSegment.y = a.y + (b.y - a.y) * (r - band);\n    pSegment.z = a.z + (b.z - a.z) * (r - band);\n    pSegment.w = p.z - p.x;\n    return pSegment;\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec4 pSegment = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    pSegment.x = a.x + (b.x - a.x) * (r - band);\n    pSegment.y = a.y + (b.y - a.y) * (r - band);\n    pSegment.z = a.z + (b.z - a.z) * (r - band);\n    pSegment.w = p.z - p.x;\n    return pSegment;\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec4 pSegment = vec4(", "\n    vec4 px = p - b;\n    vec4 py = p - b;\n    vec4 pz = p - b;\n    vec4 pw = p - b;\n    vec4 pxy = px * b;\n    vec4 pxz = px * z;\n    vec4 pyz = py * z;\n    vec4 pwz = pw * z;\n    vec4 pxyz = pxy * z;\n    vec4 pwxyz = pwxy * x;\n    vec4 pxyzw = pxyz * x;\n    vec4 pwxyzw = pwxyzw * x;\n    vec4 pxyzwxy = pxyzwxy * x;\n    vec4 pxyzwxyz = pxyzwxyz * x;\n    vec4 pxyzwxyzw = pxyzwxyzw * x;\n    vec4 pxyzwxyzw = pxyzwxyzw * x;\n    vec4 pxyzwxyzwxy = pxyzwxyzwxy * x;\n    vec4 pxyzwxyzwxyz = pxyzwxyzwxyz * x;\n    vec4 pxyzwxyzwxyzw = pxyzwxyzwxyzw * x;\n    vec4 pxyzwxyzwxyzwxy = pxyzwxyzwxyzwxy * x;\n    vec4 pxyzwxyzwxyzwxyz = pxyzwxyzwxyzwxyz * x;\n    vec4 pxyzwxyzwxyzwxyzw = pxyzwxyzwxyzwxyzw * x;\n    vec4 pxyzwxyzwxyzwxyzwxy = pxyzwxyzwxyzwxyzwxy * x;\n    vec4 pxyzwxyzwxyzwxyzwxyz = pxyzwxyzwxyzwxyzwxyz * x;\n    vec4 pxyzwxyzwxyzwxyzwxyzxy = pxyzwxyzwxy", "\n    vec3 p1 = p - b;\n    vec3 p2 = p1 + b;\n    vec3 p3 = p2 - b;\n    vec3 p4 = p3 + b;\n    vec3 p5 = p4 - b;\n    vec3 p6 = p5 + b;\n    vec3 p7 = p6 - b;\n    vec3 p8 = p7 + b;\n    vec3 p9 = p8 - b;\n    vec3 p10 = p9 + b;\n    vec3 p11 = p10 - b;\n    vec3 p12 = p11 + b;\n    vec3 p13 = p12 - b;\n    vec3 p14 = p13 + b;\n    vec3 p15 = p14 - b;\n    vec3 p16 = p15 + b;\n    vec3 p17 = p16 - b;\n    vec3 p18 = p17 + b;\n    vec3 p19 = p18 - b;\n    vec3 p20 = p19 + b;\n    vec3 p21 = p20 - b;\n    vec3 p22 = p21 + b;\n    vec3 p23 = p22 - b;\n    vec3 p24 = p23 + b;\n    vec3 p25 = p24 - b;\n    vec3 p26 = p25 + b;\n    vec3 p27 = p26 - b;\n    vec3 p28 = p27 + b;\n    vec3 p29 = p28 - b;\n    vec3 p30 = p29 + b;\n    vec3 p31 = p30 - b;\n    vec3 p32 = p31 + b;\n    vec3 p33 = p32 - b;\n    vec3 p34 = p33 + b;\n    vec3 p35 = p34 - b;\n    vec3 p36 = p35 + b;\n    vec3 p37 = p36 - b;\n    vec3 p38 = p37 + b;\n    vec3 p39 = p38 - b;\n    vec3 p40 = p39 + b;\n    vec3 p41 = p40 - b;\n    vec3 p42 = p41 + b;\n    vec3 p43 = p42", "\n    vec4 p1 = vec4(p,0.0);\n    vec4 p2 = vec4(p+r,0.0);\n    vec4 p3 = vec4(p+r*2,0.0);\n    vec4 p4 = vec4(p+r*3,0.0);\n    vec4 p5 = vec4(p+r*4,0.0);\n    vec4 p6 = vec4(p+r*5,0.0);\n    vec4 p7 = vec4(p+r*6,0.0);\n    vec4 p8 = vec4(p+r*7,0.0);\n    vec4 p9 = vec4(p+r*8,0.0);\n    vec4 p10 = vec4(p+r*9,0.0);\n    vec4 p11 = vec4(p+r*10,0.0);\n    vec4 p12 = vec4(p+r*11,0.0);\n    vec4 p13 = vec4(p+r*12,0.0);\n    vec4 p14 = vec4(p+r*13,0.0);\n    vec4 p15 = vec4(p+r*14,0.0);\n    vec4 p16 = vec4(p+r*15,0.0);\n    vec4 p17 = vec4(p+r*16,0.0);\n    vec4 p18 = vec4(p+r*17,0.0);\n    vec4 p19 = vec4(p+r*18,0.0);\n    vec4 p20 = vec4(p+r*19,0.0);\n    vec4 p21 = vec4(p+r*20,0.0);\n    vec4 p22 = vec4(p+r*21,0.0);\n    vec4 p23 = vec4(p+r*22,0.0);\n    vec4 p24 = vec4(p+r*23,0.0);\n    vec4 p25 = vec4(p+r*24,0.0);\n    vec4 p26 = vec4(p+r*25,0.", "\n    vec2 p1 = p + vec2(0, r);\n    vec2 p2 = p + vec2(0, -r);\n    vec2 p3 = p + vec2(r, 0);\n    vec2 p4 = p + vec2(-r, 0);\n    vec2 p5 = p + vec2(0, -r);\n    vec2 p6 = p + vec2(0, r);\n    vec2 p7 = p + vec2(r, 0);\n    vec2 p8 = p + vec2(-r, 0);\n    vec2 p9 = p + vec2(0, r);\n    vec2 p10 = p + vec2(-r, 0);\n    vec2 p11 = p + vec2(0, -r);\n    vec2 p12 = p + vec2(r, 0);\n    vec2 p13 = p + vec2(-r, 0);\n    vec2 p14 = p + vec2(0, r);\n    vec2 p15 = p + vec2(-r, 0);\n    vec2 p16 = p + vec2(0, -r);\n    vec2 p17 = p + vec2(r, 0);\n    vec2 p18 = p + vec2(-r, 0);\n    vec2 p19 = p + vec2(0, r);\n    vec2 p20 = p + vec2(-r, 0);\n    vec2 p21 = p + vec2(0, -r);\n    vec2 p22 = p + vec2(r, 0);\n    vec2 p23 = p + vec2(-r, 0);\n    vec2 p24 = p + vec2(0, r);\n    vec2 p25 = p + vec2(-r, 0);\n    vec2 p26 = p + vec2(0, -r);\n    vec2 p27 = p + vec2(r, 0);\n    vec2 p28 = p + vec2(-r, 0);\n    vec2 p29 = p + vec2(0, r);\n    vec2 p30 = p + vec2(-r, 0);\n    vec2 p31 = p + vec2(0, -r);\n    vec2 p32 = p +", "\n    vec4 p0 = vec4( p, 0.0 );\n    vec4 p1 = vec4( p, 0.0 );\n    vec4 p2 = vec4( p, 0.0 );\n    vec4 p3 = vec4( p, 0.0 );\n    vec4 p4 = vec4( p, 0.0 );\n    vec4 p5 = vec4( p, 0.0 );\n    vec4 p6 = vec4( p, 0.0 );\n    vec4 p7 = vec4( p, 0.0 );\n    vec4 p8 = vec4( p, 0.0 );\n    vec4 p9 = vec4( p, 0.0 );\n    vec4 p10 = vec4( p, 0.0 );\n    vec4 p11 = vec4( p, 0.0 );\n    vec4 p12 = vec4( p, 0.0 );\n    vec4 p13 = vec4( p, 0.0 );\n    vec4 p14 = vec4( p, 0.0 );\n    vec4 p15 = vec4( p, 0.0 );\n    vec4 p16 = vec4( p, 0.0 );\n    vec4 p17 = vec4( p, 0.0 );\n    vec4 p18 = vec4( p, 0.0 );\n    vec4 p19 = vec4( p, 0.0 );\n    vec4 p20 = vec4( p, 0.0 );\n    vec4 p21 = vec4( p, 0.0 );\n    vec4 p22 = vec4( p, 0.0 );\n    vec4 p23 = vec4( p, 0.0 );\n    vec4 p24 = vec4( p, 0.0 );\n    vec4 p25 = vec4( p, 0.0 );\n    vec4 p26 = vec4( p, 0.0 );\n    vec4 p27 = vec4( p, 0.0 );\n    vec4 p28 = vec4( p, 0.0 );\n    vec4 p29 = vec4( p, 0.0 );\n    vec4 p30 = vec4( p, 0.0 );\n    vec4 p31 = vec4( p, 0.0 );", "\n    vec3 p1 = a - p;\n    vec3 p2 = b - a;\n    vec3 p3 = p2 - p1;\n    vec3 p4 = p1 - p3;\n    vec3 p5 = p3 - p4;\n    vec3 p6 = p4 - p5;\n    vec3 p7 = p5 - p6;\n    vec3 p8 = p6 - p7;\n    vec3 p9 = p7 - p8;\n    vec3 p10 = p8 - p9;\n    vec3 p11 = p9 - p10;\n    vec3 p12 = p10 - p11;\n    vec3 p13 = p11 - p12;\n    vec3 p14 = p12 - p13;\n    vec3 p15 = p13 - p14;\n    vec3 p16 = p14 - p15;\n    vec3 p17 = p15 - p16;\n    vec3 p18 = p16 - p17;\n    vec3 p19 = p17 - p18;\n    vec3 p20 = p18 - p19;\n    vec3 p21 = p19 - p20;\n    vec3 p22 = p20 - p21;\n    vec3 p23 = p21 - p22;\n    vec3 p24 = p22 - p23;\n    vec3 p25 = p23 - p24;\n    vec3 p26 = p24 - p25;\n    vec3 p27 = p25 - p26;\n    vec3 p28 = p26 - p27;\n    vec3 p29 = p27 - p28;\n    vec3 p30 = p28 - p29;\n    vec3 p31 = p29 - p30;\n    vec3 p32 = p30 - p31;\n    vec3 p33 = p31 - p32;\n    vec3 p34 = p32 - p33;\n    vec3 p35 = p33 - p34;\n    vec3 p36 = p34 - p35;\n    vec3 p37 = p35 - p36;\n    vec3 p38 = p36 - p37;\n    vec3 p39 = p37 - p38;\n    vec3 p40 = p38", "\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 v1 = vec3(0.0, 0.0, 0.0);\n    vec3 v2 = vec3(0.0, 0.0, 0.0);\n    vec3 v3 = vec3(0.0, 0.0, 0.0);\n    vec3 v4 = vec3(0.0, 0.0, 0.0);\n    vec3 v5 = vec3(0.0, 0.0, 0.0);\n    vec3 v6 = vec3(0.0, 0.0, 0.0);\n    vec3 v7 = vec3(0.0, 0.0, 0.0);\n    vec3 v8 = vec3(0.0, 0.0, 0.0);\n    vec3 v9 = vec3(0.0, 0.0, 0.0);\n    vec3 v10 = vec3(0.0, 0.0, 0.0);\n    vec3 v11 = vec3(0.0, 0.0, 0.0);\n    vec3 v12 = vec3(0.0, 0.0, 0.0);\n    vec3 v13 = vec3(0.0, 0.0, 0.0);\n    vec3 v14 = vec3(0.0, 0.0, 0.0);\n    vec3 v15 = vec3(0.0, 0.0, 0.0);\n    vec3 v16 = vec3(0.0, 0.0, 0.0);\n    vec3 v17 = vec3(0.0, 0.0, 0.0);\n    vec3 v18 = vec3(0.0, 0.0, 0.0);\n    vec3 v19 = vec3(0.0, 0.0, 0.0);\n    vec3 v20 = vec3(0.0, 0.0, 0.0);\n    vec3 v21 = vec3(0.0, 0.0, 0.0);\n    vec3 v22 = vec3(0.0, 0.0, 0.0);\n    vec3 v23 =", "\n    vec3 a = X.cross(p);\n    vec3 b = X.cross(X.cross(p));\n    vec3 c = X.cross(X.cross(X.cross(p)));\n    vec3 d = X.cross(X.cross(X.cross(p)));\n    vec3 e = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 f = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 g = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 h = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 i = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 j = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 k = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 l = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 m = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 n = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 o = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p1 = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p2 = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p3 = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p4 = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p5 = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p6 = X.cross(X.cross(X.cross(X.cross(p))));\n    vec3 p7 = X.cross(", "\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a, vec3 b) {\n    if (b.z == 0) {\n        b += 1e-10;\n    }\n    return a / b;\n}\n\nvec3 div(vec3 a,", "\n    vec3 r = vec3(0, 0, 1);\n    r.x = p.x * a;\n    r.y = p.y * a;\n    r.z = p.z * a;\n    return r;\n}\n\nvec3 Translate(vec3 p, vec3 v)\n{\n    vec3 r = vec3(0, 0, 0);\n    r.x = p.x + v.x;\n    r.y = p.y + v.y;\n    r.z = p.z + v.z;\n    return r;\n}\n\nvec3 Normalize(vec3 p)\n{\n    vec3 r = vec3(0, 0, 0);\n    r.x = p.x / sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n    r.y = p.y / sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n    r.z = p.z / sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n    return r;\n}\n\nvec3 Projection(vec3 p, vec3 v)\n{\n    vec3 r = vec3(0, 0, 0);\n    r.x = p.x * v.x + p.y * v.y + p.z * v.z;\n    r.y = p.x * v.y + p.y * v.z + p.z * v.x;\n    r.z = p.x * v.z + p.y * v.x + p.z * v.y;\n    return r;\n}\n\nvec3 Cross(vec3 p, vec3 q)\n{\n    vec3 r = vec3(0, 0, 0);\n    r.x = p.y * q.z - p.z * q.y;\n    r.y = p.z * q.x - p.x * q.z;\n    r.z = p.x * q.y - p.y * q.x;\n", "\n    return (float)pow(x, 3) / (float)pow(R, 3);\n}\n\n// Cubic interpolation\n// x: distance\n// y: value\nfloat CubicInterpolation(float x, float y, float R)\n{\n    return y + (x - x0) * Falloff(x - x0, R);\n}\n\n// Cubic interpolation\n// x: distance\n// y: value\nfloat CubicInterpolation(float x, float y, float R)\n{\n    return y + (x - x0) * (1 - Falloff(x - x0, R)) * CubicInterpolation(x - x0, y, R);\n}\n\n// Cubic interpolation\n// x: distance\n// y: value\nfloat CubicInterpolation(float x, float y, float R)\n{\n    return y + (x - x0) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff(x - x0, R)) * (1 - Falloff", "\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return (1.0 / (2.0 * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n", "\n    float d = b - a;\n    float h = d / 2.0f;\n    float k = (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.0f / (2.0f * d)) * (1.0f - (1.", "\n    float d = p - c;\n    float s = d.dot(d);\n    float t = s * s;\n    float u = p.dot(d);\n    float v = c.dot(d);\n    float w = p.dot(c);\n    float x = u + v + w;\n    float y = t - w;\n    float z = 2 * R * R;\n    float e = e + x + y + z;\n    return e;\n}\n\n// Point2D primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex2D(vec2 p, vec2 c, float R, float e)\n{\n    float d = p - c;\n    float s = d.dot(d);\n    float t = s * s;\n    float u = p.dot(d);\n    float v = c.dot(d);\n    float w = p.dot(c);\n    float x = u + v + w;\n    float y = t - w;\n    float z = 2 * R * R;\n    float e = e + x + y + z;\n    return e;\n}\n\n// Point3D primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex3D(vec3 p, vec3 c, float R, float e)\n{\n    float d = p - c;\n    float s = d.dot(d);\n    float t = s * s;\n    float u = p.dot(d);\n    float v = c.dot(d);\n    float w = p.dot(c);\n    float x = u + v + w;\n    float y = t - w;\n    float z = 2 * R * R;\n    float e = e + x + y + z;\n    return e;\n}\n\n// Point4D primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex4D(vec4 p, vec4 c, float R, float e)\n{\n    float d = p - c;\n    float s =", "\n    float d = b - a;\n    float s = d.length();\n    float t = (s - 1) / 2;\n    float u = (s + 1) / 2;\n    float v = (s + 1) / 2;\n    float w = (s - 1) / 2;\n    float x = (s - 1) / 2;\n    float y = (s + 1) / 2;\n    float z = (s + 1) / 2;\n    float d1 = (b - a).dot(d);\n    float d2 = (b - a).dot(d);\n    float d3 = (b - a).dot(d);\n    float d4 = (b - a).dot(d);\n    float d5 = (b - a).dot(d);\n    float d6 = (b - a).dot(d);\n    float d7 = (b - a).dot(d);\n    float d8 = (b - a).dot(d);\n    float d9 = (b - a).dot(d);\n    float d10 = (b - a).dot(d);\n    float d11 = (b - a).dot(d);\n    float d12 = (b - a).dot(d);\n    float d13 = (b - a).dot(d);\n    float d14 = (b - a).dot(d);\n    float d15 = (b - a).dot(d);\n    float d16 = (b - a).dot(d);\n    float d17 = (b - a).dot(d);\n    float d18 = (b - a).dot(d);\n    float d19 = (b - a).dot(d);\n    float d20 = (b - a).dot(d);\n    float d21 = (b - a).dot(d);\n    float d22 = (b - a).dot(d);\n    float d23 = (b - a).dot(d);\n    float d24 = (b - a).dot(d);\n    float d25 = (b - a).dot(d);\n    float d26 = (b - a).dot(d);\n    float d27 = (b - a).dot(", "\n    return p.x + p.y + p.z;\n}\n\n// Tree node\nstruct Node\n{\n    vec3 pos;\n    vec3 vel;\n    vec3 acc;\n    vec3 mass;\n    vec3 force;\n    vec3 center;\n    vec3 parent;\n    vec3 children[3];\n    vec3 children_vel[3];\n    vec3 children_acc[3];\n    vec3 children_mass[3];\n    vec3 children_force[3];\n    vec3 children_center[3];\n    vec3 children_parent[3];\n    vec3 children_children[3];\n    vec3 children_children_vel[3];\n    vec3 children_children_acc[3];\n    vec3 children_children_mass[3];\n    vec3 children_children_force[3];\n    vec3 children_children_center[3];\n    vec3 children_children_parent[3];\n    vec3 children_children_children[3];\n    vec3 children_children_children_vel[3];\n    vec3 children_children_children_acc[3];\n    vec3 children_children_children_mass[3];\n    vec3 children_children_children_force[3];\n    vec3 children_children_children_center[3];\n    vec3 children_children_children_parent[3];\n    vec3 children_children_children_children[3];\n    vec3 children_children_children_children_vel[3];\n    vec3 children_children_children_children_acc[3];\n    vec3 children_children_children_children_mass[3];\n    vec3 children_children_children_children_force[3];\n    vec3 children_children_children_children_center[3];\n    vec3 children_children_children_children_parent[3];\n    vec3 children_children_children_children_children[3];\n    vec3 children_children_children_children_children_vel[3];\n    vec3 children_children_children_children_children_acc[3];\n    vec3 children_children_children_children_children_mass[3];\n    vec3 children_children_children_children_children_force[3", "\n    float d = a.x - b.x;\n    float e = a.y - b.y;\n    float f = a.z - b.z;\n    float c = d * d + e * e + f * f;\n    float s = sqrt(c);\n    if (s == 0)\n        return 0;\n    return (float) (a.z / s);\n}\n\n// K-means clustering\nvoid kmeans(vec3 points[], int k)\n{\n    vec3 centroids[k];\n    vec3 sum[k];\n    vec3 dist[k];\n    int i, j;\n    for (i = 0; i < k; i++)\n        centroids[i] = points[0];\n    for (i = 1; i < points.size(); i++)\n    {\n        for (j = 0; j < k; j++)\n        {\n            dist[j] = KSegment(centroids[j], points[i]);\n        }\n        for (j = 0; j < k; j++)\n        {\n            if (dist[j] < dist[j + 1])\n            {\n                sum[j] = centroids[j];\n                centroids[j] = points[i];\n            }\n        }\n    }\n    for (i = 0; i < k; i++)\n        points[0] = sum[i];\n}\n\n// K-means clustering\nvoid kmeans_iter(vec3 points[], int k, int iter)\n{\n    vec3 centroids[k];\n    vec3 sum[k];\n    vec3 dist[k];\n    int i, j;\n    for (i = 0; i < k; i++)\n        centroids[i] = points[0];\n    for (i = 1; i < points.size(); i++)\n    {\n        for (j = 0; j < k; j++)\n        {\n            dist[j] = KSegment(centroids[j], points[i]);\n        }\n        for (j = 0; j < k; j++)\n        {\n            if (dist[j] <", "\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    n.x = p.x;\n    n.y = p.y;\n    n.z = p.z;\n    return n;\n}\n\nvec3 Normalize( vec3 n )\n{\n    n.x /= sqrt( n.x.x + n.y.y + n.z.z );\n    n.y /= sqrt( n.x.x + n.y.y + n.z.z );\n    n.z /= sqrt( n.x.x + n.y.y + n.z.z );\n    return n;\n}\n\nvec3 DotProduct( vec3 a, vec3 b )\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 CrossProduct( vec3 a, vec3 b )\n{\n    return vec3( a.y * b.z - a.z * b.y,\n                  a.z * b.x - a.x * b.z,\n                  a.x * b.y - a.y * b.x );\n}\n\nvec3 Projection( vec3 p, vec3 n )\n{\n    return n * p.x / DotProduct( n, p );\n}\n\nvec3 Normalize( vec3 n )\n{\n    n.x /= sqrt( n.x.x + n.y.y + n.z.z );\n    n.y /= sqrt( n.x.x + n.y.y + n.z.z );\n    n.z /= sqrt( n.x.x + n.y.y + n.z.z );\n    return n;\n}\n\nvec3 Projection( vec3 p, vec3 n )\n{\n    return n * p.x / DotProduct( n, p );\n}\n\nvec3 Normalize( vec3 n )\n{\n    n.x /= sqrt( n.x.x + n.y.y + n.z.z );\n    n.y /= sqrt( n.", "\n    float d = 0.0f;\n    float r = 0.0f;\n    float t = 0.0f;\n    float t2 = 0.0f;\n    float t3 = 0.0f;\n    float t4 = 0.0f;\n    float t5 = 0.0f;\n    float t6 = 0.0f;\n    float t7 = 0.0f;\n    float t8 = 0.0f;\n    float t9 = 0.0f;\n    float t10 = 0.0f;\n    float t11 = 0.0f;\n    float t12 = 0.0f;\n    float t13 = 0.0f;\n    float t14 = 0.0f;\n    float t15 = 0.0f;\n    float t16 = 0.0f;\n    float t17 = 0.0f;\n    float t18 = 0.0f;\n    float t19 = 0.0f;\n    float t20 = 0.0f;\n    float t21 = 0.0f;\n    float t22 = 0.0f;\n    float t23 = 0.0f;\n    float t24 = 0.0f;\n    float t25 = 0.0f;\n    float t26 = 0.0f;\n    float t27 = 0.0f;\n    float t28 = 0.0f;\n    float t29 = 0.0f;\n    float t30 = 0.0f;\n    float t31 = 0.0f;\n    float t32 = 0.0f;\n    float t33 = 0.0f;\n    float t34 = 0.0f;\n    float t35 = 0.0f;\n    float t36 = 0.0f;\n    float t37 = 0.0f;\n    float t38 = 0.0f;\n    float t39 = 0.0f;\n    float t40 = 0.0f;\n    float t41 = 0.0f;\n    float t42 = 0.0f;\n    float t43 = 0.0f;\n    float t44 = 0.0f;\n    float t45 = 0.0", "\n    float d = u.dot(o - o);\n    if (d < 0)\n    {\n        h = false;\n        s = 0;\n    }\n    else\n    {\n        h = true;\n        s = 1;\n    }\n    for (int i = 0; i < s; i++)\n    {\n        float d = u.dot(o - o + i * u);\n        if (d < 0)\n        {\n            h = false;\n            s = 0;\n        }\n        else\n        {\n            h = true;\n            s = 1;\n        }\n        o += u;\n    }\n    return h;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float d = u.dot(o - o);\n    if (d < 0)\n    {\n        h = false;\n        s = 0;\n    }\n    else\n    {\n        h = true;\n        s = 1;\n    }\n    for (int i = 0; i < s; i++)\n    {\n        float d = u.dot(o - o + i * u);\n        if (d < 0)\n        {\n            h = false;\n            s = 0;\n        }\n        else\n        {\n            h = true;\n            s = 1;\n        }\n        o += u;\n    }\n    return h;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float d = u.dot(o - o);\n    if (d < 0)\n    {\n        h = false;\n        s = 0;\n    }\n    else\n    {\n        h = true;\n        s = 1;\n    }\n    for (int i = 0; i < s; i++)\n    {\n        float d = u", "\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    b.x = rd.x;\n    b.y = rd.y;\n    b.z = rd.z;\n    return b;\n}\n\nvec3 Color(vec3 rd)\n{\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    c.x = rd.x;\n    c.y = rd.y;\n    c.z = rd.z;\n    return c;\n}\n\nvec3 Normalize(vec3 rd)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    n.x = rd.x;\n    n.y = rd.y;\n    n.z = rd.z;\n    return n;\n}\n\nvec3 Color(vec3 rd)\n{\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    c.x = rd.x;\n    c.y = rd.y;\n    c.z = rd.z;\n    return c;\n}\n\nvec3 Normalize(vec3 rd)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    n.x = rd.x;\n    n.y = rd.y;\n    n.z = rd.z;\n    return n;\n}\n\nvec3 Color(vec3 rd)\n{\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    c.x = rd.x;\n    c.y = rd.y;\n    c.z = rd.z;\n    return c;\n}\n\nvec3 Normalize(vec3 rd)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    n.x = rd.x;\n    n.y = rd.y;\n    n.z = rd.z;\n    return n;\n}\n\nvec3", "\n    vec3 v = a - p;\n    vec3 v2 = b - p;\n    vec3 v3 = p - b;\n    vec3 v4 = a - p;\n    vec3 v5 = b - a;\n    vec3 v6 = p - a;\n    vec3 v7 = b - a;\n    vec3 v8 = p - a;\n    vec3 v9 = b - a;\n    vec3 v10 = p - a;\n    vec3 v11 = b - a;\n    vec3 v12 = p - a;\n    vec3 v13 = b - a;\n    vec3 v14 = p - a;\n    vec3 v15 = b - a;\n    vec3 v16 = p - a;\n    vec3 v17 = b - a;\n    vec3 v18 = p - a;\n    vec3 v19 = b - a;\n    vec3 v20 = p - a;\n    vec3 v21 = b - a;\n    vec3 v22 = p - a;\n    vec3 v23 = b - a;\n    vec3 v24 = p - a;\n    vec3 v25 = b - a;\n    vec3 v26 = p - a;\n    vec3 v27 = b - a;\n    vec3 v28 = p - a;\n    vec3 v29 = b - a;\n    vec3 v30 = p - a;\n    vec3 v31 = b - a;\n    vec3 v32 = p - a;\n    vec3 v33 = b - a;\n    vec3 v34 = p - a;\n    vec3 v35 = b - a;\n    vec3 v36 = p - a;\n    vec3 v37 = b - a;\n    vec3 v38 = p - a;\n    vec3 v39 = b - a;\n    vec3 v40 = p - a;\n    vec3 v41 = b - a;\n    vec3 v42 = p - a;\n    vec3 v43 = b - a;\n    vec3 v44 = p - a;\n    vec3 v45 = b - a;\n    vec3 v46 = p - a;\n    vec3 v47 =", "\n    vec3 r = rd - ro;\n    vec3 r2 = r.dot(r);\n    vec3 r3 = r.dot(rd);\n    vec3 r4 = r.dot(rd);\n    vec3 r5 = r.dot(rd);\n    vec3 r6 = r.dot(rd);\n    vec3 r7 = r.dot(rd);\n    vec3 r8 = r.dot(rd);\n    vec3 r9 = r.dot(rd);\n    vec3 r10 = r.dot(rd);\n    vec3 r11 = r.dot(rd);\n    vec3 r12 = r.dot(rd);\n    vec3 r13 = r.dot(rd);\n    vec3 r14 = r.dot(rd);\n    vec3 r15 = r.dot(rd);\n    vec3 r16 = r.dot(rd);\n    vec3 r17 = r.dot(rd);\n    vec3 r18 = r.dot(rd);\n    vec3 r19 = r.dot(rd);\n    vec3 r20 = r.dot(rd);\n    vec3 r21 = r.dot(rd);\n    vec3 r22 = r.dot(rd);\n    vec3 r23 = r.dot(rd);\n    vec3 r24 = r.dot(rd);\n    vec3 r25 = r.dot(rd);\n    vec3 r26 = r.dot(rd);\n    vec3 r27 = r.dot(rd);\n    vec3 r28 = r.dot(rd);\n    vec3 r29 = r.dot(rd);\n    vec3 r30 = r.dot(rd);\n    vec3 r31 = r.dot(rd);\n    vec3 r32 = r.dot(rd);\n    vec3 r33 = r.dot(rd);\n    vec3 r34 = r.dot(rd);\n    vec3 r35 = r.dot(rd);\n    vec3 r36 = r.dot(rd);\n    vec3 r37 = r.dot(rd);\n    vec3 r38 = r.dot(rd);\n    vec3 r39 = r.dot(rd);\n    vec3 r40 =", "\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec_vec(vec2 coord) {\n    return coord / vec2(norm(coord), 1);\n}\n\n// normalized vector\nvec2 v_norm_vec_vec_vec_vec_vec(vec2", "\n    vec3 pq = q - p;\n    vec3 pqz = pq.z;\n    vec3 pqx = pq.x;\n    vec3 pqy = pq.y;\n    vec3 pqzx = pqz.x;\n    vec3 pqzy = pqz.y;\n    vec3 pqxy = pqx.y;\n    vec3 pqxz = pqx.z;\n    vec3 pqyz = pqz.y;\n    vec3 pqxyz = pqxy.z;\n    vec3 pqyzx = pqyz.x;\n    vec3 pqxzy = pqxz.y;\n    vec3 pqxzxy = pqxz.x;\n    vec3 pqyzxy = pqyz.x;\n    vec3 pqxyzx = pqxy.x;\n    vec3 pqxyzy = pqxy.y;\n    vec3 pqxyzz = pqxyz.y;\n    vec3 pqxyzxy = pqxyz.x;\n    vec3 pqxyzyz = pqxyz.y;\n    vec3 pqxyzxyz = pqxyz.z;\n    vec3 pqxyzxyz = pqxyz.xy;\n    vec3 pqxyzxyz = pqxyz.yz;\n    vec3 pqxyzxyzx = pqxyzxy.x;\n    vec3 pqxyzxyzy = pqxyzxy.y;\n    vec3 pqxyzxyzz = pqxyzxyz.z;\n    vec3 pqxyzxyzxy = pqxyzxyz.xy;\n    vec3 pqxyzxyzyz = pqxyzxyz.yz;\n    vec3 pqxyzxyzxyz = pqxyzxyz.xyz;\n    vec3 pqxyzxyzxyz = pqxyzxyz.xyz;\n    vec3 pqxyzxyzxyzx = pqxyzxyzxy.x;", "\n    vec3 v = p - r;\n    vec3 vx = v.x;\n    vec3 vy = v.y;\n    vec3 vz = v.z;\n    vec3 vx2 = vx * vx;\n    vec3 vy2 = vy * vy;\n    vec3 vz2 = vz * vz;\n    vec3 vx3 = vx * vy;\n    vec3 vy3 = vy * vz;\n    vec3 vz3 = vz * vx;\n    vec3 vx4 = vx * vz;\n    vec3 vy4 = vy * vx;\n    vec3 vz4 = vz * vy;\n    vec3 vx5 = vx * vz;\n    vec3 vy5 = vy * vz;\n    vec3 vz5 = vz * vx;\n    vec3 vx6 = vx * vy;\n    vec3 vy6 = vy * vz;\n    vec3 vz6 = vz * vx;\n    vec3 vx7 = vx * vz;\n    vec3 vy7 = vy * vx;\n    vec3 vz7 = vz * vy;\n    vec3 vx8 = vx * vz;\n    vec3 vy8 = vy * vx;\n    vec3 vz8 = vz * vy;\n    vec3 vx9 = vx * vz;\n    vec3 vy9 = vy * vx;\n    vec3 vz9 = vz * vy;\n    vec3 vx10 = vx * vz;\n    vec3 vy10 = vy * vx;\n    vec3 vz10 = vz * vy;\n    vec3 vx11 = vx * vz;\n    vec3 vy11 = vy * vz;\n    vec3 vz11 = vz * vx;\n    vec3 vx12 = vx * vy;\n    vec3 vy12 = vy * vx;\n    vec3 vz12 = vz * vy;\n    vec3 vx13", "\n    vec3 px = p.x;\n    vec3 py = p.y;\n    vec3 pz = p.z;\n    vec3 pxy = px - py;\n    vec3 pxz = px - pz;\n    vec3 pyz = py - pz;\n    vec3 pxzr = pxz / r;\n    vec3 pyzr = pyz / r;\n    vec3 pxyr = pxy / r;\n    vec3 pxzrpy = pxzr * pyzr;\n    vec3 pyzrpyx = pyzrpy * pxzr;\n    vec3 pxyrpyz = pxyrpy * pyzr;\n    vec3 pxyrpyzr = pxyrpyz * pxzr;\n    vec3 pxyrpyzrpy = pxyrpyzr * pxzrpy;\n    vec3 pxyrpyzrpyx = pxyrpyzrpyx * pxzrpy;\n    vec3 pxyrpyzrpyxz = pxyrpyzrpyx * pxzrpy;\n    vec3 pxyrpyzrpyxzr = pxyrpyzrpyxz * pxzrpy;\n    vec3 pxyrpyzrpyxzrpy = pxyrpyzrpyxzr * pxzrpy;\n    vec3 pxyrpyzrpyxzrpyx = pxyrpyzrpyxzr * pxzrpy;\n    vec3 pxyrpyzrpyxzrpyxz = pxyrpyzrpyxzr * pxzrpy;\n    vec3 pxyrpyzrpyxzrpyxzr = pxyrpyzrpyxzr * pxzrpy;\n    vec3 pxyrpyzrpyxzrpyxzrpy = pxyrpyzrpyxzrpy * pxzrpy;\n    vec3 pxyrpyzrpyxzrpyxzrpyx = pxyrpyzrpyxzrpy", "\n    vec3 p1 = v[0] - p;\n    vec3 p2 = v[1] - p;\n    vec3 p3 = v[2] - p;\n    vec3 p4 = v[0] - v[1];\n    vec3 p5 = v[1] - v[2];\n    vec3 p6 = v[2] - v[0];\n    vec3 p7 = v[0] - v[2];\n    vec3 p8 = v[1] - v[0];\n    vec3 p9 = v[2] - v[1];\n    vec3 p10 = v[0] - v[1];\n    vec3 p11 = v[1] - v[0];\n    vec3 p12 = v[2] - v[0];\n    vec3 p13 = v[0] - v[2];\n    vec3 p14 = v[1] - v[2];\n    vec3 p15 = v[2] - v[1];\n    vec3 p16 = v[0] - v[1];\n    vec3 p17 = v[1] - v[0];\n    vec3 p18 = v[2] - v[0];\n    vec3 p19 = v[0] - v[2];\n    vec3 p20 = v[1] - v[2];\n    vec3 p21 = v[2] - v[1];\n    vec3 p22 = v[0] - v[1];\n    vec3 p23 = v[1] - v[0];\n    vec3 p24 = v[2] - v[0];\n    vec3 p25 = v[0] - v[2];\n    vec3 p26 = v[1] - v[2];\n    vec3 p27 = v[2] - v[1];\n    vec3 p28 = v[0] - v[1];\n    vec3 p29 = v[1] - v[0];\n    vec3 p30 = v[2] - v[0];\n    vec3 p31 = v[0] - v[2];\n    vec3 p32 = v[1] - v[0];\n    vec3 p33", "\n    vec3 p0 = p - ra;\n    vec3 p1 = p + rb;\n    vec3 p2 = p - rb;\n    vec3 p3 = p + ra;\n    vec3 p4 = p - ra;\n    vec3 p5 = p + ra;\n    vec3 p6 = p - ra;\n    vec3 p7 = p + ra;\n    vec3 p8 = p - ra;\n    vec3 p9 = p + ra;\n    vec3 p10 = p - ra;\n    vec3 p11 = p + ra;\n    vec3 p12 = p - ra;\n    vec3 p13 = p + ra;\n    vec3 p14 = p - ra;\n    vec3 p15 = p + ra;\n    vec3 p16 = p - ra;\n    vec3 p17 = p + ra;\n    vec3 p18 = p - ra;\n    vec3 p19 = p + ra;\n    vec3 p20 = p - ra;\n    vec3 p21 = p + ra;\n    vec3 p22 = p - ra;\n    vec3 p23 = p + ra;\n    vec3 p24 = p - ra;\n    vec3 p25 = p + ra;\n    vec3 p26 = p - ra;\n    vec3 p27 = p + ra;\n    vec3 p28 = p - ra;\n    vec3 p29 = p + ra;\n    vec3 p30 = p - ra;\n    vec3 p31 = p + ra;\n    vec3 p32 = p - ra;\n    vec3 p33 = p + ra;\n    vec3 p34 = p - ra;\n    vec3 p35 = p + ra;\n    vec3 p36 = p - ra;\n    vec3 p37 = p + ra;\n    vec3 p38 = p - ra;\n    vec3 p39 = p + ra;\n    vec3 p40 = p - ra;\n    vec3 p41 = p + ra;\n    vec3 p42 = p - ra;\n    vec3 p43 = p + ra;\n    vec3 p44 = p - ra;\n    vec3 p45 = p + ra;\n    vec3", "\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 1.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p = a + b;\n    return vec3( p.x, p.y, 0.0 );\n}\n\nfloat cro( in vec2 a, in vec2 b ) {\n    vec2 p =", "\n    vec3 a = ab;\n    vec3 b = p - a;\n    vec3 c = b.cross(a);\n    vec3 d = b.cross(c);\n    vec3 e = b.cross(d);\n    vec3 f = b.cross(e);\n    vec3 g = b.cross(f);\n    vec3 h = b.cross(g);\n    vec3 i = b.cross(h);\n    vec3 j = b.cross(i);\n    vec3 k = b.cross(j);\n    vec3 l = b.cross(k);\n    vec3 m = b.cross(l);\n    vec3 n = b.cross(m);\n    vec3 o = b.cross(n);\n    vec3 p = b.cross(o);\n    vec3 q = b.cross(p);\n    vec3 r = b.cross(q);\n    vec3 s = b.cross(r);\n    vec3 t = b.cross(s);\n    vec3 u = b.cross(t);\n    vec3 v = b.cross(u);\n    vec3 w = b.cross(v);\n    vec3 x = b.cross(w);\n    vec3 y = b.cross(x);\n    vec3 z = b.cross(y);\n    vec3 zdg = b.cross(z);\n    vec3 xyz = b.cross(x,y,z);\n    vec3 xyzdg = b.cross(x,y,z,dg);\n    vec3 xyzdgz = b.cross(x,y,z,dg,z);\n    vec3 xyzdgzd = b.cross(x,y,z,dg,z,dg);\n    vec3 xyzdgzdg = b.cross(x,y,z,dg,z,dg,dg);\n    vec3 xyzdgzdgz = b.cross(x,y,z,dg,z,dg,dg,dg);\n    vec3 xyzdgzdgzd = b.cross(x,y,z,dg,z,", "\n    vec4 v = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    vec3 p0 = p - ra;\n    vec3 p1 = p - rb;\n    vec3 p2 = p + ra;\n    vec3 p3 = p + rb;\n    vec3 p4 = p - ra;\n    vec3 p5 = p - rb;\n    vec3 p6 = p + ra;\n    vec3 p7 = p + rb;\n    vec3 p8 = p - ra;\n    vec3 p9 = p - rb;\n    vec3 p10 = p + ra;\n    vec3 p11 = p + rb;\n    vec3 p12 = p - ra;\n    vec3 p13 = p - rb;\n    vec3 p14 = p + ra;\n    vec3 p15 = p + rb;\n    vec3 p16 = p - ra;\n    vec3 p17 = p - rb;\n    vec3 p18 = p + ra;\n    vec3 p19 = p + rb;\n    vec3 p20 = p - ra;\n    vec3 p21 = p - rb;\n    vec3 p22 = p + ra;\n    vec3 p23 = p + rb;\n    vec3 p24 = p - ra;\n    vec3 p25 = p - rb;\n    vec3 p26 = p + ra;\n    vec3 p27 = p + rb;\n    vec3 p28 = p - ra;\n    vec3 p29 = p - rb;\n    vec3 p30 = p + ra;\n    vec3 p31 = p + rb;\n    vec3 p32 = p - ra;\n    vec3 p33 = p - rb;\n    vec3 p34 = p + ra;\n    vec3 p35 = p + rb;\n    vec3 p36 = p - ra;\n    vec3 p37 = p - rb;\n    vec3 p38 = p + ra;\n    vec3 p39 = p + rb;\n    vec3 p40 = p - ra;\n    vec3 p41 = p - rb;", "\n    vec4 p1 = a + (b - a) * (p - a);\n    vec4 p2 = a + (b - a) * (p - b);\n    vec4 p3 = a + (b - a) * (p - c);\n    vec4 p4 = a + (b - a) * (p - d);\n    vec4 p5 = a + (b - a) * (p - e);\n    vec4 p6 = a + (b - a) * (p - f);\n    vec4 p7 = a + (b - a) * (p - g);\n    vec4 p8 = a + (b - a) * (p - h);\n    vec4 p9 = a + (b - a) * (p - i);\n    vec4 p10 = a + (b - a) * (p - j);\n    vec4 p11 = a + (b - a) * (p - k);\n    vec4 p12 = a + (b - a) * (p - l);\n    vec4 p13 = a + (b - a) * (p - m);\n    vec4 p14 = a + (b - a) * (p - n);\n    vec4 p15 = a + (b - a) * (p - o);\n    vec4 p16 = a + (b - a) * (p - p);\n    vec4 p17 = a + (b - a) * (p - q);\n    vec4 p18 = a + (b - a) * (p - r);\n    vec4 p19 = a + (b - a) * (p - s);\n    vec4 p20 = a + (b - a) * (p - t);\n    vec4 p21 = a + (b - a) * (p - u);\n    vec4 p22 = a + (b - a) * (p - v);\n    vec4 p23 = a + (b - a) * (p - w);\n    vec4 p24 = a + (b - a) * (p - x);\n    vec4 p25 = a + (b - a) * (p - y);\n    vec4 p26 = a + (b -", "\n    vec2 p1 = p + vec2(0, wi);\n    vec2 p2 = p + vec2(0, he);\n    vec2 p3 = p + vec2(sk, he);\n    vec2 p4 = p + vec2(sk, 0);\n    float d1 = p1.x - p2.x;\n    float d2 = p1.y - p2.y;\n    float d3 = p3.x - p4.x;\n    float d4 = p3.y - p4.y;\n    float d5 = p1.x - p4.x;\n    float d6 = p1.y - p4.y;\n    float d7 = p2.x - p3.x;\n    float d8 = p2.y - p3.y;\n    float d9 = p3.x - p4.x;\n    float d10 = p3.y - p4.y;\n    float d11 = p1.x - p2.x;\n    float d12 = p1.y - p2.y;\n    float d13 = p3.x - p4.x;\n    float d14 = p3.y - p4.y;\n    float d15 = p1.x - p4.x;\n    float d16 = p1.y - p4.y;\n    float d17 = p2.x - p3.x;\n    float d18 = p2.y - p3.y;\n    float d19 = p3.x - p4.x;\n    float d20 = p3.y - p4.y;\n    float d21 = p1.x - p2.x;\n    float d22 = p1.y - p2.y;\n    float d23 = p3.x - p4.x;\n    float d24 = p3.y - p4.y;\n    float d25 = p1.x - p4.x;\n    float d26 = p1.y - p4.y;\n    float d27 = p2.x - p3.x;\n    float d28 = p2.y - p3.y;", "\n    vec3 p1 = p + vec2(0, wi);\n    vec3 p2 = p + vec2(0, he);\n    vec3 p3 = p + vec2(sk, 0);\n    vec3 p4 = p + vec2(-sk, 0);\n    vec3 p5 = p + vec2(0, -sk);\n    vec3 p6 = p + vec2(0, sk);\n    vec3 p7 = p + vec2(-sk, sk);\n    vec3 p8 = p + vec2(sk, -sk);\n    vec3 p9 = p + vec2(0, 0);\n    vec3 p10 = p + vec2(0, 0);\n    vec3 p11 = p + vec2(0, 0);\n    vec3 p12 = p + vec2(0, 0);\n    vec3 p13 = p + vec2(0, 0);\n    vec3 p14 = p + vec2(0, 0);\n    vec3 p15 = p + vec2(0, 0);\n    vec3 p16 = p + vec2(0, 0);\n    vec3 p17 = p + vec2(0, 0);\n    vec3 p18 = p + vec2(0, 0);\n    vec3 p19 = p + vec2(0, 0);\n    vec3 p20 = p + vec2(0, 0);\n    vec3 p21 = p + vec2(0, 0);\n    vec3 p22 = p + vec2(0, 0);\n    vec3 p23 = p + vec2(0, 0);\n    vec3 p24 = p + vec2(0, 0);\n    vec3 p25 = p + vec2(0, 0);\n    vec3 p26 = p + vec2(0, 0);\n    vec3 p27 = p + vec2(0, 0);\n    vec3 p28 = p + vec2(0, 0);\n    vec3 p29 = p + vec2(0, 0);\n    vec3 p30 = p + vec2(0, 0);\n    vec3 p31 = p + vec2(0, 0);\n    vec3 p32 = p + vec2(0,", "\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\treturn op;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/2;\n\t\treturn op;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/3;\n\t\treturn op;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/4;\n\t\treturn op;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/5;\n\t\treturn op;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/6;\n\t\treturn op;\n\t}\n\nfloat opRep7D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/7;\n\t\treturn op;\n\t}\n\nfloat opRep8D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/8;\n\t\treturn op;\n\t}\n\nfloat opRep9D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/9;\n\t\treturn op;\n\t}\n\nfloat opRep10D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/10;\n\t\treturn op;\n\t}\n\nfloat opRep11D( float p, float c )\n\t{\n\t\tfloat op = 0;\n\t\top = p*c;\n\t\top = op/11;\n\t\treturn op;\n\t}\n\nfloat opRep12D( float", "\n    float p = a;\n    for (int i = 0; i < k; i++) {\n        p = p - b * p;\n    }\n    return p;\n}\n\nint main() {\n    float a = 0.0, b = 1.0, k = 3;\n    float p = pmin(a, b, k);\n    printf(\"%f\\n\", p);\n}\n\nA:\n\nYou can use the following function to get the minimum of a polynomial:\nfloat minPoly(float a, float b, float c, float d) {\n    float p = a;\n    for (int i = 0; i < c; i++) {\n        p = p - b * p;\n    }\n    return p;\n}\n\nA:\n\nYou can use the following function to get the minimum of a polynomial:\nfloat minPoly(float a, float b, float c, float d) {\n    float p = a;\n    for (int i = 0; i < c; i++) {\n        p = p - b * p;\n    }\n    return p;\n}\n\nA:\n\nYou can use the following function to get the minimum of a polynomial:\nfloat minPoly(float a, float b, float c, float d) {\n    float p = a;\n    for (int i = 0; i < c; i++) {\n        p = p - b * p;\n    }\n    return p;\n}\n\nA:\n\nYou can use the following function to get the minimum of a polynomial:\nfloat minPoly(float a, float b, float c, float d) {\n    float p = a;\n    for (int i = 0; i < c; i++) {\n        p = p - b * p;\n    }\n    return p;\n}\n\nA:\n\nYou can use the following function to get the minimum of a polynomial:\nfloat minPoly(float a, float b, float c, float d) {\n    float p = a;\n    for (int i = 0; i < c; i++) {\n        p = p - b * p;\n    }\n    return p;\n}\n\n", "\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i) {\n        out += p[i] * p[i];\n    }\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    for (int i = 0; i < size; ++i)", "\n    vec3 r = vec3(0, 0, 0);\n    vec3 g = vec3(0, 0, 0);\n    vec3 b = vec3(0, 0, 0);\n    vec3 v = vec3(0, 0, 0);\n    vec3 p = vec3(0, 0, 0);\n    vec3 q = vec3(0, 0, 0);\n    vec3 r1 = vec3(0, 0, 0);\n    vec3 g1 = vec3(0, 0, 0);\n    vec3 b1 = vec3(0, 0, 0);\n    vec3 v1 = vec3(0, 0, 0);\n    vec3 p1 = vec3(0, 0, 0);\n    vec3 q1 = vec3(0, 0, 0);\n    vec3 r2 = vec3(0, 0, 0);\n    vec3 g2 = vec3(0, 0, 0);\n    vec3 b2 = vec3(0, 0, 0);\n    vec3 v2 = vec3(0, 0, 0);\n    vec3 p2 = vec3(0, 0, 0);\n    vec3 q2 = vec3(0, 0, 0);\n    vec3 r3 = vec3(0, 0, 0);\n    vec3 g3 = vec3(0, 0, 0);\n    vec3 b3 = vec3(0, 0, 0);\n    vec3 v3 = vec3(0, 0, 0);\n    vec3 p3 = vec3(0, 0, 0);\n    vec3 q3 = vec3(0, 0, 0);\n    vec3 r4 = vec3(0, 0, 0);\n    vec3 g4 = vec3(0, 0, 0);\n    vec3 b4 = vec3(0, 0, 0);\n    vec3 v4 = vec3(0, 0, 0);\n    vec3 p4 = vec3(0, 0, 0);\n    vec3 q4 = vec3(0, 0, 0);\n    vec3 r5 = vec3(0, 0, 0);\n    vec3 g5 = vec3(0, 0, 0);\n    vec3 b5", "\n    vec2 ray = s - ro;\n    vec2 raySphere = s - rd;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere = s - r;\n    return raySphere.cross(ray);\n}\n\nvec3 raySphereIntersection(vec3 p, vec3 r, vec4 s) {\n    vec3 ray = s - p;\n    vec3 raySphere", "\n    vec3 p = (rd - ro).normalize();\n    vec3 n = boxSize - p;\n    outNormal = n.cross(p);\n    return outNormal;\n}\n\nvec3 rayIntersect(vec3 p, vec3 ray, vec3 boxSize, out vec3 outNormal )  {\n    vec3 n = rayBox(p, ray, boxSize, outNormal);\n    if (n.length() < 0.001) return vec3(0,0,0);\n    return outNormal.cross(n);\n}\n\nvec3 rayIntersect(vec3 p, vec3 ray, vec3 boxSize, out vec3 outNormal )  {\n    vec3 n = rayBox(p, ray, boxSize, outNormal);\n    if (n.length() < 0.001) return vec3(0,0,0);\n    return outNormal.cross(n);\n}\n\nvec3 rayIntersect(vec3 p, vec3 ray, vec3 boxSize, out vec3 outNormal )  {\n    vec3 n = rayBox(p, ray, boxSize, outNormal);\n    if (n.length() < 0.001) return vec3(0,0,0);\n    return outNormal.cross(n);\n}\n\nvec3 rayIntersect(vec3 p, vec3 ray, vec3 boxSize, out vec3 outNormal )  {\n    vec3 n = rayBox(p, ray, boxSize, outNormal);\n    if (n.length() < 0.001) return vec3(0,0,0);\n    return outNormal.cross(n);\n}\n\nvec3 rayIntersect(vec3 p, vec3 ray, vec3 boxSize, out vec3 outNormal )  {\n    vec3 n = rayBox(p, ray, boxSize, outNormal);\n    if (n.length() < 0.001) return vec3(0,0,0);\n    return outNormal.cross(n);\n}\n\nvec3 rayIntersect(vec3 p, vec3 ray, vec3 boxSize, out vec3 outNormal )  {\n    vec3 n = rayBox(p, ray, boxSize, outNormal);\n    if (n", "\n    vec2 v1 = p - d;\n    vec2 v2 = p + d;\n    vec2 v3 = p - d;\n    vec2 v4 = p + d;\n    vec2 v5 = p - d;\n    vec2 v6 = p + d;\n    vec2 v7 = p - d;\n    vec2 v8 = p + d;\n    vec2 v9 = p - d;\n    vec2 v10 = p + d;\n    vec2 v11 = p - d;\n    vec2 v12 = p + d;\n    vec2 v13 = p - d;\n    vec2 v14 = p + d;\n    vec2 v15 = p - d;\n    vec2 v16 = p + d;\n    vec2 v17 = p - d;\n    vec2 v18 = p + d;\n    vec2 v19 = p - d;\n    vec2 v20 = p + d;\n    vec2 v21 = p - d;\n    vec2 v22 = p + d;\n    vec2 v23 = p - d;\n    vec2 v24 = p + d;\n    vec2 v25 = p - d;\n    vec2 v26 = p + d;\n    vec2 v27 = p - d;\n    vec2 v28 = p + d;\n    vec2 v29 = p - d;\n    vec2 v30 = p + d;\n    vec2 v31 = p - d;\n    vec2 v32 = p + d;\n    vec2 v33 = p - d;\n    vec2 v34 = p + d;\n    vec2 v35 = p - d;\n    vec2 v36 = p + d;\n    vec2 v37 = p - d;\n    vec2 v38 = p + d;\n    vec2 v39 = p - d;\n    vec2 v40 = p + d;\n    vec2 v41 = p - d;\n    vec2 v42 = p + d;\n    vec2 v43 = p - d;\n    vec2 v44 = p + d;\n    vec2 v45 = p - d;\n    vec2 v46 = p + d;\n    vec2 v47", "\n    return sqrt(pow(a.x - p.x, 2) + pow(a.y - p.y, 2));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b) {\n    return sqrt(pow(a.x - p.x, 2) + pow(a.y - p.y, 2));\n}\n\nfloat closest(vec2 p, vec2 a, vec2 b, vec2 c) {\n    float d = dist(p, a, b);\n    float e = dist(p, a, c);\n    float f = dist(b, a, c);\n    float g = dist(b, a, p);\n    float h = dist(p, b, a);\n    float i = dist(p, b, b);\n    float j = dist(p, c, a);\n    float k = dist(p, c, b);\n    float l = dist(p, c, p);\n    float m = dist(a, b, c);\n    float n = dist(a, b, p);\n    float o = dist(a, c, p);\n    float p = dist(a, c, b);\n    float q = dist(b, c, a);\n    float r = dist(b, c, p);\n    float s = dist(c, a, p);\n    float t = dist(c, a, b);\n    float u = dist(c, b, a);\n    float v = dist(c, b, b);\n    float w = dist(c, b, p);\n    float x = dist(a, b, p);\n    float y = dist(a, b, c);\n    float z = dist(a, c, p);\n    float closest = min(d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z);\n    return closest;\n}\n\nvoid draw(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g, vec2 h, vec2 i,", "\n    vec2 p1 = p - a;\n    vec2 p2 = p - b;\n    float d = dot( p1, p2 );\n    float s = dot( p1, p1 ) + dot( p2, p2 );\n    float t = dot( p1, p2 ) - d;\n    float r = s / t;\n    return r;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h )\n{\n    vec2 p1 = p - a;\n    vec2 p2 = p - b;\n    float d = dot( p1, p2 );\n    float s = dot( p1, p1 ) + dot( p2, p2 );\n    float t = dot( p1, p2 ) - d;\n    float r = s / t;\n    float h1 = h * r;\n    float h2 = h * (1 - r);\n    return h1 + h2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h )\n{\n    vec2 p1 = p - a;\n    vec2 p2 = p - b;\n    float d = dot( p1, p2 );\n    float s = dot( p1, p1 ) + dot( p2, p2 );\n    float t = dot( p1, p2 ) - d;\n    float r = s / t;\n    float h1 = h * r;\n    float h2 = h * (1 - r);\n    return h1 + h2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h1 )\n{\n    vec2 p1 = p - a", "\n    float r = 0.0f;\n    float d = 0.0f;\n    float t = 0.0f;\n    float a = 0.0f;\n    float b = 0.0f;\n    float c = 0.0f;\n    float d1 = 0.0f;\n    float d2 = 0.0f;\n    float d3 = 0.0f;\n    float d4 = 0.0f;\n    float d5 = 0.0f;\n    float d6 = 0.0f;\n    float d7 = 0.0f;\n    float d8 = 0.0f;\n    float d9 = 0.0f;\n    float d10 = 0.0f;\n    float d11 = 0.0f;\n    float d12 = 0.0f;\n    float d13 = 0.0f;\n    float d14 = 0.0f;\n    float d15 = 0.0f;\n    float d16 = 0.0f;\n    float d17 = 0.0f;\n    float d18 = 0.0f;\n    float d19 = 0.0f;\n    float d20 = 0.0f;\n    float d21 = 0.0f;\n    float d22 = 0.0f;\n    float d23 = 0.0f;\n    float d24 = 0.0f;\n    float d25 = 0.0f;\n    float d26 = 0.0f;\n    float d27 = 0.0f;\n    float d28 = 0.0f;\n    float d29 = 0.0f;\n    float d30 = 0.0f;\n    float d31 = 0.0f;\n    float d32 = 0.0f;\n    float d33 = 0.0f;\n    float d34 = 0.0f;\n    float d35 = 0.0f;\n    float d36 = 0.0f;\n    float d37 = 0.0f;\n    float d38 = 0.0f;\n    float d39 = 0.0f;\n    float d40 = 0.0f;\n    float d41 = 0.0f;\n", "\n    vec3 n = vec3(0, 0, 0);\n    n.x = pos.x - tor.x;\n    n.y = pos.y - tor.y;\n    n.z = pos.z - tor.z;\n    return n;\n}\n\nvec3 normalize(vec3 n) {\n    vec3 n_norm = n / length(n);\n    return n_norm;\n}\n\nvec3 dot(vec3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 cross(vec3 a, vec3 b) {\n    vec3 c = vec3(0, 0, 0);\n    c.x = a.y * b.z - a.z * b.y;\n    c.y = a.z * b.x - a.x * b.z;\n    c.z = a.x * b.y - a.y * b.x;\n    return c;\n}\n\nvec3 angleBetween(vec3 a, vec3 b) {\n    vec3 c = cross(a, b);\n    return acos(dot(a, b) / length(a) / length(b));\n}\n\nvec3 normalize(vec3 n) {\n    vec3 n_norm = n / length(n);\n    return n_norm;\n}\n\nvec3 dot(vec3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 cross(vec3 a, vec3 b) {\n    vec3 c = vec3(0, 0, 0);\n    c.x = a.y * b.z - a.z * b.y;\n    c.y = a.z * b.x - a.x * b.z;\n    c.z = a.x * b.y - a.y * b.x;\n    return c;\n}\n\nvec3 normalize(vec3 n) {\n    vec3 n_norm = n / length(n);\n    return n_norm", "\n    float y = 0.0;\n    for (int i = 0; i < 100; i++) {\n        y += 1.0 / (1.0 + exp(-x * i));\n    }\n    return y;\n}\n\nA:\n\nThe problem is that you are not using the tanh function correctly.\nThe function is defined as:\n\ntanh(x) = (e^x - e^-x) / (e^x + e^-x)\n\nSo you need to use the following formula:\n\ntanh(x) = (e^x - e^-x) / (e^x + e^-x)\ntanh(x) = (exp(x) - exp(-x)) / (exp(x) + exp(-x))\ntanh(x) = (1 - exp(-x)) / (1 + exp(-x))\ntanh(x) = 1 - tanh(x)\n\nSo you need to use the following code:\nfloat tanh_approx(float x) {\n    float y = 0.0;\n    for (int i = 0; i < 100; i++) {\n        y += 1.0 / (1.0 + exp(-x * i));\n    }\n    return y;\n}\n\nA:\n\nThe problem is that you are not using the tanh function correctly.\nThe function is defined as:\n\ntanh(x) = (e^x - e^-x) / (e^x + e^-x)\n\nSo you need to use the following formula:\n\ntanh(x) = (exp(x) - exp(-x)) / (exp(x) + exp(-x))\ntanh(x) = (1 - exp(-x)) / (1 + exp(-x))\ntanh(x) = 1 - tanh(x)\n\nSo you need to use the following code:\nfloat tanh_approx(float x) {\n    float y = 0.0;\n    for (int i = 0; i < 100; i++) {\n        y += 1.0 / (1.0 + exp(-x * i));\n    }\n    return y;\n}\n\nA:\n\nThe problem is that you are", "\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r.y = col.y + q.y;\n    r.z = col.z + q.z;\n    return r;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r.y = col.y + q.y;\n    r.z = col.z + q.z;\n    return r;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r.y = col.y + q.y;\n    r.z = col.z + q.z;\n    return r;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r.y = col.y + q.y;\n    r.z = col.z + q.z;\n    return r;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r.y = col.y + q.y;\n    r.z = col.z + q.z;\n    return r;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r.y = col.y + q.y;\n    r.z = col.z + q.z;\n    return r;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = col.x + q.x;\n    r", "\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 out = vec2(0, 0);\n    out.x = p.x - size.x;\n    out.y = p.y - size.y;\n    return out;\n}\n\nvec2 mod2(vec2 p, vec2 size) {", "\n    return uv.x * uv.x + uv.y * uv.y;\n}\n\n// Function: Get the index of the closest point in the grid\nint getIndex(vec2 uv, vec2 grid[]) {\n    int i = 0;\n    for (int j = 0; j < grid.size(); j++) {\n        if (hash(uv) == hash(grid[j])) {\n            i = j;\n            break;\n        }\n    }\n    return i;\n}\n\n// Function: Get the index of the closest point in the grid\nint getIndex(vec2 uv, vec2 grid[], int n) {\n    int i = 0;\n    for (int j = 0; j < n; j++) {\n        if (hash(uv) == hash(grid[j])) {\n            i = j;\n            break;\n        }\n    }\n    return i;\n}\n\n// Function: Get the index of the closest point in the grid\nint getIndex(vec2 uv, vec2 grid[], int n, int m) {\n    int i = 0;\n    for (int j = 0; j < n; j++) {\n        if (hash(uv) == hash(grid[j])) {\n            i = j;\n            break;\n        }\n    }\n    return i;\n}\n\n// Function: Get the index of the closest point in the grid\nint getIndex(vec2 uv, vec2 grid[], int n, int m, int k) {\n    int i = 0;\n    for (int j = 0; j < n; j++) {\n        if (hash(uv) == hash(grid[j])) {\n            i = j;\n            break;\n        }\n    }\n    return i;\n}\n\n// Function: Get the index of the closest point in the grid\nint getIndex(vec2 uv, vec2 grid[], int n, int m, int k, int l) {\n    int i = 0;\n    for (int j = 0; j < n; j++) {\n        if (hash(uv) == hash(grid[j])) {\n            i = j;\n            ", "\n    return sqrt( pow( c.x - p.x, 2 ) + pow( c.y - p.y, 2 ) );\n}\n\n// signed distance to a line\nfloat sdLine( in vec2 p, in vec2 c, in vec2 d )\n{\n    return sqrt( pow( c.x - p.x, 2 ) + pow( c.y - p.y, 2 ) + pow( d.x - p.x, 2 ) + pow( d.y - p.y, 2 ) );\n}\n\n// signed distance to a point\nfloat sdPoint( in vec2 p, in vec2 c, in vec2 d )\n{\n    return sqrt( pow( c.x - p.x, 2 ) + pow( c.y - p.y, 2 ) );\n}\n\n// signed distance to a line segment\nfloat sdLineSegment( in vec2 p, in vec2 c, in vec2 d )\n{\n    return sqrt( pow( c.x - p.x, 2 ) + pow( c.y - p.y, 2 ) + pow( d.x - p.x, 2 ) + pow( d.y - p.y, 2 ) );\n}\n\n// signed distance to a point on a line\nfloat sdPointOnLineSegment( in vec2 p, in vec2 c, in vec2 d )\n{\n    return sqrt( pow( c.x - p.x, 2 ) + pow( c.y - p.y, 2 ) + pow( d.x - p.x, 2 ) + pow( d.y - p.y, 2 ) );\n}\n\n// signed distance to a point on a line segment\nfloat sdPointOnLineSegment( in vec2 p, in vec2 c, in vec2 d )\n{\n    return sqrt( pow( c.x - p.x, 2 ) + pow( c.y - p.y, 2 ) + pow( d.x - p.x, 2 ) + pow( d.y - p.y, 2 ) );\n}\n\n// signed distance to a point on a circle\nfloat sdPointOnCircle( in vec2 p, in vec2 c, in float r )\n{\n", "\n    float d = b - a;\n    float s = sqrt( d.x * d.x + d.y * d.y );\n    return s;\n}\n\n// distance to a point\nfloat sdPoint( in vec2 p, in vec2 a )\n{\n    float d = a - p;\n    return sqrt( d.x * d.x + d.y * d.y );\n}\n\n// distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = b - a;\n    float s = sdSegment( p, a, b );\n    return s;\n}\n\n// distance to a point on a line\nfloat sdPointOnLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = b - a;\n    float s = sdSegment( p, a, b );\n    return s * s + sdPoint( p, a ) * sdPoint( p, b );\n}\n\n// distance to a point on a line segment\nfloat sdPointOnSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = b - a;\n    float s = sdSegment( p, a, b );\n    return s * s + sdPoint( p, a ) * sdPoint( p, b );\n}\n\n// distance to a point on a line segment\nfloat sdPointOnLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = b - a;\n    float s = sdSegment( p, a, b );\n    return s * s + sdPoint( p, a ) * sdPoint( p, b );\n}\n\n// distance to a point on a line\nfloat sdPointOnLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    float d = b - a;\n    float s = sdSegment( p, a, b );\n    return s * s + sdPoint( p, a ) * sdPoint( p, b );\n}\n\n// distance to a point on a line segment\nfloat sdPointOnLineSegment( in vec", "\n    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) );\n}\n\n// signed distance to a 2D triangle\nfloat tri(in vec2 a, in vec2 b, in vec2 c ) {\n    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y) );\n}\n\n// signed distance to a 2D triangle\nfloat tri2(in vec2 a, in vec2 b, in vec2 c ) {\n    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y) );\n}\n\n// signed distance to a 2D triangle\nfloat tri3(in vec2 a, in vec2 b, in vec2 c ) {\n    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y) );\n}\n\n// signed distance to a 2D triangle\nfloat tri4(in vec2 a, in vec2 b, in vec2 c ) {\n    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (", "\n    vec2 p2 = p + vec2( s, 0 );\n    vec2 p3 = p2 + vec2( s, r );\n    vec2 p4 = p3 + vec2( s, 0 );\n    vec2 p5 = p4 + vec2( s, r );\n    vec2 p6 = p5 + vec2( s, 0 );\n    vec2 p7 = p6 + vec2( s, r );\n    vec2 p8 = p7 + vec2( s, 0 );\n    vec2 p9 = p8 + vec2( s, r );\n    vec2 p10 = p9 + vec2( s, 0 );\n    vec2 p11 = p10 + vec2( s, r );\n    vec2 p12 = p11 + vec2( s, 0 );\n    vec2 p13 = p12 + vec2( s, r );\n    vec2 p14 = p13 + vec2( s, 0 );\n    vec2 p15 = p14 + vec2( s, r );\n    vec2 p16 = p15 + vec2( s, 0 );\n    vec2 p17 = p16 + vec2( s, r );\n    vec2 p18 = p17 + vec2( s, 0 );\n    vec2 p19 = p18 + vec2( s, r );\n    vec2 p20 = p19 + vec2( s, 0 );\n    vec2 p21 = p20 + vec2( s, r );\n    vec2 p22 = p21 + vec2( s, 0 );\n    vec2 p23 = p22 + vec2( s, r );\n    vec2 p24 = p23 + vec2( s, 0 );\n    vec2 p25 = p24 + vec2( s, r );\n    vec2 p26 = p25 + vec2( s, 0 );\n    vec2 p27 = p26 + vec2( s, r );\n    vec2 p28 = p27 + vec2( s, 0 );\n    vec2 p29 = p28 + vec2( s, r );\n    vec2 p30 = p29 + vec2( s, 0 );\n    vec2 p31 = p30 + vec2( s, r );\n    vec", "\n    vec3 s = vec3(0, 0, 0);\n    s.x = x.x;\n    s.y = x.y;\n    s.z = x.z;\n    return s;\n}\n\nvec3 s_curve_inverse(vec3 x)\n{\n    vec3 s = vec3(0, 0, 0);\n    s.x = -x.x;\n    s.y = -x.y;\n    s.z = -x.z;\n    return s;\n}\n\nvec3 s_curve_inverse_inverse(vec3 x)\n{\n    vec3 s = vec3(0, 0, 0);\n    s.x = -x.x;\n    s.y = -x.y;\n    s.z = -x.z;\n    return s;\n}\n\nvec3 s_curve_inverse_inverse_inverse(vec3 x)\n{\n    vec3 s = vec3(0, 0, 0);\n    s.x = -x.x;\n    s.y = -x.y;\n    s.z = -x.z;\n    return s;\n}\n\nvec3 s_curve_inverse_inverse_inverse(vec3 x)\n{\n    vec3 s = vec3(0, 0, 0);\n    s.x = -x.x;\n    s.y = -x.y;\n    s.z = -x.z;\n    return s;\n}\n\nvec3 s_curve_inverse_inverse_inverse(vec3 x)\n{\n    vec3 s = vec3(0, 0, 0);\n    s.x = -x.x;\n    s.y = -x.y;\n    s.z = -x.z;\n    return s;\n}\n\nvec3 s_curve_inverse_inverse_inverse(vec3 x)\n{\n    vec3 s = vec3(0, 0, 0);\n    s.x = -x.x;\n    s.y = -x.y;\n    s.z = -x.z;\n    ", "\n    vec3 d_s = vec3(0, 0, 0);\n    d_s.x = x.y;\n    d_s.y = -x.z;\n    d_s.z = x.x;\n    return d_s;\n}\n\nvec3 d_s_curve_derivative(vec3 x)\n{\n    vec3 d_s = vec3(0, 0, 0);\n    d_s.x = -x.y;\n    d_s.y = x.z;\n    d_s.z = -x.x;\n    return d_s;\n}\n\nvec3 d_s_curve_derivative_derivative(vec3 x)\n{\n    vec3 d_s = vec3(0, 0, 0);\n    d_s.x = -x.y;\n    d_s.y = -x.z;\n    d_s.z = x.x;\n    return d_s;\n}\n\nvec3 d_s_curve_derivative_derivative_derivative(vec3 x)\n{\n    vec3 d_s = vec3(0, 0, 0);\n    d_s.x = -x.y;\n    d_s.y = -x.z;\n    d_s.z = -x.x;\n    d_s.x = -x.y;\n    return d_s;\n}\n\nvec3 d_s_curve_derivative_derivative_derivative_derivative(vec3 x)\n{\n    vec3 d_s = vec3(0, 0, 0);\n    d_s.x = -x.y;\n    d_s.y = -x.z;\n    d_s.z = -x.x;\n    d_s.x = -x.y;\n    d_s.y = -x.z;\n    d_s.z = -x.x;\n    d_s.x = -x.y;\n    d_s.y = -x.z;\n    d_s.z = -x.x;\n", "\n    float r = w / 2.0;\n    float s = k * r;\n    float t = w / 2.0;\n    float d = w / 2.0;\n    float r2 = r * r;\n    float s2 = s * s;\n    float t2 = t * t;\n    float d2 = d * d;\n    float r3 = r2 + s2;\n    float s3 = s2 + t2;\n    float t3 = t2 + d2;\n    float r4 = r3 + s3;\n    float s4 = s3 + t3;\n    float t4 = t3 + d3;\n    float r5 = r4 + s4;\n    float s5 = s4 + t4;\n    float t5 = t4 + d4;\n    float r6 = r5 + s5;\n    float s6 = s5 + t5;\n    float t6 = t5 + d5;\n    float r7 = r6 + s6;\n    float s7 = s6 + t6;\n    float t7 = t6 + d6;\n    float r8 = r7 + s7;\n    float s8 = s7 + t7;\n    float t8 = t7 + d7;\n    float r9 = r8 + s8;\n    float s9 = s8 + t8;\n    float t9 = t8 + d8;\n    float r10 = r9 + s9;\n    float s10 = s9 + t9;\n    float t10 = t9 + d9;\n    float r11 = r10 + s10;\n    float s11 = s10 + t10;\n    float t11 = t10 + d10;\n    float r12 = r11 + s11;\n    float s12 = s11 + t11;\n    float t12 = t11 + d11;\n    float r13 = r12 + s12;\n    float s13 = s12 + t12;\n    float t13 = t12 + d12;\n    float r14 = r13 + s13;\n    float s14 = s13 + t13;\n    float t14 = t13 + d", "\n    vec3 luminance = 1.0 - opticalDepth;\n    return luminance;\n}\n\nvec3 Reflect(vec3 opticalDepth)\n{\n    vec3 luminance = opticalDepth;\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Absorb(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(opticalDepth);\n    return luminance;\n}\n\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 luminance = Reflect(optical", "\n    vec3 lightDir = lightDir / lightDir.length();\n    vec3 lightDirNormalized = lightDir / lightDir.length();\n    vec3 lightDirCrossProduct = lightDirNormalized.cross(rayDir);\n    vec3 lightDirCrossProductNormalized = lightDirCrossProduct / lightDirCrossProduct.length();\n    vec3 lightDirCrossProductNormalizedUnit = lightDirCrossProductNormalized / lightDirCrossProductNormalized.length();\n    vec3 lightDirCrossProductNormalizedUnitUnit = lightDirCrossProductNormalizedUnit / lightDirCrossProductNormalizedUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnit = lightDirCrossProductNormalizedUnitUnit / lightDirCrossProductNormalizedUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnitUnit = lightDirCrossProductNormalizedUnitUnitUnit / lightDirCrossProductNormalizedUnitUnitUnit.length();\n    vec3 lightDirCrossProductNormalizedUnitUnitUnit", "\n    float r = ra + rb;\n    float s = sqrt( (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra) );\n    float t = s - d;\n    float u = (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra);\n    float v = (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra);\n    float w = (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra);\n    float x = (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra);\n    float y = (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra);\n    float z = (p2.x - ra) * (p2.x - ra) + (p2.y - ra) * (p2.y - ra) + (p2.z - ra) * (p2.z - ra);\n    float d = sqrt( (u - v) * (u - v) + (w - x) * (w - x) + (y - z) * (y - z) );\n    return d;\n}\n\nvoid main()\n{\n    vec3 p1 = vec3(0.0, 0.0, 0.0);\n    vec", "\n    vec3 p1 = p + vec3(0, 0, t);\n    vec3 p2 = p + vec3(0, 0, -t);\n    vec3 p3 = p + vec3(0, 0, t);\n    vec3 p4 = p + vec3(0, 0, -t);\n    vec3 p5 = p + vec3(0, 0, t);\n    vec3 p6 = p + vec3(0, 0, -t);\n    vec3 p7 = p + vec3(0, 0, t);\n    vec3 p8 = p + vec3(0, 0, -t);\n    vec3 p9 = p + vec3(0, 0, t);\n    vec3 p10 = p + vec3(0, 0, -t);\n    vec3 p11 = p + vec3(0, 0, t);\n    vec3 p12 = p + vec3(0, 0, t);\n    vec3 p13 = p + vec3(0, 0, t);\n    vec3 p14 = p + vec3(0, 0, t);\n    vec3 p15 = p + vec3(0, 0, t);\n    vec3 p16 = p + vec3(0, 0, t);\n    vec3 p17 = p + vec3(0, 0, t);\n    vec3 p18 = p + vec3(0, 0, t);\n    vec3 p19 = p + vec3(0, 0, t);\n    vec3 p20 = p + vec3(0, 0, t);\n    vec3 p21 = p + vec3(0, 0, t);\n    vec3 p22 = p + vec3(0, 0, t);\n    vec3 p23 = p + vec3(0, 0, t);\n    vec3 p24 = p + vec3(0, 0, t);\n    vec3 p25 = p + vec3(0, 0, t);\n    vec3 p26 = p + vec3(0, 0, t);\n    vec3 p27 = p + vec3(0, 0, t);\n    vec3 p28 = p + vec3(0, 0, t);\n    vec", "\n    float s = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float sigma = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n    float tt = 0.0f;\n    float uu = 0.0f;\n    float vv = 0.0f;\n    float ww = 0.0f;\n    float xx = 0.0f;\n    float yy = 0.0f;\n    float zz = 0.0f;\n    float tt2 = 0.0f;\n    float uu2 = 0.0f;\n    float vv2 = 0.0f;\n    float ww2 = 0.0f;\n    float xx2 = 0.0f;\n    float yy2 = 0.0f;\n    float zz2 = 0.0f;\n    float tt3 = 0.0f;\n    float uu3 = 0.0f;\n    float vv3 = 0.0f;\n    float ww3 = 0.0f;\n    float xx3 = 0.0f;\n    float yy3 = 0.0f;\n    float zz3 = 0.0f;\n    float tt4 = 0.0f;\n    float uu4 = 0.0f;\n    ", "\n    vec3 p1 = p + h;\n    vec3 p2 = p - h;\n    vec3 p3 = p - r;\n    vec3 p4 = p + r;\n    vec3 p5 = p - r;\n    vec3 p6 = p + r;\n    vec3 p7 = p - r;\n    vec3 p8 = p + r;\n    vec3 p9 = p - r;\n    vec3 p10 = p + r;\n    vec3 p11 = p - r;\n    vec3 p12 = p + r;\n    vec3 p13 = p - r;\n    vec3 p14 = p + r;\n    vec3 p15 = p - r;\n    vec3 p16 = p + r;\n    vec3 p17 = p - r;\n    vec3 p18 = p + r;\n    vec3 p19 = p - r;\n    vec3 p20 = p + r;\n    vec3 p21 = p - r;\n    vec3 p22 = p + r;\n    vec3 p23 = p - r;\n    vec3 p24 = p + r;\n    vec3 p25 = p - r;\n    vec3 p26 = p + r;\n    vec3 p27 = p - r;\n    vec3 p28 = p + r;\n    vec3 p29 = p - r;\n    vec3 p30 = p + r;\n    vec3 p31 = p - r;\n    vec3 p32 = p + r;\n    vec3 p33 = p - r;\n    vec3 p34 = p + r;\n    vec3 p35 = p - r;\n    vec3 p36 = p + r;\n    vec3 p37 = p - r;\n    vec3 p38 = p + r;\n    vec3 p39 = p - r;\n    vec3 p40 = p + r;\n    vec3 p41 = p - r;\n    vec3 p42 = p + r;\n    vec3 p43 = p - r;\n    vec3 p44 = p + r;\n    vec3 p45 = p - r;\n    vec3 p46 = p + r;\n    vec3 p47", "\n    vec3 n = normalize( cross( pos.xyz, vec3( 0.0, 0.0, 1.0 ) ) );\n    return n;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 m = normalize( n );\n    return m;\n}\n\nvec3 normalize(", "\n    vec2 p1 = p + vec2( r, 0.0 );\n    vec2 p2 = p + vec2( 0.0, h );\n    vec2 p3 = p + vec2( -r, 0.0 );\n    vec2 p4 = p + vec2( 0.0, -h );\n    vec2 p5 = p + vec2( r, -h );\n    vec2 p6 = p + vec2( 0.0, -r );\n    vec2 p7 = p + vec2( -r, r );\n    vec2 p8 = p + vec2( 0.0, r );\n    vec2 p9 = p + vec2( r, 0.0 );\n    vec2 p10 = p + vec2( 0.0, -r );\n    vec2 p11 = p + vec2( -r, -r );\n    vec2 p12 = p + vec2( -r, r );\n    vec2 p13 = p + vec2( r, -r );\n    vec2 p14 = p + vec2( r, r );\n    vec2 p15 = p + vec2( 0.0, -r );\n    vec2 p16 = p + vec2( 0.0, r );\n    vec2 p17 = p + vec2( -r, 0.0 );\n    vec2 p18 = p + vec2( 0.0, r );\n    vec2 p19 = p + vec2( r, 0.0 );\n    vec2 p20 = p + vec2( 0.0, -r );\n    vec2 p21 = p + vec2( -r, -r );\n    vec2 p22 = p + vec2( -r, r );\n    vec2 p23 = p + vec2( r, -r );\n    vec2 p24 = p + vec2( r, r );\n    vec2 p25 = p + vec2( 0.0, -r );\n    vec2 p26 = p + vec2( 0.0, r );\n    vec2 p27 = p + vec2( -r, -r );\n    vec2 p28 = p + vec2( -r, r );\n    vec2 p29 = p + vec2", "\n    vec3 y = vec3( x.x, x.y, x.z );\n    float r = sqrt( y.x * y.x + y.y * y.y + y.z * y.z );\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r;\n    float r40 = r39 * r;\n    float r41 = r40 * r;\n    float r42 = r41 * r;\n    float r43 = r42 *", "\n    vec3 r = vec3( 0.0, 0.0, 0.0 );\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float d =", "\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x1f) % 0x1f;\n}\n\nfloat hash32(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x2f) % 0x1f;\n}\n\nfloat hash33(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x3f) % 0x1f;\n}\n\nfloat hash34(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x4f) % 0x1f;\n}\n\nfloat hash35(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x5f) % 0x1f;\n}\n\nfloat hash36(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x6f) % 0x1f;\n}\n\nfloat hash37(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x7f) % 0x1f;\n}\n\nfloat hash38(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3f + 0x9f) % 0x1f;\n}\n\nfloat hash39(vec3 p3)\n{\n    return (p3.x * 0x1f + p3.y * 0x3f + p3.z * 0x3", "\n    vec2 fragCoord = fragCoord.xy;\n    vec2 fragCoord2 = fragCoord + vec2(0.5, 0.5);\n    vec2 fragCoord3 = fragCoord + vec2(0.5, -0.5);\n    vec2 fragCoord4 = fragCoord + vec2(-0.5, -0.5);\n    vec2 fragCoord5 = fragCoord + vec2(-0.5, 0.5);\n    vec2 fragCoord6 = fragCoord + vec2(0.5, 0.5);\n    vec2 fragCoord7 = fragCoord + vec2(0.5, -0.5);\n    vec2 fragCoord8 = fragCoord + vec2(-0.5, -0.5);\n    vec2 fragCoord9 = fragCoord + vec2(-0.5, 0.5);\n    vec2 fragCoord10 = fragCoord + vec2(0.5, 0.5);\n    vec2 fragCoord11 = fragCoord + vec2(0.5, -0.5);\n    vec2 fragCoord12 = fragCoord + vec2(-0.5, -0.5);\n    vec2 fragCoord13 = fragCoord + vec2(-0.5, 0.5);\n    vec2 fragCoord14 = fragCoord + vec2(0.5, 0.5);\n    vec2 fragCoord15 = fragCoord + vec2(0.5, -0.5);\n    vec2 fragCoord16 = fragCoord + vec2(-0.5, -0.5);\n    vec2 fragCoord17 = fragCoord + vec2(-0.5, 0.5);\n    vec2 fragCoord18 = fragCoord + vec2(0.5, 0.5);\n    vec2 fragCoord19 = fragCoord + vec2(0.5, -0.5);\n    vec2 fragCoord20 = fragCoord + vec2(-0.5, -0.5);\n    vec2 fragCoord21 = fragCoord + vec2(-0.5, 0.5);\n    vec2 fragCoord22", "\n    vec3 r = vec3(0, 0, 0);\n    vec3 g = vec3(0, 0, 0);\n    vec3 b = vec3(0, 0, 0);\n    vec3 h = vec3(0, 0, 0);\n    vec3 s = vec3(0, 0, 0);\n    vec3 v = vec3(0, 0, 0);\n\n    if (c.x < 0) {\n        c.x = 0;\n        s = 1;\n        v = c.y;\n        g = c.z;\n        b = 0;\n    } else if (c.x > 1) {\n        c.x = 1;\n        s = 0;\n        v = c.y;\n        g = c.z;\n        b = 1;\n    } else {\n        c.x = 0.5;\n        s = (c.y < 0.5)? 1 : 0;\n        v = c.z;\n        g = 0;\n        b = 0;\n    }\n\n    if (c.y < 0) {\n        c.y = 0;\n        s = 1;\n        v = c.x;\n        g = c.z;\n        b = 0;\n    } else if (c.y > 1) {\n        c.y = 1;\n        s = 0;\n        v = c.x;\n        g = c.z;\n        b = 1;\n    } else {\n        c.y = 0.5;\n        s = (c.x < 0.5)? 1 : 0;\n        v = c.z;\n        g = 0;\n        b = 0;\n    }\n\n    if (c.z < 0) {\n        c.z = 0;\n        s = 1;\n        v = c.y;\n        g = c.x;\n        b = 0;\n    } else if (c.z > 1) {\n        c.z = 1;\n        s = 0;\n        v = c.y;\n        g = c.x;\n        b = 1;\n    } else {\n        c.z = 0.5;\n        s = (c.", "\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod2(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod3(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod4(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod5(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod6(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod7(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod8(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod9(inout float p, float size) {\n    float r = 0.0;\n    for (int i = 0; i < size; i++) {\n        r += p * p;\n    }\n    return r;\n}\n\nfloat mod10", "\n    return co * co;\n}\n\nint main() {\n    float co[3] = { 1.0, 2.0, 3.0 };\n    int i;\n    for (i = 0; i < 3; i++) {\n        printf(\"%f\\n\", hash(co[i]));\n    }\n    return 0;\n}\n\nA:\n\nThe problem is that you are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for each element.\n\nA:\n\nYou are using the same hash function for all the elements of the array.\nYou should use a different hash function for", "\n    return t * 0.0031308;\n}\n\nint main() {\n    int i;\n    for (i = 0; i < 256; i++) {\n        printf(\"%d: %f\\n\", i, sRGB(i));\n    }\n    return 0;\n}\n\nA:\n\nThe problem is that you are using the wrong type for the conversion.\nThe sRGB function expects a float, but you are passing an int.\nYou can fix this by changing the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a float.\nYou need to change the type of the argument to float.\n\nA:\n\nYou are passing an int to sRGB, which is not a", "\n    vec3 r = vec3(0.299, 0.587, 0.114);\n    vec3 g = vec3(0.596, -0.274, -0.322);\n    vec3 b = vec3(0.211, -0.523, -0.311);\n    return vec3(c.x * r, c.y * g, c.z * b);\n}\n\nvec3 normalize(vec3 v) {\n    return v / length(v);\n}\n\nvec3 dot(vec3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 cross(vec3 a, vec3 b) {\n    return vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nvec3 normalize(vec3 v) {\n    return v / length(v);\n}\n\nvec3 dot(vec3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 cross(vec3 a, vec3 b) {\n    return vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nvec3 normalize(vec3 v) {\n    return v / length(v);\n}\n\nvec3 dot(vec3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 cross(vec3 a, vec3 b) {\n    return vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nvec3 normal", "\n    return a - (b - a) * (k - 1.0f) / (k + 1.0f);\n}\n\nfloat pmax(float a, float b, float k) {\n    return a + (b - a) * (k - 1.0f) / (k + 1.0f);\n}\n\nfloat pmean(float a, float b, float k) {\n    return (a + b) / 2.0f;\n}\n\nfloat pvariance(float a, float b, float k) {\n    return (a - pmean(a, b, k)) * (a - pmean(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(", "\n    vec3 r = rd - ro;\n    float d = sqrt(dot(r, r));\n    float s = dot(r, sph);\n    float c = dot(r, sph);\n    float a = (1.0 - s) / d;\n    float b = (s * s - c * c) / (2.0 * d);\n    float c = (2.0 * s * c - a * d) / (1.0 - s);\n    float d = (2.0 * s * d + a * c) / (1.0 - s);\n    float e = (1.0 - s) / d;\n    float f = (s * s - c * c) / (2.0 * d);\n    float g = (2.0 * s * g - a * d) / (1.0 - s);\n    float h = (2.0 * s * h - a * c) / (1.0 - s);\n    float i = (1.0 - s) / d;\n    float j = (s * s - c * c) / (2.0 * d);\n    float k = (2.0 * s * k - a * c) / (1.0 - s);\n    float l = (2.0 * s * l - a * d) / (1.0 - s);\n    float m = (1.0 - s) / d;\n    float n = (s * s - c * c) / (2.0 * d);\n    float o = (s * s - c * c) / (1.0 - s);\n    float p = (2.0 * s * p - a * d) / (1.0 - s);\n    float q = (2.0 * s * q - a * c) / (1.0 - s);\n    float r = (1.0 - s) / d;\n    float s = (s * s - c * c) / (2.0 * d);\n    float t = (s * s - c * c) / (1.0 - s);\n    float u = (s * s - c * c) / (1.0 - s);\n    float v", "\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    result.x = p.x * 0.5 + 0.5;\n    result.y = p.y * 0.5 + 0.5;\n    result.z = p.z * 0.5 + 0.5;\n    result.w = p.w * 0.5 + 0.5;\n    return result;\n}\n\nvec4 apply_transform(vec4 p, vec4 t) {\n    return formula(p) * t;\n}\n\nvec4 apply_transform_to_surface(vec4 p, vec4 t) {\n    return apply_transform(p, t);\n}\n\nvec4 apply_transform_to_surface_to_surface(vec4 p, vec4 t) {\n    return apply_transform(p, t, t);\n}\n\nvec4 apply_transform_to_surface_to_surface_to_surface(vec4 p, vec4 t, vec4 t2) {\n    return apply_transform(p, t, t2);\n}\n\nvec4 apply_transform_to_surface_to_surface_to_surface_to_surface(vec4 p, vec4 t, vec4 t2, vec4 t3) {\n    return apply_transform(p, t, t2, t3);\n}\n\nvec4 apply_transform_to_surface_to_surface_to_surface_to_surface(vec4 p, vec4 t, vec4 t2, vec4 t3, vec4 t4) {\n    return apply_transform(p, t, t2, t3, t4);\n}\n\nvec4 apply_transform_to_surface_to_surface_to_surface_to_surface_to_surface(vec4 p, vec4 t, vec4 t2, vec4 t3, vec4 t4, vec4 t5) {\n    return apply_transform(p, t, t2, t3, t4, t5);\n}\n\nvec4 apply_transform_to_surface_to_surface_to_surface_to_surface_to_surface_to_surface(vec4 p, vec4 t, vec", "\n    vec3 p0 = p - r;\n    vec3 p1 = p + r;\n    vec3 p2 = p - r;\n    vec3 p3 = p + r;\n    vec3 p4 = p - r;\n    vec3 p5 = p + r;\n    vec3 p6 = p - r;\n    vec3 p7 = p + r;\n    vec3 p8 = p - r;\n    vec3 p9 = p + r;\n    vec3 p10 = p - r;\n    vec3 p11 = p + r;\n    vec3 p12 = p - r;\n    vec3 p13 = p + r;\n    vec3 p14 = p - r;\n    vec3 p15 = p + r;\n    vec3 p16 = p - r;\n    vec3 p17 = p + r;\n    vec3 p18 = p - r;\n    vec3 p19 = p + r;\n    vec3 p20 = p - r;\n    vec3 p21 = p + r;\n    vec3 p22 = p - r;\n    vec3 p23 = p + r;\n    vec3 p24 = p - r;\n    vec3 p25 = p + r;\n    vec3 p26 = p - r;\n    vec3 p27 = p + r;\n    vec3 p28 = p - r;\n    vec3 p29 = p + r;\n    vec3 p30 = p - r;\n    vec3 p31 = p + r;\n    vec3 p32 = p - r;\n    vec3 p33 = p + r;\n    vec3 p34 = p - r;\n    vec3 p35 = p + r;\n    vec3 p36 = p - r;\n    vec3 p37 = p + r;\n    vec3 p38 = p - r;\n    vec3 p39 = p + r;\n    vec3 p40 = p - r;\n    vec3 p41 = p + r;\n    vec3 p42 = p - r;\n    vec3 p43 = p + r;\n    vec3 p44 = p - r;\n    vec3 p45 = p + r;\n    vec3 p46", "\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    float alpha = 0.0;\n    float beta = 0.0;\n    float gamma = 0.0;\n    float delta = 0.0;\n    float epsilon = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float gx = 0.0;\n    float gy = 0.0;\n    float gz = 0.0;\n    float bx = 0.0;\n    float by = 0.0;\n    float bz = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float aa = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    ", "\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = back.x * front.x + back.y * front.y + back.z * front.z;\n    result.y = back.x * front.y + back.y * front.z + back.z * front.x;\n    result.z = back.x * front.z + back.y * front.x + back.z * front.y;\n    return result;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = back.x * front.x + back.y * front.y + back.z * front.z;\n    result.y = back.x * front.y + back.y * front.z + back.z * front.x;\n    result.z = back.x * front.z + back.y * front.x + back.z * front.y;\n    return result;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = back.x * front.x + back.y * front.y + back.z * front.z;\n    result.y = back.x * front.y + back.y * front.z + back.z * front.x;\n    result.z = back.x * front.z + back.y * front.x + back.z * front.y;\n    return result;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = back.x * front.x + back.y * front.y + back.z * front.z;\n    result.y = back.x * front.y + back.y * front.z + back.z * front.x;\n    result.z = back.x * front.z + back.y * front.x + back.z *", "\n    float x = p.x;\n    float y = p.y;\n    float z = r;\n    float s = sqrt(x*x + y*y + z*z);\n    float t = (x*y*z)/s;\n    float u = (x*z*y)/s;\n    float v = (y*z*x)/s;\n    float w = (x*y*z)/s;\n    float x1 = x*x;\n    float y1 = y*y;\n    float z1 = z*z;\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n    float x3 = x*x;\n    float y3 = y*y;\n    float z3 = z*z;\n    float x4 = x*x;\n    float y4 = y*y;\n    float z4 = z*z;\n    float x5 = x*x;\n    float y5 = y*y;\n    float z5 = z*z;\n    float x6 = x*x;\n    float y6 = y*y;\n    float z6 = z*z;\n    float x7 = x*x;\n    float y7 = y*y;\n    float z7 = z*z;\n    float x8 = x*x;\n    float y8 = y*y;\n    float z8 = z*z;\n    float x9 = x*x;\n    float y9 = y*y;\n    float z9 = z*z;\n    float x10 = x*x;\n    float y10 = y*y;\n    float z10 = z*z;\n    float x11 = x*x;\n    float y11 = y*y;\n    float z11 = z*z;\n    float x12 = x*x;\n    float y12 = y*y;\n    float z12 = z*z;\n    float x13 = x*x;\n    float y13 = y*y;\n    float z13 = z*z;\n    float x14 = x*x;\n    float y14 = y*y;\n", "\n    vec3 a = vec3(0, 0, 0);\n    vec3 b = vec3(0, 0, 0);\n    vec3 c = vec3(0, 0, 0);\n    vec3 d = vec3(0, 0, 0);\n    vec3 e = vec3(0, 0, 0);\n    vec3 f = vec3(0, 0, 0);\n    vec3 g = vec3(0, 0, 0);\n    vec3 h = vec3(0, 0, 0);\n    vec3 i = vec3(0, 0, 0);\n    vec3 j = vec3(0, 0, 0);\n    vec3 k = vec3(0, 0, 0);\n    vec3 l = vec3(0, 0, 0);\n    vec3 m = vec3(0, 0, 0);\n    vec3 n = vec3(0, 0, 0);\n    vec3 o = vec3(0, 0, 0);\n    vec3 p = vec3(0, 0, 0);\n    vec3 q = vec3(0, 0, 0);\n    vec3 r = vec3(0, 0, 0);\n    vec3 s = vec3(0, 0, 0);\n    vec3 t = vec3(0, 0, 0);\n    vec3 u = vec3(0, 0, 0);\n    vec3 v = vec3(0, 0, 0);\n    vec3 w = vec3(0, 0, 0);\n    vec3 x = vec3(0, 0, 0);\n    vec3 y = vec3(0, 0, 0);\n    vec3 z = vec3(0, 0, 0);\n    vec3 a1 = vec3(0, 0, 0);\n    vec3 a2 = vec3(0, 0, 0);\n    vec3 a3 = vec3(0, 0, 0);\n    vec3 a4 = vec3(0, 0, 0);\n    vec3 a5 = vec3(0, 0, 0);\n    vec3 a6 = vec3(0, 0, 0);\n    vec3 a7 = vec3(0, 0, 0);\n    vec3 a8 = vec3(", "\n    return p.x + p.y;\n}\n\nvec2 hash3(vec2 p) {\n    return p.x * p.x + p.y * p.y;\n}\n\nvec2 hash4(vec2 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nvec2 hash5(vec2 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z + p.w * p.w;\n}\n\nvec2 hash6(vec2 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z + p.w * p.w + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x;\n}\n\nvec2 hash7(vec2 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z + p.w * p.w + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w + p.w * p.x + p.x * p.y + p.y * p.z + p.z * p.w +", "\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r.x = 1.0 / (Temp * Temp);\n    r.y = 1.0 / (Temp * Temp);\n    r.z = 1.0 / (Temp * Temp);\n    return r;\n}\n\nvec3 whitebody(float Temp) {\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r.x = 1.0 / (Temp * Temp);\n    r.y = 1.0 / (Temp * Temp);\n    r.z = 1.0 / (Temp * Temp);\n    return r;\n}\n\nvec3 diffuse(vec3 src, vec3 ref, vec3 tgt) {\n    vec3 r = src + (ref - src) * tgt;\n    return r;\n}\n\nvec3 specular(vec3 src, vec3 ref, vec3 tgt) {\n    vec3 r = src + (ref - src) * tgt;\n    r.x = (ref.x * ref.x + ref.y * ref.y + ref.z * ref.z) * tgt.x + (src.x * src.x + src.y * src.y + src.z * src.z) * (1.0 - tgt.x);\n    r.y = (ref.x * ref.y + ref.y * ref.z + ref.z * ref.x) * tgt.y + (src.x * src.y + src.y * src.z + src.z * src.x) * (1.0 - tgt.y);\n    r.z = (ref.x * ref.z + ref.z * ref.y + ref.y * ref.x) * tgt.z + (src.x * src.z + src.z * src.y + src.y * src.x) * (1.0 - tgt.z);\n    return r;\n}\n\nvec3 ambient(vec3 src) {\n    vec3 r = src;\n    r.x = src.x;\n    r.y = src.y;\n    r.z = src.", "\n    float r = 0;\n    float s = 0;\n    float t = 0;\n    float u = 0;\n    float v = 0;\n    float w = 0;\n    float x = 0;\n    float y = 0;\n    float z = 0;\n    float rho = 0;\n    float theta = 0;\n    float phi = 0;\n    float x_dot = 0;\n    float y_dot = 0;\n    float z_dot = 0;\n    float x_dot_dot = 0;\n    float y_dot_dot = 0;\n    float z_dot_dot = 0;\n    float x_dot_dot_dot = 0;\n    float y_dot_dot_dot = 0;\n    float z_dot_dot_dot = 0;\n    float x_dot_dot_dot_dot = 0;\n    float y_dot_dot_dot_dot = 0;\n    float z_dot_dot_dot_dot = 0;\n    float x_dot_dot_dot_dot_dot = 0;\n    float y_dot_dot_dot_dot_dot = 0;\n    float z_dot_dot_dot_dot_dot = 0;\n    float x_dot_dot_dot_dot_dot_dot = 0;\n    float y_dot_dot_dot_dot_dot_dot = 0;\n    float z_dot_dot_dot_dot_dot_dot = 0;\n    float x_dot_dot_dot_dot_dot_dot_dot = 0;\n    float y_dot_dot_dot_dot_dot_dot_dot = 0;\n    float z_dot_dot_dot_dot_dot_dot_dot = 0;\n    float x_dot_dot_dot_dot_dot_dot_dot_dot = 0;\n    float y_dot_dot_dot_dot_dot_dot_dot_dot = 0;\n    float z_dot_dot_dot_dot_dot_dot_dot_dot = 0;\n    float x_dot_dot_dot_dot_dot_dot_dot_dot_dot = 0;\n    float y_dot_dot_dot_dot_dot_dot", "\n    vec3 p = sph.xyz;\n    vec3 p1 = p - rd;\n    vec3 p2 = p - ro;\n    vec3 p3 = p - ro + rd;\n    vec3 p4 = p - ro + rd + rd;\n    vec3 p5 = p - ro + rd + rd + rd;\n    vec3 p6 = p - ro + rd + rd + rd + rd;\n    vec3 p7 = p - ro + rd + rd + rd + rd + rd;\n    vec3 p8 = p - ro + rd + rd + rd + rd + rd + rd;\n    vec3 p9 = p - ro + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p10 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p11 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p12 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p13 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p14 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p15 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p16 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p17 = p - ro + rd + rd + rd + rd + rd + rd + rd + rd + rd + rd;\n    vec3 p18", "\n    vec3 v = p;\n    vec3 v2 = p.cross(p);\n    vec3 v3 = v2.cross(p);\n    vec3 v4 = v3.cross(p);\n    vec3 v5 = v4.cross(p);\n    vec3 v6 = v5.cross(p);\n    vec3 v7 = v6.cross(p);\n    vec3 v8 = v7.cross(p);\n    vec3 v9 = v8.cross(p);\n    vec3 v10 = v9.cross(p);\n    vec3 v11 = v10.cross(p);\n    vec3 v12 = v11.cross(p);\n    vec3 v13 = v12.cross(p);\n    vec3 v14 = v13.cross(p);\n    vec3 v15 = v14.cross(p);\n    vec3 v16 = v15.cross(p);\n    vec3 v17 = v16.cross(p);\n    vec3 v18 = v17.cross(p);\n    vec3 v19 = v18.cross(p);\n    vec3 v20 = v19.cross(p);\n    vec3 v21 = v20.cross(p);\n    vec3 v22 = v21.cross(p);\n    vec3 v23 = v22.cross(p);\n    vec3 v24 = v23.cross(p);\n    vec3 v25 = v24.cross(p);\n    vec3 v26 = v25.cross(p);\n    vec3 v27 = v26.cross(p);\n    vec3 v28 = v27.cross(p);\n    vec3 v29 = v28.cross(p);\n    vec3 v30 = v29.cross(p);\n    vec3 v31 = v30.cross(p);\n    vec3 v32 = v31.cross(p);\n    vec3 v33 = v32.cross(p);\n    vec3 v34 = v33.cross(p);\n    vec3 v35 = v34.cross(p);\n    vec3 v36 = v35.cross(p);\n    vec3 v37 = v36.cross(p);\n", "\n    if ( t == 0 )\n        return 1.0;\n    else if ( t == 1 )\n        return x;\n    else\n        return ( 2.0 * x * cantor( x, t - 1 ) - cantor( x, t - 2 ) ) / ( t - 1 );\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    float x, t;\n    for ( int i = 0; i < n; i++ )\n    {\n        scanf(\"%f %f\", &x, &t);\n        printf(\"%f\\n\", cantor(x, t));\n    }\n    return 0;\n}\n\nA:\n\nThe problem is that you are not using the value of t in the recursive call.\nYou should change the call to:\nreturn ( 2.0 * x * cantor( x, t - 1 ) - cantor( x, t - 2 ) ) / ( t - 1 );\n\nto:\nreturn ( 2.0 * x * cantor( x, t ) - cantor( x, t - 1 ) ) / ( t - 1 );\n\nA:\n\nYou are not using the value of t in the recursive call.\nChange the call to:\nreturn ( 2.0 * x * cantor( x, t ) - cantor( x, t - 1 ) ) / ( t - 1 );\n\nto:\nreturn ( 2.0 * x * cantor( x, t ) - cantor( x, t - 1 ) ) / ( t - 1 );\n\nA:\n\nYou are not using the value of t in the recursive call.\nChange the call to:\nreturn ( 2.0 * x * cantor( x, t ) - cantor( x, t - 1 ) ) / ( t - 1 );\n\nto:\nreturn ( 2.0 * x * cantor( x, t ) - cantor( x, t - 1 ) ) / ( t - 1 );\n\nA:\n\nYou are not using the value of t in the recursive call.\nChange the call to:\nreturn ( 2.0 * x * cantor( x, t ) - cantor( x, t - 1 ) ) / ( t - 1 );", "\n    vec2 p1 = a - p;\n    vec2 p2 = b - p;\n    vec2 p3 = p1 + p2;\n    vec2 p4 = p2 - p1;\n    vec2 p5 = p3 - p4;\n    vec2 p6 = p4 - p3;\n    vec2 p7 = p5 - p6;\n    vec2 p8 = p6 - p5;\n    vec2 p9 = p7 - p8;\n    vec2 p10 = p8 - p7;\n    vec2 p11 = p9 - p8;\n    vec2 p12 = p10 - p9;\n    vec2 p13 = p11 - p10;\n    vec2 p14 = p12 - p11;\n    vec2 p15 = p13 - p12;\n    vec2 p16 = p14 - p13;\n    vec2 p17 = p15 - p14;\n    vec2 p18 = p16 - p15;\n    vec2 p19 = p17 - p16;\n    vec2 p20 = p18 - p17;\n    vec2 p21 = p19 - p18;\n    vec2 p22 = p20 - p19;\n    vec2 p23 = p21 - p20;\n    vec2 p24 = p22 - p21;\n    vec2 p25 = p23 - p22;\n    vec2 p26 = p24 - p23;\n    vec2 p27 = p25 - p24;\n    vec2 p28 = p26 - p25;\n    vec2 p29 = p27 - p26;\n    vec2 p30 = p28 - p27;\n    vec2 p31 = p29 - p28;\n    vec2 p32 = p30 - p29;\n    vec2 p33 = p31 - p30;\n    vec2 p34 = p32 - p31;\n    vec2 p35 = p33 - p32;\n    vec2 p36 = p34 - p33;\n    vec2 p37 = p35 - p34;\n    vec2 p38 = p36 - p35;\n    vec2 p39 = p37 - p36;\n    vec2 p40 = p38", "\n    vec3 v = vec3(p.xyz);\n    vec3 v1 = vec3(p.xyz + vec3(0.5, 0.5, 0.5));\n    vec3 v2 = vec3(p.xyz + vec3(0.5, -0.5, 0.5));\n    vec3 v3 = vec3(p.xyz + vec3(-0.5, 0.5, 0.5));\n    vec3 v4 = vec3(p.xyz + vec3(-0.5, -0.5, 0.5));\n    vec3 v5 = vec3(p.xyz + vec3(0.5, -0.5, -0.5));\n    vec3 v6 = vec3(p.xyz + vec3(0.5, 0.5, -0.5));\n    vec3 v7 = vec3(p.xyz + vec3(-0.5, 0.5, -0.5));\n    vec3 v8 = vec3(p.xyz + vec3(-0.5, -0.5, 0.5));\n    vec3 v9 = vec3(p.xyz + vec3(-0.5, 0.5, 0.5));\n    vec3 v10 = vec3(p.xyz + vec3(0.5, 0.5, 0.5));\n    vec3 v11 = vec3(p.xyz + vec3(0.5, -0.5, 0.5));\n    vec3 v12 = vec3(p.xyz + vec3(-0.5, 0.5, 0.5));\n    vec3 v13 = vec3(p.xyz + vec3(-0.5, -0.5, 0.5));\n    vec3 v14 = vec3(p.xyz + vec3(-0.5, 0.5, -0.5));\n    vec3 v15 = vec3(p.xyz + vec3(0.5, 0.5, -0.5));\n    vec3 v16 = vec3(p.xyz + vec3(0.5, -0.5, -0.5));\n    vec3 v", "\n    float a = y;\n    float b = x;\n    float c = 1.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float s = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n    float l = 0.0f;\n    float m = 0.0f;\n    float n = 0.0f;\n    float o = 0.0f;\n    float p = 0.0f;\n    float q = 0.0f;\n    float r = 0.0f;\n    float s = 0.0f;\n    float t = 0.0f;\n    float u = 0.0f;\n    float v = 0.0f;\n    float w = 0.0f;\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec_vec_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec_vec_vec_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec_vec_vec_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec_vec_vec_vec_vec(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul_vec_vec_vec_vec_vec_vec(vec2 z, vec2 w) {", "\n    vec2 x = z.x;\n    vec2 y = z.y;\n    vec2 z = z.z;\n    vec2 u = x.y / (x.x + y.y);\n    vec2 v = y.z / (x.x + y.y);\n    vec2 w = z.x / (x.x + y.y);\n    vec2 u_hat = u.x / (u.x + v.x);\n    vec2 v_hat = v.y / (v.x + w.y);\n    vec2 w_hat = w.z / (w.x + v.y);\n    vec2 u_hat_hat = u_hat.x / (u_hat.x + v_hat.x);\n    vec2 v_hat_hat = v_hat.y / (v_hat.x + w_hat.y);\n    vec2 w_hat_hat = w_hat.z / (w_hat.x + v_hat.y);\n    vec2 u_hat_hat_hat = u_hat_hat.x / (u_hat_hat.x + v_hat_hat.x);\n    vec2 v_hat_hat_hat = v_hat_hat.y / (v_hat_hat.x + w_hat_hat.y);\n    vec2 w_hat_hat_hat = w_hat_hat.z / (w_hat_hat.x + v_hat_hat_hat.x);\n    vec2 u_hat_hat_hat_hat = u_hat_hat_hat.x / (u_hat_hat_hat.x + v_hat_hat_hat.x);\n    vec2 v_hat_hat_hat_hat = v_hat_hat_hat.y / (v_hat_hat_hat.x + w_hat_hat.y);\n    vec2 w_hat_hat_hat_hat = w_hat_hat_hat.z / (w_hat_hat_hat.x + v_hat_hat_hat.y);\n    vec2 u_hat_hat_hat_hat_hat = u_hat_hat_hat.x / (u_", "\n    vec2 c = z;\n    c.x = c.x * c.x;\n    c.y = c.y * c.y;\n    c.z = c.z * c.z;\n    c.x = c.x / c.x;\n    c.y = c.y / c.y;\n    c.z = c.z / c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.", "\n    vec2 c = z;\n    c.x = c.x * c.x;\n    c.y = c.y * c.y;\n    c.z = c.z * c.z;\n    c.x = c.x / c.x;\n    c.y = c.y / c.y;\n    c.z = c.z / c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;\n    c.x = c.x - c.x;\n    c.y = c.y - c.y;\n    c.z = c.z - c.z;\n    c.x = c.x + c.x;\n    c.y = c.y + c.y;\n    c.z = c.z + c.z;", "\n    vec4 result = alpha;\n    result.a = alpha.a + contrast;\n    result.b = alpha.b - contrast;\n    result.c = alpha.c + contrast;\n    result.d = alpha.d - contrast;\n    return result;\n}\n\nvec4 alphaBlend(vec4 alpha, vec4 beta, float alphaBeta) {\n    vec4 result = alpha;\n    result.a = alpha.a * alphaBeta;\n    result.b = alpha.b * alphaBeta;\n    result.c = alpha.c * alphaBeta;\n    result.d = alpha.d * alphaBeta;\n    return result;\n}\n\nvec4 alphaBlend2(vec4 alpha, vec4 beta, float alphaBeta) {\n    vec4 result = alpha;\n    result.a = alpha.a * alphaBeta;\n    result.b = alpha.b * alphaBeta;\n    result.c = alpha.c * alphaBeta;\n    result.d = alpha.d * alphaBeta;\n    return result;\n}\n\nvec4 alphaBlend3(vec4 alpha, vec4 beta, float alphaBeta) {\n    vec4 result = alpha;\n    result.a = alpha.a * alphaBeta;\n    result.b = alpha.b * alphaBeta;\n    result.c = alpha.c * alphaBeta;\n    result.d = alpha.d * alphaBeta;\n    return result;\n}\n\nvec4 alphaBlend4(vec4 alpha, vec4 beta, float alphaBeta) {\n    vec4 result = alpha;\n    result.a = alpha.a * alphaBeta;\n    result.b = alpha.b * alphaBeta;\n    result.c = alpha.c * alphaBeta;\n    result.d = alpha.d * alphaBeta;\n    return result;\n}\n\nvec4 alphaBlend5(vec4 alpha, vec4 beta, float alphaBeta) {\n    vec4 result = alpha;\n    result.a = alpha.a * alphaBeta;\n    result.b = alpha.b * alphaBeta;\n    result.c = alpha.c * alphaBeta;\n    result.d = alpha.d * alphaBeta;\n    return result;\n}\n\nvec4 alpha", "\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p)", "\n    vec3 v = uvw - vec3(0, 0, 1);\n    vec3 v2 = v.cross(v);\n    vec3 v3 = v2.cross(v);\n    vec3 v4 = v3.cross(v);\n    vec3 v5 = v4.cross(v);\n    vec3 v6 = v5.cross(v);\n    vec3 v7 = v6.cross(v);\n    vec3 v8 = v7.cross(v);\n    vec3 v9 = v8.cross(v);\n    vec3 v10 = v9.cross(v);\n    vec3 v11 = v10.cross(v);\n    vec3 v12 = v11.cross(v);\n    vec3 v13 = v12.cross(v);\n    vec3 v14 = v13.cross(v);\n    vec3 v15 = v14.cross(v);\n    vec3 v16 = v15.cross(v);\n    vec3 v17 = v16.cross(v);\n    vec3 v18 = v17.cross(v);\n    vec3 v19 = v18.cross(v);\n    vec3 v20 = v19.cross(v);\n    vec3 v21 = v20.cross(v);\n    vec3 v22 = v21.cross(v);\n    vec3 v23 = v22.cross(v);\n    vec3 v24 = v23.cross(v);\n    vec3 v25 = v24.cross(v);\n    vec3 v26 = v25.cross(v);\n    vec3 v27 = v26.cross(v);\n    vec3 v28 = v27.cross(v);\n    vec3 v29 = v28.cross(v);\n    vec3 v30 = v29.cross(v);\n    vec3 v31 = v30.cross(v);\n    vec3 v32 = v31.cross(v);\n    vec3 v33 = v32.cross(v);\n    vec3 v34 = v33.cross(v);\n    vec3 v35 = v34.cross(v);\n    vec3 v36 = v35.cross(v);\n    vec3", "\n    vec3 uvw2 = uvw - offset;\n    vec3 uvw3 = uvw2 - offset;\n    vec3 uvw4 = uvw3 - offset;\n    vec3 uvw5 = uvw4 - offset;\n    vec3 uvw6 = uvw5 - offset;\n    vec3 uvw7 = uvw6 - offset;\n    vec3 uvw8 = uvw7 - offset;\n    vec3 uvw9 = uvw8 - offset;\n    vec3 uvw10 = uvw9 - offset;\n    vec3 uvw11 = uvw10 - offset;\n    vec3 uvw12 = uvw11 - offset;\n    vec3 uvw13 = uvw12 - offset;\n    vec3 uvw14 = uvw13 - offset;\n    vec3 uvw15 = uvw14 - offset;\n    vec3 uvw16 = uvw15 - offset;\n    vec3 uvw17 = uvw16 - offset;\n    vec3 uvw18 = uvw17 - offset;\n    vec3 uvw19 = uvw18 - offset;\n    vec3 uvw20 = uvw19 - offset;\n    vec3 uvw21 = uvw20 - offset;\n    vec3 uvw22 = uvw21 - offset;\n    vec3 uvw23 = uvw22 - offset;\n    vec3 uvw24 = uvw23 - offset;\n    vec3 uvw25 = uvw24 - offset;\n    vec3 uvw26 = uvw25 - offset;\n    vec3 uvw27 = uvw26 - offset;\n    vec3 uvw28 = uvw27 - offset;\n    vec3 uvw29 = uvw28 - offset;\n    vec3 uvw30 = uvw29 - offset;\n    vec3 uvw31 = uvw30 - offset;\n    vec3 uvw32 = uvw31 - offset;\n    vec3 uvw33 = uvw32 - offset;\n", "\n    vec3 v = uvw - vec3(0, 0, 0);\n    vec3 v2 = v.cross(v);\n    vec3 v3 = v2.cross(v);\n    vec3 v4 = v3.cross(v);\n    vec3 v5 = v4.cross(v);\n    vec3 v6 = v5.cross(v);\n    vec3 v7 = v6.cross(v);\n    vec3 v8 = v7.cross(v);\n    vec3 v9 = v8.cross(v);\n    vec3 v10 = v9.cross(v);\n    vec3 v11 = v10.cross(v);\n    vec3 v12 = v11.cross(v);\n    vec3 v13 = v12.cross(v);\n    vec3 v14 = v13.cross(v);\n    vec3 v15 = v14.cross(v);\n    vec3 v16 = v15.cross(v);\n    vec3 v17 = v16.cross(v);\n    vec3 v18 = v17.cross(v);\n    vec3 v19 = v18.cross(v);\n    vec3 v20 = v19.cross(v);\n    vec3 v21 = v20.cross(v);\n    vec3 v22 = v21.cross(v);\n    vec3 v23 = v22.cross(v);\n    vec3 v24 = v23.cross(v);\n    vec3 v25 = v24.cross(v);\n    vec3 v26 = v25.cross(v);\n    vec3 v27 = v26.cross(v);\n    vec3 v28 = v27.cross(v);\n    vec3 v29 = v28.cross(v);\n    vec3 v30 = v29.cross(v);\n    vec3 v31 = v30.cross(v);\n    vec3 v32 = v31.cross(v);\n    vec3 v33 = v32.cross(v);\n    vec3 v34 = v33.cross(v);\n    vec3 v35 = v34.cross(v);\n    vec3 v36 = v35.cross(v);\n    vec3", "\n    vec3 v = p - vec3(0,0,0);\n    return sqrt(dot(v,v));\n}\n\nvec3 GetCenter(vec3 p) {\n    vec3 c = vec3(0,0,0);\n    c = p - vec3(0,0,0);\n    return c;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n    n = p - vec3(0,0,0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 GetNormalized(vec3 p) {\n    vec3 n = vec3(0,0,0);\n", "\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    c.a = 1.0;\n    c.b = 1.0;\n    c.c = 1.0;\n    c.d = 1.0;\n    c.e = 1.0;\n    c.f = 1.0;\n    c.g = 1.0;\n    c.h = 1.0;\n    c.i = 1.0;\n    c.j = 1.0;\n    c.k = 1.0;\n    c.l = 1.0;\n    c.m = 1.0;\n    c.n = 1.0;\n    c.o = 1.0;\n    c.p = 1.0;\n    c.q = 1.0;\n    c.r = 1.0;\n    c.s = 1.0;\n    c.t = 1.0;\n    c.u = 1.0;\n    c.v = 1.0;\n    c.w = 1.0;\n    c.x = 1.0;\n    c.y = 1.0;\n    c.z = 1.0;\n    return c;\n}\n\nvec3 Cool(vec3 v) {\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    c.a = 1.0;\n    c.b = 1.0;\n    c.c = 1.0;\n    c.d = 1.0;\n    c.e = 1.0;\n    c.f = 1.0;\n    c.g = 1.0;\n    c.h = 1.0;\n    c.i = 1.0;\n    c.j = 1.0;\n    c.k = 1.0;\n    c.l = 1.0;\n    c.m = 1.0;\n    c.n = 1.0;\n    c.o = 1.0;\n    c.p = 1.0;\n    c.q = 1.0;\n    c.r = 1.0;\n    c.s = 1.0;\n    ", "\n    vec3 r = v;\n    r.x = a.x * (1 - cos(a.z)) - a.x * cos(a.z);\n    r.y = a.y * (1 - cos(a.z)) - a.y * cos(a.z);\n    r.z = a.z * (1 - cos(a.z)) - a.z * cos(a.z);\n    return r;\n}\n\nvec3 normalize(vec3 v)\n{\n    return v / length(v);\n}\n\nvec3 dot(vec3 v1, vec3 v2)\n{\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nvec3 cross(vec3 v1, vec3 v2)\n{\n    return vec3(\n        v1.y * v2.z - v1.z * v2.y,\n        v1.z * v2.x - v1.x * v2.z,\n        v1.x * v2.y - v1.y * v2.x\n    );\n}\n\nvec3 normalize(vec3 v)\n{\n    return v / length(v);\n}\n\nvec3 dot(vec3 v1, vec3 v2)\n{\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nvec3 cross(vec3 v1, vec3 v2)\n{\n    return vec3(\n        v1.y * v2.z - v1.z * v2.y,\n        v1.z * v2.x - v1.x * v2.z,\n        v1.x * v2.y - v1.y * v2.x\n    );\n}\n\nvec3 normalize(vec3 v)\n{\n    return v / length(v);\n}\n\nvec3 dot(vec3 v1, vec3 v2)\n{\n    return v1.x * v2.x + v1.y * v2.y +", "\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {\n    return co.x * co.x + co.y * co.y;\n}\n\nvec2 hash(vec2 co) {", "\n    float x = p.x - 0.5f;\n    float y = p.y - 0.5f;\n    float d = sqrt(x*x + y*y);\n    return d;\n}\n\n// Calculate the distance between two hexagons\nfloat hexDist(vec2 p1, vec2 p2) {\n    float x1 = p1.x - 0.5f;\n    float y1 = p1.y - 0.5f;\n    float x2 = p2.x - 0.5f;\n    float y2 = p2.y - 0.5f;\n    float d = sqrt(x1*x1 + y1*y1 + x2*x2 + y2*y2);\n    return d;\n}\n\n// Calculate the distance between two hexagons\nfloat hexDist(vec2 p1, vec2 p2, vec2 p3) {\n    float x1 = p1.x - 0.5f;\n    float y1 = p1.y - 0.5f;\n    float x2 = p2.x - 0.5f;\n    float y2 = p2.y - 0.5f;\n    float x3 = p3.x - 0.5f;\n    float y3 = p3.y - 0.5f;\n    float d = sqrt(x1*x1 + y1*y1 + x2*x2 + y2*y2 + x3*x3 + y3*y3);\n    return d;\n}\n\n// Calculate the distance between two hexagons\nfloat hexDist(vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec2 p5, vec2 p6) {\n    float x1 = p1.x - 0.5f;\n    float y1 = p1.y - 0.5f;\n    float x2 = p2.x - 0.5f;\n    float y2 = p2.y - 0.5f;\n    float x3 = p3.x - 0.5f;\n    float y3 = p3.y - 0.5f;\n    float x4 = p4.", "\n    vec2 v = uv + vec2(0.5, 0.5);\n    vec2 w = v + vec2(0.5, -0.5);\n    vec2 x = w + vec2(0.5, 0.5);\n    vec2 y = x + vec2(-0.5, 0.5);\n    vec2 z = y + vec2(-0.5, -0.5);\n    vec2 w1 = w + vec2(0.5, -0.5);\n    vec2 w2 = w1 + vec2(0.5, 0.5);\n    vec2 w3 = w2 + vec2(-0.5, 0.5);\n    vec2 w4 = w3 + vec2(-0.5, -0.5);\n    vec2 w5 = w4 + vec2(0.5, -0.5);\n    vec2 w6 = w5 + vec2(0.5, 0.5);\n    vec2 w7 = w6 + vec2(-0.5, 0.5);\n    vec2 w8 = w7 + vec2(-0.5, -0.5);\n    vec2 w9 = w8 + vec2(0.5, -0.5);\n    vec2 w10 = w9 + vec2(-0.5, 0.5);\n    vec2 w11 = w10 + vec2(0.5, 0.5);\n    vec2 w12 = w11 + vec2(-0.5, -0.5);\n    vec2 w13 = w12 + vec2(0.5, -0.5);\n    vec2 w14 = w13 + vec2(-0.5, 0.5);\n    vec2 w15 = w14 + vec2(0.5, 0.5);\n    vec2 w16 = w15 + vec2(-0.5, -0.5);\n    vec2 w17 = w16 + vec2(0.5, -0.5);\n    vec2 w18 = w17 + vec2(-0.5, 0.5);\n    vec2 w19 = w18 + vec2(0.5, 0.5);\n    vec2 w20 =", "\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r1 = vec3(0.0, 0.0, 0.0);\n    vec3 r2 = vec3(0.0, 0.0, 0.0);\n    vec3 r3 = vec3(0.0, 0.0, 0.0);\n    vec3 r4 = vec3(0.0, 0.0, 0.0);\n    vec3 r5 = vec3(0.0, 0.0, 0.0);\n    vec3 r6 = vec3(0.0, 0.0, 0.0);\n    vec3 r7 = vec3(0.0, 0.0, 0.0);\n    vec3 r8 = vec3(0.0, 0.0, 0.0);\n    vec3 r9 = vec3(0.0, 0.0, 0.0);\n    vec3 r10 = vec3(0.0, 0.0, 0.0);\n    vec3 r11 = vec3(0.0, 0.0, 0.0);\n    vec3 r12 = vec3(0.0, 0.0, 0.0);\n    vec3 r13 = vec3(0.0, 0.0, 0.0);\n    vec3 r14 = vec3(0.0, 0.0, 0.0);\n    vec3 r15 = vec3(0.0, 0.0, 0.0);\n    vec3 r16 = vec3(0.0, 0.0, 0.0);\n    vec3 r17 = vec3(0.0, 0.0, 0.0);\n    vec3 r18 = vec3(0.0, 0.0, 0.0);\n    vec3 r19 = vec3(0", "\n    return (x + 1) / 2;\n}\n\nint main() {\n    float x = -1;\n    printf(\"%f\\n\", make0to1(x));\n    return 0;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to1(float x) {\n    return (x + 1) / 2;\n}\n\nA:\n\nYou can use the following function:\nfloat make0to", "\n    float fx = (float) (uv.x + offset.x) / gridRes.x;\n    float fy = (float) (uv.y + offset.y) / gridRes.y;\n    float fz = (float) (uv.z + offset.z) / gridRes.z;\n    float f = fx * fx + fy * fy + fz * fz;\n    return f;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float fx = (float) (uv.x + offset.x) / gridRes.x;\n    float fy = (float) (uv.y + offset.y) / gridRes.y;\n    float fz = (float) (uv.z + offset.z) / gridRes.z;\n    float f = fx * fx + fy * fy + fz * fz;\n    return f;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float fx = (float) (uv.x + offset.x) / gridRes.x;\n    float fy = (float) (uv.y + offset.y) / gridRes.y;\n    float fz = (float) (uv.z + offset.z) / gridRes.z;\n    float f = fx * fx + fy * fy + fz * fz;\n    return f;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float fx = (float) (uv.x + offset.x) / gridRes.x;\n    float fy = (float) (uv.y + offset.y) / gridRes.y;\n    float fz = (float) (uv.z + offset.z) / gridRes.z;\n    float f = fx * fx + fy * fy + fz * fz;\n    return f;\n", "\n    vec2 uv_new = uv;\n    float uv_new_x = uv_new.x;\n    float uv_new_y = uv_new.y;\n    float uv_new_z = uv_new.z;\n    float uv_new_x_new = uv_new_x + gridRes * time;\n    float uv_new_y_new = uv_new_y + gridRes * time;\n    float uv_new_z_new = uv_new_z + gridRes * time;\n    float uv_new_x_new_new = uv_new_x_new + gridRes * time;\n    float uv_new_y_new_new = uv_new_y_new + gridRes * time;\n    float uv_new_z_new_new = uv_new_z_new + gridRes * time;\n    float uv_new_x_new_new_new = uv_new_x_new_new + gridRes * time;\n    float uv_new_y_new_new_new = uv_new_y_new_new + gridRes * time;\n    float uv_new_z_new_new_new = uv_new_z_new_new + gridRes * time;\n    float uv_new_x_new_new_new_new = uv_new_x_new_new_new + gridRes * time;\n    float uv_new_y_new_new_new_new = uv_new_y_new_new_new + gridRes * time;\n    float uv_new_z_new_new_new_new = uv_new_z_new_new_new + gridRes * time;\n    float uv_new_x_new_new_new_new_new = uv_new_x_new_new_new_new + gridRes * time;\n    float uv_new_y_new_new_new_new_new = uv_new_y_new_new_new + gridRes * time;\n    float uv_new_z_new", "\n    vec2 center = point + radius * vec2(0, 1);\n    vec2 direction = point - center;\n    vec2 flow = direction / norm(direction);\n    vec2 flow_mag = norm(flow);\n    vec2 flow_dir = flow / flow_mag;\n    vec2 flow_dir_mag = norm(flow_dir);\n    vec2 flow_dir_cos = dot(flow_dir, flow_mag);\n    vec2 flow_dir_sin = dot(flow_dir, flow_mag);\n    vec2 flow_dir_cos_sin = dot(flow_dir, flow_dir_mag);\n    vec2 flow_dir_cos_sin_mag = norm(flow_dir_cos_sin);\n    vec2 flow_dir_cos_sin_mag_sq = flow_dir_cos_sin_mag * flow_dir_cos_sin_mag;\n    vec2 flow_dir_cos_sin_mag_sq_sq = flow_dir_cos_sin_mag_sq * flow_dir_cos_sin_mag_sq;\n    vec2 flow_dir_cos_sin_mag_sq_sq_sq = flow_dir_cos_sin_mag_sq_sq * flow_dir_cos_sin_mag_sq_sq;\n    vec2 flow_dir_cos_sin_mag_sq_sq_sq_sq_sq = flow_dir_cos_sin_mag_sq_sq_sq * flow_dir_cos_sin_mag_sq_sq_sq;\n    vec2 flow_dir_cos_sin_mag_sq_sq_sq_sq_sq_sq_sq = flow_dir_cos_sin_mag_sq_sq_sq_sq_sq_sq_sq;\n    vec2 flow_dir_cos_sin_mag_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = flow_dir_cos_sin_mag_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n    vec2 flow_dir_cos_sin_mag_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq", "\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 center = pos + vec2(0.5, 0.5);\n    return center;\n}", "\n    return (p - p1).length() / (p2 - p1).length();\n}\n\n// Computes the signed distance from a point to a line\nfloat point_line(vec2 p, vec2 p1, vec2 p2) {\n    return (p - p1).length() / (p2 - p1).length() - line(p, p1, p2);\n}\n\n// Computes the signed distance from a point to a plane\nfloat point_plane(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    return (p - p1).length() / (p2 - p1).length() - point_line(p, p1, p2) - point_line(p, p2, p3);\n}\n\n// Computes the signed distance from a point to a line segment\nfloat point_line_segment(vec2 p, vec2 p1, vec2 p2) {\n    return (p - p1).length() / (p2 - p1).length() - point_line(p, p1, p2) - point_line(p, p2, p1);\n}\n\n// Computes the signed distance from a point to a plane\nfloat point_plane_segment(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    return (p - p1).length() / (p2 - p1).length() - point_line_segment(p, p1, p2) - point_line_segment(p, p2, p3);\n}\n\n// Computes the signed distance from a point to a line\nfloat point_line_segment_line(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    return (p - p1).length() / (p2 - p1).length() - point_line_segment(p, p1, p2) - point_line_segment(p, p2, p3);\n}\n\n// Computes the signed distance from a point to a plane\nfloat point_plane_segment_line(vec2 p, vec2 p1, vec2 p2, vec2 p3) {", "\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n    return (p - arrowTileCenterCoord(v)) / arrowLength;\n}\n\n// v = field sampled at arrow", "\n    vec2 y = vec2(x);\n    y.x = y.x - 1;\n    y.y = y.y - 1;\n    return y;\n}\n\nvec2 make1to0(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x + 1;\n    y.y = y.y + 1;\n    return y;\n}\n\nvec2 make0to1(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x + 1;\n    y.y = y.y - 1;\n    return y;\n}\n\nvec2 make1to0(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x - 1;\n    y.y = y.y + 1;\n    return y;\n}\n\nvec2 make0to1(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x - 1;\n    y.y = y.y - 1;\n    return y;\n}\n\nvec2 make1to0(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x + 1;\n    y.y = y.y + 1;\n    return y;\n}\n\nvec2 make0to1(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x - 1;\n    y.y = y.y - 1;\n    return y;\n}\n\nvec2 make1to0(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x + 1;\n    y.y = y.y + 1;\n    return y;\n}\n\nvec2 make0to1(vec2 x) {\n    vec2 y = vec2(x);\n    y.x = y.x - 1;\n    y.y = y.y - 1;\n    return y;\n}\n\nvec2 make1to0(vec2 x) {\n    vec2 y = vec2", "\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0, 1);\n    vec2 flow = flow - offset;\n    vec2 flow = flow / (vec2(1, 1) - flow);\n    return flow;\n}\n\nvec2 flow(vec2 point, float spread, float offset)\n{\n    vec2 flow = point + spread * vec2(0,", "\n    vec2 p1 = p - b;\n    vec2 p2 = p - b;\n    vec2 p3 = p - b;\n    vec2 p4 = p - b;\n    vec2 p5 = p - b;\n    vec2 p6 = p - b;\n    vec2 p7 = p - b;\n    vec2 p8 = p - b;\n    vec2 p9 = p - b;\n    vec2 p10 = p - b;\n    vec2 p11 = p - b;\n    vec2 p12 = p - b;\n    vec2 p13 = p - b;\n    vec2 p14 = p - b;\n    vec2 p15 = p - b;\n    vec2 p16 = p - b;\n    vec2 p17 = p - b;\n    vec2 p18 = p - b;\n    vec2 p19 = p - b;\n    vec2 p20 = p - b;\n    vec2 p21 = p - b;\n    vec2 p22 = p - b;\n    vec2 p23 = p - b;\n    vec2 p24 = p - b;\n    vec2 p25 = p - b;\n    vec2 p26 = p - b;\n    vec2 p27 = p - b;\n    vec2 p28 = p - b;\n    vec2 p29 = p - b;\n    vec2 p30 = p - b;\n    vec2 p31 = p - b;\n    vec2 p32 = p - b;\n    vec2 p33 = p - b;\n    vec2 p34 = p - b;\n    vec2 p35 = p - b;\n    vec2 p36 = p - b;\n    vec2 p37 = p - b;\n    vec2 p38 = p - b;\n    vec2 p39 = p - b;\n    vec2 p40 = p - b;\n    vec2 p41 = p - b;\n    vec2 p42 = p - b;\n    vec2 p43 = p - b;\n    vec2 p44 = p - b;\n    vec2 p45 = p - b;\n    vec2 p46 = p - b;\n    vec2 p47", "\n    vec2 p1 = p + sp * id;\n    vec2 p2 = p - sp * id;\n    vec2 p3 = p - sp * id;\n    vec2 p4 = p + sp * id;\n    vec2 p5 = p - sp * id;\n    vec2 p6 = p - sp * id;\n    vec2 p7 = p + sp * id;\n    vec2 p8 = p - sp * id;\n    vec2 p9 = p - sp * id;\n    vec2 p10 = p + sp * id;\n    vec2 p11 = p - sp * id;\n    vec2 p12 = p - sp * id;\n    vec2 p13 = p + sp * id;\n    vec2 p14 = p - sp * id;\n    vec2 p15 = p - sp * id;\n    vec2 p16 = p + sp * id;\n    vec2 p17 = p - sp * id;\n    vec2 p18 = p - sp * id;\n    vec2 p19 = p + sp * id;\n    vec2 p20 = p - sp * id;\n    vec2 p21 = p - sp * id;\n    vec2 p22 = p + sp * id;\n    vec2 p23 = p - sp * id;\n    vec2 p24 = p - sp * id;\n    vec2 p25 = p + sp * id;\n    vec2 p26 = p - sp * id;\n    vec2 p27 = p - sp * id;\n    vec2 p28 = p + sp * id;\n    vec2 p29 = p - sp * id;\n    vec2 p30 = p - sp * id;\n    vec2 p31 = p + sp * id;\n    vec2 p32 = p - sp * id;\n    vec2 p33 = p - sp * id;\n    vec2 p34 = p + sp * id;\n    vec2 p35 = p - sp * id;\n    vec2 p36 = p - sp * id;\n    vec2 p37 = p + sp * id;\n    vec2 p38 = p - sp * id;\n    vec2 p39 = p - sp * id;\n    vec2 p", "\n    vec2 r = p + vec2(ra, sp);\n    float r_sq = r.dot(r);\n    float r_sq_inv = 1.0 / r_sq;\n    float r_sq_inv_times_time = r_sq_inv * time;\n    float r_sq_times_sp = r_sq_inv_times_time * sp;\n    float r_sq_times_ra = r_sq_times_sp * ra;\n    float r_sq_times_ra_sq = r_sq_times_ra * r_sq;\n    float r_sq_times_ra_sq_times_time = r_sq_times_ra_sq * time;\n    float r_sq_times_ra_sq_times_ra = r_sq_times_ra_sq_times_time * ra;\n    float r_sq_times_ra_sq_times_ra_sq = r_sq_times_ra_sq_times_ra * r_sq;\n    float r_sq_times_ra_sq_times_ra_sq_times_time = r_sq_times_ra_sq_times_ra_sq * time;\n    float r_sq_times_ra_sq_times_ra_sq_times_ra = r_sq_times_ra_sq_times_ra_sq_times_ra * ra;\n    float r_sq_times_ra_sq_times_ra_sq_times_ra_sq = r_sq_times_ra_sq_times_ra_sq_times_ra_sq * ra;\n    float r_sq_times_ra_sq_times_ra_sq_times_ra_sq_times_ra = r_sq_times_ra_sq_times_ra_sq_times_ra_sq_times_ra * ra;\n    float r_sq_times_ra_sq_times_ra_sq_times_ra_sq_times_ra_sq = r_sq_times_ra_sq_times_ra_sq_times_ra_sq_times_ra_sq * ra;\n    float r_sq_times_ra_sq_times_ra_sq_times_ra_sq_", "\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z*uvw.z);\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    return sqrt(uvw.x*uvw.x + uvw.y*uvw.y + uvw.z", "\n    vec3 uv = uvw;\n    vec3 v = vec3(uvw.x, uvw.y, uvw.z);\n    vec3 v2 = v.cross(v);\n    vec3 v3 = v2.cross(v);\n    vec3 v4 = v3.cross(v);\n    vec3 v5 = v4.cross(v);\n    vec3 v6 = v5.cross(v);\n    vec3 v7 = v6.cross(v);\n    vec3 v8 = v7.cross(v);\n    vec3 v9 = v8.cross(v);\n    vec3 v10 = v9.cross(v);\n    vec3 v11 = v10.cross(v);\n    vec3 v12 = v11.cross(v);\n    vec3 v13 = v12.cross(v);\n    vec3 v14 = v13.cross(v);\n    vec3 v15 = v14.cross(v);\n    vec3 v16 = v15.cross(v);\n    vec3 v17 = v16.cross(v);\n    vec3 v18 = v17.cross(v);\n    vec3 v19 = v18.cross(v);\n    vec3 v20 = v19.cross(v);\n    vec3 v21 = v20.cross(v);\n    vec3 v22 = v21.cross(v);\n    vec3 v23 = v22.cross(v);\n    vec3 v24 = v23.cross(v);\n    vec3 v25 = v24.cross(v);\n    vec3 v26 = v25.cross(v);\n    vec3 v27 = v26.cross(v);\n    vec3 v28 = v27.cross(v);\n    vec3 v29 = v28.cross(v);\n    vec3 v30 = v29.cross(v);\n    vec3 v31 = v30.cross(v);\n    vec3 v32 = v31.cross(v);\n    vec3 v33 = v32.cross(v);\n    vec3 v34 = v33.cross(v);\n    vec3 v35 = v34.cross(v);", "\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\nvec4 cubeCell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\nvec4 cubeCell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\nvec4 cubeCell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\nvec4 cubeCell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\nvec4 cubeCell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    vec3 uvw_scaled = uvw * gridRes;\n    vec3 uvw_scaled_offset = uvw_scaled + offset;\n    return vec4(uvw_scaled_offset, 1.0);\n}\n\nvec4 cubeCell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    vec3 uvw_scaled = uvw", "\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += vec3(t, 0.0, 0.0);\n    r += vec3(t, 0.0, 1.0);\n    r += vec3(t, 1.0, 0.0);\n    r += vec3(t, 1.0, 1.0);\n    return r;\n}\n\nvec3 RdYlBu_g(float t) {\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += vec3(t, 0.0, 0.0);\n    r += vec3(t, 0.0, 1.0);\n    r += vec3(t, 1.0, 0.0);\n    r += vec3(t, 1.0, 1.0);\n    return r;\n}\n\nvec3 RdYlBu_b(float t) {\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += vec3(t, 0.0, 0.0);\n    r += vec3(t, 0.0, 1.0);\n    r += vec3(t, 1.0, 0.0);\n    r += vec3(t, 1.0, 1.0);\n    return r;\n}\n\nvec3 RdYlBu_m(float t) {\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += vec3(t, 0.0, 0.0);\n    r += vec3(t, 0.0, 1.0);\n    r += vec3(t, 1.0, 0.0);\n    r += vec3(t, 1.0, 1.0);\n    return r;\n}\n\nvec3 RdYlBu_n(float t) {\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += vec3(t, 0.0, 0.0);\n    r += vec3(t, 0.0, 1.0);\n    r += vec3(t, 1.0,", "\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0, 0, 0);\n    return sqrt(dot(v, v));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    vec3 v = p - vec3(0", "\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    c.x = c.y = c.z = 1.0;\n    c.a = 1.0;\n    c.b = 0.0;\n    c.c = 0.0;\n    c.d = 0.0;\n    c.e = 0.0;\n    c.f = 0.0;\n    c.g = 0.0;\n    c.h = 0.0;\n    c.i = 0.0;\n    c.j = 0.0;\n    c.k = 0.0;\n    c.l = 0.0;\n    c.m = 0.0;\n    c.n = 0.0;\n    c.o = 0.0;\n    c.p = 0.0;\n    c.q = 0.0;\n    c.r = 0.0;\n    c.s = 0.0;\n    c.t = 0.0;\n    c.u = 0.0;\n    c.v = 0.0;\n    c.w = 0.0;\n    c.x = 0.0;\n    c.y = 0.0;\n    c.z = 0.0;\n    return c;\n}\n\nvec3 winter_colormap(float t) {\n    vec3 c = winter(t);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r.x = r.y = r.z = 1.0;\n    r.a = 1.0;\n    r.b = 0.0;\n    r.c = 0.0;\n    r.d = 0.0;\n    r.e = 0.0;\n    r.f = 0.0;\n    r.g = 0.0;\n    r.h = 0.0;\n    r.i = 0.0;\n    r.j = 0.0;\n    r.k = 0.0;\n    r.l = 0.0;\n    r.m = 0.0;\n    r.n = 0.0;\n    r", "\n    vec3 v = vec3(0, 0, 0);\n    v += uv;\n    v += uv;\n    v += uv;\n    v += uv;\n    return v;\n}\n\nvec3 tile(vec2 uv, vec2 v) {\n    vec3 v1 = vec3(0, 0, 0);\n    v1 += uv;\n    v1 += v;\n    v1 += v;\n    v1 += v;\n    return v1;\n}\n\nvec3 tile(vec2 uv, vec2 v, vec2 w) {\n    vec3 v1 = vec3(0, 0, 0);\n    v1 += uv;\n    v1 += v;\n    v1 += v;\n    v1 += v;\n    v1 += w;\n    v1 += w;\n    v1 += w;\n    v1 += w;\n    return v1;\n}\n\nvec3 tile(vec2 uv, vec2 v, vec2 w, vec2 x) {\n    vec3 v1 = vec3(0, 0, 0);\n    v1 += uv;\n    v1 += v;\n    v1 += v;\n    v1 += v;\n    v1 += w;\n    v1 += w;\n    v1 += w;\n    v1 += x;\n    v1 += x;\n    v1 += x;\n    v1 += x;\n    return v1;\n}\n\nvec3 tile(vec2 uv, vec2 v, vec2 w, vec2 x, vec2 y) {\n    vec3 v1 = vec3(0, 0, 0);\n    v1 += uv;\n    v1 += v;\n    v1 += v;\n    v1 += v;\n    v1 += w;\n    v1 += w;\n    v1 += w;\n    v1 += w;\n    v1 += x;\n    v1 += x;\n    v1 += x;\n    v1 += y;\n    v1 += y;\n    v1 += y;\n    v1 += y;\n    return v1;\n}\n\nvec3 tile(vec2", "\n    vec3 v = vec3(uv.x, uv.y, 0);\n    vec3 v2 = vec3(0, 0, 0);\n    vec3 v3 = vec3(0, 0, 0);\n    vec3 v4 = vec3(0, 0, 0);\n    vec3 v5 = vec3(0, 0, 0);\n    vec3 v6 = vec3(0, 0, 0);\n    vec3 v7 = vec3(0, 0, 0);\n    vec3 v8 = vec3(0, 0, 0);\n    vec3 v9 = vec3(0, 0, 0);\n    vec3 v10 = vec3(0, 0, 0);\n    vec3 v11 = vec3(0, 0, 0);\n    vec3 v12 = vec3(0, 0, 0);\n    vec3 v13 = vec3(0, 0, 0);\n    vec3 v14 = vec3(0, 0, 0);\n    vec3 v15 = vec3(0, 0, 0);\n    vec3 v16 = vec3(0, 0, 0);\n    vec3 v17 = vec3(0, 0, 0);\n    vec3 v18 = vec3(0, 0, 0);\n    vec3 v19 = vec3(0, 0, 0);\n    vec3 v20 = vec3(0, 0, 0);\n    vec3 v21 = vec3(0, 0, 0);\n    vec3 v22 = vec3(0, 0, 0);\n    vec3 v23 = vec3(0, 0, 0);\n    vec3 v24 = vec3(0, 0, 0);\n    vec3 v25 = vec3(0, 0, 0);\n    vec3 v26 = vec3(0, 0, 0);\n    vec3 v27 = vec3(0, 0, 0);\n    vec3 v28 = vec3(0, 0, 0);\n    vec3 v29 = vec3(0, 0, 0);\n    vec3 v30 = vec3(0, 0, 0);\n    vec3 v31 = vec3(0, 0, 0);\n    vec3 v32 = vec3(0,", "\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < gridRes.x; i++) {\n        for (int j = 0; j < gridRes.y; j++) {\n            result += uv + offset;\n        }\n    }\n    return result;\n}\n\nvec3 squarePixelizor(vec2 uv, vec2 offset) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < gridRes.x; i++) {\n        for (int j = 0; j < gridRes.y; j++) {\n            result += uv + offset;\n        }\n    }\n    return result;\n}\n\nvec3 squarePixelizor(vec2 uv, vec2 offset) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < gridRes.x; i++) {\n        for (int j = 0; j < gridRes.y; j++) {\n            result += uv + offset;\n        }\n    }\n    return result;\n}\n\nvec3 squarePixelizor(vec2 uv, vec2 offset) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < gridRes.x; i++) {\n        for (int j = 0; j < gridRes.y; j++) {\n            result += uv + offset;\n        }\n    }\n    return result;\n}\n\nvec3 squarePixelizor(vec2 uv, vec2 offset) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < gridRes.x; i++) {\n        for (int j = 0; j < gridRes.y; j++) {\n            result += uv + offset;\n        }\n    }\n    return result;\n}\n\nvec3 squarePixelizor(vec2 uv, vec2 offset) {\n    vec3 result = vec3(0.0", "\n    vec3 r = vec3(0, 0, 0);\n    r.x = uv.x / gridRes;\n    r.y = uv.y / gridRes;\n    return r;\n}\n\nvec3 rhomPixelizor(vec2 uv, vec2 vv) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = uv.x / gridRes;\n    r.y = uv.y / gridRes;\n    r.z = vv.z / gridRes;\n    return r;\n}\n\nvec3 rhomPixelizor(vec2 uv, vec2 vv, vec2 ww) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = uv.x / gridRes;\n    r.y = uv.y / gridRes;\n    r.z = uv.z / gridRes;\n    r.w = ww.x / gridRes;\n    r.w = ww.y / gridRes;\n    r.w = ww.z / gridRes;\n    return r;\n}\n\nvec3 rhomPixelizor(vec2 uv, vec2 vv, vec2 ww, vec2 xyz) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = uv.x / gridRes;\n    r.y = uv.y / gridRes;\n    r.z = uv.z / gridRes;\n    r.w = ww.x / gridRes;\n    r.w = ww.y / gridRes;\n    r.w = ww.z / gridRes;\n    r.xy = xyz.x / gridRes;\n    r.xy = xyz.y / gridRes;\n    r.xy = xyz.z / gridRes;\n    return r;\n}\n\nvec3 rhomPixelizor(vec2 uv, vec2 vv, vec2 ww, vec2 xyz, vec3 r) {\n    vec3 r = vec3(0, 0, 0);\n    r.x = uv.x / gridRes;\n    ", "\n    vec2 u = uv + offset;\n    vec2 v = u + vec2(0, 1);\n    float f = 1.0f / len;\n    float d = f * (1.0f - f * cos(f * time));\n    return vec2(f * (1.0f - f * cos(f * time)), f * (1.0f - f * cos(f * time)));\n}\n\n// generates pixelated directional waves\nvec2 flowSquare(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    vec2 u = uv + offset;\n    vec2 v = u + vec2(0, 1);\n    float f = 1.0f / len;\n    float d = f * (1.0f - f * cos(f * time));\n    return vec2(f * (1.0f - f * cos(f * time)), f * (1.0f - f * cos(f * time)));\n}\n\n// generates pixelated directional waves\nvec2 flowSquare(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    vec2 u = uv + offset;\n    vec2 v = u + vec2(0, 1);\n    float f = 1.0f / len;\n    float d = f * (1.0f - f * cos(f * time));\n    return vec2(f * (1.0f - f * cos(f * time)), f * (1.0f - f * cos(f * time)));\n}\n\n// generates pixelated directional waves\nvec2 flowSquare(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    vec2 u = uv + offset;\n    vec2 v = u + vec2(0, 1);\n    float f = 1.0f / len;\n    float d = f * (1.0f - f * cos(f * time));\n    return vec2(f * (1.0f - f * cos(f * time)), f * (1.0f - f * cos(f * time)));\n}\n\n// generates pixelated directional waves\nvec", "\n    vec2 uv_new = uv + vec2(0, time);\n    float uv_new_x = uv_new.x / gridRes;\n    float uv_new_y = uv_new.y / gridRes;\n    float uv_new_z = uv_new.z / gridRes;\n    float uv_new_x_dot = uv_new_x * uv_new_x;\n    float uv_new_y_dot = uv_new_y * uv_new_y;\n    float uv_new_z_dot = uv_new_z * uv_new_z;\n    float uv_new_x_dot_dot = uv_new_x_dot * uv_new_x_dot;\n    float uv_new_y_dot_dot = uv_new_y_dot * uv_new_y_dot;\n    float uv_new_z_dot_dot = uv_new_z_dot * uv_new_z_dot;\n    float uv_new_x_dot_dot_dot = uv_new_x_dot_dot * uv_new_x_dot_dot;\n    float uv_new_y_dot_dot_dot = uv_new_y_dot_dot * uv_new_y_dot_dot;\n    float uv_new_z_dot_dot_dot = uv_new_z_dot_dot * uv_new_z_dot_dot;\n    float uv_new_x_dot_dot_dot_dot = uv_new_x_dot_dot * uv_new_x_dot_dot_dot;\n    float uv_new_y_dot_dot_dot_dot = uv_new_y_dot_dot * uv_new_y_dot_dot_dot;\n    float uv_new_z_dot_dot_dot_dot = uv_new_z_dot_dot * uv_new_z_dot_dot_dot;\n    float uv_new_x_dot_dot_dot_dot_dot", "\n    vec2 px = p.x;\n    vec2 py = p.y;\n    vec2 dx = ddx.x;\n    vec2 dy = ddy.y;\n    vec2 d = vec2(dx, dy);\n    vec2 d2 = d.x * d.x + d.y * d.y;\n    vec2 d3 = d.x * d.y;\n    vec2 d4 = d.y * d.y;\n    vec2 d5 = d.x * d.y;\n    vec2 d6 = d.x * d.x;\n    vec2 d7 = d.y * d.y;\n    vec2 d8 = d.x * d.x;\n    vec2 d9 = d.y * d.y;\n    vec2 d10 = d.x * d.x;\n    vec2 d11 = d.y * d.y;\n    vec2 d12 = d.x * d.x;\n    vec2 d13 = d.y * d.y;\n    vec2 d14 = d.x * d.x;\n    vec2 d15 = d.y * d.y;\n    vec2 d16 = d.x * d.x;\n    vec2 d17 = d.y * d.y;\n    vec2 d18 = d.x * d.x;\n    vec2 d19 = d.y * d.y;\n    vec2 d20 = d.x * d.x;\n    vec2 d21 = d.y * d.y;\n    vec2 d22 = d.x * d.x;\n    vec2 d23 = d.y * d.y;\n    vec2 d24 = d.x * d.x;\n    vec2 d25 = d.y * d.y;\n    vec2 d26 = d.x * d.x;\n    vec2 d27 = d.y * d.y;\n    vec2 d28 = d.x * d.x;\n    vec2 d29 = d.y * d.y;\n    vec2 d30 = d.x * d.x;\n    vec2 d31 = d.y * d.", "\n    vec2 d = p - vec2(0, 0);\n    float s = sqrt(d.x * d.x + d.y * d.y);\n    float t = r * r;\n    float u = s * s;\n    float v = t * t;\n    float w = u * u;\n    float x = v * v;\n    float y = w * w;\n    float z = x * x;\n    float r2 = r * r;\n    float s2 = s * s;\n    float t2 = t * t;\n    float u2 = u * u;\n    float v2 = v * v;\n    float w2 = w * w;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float r3 = r2 * r2;\n    float s3 = s2 * s2;\n    float t3 = t2 * t2;\n    float u3 = u2 * u2;\n    float v3 = v2 * v2;\n    float w3 = w2 * w2;\n    float x3 = x2 * x2;\n    float y3 = y2 * y2;\n    float z3 = z2 * z2;\n    float r4 = r3 * r3;\n    float s4 = s3 * s3;\n    float t4 = t3 * t3;\n    float u4 = u3 * u3;\n    float v4 = v3 * v3;\n    float w4 = w3 * w3;\n    float x4 = x3 * x3;\n    float y4 = y3 * y3;\n    float z4 = z3 * z3;\n    float r5 = r4 * r4;\n    float s5 = s4 * s4;\n    float t5 = t4 * t4;\n    float u5 = u4 * u4;\n    float v5 = v4 * v4;\n    float w5 = w4 * w4;\n    float x5 = x4 * x4;\n    float y5 = y4 * y4;\n    float z5 = z4", "\n    vec2 v = vec2(p.x, p.y);\n    vec2 v2 = vec2(p.x + 1, p.y);\n    vec2 v3 = vec2(p.x + 2, p.y);\n    vec2 v4 = vec2(p.x + 3, p.y);\n    vec2 v5 = vec2(p.x + 4, p.y);\n    vec2 v6 = vec2(p.x + 5, p.y);\n    vec2 v7 = vec2(p.x + 6, p.y);\n    vec2 v8 = vec2(p.x + 7, p.y);\n    vec2 v9 = vec2(p.x + 8, p.y);\n    vec2 v10 = vec2(p.x + 9, p.y);\n    vec2 v11 = vec2(p.x + 10, p.y);\n    vec2 v12 = vec2(p.x + 11, p.y);\n    vec2 v13 = vec2(p.x + 12, p.y);\n    vec2 v14 = vec2(p.x + 13, p.y);\n    vec2 v15 = vec2(p.x + 14, p.y);\n    vec2 v16 = vec2(p.x + 15, p.y);\n    vec2 v17 = vec2(p.x + 16, p.y);\n    vec2 v18 = vec2(p.x + 17, p.y);\n    vec2 v19 = vec2(p.x + 18, p.y);\n    vec2 v20 = vec2(p.x + 19, p.y);\n    vec2 v21 = vec2(p.x + 20, p.y);\n    vec2 v22 = vec2(p.x + 21, p.y);\n    vec2 v23 = vec2(p.x + 22, p.y);\n    vec2 v24 = vec2(p.x + 23, p.y);\n    vec2 v25 = vec2(p.x + 24, p.y);\n    vec2 v26 = vec2(p.x + 25", "\n    return x * x;\n}\n\nint main( void )\n{\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n\n    for ( int i = 0; i < 10; i++ )\n    {\n        x = fun( x );\n        y = fun( y );\n        z = fun( z );\n    }\n\n    printf( \"x = %f, y = %f, z = %f\\n\", x, y, z );\n\n    return 0;\n}\n\nThe output is\nx = 0.000000, y = 0.000000, z = 0.000000\n\nA:\n\nThe problem is that you are not initializing the variables.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nYou need to initialize them to 0.0f before you use them.\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.0f;\n\nA:\n\nYou need to initialize the variables before using them.\nfloat x = 0.0f;\nfloat y = 0.0f;\nfloat z = 0.", "\n    vec3 r = vec3(0.299, 0.587, 0.114);\n    vec3 g = vec3(0.596, -0.274, -0.322);\n    vec3 b = vec3(0.211, -0.523, -0.311);\n    return (r * t.x + g * t.y + b * t.z);\n}\n\nvec3 sRGB_to_xyz(vec3 t) {\n    vec3 r = vec3(0.299, 0.587, 0.114);\n    vec3 g = vec3(0.596, -0.274, -0.322);\n    vec3 b = vec3(0.211, -0.523, -0.311);\n    return (r * t.x + g * t.y + b * t.z);\n}\n\nvec3 sRGB_to_xyz_w(vec3 t) {\n    vec3 r = vec3(0.299, 0.596, 0.114);\n    vec3 g = vec3(0.596, -0.274, -0.322);\n    vec3 b = vec3(0.211, -0.523, -0.311);\n    return (r * t.x + g * t.y + b * t.z);\n}\n\nvec3 sRGB_to_xyz_w_w(vec3 t) {\n    vec3 r = vec3(0.299, 0.596, 0.114);\n    vec3 g = vec3(0.596, -0.274, -0.322);\n    vec3 b = vec3(0.211, -0.523, -0.311);\n    return (r * t.x + g * t.y + b * t.z);\n}\n\nvec3 sRGB_to_xyz_w_w_w(vec3 t) {\n    vec3 r = vec3(0.299, 0.596, 0.114);\n    vec3 g = vec3(0.596, -0.274, -0.322);\n    vec3 b = vec3(0.211, -0.523, -0.311);\n", "\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df1(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.y - v.y * v.x;\n}\n\nfloat df2(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df3(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.y - v.y * v.x;\n}\n\nfloat df4(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df5(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df6(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df7(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df8(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df9(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df10(vec2 p) {\n    vec2 v = p - vec2(0, 0);\n    return v.x * v.x + v.y * v.y;\n}\n\nfloat df11(", "\n    vec2 p1 = p - vec2(0, 0, 0);\n    vec2 p2 = p1 + vec2(0, 0, 0);\n    vec2 p3 = p2 + vec2(0, 0, 0);\n    vec2 p4 = p3 + vec2(0, 0, 0);\n    vec2 p5 = p4 + vec2(0, 0, 0);\n    vec2 p6 = p5 + vec2(0, 0, 0);\n    vec2 p7 = p6 + vec2(0, 0, 0);\n    vec2 p8 = p7 + vec2(0, 0, 0);\n    vec2 p9 = p8 + vec2(0, 0, 0);\n    vec2 p10 = p9 + vec2(0, 0, 0);\n    vec2 p11 = p10 + vec2(0, 0, 0);\n    vec2 p12 = p11 + vec2(0, 0, 0);\n    vec2 p13 = p12 + vec2(0, 0, 0);\n    vec2 p14 = p13 + vec2(0, 0, 0);\n    vec2 p15 = p14 + vec2(0, 0, 0);\n    vec2 p16 = p15 + vec2(0, 0, 0);\n    vec2 p17 = p16 + vec2(0, 0, 0);\n    vec2 p18 = p17 + vec2(0, 0, 0);\n    vec2 p19 = p18 + vec2(0, 0, 0);\n    vec2 p20 = p19 + vec2(0, 0, 0);\n    vec2 p21 = p20 + vec2(0, 0, 0);\n    vec2 p22 = p21 + vec2(0, 0, 0);\n    vec2 p23 = p22 + vec2(0, 0, 0);\n    vec2 p24 = p23 + vec2(0, 0, 0);\n    vec2 p25 = p24 + vec2(0, 0, 0);\n    vec2 p26 = p25 + vec2(0, 0, 0);\n    vec2 p27 = p26 + vec2(0, 0, 0);", "\n    vec2 v = p - p0;\n    vec2 v1 = p1 - p0;\n    vec2 v2 = p2 - p0;\n    float d = dot( v, v1 );\n    if ( d < 0.0f )\n    {\n        d = -d;\n        v1 *= -1.0f;\n    }\n    float d1 = dot( v, v2 );\n    if ( d1 < 0.0f )\n    {\n        d1 = -d1;\n        v2 *= -1.0f;\n    }\n    float d2 = dot( v1, v1 );\n    if ( d2 < 0.0f )\n    {\n        d2 = -d2;\n        v1 *= -1.0f;\n    }\n    float d3 = dot( v2, v2 );\n    if ( d3 < 0.0f )\n    {\n        d3 = -d3;\n        v2 *= -1.0f;\n    }\n    float d4 = dot( v1, v1 );\n    if ( d4 < 0.0f )\n    {\n        d4 = -d4;\n        v1 *= -1.0f;\n    }\n    float d5 = dot( v2, v );\n    if ( d5 < 0.0f )\n    {\n        d5 = -d5;\n        v *= -1.0f;\n    }\n    return d;\n}\n\nA:\n\nI think you are looking for the distance between the point and the line segment.\nThe distance between a point and a line segment is the distance from the point to the closest point on the line segment.\nThe distance between a point and a line is the distance from the point to the closest point on the line.\nThe distance between a point and a plane is the distance from the point to the closest point on the plane.\nThe distance between a point and a triangle is the distance from the point to the closest point on the triangle.\nThe distance between a point and a quadrilateral is the distance from the point to the closest point on the quadrilateral.\nThe distance between a point and a pentagon is the distance from the", "\n    float r = sqrt(rd.x * rd.x + rd.y * rd.y + rd.z * rd.z);\n    float s = sqrt(sph.x * sph.x + sph.y * sph.y + sph.z * sph.z);\n    float theta = acos(rd.z / r);\n    float phi = acos(sph.z / s);\n    float d = r * sin(theta) * sin(phi);\n    float c = r * sin(theta) * cos(phi);\n    float e = r * cos(theta);\n    float f = sph.x * sph.y * sph.z * sin(theta) * sin(phi);\n    float g = sph.x * sph.y * sph.z * cos(theta) * cos(phi);\n    float h = sph.x * sph.y * sph.z * sin(theta) * cos(phi);\n    float i = sph.x * sph.y * sph.z * sin(theta) * sin(phi);\n    float j = sph.x * sph.y * sph.z * cos(theta) * cos(phi);\n    float k = sph.x * sph.y * sph.z * cos(theta) * sin(phi);\n    float l = sph.x * sph.y * sph.z * sin(theta) * cos(phi);\n    float m = sph.x * sph.y * sph.z * sin(theta) * sin(phi);\n    float n = sph.x * sph.y * sph.z * cos(theta) * cos(phi);\n    float o = sph.x * sph.y * sph.z * cos(theta) * sin(phi);\n    float p = sph.x * sph.y * sph.z * sin(theta) * cos(phi);\n    float q = sph.x * sph.y * sph.z * sin(theta) * sin(phi);", "\n    return (p.x + w) / 2.0;\n}\n\nfloat roundedY(vec2 p, float w, float r) {\n    return (p.y + w) / 2.0;\n}\n\nfloat squaredDistance(vec2 p1, vec2 p2) {\n    return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\nfloat squaredDistanceSquared(vec2 p1, vec2 p2) {\n    return squaredDistance(p1, p2) * squaredDistance(p1, p2);\n}\n\nfloat squaredDistanceSquaredSquared(vec2 p1, vec2 p2) {\n    return squaredDistanceSquared(p1, p2) * squaredDistanceSquared(p1, p2);\n}\n\nfloat squaredDistanceSquaredSquaredSquared(vec2 p1, vec2 p2) {\n    return squaredDistanceSquaredSquared(p1, p2) * squaredDistanceSquaredSquared(p1, p2);\n}\n\nfloat squaredDistanceSquaredSquaredSquared(vec2 p1, vec2 p2) {\n    return squaredDistanceSquaredSquaredSquared(p1, p2) * squaredDistanceSquaredSquaredSquared(p1, p2);\n}\n\nfloat squaredDistanceSquaredSquaredSquared(vec2 p1, vec2 p2) {\n    return squaredDistanceSquaredSquaredSquaredSquared(p1, p2) * squaredDistanceSquaredSquaredSquaredSquared(p1, p2);\n}\n\nfloat squaredDistanceSquaredSquaredSquaredSquared(vec2 p1, vec2 p2) {\n    return squaredDistanceSquaredSquaredSquaredSquaredSquaredSquaredSquared(p1, p2) * squaredDistanceSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSquaredSqu", "\n    float s = 0.0f;\n    float c = 0.0f;\n    float d = 0.0f;\n    float e = 0.0f;\n    float f = 0.0f;\n    float g = 0.0f;\n    float h = 0.0f;\n    float i = 0.0f;\n    float j = 0.0f;\n    float k = 0.0f;\n\n    if ( k < 0.0f )\n    {\n        k = k + 1.0f;\n    }\n\n    if ( k > 1.0f )\n    {\n        k = k - 1.0f;\n    }\n\n    if ( k == 0.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 1.0f )\n    {\n        k = 0.0f;\n    }\n\n    if ( k == 2.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 3.0f )\n    {\n        k = 0.0f;\n    }\n\n    if ( k == 4.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 5.0f )\n    {\n        k = 0.0f;\n    }\n\n    if ( k == 6.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 7.0f )\n    {\n        k = 0.0f;\n    }\n\n    if ( k == 8.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 9.0f )\n    {\n        k = 0.0f;\n    }\n\n    if ( k == 10.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 11.0f )\n    {\n        k = 0.0f;\n    }\n\n    if ( k == 12.0f )\n    {\n        k = 1.0f;\n    }\n\n    if ( k == 13.0f )\n    {\n        k =", "\n    float x = p.x;\n    float y = p.y;\n    float d = sqrt( x*x + y*y );\n    return d;\n}\n\nfloat sdOXY( in vec2 p1, in vec2 p2 )\n{\n    float x1 = p1.x;\n    float y1 = p1.y;\n    float x2 = p2.x;\n    float y2 = p2.y;\n    float d = sqrt( x1*x1 + y1*y1 + x2*x2 + y2*y2 );\n    return d;\n}\n\nfloat sdOX( in vec2 p1, in vec2 p2 )\n{\n    float x1 = p1.x;\n    float y1 = p1.y;\n    float x2 = p2.x;\n    float y2 = p2.y;\n    float d = sqrt( x1*x1 + y1*y1 + x2*x2 + y2*y2 );\n    return d;\n}\n\nfloat sdOY( in vec2 p1, in vec2 p2 )\n{\n    float x1 = p1.x;\n    float y1 = p1.y;\n    float x2 = p2.x;\n    float y2 = p2.y;\n    float d = sqrt( x1*x1 + y1*y1 + x2*x2 + y2*y2 );\n    return d;\n}\n\nfloat sdOXY( in vec2 p1, in vec2 p2 )\n{\n    float x1 = p1.x;\n    float y1 = p1.y;\n    float x2 = p2.x;\n    float y2 = p2.y;\n    float d = sqrt( x1*x1 + y1*y1 + x2*x2 + y2*y2 );\n    return d;\n}\n\nfloat sdO( in vec2 p1, in vec2 p2 )\n{\n    float x1 = p1.x;\n    float y1 = p1.y;\n    float x2 = p2.x;\n    ", "\n    return a - (b - a) * (k - 1.0f) / (k + 1.0f);\n}\n\nfloat pmax(float a, float b, float k) {\n    return a + (b - a) * (k - 1.0f) / (k + 1.0f);\n}\n\nfloat pmean(float a, float b, float k) {\n    return (a + b) / 2.0f;\n}\n\nfloat pvariance(float a, float b, float k) {\n    return (a - pmean(a, b, k)) * (a - pmean(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(float a, float b, float k) {\n    return sqrt(pvariance(a, b, k));\n}\n\nfloat pstdev(", "\n    return a < 0? -a : a;\n}\n\nfloat pdiv(float a, float b) {\n    return a < 0? -a : a / b;\n}\n\nfloat pmod(float a, float b) {\n    return a < 0? -a : a % b;\n}\n\nfloat psqrt(float a) {\n    return a < 0? -a : sqrtf(a);\n}\n\nfloat psin(float a) {\n    return sinf(a);\n}\n\nfloat pcos(float a) {\n    return cosf(a);\n}\n\nfloat ptan(float a, float b) {\n    return atan2f(b, a);\n}\n\nfloat phypot(float a, float b) {\n    return hypotf(a, b);\n}\n\nfloat phypot2(float a, float b) {\n    return hypotf2(a, b);\n}\n\nfloat phypot3(float a, float b, float c) {\n    return hypotf3(a, b, c);\n}\n\nfloat phypot4(float a, float b, float c, float d) {\n    return hypotf4(a, b, c, d);\n}\n\nfloat phypot5(float a, float b, float c, float d, float e) {\n    return hypotf5(a, b, c, d, e);\n}\n\nfloat phypot6(float a, float b, float c, float d, float e, float f) {\n    return hypotf6(a, b, c, d, e, f);\n}\n\nfloat phypot7(float a, float b, float c, float d, float e, float f, float g) {\n    return hypotf7(a, b, c, d, e, f, g);\n}\n\nfloat phypot8(float a, float b, float c, float d, float e, float f, float g, float h) {\n    return hypotf8(a, b, c, d, e, f, g, h);\n}\n\nfloat phypot9(float a, float b, float c,", "\n    float r = sqrt(p.x * p.x + p.y * p.y);\n    return r;\n}\n\nfloat dist(vec2 p1, vec2 p2) {\n    return heart(p1 - p2);\n}\n\nfloat dist2(vec2 p1, vec2 p2) {\n    return dist(p1, p2);\n}\n\nfloat dist3(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2);\n}\n\nfloat dist4(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2) * dist(p1, p2);\n}\n\nfloat dist5(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2);\n}\n\nfloat dist6(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2);\n}\n\nfloat dist7(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2);\n}\n\nfloat dist8(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p2);\n}\n\nfloat dist9(vec2 p1, vec2 p2) {\n    return dist(p1, p2) * dist(p1, p2) * dist(p1, p2) * dist(p1, p", "\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash13(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash14(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash15(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash16(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash17(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash18(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash19(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash20(vec2 p) {\n    float hash = 0;\n    for (int i = 0; i < 3; i++) {\n        hash += p[i] * p[i];\n    }\n    return hash;\n}\n\nfloat hash21(vec2 p)", "\n    vec3 p = A + (B - A) * pos;\n    vec3 p1 = A + (B - A) * (pos + 1);\n    vec3 p2 = A + (B - A) * (pos + 2);\n    vec3 p3 = A + (B - A) * (pos + 3);\n    vec3 p4 = A + (B - A) * (pos + 4);\n    vec3 p5 = A + (B - A) * (pos + 5);\n    vec3 p6 = A + (B - A) * (pos + 6);\n    vec3 p7 = A + (B - A) * (pos + 7);\n    vec3 p8 = A + (B - A) * (pos + 8);\n    vec3 p9 = A + (B - A) * (pos + 9);\n    vec3 p10 = A + (B - A) * (pos + 10);\n    vec3 p11 = A + (B - A) * (pos + 11);\n    vec3 p12 = A + (B - A) * (pos + 12);\n    vec3 p13 = A + (B - A) * (pos + 13);\n    vec3 p14 = A + (B - A) * (pos + 14);\n    vec3 p15 = A + (B - A) * (pos + 15);\n    vec3 p16 = A + (B - A) * (pos + 16);\n    vec3 p17 = A + (B - A) * (pos + 17);\n    vec3 p18 = A + (B - A) * (pos + 18);\n    vec3 p19 = A + (B - A) * (pos + 19);\n    vec3 p20 = A + (B - A) * (pos + 20);\n    vec3 p21 = A + (B - A) * (pos + 21);\n    vec3 p22 = A + (B - A) * (pos + 22);\n    vec3 p23 = A + (B - A) * (pos + 23);\n    vec3 p24 = A + (B - A) * (pos + 24);\n    vec3 p25 = A + (B - A) * (", "\n    vec3 p = pos - vec2(wi, he);\n    vec3 p2 = p.cross(vec2(0, 1));\n    vec3 p3 = p.cross(vec2(0, -1));\n    vec3 p4 = p.cross(vec2(1, 0));\n    vec3 p5 = p.cross(vec2(-1, 0));\n    vec3 p6 = p.cross(vec2(0, 1));\n    vec3 p7 = p.cross(vec2(0, -1));\n    vec3 p8 = p.cross(vec2(1, 0));\n    vec3 p9 = p.cross(vec2(-1, 0));\n    vec3 p10 = p.cross(vec2(0, 1));\n    vec3 p11 = p.cross(vec2(-1, 0));\n    vec3 p12 = p.cross(vec2(0, -1));\n    vec3 p13 = p.cross(vec2(1, 0));\n    vec3 p14 = p.cross(vec2(-1, 0));\n    vec3 p15 = p.cross(vec2(0, 1));\n    vec3 p16 = p.cross(vec2(-1, 0));\n    vec3 p17 = p.cross(vec2(0, -1));\n    vec3 p18 = p.cross(vec2(1, 0));\n    vec3 p19 = p.cross(vec2(-1, 0));\n    vec3 p20 = p.cross(vec2(0, 1));\n    vec3 p21 = p.cross(vec2(-1, 0));\n    vec3 p22 = p.cross(vec2(0, -1));\n    vec3 p23 = p.cross(vec2(1, 0));\n    vec3 p24 = p.cross(vec2(-1, 0));\n    vec3 p25 = p.cross(vec2(0, 1));\n    vec3 p26 = p.cross(vec2(-1, 0));\n    vec3 p27 = p.cross(vec2(0, -1));\n    vec3 p28 = p.cross(vec2(1, 0));\n    vec3 p", "\n    vec3 p = pos;\n    vec3 p1 = pos + k * vec2(1, 0);\n    vec3 p2 = pos + k * vec2(0, 1);\n    vec3 p3 = pos + k * vec2(0, -1);\n    vec3 p4 = pos + k * vec2(-1, 0);\n    vec3 p5 = pos + k * vec2(1, 1);\n    vec3 p6 = pos + k * vec2(-1, -1);\n    vec3 p7 = pos + k * vec2(-1, 1);\n    vec3 p8 = pos + k * vec2(1, -1);\n    vec3 p9 = pos + k * vec2(1, 1);\n    vec3 p10 = pos + k * vec2(-1, 1);\n    vec3 p11 = pos + k * vec2(-1, -1);\n    vec3 p12 = pos + k * vec2(1, -1);\n    vec3 p13 = pos + k * vec2(1, 1);\n    vec3 p14 = pos + k * vec2(-1, 1);\n    vec3 p15 = pos + k * vec2(-1, -1);\n    vec3 p16 = pos + k * vec2(1, -1);\n    vec3 p17 = pos + k * vec2(1, 1);\n    vec3 p18 = pos + k * vec2(-1, 1);\n    vec3 p19 = pos + k * vec2(-1, -1);\n    vec3 p20 = pos + k * vec2(1, -1);\n    vec3 p21 = pos + k * vec2(1, 1);\n    vec3 p22 = pos + k * vec2(-1, 1);\n    vec3 p23 = pos + k * vec2(-1, -1);\n    vec3 p24 = pos + k * vec2(1, -1);\n    vec3 p25 = pos + k * vec2(1, 1);\n    vec3 p26 = pos + k * vec2(-1, 1);\n    vec3 p27 = pos + k * vec2(-1, -1);\n    vec3 p28", "\n    vec3 v = p - ra;\n    vec3 v2 = v.cross(rb - ra);\n    vec3 v3 = v2.cross(d);\n    vec3 v4 = v3.cross(v);\n    vec3 v5 = v4.cross(v2);\n    vec3 v6 = v5.cross(v);\n    vec3 v7 = v6.cross(v);\n    vec3 v8 = v7.cross(v);\n    vec3 v9 = v8.cross(v);\n    vec3 v10 = v9.cross(v);\n    vec3 v11 = v10.cross(v);\n    vec3 v12 = v11.cross(v);\n    vec3 v13 = v12.cross(v);\n    vec3 v14 = v13.cross(v);\n    vec3 v15 = v14.cross(v);\n    vec3 v16 = v15.cross(v);\n    vec3 v17 = v16.cross(v);\n    vec3 v18 = v17.cross(v);\n    vec3 v19 = v18.cross(v);\n    vec3 v20 = v19.cross(v);\n    vec3 v21 = v20.cross(v);\n    vec3 v22 = v21.cross(v);\n    vec3 v23 = v22.cross(v);\n    vec3 v24 = v23.cross(v);\n    vec3 v25 = v24.cross(v);\n    vec3 v26 = v25.cross(v);\n    vec3 v27 = v26.cross(v);\n    vec3 v28 = v27.cross(v);\n    vec3 v29 = v28.cross(v);\n    vec3 v30 = v29.cross(v);\n    vec3 v31 = v30.cross(v);\n    vec3 v32 = v31.cross(v);\n    vec3 v33 = v32.cross(v);\n    vec3 v34 = v33.cross(v);\n    vec3 v35 = v34.cross(v);\n    vec3 v36 = v35.cross(v);\n    vec3 v37 = v36.", "\n    ivec2 h = v;\n    ivec2 h2 = v;\n    ivec2 h3 = v;\n    ivec2 h4 = v;\n    ivec2 h5 = v;\n    ivec2 h6 = v;\n    ivec2 h7 = v;\n    ivec2 h8 = v;\n    ivec2 h9 = v;\n    ivec2 h10 = v;\n    ivec2 h11 = v;\n    ivec2 h12 = v;\n    ivec2 h13 = v;\n    ivec2 h14 = v;\n    ivec2 h15 = v;\n    ivec2 h16 = v;\n    ivec2 h17 = v;\n    ivec2 h18 = v;\n    ivec2 h19 = v;\n    ivec2 h20 = v;\n    ivec2 h21 = v;\n    ivec2 h22 = v;\n    ivec2 h23 = v;\n    ivec2 h24 = v;\n    ivec2 h25 = v;\n    ivec2 h26 = v;\n    ivec2 h27 = v;\n    ivec2 h28 = v;\n    ivec2 h29 = v;\n    ivec2 h30 = v;\n    ivec2 h31 = v;\n    ivec2 h32 = v;\n    ivec2 h33 = v;\n    ivec2 h34 = v;\n    ivec2 h35 = v;\n    ivec2 h36 = v;\n    ivec2 h37 = v;\n    ivec2 h38 = v;\n    ivec2 h39 = v;\n    ivec2 h40 = v;\n    ivec2 h41 = v;\n    ivec2 h42 = v;\n    ivec2 h43 = v;\n    ivec2 h44 = v;\n    ivec2 h45 = v;\n    ivec2 h46 = v;\n    ivec2 h47 = v;\n    ivec2 h48 = v;\n    ivec2 h49 = v;\n    ivec2 h50 = v;\n    ivec2 h51 = v;\n    ive", "\n    ivec3 p = v;\n    ivec3 p1 = v;\n    ivec3 p2 = v;\n    ivec3 p3 = v;\n    ivec3 p4 = v;\n    ivec3 p5 = v;\n    ivec3 p6 = v;\n    ivec3 p7 = v;\n    ivec3 p8 = v;\n    ivec3 p9 = v;\n    ivec3 p10 = v;\n    ivec3 p11 = v;\n    ivec3 p12 = v;\n    ivec3 p13 = v;\n    ivec3 p14 = v;\n    ivec3 p15 = v;\n    ivec3 p16 = v;\n    ivec3 p17 = v;\n    ivec3 p18 = v;\n    ivec3 p19 = v;\n    ivec3 p20 = v;\n    ivec3 p21 = v;\n    ivec3 p22 = v;\n    ivec3 p23 = v;\n    ivec3 p24 = v;\n    ivec3 p25 = v;\n    ivec3 p26 = v;\n    ivec3 p27 = v;\n    ivec3 p28 = v;\n    ivec3 p29 = v;\n    ivec3 p30 = v;\n    ivec3 p31 = v;\n    ivec3 p32 = v;\n    ivec3 p33 = v;\n    ivec3 p34 = v;\n    ivec3 p35 = v;\n    ivec3 p36 = v;\n    ivec3 p37 = v;\n    ivec3 p38 = v;\n    ivec3 p39 = v;\n    ivec3 p40 = v;\n    ivec3 p41 = v;\n    ivec3 p42 = v;\n    ivec3 p43 = v;\n    ivec3 p44 = v;\n    ivec3 p45 = v;\n    ivec3 p46 = v;\n    ivec3 p47 = v;\n    ivec3 p48 = v;\n    ivec3 p49 = v;\n    ivec3 p50 = v;\n    ive", "\n    vec2 d = A - B;\n    vec2 e = B - C;\n    vec2 f = C - A;\n    float d2 = d.dot(d);\n    float e2 = e.dot(e);\n    float f2 = f.dot(f);\n    float d3 = d.dot(d);\n    float e3 = e.dot(e);\n    float f3 = f.dot(f);\n    float d4 = d.dot(d);\n    float e4 = e.dot(e);\n    float f4 = f.dot(f);\n    float d5 = d.dot(d);\n    float e5 = e.dot(e);\n    float f5 = f.dot(f);\n    float d6 = d.dot(d);\n    float e6 = e.dot(e);\n    float f6 = f.dot(f);\n    float d7 = d.dot(d);\n    float e7 = e.dot(e);\n    float f7 = f.dot(f);\n    float d8 = d.dot(d);\n    float e8 = e.dot(e);\n    float f8 = f.dot(f);\n    float d9 = d.dot(d);\n    float e9 = e.dot(e);\n    float f9 = f.dot(f);\n    float d10 = d.dot(d);\n    float e10 = e.dot(e);\n    float f10 = f.dot(f);\n    float d11 = d.dot(d);\n    float e11 = e.dot(e);\n    float f11 = f.dot(f);\n    float d12 = d.dot(d);\n    float e12 = e.dot(e);\n    float f12 = f.dot(f);\n    float d13 = d.dot(d);\n    float e13 = e.dot(e);\n    float f13 = f.dot(f);\n    float d14 = d.dot(d);\n    float e14 = e.dot(e);\n    float f14 = f.dot(f);\n    float d15 = d.dot(d);\n    ", "\n    vec2 v = a - p;\n    vec2 v_norm = v.norm();\n    vec2 v_dot = v.dot(v);\n    if (v_dot < 0) {\n        return -1;\n    } else if (v_dot > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n// Source: https://www.shadertoy.com/view/wD9WXW\nfloat winding_angle(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 v = a - p;\n    vec2 v_norm = v.norm();\n    vec2 v_dot = v.dot(v);\n    if (v_dot < 0) {\n        return 0;\n    } else if (v_dot > 0) {\n        return 2 * PI;\n    } else {\n        return PI;\n    }\n}\n\n// Source: https://www.shadertoy.com/view/wD9WXW\nfloat winding_length(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 v = a - p;\n    vec2 v_norm = v.norm();\n    vec2 v_dot = v.dot(v);\n    if (v_dot < 0) {\n        return 0;\n    } else if (v_dot > 0) {\n        return v_norm;\n    } else {\n        return v_dot;\n    }\n}\n\n// Source: https://www.shadertoy.com/view/wD9WXW\nfloat winding_area(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 v = a - p;\n    vec2 v_norm = v.norm();\n    vec2 v_dot = v.dot(v);\n    if (v_dot < 0) {\n        return 0;\n    } else if (v_dot > 0) {\n        return PI * v_dot;\n    } else {\n        return 0;\n    }\n}\n\n// Source: https://www.shadertoy.com/view/wD9WX", "\n    vec4 i = vec4(0.0,0.0,0.0,0.0);\n    vec3 n = normalize(rd);\n    vec3 p = normalize(cross(n,s));\n    vec3 q = cross(n,p);\n    vec3 r = cross(n,q);\n    vec3 s = cross(n,r);\n    i.x = dot(ro,n);\n    i.y = dot(rd,n);\n    i.z = dot(rd,q);\n    i.w = dot(rd,r);\n    return i;\n}\n\nvec4 iWedge2( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec4 i = vec4(0.0,0.0,0.0,0.0);\n    vec3 n = normalize(rd);\n    vec3 p = normalize(cross(n,s));\n    vec3 q = cross(n,p);\n    vec3 r = cross(n,q);\n    vec3 s = cross(n,r);\n    i.x = dot(ro,n);\n    i.y = dot(rd,n);\n    i.z = dot(rd,q);\n    i.w = dot(rd,r);\n    return i;\n}\n\nvec4 iWedge3( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec4 i = vec4(0.0,0.0,0.0,0.0);\n    vec3 n = normalize(rd);\n    vec3 p = normalize(cross(n,s));\n    vec3 q = cross(n,p);\n    vec3 r = cross(n,q);\n    vec3 s = cross(n,r);\n    i.x = dot(ro,n);\n    i.y = dot(rd,n);\n    i.z = dot(rd,q);\n    i.w = dot(rd,r);\n    return i;\n}\n\nvec4 iWedge4( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec4 i", "\n    int a_i24 = a >> 24;\n    int b_i24 = b >> 24;\n    int a_m12 = a_i24 & 0xFF;\n    int b_m12 = b_i24 & 0xFF;\n    int a_f32 = a_i24 & 0xFFF;\n    int b_f32 = b_i24 & 0xFFF;\n    int a_f32_m12 = a_f32 & 0xFFF;\n    int b_f32_m12 = b_f32 & 0xFFF;\n    int a_f32_m12_f32 = a_f32_m12 & 0xFFF;\n    int b_f32_m12_f32 = b_f32_m12 & 0xFFF;\n    int a_f32_m12_f32_f32 = a_f32_m12_f32 & 0xFFF;\n    int b_f32_m12_f32_f32 = b_f32_m12_f32 & 0xFFF;\n    int a_f32_m12_f32_f32_f32 = a_f32_m12_f32_f32 & 0xFFF;\n    int b_f32_m12_f32_f32_f32 = b_f32_m12_f32_f32 & 0xFFF;\n    int a_f32_m12_f32_f32_f32_f32 = a_f32_m12_f32_f32_f32 & 0xFFF;\n    int b_f32_m12_f32_f32_f32_f32 = b_f32_m12_f32_f32_f32 & 0xFFF;\n    int a_f32_m12_f32_f32_f32_f32_f32 = a_f32_m12_f32_f32_f32_f32 & 0xFFF;\n    int b_f32_m12_f32_f32_f32_f32_f32 = b_f32_m12_f32_", "\n    vec3 s = a - b;\n    vec3 sx = s.x;\n    vec3 sy = s.y;\n    vec3 sz = s.z;\n    vec3 sx2 = sx * sx;\n    vec3 sy2 = sy * sy;\n    vec3 sz2 = sz * sz;\n    vec3 sx3 = sx * sx2;\n    vec3 sy3 = sy * sy2;\n    vec3 sz3 = sz * sz2;\n    vec3 sx4 = sx * sz3;\n    vec3 sy4 = sy * sz3;\n    vec3 sz4 = sz * sz3;\n    vec3 sx5 = sx * sx4;\n    vec3 sy5 = sy * sx4;\n    vec3 sz5 = sz * sx4;\n    vec3 sx6 = sx * sz5;\n    vec3 sy6 = sy * sz5;\n    vec3 sz6 = sz * sz5;\n    vec3 sx7 = sx * sz6;\n    vec3 sy7 = sy * sz6;\n    vec3 sz7 = sz * sz6;\n    vec3 sx8 = sx * sx7;\n    vec3 sy8 = sy * sx7;\n    vec3 sz8 = sz * sx7;\n    vec3 sx9 = sx * sx8;\n    vec3 sy9 = sy * sx8;\n    vec3 sz9 = sz * sx8;\n    vec3 sx10 = sx * sx9;\n    vec3 sy10 = sy * sx9;\n    vec3 sz10 = sz * sx9;\n    vec3 sx11 = sx * sx10;\n    vec3 sy11 = sy * sx10;\n    vec3 sz11 = sz * sx10;\n    vec3 sx12 = sx * sx11;\n    vec3 sy12 = sy * sx11;\n    vec3 sz12 = sz * sx11;\n    ", "\n    vec2 a = ab - p;\n    vec2 b = ab + p;\n    vec2 c = ab - p;\n    vec2 d = ab + p;\n    vec2 e = ab - p;\n    vec2 f = ab + p;\n    vec2 g = ab - p;\n    vec2 h = ab + p;\n    vec2 i = ab - p;\n    vec2 j = ab + p;\n    vec2 k = ab - p;\n    vec2 l = ab + p;\n    vec2 m = ab - p;\n    vec2 n = ab + p;\n    vec2 o = ab - p;\n    vec2 p1 = a + b;\n    vec2 p2 = c + d;\n    vec2 p3 = e + f;\n    vec2 p4 = g + h;\n    vec2 p5 = i + j;\n    vec2 p6 = k + l;\n    vec2 p7 = m + n;\n    vec2 p8 = o + p;\n    vec2 p9 = p1 + p2;\n    vec2 p10 = p3 + p4;\n    vec2 p11 = p5 + p6;\n    vec2 p12 = p7 + p8;\n    vec2 p13 = p9 + p10;\n    vec2 p14 = p11 + p12;\n    vec2 p15 = p13 + p14;\n    vec2 p16 = p15 + p16;\n    vec2 p17 = p16 + p17;\n    vec2 p18 = p17 + p18;\n    vec2 p19 = p18 + p19;\n    vec2 p20 = p19 + p20;\n    vec2 p21 = p20 + p21;\n    vec2 p22 = p21 + p22;\n    vec2 p23 = p22 + p23;\n    vec2 p24 = p23 + p24;\n    vec2 p25 = p24 + p25;\n    vec2 p26 = p25 + p26;\n    vec2 p27 = p26 + p27;\n    vec2 p28 = p27 + p28;\n    vec2 p29 = p28 + p29;\n", "\n    return a + b;\n}\n\nfloat add_ploss_test(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_2(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_3(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_4(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_5(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_6(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_7(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_8(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_9(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_10(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_11(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_12(in float a, in float b, in float c){\n    return add_ploss(a, b) + c;\n}\n\nfloat add_ploss_test_13(in", "\n    vec2 pHyperbola_sols = vec2(0,0);\n    vec2 pHyperbola_sols_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec = vec2(0,0);\n\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n\n    vec2 pHyperbola_sols_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec_vec = vec2(0,0);\n    vec2 pHyperbola", "\n    vec3 pC = p - a;\n    vec3 pC2 = pC.cross(b - a);\n    vec3 pC3 = pC2.cross(b - a);\n    vec3 pC4 = pC3.cross(b - a);\n    vec3 pC5 = pC4.cross(b - a);\n    vec3 pC6 = pC5.cross(b - a);\n    vec3 pC7 = pC6.cross(b - a);\n    vec3 pC8 = pC7.cross(b - a);\n    vec3 pC9 = pC8.cross(b - a);\n    vec3 pC10 = pC9.cross(b - a);\n    vec3 pC11 = pC10.cross(b - a);\n    vec3 pC12 = pC11.cross(b - a);\n    vec3 pC13 = pC12.cross(b - a);\n    vec3 pC14 = pC13.cross(b - a);\n    vec3 pC15 = pC14.cross(b - a);\n    vec3 pC16 = pC15.cross(b - a);\n    vec3 pC17 = pC16.cross(b - a);\n    vec3 pC18 = pC17.cross(b - a);\n    vec3 pC19 = pC18.cross(b - a);\n    vec3 pC20 = pC19.cross(b - a);\n    vec3 pC21 = pC20.cross(b - a);\n    vec3 pC22 = pC21.cross(b - a);\n    vec3 pC23 = pC22.cross(b - a);\n    vec3 pC24 = pC23.cross(b - a);\n    vec3 pC25 = pC24.cross(b - a);\n    vec3 pC26 = pC25.cross(b - a);\n    vec3 pC27 = pC26.cross(b - a);\n    vec3 pC28 = pC27.cross(b - a);\n    vec3 pC29 = pC28.cross(b -", "\n    vec3 p1 = p - a;\n    vec3 p2 = p - b;\n    vec3 p3 = p - a;\n    vec3 p4 = p - b;\n    vec3 p5 = p - a;\n    vec3 p6 = p - b;\n    vec3 p7 = p - a;\n    vec3 p8 = p - b;\n    vec3 p9 = p - a;\n    vec3 p10 = p - b;\n    vec3 p11 = p - a;\n    vec3 p12 = p - b;\n    vec3 p13 = p - a;\n    vec3 p14 = p - b;\n    vec3 p15 = p - a;\n    vec3 p16 = p - b;\n    vec3 p17 = p - a;\n    vec3 p18 = p - b;\n    vec3 p19 = p - a;\n    vec3 p20 = p - b;\n    vec3 p21 = p - a;\n    vec3 p22 = p - b;\n    vec3 p23 = p - a;\n    vec3 p24 = p - b;\n    vec3 p25 = p - a;\n    vec3 p26 = p - b;\n    vec3 p27 = p - a;\n    vec3 p28 = p - b;\n    vec3 p29 = p - a;\n    vec3 p30 = p - b;\n    vec3 p31 = p - a;\n    vec3 p32 = p - b;\n    vec3 p33 = p - a;\n    vec3 p34 = p - b;\n    vec3 p35 = p - a;\n    vec3 p36 = p - b;\n    vec3 p37 = p - a;\n    vec3 p38 = p - b;\n    vec3 p39 = p - a;\n    vec3 p40 = p - b;\n    vec3 p41 = p - a;\n    vec3 p42 = p - b;\n    vec3 p43 = p - a;\n    vec3 p44 = p - b;\n    vec3 p45 = p - a;\n    vec3 p46 = p - b;\n    vec3 p47", "\n    vec3 v = p - cen;\n    float s = dot( v, v );\n    float d = dot( v, cen );\n    float r = rad * rad;\n    float s2 = s * s;\n    float d2 = d * d;\n    float r2 = r * r;\n    float t = d2 - s2;\n    float u = 2.0 * s * d;\n    float v = s2 - r2;\n    float w = 2.0 * d2;\n    float x = u + v;\n    float y = w - u;\n    float z = 2.0 * v * w;\n    float s = sqrt( s2 );\n    float d = sqrt( d2 );\n    float r = sqrt( r2 );\n    float t = sqrt( t );\n    float u = sqrt( u );\n    float v = sqrt( v );\n    float w = sqrt( w );\n    float x = sqrt( x );\n    float y = sqrt( y );\n    float z = sqrt( z );\n    float s = sqrt( s );\n    float d = sqrt( d );\n    float r = sqrt( r );\n    float t = sqrt( t );\n    float u = sqrt( u );\n    float v = sqrt( v );\n    float w = sqrt( w );\n    float x = sqrt( x );\n    float y = sqrt( y );\n    float z = sqrt( z );\n    float s = sqrt( s );\n    float d = sqrt( d );\n    float r = sqrt( r );\n    float t = sqrt( t );\n    float u = sqrt( u );\n    float v = sqrt( v );\n    float w = sqrt( w );\n    float x = sqrt( x );\n    float y = sqrt( y );\n    float z = sqrt( z );\n    float s = sqrt( s );\n    float d = sqrt( d );\n    float r = sqrt( r );\n    float t = sqrt( t );\n    float u = sqrt( u );\n    float v = sqrt(", "\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    if( showSurface )\n    {\n        normal = normalize( cross( pos - samplePoint, vec3(0.0, 0.0, 1.0) ) );\n    }\n    return normal;\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 cross( vec3 a, vec3 b )\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec3 dot( vec3 a, vec3 b )\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v );\n}\n\nvec3 normalize( vec3 v )\n{\n    return v / length( v", "\n    vec3 shadow = vec3(0.0, 0.0, 0.0);\n    if( showSurface )\n    {\n        shadow = samplePoint - rd;\n    }\n    else\n    {\n        shadow = samplePoint;\n    }\n    return shadow.dot(ro);\n}\n\nvoid main()\n{\n    vec3 rd = vec3(0.0, 0.0, 0.0);\n    vec3 shadow = vec3(0.0, 0.0, 0.0);\n    vec3 samplePoint = vec3(0.0, 0.0, 0.0);\n    vec3 light = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightDir2 = vec3(0.0, 1.0, 0.0);\n    vec3 lightDir3 = vec3(1.0, 0.0, 0.0);\n    vec3 lightDir4 = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir5 = vec3(0.0, 1.0, -1.0);\n    vec3 lightDir6 = vec3(1.0, -1.0, 0.0);\n    vec3 lightDir7 = vec3(-1.0, 0.0, 1.0);\n    vec3 lightDir8 = vec3(-1.0, 1.0, 0.0);\n    vec3 lightDir9 = vec3(1.0, -1.0, -1.0);\n    vec3 lightDir10 = vec3(1.0, -1.0, 1.0);\n    vec3 lightDir11 = vec3(-1.0, 1.0, -1.0);\n    vec3 lightDir12 = vec3(-1.0, -1.0, 1.0);\n    vec3 lightDir13 = vec3(1.0, 1.0, -1.0);\n    vec3 lightDir14 = vec3(1.0, -1.0, 1.0);\n    vec3 lightDir15 = vec3(-1.0, 1", "\n    vec3 p1 = p + ra*(rb-p);\n    vec3 p2 = p + ra*(rb+p);\n    vec3 p3 = p - ra*(rb-p);\n    vec3 p4 = p - ra*(rb+p);\n    vec3 p5 = p + ra*(rb-p);\n    vec3 p6 = p + ra*(rb+p);\n    vec3 p7 = p - ra*(rb-p);\n    vec3 p8 = p - ra*(rb+p);\n    vec3 p9 = p + ra*(rb-p);\n    vec3 p10 = p + ra*(rb+p);\n    vec3 p11 = p - ra*(rb-p);\n    vec3 p12 = p - ra*(rb+p);\n    vec3 p13 = p + ra*(rb-p);\n    vec3 p14 = p + ra*(rb+p);\n    vec3 p15 = p - ra*(rb-p);\n    vec3 p16 = p - ra*(rb+p);\n    vec3 p17 = p + ra*(rb-p);\n    vec3 p18 = p + ra*(rb+p);\n    vec3 p19 = p - ra*(rb-p);\n    vec3 p20 = p - ra*(rb+p);\n    vec3 p21 = p + ra*(rb-p);\n    vec3 p22 = p + ra*(rb+p);\n    vec3 p23 = p - ra*(rb-p);\n    vec3 p24 = p - ra*(rb+p);\n    vec3 p25 = p + ra*(rb-p);\n    vec3 p26 = p + ra*(rb+p);\n    vec3 p27 = p - ra*(rb-p);\n    vec3 p28 = p - ra*(rb+p);\n    vec3 p29 = p + ra*(rb-p);\n    vec3 p30 = p + ra*(rb+p);\n    vec3 p31 = p - ra*(rb-p);\n    vec3 p32 = p - ra*(rb+p);", "\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz = p;\n    s.w = ra;\n    s.x = rb;\n    return s;\n}\n\nvec4 sgTorus( vec3 p, float ra, float rb )\n{\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz = p;\n    s.w = ra;\n    s.x = rb;\n    return s;\n}\n\nvec4 sgTorus( vec3 p, float ra, float rb )\n{\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz = p;\n    s.w = ra;\n    s.x = rb;\n    return s;\n}\n\nvec4 sgTorus( vec3 p, float ra, float rb )\n{\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz = p;\n    s.w = ra;\n    s.x = rb;\n    return s;\n}\n\nvec4 sgTorus( vec3 p, float ra, float rb )\n{\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz = p;\n    s.w = ra;\n    s.x = rb;\n    return s;\n}\n\nvec4 sgTorus( vec3 p, float ra, float rb )\n{\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz = p;\n    s.w = ra;\n    s.x = rb;\n    return s;\n}\n\nvec4 sgTorus( vec3 p, float ra, float rb )\n{\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    s.xyz =", "\n    float u = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    return u / (b.x - a.x) * (b.y - a.y) + a.x;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float u = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    return u / (b.x - a.x) * (b.y - a.y) + a.x;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float u = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    return u / (b.x - a.x) * (b.y - a.y) + a.x;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float u = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    return u / (b.x - a.x) * (b.y - a.y) + a.x;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float u = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    return u / (b.x - a.x) * (b.y - a.y) + a.x;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    float u = (b.x - a.", "\n    return vec3(v.x * v.x, v.y * v.y, v.z * v.z);\n}\n\nfloat dot3(in vec3 v1, in vec3 v2) {\n    return dot2(v1, v2);\n}\n\nfloat dot4(in vec3 v1, in vec3 v2, in vec3 v3) {\n    return dot2(v1, v2) + dot2(v2, v3);\n}\n\nfloat dot5(in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4) {\n    return dot2(v1, v2) + dot2(v2, v3) + dot2(v3, v4) + dot2(v4, v1);\n}\n\nfloat dot6(in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 v5) {\n    return dot2(v1, v2) + dot2(v2, v3) + dot2(v3, v4) + dot2(v4, v5) + dot2(v5, v1);\n}\n\nfloat dot7(in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 v5, in vec3 v6) {\n    return dot2(v1, v2) + dot2(v2, v3) + dot2(v3, v4) + dot2(v4, v5) + dot2(v5, v6) + dot2(v6, v1);\n}\n\nfloat dot8(in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 v5, in vec3 v6, in vec3 v7) {\n    return dot2(v1, v2) + dot2(v2, v3) + dot2(v3, v4) + dot2(v4, v5) + dot2(v5, v6) + dot2(v6, v7) + dot2(v7, v1);\n}\n\n", "\n    return ( maxCorner.x - p.x ) * ( maxCorner.x - p.x ) + ( maxCorner.y - p.y ) * ( maxCorner.y - p.y );\n}\n\n// Calculate the distance between the two corners\nfloat distance( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    return sqAABB( p, minCorner, maxCorner );\n}\n\n// Calculate the angle between the two corners\nfloat angle( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    return acos( distance( p, minCorner, maxCorner ) / ( distance( minCorner, minCorner, maxCorner ) * distance( maxCorner, maxCorner, minCorner ) ) );\n}\n\n// Calculate the angle between the two corners\nfloat angle( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    return acos( distance( p, minCorner, maxCorner ) / ( distance( minCorner, minCorner, maxCorner ) * distance( maxCorner, maxCorner, minCorner ) ) );\n}\n\n// Calculate the angle between the two corners\nfloat angle( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    return acos( distance( p, minCorner, maxCorner ) / ( distance( minCorner, minCorner, maxCorner ) * distance( maxCorner, maxCorner, minCorner ) ) );\n}\n\n// Calculate the angle between the two corners\nfloat angle( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    return acos( distance( p, minCorner, maxCorner ) / ( distance( minCorner, minCorner, maxCorner ) * distance( maxCorner, maxCorner, minCorner ) ) );\n}\n\n// Calculate the angle between the two corners\nfloat angle( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    return acos( distance", "\n    vec3 r = vec3(0, 0, 0);\n    vec3 d = vec3(0, 0, 0);\n    vec3 e = vec3(0, 0, 0);\n    vec3 f = vec3(0, 0, 0);\n    vec3 g = vec3(0, 0, 0);\n    vec3 h = vec3(0, 0, 0);\n    vec3 i = vec3(0, 0, 0);\n    vec3 j = vec3(0, 0, 0);\n    vec3 k = vec3(0, 0, 0);\n    vec3 l = vec3(0, 0, 0);\n    vec3 m = vec3(0, 0, 0);\n    vec3 n = vec3(0, 0, 0);\n    vec3 o = vec3(0, 0, 0);\n    vec3 p = vec3(0, 0, 0);\n    vec3 q = vec3(0, 0, 0);\n    vec3 r = vec3(0, 0, 0);\n    vec3 s = vec3(0, 0, 0);\n    vec3 t = vec3(0, 0, 0);\n    vec3 u = vec3(0, 0, 0);\n    vec3 v = vec3(0, 0, 0);\n    vec3 w = vec3(0, 0, 0);\n    vec3 x = vec3(0, 0, 0);\n    vec3 y = vec3(0, 0, 0);\n    vec3 z = vec3(0, 0, 0);\n    vec3 p1 = vec3(0, 0, 0);\n    vec3 p2 = vec3(0, 0, 0);\n    vec3 p3 = vec3(0, 0, 0);\n    vec3 p4 = vec3(0, 0, 0);\n    vec3 p5 = vec3(0, 0, 0);\n    vec3 p6 = vec3(0, 0, 0);\n    vec3 p7 = vec3(0, 0, 0);\n    vec3 p8 = vec3(0, 0, 0);\n    vec3 p9 = vec3(0, 0, 0);\n    vec3 p10 = vec", "\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat_vec(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat_vec_vec(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat_vec_vec_vec(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat_vec_vec_vec(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat_vec_vec_vec(vec2 uv)\n{\n    vec3 v = vec3(0, 0, 0);\n    v.x = uv.x;\n    v.y = uv.y;\n    return v;\n}\n\nvec3 pixtoraw_mat_vec", "\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = q.x * v.x - q.y * v.y - q.z * v.z - q.w * v.w;\n    result.y = q.x * v.y + q.y * v.z + q.z * v.w - q.w * v.x;\n    result.z = q.x * v.z - q.y * v.w + q.w * v.x + q.z * v.y;\n    return result;\n}\n\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = q.x * v.x + q.y * v.y + q.z * v.z + q.w * v.w;\n    result.y = q.x * v.y - q.y * v.z - q.z * v.w + q.w * v.x;\n    result.z = q.x * v.z + q.y * v.w - q.w * v.x - q.z * v.y;\n    return result;\n}\n\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = q.x * v.x + q.y * v.y + q.z * v.z + q.w * v.w;\n    result.y = q.x * v.y - q.y * v.z - q.z * v.w + q.w * v.x;\n    result.z = q.x * v.z + q.y * v.w + q.w * v.x - q.z * v.y;\n    return result;\n}\n\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    result.x = q.", "\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    ", "\n    vec2 p1 = a - p;\n    vec2 p2 = b - p;\n    vec2 p3 = p1 + p2;\n    vec2 p4 = p3 - p;\n    vec2 p5 = p4 + p;\n    vec2 p6 = p5 - p;\n    vec2 p7 = p6 + p;\n    vec2 p8 = p7 - p;\n    vec2 p9 = p8 + p;\n    vec2 p10 = p9 - p;\n    vec2 p11 = p10 + p;\n    vec2 p12 = p11 - p;\n    vec2 p13 = p12 + p;\n    vec2 p14 = p13 - p;\n    vec2 p15 = p14 + p;\n    vec2 p16 = p15 - p;\n    vec2 p17 = p16 + p;\n    vec2 p18 = p17 - p;\n    vec2 p19 = p18 + p;\n    vec2 p20 = p19 - p;\n    vec2 p21 = p20 + p;\n    vec2 p22 = p21 - p;\n    vec2 p23 = p22 + p;\n    vec2 p24 = p23 - p;\n    vec2 p25 = p24 + p;\n    vec2 p26 = p25 - p;\n    vec2 p27 = p26 + p;\n    vec2 p28 = p27 - p;\n    vec2 p29 = p28 + p;\n    vec2 p30 = p29 - p;\n    vec2 p31 = p30 + p;\n    vec2 p32 = p31 - p;\n    vec2 p33 = p32 + p;\n    vec2 p34 = p33 - p;\n    vec2 p35 = p34 + p;\n    vec2 p36 = p35 - p;\n    vec2 p37 = p36 + p;\n    vec2 p38 = p37 - p;\n    vec2 p39 = p38 + p;\n    vec2 p40 = p39 - p;\n    vec2 p41 = p40 + p;\n    vec2 p42 = p41 - p;\n    vec2 p43 = p42", "\n    vec2 v = m;\n    vec2 u = vec2(0,0);\n    vec2 v2 = vec2(0,0);\n    vec2 u2 = vec2(0,0);\n    vec2 v3 = vec2(0,0);\n    vec2 u3 = vec2(0,0);\n    vec2 v4 = vec2(0,0);\n    vec2 u4 = vec2(0,0);\n    vec2 v5 = vec2(0,0);\n    vec2 u5 = vec2(0,0);\n    vec2 v6 = vec2(0,0);\n    vec2 u6 = vec2(0,0);\n    vec2 v7 = vec2(0,0);\n    vec2 u7 = vec2(0,0);\n    vec2 v8 = vec2(0,0);\n    vec2 u8 = vec2(0,0);\n    vec2 v9 = vec2(0,0);\n    vec2 u9 = vec2(0,0);\n    vec2 v10 = vec2(0,0);\n    vec2 u10 = vec2(0,0);\n    vec2 v11 = vec2(0,0);\n    vec2 u11 = vec2(0,0);\n    vec2 v12 = vec2(0,0);\n    vec2 u12 = vec2(0,0);\n    vec2 v13 = vec2(0,0);\n    vec2 u13 = vec2(0,0);\n    vec2 v14 = vec2(0,0);\n    vec2 u14 = vec2(0,0);\n    vec2 v15 = vec2(0,0);\n    vec2 u15 = vec2(0,0);\n    vec2 v16 = vec2(0,0);\n    vec2 u16 = vec2(0,0);\n    vec2 v17 = vec2(0,0);\n    vec2 u17 = vec2(0,0);\n    vec2 v18 = vec2(0,0);\n    vec2 u18 = vec2(0,0);\n    vec2 v19 = vec2(0,0);\n", "\n    vec2 p = p1 + rd * rad;\n    vec2 p2 = p2 - p;\n    vec2 p3 = p - p2;\n    vec2 p4 = p + p2;\n    vec2 p5 = p - p4;\n    vec2 p6 = p + p4;\n    vec2 p7 = p - p6;\n    vec2 p8 = p + p6;\n    vec2 p9 = p - p8;\n    vec2 p10 = p + p8;\n    vec2 p11 = p - p10;\n    vec2 p12 = p + p10;\n    vec2 p13 = p - p12;\n    vec2 p14 = p + p12;\n    vec2 p15 = p - p14;\n    vec2 p16 = p + p14;\n    vec2 p17 = p - p16;\n    vec2 p18 = p + p16;\n    vec2 p19 = p - p18;\n    vec2 p20 = p + p18;\n    vec2 p21 = p - p20;\n    vec2 p22 = p + p20;\n    vec2 p23 = p - p22;\n    vec2 p24 = p + p22;\n    vec2 p25 = p - p24;\n    vec2 p26 = p + p24;\n    vec2 p27 = p - p26;\n    vec2 p28 = p + p26;\n    vec2 p29 = p - p28;\n    vec2 p30 = p + p28;\n    vec2 p31 = p - p30;\n    vec2 p32 = p + p30;\n    vec2 p33 = p - p32;\n    vec2 p34 = p + p32;\n    vec2 p35 = p - p34;\n    vec2 p36 = p + p34;\n    vec2 p37 = p - p36;\n    vec2 p38 = p + p36;\n    vec2 p39 = p - p38;\n    vec2 p40 = p + p38;\n    vec2 p41 = p - p40;\n    vec2 p42 = p + p40;\n    vec2 p43", "\n    vec3 v = p - c;\n    vec3 v2 = v.x * v.x + v.y * v.y;\n    vec3 v3 = v.x * v.y;\n    vec3 v4 = v.x * v.z;\n    vec3 v5 = v.y * v.z;\n    vec3 v6 = v.z * v.z;\n    vec3 v7 = v.z * v.y;\n    vec3 v8 = v.y * v.y;\n    vec3 v9 = v.x * v.z;\n    vec3 v10 = v.y * v.x;\n    vec3 v11 = v.z * v.x;\n    vec3 v12 = v.z * v.y;\n    vec3 v13 = v.y * v.y;\n    vec3 v14 = v.x * v.z;\n    vec3 v15 = v.y * v.z;\n    vec3 v16 = v.z * v.x;\n    vec3 v17 = v.x * v.x;\n    vec3 v18 = v.y * v.y;\n    vec3 v19 = v.x * v.y;\n    vec3 v20 = v.y * v.z;\n    vec3 v21 = v.z * v.y;\n    vec3 v22 = v.x * v.z;\n    vec3 v23 = v.y * v.z;\n    vec3 v24 = v.z * v.x;\n    vec3 v25 = v.x * v.x;\n    vec3 v26 = v.y * v.x;\n    vec3 v27 = v.z * v.x;\n    vec3 v28 = v.x * v.y;\n    vec3 v29 = v.y * v.y;\n    vec3 v30 = v.z * v.y;\n    vec3 v31 = v.x * v.z;\n    vec3 v32 = v.y * v.z;\n    vec3 v33 = v.z * v.x;\n    vec3 v34 = v.x * v.x", "\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec3 v = b - p;\n    return v.x * v.x + v.y * v.y;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    ", "\n    vec3 v = vec3( p.x, p.y, 1 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n    return v;\n}\n\nvec3 sdgHeart( in vec2 p )\n{\n    vec3 v = vec3( p.x, p.y, 0 );\n", "\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat h(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat f(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat h(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat f(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat h(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat f(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);\n}\n\nfloat h(float a1, float b1, float a2, float b2, float x) {\n    return (a1 * x + b1) / (a2 * x + b2);", "\n    float y = a * sin(x);\n    float z = b * cos(x);\n    float w = n * sin(x);\n    float x1 = x + y;\n    float x2 = x - y;\n    float x3 = x + z;\n    float x4 = x - z;\n    float x5 = x + w;\n    float x6 = x - w;\n    float x7 = x + x1;\n    float x8 = x - x1;\n    float x9 = x + x2;\n    float x10 = x - x2;\n    float x11 = x + x3;\n    float x12 = x - x3;\n    float x13 = x + x4;\n    float x14 = x - x4;\n    float x15 = x + x5;\n    float x16 = x - x5;\n    float x17 = x + x6;\n    float x18 = x - x6;\n    float x19 = x + x7;\n    float x20 = x - x7;\n    float x21 = x + x8;\n    float x22 = x - x8;\n    float x23 = x + x9;\n    float x24 = x - x9;\n    float x25 = x + x10;\n    float x26 = x - x10;\n    float x27 = x + x11;\n    float x28 = x - x11;\n    float x29 = x + x12;\n    float x30 = x - x12;\n    float x31 = x + x13;\n    float x32 = x - x13;\n    float x33 = x + x14;\n    float x34 = x - x14;\n    float x35 = x + x15;\n    float x36 = x - x15;\n    float x37 = x + x16;\n    float x38 = x - x16;\n    float x39 = x + x17;\n    float x40 = x - x17;\n    float x41 = x + x18;\n    float x42 = x - x18;\n    float x43 = x + x19;\n    float x44 = x - x19;\n", "\n                float x = uv.x;\n                float y = uv.y;\n                float z = uv.z;\n                float sigma = 0.1f;\n                float s = sqrt(x*x + y*y + z*z);\n                float t = s*s;\n                float r = sigma*sigma;\n                float theta = atan2(y, x);\n                float phi = atan2(z, s);\n                float d = sqrt(r*r + t*t);\n                float e = atan2(z, -x);\n                float f = atan2(y, -z);\n                float g = atan2(x, -y);\n                float h = atan2(y, x);\n                float i = atan2(z, -y);\n                float j = atan2(x, -z);\n                float k = atan2(y, x);\n                float l = atan2(z, -x);\n                float m = atan2(y, -z);\n                float n = atan2(x, -y);\n                float o = atan2(y, x);\n                float p = atan2(z, -x);\n                float q = atan2(y, -z);\n                float r = atan2(x, -y);\n                float s = atan2(z, -x);\n                float t = atan2(y, -z);\n                float u = atan2(x, -y);\n                float v = atan2(z, -x);\n                float w = atan2(y, -z);\n                float x = cos(theta)*cos(phi)*cos(d);\n                float y = cos(theta)*cos(phi)*sin(d);\n                float z = cos(theta)*sin(phi);\n                float sigma = 0.1f;\n                float s = sqrt(x*x + y*y + z*z);\n                float t = s*s;\n                float r = sigma*sigma;\n                float theta = atan2(y, x);\n                float phi = atan2", "\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    v.x = x;\n    v.y = y;\n    return v;\n}\n\nvec3 compute( vec3 v1, vec3 v2 )\n{\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    v.x = v1.x + v2.x;\n    v.y = v1.y + v2.y;\n    return v;\n}\n\nvec3 compute( vec3 v1, vec3 v2, vec3 v3 )\n{\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    v.x = v1.x + v2.x + v3.x;\n    v.y = v1.y + v2.y + v3.y;\n    return v;\n}\n\nvec3 compute( vec3 v1, vec3 v2, vec3 v3, vec3 v4 )\n{\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    v.x = v1.x + v2.x + v3.x + v4.x;\n    v.y = v1.y + v2.y + v3.y + v4.y;\n    return v;\n}\n\nvec3 compute( vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5 )\n{\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    v.x = v1.x + v2.x + v3.x + v4.x + v5.x;\n    v.y = v1.y + v2.y + v3.y + v4.y + v5.y;\n    return v;\n}\n\nvec3 compute( vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6 )\n{\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    v.x = v", "\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle2d( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle3d( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle4d( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle5d( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    float s = dot(d, d);\n    float t = dot(d, r);\n    float u = dot(c, r);\n    float v = dot(d, c);\n    float w = s - t - u - v;\n    return sqrt(w);\n}\n\nfloat sdCircle6d( in vec2 p, in vec2 c, in float r )\n{\n    ", "\n    vec2 p1 = p - c;\n    vec2 p2 = p - b;\n    vec2 p3 = p - c;\n    vec2 p4 = p - b;\n    vec2 p5 = p - c;\n    vec2 p6 = p - b;\n    vec2 p7 = p - c;\n    vec2 p8 = p - b;\n    vec2 p9 = p - c;\n    vec2 p10 = p - b;\n    vec2 p11 = p - c;\n    vec2 p12 = p - b;\n    vec2 p13 = p - c;\n    vec2 p14 = p - b;\n    vec2 p15 = p - c;\n    vec2 p16 = p - b;\n    vec2 p17 = p - c;\n    vec2 p18 = p - b;\n    vec2 p19 = p - c;\n    vec2 p20 = p - b;\n    vec2 p21 = p - c;\n    vec2 p22 = p - b;\n    vec2 p23 = p - c;\n    vec2 p24 = p - b;\n    vec2 p25 = p - c;\n    vec2 p26 = p - b;\n    vec2 p27 = p - c;\n    vec2 p28 = p - b;\n    vec2 p29 = p - c;\n    vec2 p30 = p - b;\n    vec2 p31 = p - c;\n    vec2 p32 = p - b;\n    vec2 p33 = p - c;\n    vec2 p34 = p - b;\n    vec2 p35 = p - c;\n    vec2 p36 = p - b;\n    vec2 p37 = p - c;\n    vec2 p38 = p - b;\n    vec2 p39 = p - c;\n    vec2 p40 = p - b;\n    vec2 p41 = p - c;\n    vec2 p42 = p - b;\n    vec2 p43 = p - c;\n    vec2 p44 = p - b;\n    vec2 p45 = p - c;\n    vec2 p46 = p - b;\n    vec2 p47", "\n    vec2 p1 = p - a;\n    vec2 p2 = b - a;\n    vec2 p3 = p1 + p2;\n    vec2 p4 = p3 - p;\n    vec2 p5 = p4 + p;\n    vec2 p6 = p5 - p;\n    vec2 p7 = p6 + p;\n    vec2 p8 = p7 - p;\n    vec2 p9 = p8 + p;\n    vec2 p10 = p9 - p;\n    vec2 p11 = p10 + p;\n    vec2 p12 = p11 - p;\n    vec2 p13 = p12 + p;\n    vec2 p14 = p13 - p;\n    vec2 p15 = p14 + p;\n    vec2 p16 = p15 - p;\n    vec2 p17 = p16 + p;\n    vec2 p18 = p17 - p;\n    vec2 p19 = p18 + p;\n    vec2 p20 = p19 - p;\n    vec2 p21 = p20 + p;\n    vec2 p22 = p21 - p;\n    vec2 p23 = p22 + p;\n    vec2 p24 = p23 - p;\n    vec2 p25 = p24 + p;\n    vec2 p26 = p25 - p;\n    vec2 p27 = p26 + p;\n    vec2 p28 = p27 - p;\n    vec2 p29 = p28 + p;\n    vec2 p30 = p29 - p;\n    vec2 p31 = p30 + p;\n    vec2 p32 = p31 - p;\n    vec2 p33 = p32 + p;\n    vec2 p34 = p33 - p;\n    vec2 p35 = p34 + p;\n    vec2 p36 = p35 - p;\n    vec2 p37 = p36 + p;\n    vec2 p38 = p37 - p;\n    vec2 p39 = p38 + p;\n    vec2 p40 = p39 - p;\n    vec2 p41 = p40 + p;\n    vec2 p42 = p41 - p;\n    vec2 p43 = p42", "\n    vec2 p2 = p + a;\n    vec2 p3 = p2 + b;\n    vec2 p4 = p3 + a;\n    vec2 p5 = p4 + b;\n    vec2 p6 = p5 + a;\n    vec2 p7 = p6 + b;\n    vec2 p8 = p7 + a;\n    vec2 p9 = p8 + b;\n    vec2 p10 = p9 + a;\n    vec2 p11 = p10 + b;\n    vec2 p12 = p11 + a;\n    vec2 p13 = p12 + b;\n    vec2 p14 = p13 + a;\n    vec2 p15 = p14 + b;\n    vec2 p16 = p15 + a;\n    vec2 p17 = p16 + b;\n    vec2 p18 = p17 + a;\n    vec2 p19 = p18 + b;\n    vec2 p20 = p19 + a;\n    vec2 p21 = p20 + b;\n    vec2 p22 = p21 + a;\n    vec2 p23 = p22 + b;\n    vec2 p24 = p23 + a;\n    vec2 p25 = p24 + b;\n    vec2 p26 = p25 + a;\n    vec2 p27 = p26 + b;\n    vec2 p28 = p27 + a;\n    vec2 p29 = p28 + b;\n    vec2 p30 = p29 + a;\n    vec2 p31 = p30 + b;\n    vec2 p32 = p31 + a;\n    vec2 p33 = p32 + b;\n    vec2 p34 = p33 + a;\n    vec2 p35 = p34 + b;\n    vec2 p36 = p35 + a;\n    vec2 p37 = p36 + b;\n    vec2 p38 = p37 + a;\n    vec2 p39 = p38 + b;\n    vec2 p40 = p39 + a;\n    vec2 p41 = p40 + b;\n    vec2 p42 = p41 + a;\n    vec2 p43 = p42 + b;\n    vec2 p44 = p43", "\n    float s = 0.0f;\n    float s2 = 0.0f;\n    float s3 = 0.0f;\n    float s4 = 0.0f;\n    float s5 = 0.0f;\n    float s6 = 0.0f;\n    float s7 = 0.0f;\n    float s8 = 0.0f;\n    float s9 = 0.0f;\n    float s10 = 0.0f;\n    float s11 = 0.0f;\n    float s12 = 0.0f;\n    float s13 = 0.0f;\n    float s14 = 0.0f;\n    float s15 = 0.0f;\n    float s16 = 0.0f;\n    float s17 = 0.0f;\n    float s18 = 0.0f;\n    float s19 = 0.0f;\n    float s20 = 0.0f;\n    float s21 = 0.0f;\n    float s22 = 0.0f;\n    float s23 = 0.0f;\n    float s24 = 0.0f;\n    float s25 = 0.0f;\n    float s26 = 0.0f;\n    float s27 = 0.0f;\n    float s28 = 0.0f;\n    float s29 = 0.0f;\n    float s30 = 0.0f;\n    float s31 = 0.0f;\n    float s32 = 0.0f;\n    float s33 = 0.0f;\n    float s34 = 0.0f;\n    float s35 = 0.0f;\n    float s36 = 0.0f;\n    float s37 = 0.0f;\n    float s38 = 0.0f;\n    float s39 = 0.0f;\n    float s40 = 0.0f;\n    float s41 = 0.0f;\n    float s42 = 0.0f;\n    float s43 = 0.0f;\n    float s44 = 0.0f;\n    float s45 = 0.0f;\n    float s46 = 0.0f;\n    float s47 = 0", "\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y;\n    }\n    return sqrt( s );\n}\n\nfloat sdB( in vec2 p )\n{\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y;\n    }\n    return sqrt( s );\n}\n\nfloat sdC( in vec2 p )\n{\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y;\n    }\n    return sqrt( s );\n}\n\nfloat sdD( in vec2 p )\n{\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y;\n    }\n    return sqrt( s );\n}\n\nfloat sdE( in vec2 p )\n{\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y;\n    }\n    return sqrt( s );\n}\n\nfloat sdF( in vec2 p )\n{\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y;\n    }\n    return sqrt( s );\n}\n\nfloat sdG( in vec2 p )\n{\n    float s = 0.0;\n    for ( int i = 0; i < vec2.size(); i++ )\n    {\n        s += p.x * p.x + p.y * p.y", "\n    float s = 0.0;\n    for ( vec2 i = p; i!= p + 1; ++i )\n    {\n        s += ( in vec2( i.x, i.y ) - in vec2( p.x, p.y ) ) * ( in vec2( i.x, i.y ) - in vec2( p.x, p.y ) );\n    }\n    return s;\n}\n\nA:\n\nI think you are looking for the distance between two points.\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\nSo, for example, the distance between (0,0) and (3,4) is sqrt( (3-0)^2 + (4-0)^2 ) = sqrt( 9 + 16 ) = sqrt( 25 ) = 5.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of the differences between the coordinates of the two points.\n\nA:\n\nThe distance between two points is the square root of the sum of the squares of", "\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x = uv.x;\n    p.y = uv.y;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x = uv.x;\n    p.y = uv.y;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x = uv.x;\n    p.y = uv.y;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x = uv.x;\n    p.y = uv.y;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x = uv.x;\n    p.y = uv.y;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x = uv.x;\n    p.y = uv.y;\n    return p;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates\nvec3 pattern( in vec2 uv )\n{\n    vec3 p = vec3( 0.0, 0.0, 0.0 );\n    p.x", "\n    vec2 p1 = a + (b - a) * th;\n    vec2 p2 = b - (b - a) * th;\n    vec2 p3 = p - (p - a) * th;\n    vec2 p4 = p - (p - a) * th;\n    vec2 p5 = p - (p - a) * th;\n    vec2 p6 = p - (p - a) * th;\n    vec2 p7 = p - (p - a) * th;\n    vec2 p8 = p - (p - a) * th;\n    vec2 p9 = p - (p - a) * th;\n    vec2 p10 = p - (p - a) * th;\n    vec2 p11 = p - (p - a) * th;\n    vec2 p12 = p - (p - a) * th;\n    vec2 p13 = p - (p - a) * th;\n    vec2 p14 = p - (p - a) * th;\n    vec2 p15 = p - (p - a) * th;\n    vec2 p16 = p - (p - a) * th;\n    vec2 p17 = p - (p - a) * th;\n    vec2 p18 = p - (p - a) * th;\n    vec2 p19 = p - (p - a) * th;\n    vec2 p20 = p - (p - a) * th;\n    vec2 p21 = p - (p - a) * th;\n    vec2 p22 = p - (p - a) * th;\n    vec2 p23 = p - (p - a) * th;\n    vec2 p24 = p - (p - a) * th;\n    vec2 p25 = p - (p - a) * th;\n    vec2 p26 = p - (p - a) * th;\n    vec2 p27 = p - (p - a) * th;\n    vec2 p28 = p - (p - a) * th;\n    vec2 p29 = p - (p - a) * th;\n    vec2 p30 = p - (p - a) * th;\n    ", "\n    float d = b - a;\n    float s = d.length();\n    float d2 = d * d;\n    float s2 = s * s;\n    float d3 = d2 * th;\n    float s3 = s2 * th;\n    float d4 = d3 * th;\n    float s4 = s3 * th;\n    float d5 = d4 * th;\n    float s5 = s4 * th;\n    float d6 = d5 * th;\n    float s6 = s5 * th;\n    float d7 = d6 * th;\n    float s7 = s6 * th;\n    float d8 = d7 * th;\n    float s8 = s7 * th;\n    float d9 = d8 * th;\n    float s9 = s8 * th;\n    float d10 = d9 * th;\n    float s10 = s9 * th;\n    float d11 = d10 * th;\n    float s11 = s10 * th;\n    float d12 = d11 * th;\n    float s12 = s11 * th;\n    float d13 = d12 * th;\n    float s13 = s12 * th;\n    float d14 = d13 * th;\n    float s14 = s13 * th;\n    float d15 = d14 * th;\n    float s15 = s14 * th;\n    float d16 = d15 * th;\n    float s16 = s15 * th;\n    float d17 = d16 * th;\n    float s17 = s16 * th;\n    float d18 = d17 * th;\n    float s18 = s17 * th;\n    float d19 = d18 * th;\n    float s19 = s18 * th;\n    float d20 = d19 * th;\n    float s20 = s19 * th;\n    float d21 = d20 * th;\n    float s21 = s20 * th;\n    float d22 = d21 * th;\n    float s22 = s21 * th;\n    float d23 = d22 * th;\n    float s23 = s22 * th;\n    float d24 = d23 * th;\n", "\n    vec2 p2 = p + vec2(r,0);\n    vec2 b2 = b + vec2(0,r);\n    vec2 p3 = p2 - vec2(r,0);\n    vec2 b3 = b2 - vec2(0,r);\n    vec2 p4 = p3 + vec2(0,r);\n    vec2 b4 = b3 + vec2(0,r);\n    vec2 p5 = p4 - vec2(0,r);\n    vec2 b5 = b4 - vec2(0,r);\n    vec2 p6 = p5 + vec2(0,r);\n    vec2 b6 = b5 + vec2(0,r);\n    vec2 p7 = p6 - vec2(0,r);\n    vec2 b7 = b6 - vec2(0,r);\n    vec2 p8 = p7 + vec2(0,r);\n    vec2 b8 = b7 + vec2(0,r);\n    vec2 p9 = p8 - vec2(0,r);\n    vec2 b9 = b8 - vec2(0,r);\n    vec2 p10 = p9 + vec2(0,r);\n    vec2 b10 = b9 + vec2(0,r);\n    vec2 p11 = p10 - vec2(0,r);\n    vec2 b11 = b10 - vec2(0,r);\n    vec2 p12 = p11 + vec2(0,r);\n    vec2 b12 = b11 + vec2(0,r);\n    vec2 p13 = p12 - vec2(0,r);\n    vec2 b13 = b12 - vec2(0,r);\n    vec2 p14 = p13 + vec2(0,r);\n    vec2 b14 = b13 + vec2(0,r);\n    vec2 p15 = p14 - vec2(0,r);\n    vec2 b15 = b14 - vec2(0,r);\n    vec2 p16 = p15 + vec2(0,r);\n    vec2 b16 = b15 + vec2(0,r);\n    vec2", "\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b.x, 2 ) + pow( p.y - b.y, 2 ) );\n    return d / r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    float d = sqrt( pow( p.x - b", "\n    return sqrt( (p.x - b.x) * (p.x - b.x) + (p.y - b.y) * (p.y - b.y) );\n}\n\n// distance to line\nfloat distLine( in vec2 p, in vec2 q, in vec2 r )\n{\n    return sqrt( (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) );\n}\n\n// distance to line segment\nfloat distLineSeg( in vec2 p, in vec2 q, in vec2 r )\n{\n    return sqrt( (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) );\n}\n\n// distance to line segment\nfloat distLineSeg2( in vec2 p, in vec2 q, in vec2 r )\n{\n    return sqrt( (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) );\n}\n\n// distance to line\nfloat distLineSeg2( in vec2 p, in vec2 q, in vec2 r )\n{\n    return sqrt( (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) );\n}\n\n// distance to line segment\nfloat distLineSeg2( in vec2 p, in vec2 q, in vec2 r )\n{\n    return sqrt( (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) );\n}\n\n// distance to line\nfloat distLineSeg2( in vec2 p, in vec2 q, in vec2 r )\n{\n    return sqrt( (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y", "\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x*x + y*y + z*z);\n    hash = s*s*s;\n    return hash;\n}\n\nfloat hash13(vec2 p){\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x*x + y*y + z*z);\n    hash = s*s*s;\n    return hash;\n}\n\nfloat hash14(vec2 p){\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x*x + y*y + z*z);\n    hash = s*s*s;\n    return hash;\n}\n\nfloat hash15(vec2 p){\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x*x + y*y + z*z);\n    hash = s*s*s;\n    return hash;\n}\n\nfloat hash16(vec2 p){\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x*x + y*y + z*z);\n    hash = s*s*s;\n    return hash;\n}\n\nfloat hash17(vec2 p){\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x*x + y*y + z*z);\n    hash = s*s*s;\n    return hash;\n}\n\nfloat hash18(vec2 p){\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n", "\n    float r = 0;\n    for (int i = 0; i < vec2.size(); ++i)\n    {\n        r += vec2[i] * vec2[i];\n    }\n    return r;\n}\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\nA:\n\nI think you're looking for the Fisher-Yates shuffle.\n\n", "\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random3(vec2 st){\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random4(vec2 st){\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random5(vec2 st){\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random6(vec2 st){\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random7(vec2 st){\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random8(vec2 st){\n    vec2 r;\n    r.x = st.x + rand() % (st.x - st.x + 1);\n    r.y = st.y + rand() % (st.y - st.y + 1);\n    return r;\n}\n\nvec2 random9(vec2 st){\n    vec2 r;\n    ", "\n    float r = x.x + x.y;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r;\n    float r40 = r39 * r;\n    float r41 = r40 * r;\n    float r42 = r41 * r;\n    float r43 = r42 * r;\n    float r44 = r43 * r;\n    float r45 = r44 * r;\n    float r46 = r45 * r;\n    float r47", "\n    vec2 y = x + vec2(0.1, 0.1);\n    return y.x + y.y;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat fbm(vec2 x)\n{\n    vec2 y = x + vec2(0.1, 0.1);\n    return y.x + y.y + y.z;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat fbm(vec2 x)\n{\n    vec2 y = x + vec2(0.1, 0.1);\n    return y.x + y.y + y.z + y.x + y.y + y.z;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat fbm(vec2 x)\n{\n    vec2 y = x + vec2(0.1, 0.1);\n    return y.x + y.y + y.z + y.x + y.y + y.z + y.x + y.y + y.z;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat fbm(vec2 x)\n{\n    vec2 y = x + vec2(0.1, 0.1);\n    return y.x + y.y + y.z + y.x + y.y + y.z + y.x + y.y + y.z + y.x + y.y + y.z;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat fbm(vec2 x)\n{\n    vec2 y = x + vec2(0.1, 0.1);\n    return y.x + y.y + y.z + y.x + y.y + y.z + y.x + y.y + y.z + y.x + y.y + y.z;\n}\n\n// Fractional Brownian Motion noise to test the \n// double-octave noise function\nfloat fbm(", "\n    float y = x.y;\n    float z = x.z;\n    float w = x.w;\n    float x = x.x;\n    float yy = y * y;\n    float zz = z * z;\n    float ww = w * w;\n    float xx = x * x;\n    float yyz = yy * z;\n    float zzz = zz * z;\n    float www = ww * w;\n    float xxx = x * x;\n    float yyyz = yyz * y;\n    float zzzz = zzz * z;\n    float wwww = www * w;\n    float xxxxx = x * x;\n    float yyyyy = yy * y;\n    float zzzzz = zzz * z;\n    float wwwww = www * w;\n    float xxxxxx = x * x;\n    float yyyyyy = yy * y;\n    float zzzzzz = zzz * z;\n    float wwwwww = www * w;\n    float xxxxxxx = x * x;\n    float yyyyyyy = yy * y;\n    float zzzzzzz = zzz * z;\n    float wwwwwww = www * w;\n    return (yyy + zzz + www + xxx + yyyy + zzzz + wwww + xxxxx + yyyyy + zzzzz + wwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + wwwwww + xxxxxx + yyyyyy + zzzzzz + w", "\n    return (float) (x * y);\n}\n\nfloat texelSolidAngle(float x, float y, float z)\n{\n    return (float) (180.0 * (x * y + y * z + z * x));\n}\n\nvoid draw(float x, float y, float z, float area, float texelSolidAngle)\n{\n    float dx = x - 0.5f;\n    float dy = y - 0.5f;\n    float dz = z - 0.5f;\n\n    float areaElement = areaElement(dx, dy);\n    float texelSolidAngle = texelSolidAngle(dx, dy, dz);\n\n    float area = areaElement * areaElement + areaElement * areaElement + areaElement * areaElement;\n    float texel = texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle;\n\n    float area_x = areaElement(dx, dy);\n    float area_y = areaElement(dy, dz);\n    float area_z = areaElement(dz, dx);\n\n    float texel_x = texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle;\n    float texel_y = texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle;\n    float texel_z = texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle;\n\n    float area_x_x = areaElement(dx, dy) * areaElement(dx, dz);\n    float area_y_y = areaElement(dy, dz) * areaElement(dy, dx);\n    float area_z_z = areaElement(dz, dx) * areaElement(dz, dy);\n\n    float texel_x_x = texelSolidAngle * texelSolidAngle + texelSolidAngle * texelSolidAngle + texelSolidAng", "\n    vec3 hash = vec3(0, 0, 0);\n    hash.x = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.y = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.z = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    return hash;\n}\n\nvec3 hash33(vec3 p3) {\n    vec3 hash = vec3(0, 0, 0);\n    hash.x = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.y = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.z = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    return hash;\n}\n\nvec3 hash33(vec3 p3) {\n    vec3 hash = vec3(0, 0, 0);\n    hash.x = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.y = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.z = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    return hash;\n}\n\nvec3 hash33(vec3 p3) {\n    vec3 hash = vec3(0, 0, 0);\n    hash.x = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0x3f;\n    hash.y = p3.x * 0x3f + p3.y * 0x3f + p3.z * 0", "\n    vec3 v = p;\n    vec3 v1 = v;\n    vec3 v2 = v;\n    vec3 v3 = v;\n    vec3 v4 = v;\n    vec3 v5 = v;\n    vec3 v6 = v;\n    vec3 v7 = v;\n    vec3 v8 = v;\n    vec3 v9 = v;\n    vec3 v10 = v;\n    vec3 v11 = v;\n    vec3 v12 = v;\n    vec3 v13 = v;\n    vec3 v14 = v;\n    vec3 v15 = v;\n    vec3 v16 = v;\n    vec3 v17 = v;\n    vec3 v18 = v;\n    vec3 v19 = v;\n    vec3 v20 = v;\n    vec3 v21 = v;\n    vec3 v22 = v;\n    vec3 v23 = v;\n    vec3 v24 = v;\n    vec3 v25 = v;\n    vec3 v26 = v;\n    vec3 v27 = v;\n    vec3 v28 = v;\n    vec3 v29 = v;\n    vec3 v30 = v;\n    vec3 v31 = v;\n    vec3 v32 = v;\n    vec3 v33 = v;\n    vec3 v34 = v;\n    vec3 v35 = v;\n    vec3 v36 = v;\n    vec3 v37 = v;\n    vec3 v38 = v;\n    vec3 v39 = v;\n    vec3 v40 = v;\n    vec3 v41 = v;\n    vec3 v42 = v;\n    vec3 v43 = v;\n    vec3 v44 = v;\n    vec3 v45 = v;\n    vec3 v46 = v;\n    vec3 v47 = v;\n    vec3 v48 = v;\n    vec3 v49 = v;\n    vec3 v50 = v;\n    vec3 v51 = v;\n    vec3 v52 = v;\n    vec3 v53 = v;\n    vec3 v54 = v;\n    vec3 v55 = v;\n    vec3 v56 = v;", "\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec2 x )\n{\n    return x.x + x.y;\n}\n\n// this is a very simple hash function. it will not work for\n// very large vectors.\nvec2 hash( in vec", "\n    float s = (b - a).length();\n    float d = (b - a).length();\n    float s2 = (b - a).length();\n    float d2 = (b - a).length();\n    float s3 = (b - a).length();\n    float d3 = (b - a).length();\n    float s4 = (b - a).length();\n    float d4 = (b - a).length();\n    float s5 = (b - a).length();\n    float d5 = (b - a).length();\n    float s6 = (b - a).length();\n    float d6 = (b - a).length();\n    float s7 = (b - a).length();\n    float d7 = (b - a).length();\n    float s8 = (b - a).length();\n    float d8 = (b - a).length();\n    float s9 = (b - a).length();\n    float d9 = (b - a).length();\n    float s10 = (b - a).length();\n    float d10 = (b - a).length();\n    float s11 = (b - a).length();\n    float d11 = (b - a).length();\n    float s12 = (b - a).length();\n    float d12 = (b - a).length();\n    float s13 = (b - a).length();\n    float d13 = (b - a).length();\n    float s14 = (b - a).length();\n    float d14 = (b - a).length();\n    float s15 = (b - a).length();\n    float d15 = (b - a).length();\n    float s16 = (b - a).length();\n    float d16 = (b - a).length();\n    float s17 = (b - a).length();\n    float d17 = (b - a).length();\n    float s18 = (b - a).length();\n    float d18 = (b - a).length();\n    float s19 = (b - a).length();\n    float d19 = (b - a).length();\n    float s20 = (b - a).length();\n    float d20 = (", "\n    vec2 p1 = p - b;\n    vec2 p2 = p - r;\n    vec2 p3 = p - b;\n    vec2 p4 = p - r;\n    vec2 p5 = p - b;\n    vec2 p6 = p - r;\n    vec2 p7 = p - b;\n    vec2 p8 = p - r;\n    vec2 p9 = p - b;\n    vec2 p10 = p - r;\n    vec2 p11 = p - b;\n    vec2 p12 = p - r;\n    vec2 p13 = p - b;\n    vec2 p14 = p - r;\n    vec2 p15 = p - b;\n    vec2 p16 = p - r;\n    vec2 p17 = p - b;\n    vec2 p18 = p - r;\n    vec2 p19 = p - b;\n    vec2 p20 = p - r;\n    vec2 p21 = p - b;\n    vec2 p22 = p - r;\n    vec2 p23 = p - b;\n    vec2 p24 = p - r;\n    vec2 p25 = p - b;\n    vec2 p26 = p - r;\n    vec2 p27 = p - b;\n    vec2 p28 = p - r;\n    vec2 p29 = p - b;\n    vec2 p30 = p - r;\n    vec2 p31 = p - b;\n    vec2 p32 = p - r;\n    vec2 p33 = p - b;\n    vec2 p34 = p - r;\n    vec2 p35 = p - b;\n    vec2 p36 = p - r;\n    vec2 p37 = p - b;\n    vec2 p38 = p - r;\n    vec2 p39 = p - b;\n    vec2 p40 = p - r;\n    vec2 p41 = p - b;\n    vec2 p42 = p - r;\n    vec2 p43 = p - b;\n    vec2 p44 = p - r;\n    vec2 p45 = p - b;\n    vec2 p46 = p - r;\n    vec2 p47", "\n    vec2 proj_center_x = proj_info.x - center.x;\n    vec2 proj_center_y = proj_info.y - center.y;\n    vec2 proj_major = proj_info.z;\n    vec2 proj_minor = proj_info.z;\n    vec2 proj_center = proj_info;\n    vec2 proj_center_x_norm = proj_center_x / proj_major;\n    vec2 proj_center_y_norm = proj_center_y / proj_major;\n    vec2 proj_center_x_norm_sq = proj_center_x_norm * proj_center_x_norm;\n    vec2 proj_center_y_norm_sq = proj_center_y_norm * proj_center_y_norm;\n    vec2 proj_center_x_norm_sq_sq = proj_center_x_norm_sq * proj_center_x_norm_sq;\n    vec2 proj_center_y_norm_sq_sq_sq = proj_center_y_norm_sq * proj_center_y_norm_sq;\n    vec2 proj_center_x_norm_sq_sq_sq_sq = proj_center_x_norm_sq_sq * proj_center_x_norm_sq_sq;\n    vec2 proj_center_y_norm_sq_sq_sq_sq_sq = proj_center_y_norm_sq_sq * proj_center_y_norm_sq_sq;\n    vec2 proj_center_x_norm_sq_sq_sq_sq_sq_sq = proj_center_x_norm_sq_sq_sq * proj_center_x_norm_sq_sq_sq;\n    vec2 proj_center_y_norm_sq_sq_sq_sq_sq_sq_sq = proj_center_y_norm_sq_sq_sq * proj_center_y_norm_sq_sq_sq_sq;\n    vec2 proj_center_x_norm_sq_", "\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x * x + y * y + z * z);\n    hash = (int)s;\n    return hash;\n}\n\nvec2 Hash13(vec2 p)\n{\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x * x + y * y + z * z);\n    hash = (int)s;\n    return hash;\n}\n\nvec2 Hash14(vec2 p)\n{\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x * x + y * y + z * z);\n    hash = (int)s;\n    return hash;\n}\n\nvec2 Hash15(vec2 p)\n{\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x * x + y * y + z * z);\n    hash = (int)s;\n    return hash;\n}\n\nvec2 Hash16(vec2 p)\n{\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x * x + y * y + z * z);\n    hash = (int)s;\n    return hash;\n}\n\nvec2 Hash17(vec2 p)\n{\n    float hash = 0;\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float s = sqrt(x * x + y * y + z * z);\n    hash = (int)s;\n    return hash;\n}\n\nvec2 Hash18(vec2 p)\n{\n    float hash = 0;\n    float x = p.", "\n    float d = acs.x - p.x;\n    float d2 = acs.x * acs.x;\n    float d3 = acs.y * acs.y;\n    float d4 = acs.z * acs.z;\n    float d5 = acs.x * acs.y;\n    float d6 = acs.y * acs.z;\n    float d7 = acs.z * acs.x;\n    float d8 = acs.x * acs.y;\n    float d9 = acs.y * acs.z;\n    float d10 = acs.z * acs.x;\n    float d11 = acs.x * acs.y;\n    float d12 = acs.y * acs.z;\n    float d13 = acs.z * acs.x;\n    float d14 = acs.x * acs.y;\n    float d15 = acs.y * acs.z;\n    float d16 = acs.z * acs.x;\n    float d17 = acs.x * acs.y;\n    float d18 = acs.y * acs.z;\n    float d19 = acs.z * acs.x;\n    float d20 = acs.x * acs.y;\n    float d21 = acs.y * acs.z;\n    float d22 = acs.z * acs.x;\n    float d23 = acs.x * acs.y;\n    float d24 = acs.y * acs.z;\n    float d25 = acs.z * acs.x;\n    float d26 = acs.x * acs.y;\n    float d27 = acs.y * acs.z;\n    float d28 = acs.z * acs.x;\n    float d29 = acs.x * acs.y;\n    float d30 = acs.y * acs.z;\n    float d31 = acs.z * acs.x;\n    float d32 = acs.x * acs.y;\n    ", "\n    vec3 n = vec3( 0.0, 0.0, 0.0 );\n    n.x = p.x;\n    n.y = p.y;\n    n.z = p.z;\n    return n;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y + n_norm.z * n_norm.z;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y + n_norm.z * n_norm.z;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y + n_norm.z * n_norm.z;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y + n_norm.z * n_norm.z;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y + n_norm.z * n_norm.z;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y + n_norm.z * n_norm.z;\n}\n\nvec3 normalize( vec3 n )\n{\n    vec3 n_norm = normalize( n );\n    return n_norm.x * n_norm.x + n_norm.y * n_norm.y", "\n    vec3 normal = normalize(rd - ro);\n    float d = t1 - t0;\n    float s = d * d;\n    float c = 2.0f * d * t0;\n    float e = s * t0;\n    float f = c * t0;\n    float g = e * t0;\n    float h = f * t0;\n    float i = g * t0;\n    float j = h * t0;\n    float k = i * t0;\n    float l = j * t0;\n    float m = k * t0;\n    float n = l * t0;\n    float o = m * t0;\n    float p = n * t0;\n    float q = o * t0;\n    float r = p * t0;\n    float s = q * t0;\n    float t = r * t0;\n    float u = s * t0;\n    float v = t * t0;\n    float w = u * t0;\n    float x = v * t0;\n    float y = w * t0;\n    float z = x * t0;\n    float d = z - t0;\n    float e = d * d;\n    float f = e * d;\n    float g = f * d;\n    float h = g * d;\n    float i = h * d;\n    float j = i * d;\n    float k = j * d;\n    float l = k * d;\n    float m = l * d;\n    float n = m * d;\n    float o = n * d;\n    float p = o * d;\n    float q = p * d;\n    float r = q * d;\n    float s = r * d;\n    float t = s * d;\n    float u = t * d;\n    float v = u * d;\n    float w = v * d;\n    float x = w * d;\n    float y = x * d;\n    float z = y * d;\n    return (float)sqrt(x * x + y * y + z * z);\n}\n\n// NOTE: Don't forget to add +normal*", "\n    vec3 a = pos - nor;\n    vec3 b = pos + nor;\n    vec3 c = pos + nor;\n    vec3 d = pos - nor;\n    vec3 e = pos - nor;\n    vec3 f = pos + nor;\n    vec3 g = pos + nor;\n    vec3 h = pos - nor;\n    vec3 i = pos + nor;\n    vec3 j = pos - nor;\n    vec3 k = pos + nor;\n    vec3 l = pos - nor;\n    vec3 m = pos + nor;\n    vec3 n = pos - nor;\n    vec3 o = pos + nor;\n    vec3 p = pos - nor;\n    vec3 q = pos + nor;\n    vec3 r = pos - nor;\n    vec3 s = pos + nor;\n    vec3 t = pos - nor;\n    vec3 u = pos + nor;\n    vec3 v = pos - nor;\n    vec3 w = pos + nor;\n    vec3 x = pos - nor;\n    vec3 y = pos + nor;\n    vec3 z = pos - nor;\n    vec3 ao = (a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z) / 8;\n    return ao;\n}\n\nvec3 calcAO( in vec3 pos, in vec3 nor )\n{\n    vec3 a = pos - nor;\n    vec3 b = pos + nor;\n    vec3 c = pos + nor;\n    vec3 d = pos - nor;\n    vec3 e = pos - nor;\n    vec3 f = pos + nor;\n    vec3 g = pos + nor;\n    vec3 h = pos - nor;\n    vec3 i = pos + nor;\n    vec3 j = pos - nor;\n    vec3 k = pos + nor;\n    vec3 l = pos - nor;\n    vec3 m = pos + nor;\n    vec3 n = pos - nor;\n    vec3 o = pos + nor;\n    vec3 p = pos - nor;\n", "\n    vec3 r = vec3(axis.x, axis.y, axis.z);\n    vec3 r_norm = r.length();\n    vec3 r_cross = cross(r, r);\n    vec3 r_norm_cross = cross(r_norm, r_cross);\n    vec3 r_norm_cross_norm = r_norm_cross.length();\n    vec3 r_norm_cross_norm_cross = cross(r_norm_cross, r_cross_norm);\n    vec3 r_norm_cross_norm_cross_norm = cross(r_norm_cross_norm, r_cross_norm_cross);\n    vec3 r_norm_cross_norm_cross_norm_cross = cross(r_norm_cross_norm_cross, r_cross_norm_cross_cross);\n    vec3 r_norm_cross_norm_cross_norm_cross_cross = cross(r_norm_cross_norm_cross_cross, r_cross_norm_cross_cross_cross);\n    vec3 r_norm_cross_norm_cross_norm_cross_cross_cross = cross(r_norm_cross_norm_cross_cross_cross, r_cross_norm_cross_cross_cross_cross_cross);\n    vec3 r_norm_cross_norm_cross_norm_cross_cross_cross_cross_cross = cross(r_norm_cross_norm_cross_cross_cross_cross_cross_cross_cross_cross_cross, r_cross_norm_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross_cross", "\n    vec3 ray = vec3(0, 0, 0);\n    ray.x = fragCoord.x - camera.position.x;\n    ray.y = fragCoord.y - camera.position.y;\n    ray.z = fragCoord.z - camera.position.z;\n    return ray;\n}\n\n// Helper function that calculates the intersection point of a ray and a plane\nvec3 intersectPlane(vec3 ray, vec3 plane) {\n    vec3 intersection = vec3(0, 0, 0);\n    if (plane.x == 0 && plane.y == 0 && plane.z == 0) {\n        return ray;\n    }\n    if (plane.x == 0) {\n        intersection.x = ray.x;\n        intersection.y = ray.y;\n        intersection.z = ray.z;\n    }\n    if (plane.y == 0) {\n        intersection.x = ray.x;\n        intersection.y = ray.z;\n        intersection.z = ray.y;\n    }\n    if (plane.z == 0) {\n        intersection.x = ray.y;\n        intersection.y = ray.x;\n        intersection.z = ray.z;\n    }\n    return intersection;\n}\n\n// Helper function that calculates the intersection point of a ray and a sphere\nvec3 intersectSphere(vec3 ray, vec3 sphere) {\n    vec3 intersection = vec3(0, 0, 0);\n    if (ray.x == 0 && ray.y == 0 && ray.z == 0) {\n        return ray;\n    }\n    if (ray.x == 0) {\n        intersection.x = ray.y;\n        intersection.y = ray.z;\n        intersection.z = ray.x;\n    }\n    if (ray.y == 0) {\n        intersection.x = ray.z;\n        intersection.y = ray.x;\n        intersection.z = ray.y;\n    }\n    if (ray.z == 0) {\n        intersection.x = ray.x;\n        intersection.y = ray.y;\n        intersection", "\n    vec2 r = vec2(rand(co.x, co.y), rand(co.x, co.y));\n    return r;\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    vec3 r = vec3(rand(co.x, co.y, co.z), rand(co.x, co.y, co.z), rand(co.x, co.y, co.z));\n    return r;\n}\n\n// Standard 4d noise\nfloat rand4dTime(vec4 co){\n    vec4 r = vec4(rand(co.x, co.y, co.z, co.w), rand(co.x, co.y, co.z, co.w), rand(co.x, co.y, co.z, co.w), rand(co.x, co.y, co.z, co.w));\n    return r;\n}\n\n// Standard 5d noise\nfloat rand5dTime(vec5 co){\n    vec5 r = vec5(rand(co.x, co.y, co.z, co.w, co.v), rand(co.x, co.y, co.z, co.w, co.v), rand(co.x, co.y, co.z, co.w, co.v), rand(co.x, co.y, co.z, co.w, co.v), rand(co.x, co.y, co.z, co.w, co.v));\n    return r;\n}\n\n// Standard 6d noise\nfloat rand6dTime(vec6 co){\n    vec6 r = vec6(rand(co.x, co.y, co.z, co.w, co.v, co.u), rand(co.x, co.y, co.z, co.w, co.v, co.u), rand(co.x, co.y, co.z, co.w, co.v, co.u), rand(co.x, co.y, co.z, co.w, co.v, co.u), rand(co.x, co.y, co.z, co.w, co", "\n    vec3 h = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    vec3 h1 = vec3(0.0, 0.0, 0.0);\n    vec3 h2 = vec3(0.0, 0.0, 0.0);\n    vec3 h3 = vec3(0.0, 0.0, 0.0);\n    vec3 h4 = vec3(0.0, 0.0, 0.0);\n    vec3 h5 = vec3(0.0, 0.0, 0.0);\n    vec3 h6 = vec3(0.0, 0.0, 0.0);\n    vec3 h7 = vec3(0.0, 0.0, 0.0);\n    vec3 h8 = vec3(0.0, 0.0, 0.0);\n    vec3 h9 = vec3(0.0, 0.0, 0.0);\n    vec3 h10 = vec3(0.0, 0.0, 0.0);\n    vec3 h11 = vec3(0.0, 0.0, 0.0);\n    vec3 h12 = vec3(0.0, 0.0, 0.0);\n    vec3 h13 = vec3(0.0, 0.0, 0.0);\n    vec3 h14 = vec3(0.0, 0.", "\n    vec3 y = vec3(x.x, x.y, x.z);\n    vec3 z = vec3(x.x, x.y, x.z);\n    vec3 w = vec3(x.x, x.y, x.z);\n    vec3 v = vec3(x.x, x.y, x.z);\n    vec3 u = vec3(x.x, x.y, x.z);\n    vec3 d = vec3(x.x, x.y, x.z);\n    vec3 e = vec3(x.x, x.y, x.z);\n    vec3 f = vec3(x.x, x.y, x.z);\n    vec3 g = vec3(x.x, x.y, x.z);\n    vec3 h = vec3(x.x, x.y, x.z);\n    vec3 i = vec3(x.x, x.y, x.z);\n    vec3 j = vec3(x.x, x.y, x.z);\n    vec3 k = vec3(x.x, x.y, x.z);\n    vec3 l = vec3(x.x, x.y, x.z);\n    vec3 m = vec3(x.x, x.y, x.z);\n    vec3 n = vec3(x.x, x.y, x.z);\n    vec3 o = vec3(x.x, x.y, x.z);\n    vec3 p = vec3(x.x, x.y, x.z);\n    vec3 q = vec3(x.x, x.y, x.z);\n    vec3 r = vec3(x.x, x.y, x.z);\n    vec3 s = vec3(x.x, x.y, x.z);\n    vec3 t = vec3(x.x, x.y, x.z);\n    vec3 u = vec3(x.x, x.y, x.z);\n    vec3 v = vec3(x.x, x.y, x.z);\n    vec3 w = vec3", "\n    vec3 v = p;\n    v.x = v.x + (float)rand() / (float)RAND_MAX;\n    v.y = v.y + (float)rand() / (float)RAND_MAX;\n    v.z = v.z + (float)rand() / (float)RAND_MAX;\n    return v;\n}\n\n// 3D simplex noise, cool trick\nvec3 supernoise3d(vec3 p){\n    vec3 v = p;\n    v.x = v.x + (float)rand() / (float)RAND_MAX;\n    v.y = v.y + (float)rand() / (float)RAND_MAX;\n    v.z = v.z + (float)rand() / (float)RAND_MAX;\n    return v;\n}\n\n// 3D simplex noise, cool trick\nvec3 supernoise3d(vec3 p){\n    vec3 v = p;\n    v.x = v.x + (float)rand() / (float)RAND_MAX;\n    v.y = v.y + (float)rand() / (float)RAND_MAX;\n    v.z = v.z + (float)rand() / (float)RAND_MAX;\n    return v;\n}\n\n// 3D simplex noise, cool trick\nvec3 supernoise3d(vec3 p){\n    vec3 v = p;\n    v.x = v.x + (float)rand() / (float)RAND_MAX;\n    v.y = v.y + (float)rand() / (float)RAND_MAX;\n    v.z = v.z + (float)rand() / (float)RAND_MAX;\n    return v;\n}\n\n// 3D simplex noise, cool trick\nvec3 supernoise3d(vec3 p){\n    vec3 v = p;\n    v.x = v.x + (float)rand() / (float)RAND_MAX;\n    v.y = v.y + (float)rand() / (float)RAND_MAX;\n    v.z = v.z + (float", "\n    vec3 v = p - vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    for(int i = 0; i < 3; i++){\n        f += v[i] * v[i];\n    }\n    return f;\n}\n\n// This is the FBM that we want to optimize\nfloat fbm(vec3 p){\n    vec3 v = p - vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    for(int i = 0; i < 3; i++){\n        f += v[i] * v[i];\n    }\n    return f;\n}\n\n// This is the FBM that we want to optimize\nfloat fbm2(vec3 p){\n    vec3 v = p - vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    for(int i = 0; i < 3; i++){\n        f += v[i] * v[i];\n    }\n    return f;\n}\n\n// This is the FBM that we want to optimize\nfloat fbm3(vec3 p){\n    vec3 v = p - vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    for(int i = 0; i < 3; i++){\n        f += v[i] * v[i];\n    }\n    return f;\n}\n\n// This is the FBM that we want to optimize\nfloat fbm4(vec3 p){\n    vec3 v = p - vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    for(int i = 0; i < 3; i++){\n        f += v[i] * v[i];\n    }\n    return f;\n}\n\n// This is the FBM that we want to optimize\nfloat fbm5(vec3 p){\n    vec3 v = p - vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    for(int i = 0; i <", "\n    vec2 x = pos.x;\n    vec2 y = pos.y;\n    vec2 z = pos.z;\n    vec2 d = z;\n    vec2 d2 = d*d;\n    vec2 d3 = d2*d;\n    vec2 d4 = d3*d;\n    vec2 d5 = d4*d;\n    vec2 d6 = d5*d;\n    vec2 d7 = d6*d;\n    vec2 d8 = d7*d;\n    vec2 d9 = d8*d;\n    vec2 d10 = d9*d;\n    vec2 d11 = d10*d;\n    vec2 d12 = d11*d;\n    vec2 d13 = d12*d;\n    vec2 d14 = d13*d;\n    vec2 d15 = d14*d;\n    vec2 d16 = d15*d;\n    vec2 d17 = d16*d;\n    vec2 d18 = d17*d;\n    vec2 d19 = d18*d;\n    vec2 d20 = d19*d;\n    vec2 d21 = d20*d;\n    vec2 d22 = d21*d;\n    vec2 d23 = d22*d;\n    vec2 d24 = d23*d;\n    vec2 d25 = d24*d;\n    vec2 d26 = d25*d;\n    vec2 d27 = d26*d;\n    vec2 d28 = d27*d;\n    vec2 d29 = d28*d;\n    vec2 d30 = d29*d;\n    vec2 d31 = d30*d;\n    vec2 d32 = d31*d;\n    vec2 d33 = d32*d;\n    vec2 d34 = d33*d;\n    vec2 d35 = d34*d;\n    vec2 d36 = d35*d;\n    vec2 d37 = d36*d;\n    vec2 d38 = d37*d;\n    vec2 d39 = d38*d;\n    vec2 d40 = d39*d;\n    vec2 d41 =", "\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderCloud(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderShadow(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderShadowCloud(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderShadowCloud(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderShadowCloud(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderShadowCloud(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow = light * ray;\n    return shadow;\n}\n\nvec3 renderShadowCloud(vec3 point, float dist, float random){\n    vec3 ray = point + dist * normalize(random);\n    vec3 light = normalize(vec3(0, 0, 1));\n    vec3 shadow", "\n    vec3 raymarch = pointEnd - pointStart;\n    vec3 raymarchDir = normalize(raymarch);\n    vec3 raymarchDirNorm = normalize(raymarchDir);\n    vec3 raymarchDirNormInv = 1.0 / raymarchDirNorm;\n    vec3 raymarchDirInvNorm = 1.0 / raymarchDirNormInv;\n    vec3 raymarchDirInvNormInv = 1.0 / raymarchDirInvNormInv;\n    vec3 raymarchDirInvNormInvInv = 1.0 / raymarchDirInvNormInvInv;\n    vec3 raymarchDirInvNormInvInvInv = 1.0 / raymarchDirInvNormInvInvInv;\n    vec3 raymarchDirInvNormInvInvInvInv = 1.0 / raymarchDirInvNormInvInvInvInv;\n    vec3 raymarchDirInvNormInvInvInvInvInv = 1.0 / raymarchDirInvNormInvInvInvInvInv;\n    vec3 raymarchDirInvNormInvInvInvInvInvInvInv = 1.0 / raymarchDirInvNormInvInvInvInvInvInvInv;\n    vec3 raymarchDirInvNormInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInvInv", "\n    vec3 aces = vec3(0.0, 0.0, 0.0);\n    vec3 b = color;\n    vec3 c = b + vec3(0.0, 0.0, 0.0);\n    vec3 d = c + vec3(0.0, 0.0, 0.0);\n    vec3 e = d + vec3(0.0, 0.0, 0.0);\n    vec3 f = e + vec3(0.0, 0.0, 0.0);\n    vec3 g = f + vec3(0.0, 0.0, 0.0);\n    vec3 h = g + vec3(0.0, 0.0, 0.0);\n    vec3 i = h + vec3(0.0, 0.0, 0.0);\n    vec3 j = i + vec3(0.0, 0.0, 0.0);\n    vec3 k = j + vec3(0.0, 0.0, 0.0);\n    vec3 l = k + vec3(0.0, 0.0, 0.0);\n    vec3 m = l + vec3(0.0, 0.0, 0.0);\n    vec3 n = m + vec3(0.0, 0.0, 0.0);\n    vec3 o = n + vec3(0.0, 0.0, 0.0);\n    vec3 p = o + vec3(0.0, 0.0, 0.0);\n    vec3 q = p + vec3(0.0, 0.0, 0.0);\n    vec3 r = q + vec3(0.0, 0.0, 0.0);\n    vec3 s = r + vec3(0.0, 0.0, 0.0);\n    vec3 t = s + vec3(0.0, 0.0, 0.0);\n    vec3 u = t + vec3(0.0, 0.0, 0.0);\n    vec3 v = u + vec3(0.0, 0.0, 0.0);\n    vec3 w = v + vec3(0.0, 0.0, 0.0"]}