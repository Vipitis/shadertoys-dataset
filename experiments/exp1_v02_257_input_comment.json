{"input_comment": [[{"generated_text": "\n\treturn (cos(a*TAU)+1)/2;\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) =.5, fsin(2/3) =.5\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat"}], [{"generated_text": "\n    float d = length(p);\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat"}], [{"generated_text": "\n    return length(p - voxelPos);\n}\n\n// Distance to the voxel\nfloat"}], [{"generated_text": "\n    vec3 q = p - scene.position;\n    float d = dot(q, q);\n    P = scene.position + q * scene.radius;\n    return vec2(d, scene.radius);\n}\n\n// Distance to the scene and color of the closest point\nvec"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec2 q = p;\n        for (int j = 0; j < 10; j++) {\n            q = vec2(q.x * q.x - q.y * q.y, 2.0 * q.x * q.y) + vec2(0.0, 0.0);\n            d = length(q);\n            if (d > 2.0) break;\n        }\n        col += vec3(d < 1.0? 1.0 : 0.0);\n        p = q;\n    }\n    col /= 10.0;\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n// this is the main function that will be called by the shader\nvoid main()\n{\n    // get the position of the vertex\n    vec4 pos = gl_Vertex;\n\n    // get the position of the vertex in the texture\n    vec2 tex = (pos.xy / pos.w) * 0.5 + 0.5;\n\n    // get the color of the vertex\n    vec4 color = texture2D(tex_color, tex);\n\n    // get the color of the vertex\n    vec4 gradient_color = gradient(tex.x);\n\n    // get the color of the vertex\n    vec4 final_color = color * gradient_color;\n\n    // set the color of the vertex\n    gl_FragColor = final_color;\n}\n"}], [{"generated_text": "\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// shade a point based on distance\nvec"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(sunDir);\n    vec3 lightColor = vec3(1.0);\n    float lightRadius = 0.0;\n    float lightIntensity = 0.0;\n    float lightFade = 0.0;\n    float lightFadeEnd = 0.0;\n    float lightFadeStart = 0.0;\n    float lightFadeStep = 0.0;\n    float lightFadeStepEnd = 0.0;\n    float lightFadeStepStart = 0.0;\n    float lightFadeStepStartEnd = 0.0;\n    float lightFadeStepStartEndEnd = 0.0;\n    float lightFadeStepStartEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0."}], [{"generated_text": "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat"}], [{"generated_text": "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat"}], [{"generated_text": "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec2 q = p;\n        float a = 0.0;\n        for (int j = 0; j < 10; j++) {\n            q = abs(q);\n            q = q - 0.5;\n            a += length(q);\n        }\n        d = min(d, a);\n        p = p * 2.0 - 1.0;\n    }\n    col = vec3(d);\n\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    float n = 0.0;\n    float f = 1.0;\n    for (int i = 0; i < NUM_LAYERS; i++) {\n        n += f * fbm(p);\n        p *= 2.0;\n        f *= 0.5;\n    }\n    return n;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat"}], [{"generated_text": "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec"}], [{"generated_text": "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(i,vec2(1.0,0.0)),i.y,u.x),\n                   mix(dot(i+vec2(0.0,1.0),vec2(1.0,0.0)),i.x,u.x),u.y),\n               mix(mix(dot(i+vec2(1.0,1.0),vec2(1.0,1.0)),i.y,u.x),\n                   mix(dot(i+vec2(1.0,0.0),vec2(1.0,1.0)),i.x,u.x),u.y),f.y);\n}\n\n//\n// This is a modified version of the Voronoi3Tap function. It is used to generate a\n// 3D Voronoi noise field.\n//\n// The original Voronoi3Tap function is a 2D function. This modified version is a 3D\n// function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a"}], [{"generated_text": "\n    // The 2D Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point"}], [{"generated_text": "\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n   "}], [{"generated_text": "\n    // find the closest object\n    float t = -1.0;\n    vec2 closest = vec2(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < objects[i].radius && d < t)\n        {\n            t = d;\n            closest = objects[i].position;\n        }\n    }\n\n    // move the object/shape by messing with p\n    if (t > 0.0)\n    {\n        p = closest;\n    }\n\n    // find the closest point on the plane\n    float t2 = -1.0;\n    vec2 closest2 = vec2(0.0);\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        float d = distance(p, planes[i].position);\n        if (d < planes[i].radius && d < t2)\n        {\n            t2 = d;\n            closest2 = planes[i].position;\n        }\n    }\n\n    // move the plane by messing with p\n    if (t2 > 0.0)\n    {\n        p = closest2;\n    }\n\n    // find the closest point on the circle\n    float t3 = -1.0;\n    vec2 closest3 = vec2(0.0);\n    for (int i = 0; i < NUM_CIRCLES; i++)\n    {\n        float d = distance(p, circles[i].position);\n        if (d < circles[i].radius && d < t3)\n        {\n            t3 = d;\n            closest3 = circles[i].position;\n        }\n    }\n\n    // move the circle by messing with p\n    if (t3 > 0.0)\n    {\n        p = closest3;\n    }\n\n    // find the closest point on the triangle\n    float t4 = -1.0;\n    vec2 closest4 = vec2(0.0);\n    for (int i = 0; i <"}], [{"generated_text": "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\t"}], [{"generated_text": "\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/"}], [{"generated_text": "\n    // ray-plane intersection\n    float t = (plane.z - ro.z) / rd.z;\n    vec3 pt = ro + t * rd;\n\n    // ray-sphere intersection\n    vec3 oc = pt - sphere.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n\n    // ray-triangle intersection\n    vec3 pt2 = ro + t * rd;\n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 n = cross(e1, e2);\n    vec3 p1 = sphere.xyz + n * sphere.w;\n    vec3 p2 = sphere.xyz - n * sphere.w;\n    vec3 p3 = pt2;\n    vec3 v1 = p2 - p1;\n    vec3 v2 = p3 - p1;\n    vec3 v3 = pt2 - p1;\n    float s = sign(dot(n, cross(v1, v2)));\n    if (s < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0."}], [{"generated_text": "\n    vec3 n = vec3(0.0);\n    float d = 0.0001;\n    for(int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int k=-1; k<=1; k++)\n            {\n                vec3 p2 = p + vec3(i,j,k)*d;\n                vec3 oN2 = texture(texture_normal, p2).rgb;\n                n += oN2 - oN;\n            }\n        }\n    }\n    return normalize(n);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// output --> averaged? out normal vector at point p\nvec"}], [{"generated_text": "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Four corners in 3D space\n    float a = dot(i, vec3(1.0));\n    float b = dot(i, vec3(5.0));\n    float c = dot(i, vec3(7.0));\n    float d = dot(i, vec3(11.0));\n\n    // Smooth values of the four corners\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    // Mix 4 coords together to create a value between 0 and 1.\n    vec4 x = mix(vec4(a, b, c, d), vec4(b, c, d, a), u.z);\n    vec4 y = mix(vec4(d, a, b, c), vec4(c, a, b, d), u.y);\n    vec4 z0 = mix(vec4(a, b, c, d), vec4(c, a, b, d), u.x);\n    vec4 z1 = mix(vec4(d, a, b, c), vec4(a, b, c, d), u.x);\n\n    // Mix 4 values together to create a value between 0 and 1.\n    vec4 z = mix(z0, z1, u.z);\n    float z2 = mix(z.x, z.y, u.y);\n    return mix(z2, z.z, u.x);\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec2 texCoord = vec2(0.0);\n    float t = 0.0;\n    float step = 1.0 / 1024.0;\n    for (int i = 0; i < 1024; i++) {\n        texCoord.x = (i + 0.5) * step;\n        t = Raymarch(rayDir, texCoord);\n        if (t < 1.0) {\n            color += texture(u_envMap, texCoord).rgb * (1.0 - blur) + texture(u_envMap, texCoord + vec2(blur, 0.0)).rgb * blur;\n        }\n    }\n    return color;\n}\n\n// from https://www.shadertoy.com/view/XljGDz\nvec"}], [{"generated_text": "\n    float d = distance(coords, A);\n    float d1 = distance(coords, B);\n    float t = clamp(d / (d1 + d), 0.0, 1.0);\n    return height * t;\n}\n\n//============================================================\nfloat"}], [{"generated_text": "\n    float dot = dot(start, end);\n    float theta = acos(dot);\n    float sinTheta = sin(theta);\n    if (sinTheta < 0.0001)\n    {\n        return normalize(start + end);\n    }\n    float theta2 = theta * percent;\n    float sinTheta2 = sin(theta2);\n    float cosTheta2 = cos(theta2);\n    return normalize(start * cosTheta2 + end * sinTheta2 / sinTheta);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(r);\n    float f2 = fract(r * 0.5);\n    float f3 = fract(r * 0.25);\n    float f4 = fract(r * 0.125);\n    float f5 = fract(r * 0.0625);\n    float f6 = fract(r * 0.03125);\n    float f7 = fract(r * 0.015625);\n    float f8 = fract(r * 0.0078125);\n    float f9 = fract(r * 0.00390625);\n    float f10 = fract(r * 0.001953125);\n    float f11 = fract(r * 0.0009765625);\n    float f12 = fract(r * 0.00048828125);\n    float f13 = fract(r * 0.000244140625);\n    float f14 = fract(r * 0.0001220703125);\n    float f15 = fract(r * 0.00006103515625);\n    float f16 = fract("}], [{"generated_text": "\n    //http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n    vec2 v = b - a;\n    vec2 w = p - a;\n    float c1 = dot(w, v);\n    if (c1 <= 0.0)\n        return length(w);\n    vec2 vv = v;\n    normalize(vv);\n    float c2 = dot(vv, w);\n    if (c2 >= 0.0 && c2 <= length(v))\n        return length(w - v * c2);\n    return min(length(w - v * c1), length(w - v * c2));\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float lightIntensity = dot(lightDir, rayDir);\n    color = vec3(lightIntensity);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec"}], [{"generated_text": "\n    // The distance to the nearest surface.\n    float d = length(p.xz) - 1.0;\n\n    // The material index.\n    int m = 0;\n\n    // The distance to the nearest surface.\n    if (d < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = -d;\n\n        // The material index.\n        m = 1;\n    }\n\n    // The distance to the nearest surface.\n    if (p.y > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.y + 1.0);\n\n        // The material index.\n        m = 2;\n    }\n\n    // The distance to the nearest surface.\n    if (p.y < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.y - 1.0);\n\n        // The material index.\n        m = 3;\n    }\n\n    // The distance to the nearest surface.\n    if (p.x > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.x + 1.0);\n\n        // The material index.\n        m = 4;\n    }\n\n    // The distance to the nearest surface.\n    if (p.x < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.x - 1.0);\n\n        // The material index.\n        m = 5;\n    }\n\n    // The distance to the nearest surface.\n    if (p.z > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.z + 1.0);\n\n        // The material index.\n        m = 6;\n    }\n\n    // The distance to the nearest surface.\n    if (p.z < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.z - 1.0);\n\n        // The material index."}], [{"generated_text": "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org - vec3(0.0, 0.0, 0.0));\n    float c = dot(org - vec3(0.0, 0.0, 0.0), org - vec3(0.0, 0.0, 0.0)) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    d = sqrt(d);\n    float t0 = (-b - d) / (2.0 * a);\n    float t1 = (-b + d) / (2.0 * a);\n    if (t0 > t1)\n    {\n        near = t1;\n        far = t0;\n    }\n    else\n    {\n        near = t0;\n        far = t1;\n    }\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DX\nfloat"}], [{"generated_text": "\n    vec3 q = p - vec3(r.x, r.y, r.z);\n    vec3 q1 = q;\n    q.y -= s.y;\n    vec3 q2 = q;\n    q.y -= s.w;\n    vec3 q3 = q;\n    q.y -= s.z;\n    vec3 q4 = q;\n    q.y -= s.x;\n    vec3 q5 = q;\n    q.y -= s.y;\n    vec3 q6 = q;\n    q.y -= s.w;\n    vec3 q7 = q;\n    q.y -= s.z;\n    vec3 q8 = q;\n    q.y -= s.x;\n    vec3 q9 = q;\n    q.y -= s.y;\n    vec3 q10 = q;\n    q.y -= s.w;\n    vec3 q11 = q;\n    q.y -= s.z;\n    vec3 q12 = q;\n    q.y -= s.x;\n    vec3 q13 = q;\n    q.y -= s.y;\n    vec3 q14 = q;\n    q.y -= s.w;\n    vec3 q15 = q;\n    q.y -= s.z;\n    vec3 q16 = q;\n    q.y -= s.x;\n    vec3 q17 = q;\n    q.y -= s.y;\n    vec3 q18 = q;\n    q.y -= s.w;\n    vec3 q19 = q;\n    q.y -= s.z;\n    vec3 q20 = q;\n    q.y -= s.x;\n    vec3 q21 = q;\n    q.y -= s.y;\n    vec3 q22 = q;\n    q.y -= s.w;\n    vec3 q23 = q;\n"}], [{"generated_text": "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = i.x + i.y*57.0 + 113.0*i.z;\n\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)),\n                        dot(f, vec3(57.0, 113.0, 17.0)),\n                        f.y),\n                   mix(dot(f, vec3(17.0, 113.0, 57.0)),\n                       dot(f, vec3(57.0, 17.0, 113.0)),\n                       f.y),\n                   f.z),\n               mix(mix(dot(f, vec3(57.0, 17.0, 113.0)),\n                       dot(f, vec3(17.0, 57.0, 113.0)),\n                       f.z),\n                   mix(dot(f, vec3(113.0, 57.0, 17.0)),\n                       dot(f, vec3(57.0, 113.0, 17.0)),\n                       f.z),\n                   f.x),\n               f.x);\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat"}], [{"generated_text": "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 1.0) * 0.5;\n    float c = cos(a);\n    float s = sin(a);\n    float t = (d - 1.0) * 0.5;\n    float x = r * c;\n    float y = r * s;\n    float z = t;\n    float w = (d - 1.0) * 0.5;\n    float u = (d - 1.0) * 0.5;\n    float v = (d - 1.0) * 0.5;\n    float r2 = r * r;\n    float s2 = s * s;\n    float t2 = t * t;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float w2 = w * w;\n    float u2 = u * u;\n    float v2 = v * v;\n    float r3 = r2 * r;\n    float s3 = s2 * s;\n    float t3 = t2 * t;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float z3 = z2 * z;\n    float w3 = w2 * w;\n    float u3 = u2 * u;\n    float v3 = v2 * v;\n    float r4 = r3 * r;\n    float s4 = s3 * s;\n    float t4 = t3 * t;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float z4 = z3 * z;\n    float w4 = w3 * w;\n    float u4 = u3 * u;\n    float v4 = v3 * v;\n    float r5 = r4 * r;\n    float s5 = s4 * s;\n    float t5 = t4 * t;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float z5 ="}], [{"generated_text": "\n    vec3 bump = texture(bumpMap, sp.xy).rgb;\n    bump = normalize(bump * 2.0 - 1.0);\n    bump = normalize(bump * bumpFactor + sn);\n    return bump;\n}\n\n//\n// Standard bump function.\n//\nvec"}], [{"generated_text": "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec"}], [{"generated_text": "\n    // Ambient\n    vec3 ambient = vec3(0.1, 0.1, 0.1);\n\n    // Diffuse\n    vec3 lightDir = normalize(vec3(1, 1, 1));\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = vec3(0.5, 0.5, 0.5) * diff;\n\n    // Specular\n    vec3 viewDir = normalize(vec3(0, 0, 1));\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(n, halfDir), 0.0), 32.0);\n    vec3 specular = vec3(1, 1, 1) * spec;\n\n    return (ambient + diffuse + specular) * 0.3;\n}\n\n// Raymarching\n// p : point,\n// n : normal at point\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + p;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(r, r) > 4.0) break;\n        t = r;\n        r = r * r + p;\n    }\n\n    vec3 col = vec3(0.0);\n    if (dot(s, s) > 4.0) col = vec3(1.0, 0.0, 0.0);\n    if (dot(t, t) > 4.0) col = vec3(0.0, 1.0, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 col = vec3(0.0);\n    vec2 uv = vec2(atan(rd.z, rd.x), asin(rd.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    uv.x *= TAU;\n    uv.y *= TAU;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0."}], [{"generated_text": "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dp;\n    float dp2;\n    float dp3;\n    float dp4;\n    float dp5;\n    float dp6;\n    float dp7;\n    float dp8;\n    float dp9;\n    float dp10;\n    float dp11;\n    float dp12;\n    float dp13;\n    float dp14;\n    float dp15;\n    float dp16;\n    float dp17;\n    float dp18;\n    float dp19;\n    float dp20;\n    float dp21;\n    float dp22;\n    float dp23;\n    float dp24;\n    float dp25;\n    float dp26;\n    float dp27;\n    float dp28;\n    float dp29;\n    float dp30;\n    float dp31;\n    float dp32;\n    float dp33;\n    float dp34;\n    float dp35;\n    float dp36;\n    float dp37;\n    float dp38;\n    float dp39;\n    float dp40;\n    float dp41;\n    float dp42;\n    float dp43;\n    float dp44;\n    float dp45;\n    float dp46;\n    float dp47;\n    float dp48;\n    float dp49;\n    float dp50;\n    float dp51;\n    float dp52;\n    float dp53;\n    float dp54;\n    float dp55;\n    float dp56;\n    float dp57;\n    float dp58;\n    float dp59;\n    float dp60;"}], [{"generated_text": "\n    return length(p)-rad;\n}\n\n//cylinder\nfloat"}], [{"generated_text": "\n    float d = length(p);\n    float t = param.x;\n    float r = param.y;\n    float s = param.z;\n    float a = param.w;\n    float b = param.z;\n    float c = param.w;\n    float d1 = (d - r) / s;\n    float d2 = (d - a) / b;\n    float d3 = (d - c) / b;\n    float d4 = (d - c) / a;\n    float d5 = (d - b) / a;\n    float d6 = (d - b) / c;\n    float d7 = (d - a) / c;\n    float d8 = (d - t) / a;\n    float d9 = (d - t) / b;\n    float d10 = (d - t) / c;\n    float d11 = (d - t) / d;\n    float d12 = (d - t) / s;\n    float d13 = (d - t) / a;\n    float d14 = (d - t) / b;\n    float d15 = (d - t) / c;\n    float d16 = (d - t) / d;\n    float d17 = (d - t) / s;\n    float d18 = (d - t) / a;\n    float d19 = (d - t) / b;\n    float d20 = (d - t) / c;\n    float d21 = (d - t) / d;\n    float d22 = (d - t) / s;\n    float d23 = (d - t) / a;\n    float d24 = (d - t) / b;\n    float d25 = (d - t) / c;\n    float d26 = (d - t) / d;\n    float d27 = (d - t) / s;\n    float d28 = (d - t) / a;\n    float d29 = (d - t) / b;\n    float d30 = (d - t) / c;\n    float d31 = ("}], [{"generated_text": "\n    float d = DE_scene(p, param);\n    d = min(d, DE_light(p, param));\n    return d;\n}\n\n// scene distant with light gathering\nfloat"}], [{"generated_text": "\n    vec3 col = vec3(0.0);\n    vec3 bg = vec3(0.0);\n    vec3 sky = vec3(0.0);\n    vec3 kaliset = vec3(0.0);\n    vec3 kaliset2 = vec3(0.0);\n    vec3 kaliset3 = vec3(0.0);\n    vec3 kaliset4 = vec3(0.0);\n    vec3 kaliset5 = vec3(0.0);\n    vec3 kaliset6 = vec3(0.0);\n    vec3 kaliset7 = vec3(0.0);\n    vec3 kaliset8 = vec3(0.0);\n    vec3 kaliset9 = vec3(0.0);\n    vec3 kaliset10 = vec3(0.0);\n    vec3 kaliset11 = vec3(0.0);\n    vec3 kaliset12 = vec3(0.0);\n    vec3 kaliset13 = vec3(0.0);\n    vec3 kaliset14 = vec3(0.0);\n    vec3 kaliset15 = vec3(0.0);\n    vec3 kaliset16 = vec3(0.0);\n    vec3 kaliset17 = vec3(0.0);\n    vec3 kaliset18 = vec3(0.0);\n    vec3 kaliset19 = vec3(0.0);\n    vec3 kaliset20 = vec3(0.0);\n    vec3 kaliset21 = vec3(0.0);\n    vec3 kaliset22 = vec3(0.0);\n    vec3 kaliset23 = vec3(0.0);\n    vec3 kaliset24 = vec3(0.0);\n    vec3 kaliset25 = vec3(0.0);\n   "}], [{"generated_text": "\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * ti;\n    float d = length(p);\n    if (d < 0.001)\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 muv = uv * 2.0 - 1.0;\n    muv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(muv, 1.0));\n\n    float ti = 0.0;\n    float tf = 1000.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        ti = tmin;\n        tf = tmax;\n        float t = (ti + tf) * 0.5;\n        vec3 p = ro + rd * t;\n        float d = length(p);\n        if (d < 0.001)\n        {\n            break;\n        }\n        if (d < ti)\n        {\n            ti = d;\n        }\n        if (d > tf)\n        {\n            tf = d;\n        }\n    }\n\n    vec3 col = rayColor(ro, rd, ti);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col,"}], [{"generated_text": "\n    vec2 q = abs(p - diamond.xy);\n    return min(max(q.x, q.y), diamond.z);\n}\n\n// triangle: (center.x, center.y, helf width, helf height)\nfloat"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    float t = time * 0.01;\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 1.0) * 10.0;\n    float n = floor(d);\n    float f = fract(d);\n    float p = n + f;\n    float w = p * 0.1;\n    float h = p * 0.1;\n    float x = w * c;\n    float y = h * s;\n    float z = w * s;\n    float rx = x * 0.1;\n    float ry = y * 0.1;\n    float rz = z * 0.1;\n    float rw = r * 0.1;\n    float rx2 = rx * 0.1;\n    float ry2 = ry * 0.1;\n    float rz2 = rz * 0.1;\n    float rw2 = rw * 0.1;\n    float rx3 = rx2 * 0.1;\n    float ry3 = ry2 * 0.1;\n    float rz3 = rz2 * 0.1;\n    float rw3 = rw2 * 0.1;\n    float rx4 = rx3 * 0.1;\n    float ry4 = ry3 * 0.1;\n    float rz4 = rz3 * 0.1;\n    float rw4 = rw3 * 0.1;\n    float rx5 = rx4 * 0.1;\n    float ry5 = ry4 * 0.1;\n    float rz5 = rz4 * 0.1;\n    float rw5 = rw4 * 0.1;\n    float rx6 = rx5 * 0.1;\n    float ry6 = ry5 * 0.1;\n   "}], [{"generated_text": "\n    return length( pos - vec3( 0.5, 0.5, 0.5 ) );\n}\n\n// get distance in the world\nfloat"}], [{"generated_text": "\n    vec3 l = normalize(v - eye);\n    vec3 r = reflect(-l, n);\n    vec3 h = normalize(l + eye);\n    float s = pow(max(dot(n, l), 0.0), 10.0);\n    float t = pow(max(dot(n, h), 0.0), 10.0);\n    return (0.2 * s + 0.8 * t) * vec3(1.0, 1.0, 1.0);\n}\n\n// phong shading with specular highlights\nvec"}], [{"generated_text": "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat"}], [{"generated_text": "\n    float d = distance(p, vec2(0.5));\n    return pow(d, 1.0 - offset) * 0.5;\n}\n\n// 2D noise function. \nfloat"}], [{"generated_text": "\n    float xmts = x.x;\n    float xmts_a = x.y;\n    float xmts_b = x.z;\n    float xmts_c = x.w;\n    float xmts_d = x.z;\n    float xmts_e = x.w;\n    float xmts_f = x.w;\n    float xmts_g = x.w;\n    float xmts_h = x.w;\n    float xmts_i = x.w;\n    float xmts_j = x.w;\n    float xmts_k = x.w;\n    float xmts_l = x.w;\n    float xmts_m = x.w;\n    float xmts_n = x.w;\n    float xmts_o = x.w;\n    float xmts_p = x.w;\n    float xmts_q = x.w;\n    float xmts_r = x.w;\n    float xmts_s = x.w;\n    float xmts_t = x.w;\n    float xmts_u = x.w;\n    float xmts_v = x.w;\n    float xmts_w = x.w;\n    float xmts_x = x.w;\n    float xmts_y = x.w;\n    float xmts_z = x.w;\n    float xmts_aa = x.w;\n    float xmts_ab = x.w;\n    float xmts_ac = x.w;\n    float xmts_ad = x.w;\n    float xmts_ae = x.w;\n    float xmts_af = x.w;\n    float xmts_ag = x.w;\n    float xmts_ah = x.w;\n    float xmts_ai = x.w;\n    float xmts_aj = x.w;\n    float xmts_ak = x.w;\n    float xmts_al = x.w;\n    float xmts_"}], [{"generated_text": "\n    vec2 d = abs(vec2(length(p.xz) - r, p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * Signed distance function for an XY aligned sphere centered at the origin with\n * radius r.\n */\nfloat"}], [{"generated_text": "\n    vec3 q = p;\n    q.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n    q.yz *= mat2(1.0, 0.0, 0.0, 1.0);\n    return length(q) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat"}], [{"generated_text": "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat"}], [{"generated_text": "\n    return 0.5 + 0.5*sin(p.x*100.0+p.y*100.0+p.z*100.0);\n}\n\n// my noise\nfloat"}], [{"generated_text": "\n\tvec4 color = vec4(0.0);\n\t\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\t\n\tfloat x1 = x - morphConstant.x;\n\tfloat y1 = y - morphConstant.y;\n\t\n\tfloat x2 = x + morphConstant.x;\n\tfloat y2 = y + morphConstant.y;\n\t\n\tfloat x3 = x - morphConstant.x;\n\tfloat y3 = y + morphConstant.y;\n\t\n\tfloat x4 = x + morphConstant.x;\n\tfloat y4 = y - morphConstant.y;\n\t\n\tfloat x5 = x - morphConstant.x;\n\tfloat y5 = y + morphConstant.y;\n\t\n\tfloat x6 = x + morphConstant.x;\n\tfloat y6 = y - morphConstant.y;\n\t\n\tfloat x7 = x - morphConstant.x;\n\tfloat y7 = y + morphConstant.y;\n\t\n\tfloat x8 = x + morphConstant.x;\n\tfloat y8 = y - morphConstant.y;\n\t\n\tfloat x9 = x - morphConstant.x;\n\tfloat y9 = y + morphConstant.y;\n\t\n\tfloat x10 = x + morphConstant.x;\n\tfloat y10 = y - morphConstant.y;\n\t\n\tfloat x11 = x - morphConstant.x;\n\tfloat y11 = y + morphConstant.y;\n\t\n\tfloat x12 = x + morphConstant.x;\n\tfloat y12 = y - morphConstant.y;\n\t\n\tfloat x13 = x - morphConstant.x;\n\tfloat y13 = y + morphConstant.y;\n\t\n\tfloat x14 = x + morphConstant.x;\n\tfloat y14 = y - morphConstant.y;\n\t\n\tfloat x15 = x - morphConstant.x;\n\tfloat y15 = y + morphConstant.y;\n\t\n\tfloat x16 = x + morphConstant.x;\n\tfloat y16 = y - morphConstant.y;\n\t\n\tfloat x17 = x - morphConstant.x;"}], [{"generated_text": "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * w);\n}\n\n// vec3 to vec3 hash.\nvec"}], [{"generated_text": "\n    float f = sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n    f = f * f * (3.0 - 2.0 * f);\n    return f;\n}\n\n// The bump mapping function.\nfloat"}], [{"generated_text": "\n    vec4 ray_nds = vec4(scr_pt, 0.0, 1.0);\n    vec4 ray_clip = view_inv * ray_nds;\n    vec4 ray_eye = viewp_inv * ray_clip;\n    vec4 ray_world = proj_inv * ray_eye;\n    ray_world.xyz /= ray_world.w;\n    return ray_world;\n}\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec"}], [{"generated_text": "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dp = dot(d, uv - p);\n    float dl2 = dl * dl;\n    float dp2 = dp * dp;\n    float dl4 = dl2 * dl2;\n    float dp4 = dp2 * dp2;\n    float dl8 = dl4 * dl4;\n    float dp8 = dp4 * dp4;\n    float dl16 = dl8 * dl8;\n    float dp16 = dp8 * dp8;\n    float dl32 = dl16 * dl16;\n    float dp32 = dp16 * dp16;\n    float dl64 = dl32 * dl32;\n    float dp64 = dp32 * dp32;\n    float dl128 = dl64 * dl64;\n    float dp128 = dp64 * dp64;\n    float dl256 = dl128 * dl128;\n    float dp256 = dp128 * dp128;\n    float dl512 = dl256 * dl256;\n    float dp512 = dp256 * dp256;\n    float dl1024 = dl512 * dl512;\n    float dp1024 = dp512 * dp512;\n    float dl2048 = dl1024 * dl1024;\n    float dp2048 = dp1024 * dp1024;\n    float dl4096 = dl2048 * dl2048;\n    float dp4096 = dp2048 * dp2048;\n    float dl8192 = dl"}], [{"generated_text": "\n    // TODO: implement this function\n    // You can use the following variables:\n    //   p : the point at which the shading is performed\n    //   n : the normal at the point\n    //   light : the light source\n    //   light.position : the position of the light source\n    //   light.intensity : the intensity of the light source\n    //   light.color : the color of the light source\n    //   light.attenuation : the attenuation factor of the light source\n    //   light.type : the type of the light source (ambient, point, spot, directional)\n    //   light.spot.direction : the direction of the spotlight\n    //   light.spot.cutoff : the cutoff angle of the spotlight\n    //   light.spot.exponent : the exponent of the spotlight\n    //   light.spot.innerCutoff : the inner cutoff angle of the spotlight\n    //   light.spot.outerCutoff : the outer cutoff angle of the spotlight\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.color : the color of the spotlight\n    //   light.spot.intensity : the intensity of the spotlight\n    //   light.spot.attenuation : the attenuation factor of the spotlight\n    //   light.spot.type : the type of the spotlight (constant, linear, quadratic)\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.innerCutoff : the inner cutoff angle of the spotlight\n    //   light.spot.outerCutoff : the outer cutoff angle of the spotlight\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.color : the color of the spotlight\n    //   light.spot.intensity : the intensity of the spotlight\n    //   light.spot.attenuation : the attenuation factor of the spotlight\n    //   light.spot.type : the type of the spotlight (constant, linear, quadratic)\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light."}], [{"generated_text": "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec"}], [{"generated_text": "\n  return sin(x * a) * 0.5 + sin(x * b) * 0.5 + 0.5;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat"}], [{"generated_text": "\n    return vec2(a.x * b.x, a.y * b.y);\n}\n\n// z * z\nvec"}], [{"generated_text": "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec"}], [{"generated_text": "\n    vec3 P0 = O.xyz;\n    vec3 P1 = O.xyz + vec3(U.x, U.y, 0.0);\n    vec3 P2 = O.xyz + vec3(U.x, 0.0, U.y);\n    vec3 P3 = O.xyz + vec3(0.0, U.y, U.x);\n    vec3 P4 = O.xyz + vec3(0.0, 0.0, U.x);\n    vec3 P5 = O.xyz + vec3(U.x, U.y, U.x);\n    vec3 P6 = O.xyz + vec3(U.x, U.x, U.y);\n    vec3 P7 = O.xyz + vec3(U.x, U.x, 0.0);\n    vec3 P8 = O.xyz + vec3(0.0, U.x, U.y);\n    vec3 P9 = O.xyz + vec3(0.0, U.x, 0.0);\n    vec3 P10 = O.xyz + vec3(U.x, 0.0, 0.0);\n    vec3 P11 = O.xyz + vec3(0.0, 0.0, 0.0);\n    vec3 P12 = O.xyz + vec3(0.0, U.y, 0.0);\n    vec3 P13 = O.xyz + vec3(0.0, 0.0, 0.0);\n    vec3 P14 = O.xyz + vec3(0.0, 0.0, U.x);\n    vec3 P15 = O.xyz + vec3(0.0, U.y, U.x);\n    vec3 P16 = O.xyz + vec3(0.0, U.y, 0.0);\n    vec3 P17 = O.xyz +"}], [{"generated_text": "\n    float d = dot(p, p);\n    return sqrt(d);\n}\n\n// distance estimation of the scene\nfloat"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    float scale = 1.0;\n    float scaleFactor = 1.0;\n    float scaleFactor2 = 1.0;\n    float scaleFactor3 = 1.0;\n    float scaleFactor4 = 1.0;\n    float scaleFactor5 = 1.0;\n    float scaleFactor6 = 1.0;\n    float scaleFactor7 = 1.0;\n    float scaleFactor8 = 1.0;\n    float scaleFactor9 = 1.0;\n    float scaleFactor10 = 1.0;\n    float scaleFactor11 = 1.0;\n    float scaleFactor12 = 1.0;\n    float scaleFactor13 = 1.0;\n    float scaleFactor14 = 1.0;\n    float scaleFactor15 = 1.0;\n    float scaleFactor16 = 1.0;\n    float scaleFactor17 = 1.0;\n    float scaleFactor18 = 1.0;\n    float scaleFactor19 = 1.0;\n    float scaleFactor20 = 1.0;\n    float scaleFactor21 = 1.0;\n    float scaleFactor22 = 1.0;\n    float scaleFactor23 = 1.0;\n    float scaleFactor24 = 1.0;\n    float scaleFactor25 = 1.0;\n    float scaleFactor26 = 1.0;\n    float scaleFactor27 = 1.0;\n    float scaleFactor28 = 1.0;\n    float scaleFactor29 = 1.0;\n    float scaleFactor30 = 1.0;\n    float scaleFactor31 = 1.0;\n    float scaleFactor32 = 1.0;\n    float scaleFactor33 = 1.0;\n    float scaleFactor34 = 1.0;\n    float scaleFactor35 = 1.0;\n    float scaleFactor36 = 1.0;\n    float scaleFactor37 = 1.0;\n    float scaleFactor38 = 1.0;\n    float scale"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec2 q = p;\n    float r = length(q);\n    if(r < 0.5){\n        color = vec3(1.0);\n    }\n    else{\n        float t = (r-0.5) * 2.0;\n        color = vec3(0.5 + 0.5 * cos(t * 3.1415926535897932384626433832795));\n    }\n    return color;\n}\n\n// The decrotated scale tiles. Render one set of decorated fans, combine them with the\n// other set, then add some highlighting and postprocessing.\nvec"}], [{"generated_text": "\n    float flameRadius = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], [{"generated_text": "\n    // 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1."}], [{"generated_text": "\n    return fract(x * sm) - 0.5 * sm;\n}\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat"}], [{"generated_text": "\n    p = fract(p * vec3(12345.6789, 12345.6789, 12345.6789));\n    p += dot(p, p + 19.19);\n    return fract(vec3(dot(p, p + 137.19), dot(p, p + 269.59), dot(p, p + 41.71)));\n}\n\n// 3D noise function.\nfloat"}], [{"generated_text": "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)), dot(f, vec3(57.0, 113.0, 17.0)), f.y),\n        mix(dot(f, vec3(113.0, 57.0, 17.0)), dot(f, vec3(17.0, 113.0, 57.0)), f.y), f.z),\n        mix(mix(dot(f, vec3(57.0, 17.0, 113.0)), dot(f, vec3(17.0, 57.0, 113.0)), f.y),\n        mix(dot(f, vec3(113.0, 17.0, 57.0)), dot(f, vec3(57.0, 113.0, 17.0)), f.y), f.z),\n        f.x);\n}\n\n// 3D Simplex noise.\nfloat"}], [{"generated_text": "\n    return 0.5*sin(p.x*10.0)+0.5*sin(p.y*10.0);\n}\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat"}], [{"generated_text": "\n    vec2 balloon = vec2( 0.0 );\n    float balloonRadius = 0.001;\n    float balloonHeight = 0.001;\n    float balloonWidth = 0.001;\n    float balloonDepth = 0.001;\n    float balloonX = currentRayPosition.x;\n    float balloonY = currentRayPosition.y;\n    float balloonZ = currentRayPosition.z;\n    float balloonX2 = balloonX + balloonWidth;\n    float balloonY2 = balloonY + balloonHeight;\n    float balloonZ2 = balloonZ + balloonDepth;\n    float balloonX3 = balloonX - balloonWidth;\n    float balloonY3 = balloonY - balloonHeight;\n    float balloonZ3 = balloonZ - balloonDepth;\n    float balloonX4 = balloonX + balloonWidth;\n    float balloonY4 = balloonY - balloonHeight;\n    float balloonZ4 = balloonZ + balloonDepth;\n    float balloonX5 = balloonX - balloonWidth;\n    float balloonY5 = balloonY + balloonHeight;\n    float balloonZ5 = balloonZ - balloonDepth;\n    float balloonX6 = balloonX + balloonWidth;\n    float balloonY6 = balloonY + balloonHeight;\n    float balloonZ6 = balloonZ - balloonDepth;\n    float balloonX7 = balloonX - balloonWidth;\n    float balloonY7 = balloonY - balloonHeight;\n    float balloonZ7 = balloonZ + balloonDepth;\n    float balloonX8 = balloonX + balloonWidth;\n    float balloonY8 = balloonY - balloonHeight;\n    float balloonZ8 = balloonZ + balloonDepth;\n    float balloonX9 = balloonX - balloonWidth;\n    float balloonY9 = balloonY + balloonHeight;\n    float balloonZ9 = balloonZ - balloonDepth;\n    float balloonX10 = balloonX + balloonWidth"}], [{"generated_text": "\n    vec3 n = sign(rd);\n    vec3 k = abs(n) - rad;\n    vec3 t1 = k / rd;\n    vec3 t2 = k / ro;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    vec4 r = vec4(tmin.x, tmin.yz);\n    if(tmax.x < 0.0) discard;\n    r.yz = max(r.yz, tmax.yx);\n    return r;\n}\n\n// ray sphere intersection by iq https://www.shadertoy.com/view/ld23DV\nvec"}], [{"generated_text": "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y + p.z;\n    return -1.0 + 2.0*f.x + f.y + f.z + f.x + f.y + f.z + f.x + f.y + f.z;\n}\n\n// 3D Simplex noise.\nfloat"}], [{"generated_text": "\n    vec2 ab = b-a;\n    vec2 ac = c-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    vec2 cp = p-c;\n    vec2 apxb = cross(ap,ab);\n    vec2 apxc = cross(ap,ac);\n    vec2 bpxc = cross(bp,ac);\n    vec2 bpxa = cross(bp,ab);\n    vec2 cpxa = cross(cp,ab);\n    vec2 cpxb = cross(cp,bc);\n    float d1 = dot(apxb,ab);\n    float d2 = dot(apxc,ac);\n    float d3 = dot(bpxa,ab);\n    float d4 = dot(bpxc,ac);\n    float d5 = dot(cpxa,ab);\n    float d6 = dot(cpxb,bc);\n    float denom = d1*d4 - d3*d2;\n    float v1 = (d5*d4 - d3*d6)/denom;\n    float v2 = (d2*d1 - d4*d3)/denom;\n    return c + v1*ab + v2*ac;\n}\n\n//coloring lineAO()\nvec"}], [{"generated_text": "\n    float a = 0.0;\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 0.0;\n}\n\n//Fractal calculation loop\nfloat"}], [{"generated_text": "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n    return mat4(x, y, z, vec4(0, 0, 0, 1));\n}\n\n//perspective matrix\nmat"}], [{"generated_text": "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//color space\nvec"}], [{"generated_text": "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float d = w / 2.0;\n    float c = cos(a);\n    float s = sin(a);\n    float x = r * c;\n    float y = r * s;\n    float t = (x * c + y * s) / d;\n    float u = (x * s - y * c) / d;\n    return t * u;\n}\n\n// This is the main function. It's a bit of a mess, but it's pretty easy to understand.\n// The first thing it does is check if the mouse is inside the circle. If it is, it\n// returns 1. If it's not, it returns 0.\nfloat"}], [{"generated_text": "\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat"}], [{"generated_text": "\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;"}], [{"generated_text": "\n    float d=1.0;\n    for(int i=0;i<4;i++){\n        d=min(d,length(p-voronoi(p+vec2(0.0,j*i*0.1),j)));\n    }\n    return d;\n}\n\nfloat"}], [{"generated_text": "\n    return smoothstep(0.0,1.0,f);\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat"}], [{"generated_text": "\n    vec3 rgb = vec3(0.0);\n    rgb.r = c.r * 0.299 + c.g * 0.587 + c.b * 0.114;\n    rgb.g = c.r * 0.5957 + c.g * 0.332 + c.b * 0.131;\n    rgb.b = c.r * 0.2115 + c.g * 0.7152 + c.b * 0.0722;\n    return rgb;\n}\n\n//enhance the hue of a color\nvec"}], [{"generated_text": "\n    vec4 d = vec4(0.0);\n    d.x = max(abs(p.x)-s.x,0.0);\n    d.y = max(abs(p.y)-s.y,0.0);\n    d.z = max(abs(p.z)-s.z,0.0);\n    return d;\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec"}], [{"generated_text": "\n    vec4 rv = vec4(0.0);\n    if(s==0) {\n        rv.x = sdSphere(p,r.x);\n        rv.y = sdBox(p,vec3(r.x,r.y,r.y));\n        rv.z = sdCylinder(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCone(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==1) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==2) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==3) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule("}], [{"generated_text": "\n    Material mat = Material(vec3(0.0), vec3(0.0), vec3(0.0));\n    vec3 sourceMaterial = vec3(0.0);\n    vec3 targetMaterial = vec3(0.0);\n    float interpolant = 0.0;\n\n    // If we're at the end of the scene, return the final material\n    if (steps == 0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 0.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 1.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 2.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 3.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 4.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 5.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 6.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 7.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n"}], [{"generated_text": "\n    return clamp(x * (2.51 * x + 0.04), 0.0, 1.0);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec"}], [{"generated_text": "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;\n    float bd = 0.0"}], [{"generated_text": "\n    vec3 n = normal(p);\n    vec3 r = reflect(lightDir(p), n);\n    float s = max(0.0, dot(r, viewDir));\n    return vec4(vec3(s), 1.0);\n}\n\n//scene light at position p\nvec"}], [{"generated_text": "\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        f += a * noise(p);\n        p = rot * p * 2.02 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// returns a fractal noise in a 3D space\nfloat"}], [{"generated_text": "\n    p = p*2.-1.;\n    float a = dot(p,p);\n    float b = dot(p,vec2(p.y, -p.x));\n    float c = dot(p,vec2(-p.y, p.x));\n    float d = dot(p,vec2(p.y,-p.y));\n    float e = dot(p,vec2(-p.x,-p.x));\n    float f = dot(p,vec2(p.x,-p.x));\n    float g = dot(p,vec2(-p.x,p.x));\n    float h = dot(p,vec2(p.x,p.x));\n    float i = dot(p,vec2(p.y,p.y));\n    float j = dot(p.xz,p.xz);\n    float k = dot(p.yz,p.yz);\n    float l = dot(p.xz,p.yz);\n    float m = dot(p.xz,p.xz);\n    float n = dot(p.yz,p.xz);\n    float o = dot(p.yz,p.yz);\n    float p = dot(p.xz,p.yz);\n    float q = dot(p.xz,p.xz);\n    float r = dot(p.yz,p.xz);\n    float s = dot(p.yz,p.yz);\n    float t = dot(p.xz,p.yz);\n    float u = dot(p.xz,p.xz);\n    float v = dot(p.yz,p.xz);\n    float w = dot(p.yz,p.yz);\n    float x = dot(p.xz,p.yz);\n    float y = dot(p.xz,p.xz);\n    float z = dot(p.yz,p.xz);\n    float aa = a*a;\n    float ab = a*b;\n    float ac = a*c;\n    float ad = a*d;\n    float a"}], [{"generated_text": "\n    return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat"}], [{"generated_text": "\n    float d = dot(u,m);\n    return d;\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat"}], [{"generated_text": "\n    vec2 d = u - m.xy;\n    vec2 d1 = abs(d) - m.zw;\n    return length(max(d,0.0)) + min(max(d1.x,d1.y),0.0);\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat"}], [{"generated_text": "\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;"}], [{"generated_text": "\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U, v10 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U"}], [{"generated_text": "\n    return normalize(a - dot(a, b) * b);\n}\n\n//Gram-Schmidt method\nvec"}], [{"generated_text": "\n    vec3 v0 = B - A;\n    vec3 v1 = C - A;\n    vec3 v2 = cross(v0, v1);\n    float a = length(v2);\n    float alpha = acos(dot(v0, v1) / (a * length(v0)));\n    float beta = acos(dot(v1, v2) / (a * length(v1)));\n    float gamma = acos(dot(v2, v0) / (a * length(v2)));\n    float s = sin(alpha);\n    float c = cos(alpha);\n    float t = sin(beta);\n    float u = cos(beta);\n    float p = sin(gamma);\n    float q = cos(gamma);\n    float r = sqrt(Xi1);\n    float sigma = sqrt(Xi2);\n    float z = r * c * t;\n    float x = r * s * p;\n    float y = r * s * q;\n    w = vec3(x, y, z);\n    wPdf = (a * sigma * s) / (4.0 * PI);\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangle(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec3 v0 = B - A;\n    vec3 v1 = C - A;\n    vec3 v2 = cross(v0, v1);\n    float a = length(v2);\n    float alpha = acos(dot(v0, v1) / (a * length(v0)));\n    float beta = acos(dot(v1, v2) / (a * length(v1)));\n    float gamma = acos(dot("}], [{"generated_text": "\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U, v10 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U"}], [{"generated_text": "\n    float d = length(p);\n    if(d < 0.5){\n        return 1.0;\n    }\n    return 0.0;\n}\n\n// Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n// beveled sides.\nfloat"}], [{"generated_text": "\n    vec4 res = vec4(0.0);\n    float d = length(p.xy);\n    if(d < 0.5){\n        res.rgb = vec3(0.0);\n        res.a = 1.0;\n    }\n    else{\n        res.rgb = vec3(0.0);\n        res.a = 0.0;\n    }\n    return res;\n}\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec"}], [{"generated_text": "\n    float d = distance(p, vec3(0.0));\n    float t = gID;\n    float a = t * 0.01;\n    float b = t * 0.02;\n    float c = t * 0.03;\n    float d1 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d2 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d3 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d4 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d5 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d6 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d7 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d8 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d9 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d10 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d11 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d12 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d13 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d14 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d15 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d16 = distance(p, vec3(0.0, 0."}], [{"generated_text": "\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\tfloat tmax18 = 1000.0;\n"}], [{"generated_text": "\n    float d = length(lp - ro);\n    float f = k / (d * d);\n    return f * exp(-t * f);\n}\n\n// The main raymarching function.\nfloat"}], [{"generated_text": "\n    vec3 q = p;\n    vec3 d = vec3(0.0);\n    float dd = 0.0;\n    float ddd = 0.0;\n    float dddd = 0.0;\n    float ddddd = 0.0;\n    float dddddd = 0.0;\n    float ddddddd = 0.0;\n    float dddddddd = 0.0;\n    float ddddddddd = 0.0;\n    float dddddddddd = 0.0;\n    float ddddddddddd = 0.0;\n    float dddddddddddd = 0.0;\n    float ddddddddddddd = 0.0;\n    float dddddddddddddd = 0.0;\n    float ddddddddddddddd = 0.0;\n    float dddddddddddddddd = 0.0;\n    float ddddddddddddddddd = 0.0;\n    float dddddddddddddddddd = 0.0;\n    float ddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddddd = 0.0;\n   "}], [{"generated_text": "\n    vec3 p0 = m[0] * p3;\n    vec3 p1 = m[1] * p3;\n    vec3 p2 = m[2] * p3;\n    vec3 p4 = m[3] * p3;\n    vec3 p5 = m[4] * p3;\n    vec3 p6 = m[5] * p3;\n    vec3 p7 = m[6] * p3;\n    vec3 p8 = m[7] * p3;\n    vec3 p9 = m[8] * p3;\n    vec3 p10 = m[9] * p3;\n    vec3 p11 = m[10] * p3;\n    vec3 p12 = m[11] * p3;\n    vec3 p13 = m[12] * p3;\n    vec3 p14 = m[13] * p3;\n    vec3 p15 = m[14] * p3;\n    vec3 p16 = m[15] * p3;\n    vec3 p17 = m[16] * p3;\n    vec3 p18 = m[17] * p3;\n    vec3 p19 = m[18] * p3;\n    vec3 p20 = m[19] * p3;\n    vec3 p21 = m[20] * p3;\n    vec3 p22 = m[21] * p3;\n    vec3 p23 = m[22] * p3;\n    vec3 p24 = m[23] * p3;\n    vec3 p25 = m[24] * p3;\n    vec3 p26 = m[25] * p3;\n    vec3 p27 = m[26] * p3;\n    vec3 p28 = m[27] * p3;\n    vec3 p29 = m[28] * p3;\n    vec3 p30 ="}], [{"generated_text": "\n    vec4 hex = vec4(p, 0.0, 1.0);\n    hex.xy = mod(hex.xy, 2.0) - 1.0;\n    return hex;\n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec"}], [{"generated_text": "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float b = atan(p.y, -p.x);\n    float c = atan(p.x, p.y);\n    float d1 = abs(a - dir);\n    float d2 = abs(b - dir);\n    float d3 = abs(c - dir);\n    return min(d1, min(d2, d3));\n}\n\n// Truchet pattern distance field.\nfloat"}], [{"generated_text": "\n    return atan2(q.y, q.x) + dir;\n}\n\n// Get the polar coordinate of the arc pixel.\nfloat"}], [{"generated_text": "\n    vec3 v0 = p3 - n[0];\n    vec3 v1 = p3 - n[1];\n    vec3 v2 = p3 - n[2];\n    vec3 v3 = p3 - t;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d02 = dot(v0, v2);\n    float d11 = dot(v1, v1);\n    float d12 = dot(v1, v2);\n    float d22 = dot(v2, v2);\n    float inv_det = 1.0 / (d00 * d11 * d22 + d01 * d12 * d02 + d02 * d10 * d01 - d00 * d12 * d11 - d01 * d10 * d22 - d02 * d11 * d00);\n    return vec4(\n        (d11 * d22 - d12 * d12) * inv_det,\n        (d02 * d22 - d01 * d22) * inv_det,\n        (d01 * d12 - d02 * d11) * inv_det,\n        1.0\n    );\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec"}], [{"generated_text": "\n    vec4 s = cross(q, p);\n    float d = dot(s, r);\n    return d * d;\n}\n\n// Find the (squared) distance to the plane in R3 but\n// using homogeneous coordinates.\nfloat"}], [{"generated_text": "\n    float d = length(p);\n    return smoothstep(lW, lW+0.01, d);\n}\n\n// A simple 2D noise function.\nfloat"}], [{"generated_text": "\n    vec2 d = ddx * ddy;\n    return 0.25 * (\n        (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x + p.y) * (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * (p.x + p.y) * d.x * d.y\n    );\n}\n\n// grid ratio\nfloat"}], [{"generated_text": "\n    float d = dot( n, n );\n    if( d > 0.0 )\n    {\n        float d2 = dot( f, f );\n        if( d2 > d )\n        {\n            float d3 = d2 - d;\n            float d4 = d3 * d3;\n            float d5 = d4 * d4;\n            float d6 = d5 * d5;\n            float d7 = d6 * d6;\n            float d8 = d7 * d7;\n            float d9 = d8 * d8;\n            float d10 = d9 * d9;\n            float d11 = d10 * d10;\n            float d12 = d11 * d11;\n            float d13 = d12 * d12;\n            float d14 = d13 * d13;\n            float d15 = d14 * d14;\n            float d16 = d15 * d15;\n            float d17 = d16 * d16;\n            float d18 = d17 * d17;\n            float d19 = d18 * d18;\n            float d20 = d19 * d19;\n            float d21 = d20 * d20;\n            float d22 = d21 * d21;\n            float d23 = d22 * d22;\n            float d24 = d23 * d23;\n            float d25 = d24 * d24;\n            float d26 = d25 * d25;\n            float d27 = d26 * d26;\n            float d28 = d27 * d27;\n            float d29 = d28 * d28;\n            float d30 = d29 * d29;\n            float d31 = d30 * d30;\n            float d32 = d31 * d31;\n            float d33 = d32 * d32;\n            float d34 = d33 * d33;\n            float d35 = d"}], [{"generated_text": "\n    return vec2(\n        lerp(p1.x,p2.x,t),\n        lerp(p1.y,p2.y,t)\n    );\n}\n\n////////////////////////////// POSICAO PONTOS\nvec"}], [{"generated_text": "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat"}], [{"generated_text": "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nfloat"}], [{"generated_text": "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p0;\n    vec2 c = p0;\n    float d = dot(a, a);\n    float e = dot(b, b);\n    float f = dot(a, b);\n    float D = d * e - f * f;\n    if(D == 0.0) return c;\n    float sc = (dot(a, a) - dot(b, b) + D) / 2.0;\n    float tc = (dot(b, b) - dot(a, a) + D) / 2.0;\n    return c + a * sc + b * tc;\n}\n\n// Triangle's circumcenter: The center of the circumcircle, which in essence is the smallest\n// circle that you can fit into a triangle.\nvec"}], [{"generated_text": "\n    float a = dist(p0, p1);\n    float b = dist(p1, p2);\n    float c = dist(p2, p0);\n    float s = (a + b + c) / 2.0;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// The area of the triangle:\nfloat"}], [{"generated_text": "\n    vec2 v1 = h1 - h2;\n    vec2 v2 = h3 - h2;\n    vec2 v3 = h1 - h3;\n    vec2 v4 = h2 - h3;\n    vec2 v5 = h1 - h1;\n    vec2 v6 = h2 - h2;\n    vec2 v7 = h3 - h3;\n    vec2 v8 = h1 - h1;\n    vec2 v9 = h2 - h2;\n    vec2 v10 = h3 - h3;\n    vec2 v11 = h1 - h1;\n    vec2 v12 = h2 - h2;\n    vec2 v13 = h3 - h3;\n    vec2 v14 = h1 - h1;\n    vec2 v15 = h2 - h2;\n    vec2 v16 = h3 - h3;\n    vec2 v17 = h1 - h1;\n    vec2 v18 = h2 - h2;\n    vec2 v19 = h3 - h3;\n    vec2 v20 = h1 - h1;\n    vec2 v21 = h2 - h2;\n    vec2 v22 = h3 - h3;\n    vec2 v23 = h1 - h1;\n    vec2 v24 = h2 - h2;\n    vec2 v25 = h3 - h3;\n    vec2 v26 = h1 - h1;\n    vec2 v27 = h2 - h2;\n    vec2 v28 = h3 - h3;\n    vec2 v29 = h1 - h1;\n    vec2 v30 = h2 - h2;\n    vec2 v31 = h3 - h3;\n    vec2 v32 = h1 - h1;\n    vec2 v33 = h2 - h2;\n    vec2 v34 = h3 - h3;\n    vec2 v35 = h1"}], [{"generated_text": "\n    triObj t;\n    t.p = p;\n    t.c = vec3(0.0);\n    t.n = vec3(0.0);\n    t.t = vec3(0.0);\n    t.i = vec3(0.0);\n    t.j = vec3(0.0);\n    t.k = vec3(0.0);\n    t.l = vec3(0.0);\n    t.m = vec3(0.0);\n    t.n = vec3(0.0);\n    t.o = vec3(0.0);\n    t.q = vec3(0.0);\n    t.r = vec3(0.0);\n    t.s = vec3(0.0);\n    t.t = vec3(0.0);\n    t.u = vec3(0.0);\n    t.v = vec3(0.0);\n    t.w = vec3(0.0);\n    t.x = vec3(0.0);\n    t.y = vec3(0.0);\n    t.z = vec3(0.0);\n    t.a = vec3(0.0);\n    t.b = vec3(0.0);\n    t.c = vec3(0.0);\n    t.d = vec3(0.0);\n    t.e = vec3(0.0);\n    t.f = vec3(0.0);\n    t.g = vec3(0.0);\n    t.h = vec3(0.0);\n    t.i = vec3(0.0);\n    t.j = vec3(0.0);\n    t.k = vec3(0.0);\n    t.l = vec3(0.0);\n    t.m = vec3(0.0);\n    t.n = vec3(0.0);\n    t.o = vec3(0.0);\n    t.p = vec"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.01) / 0.08;\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n   "}], [{"generated_text": "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec"}], [{"generated_text": "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return false;\n    else\n    {\n        float temp = sqrt( discriminant );\n        float q = ( b > 0.0 )? ( -0.5 * ( b + temp ) ) : ( -0.5 * ( b - temp ) );\n        t = q / a;\n        if ( t < tmin || tmax < t )\n            return false;\n        else\n        {\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction"}], [{"generated_text": "\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.origin - sph.center ) - sph.radius * sph.radius;\n\n    // Compute the discriminant.\n    float discriminant = b * b - c;\n\n    // If the discriminant is negative, there is no intersection.\n    if ( discriminant < 0.0f )\n    {\n        return false;\n    }\n\n    // Compute the square root of the discriminant.\n    float sqrt_discriminant = sqrt( discriminant );\n\n    // Compute the nearest root that lies in the acceptable range.\n    float root = (-b - sqrt_discriminant) / 2.0f;\n    if ( root < tmin )\n    {\n        root = (-b + sqrt_discriminant) / 2.0f;\n        if ( root < tmin )\n        {\n            return false;\n        }\n    }\n\n    // If the nearest root is beyond tmax, there is no intersection.\n    if ( root > tmax )\n    {\n        return false;\n    }\n\n    // Return true if the nearest root is within tmin and tmax.\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, inout float t )\n{\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray."}], [{"generated_text": "\n    //////////////////////////////////////////////////////////////////////////\n    // Replace with your code:\n    //////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    vec3 hitPos_ = vec3(0.0);\n    vec3 hitNormal_ = vec3(0.0);\n    vec3 k_rg_ = vec3(0.0);\n    hasHit = false;\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here:\n    //////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here:\n    //////////////////////////////////////////////////////////////////////////\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of a point light source at a given point.\n// The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n//\u8ba1\u7b97\u70b9\u5149\u6e90\u7684\u989c\u8272\u3002\n//\u989c\u8272\u662f\u6765\u81ea\u6240\u6709\u5149\u6e90\u7684\u5149\u7684\u603b\u548c\uff0c\u6bcf\u4e2a\u5149\u6e90\u4f7f\u7528Phong\u7167\u660e\u6a21\u578b\u8ba1\u7b97\uff0c\u5e76\u8003\u8651\u662f\u5426\u4ece\u5149\u7ebf\u906e\u853d\u4e86\u622a\u9762\u70b9\u3002\n//\u5982\u679c\u6ca1\u6709interesection\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\uff0c\u5e76\u8f93\u51fahasHit\u4e3afalse\u3002\n//\u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u8ba1\u7b97\u7684\u989c\u8272\uff0c\u5e76\u8f93\u51fahasHit\u4e3atrue\uff0c\u4ea4\u70b9\u76843D\u4f4d\u7f6e\uff08hitPos\uff09\uff0c\n//\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u4ee5\u53ca\u76f8\u4ea4\u5bf9\u8c61\u7684\u6750\u8d28\u7684k_rg\u503c\u3002\n/////////////////////////////////////////////////////////////////////////////\nvec"}], [{"generated_text": "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    vec2 s = (p + q) * 0.5;\n    vec2 t = (q + r) * 0.5;\n    vec2 u = (s + t) * 0.5;\n    vec2 v = (t + r) * 0.5;\n    vec2 w = (u + v) * 0.5;\n    vec2 x = (v + w) * 0.5;\n    vec2 y = (w + u) * 0.5;\n    vec2 z = (u + x) * 0.5;\n    vec2 a = (x + y) * 0.5;\n    vec2 b = (y + z) * 0.5;\n    vec2 c = (z + a) * 0.5;\n    vec2 d = (a + b) * 0.5;\n    vec2 e = (b + c) * 0.5;\n    vec2 f = (c + d) * 0.5;\n    vec2 g = (d + e) * 0.5;\n    vec2 h = (e + f) * 0.5;\n    vec2 i = (f + g) * 0.5;\n    vec2 j = (g + h) * 0.5;\n    vec2 k = (h + i) * 0.5;\n    vec2 l = (i + j) * 0.5;\n    vec2 m = (j + k) * 0.5;\n    vec2 n = (k + l) * 0.5;\n    vec2 o = (l + m) * 0.5;\n    vec2 p1 = (m + n) * 0.5;\n    vec2 q1 = (n + o) * 0.5;\n    vec2 r1 = (o + p) * 0.5;\n    vec2 s1 = (p +"}], [{"generated_text": "\n    vec3 bmin = vec3( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ),\n                      min( min( p0.y, p1.y ), min( p2.y, p3.y ) ),\n                      min( min( p0.z, p1.z ), min( p2.z, p3.z ) ) );\n    vec3 bmax = vec3( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ),\n                      max( max( p0.y, p1.y ), max( p2.y, p3.y ) ),\n                      max( max( p0.z, p1.z ), max( p2.z, p3.z ) ) );\n    return bound3( bmin, bmax );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    float t1 = dot( ap, ab );\n    float t2 = dot( bp, ab );\n    float t3 = dot( ap, ab );\n    float t4 = dot( bp, ab );\n    float tmin = max( max( t1, t2 ), max( t3, t4 ) );\n    float tmax = min( min( t1, t2"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s"}], [{"generated_text": "\n    return 0.5 * ( 1.0 - cos( k * PI ) );\n}\n\n/**\n * Cubic InOut Easing Curve\n */\nfloat"}], [{"generated_text": "\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x"}], [{"generated_text": "\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - 0.5;\n    float t = iTime;\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 0.5;\n    float f = (r - 0.5) * 0.5;\n    float g = (r - 0.5) * 0.5;\n    float h = (r - 0.5) * 0.5;\n    float i = (r - 0.5) * 0.5;\n    float j = (r - 0.5) * 0.5;\n    float k = (r - 0.5) * 0.5;\n    float l = (r - 0.5) * 0.5;\n    float m = (r - 0.5) * 0.5;\n    float n = (r - 0.5) * 0.5;\n    float o = (r - 0.5) * 0.5;\n    float p = (r - 0.5) * 0.5;\n    float q = (r - 0.5) * 0.5;\n    float r = (r - 0.5) * 0.5;\n    float s = (r - 0.5) * 0.5;\n    float t = (r - 0.5) * 0.5;\n    float u = (r - 0.5) * 0.5;\n    float v = (r - 0.5) * 0.5;\n    float w = (r - 0.5) * 0.5;\n    float x = (r - 0.5) * 0.5;\n    float y = (r - 0.5) * 0.5;\n    float z = (r - 0.5) * 0.5;\n    float aa ="}], [{"generated_text": "\n    return (coord * 2.0) / res - 1.0;\n}\n\n// Calculate the value of the julia set at the given coordinate.\nfloat"}], [{"generated_text": "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat"}], [{"generated_text": "\n    vec3 hcv = vec3(0.0);\n    float max = max(rgb.r, max(rgb.g, rgb.b));\n    float min = min(rgb.r, min(rgb.g, rgb.b));\n    float delta = max - min;\n    if (delta == 0.0) {\n        hcv.r = hcv.g = hcv.b = 0.0;\n    } else {\n        if (max == rgb.r) {\n            hcv.r = (rgb.g - rgb.b) / delta;\n        } else if (max == rgb.g) {\n            hcv.r = 2.0 + (rgb.b - rgb.r) / delta;\n        } else {\n            hcv.r = 4.0 + (rgb.r - rgb.g) / delta;\n        }\n        hcv.r *= 60.0;\n        if (hcv.r < 0.0) {\n            hcv.r += 360.0;\n        }\n        hcv.g = delta / max;\n        hcv.b = 0.0;\n    }\n    return hcv;\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec"}], [{"generated_text": "\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with perlin noise\nfloat"}], [{"generated_text": "\n    vec3 e = vec3( 0.0001, 0.0, 0.0 );\n    return normalize( vec3(\n        p.y - surface( p + e.yxx ).y,\n        p.z - surface( p + e.zzx ).z,\n        p.x - surface( p + e.xyx ).x ) );\n}\n\n// Tetrahedral surface, to save a couple of \"map\" calls. Courtesy of IQ.\nfloat"}], [{"generated_text": "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// --------------------------------------------------------\n// Simplex 3D Noise - fractal noise with an interesting\n// property\n// --------------------------------------------------------\n\nfloat"}], [{"generated_text": "\n    float x = pos.x;\n    float y = pos.y;\n    float r = radius;\n    float w = width;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float rr = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float ww = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float x9 = 0.0;\n    float y9 = 0.0;\n    float x10 = 0.0;\n    float y10 = 0.0;\n    float x11 = 0.0;\n    float y11 = 0.0;\n    float x12 = 0.0;\n    float y12 = 0.0;\n    float x13 = 0.0;\n    float y13 = 0.0;\n    float"}], [{"generated_text": "\n    return snoise(v.x, v.y);\n}\n\n//SNOISE\nfloat"}], [{"generated_text": "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n\n    vec3 col = vec3(0.0);\n\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    float intensity = 0.0;\n    float attenuation = 1.0;\n\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n\n    float radius = 0.5;\n    float dist = 0.0;\n\n    for(int i = 0; i < 100; i++){\n        pos = vec3(0.0, 0.0, 0.0);\n        dist = 0.0;\n\n        for(int j = 0; j < 10; j++){\n            pos = vec3(0.0, 0.0, 0.0);\n            dist = 0.0;\n\n            for(int k = 0; k < 10; k++){\n                pos = vec3(0.0, 0.0, 0.0);\n                dist = 0.0;\n\n                pos.x = (float(i) / 10.0) - 0.5;\n                pos.y = (float(j) / 10.0) - 0.5;\n                pos.z = (float(k) / 10.0) - 0.5;\n\n                dist = length(pos);\n\n"}], [{"generated_text": "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*157.0 + 113.0*i.z;\n    return mix(mix(mix(dot(C.xyz, f+vec3(0.0,0.0,0.0)),\n                        dot(C.xyz, f+vec3(1.0,0.0,0.0)),\n                        f.x),\n                   mix(dot(C.xyz, f+vec3(0.0,1.0,0.0)),\n                       dot(C.xyz, f+vec3(1.0,1.0,0.0)),\n                       f.x),\n                   f.y),\n               mix(mix(dot(C.xyz, f+vec3(0.0,0.0,1.0)),\n                       dot(C.xyz, f+vec3(1.0,0.0,1.0)),\n                       f.x),\n                   mix(dot(C.xyz, f+vec3(0.0,1.0,1.0)),\n                       dot(C.xyz, f+vec3(1.0,1.0,1.0)),\n                       f.x),\n                   f.y),\n               f.z);\n}\n\n// Thanks Shane.\nfloat"}], [{"generated_text": "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n"}], [{"generated_text": "\n    vec2 d = vec2(0.0);\n    d.x = length(p.xy) - 0.5;\n    d.y = p.z + 0.5;\n    return d;\n}\n\n//the second scalar represents the object type, the first the actual distance\nvec"}], [{"generated_text": "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Complex functions\nvec"}], [{"generated_text": "\n    float aa = aaSize / 2.0;\n    float aa2 = aa * aa;\n    float aa3 = aa2 * aa;\n    float aa4 = aa3 * aa;\n    float aa5 = aa4 * aa;\n    float aa6 = aa5 * aa;\n    float aa7 = aa6 * aa;\n    float aa8 = aa7 * aa;\n    float aa9 = aa8 * aa;\n    float aa10 = aa9 * aa;\n    float aa11 = aa10 * aa;\n    float aa12 = aa11 * aa;\n    float aa13 = aa12 * aa;\n    float aa14 = aa13 * aa;\n    float aa15 = aa14 * aa;\n    float aa16 = aa15 * aa;\n    float aa17 = aa16 * aa;\n    float aa18 = aa17 * aa;\n    float aa19 = aa18 * aa;\n    float aa20 = aa19 * aa;\n    float aa21 = aa20 * aa;\n    float aa22 = aa21 * aa;\n    float aa23 = aa22 * aa;\n    float aa24 = aa23 * aa;\n    float aa25 = aa24 * aa;\n    float aa26 = aa25 * aa;\n    float aa27 = aa26 * aa;\n    float aa28 = aa27 * aa;\n    float aa29 = aa28 * aa;\n    float aa30 = aa29 * aa;\n    float aa31 = aa30 * aa;\n    float aa32 = aa31 * aa;\n    float aa33 = aa32 * aa;\n    float"}], [{"generated_text": "\n    vec2 d = vec2(0.0);\n    vec3 q = pos - vec3(0.0, 0.0, 0.0);\n    d.x = length(q) - 0.01;\n    d.y = boxID(q);\n    return d;\n}\n\n// returns the distance to our rotating box and the associated material ID\nvec"}], [{"generated_text": "\n    vec2 d = vec2(0.0);\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.0;\n    float sphereDist = distance(pos, spherePos);\n    if (sphereDist < sphereRadius) {\n        d.x = sphereDist - sphereRadius;\n        d.y = sphereRadius;\n    }\n    return d;\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec"}], [{"generated_text": "\n    vec2 res = vec2(1000.0);\n    // add your scene here\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 0.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 1.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 2.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 3.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 4.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 5.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 6.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 7.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 8.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 9.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 10.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 11.0;\n    // res."}], [{"generated_text": "\n    vec4 color = vec4(0.0);\n    vec3 rayDir = normalize(camDir + lightDir);\n    vec3 rayPos = camPos;\n    float t = 0.0;\n    float tMax = 1000.0;\n    for (int i = 0; i < 100; i++) {\n        if (t > tMax) break;\n        t += rayMarch(rayPos, rayDir);\n        if (t > tMax) break;\n        vec3 hitPos = rayPos + rayDir * t;\n        vec3 hitNormal = getNormal(hitPos);\n        vec3 lightColor = vec3(0.0);\n        if (dot(hitNormal, lightDir) > 0.0) {\n            lightColor = vec3(1.0);\n        }\n        color += vec4(lightColor, 1.0);\n    }\n    return color;\n}\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec4 color = marchScene(fragCoord, camPos, camDir, lightDir);\n    gl_FragColor = color;\n}\n"}], [{"generated_text": "\n    vec2 res = vec2(0.);\n    vec3 q = abs(rd) - rad;\n    vec3 m = max(q, vec3(0.0));\n    res.x = min(max(m.x, m.y), m.z);\n    res.y = length(max(m, 0.0));\n    return res;\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + r * r;\n        t = s;\n    }\n\n    vec3 color = vec3(0.0);\n    if (dot(q, q) > 4.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n"}], [{"generated_text": "\n    return dot(plane.normal, pos - plane.position);\n}\n\n// @brief Get signed-distance funciton weight value of sphere.\nfloat"}], [{"generated_text": "\n    vec3 p = fract(fx);\n    p = p*p*(3.0-2.0*p);\n    ix = ix + ivec3(gl_GlobalInvocationID.xyz);\n    float res = 0.0;\n    for(int j=-1; j<=1; j++){\n        for(int k=-1; k<=1; k++){\n            for(int l=-1; l<=1; l++){\n                ivec3 c = ix + ivec3(j,k,l);\n                vec4 v = texelFetch(noise, c, 0);\n                res += v.x*p.x;\n                res += v.y*p.y;\n                res += v.z*p.z;\n                res += v.w*(1.0-p.x)*(1.0-p.y)*(1.0-p.z);\n            }\n        }\n    }\n    return res;\n}\n\n// High Precision 3D Gradient Noise\n// ix: integer coordinate, fx: float offset to the integer coordinate\nfloat"}], [{"generated_text": "\n    float fractal = 0.0;\n    for(int i = 0; i < 10; i++){\n        fractal += fractal_brownian(fxyz, ixyz, i);\n    }\n    return fractal;\n}\n\n// Fractal Brownian Motion \nfloat"}], [{"generated_text": "\n    vec2 d = vec2( length(p.xz) - r, p.y );\n    return length(max(d,0.0)) - h;\n}\n\nfloat"}], [{"generated_text": "\n    //The distance of the point from the center of the sphere\n    float d = length(p) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d2 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d3 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d4 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d5 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d6 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d7 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d8 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d9 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d10 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d11 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n"}], [{"generated_text": "\n    vec3 normal = vec3(0.0);\n    float d = get_distance(p);\n    normal.x = d - get_distance(p + vec3(1.0, 0.0, 0.0));\n    normal.y = d - get_distance(p + vec3(0.0, 1.0, 0.0));\n    normal.z = d - get_distance(p + vec3(0.0, 0.0, 1.0));\n    return normalize(normal);\n}\n\n// Compute the color at a position p on the surface of our objects\nvec"}], [{"generated_text": "\n    return max(dot(n,l),0.0);\n}\n\n// Lighting part, still confusing\nfloat"}], [{"generated_text": "\n    vec3 p = ro + rd*ra;\n    return dot(p,p) - ra*ra;\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat"}], [{"generated_text": "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * dot(q,q);\n    float h = f * (f + f - 16.0 * dot(f,f) + 10.0 * dot(f,f) * dot(f,f));\n    return 0.25 * (h * (h + h + 1.0) + g * (g + g + 1.0) * (g + g + 1.0));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat"}], [{"generated_text": "\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\tglClearDepth(1.0f);\n\tglEnable(GL_DEPTH_TEST);\n\tglDepthFunc(GL_LEQUAL);\n\tglShadeModel(GL_SMOOTH);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Draws the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid DrawScene()\n{\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglLoadIdentity();\n\n\tgluLookAt(0.0f, 0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n\n\tglColor3f(1.0f, 1.0f, 1.0f);\n\tglBegin(GL_QUADS);\n\tglVertex3f(-1.0f, -1.0f, 0.0f);\n\tglVertex3f(1.0f, -1.0f, 0.0f);\n\tglVertex3f(1.0f, 1.0f, 0.0f);\n\tglVertex3f(-1.0f, 1.0f, 0.0f);\n\tglEnd();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Main function.\n/////////////////////////////////////////////////////////////////////////////\nint"}], [{"generated_text": "\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO: Implement this function.\n    ///////////////////////////////////////////////////////////////////////////\n    //\n    // Hint:\n    //\n    //   - You can use the dot product to compute the distance between a\n    //     point and a line.\n    //\n    //   - You can use the cross product to compute the normal vector of a\n    //     plane.\n    //\n    //   - You can use the length of a vector to compute the distance between\n    //     two points.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n   "}], [{"generated_text": "\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.origin - sph.center ) - sph.radius * sph.radius;\n\n    // Compute the discriminant.\n    float discriminant = b * b - c;\n\n    // If the discriminant is negative, there is no intersection.\n    if ( discriminant < 0.0f )\n    {\n        return false;\n    }\n\n    // Compute the square root of the discriminant.\n    float sqrt_discriminant = sqrt( discriminant );\n\n    // Compute the nearest root that lies in the acceptable range.\n    float root = (-b - sqrt_discriminant) / 2.0f;\n    if ( root < tmin )\n    {\n        root = (-b + sqrt_discriminant) / 2.0f;\n        if ( root < tmin )\n        {\n            return false;\n        }\n    }\n\n    // If the nearest root is beyond tmax, there is no intersection.\n    if ( root > tmax )\n    {\n        return false;\n    }\n\n    // Return true if the nearest root is within tmin and tmax.\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, inout float t )\n{\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray."}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here\n    //////////////////////////////////////////////////////////////////////////\n\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here\n    //////////////////////////////////////////////////////////////////////////\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec"}], [{"generated_text": "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat"}], [{"generated_text": "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat"}], [{"generated_text": "\n\tvec3 color = vec3(0.0);\n\tvec3 ray_dir = normalize(dir);\n\tvec3 ray_start = start;\n\tvec3 ray_end = start + ray_dir * max_dist;\n\tvec3 ray_color = vec3(0.0);\n\tvec3 light_color = vec3(0.0);\n\tvec3 light_start = planet_position;\n\tvec3 light_end = planet_position + light_dir * max_dist;\n\tvec3 light_ray_dir = normalize(light_end - light_start);\n\tvec3 light_ray_start = light_start;\n\tvec3 light_ray_end = light_start + light_ray_dir * max_dist;\n\tvec3 light_ray_color = vec3(0.0);\n\tvec3 light_ray_dir_2 = normalize(light_end - light_start);\n\tvec3 light_ray_start_2 = light_start;\n\tvec3 light_ray_end_2 = light_start + light_ray_dir_2 * max_dist;\n\tvec3 light_ray_color_2 = vec3(0.0);\n\tvec3 light_ray_dir_3 = normalize(light_end - light_start);\n\tvec3 light_ray_start_3 = light_start;\n\tvec3 light_ray_end_3 = light_start + light_ray_dir_3 * max_dist;\n\tvec3 light_ray_color_3 = vec3(0.0);\n\tvec3 light_ray_dir_4 = normalize(light_end - light_start);\n\tvec3 light_ray_start_4 = light_start;\n\tvec3 light_ray_end_4 = light_start + light_ray_dir_4 * max_dist;\n\tvec3 light_ray_color_4 = vec3(0.0);\n\tvec3 light_ray_dir_5 = normalize(light_end - light_start);\n\tvec3 light_ray_start_5 = light_start;\n\tvec3 light_ray_end_5 = light_start +"}], [{"generated_text": "\n    vec3 sky_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 view_dir_norm = normalize(sample_pos - light_dir_norm);\n    float cos_theta = dot(light_dir_norm, view_dir_norm);\n    float cos_theta_sq = cos_theta * cos_theta;\n    float cos_theta_sq_inv = 1.0 - cos_theta_sq;\n    float cos_theta_sq_inv_sq = cos_theta_sq_inv * cos_theta_sq_inv;\n    float cos_theta_sq_inv_sq_inv = cos_theta_sq_inv_sq * cos_theta_sq_inv_sq;\n    float cos_theta_sq_inv_sq_inv_inv = cos_theta_sq_inv_sq_inv * cos_theta_sq_inv_sq_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv * cos_theta_sq_inv_sq_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_"}], [{"generated_text": "\n    vec4 color = vec4(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_attenuation = vec3(1.0);\n    vec3 light_ambient = vec3(0.0);\n    vec3 light_diffuse = vec3(0.0);\n    vec3 light_specular = vec3(0.0);\n    vec3 light_spot_dir = vec3(0.0);\n    vec3 light_spot_color = vec3(0.0);\n    vec3 light_spot_attenuation = vec3(0.0);\n    vec3 light_spot_ambient = vec3(0.0);\n    vec3 light_spot_diffuse = vec3(0.0);\n    vec3 light_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n\n    //get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n\n    //get the ray origin\n    vec3 rayOrigin = camPos;\n\n    //get the ray color\n    vec3 rayColor = vec3(0.0, 0.0, 0.0);\n\n    //get the ray length\n    float rayLength = 1.0;\n\n    //get the ray step\n    float rayStep = 0.001;\n\n    //get the ray step\n    float rayStep2 = 0.001;\n\n    //get the ray step\n    float rayStep3 = 0.001;\n\n    //get the ray step\n    float rayStep4 = 0.001;\n\n    //get the ray step\n    float rayStep5 = 0.001;\n\n    //get the ray step\n    float rayStep6 = 0.001;\n\n    //get the ray step\n    float rayStep7 = 0.001;\n\n    //get the ray step\n    float rayStep8 = 0.001;\n\n    //get the ray step\n    float rayStep9 = 0.001;\n\n    //get the ray step\n    float rayStep10 = 0.001;\n\n    //get the ray step\n    float rayStep11 = 0.001;\n\n    //get the ray step\n    float rayStep12 = 0.001;\n\n    //get the ray step\n    float rayStep13 = 0.001;\n\n    //get the ray step\n    float rayStep14 = 0.001;\n\n    //get the ray step\n    float rayStep15 = 0.00"}], [{"generated_text": "\n    vec3 oc = r0 - s0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\n//-----------------------------------------------------------------------\n// raySphereIntersect\n//-----------------------------------------------------------------------\nfloat"}], [{"generated_text": "\n\tvec4 finalColor = vec4(0.0);\n\tvec3 rayDir = normalize(cameraRayDir);\n\tvec3 rayPos = cameraPos;\n\tvec3 rayPosInc = rayDir;\n\tvec3 rayPosInc2 = rayDir;\n\tvec3 rayPosInc3 = rayDir;\n\tvec3 rayPosInc4 = rayDir;\n\tvec3 rayPosInc5 = rayDir;\n\tvec3 rayPosInc6 = rayDir;\n\tvec3 rayPosInc7 = rayDir;\n\tvec3 rayPosInc8 = rayDir;\n\tvec3 rayPosInc9 = rayDir;\n\tvec3 rayPosInc10 = rayDir;\n\tvec3 rayPosInc11 = rayDir;\n\tvec3 rayPosInc12 = rayDir;\n\tvec3 rayPosInc13 = rayDir;\n\tvec3 rayPosInc14 = rayDir;\n\tvec3 rayPosInc15 = rayDir;\n\tvec3 rayPosInc16 = rayDir;\n\tvec3 rayPosInc17 = rayDir;\n\tvec3 rayPosInc18 = rayDir;\n\tvec3 rayPosInc19 = rayDir;\n\tvec3 rayPosInc20 = rayDir;\n\tvec3 rayPosInc21 = rayDir;\n\tvec3 rayPosInc22 = rayDir;\n\tvec3 rayPosInc23 = rayDir;\n\tvec3 rayPosInc24 = rayDir;\n\tvec3 rayPosInc25 = rayDir;\n\tvec3 rayPosInc26 = rayDir;\n\tvec3 rayPosInc27 = rayDir;\n\tvec3 rayPosInc28 = rayDir;\n\tvec3 rayPosInc29 = rayDir;\n\tvec3 rayPosInc30 = rayDir;\n\tvec3 rayPosInc31 = rayDir;\n\tvec3 rayPosInc32 = rayDir;\n\tvec3 rayPosInc33 = rayDir;\n\tvec3 rayPosInc34 = rayDir;\n\tvec3 ray"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 0.5;\n    float dd = d * d;\n    float ddd = dd * d;\n    float dddd = ddd * d;\n    float ddddd = dddd * d;\n    float dddddd = ddddd * d;\n    float ddddddd = dddddd * d;\n    float dddddddd = ddddddd * d;\n    float ddddddddd = dddddddd * d;\n    float dddddddddd = ddddddddd * d;\n    float ddddddddddd = dddddddddd * d;\n    float dddddddddddd = ddddddddddd * d;\n    float ddddddddddddd = dddddddddddd * d;\n    float dddddddddddddd = ddddddddddddd * d;\n    float ddddddddddddddd = dddddddddddddd * d;\n    float dddddddddddddddd = ddddddddddddddd * d;\n    float ddddddddddddddddd = dddddddddddddddd * d;\n    float dddddddddddddddddd = ddddddddddddddddd * d;\n    float ddddddddddddddddddd = dddddddddddddddddd * d;\n    float dddddddddddddddddddd = ddddddddddddddddddd * d;\n   "}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_position = ray_origin;\n    for (int i = 0; i < MAX_PATHS; i++) {\n        vec3 hit_position = ray_position;\n        vec3 hit_normal = vec3(0.0);\n        vec3 hit_color = vec3(0.0);\n        vec3 hit_reflection = vec3(0.0);\n        vec3 hit_refraction = vec3(0.0);\n        vec3 hit_refraction_color = vec3(0.0);\n        vec3 hit_reflection_color = vec3(0.0);\n        vec3 hit_refraction_normal = vec3(0.0);\n        vec3 hit_reflection_normal = vec3(0.0);\n        vec3 hit_refraction_position = vec3(0.0);\n        vec3 hit_reflection_position = vec3(0.0);\n        vec3 hit_reflection_direction = vec3(0.0);\n        vec3 hit_refraction_direction = vec3(0.0);\n        vec3 hit_refraction_normal_direction = vec3(0.0);\n        vec3 hit_reflection_normal_direction = vec3(0.0);\n        vec3 hit_refraction_normal_position = vec3(0.0);\n        vec3 hit_reflection_normal_position = vec3(0.0);\n        vec3 hit_reflection_direction_position = vec3(0.0);\n        vec3 hit_refraction_direction_position = vec3(0.0);\n        vec3 hit_reflection_direction_normal = vec3(0.0);\n        vec3 hit_refraction_direction_normal = vec3(0.0);\n        vec3 hit_reflection_direction_normal_position = vec3(0.0);\n"}], [{"generated_text": "\n    vec3 c = vec3(0.0);\n    vec2 q = p;\n    float d = 0.0;\n    float t = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b2 = 0.0;\n    float a2 = 0.0;\n    float r2 = 0.0;\n    float g2 = 0.0;\n    float b3 = 0.0;\n    float a3 = 0.0;\n    float r3 = 0.0;\n    float g3 = 0.0;\n    float b4 = 0.0;\n    float a4 = 0.0;\n    float r4 = 0.0;\n    float g4 = 0.0;\n    float b5 = 0.0;\n    float a5 = 0.0;\n    float r5 = 0.0;\n    float g5 = 0.0;\n    float b6 = 0.0;\n    float a6 = 0.0;\n    float r6 = 0.0;\n    float g6 = 0.0;\n    float b7 = 0.0;\n    float a7 = 0.0;\n    float r7 = 0.0;\n    float g7 = 0.0;\n    float b8 = 0.0;\n    float a8 = 0.0;\n    float r8 = 0.0;\n    float g8 = 0.0;\n    float b9 = 0.0;\n    float a9 = 0.0;\n    float r9 = 0.0;\n    float g9 = 0.0;\n    float b10 = 0.0;\n    float a10 = 0.0;\n    float r10 = 0.0;\n    float g10 = 0.0;\n    float b11 = 0.0;\n    float a11 = 0.0;\n    float r11 = 0.0;\n    float g11 = 0.0;\n    float b12 = 0.0;\n    float a12 = 0.0;\n    float r"}], [{"generated_text": "\n    return length(p) - 1.0;\n}\n\n// Get the normal of the sphere\nvec"}], [{"generated_text": "\n    vec3 Pi0 = floor( P );\n    vec3 Pi1 = Pi0 + vec3( 1.0 );\n    vec3 Pf0 = fract( P );\n    vec3 Pf1 = Pf0 - vec3( 1.0 );\n\n    vec4 x0 = vec4( Pf0.x, Pf1.x, Pi0.x, Pi1.x );\n    vec4 x1 = vec4( Pf0.y, Pf1.y, Pi0.y, Pi1.y );\n    vec4 x2 = vec4( Pf0.z, Pf1.z, Pi0.z, Pi1.z );\n\n    vec4 w0 = vec4( dot( x0, vec4( 1.0 ) ), dot( x1, vec4( 1.0 ) ),\n                    dot( x2, vec4( 1.0 ) ), 1.0 );\n\n    return dot( w0, vec4( 1.0 ) );\n}\n\n// from: https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\nfloat"}], [{"generated_text": "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat"}], [{"generated_text": "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.z, p.z);\n    return r;\n}\n\n// Scene setup\nvec"}], [{"generated_text": "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.z, p.z);\n    return r;\n}\n\n// Scene setup\nvec"}], [{"generated_text": "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - d;\n}\n\n// segment with disc ends: seamless distance to segment\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(r);\n    float f2 = fract(r * 0.5);\n    float f3 = fract(r * 0.25);\n    float f4 = fract(r * 0.125);\n    float f5 = fract(r * 0.0625);\n    float f6 = fract(r * 0.03125);\n    float f7 = fract(r * 0.015625);\n    float f8 = fract(r * 0.0078125);\n    float f9 = fract(r * 0.00390625);\n    float f10 = fract(r * 0.001953125);\n    float f11 = fract(r * 0.0009765625);\n    float f12 = fract(r * 0.00048828125);\n    float f13 = fract(r * 0.000244140625);\n    float f14 = fract(r * 0.0001220703125);\n    float f15 = fract(r * 0.00006103515625);\n    float f16 = fract("}], [{"generated_text": "\n    return abs(p.x) + abs(p.y);\n}\n\n// Circular bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat"}], [{"generated_text": "\n    float n = noise(ix, iy);\n    return n;\n}\n\n// yea i basically spammed random stuff\nfloat"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if ( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n        pos = p + vec3( 0.0, 0.0, t );\n    }\n    color = vec3( 0.5 + 0.5 * sin( 10.0 * t ) );\n    return color;\n}\n\n// Return the color of the pixel\nvec"}], [{"generated_text": "\n    return sin(p * 10.0) * 0.5 + 0.5;\n}\n\n// Fifth scene (many elements)\nfloat"}], [{"generated_text": "\n    return vec2(atan(z.y, z.x), length(z));\n}\n\n// coordinate change \nvec"}], [{"generated_text": "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// returns the magnitude of a complex number\nfloat"}], [{"generated_text": "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)), dot(f, vec3(57.0, 113.0, 17.0)), u.y),\n                   mix(dot(f, vec3(113.0, 57.0, 17.0)), dot(f, vec3(17.0, 113.0, 57.0)), u.y), u.z),\n               mix(mix(dot(f, vec3(57.0, 17.0, 113.0)), dot(f, vec3(17.0, 57.0, 113.0)), u.x),\n                   mix(dot(f, vec3(113.0, 17.0, 57.0)), dot(f, vec3(57.0, 113.0, 17.0)), u.x), u.z),\n               u.x);\n}\n\n/* 3d simplex noise */\nfloat"}], [{"generated_text": "\n\tfloat t = time * 0.025;\n\tfloat d = distance( p, vec3( 0.0 ) );\n\tfloat r = ( 1.0 - d ) * 0.0001;\n\tfloat a = cos( t * 0.05 ) * 0.0001;\n\tfloat b = cos( t * 0.02 ) * 0.0001;\n\tfloat c = cos( t * 0.01 ) * 0.0001;\n\tfloat d1 = cos( t * 0.005 ) * 0.0001;\n\tfloat d2 = cos( t * 0.002 ) * 0.0001;\n\tfloat d3 = cos( t * 0.001 ) * 0.0001;\n\tfloat d4 = cos( t * 0.0005 ) * 0.0001;\n\tfloat d5 = cos( t * 0.0002 ) * 0.0001;\n\tfloat d6 = cos( t * 0.0001 ) * 0.0001;\n\tfloat d7 = cos( t * 0.00005 ) * 0.0001;\n\tfloat d8 = cos( t * 0.00002 ) * 0.0001;\n\tfloat d9 = cos( t * 0.00001 ) * 0.0001;\n\tfloat d10 = cos( t * 0.000005 ) * 0.0001;\n\tfloat d11 = cos( t * 0.000002 ) * 0.0001;\n\tfloat d12 = cos( t * 0.000001 ) * 0.0001;\n\tfloat d13 = cos( t * 0.0000005 ) * 0.0001;\n\tfloat d14 = cos( t * 0.0000002"}], [{"generated_text": "\n    float d = sdf( p );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0"}], [{"generated_text": "\n    float s = 0.0;\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec"}], [{"generated_text": "\n    return clamp((d - start) / (end - start), 0.0, 1.0);\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat"}], [{"generated_text": "\n    vec4 hex = vec4(p, 0.0, 1.0);\n    hex.xy = mod(hex.xy, 2.0);\n    hex.zw = floor(hex.xy);\n    return hex;\n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec"}], [{"generated_text": "\n    vec2 q = p - vec2(0.5);\n    vec2 r = vec2(length(q), atan(q.y, q.x));\n    return r;\n}\n\n// The distance field for the truchet.\nvec"}], [{"generated_text": "\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tfloat t = length(q);\n\tfloat a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n\tfloat r = mod(a, 1.0);\n\tfloat g = mod(a, 2.0);\n\tfloat b = mod(a, 3.0);\n\tfragColor = vec4(r, g, b, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tfloat t = length(q);\n\tfloat a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n\tfloat r = mod(a, 1.0);\n\tfloat g = mod(a, 2.0);\n\tfloat b = mod(a, 3.0);\n\tfragColor = vec4(r, g, b, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord."}], [{"generated_text": "\n    float theta = atan(pc.y, pc.x);\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n    float r35 = r34*r;\n    float r36 = r35*r;\n    float r37 = r36*r;\n    float r38 = r37*r;\n    float r39 = r"}], [{"generated_text": "\n    return smoothstep(pct, pct+0.01, st.y);\n}\n\n// Plot a line on X using a value between 0.0-1.0\nfloat"}], [{"generated_text": "\n    vec3 domain;\n    float angle = 2.0 * PI / float(N);\n    float radius = R * sqrt(1.0 - cos(angle));\n    domain.x = radius * cos(angle);\n    domain.y = radius * sin(angle);\n    domain.z = 0.0;\n    return domain;\n}\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec"}], [{"generated_text": "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.x - circ.x, p.y - circ.y);\n    return vec2(\n        circ.x + r.x * circ.w + r.y * circ.z,\n        circ.y + r.x * circ.z - r.y * circ.w\n    );\n}\n\n// Returns the distance from a point to a circle.\nfloat"}], [{"generated_text": "\n    return vec2(p.x, 1.0 - p.y);\n}\n\n// Mouse pointer inversion.\nvec"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 shadow = vec3(0.0);\n    vec3 fog = vec3(0.0);\n    vec3 fogColor = vec3(0.0);\n    vec3 fogStart = vec3(0.0);\n    vec3 fogEnd = vec3(0.0);\n    vec3 fogDensity = vec3(0.0);\n    vec3 fogColor2 = vec3(0.0);\n    vec3 fogDensity2 = vec3(0.0);\n    vec3 fogColor3 = vec3(0.0);\n    vec3 fogDensity3 = vec3(0.0);\n    vec3 fogColor4 = vec3(0.0);\n    vec3 fogDensity4 = vec3(0.0);\n    vec3 fogColor5 = vec3(0.0);\n    vec3 fogDensity5 = vec3(0.0);\n    vec3 fogColor6 = vec3(0.0);\n    vec3 fogDensity6 = vec3(0.0);\n    vec3 fogColor7 = vec3(0.0);\n    vec3 fogDensity7 = vec3(0.0);\n    vec3 fogColor8 = vec3(0.0);\n    vec3 fogDensity8 = vec3(0.0);\n    vec3 fogColor9 = vec3(0.0);\n    vec3 fogDensity9 = vec3(0."}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    if (d < 1.0) {\n        float t = (1.0 - d) * 10.0;\n        col = vec3(1.0 - t, t, 0.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": " // Input (r, g, b, a) pixel color \n\n    // Get the coordinates of the pixel in the polar coordinate system.\n    vec2 polarCoord = polarCoord(fragCoord);\n\n    // Get the colour of the pixel in the polar coordinate system.\n    vec3 polarColour = polarColour(polarCoord);\n\n    // Get the colour of the pixel in the HSB colour space.\n    vec3 hsbColour = hsbColour(polarColour);\n\n    // Get the colour of the pixel in the RGB colour space.\n    vec3 rgbColour = rgbColour(hsbColour);\n\n    // Output the colour of the pixel.\n    fragColor = vec4(rgbColour, 1.0);\n}\n\n// Polar coordinate system.\n// https://thebookofshaders.com/06/\nvec"}], [{"generated_text": "\n    return normalize(vec3(\n        hash * 2.0 - 1.0,\n        hash * 4.0 - 2.0,\n        hash * 8.0 - 4.0\n    ));\n}\n\n// Hash function\nfloat"}], [{"generated_text": "\n    vec2 XY = bccNoise_Plane(X);\n    return vec2(XY.x, XY.y + X.z);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec"}], [{"generated_text": "\n  float d = length(p.xz) - 1.0;\n  d = max(d, abs(p.y) - 0.9);\n  return d;\n}\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat"}], [{"generated_text": "\n    vec3 rayDir = ray.direction;\n    vec3 rayOrigin = ray.origin;\n    vec3 rayPos = rayOrigin + rayDir * ray.t;\n    vec3 rayDirNorm = normalize( rayDir );\n    vec3 rayPosNorm = normalize( rayPos );\n    vec3 rayPosToTarget = targetPos - rayPos;\n    float rayPosToTargetDot = dot( rayPosToTarget, rayDirNorm );\n    float rayPosToTargetDotSq = rayPosToTargetDot * rayPosToTargetDot;\n    float rayPosToTargetDotCos = dot( rayPosToTarget, rayPosNorm );\n    float rayPosToTargetDotSqCos = rayPosToTargetDotCos * rayPosToTargetDotCos;\n    float rayPosToTargetDotSqCosSq = rayPosToTargetDotSqCos * rayPosToTargetDotSqCos;\n    float rayPosToTargetDotSqCosSqSq = rayPosToTargetDotSqCosSq * rayPosToTargetDotSqCosSq;\n    float rayPosToTargetDotSqCosSqSqSq = rayPosToTargetDotSqCosSqSq * rayPosToTargetDotSqCosSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSq = rayPosToTargetDotSqCosSqSqSq * rayPosToTargetDotSqCosSqSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSqSq = rayPosToTargetDotSqCosSqSqSqSq * rayPosToTargetDotSqCosSqSqSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSqSqSq = rayPosToTargetDotSqCosSqSqSqSqSq * rayPosToTargetDotSqCosSqSqSqSqSq;\n    float ray"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for(int i = 0; i < 10; i++){\n        vec2 q = p;\n        float a = 0.0;\n        for(int j = 0; j < 10; j++){\n            a += length(q);\n            q = q / 2.0 + vec2(0.5);\n        }\n        d = min(d, a);\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}"}], [{"generated_text": "\n    vec4 pos = vec4(p, 1.0);\n    vec4 res = vec4(0.0);\n    res.xyz = p;\n    res.w = 1.0;\n    return res;\n}\n\n//---Essential Geometry Function\nvec"}], [{"generated_text": "\n\n    float t = ray.t;\n    float t0 = t;\n    float t1 = t + lightDiameter;\n\n    float t2 = t - lightDiameter;\n    float t3 = t + lightDiameter;\n\n    float t4 = t - lightDiameter;\n    float t5 = t + lightDiameter;\n\n    float t6 = t - lightDiameter;\n    float t7 = t + lightDiameter;\n\n    float t8 = t - lightDiameter;\n    float t9 = t + lightDiameter;\n\n    float t10 = t - lightDiameter;\n    float t11 = t + lightDiameter;\n\n    float t12 = t - lightDiameter;\n    float t13 = t + lightDiameter;\n\n    float t14 = t - lightDiameter;\n    float t15 = t + lightDiameter;\n\n    float t16 = t - lightDiameter;\n    float t17 = t + lightDiameter;\n\n    float t18 = t - lightDiameter;\n    float t19 = t + lightDiameter;\n\n    float t20 = t - lightDiameter;\n    float t21 = t + lightDiameter;\n\n    float t22 = t - lightDiameter;\n    float t23 = t + lightDiameter;\n\n    float t24 = t - lightDiameter;\n    float t25 = t + lightDiameter;\n\n    float t26 = t - lightDiameter;\n    float t27 = t + lightDiameter;\n\n    float t28 = t - lightDiameter;\n    float t29 = t + lightDiameter;\n\n    float t30 = t - lightDiameter;\n    float t31 = t + lightDiameter;\n\n    float t32 = t - lightDiameter;\n    float t33 = t + lightDiameter;\n\n    float t34 = t - lightDiameter;\n    float t35 = t + lightDiameter;\n\n    float t36 = t - lightDiameter;\n    float t37 = t + lightDiameter;\n\n    float"}], [{"generated_text": "\n    return vec2(length(p.xy), p.z);\n}\n\n// \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193"}], [{"generated_text": "\n    return fract(sin(x)*1e4);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat"}], [{"generated_text": "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0.0f && v >= 0.0f && u + v < 1.0f);\n}\n\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nvec"}], [{"generated_text": "\n    int closest_hex = -1;\n    float closest_dist = INFINITY;\n    for(int i = 0; i < hex_count; i++){\n        float dist = distance(uv, hex_pos[i]);\n        if(dist < closest_dist){\n            closest_dist = dist;\n            closest_hex = i;\n        }\n    }\n    return closest_hex;\n}\n\n//Find the closest hexagon a point would be near\nint"}], [{"generated_text": "\n    //Check if uv is on an edge of the hexagon\n    if(abs(uv.x) + abs(uv.y) <= circumradius){\n        return ON_TRIANGLE;\n    }\n    //Check if uv is inside the nth triangle\n    if(abs(uv.x) + abs(uv.y) <= circumradius * sqrt(3) / 2){\n        return IN_TRIANGLE;\n    }\n    //Check if uv is on the nth triangle\n    if(abs(uv.x) + abs(uv.y) <= circumradius * sqrt(3) / 2 * (1 + sqrt(3))){\n        return ON_TRIANGLE;\n    }\n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint"}], [{"generated_text": "\n    //Check if uv is on an edge of the hexagon.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return ON_TRIANGLE;\n    }\n    //Check if uv is inside the isosceles triangle.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return IN_TRIANGLE;\n    }\n    //Check if uv is outside the isosceles triangle.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return OUT_TRIANGLE;\n    }\n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an isosceles triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint"}], [{"generated_text": "\n    float p = exp(-d);\n    float sum = p;\n    float r = U.x;\n    for (int i = 1; i < d; i++) {\n        r *= U.y;\n        sum += p / float(i);\n        if (r < sum)\n            return i - 1;\n        p *= (d - i) / float(i);\n    }\n    return d - 1;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat"}], [{"generated_text": "\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n ="}], [{"generated_text": "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.0) / (1.0 - 0.0);\n    float t = mod(a, 2.0 * PI);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = (x * x + y * y) * 4.0;\n    float g = (x * x - y * y) * 4.0;\n    float h = (x * x + y * y) * 4.0;\n    float i = (x * x - y * y) * 4.0;\n\n    float j = (f + g + h + i) / 4.0;\n\n    col = vec3(j);\n\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.02) / 0.01;\n    float c = cos(a);\n    float s = sin(a);\n    float t = (r + 1.0) * 0.5;\n    float n = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float m = smoothstep(0.0, 1.0, t);\n    float k = smoothstep(0.0, 1.0, t - 1.0);\n    float b = (n + m) * 0.5;\n    float g = (k + m) * 0.5;\n    float y = (b + g) * 0.5;\n    float rr = (r + 1.0) * 0.5;\n    float gg = (g + 1.0) * 0.5;\n    float bb = (b + 1.0) * 0.5;\n    float rr2 = rr * rr;\n    float gg2 = gg * gg;\n    float bb2 = bb * bb;\n    float rr3 = rr2 * rr;\n    float gg3 = gg2 * gg;\n    float bb3 = bb2 * bb;\n    float rr4 = rr3 * rr;\n    float gg4 = gg3 * gg;\n    float bb4 = bb3 * bb;\n    float rr5 = rr4 * rr;\n    float gg5 = gg4 * gg;\n    float bb5 = bb4 * bb;\n    float rr6 = rr5 * rr;\n    float gg6 = gg5 * gg;\n"}], [{"generated_text": "\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy),\n        calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy),\n        calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx)\n    ));\n}\n\n// Compute height at pos\nfloat"}], [{"generated_text": "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 f = map(p);\n        vec3 dp = vec3(rd.x, rd.y, rd.z);\n        vec3 dpd = vec3(0.0);\n        for (int j = 0; j < 10; j++) {\n            dp = normalize(dp);\n            dpd = (f - p) / dp;\n            p += dp * d;\n            f = map(p);\n            if (length(f - p) < 0.001) {\n                break;\n            }\n        }\n        t += d;\n        d += length(dpd);\n        if (d > 100.0) {\n            break;\n        }\n    }\n    if (t < 100.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy),\n        calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy),\n        calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx)\n    ));\n}\n\n// Compute height at pos\nfloat"}], [{"generated_text": "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 f = map(p);\n        vec3 dp = vec3(rd.x, rd.y, rd.z);\n        vec3 dpd = vec3(0.0);\n        for (int j = 0; j < 10; j++) {\n            dp = normalize(dp);\n            dpd = (f - p) / dp;\n            p += dp * d;\n            f = map(p);\n            if (length(f - p) < 0.001) {\n                break;\n            }\n        }\n        t += d;\n        d += length(dpd);\n        if (d > 100.0) {\n            break;\n        }\n    }\n    if (t < 100.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec2 e = vec2(1.0, -1.0) * DELTA;\n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n    ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec"}], [{"generated_text": "\n    ivec2 p = ivec2(q.x,q.y);\n    p = (p<<13) ^ p;\n    return (float((p.x*p.x+p.y*p.y)*(p.x*p.x+p.y*p.y+p.x*p.x))*(p.y*p.y+p.x*p.x) + p.x) + p.y;\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\nfloat"}], [{"generated_text": "\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light, out float specular ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    specular = material_speculars[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light, out float specular, out float emissive ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    specular = material_speculars[i];\n    emissive = material_emissives[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec"}], [{"generated_text": "\n    vec2 q = p - ab;\n    float k = dot(q, q) / dot(ab, ab);\n    return vec3(k - 0.5, 2.0 * k * (1.0 - k), 1.0 - k);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec"}], [{"generated_text": "\n    vec3 p3 = fract(vec3(p) * vec3(1.0, 1.0 / 3.0, 1.0 / 5.0));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 c = vec2(0.5);\n    float r = 0.0;\n    float a = 1.0;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tau = 1.0;\n    float tau2 = 1.0;\n    float tau3 = 1.0;\n    float tau4 = 1.0;\n    float tau5 = 1.0;\n    float tau6 = 1.0;\n    float tau7 = 1.0;\n    float tau8 = 1.0;\n    float tau9 = 1.0;\n    float tau10 = 1.0;\n    float tau11 = 1.0;\n    float tau12 = 1.0;\n    float tau13 = 1.0;\n    float tau14 = 1.0;\n    float tau15 = 1.0;\n    float tau16 = 1.0;\n    float tau17 = 1.0;\n    float tau18 = 1.0;\n    float tau19 = 1.0;\n    float tau20 = 1.0;\n    float tau21 = 1.0;\n    float tau22 = 1.0;\n    float tau23 = 1.0;\n    float tau24 = 1.0;\n    float tau25 = 1.0;\n    float tau26 = 1.0;\n    float tau27 = 1.0;\n    float tau28 = 1.0;\n    float tau29 = 1.0;\n    float tau30 = 1.0;\n    float tau31 = 1.0;\n    float tau32 = 1.0;\n    float tau"}], [{"generated_text": "\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p17 ="}], [{"generated_text": "\n    return mat3(\n        vec3(cos(rotation.x)*cos(rotation.y), cos(rotation.x)*sin(rotation.y), sin(rotation.x)),\n        vec3(-sin(rotation.y), cos(rotation.y), 0),\n        vec3(sin(rotation.x)*cos(rotation.y), -sin(rotation.x)*sin(rotation.y), cos(rotation.x))\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat"}], [{"generated_text": "\n    vec3 raypos = rayori.xyz;\n    vec3 raydir_ = raydir.xyz;\n    vec3 raydir_n = raydir.w;\n    vec3 raydir_n_ = raydir.w;\n    vec3 raydir_n_n = raydir.w;\n    vec3 raydir_n_n_ = raydir.w;\n    vec3 raydir_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_n"}], [{"generated_text": "\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 dir = vec3(0.0);\n    vec3 ray = vec3(0.0);\n    vec3 ray_dir = vec3(0.0);\n    vec3 ray_dir_inv = vec3(0.0);\n    vec3 ray_dir_inv_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir"}], [{"generated_text": "\n    vec3 pos = vec3(0.0);\n    float dist = 0.0;\n    for(int i = 0; i < 100; i++){\n        pos = pos + raydir * dist;\n        dist += 0.01;\n        if(pos.y > 0.0) break;\n    }\n    return pos;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 raydir = normalize(vec3(p, 2.0));\n    vec3 rayori = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0);\n    vec3 pos = raymarch(raydir, rayori);\n    if(pos.y > 0.0) col = vec3(1.0, 0.0, 0.0);\n    gl_FragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for(int i = 0; i < 10; i++){\n        vec2 q = p;\n        float a = 0.0;\n        for(int j = 0; j < 10; j++){\n            a += length(q);\n            q = q / 2.0 + vec2(0.5);\n        }\n        d = min(d, a);\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}"}], [{"generated_text": "\n    // get the distance from the ray to the edge of the texture\n    float dist = texture(textureSampler, coord).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist2 = texture(textureSampler, coord + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist3 = texture(textureSampler, coord + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist4 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(0.0, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist5 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist6 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist7 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(0.0, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist8 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist9 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec3 p = vec3(0.0);\n        p.x = sin(d * 10.0) * 0.5 + 0.5;\n        p.y = cos(d * 10.0) * 0.5 + 0.5;\n        p.z = sin(d * 10.0) * 0.5 + 0.5;\n        d = length(p);\n        light += vec3(0.0, 0.0, 1.0) * exp(-d * 0.001);\n    }\n\n    col = light;\n\n    fragColor = vec4(col, 1.0);\n}\n// -----------------------------------------------\n"}], [{"generated_text": "\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n    e6 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4,"}], [{"generated_text": "\n    vec3 x = max(vec3(0.0), color - vec3(0.004));\n    return (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec"}], [{"generated_text": "\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat"}], [{"generated_text": "\n    vec2 q = uv - p;\n    float d = length(q);\n    return vec3(d, d, d);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec"}], [{"generated_text": "\n\tfloat t = falloff * rnd.x;\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = s * s;\n\tfloat b = c * c;\n\tfloat c2 = a * b;\n\tfloat d = a * c2;\n\tfloat e = b * c2;\n\tfloat f = c2 * c2;\n\tfloat g = d * d;\n\tfloat h = e * e;\n\tfloat i = f * f;\n\tfloat j = g * g;\n\tfloat k = h * h;\n\tfloat l = i * i;\n\tfloat m = j * j;\n\tfloat n = k * k;\n\tfloat o = l * l;\n\tfloat p = m * m;\n\tfloat q = n * n;\n\tfloat r = o * o;\n\tfloat s2 = p * p;\n\tfloat t2 = q * q;\n\tfloat u2 = r * r;\n\tfloat v2 = s2 * s2;\n\tfloat w2 = t2 * t2;\n\tfloat x2 = u2 * u2;\n\tfloat y2 = v2 * v2;\n\tfloat z2 = w2 * w2;\n\tfloat a2 = x2 * x2;\n\tfloat b2 = y2 * y2;\n\tfloat c2 = z2 * z2;\n\tfloat d2 = a2 * a2;\n\tfloat e2 = b2 * b2;\n\tfloat f2 = c2 * c2;\n\tfloat g2 = d2 * d2;\n\tfloat h2 = e2 * e2;\n\tfloat i2 = f2 * f2;\n\tfloat j2 = g2 * g2;\n\tfloat k2 = h2 * h2;\n\tfloat l2 = i2 * i2;\n\tfloat m2 = j2 * j2;\n\tfloat n2 = k2 * k2;\n\tfloat o2 = l2 * l2;\n\tfloat p2 = m2 * m2;\n\tfloat q2 = n2 * n2;\n\tfloat r2 = o2 * o2;\n\tfloat s2 = p2"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.01;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + p;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(r, r) > 4.0) break;\n        t = r;\n        r = r * r + p;\n    }\n\n    vec3 col = vec3(0.0);\n    if (dot(s, s) > 4.0) col = vec3(1.0, 0.0, 0.0);\n    if (dot(t, t) > 4.0) col = vec3(0.0, 1.0, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 p3 = fract(vec3(p) * vec3(1.0, 1.0 / 3.0, 1.0 / 5.0));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec"}], [{"generated_text": "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat"}], [{"generated_text": "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    return mix(col, vec3(c), r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    vec3 col = vec3(c);\n    col = postProcess(col, q);\n    fragColor = vec4(col, 1.0);\n}\n"}], [{"generated_text": "\n    vec3 q = abs(p) - vec3(1.0);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n/* \u4e00\u4e2a\u5706\u7684SDF */\nfloat"}], [{"generated_text": "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 mouse_offset = mouse - uv;\n\n    float radius = length(mouse_offset);\n    float brightness = radius / iResolution.x;\n\n    vec3 color = vec3(brightness);\n\n    fragColor = vec4(color, 1.0);\n}\n"}]]}