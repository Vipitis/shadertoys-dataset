{"generations": [" return 0.282095; }\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat", "\n    return (v.x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n    return dot(v,r) < 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n    vec2 q;\n    if( v.x < 0.0 )\n        q.x = ( v.x * r.x - r.y ) / ( v.x - r.z );\n    else\n        q.x = v.x;\n    if( v.y < 0.0 )\n        q.y = ( v.y * r.x - r.y ) / ( v.y - r.z );\n    else\n        q.y = v.y;\n    return q;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2*h;\n}\n\n// https://www.shadertoy.com/view/slj3Dd\nfloat", "\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = dot(rayDir, -sunDir);\n    float sunDot3 = dot(rayDir, vec3(0.0, 1.0, 0.0));\n    float sunDot4 = dot(rayDir, vec3(0.0, -1.0, 0.0));\n    float sunDot5 = dot(rayDir, vec3(0.0, 0.0, 1.0));\n    float sunDot6 = dot(rayDir, vec3(0.0, 0.0, -1.0));\n    float sunDot7 = dot(rayDir, vec3(1.0, 0.0, 0.0));\n    float sunDot8 = dot(rayDir, vec3(-1.0, 0.0, 0.0));\n    float sunDot9 = dot(rayDir, vec3(0.0, 1.0, 1.0));\n    float sunDot10 = dot(rayDir, vec3(0.0, 1.0, -1.0));\n    float sunDot11 = dot(rayDir, vec3(0.0, -1.0, 1.0));\n    float sunDot12 = dot(rayDir, vec3(0.0, -1.0, -1.0));\n    float sunDot13 = dot(rayDir, vec3(1.0, 0.0, 1.0));\n    float sunDot14 = dot(rayDir, vec3(1.0, 0.0, -1.0));\n    float sunDot15 = dot(rayDir, vec3(-1.0, 0.0, 1.0));\n    float sunDot16 = dot(rayDir, vec3(-1.0, 0.0, -1.0));\n    float sunDot17 = dot(rayDir, vec3(1.0, 1.0, 0.0));\n    float sunDot1", "\n    vec4 a = 2.0 * p1;\n    vec4 b = p2 - p0;\n    vec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    vec4 pos = 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n    return pos;\n}\n\n// This is a spline used for the camera path\nvec", "\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += snoise(p.xyz) / iter;\n\t\titer = iter * 2.0;\n\t\tp.x = p.x * 2.0 - p.y * nudge;\n\t\tp.y = p.y * 2.0 - p.z * nudge;\n\t\tp.z = p.z * 2.0 - p.x * nudge;\n\t}\n\treturn n * normalizer;\n}\n\n// 3D simplex noise, for 3D points or vec3's\nfloat", "\n    // find the segment you are in\n    int seg = int(t / 10.0);\n    // find the time within that segment\n    float t2 = t - float(seg) * 10.0;\n\n    // find the 4 points that define the segment\n    vec4 p0 = camPath[seg];\n    vec4 p1 = camPath[seg + 1];\n    vec4 p2 = camPath[seg + 2];\n    vec4 p3 = camPath[seg + 3];\n\n    // find the position of the point\n    vec4 pos = CatmullRom(p0, p1, p2, p3, t2);\n\n    // find the orientation of the point\n    vec4 dir = CatmullRom(p0, p1, p2, p3, t2 + 0.001);\n    vec4 up = vec4(0, 1, 0, 0);\n    vec4 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n\n    // return the position and orientation\n    return pos;\n}\n\nvoid main()\n{\n    // get the time\n    float t = time;\n\n    // get the position and orientation of the camera\n    vec4 pos = CamPos(t);\n\n    // get the position of the vertex\n    vec4 v = vec4(position, 1.0);\n\n    // transform the vertex\n    v = v * view;\n    v = v * proj;\n\n    // output the vertex\n    gl_Position = v;\n}\n", "\n    return Hash1d(u, 0.0f, 1.0f);\n}\n\nfloat", "\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += snoise(p) * iter;\n\t\titer *= 0.5;\n\t\tp = p * 2.0 + vec3(nudge,nudge,nudge);\n\t\tp *= normalizer;\n\t}\n\treturn n;\n}\n\n// This is a 3D version of the 2D value noise function.\n// It is only slightly slower than the 2D version because of the extra division and modulo.\nfloat", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 1.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 2.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 3.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 4.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 5.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 6.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 7.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 8.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 9.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 10.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0", "\n    // Get the ray's direction in spherical coordinates.\n    float theta = acos(rayDir.y);\n    float phi = atan(rayDir.z, rayDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun = acos(sunDir.y);\n    float phiSun = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun2 = acos(sunDir.y);\n    float phiSun2 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun3 = acos(sunDir.y);\n    float phiSun3 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun4 = acos(sunDir.y);\n    float phiSun4 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun5 = acos(sunDir.y);\n    float phiSun5 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun6 = acos(sunDir.y);\n    float phiSun6 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun7 = acos(sunDir.y);\n    float phiSun7 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun8 = acos(sunDir.y);\n    float phiSun8 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun9 = acos(sunDir.y);\n    float phiSun9 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's", "\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat", "\n\tvec3 L = spherePos - pos;\n\tfloat tca = dot(L, dirVecPLZNormalizeMeFirst);\n\tfloat d2 = dot(L, L) - tca * tca;\n\tif (d2 > rad * rad) return -1.0;\n\tfloat thc = sqrt(rad * rad - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\tif (t0 > t1)\n\t{\n\t\tfloat tmp = t0;\n\t\tt0 = t1;\n\t\tt1 = tmp;\n\t}\n\tif (t0 < 0)\n\t{\n\t\tt0 = t1; // if t0 is negative, let's use t1 instead\n\t\tif (t0 < 0) return -1.0; // both t0 and t1 are negative\n\t}\n\treturn t0;\n}\n\nfloat", "\n    // The distance to the object is the distance to the surface of the sphere.\n    // The distance to the surface of the sphere is the distance to the center of the sphere minus the radius of the sphere.\n    // The distance to the center of the sphere is the distance to the origin minus the position of the sphere.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n   ", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve second derivative (acceleration)\nvec", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve third derivative (jerk)\nvec", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return vec2( length( p - c ), t );\n}\n\n// signed squared distance between point and segment\nvec", "\n    vec3 ab = b - a;\n    vec3 oa = a - o;\n    float t = dot( oa, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return vec2( length( c - o ), length( c - o ) * length( c - o ) );\n}\n\n// signed squared distance between ray and segment\nfloat", "\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = dot(rayDir, -sunDir);\n\tfloat sunDot3 = dot(rayDir, vec3(0.0, 1.0, 0.0));\n\tfloat sunDot4 = dot(rayDir, vec3(0.0, -1.0, 0.0));\n\tfloat sunDot5 = dot(rayDir, vec3(0.0, 0.0, 1.0));\n\tfloat sunDot6 = dot(rayDir, vec3(0.0, 0.0, -1.0));\n\tfloat sunDot7 = dot(rayDir, vec3(1.0, 0.0, 0.0));\n\tfloat sunDot8 = dot(rayDir, vec3(-1.0, 0.0, 0.0));\n\tfloat sunDot9 = dot(rayDir, vec3(0.0, 1.0, 1.0));\n\tfloat sunDot10 = dot(rayDir, vec3(0.0, 1.0, -1.0));\n\tfloat sunDot11 = dot(rayDir, vec3(0.0, -1.0, 1.0));\n\tfloat sunDot12 = dot(rayDir, vec3(0.0, -1.0, -1.0));\n\tfloat sunDot13 = dot(rayDir, vec3(1.0, 0.0, 1.0));\n\tfloat sunDot14 = dot(rayDir, vec3(1.0, 0.0, -1.0));\n\tfloat sunDot15 = dot(rayDir, vec3(-1.0, 0.0, 1.0));\n\tfloat sunDot16 = dot(rayDir, vec3(-1.0, 0.0, -1.0));\n\tfloat sunDot17 = dot(rayDir, vec3(1.0, 1.0, 0.0));\n\tfloat sunDot1", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This is the main function that does the raymarching.\n// It basically just does a bunch of raymarching steps, and returns the distance\n// to the closest object.\nfloat", "\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n    vec3 balloonSize = vec3(0.5, 0.5, 0.5);\n    vec3 balloonDirection = vec3(0.0, 1.0, 0.0);\n    float balloonRadius = 0.2;\n    float balloonHeight = 0.5;\n    float balloonAngle = 0.0;\n    float balloonSpeed = 0.01;\n    float balloonRotationSpeed = 0.01;\n    float balloonRotationAngle = 0.0;\n    float balloonRotationAngleSpeed = 0.01;\n    float balloonRotationAngleSpeed2 = 0.01;\n    float balloonRotationAngleSpeed3 = 0.01;\n    float balloonRotationAngleSpeed4 = 0.01;\n    float balloonRotationAngleSpeed5 = 0.01;\n    float balloonRotationAngleSpeed6 = 0.01;\n    float balloonRotationAngleSpeed7 = 0.01;\n    float balloonRotationAngleSpeed8 = 0.01;\n    float balloonRotationAngleSpeed9 = 0.01;\n    float balloonRotationAngleSpeed10 = 0.01;\n    float balloonRotationAngleSpeed11 = 0.01;\n    float balloonRotationAngleSpeed12 = 0.01;\n    float balloonRotationAngleSpeed13 = 0.01;\n    float balloonRotationAngleSpeed14 = 0.01;\n    float balloonRotationAngleSpeed15 = 0.01;\n    float balloonRotationAngleSpeed16 = 0.01;\n    float balloonRotationAngleSpeed17 = 0.01;\n    float balloonRotationAngleSpeed18 = 0.01;\n    float balloonRotationAngleSpeed19 = 0.01;\n    float balloonRotationAngleSpeed20 = 0.01;\n    float balloonRot", "\n    float dist1 = distance( thing1, mousePos );\n    float dist2 = distance( thing2, mousePos );\n    if( dist1 < dist2 ){\n        return thing1;\n    }else{\n        return thing2;\n    }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nvec", "\n\n    // The distance to the closest object\n    float closestDistance = INFINITY;\n\n    // The closest object\n    int closestObject = -1;\n\n    // The distance to the closest object\n    float currentDistance;\n\n    // The current object\n    int currentObject;\n\n    // The current object's position\n    vec3 currentObjectPosition;\n\n    // The current object's size\n    float currentObjectSize;\n\n    // The current object's color\n    vec3 currentObjectColor;\n\n    // The current object's normal\n    vec3 currentObjectNormal;\n\n    // The current object's specular\n    float currentObjectSpecular;\n\n    // The current object's reflectivity\n    float currentObjectReflectivity;\n\n    // The current object's refractivity\n    float currentObjectRefractivity;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex2;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex3;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex4;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex5;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex6;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex7;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex8;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex9;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex10;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex11;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex12;\n\n    // The current object's refractive index\n    float currentObjectRefractiveIndex", "\n\n    // We are going to use the gradient of the SDF to figure out\n    // the normal of the surface.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of", "\n    return vec3(0.0);\n}\n\n// this is the function that does the actual\n// raymarching. it returns the distance to the\n// nearest object.\nfloat", "\n    return vec3(0.5,0.5,0.5) + 0.5*normalOfSurface;\n}\n\n// This is the function that is called when we hit a sphere.\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\nvec", "\n\n    // We will use the rayHitInfo to get the position of the hit\n    // and then we will use that position to get the normal\n    // of the hit\n    vec3 hitPosition = eyePosition + rayDirection * rayHitInfo.x;\n    vec3 normal = getNormal( hitPosition );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color = getColor( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color2 = getColor2( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color3 = getColor3( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color4 = getColor4( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color5 = getColor5( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color6 = getColor6( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color7 = getColor7( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color8 = getColor8( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color9 = getColor9( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color10 = getColor10( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color11 = getColor11( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color12 = getColor12( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color13 = getColor13( normal );\n\n    // We will", "\n    return x / (x * b + (1.0 - b));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates a random number in the range 0..1 including 0 excluding 1\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus knot\n// input t --> torus knot specs where:\n// \tt.x = torus knot thickness\n//\tt.y = torus knot pinches\n//  \n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus knot circumference/core/radius which is flat on the y axis\n// then simply subtract the torus knot thickenss from that \nfloat", "\n    float k = 0.1;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat", "\n    float k = sin(u_time*0.5);\n    return normalize(d1*k+d2*(1.0-k));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat", "\n    float  c = cos(t*p.y);\n    float  s = sin(t*p.y);\n    mat2   m = mat2(c,-s,s,c);\n    vec3   q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec", "\n    return (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n    // ~~~~~~~ sphere\n    // sphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    // ~~~~~~~ plane\n    // plane(p, vec3(0.0, 1.0, 0.0), 0.0);\n    // ~~~~~~~ box\n    // box(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    // ~~~~~~~ torus\n    // torus(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5);\n    // ~~~~~~~ cylinder\n    // cylinder(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5);\n    // ~~~~~~~ cone\n    // cone(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5);\n    // ~~~~~~~ torus knot\n    // torusKnot(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5, 10.0);\n    // ~~~~~~~ torus knot\n    // torusKnot(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5, 10.0);\n    // ~~~~~~~ torus knot\n    // torusKnot(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5, 10.0);\n    // ~~~~~~~ torus knot\n    // torusKnot(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5, 10.0);\n    // ~~~~~~~ torus knot\n    // torusKnot(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5, ", "\n\tfloat tmin = 1000.0;\n\tfloat tmax = 2000.0;\n\t\n\tfloat t = tmin;\n\t\n\tvec2 res = vec2(-1.0);\n\t\n\tfor (int i = 0; i < NUM_OBJECTS; i++)\n\t{\n\t\tfloat d = sceneSDF(ro + rd * t);\n\t\tif (d < EPSILON)\n\t\t{\n\t\t\tres = vec2(t, float(i));\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tif (t > tmax)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n// ~~~~~~~ get normal of the surface at point p\n// input p --> point on surface\n// output normal\n//\nvec", "\n    // raymarching\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < EPSILON)\n        {\n            break;\n        }\n        t += d;\n    }\n\n    // if raymarching didn't hit anything\n    if (d > EPSILON)\n    {\n        return vec3(0.0);\n    }\n\n    // if raymarching hit something\n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n    vec3 c = vec3(0.0);\n\n    // if raymarching hit a sphere\n    if (d < EPSILON)\n    {\n        c = vec3(1.0, 0.0, 0.0);\n    }\n    // if raymarching hit a plane\n    else if (d < EPSILON)\n    {\n        c = vec3(0.0, 1.0, 0.0);\n    }\n    // if raymarching hit a box\n    else if (d < EPSILON)\n    {\n        c = vec3(0.0, 0.0, 1.0);\n    }\n\n    return c;\n}\n\nvoid main()\n{\n    // calculate pixel's ray direction\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // render pixel\n    vec3 c = render(ro, rd);\n\n    // output pixel color\n    fragColor = vec4(c, 1.0);\n}\n", "\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camRight = normalize( cross(camDir, vec3(0.0,1.0,0.0) ) );\n    vec3 camUp = normalize( cross(camDir, camRight) );\n    mat3 camMat = mat3( camRight, camUp, camDir );\n    return camMat;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat", "\n    if(id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if(id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if(id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if(id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if(id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if(id == 7.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvoid main()\n{\n    // get the color from the texture\n    vec4 texColor = texture(tex, texCoord);\n\n    // get the color from the texture\n    vec4 texColor2 = texture(tex2, texCoord);\n\n    // get the color from the texture\n    vec4 texColor3 = texture(tex3, texCoord);\n\n    // get the color from the texture\n    vec4 texColor4 = texture(tex4, texCoord);\n\n    // get the color from the texture\n    vec4 texColor5 = texture(tex5, texCoord);\n\n    // get the color from the texture\n    vec4 texColor6 = texture(tex", "\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus knot\n// input t --> torus knot specs where:\n//  t.x = torus knot thickness\n//  t.y = torus knot pinches\n//  t.z = torus knot radius\n//  t.w = torus knot pinches\n// \n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus knot circumference/core/radius which is flat on the y axis\n// then simply subtract the torus knot thickenss from that \nfloat", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\nfloat", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    vec3 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec", "\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat", "\n    float theta = rand(gl_FragCoord.xy) * 2.0 * PI;\n    float phi = rand(gl_FragCoord.xy + vec2(1.0, 0.0)) * PI;\n    float r = rand(gl_FragCoord.xy + vec2(2.0, 0.0)) * 10.0;\n\n    vec3 lightPos = vec3(r * sin(phi) * cos(theta), r * sin(phi) * sin(theta), r * cos(phi));\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec", "\n    // ~~~~~~~ raymarching\n    // raymarching is basically finding the closest point to the ray\n    // by moving the ray position by a small amount and checking if\n    // the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and", "\n    float tmin = 1000.0;\n    float tmax = 2000.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x < EPSILON )\n        {\n            m = res.y;\n            break;\n        }\n        t += res.x;\n        if( t > tmax )\n            break;\n    }\n\n    if( m == -1.0 )\n        return vec4(t,m,0.0,0.0);\n\n    // calc normal\n    vec3 n = calcNormal( ro+rd*t );\n\n    // calc light\n    float occ = calcAO( ro+rd*t, n );\n    vec3 lig = normalize( vec3(0.0,0.0,1.0) );\n    float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n    float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( n, normalize(vec3(lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.9, lig.y );\n    float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp(dot(n,normalize(lig+rd)),0.0,1.0),16.0);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.30*dif*vec3(1.00,0.80,0.55);\n    lin += 2.00*spe*vec3(1.", "\n    vec3 rd = normalize(lp - sp);\n    float t = 0.001;\n    float res = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = map(sp + rd * t);\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 10.0 * h / t);\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + sp;\n        float dd = map(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// ~~~~~~~ normal\n// get normal from distance field\nvec", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float w = 0.0;\n    float wSum = 0.0;\n    float dSum = 0.0;\n    float dMax = 0.0;\n    float dMin = 1000000.0;\n    float dMinIdx = 0.0;\n    float dMaxIdx = 0.0;\n    float dMinIdx2 = 0.0;\n    float dMaxIdx2 = 0.0;\n    float dMinIdx3 = 0.0;\n    float dMaxIdx3 = 0.0;\n    float dMinIdx4 = 0.0;\n    float dMaxIdx4 = 0.0;\n    float dMinIdx5 = 0.0;\n    float dMaxIdx5 = 0.0;\n    float dMinIdx6 = 0.0;\n    float dMaxIdx6 = 0.0;\n    float dMinIdx7 = 0.0;\n    float dMaxIdx7 = 0.0;\n    float dMinIdx8 = 0.0;\n    float dMaxIdx8 = 0.0;\n    float dMinIdx9 = 0.0;\n    float dMaxIdx9 = 0.0;\n    float dMinIdx10 = 0.0;\n    float dMaxIdx10 = 0.0;\n    float dMinIdx11 = 0.0;\n    float dMaxIdx11 = 0.0;\n    float dMinIdx12 = 0.0;\n    float dMaxIdx12 = 0.0;\n    float dMinIdx13 = 0.0;\n    float dMaxIdx13 = 0.0;\n    float dMinIdx14 = 0.0;\n    float dMaxIdx14 = 0.0;\n    float dMinIdx15 = 0.0;\n    float dMaxIdx15 = 0.0;\n    float dMinIdx16 = 0.0;\n    float dMaxIdx16 = 0.0;\n    float dMin", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do tone mapping\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec", "\n    float fogAmount = exp(-d*fs.x);\n    float fogAmount2 = exp(-d*fs.x*0.5);\n    vec3 fogColor = mix(fc1,fc2,fogAmount2);\n    return mix(c,fogColor,fogAmount);\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec", "\n    return 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates the color of a point light\n// input light --> the light to calculate the color for\n// input p --> the point to calculate the color for\n// input c --> the color of the point\n// input ka --> the ambient color\n// input kd --> the diffuse color\n// input ks --> the specular color\n// input n --> the shininess\n// input v --> the view vector\n// input l --> the light vector\n// input n --> the normal vector\nvec", "\n    vec3 rayDir = vec3(fCoord, -1.0);\n    rayDir = cMatrix * rayDir;\n    return normalize(rayDir);\n}\n\n// ~~~~~~~ calculate the intersection of the ray and the sphere\n// input rayDir --> ray direction\n// input spherePos --> sphere position\n// input sphereRadius --> sphere radius\n// output --> intersection point\nvec", "\n    // get pixel's march count\n    float marchCount = march(fCoord,cPos,cMat);\n    // get pixel's color\n    vec3 color = getColor(fCoord,cPos,cMat);\n    // get pixel's antialiased color\n    vec3 aaColor = getAA(fCoord,cPos,cMat,marchCount);\n    // return antialiased color\n    return aaColor;\n}\n\n// ~~~~~~~ render, based on pixel's itteration/march count\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Iterate through the Mandelbrot set\n    float x = -1.0 + 2.0 * uv.x;\n    float y = -1.0 + 2.0 * uv.y;\n    float x0 = x;\n    float y0 = y;\n    float x1 = x;\n    float y1 = y;\n    float x2 = x;\n    float y2 = y;\n    float x3 = x;\n    float y3 = y;\n    float x4 = x;\n    float y4 = y;\n    float x5 = x;\n    float y5 = y;\n    float x6 = x;\n    float y6 = y;\n    float x7 = x;\n    float y7 = y;\n    float x8 = x;\n    float y8 = y;\n    float x9 = x;\n    float y9 = y;\n    float x10 = x;\n    float y10 = y;\n    float x11 = x;\n    float y11 = y;\n    float x12 = x;\n    float y12 = y;\n    float x13 = x;\n    float y13 = y;\n    float x14 = x;\n    float y14 = y;\n    float x15 = x;\n    float y15 = y;\n    float x16 = x;\n    float y16 = y;\n    float x17 = x;\n    float y17 = y;\n    float x18 = x;\n    float y18 = y;\n    float x19 = x;\n    float y19 = y;\n    float x20 = x;\n    float y20 = y;\n    float x21 = x;\n    float y21 = y;\n    float x22 = x;\n    float y22 = y;\n    float x23 = x;\n   ", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat", "\n    return length(p) - r;\n}\n\n// simple cone distance field\nfloat", "\n    // The distance to the nearest surface\n    float d = -1.0;\n\n    // The material number\n    int material = 0;\n\n    // The distance to the nearest surface\n    float d1 = Sphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    float d2 = Sphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n\n    // The material number\n    int material1 = 1;\n    int material2 = 2;\n\n    // The distance to the nearest surface\n    float d3 = Box(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n    // The material number\n    int material3 = 3;\n\n    // The distance to the nearest surface\n    float d4 = Box(p, vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5));\n\n    // The material number\n    int material4 = 4;\n\n    // The distance to the nearest surface\n    float d5 = Box(p, vec3(0.0, 0.0, 0.0), vec3(0.25, 0.25, 0.25));\n\n    // The material number\n    int material5 = 5;\n\n    // The distance to the nearest surface\n    float d6 = Box(p, vec3(0.0, 0.0, 0.0), vec3(0.125, 0.125, 0.125));\n\n    // The material number\n    int material6 = 6;\n\n    // The distance to the nearest surface\n    float d7 = Box(p, vec3(0.0, 0.0, 0.0), vec3(0.0625, 0.0625, 0.0625));\n\n    // The material number\n    int material7 = 7;\n\n    // The", "\n    return vec2(c.x*c.x*c.x*c.x - 5.0*c.x*c.x*c.y*c.y + 5.0*c.y*c.y*c.y*c.y, 5.0*c.x*c.x*c.x*c.y - 5.0*c.x*c.y*c.y*c.y);\n}\n\n//Function that returns a complex number to power of 6\nvec", "\n    vec2 pos = coord;\n    float dist = distance(pos, vec2(0.0, 0.0));\n    float angle = atan(pos.y, pos.x);\n    float color = sin(dist * morphConstant.x + angle * morphConstant.y);\n    return vec4(color, color, color, 1.0);\n}\n\n//Returns the color of a biomorph at position coord\nvec", "\n    vec2 uv_res = uv * resolution;\n    vec2 uv_res_int = floor(uv_res);\n    vec2 uv_res_frac = fract(uv_res);\n\n    vec4 color = vec4(0.0);\n    for (int i = -1; i <= 1; i++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            vec2 uv_res_sample = uv_res_int + vec2(i, j);\n            vec2 uv_sample = uv_res_sample / resolution;\n            color += biomorph(uv_sample, constant);\n        }\n    }\n    return color / 9.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;\n    vec4 color = antiAliasedBiomorph(uv, vec2(0.0, 0.0));\n    fragColor = color;\n}\n", "\n    return fract(x);\n}\n\n// Basically a triangle wave\nfloat", "\n    vec2 pa = pA - uv;\n    vec2 ba = pB - pA;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h) - thick.x;\n    float m = smoothstep(thick.y, 0.0, d);\n    float r = length(pa) - thick.x;\n    float a = (1.0 - smoothstep(thick.y, 0.0, r)) * dashOn;\n    return mix(m, a, rounded);\n}\n\n// This is the same as above, but it will return the distance field and the normal at the same time.\n// The normal is the direction of the line at the point.\n// This is useful for lighting, but you can also use it for other things.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float thickness = thick.x * thick.y;\n    float halfThickness = thickness * 0.5;\n    float halfThicknessSq = halfThickness * halfThickness;\n    float halfThicknessSqRounded = halfThicknessSq - rounded * rounded;\n    float halfThicknessSqRounded2 = halfThicknessSqRounded * halfThicknessSqRounded;\n    float halfThicknessSqRounded3 = halfThicknessSqRounded2 * halfThicknessSqRounded;\n    float halfThicknessSqRounded4 = halfThicknessSqRounded3 * halfThicknessSqRounded;\n    float halfThicknessSqRounded5 = halfThicknessSqRounded4 * halfThicknessSqRounded;\n    float halfThicknessSqRounded6 = halfThicknessSqRounded5 * halfThicknessSqRounded;\n    float halfThicknessSqRounded7 = halfThicknessSqRounded6 * halfThicknessSqRounded;\n    float halfThicknessSqRounded8 = halfThicknessSqRounded7 * halfThicknessSqRounded;\n    float halfThicknessSqRounded9 = halfThicknessSqRounded8 * halfThicknessSqRounded;\n    float halfThicknessSqRounded10 = halfThicknessSqRounded9 * halfThicknessSqRounded;\n    float halfThicknessSqRounded11 = halfThicknessSqRounded10 * halfThicknessSqRounded;\n    float halfThicknessSqRounded12 = halfThicknessSqRounded11 * halfThicknessSqRounded;\n    float halfThicknessSqRounded13 = halfThicknessSqRounded12 * halfThicknessSqRounded;\n    float halfThicknessSqRounded14 = halfThicknessSqRounded", "\n    float line = Line(uv, pA, pB, thick.x, rounded);\n    float outline = Line(uv, pA, pB, thick.y, rounded);\n    return outline - line;\n}\n\n// This makes a line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float thickness = thick.x + thick.y;\n    float halfThickness = thickness * 0.5;\n    float halfThicknessSq = halfThickness * halfThickness;\n    float halfThicknessSqRounded = halfThicknessSq - rounded;\n    float halfThicknessSqRoundedSq = halfThicknessSqRounded * halfThicknessSqRounded;\n    float halfThicknessSqRoundedSqSq = halfThicknessSqRoundedSq * halfThicknessSqRoundedSq;\n    float halfThicknessSqRoundedSqSqSq = halfThicknessSqRoundedSqSq * halfThicknessSqRoundedSqSq;\n    float halfThicknessSqRoundedSqSqSqSq = halfThicknessSqRoundedSqSqSq * halfThicknessSqRoundedSqSqSq;\n    float halfThicknessSqRoundedSqSqSqSqSq = halfThicknessSqRoundedSqSqSqSq * halfThicknessSqRoundedSqSqSqSq;\n    float halfThicknessSqRoundedSqSqSqSqSqSq = halfThicknessSqRoundedSqSqSqSqSq * halfThicknessSqRoundedSqSqSqSqSq;\n    float halfThicknessSqRoundedSqSqSqSqSqSqSq = halfThicknessSqRoundedSqSqSqSqSqSq * halfThicknessSqRoundedSqSqSqSqSqSq;\n    float halfThicknessSqRoundedSqSqSqSqSqSqSqSq = halfThicknessSqRoundedSqSqSqSqSqSqSq * halfThicknessSqRoundedSqSqS", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    vec2 p = uv - pA;\n    float d = dot(p, dir);\n    float d2 = d - thick.x;\n    float d3 = d + thick.y;\n    float d4 = len - d;\n    float d5 = len - d2;\n    float d6 = len - d3;\n    float d7 = len + d;\n    float d8 = len + d2;\n    float d9 = len + d3;\n    float d10 = d * d;\n    float d11 = d2 * d2;\n    float d12 = d3 * d3;\n    float d13 = d4 * d4;\n    float d14 = d5 * d5;\n    float d15 = d6 * d6;\n    float d16 = d7 * d7;\n    float d17 = d8 * d8;\n    float d18 = d9 * d9;\n    float d19 = d10 + d11 + d12 + d13 + d14 + d15 + d16 + d17 + d18;\n    float d20 = d19 * d19;\n    float d21 = d20 * d20;\n    float d22 = d21 * d21;\n    float d23 = d22 * d22;\n    float d24 = d23 * d23;\n    float d25 = d24 * d24;\n    float d26 = d25 * d25;\n    float d27 = d26 * d26;\n    float d28 = d27 * d27;\n    float d29 = d28 * d28;\n    float d30 = d29 * d29;\n    float d31 = d30 * d30;\n    float d32 = d31 * d31;\n    float d33 = d32 * d32;\n    float", "\n    vec2 pa = pA - uv;\n    vec2 ba = pB - pA;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h);\n    float r = length(ba) * 0.5;\n    float a = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float b = (1.0 - h) * asin(d / r) / PI;\n    float c = (1.0 - h) * d / r;\n    float d1 = (1.0 - h) * (a + b - c);\n    float d2 = (1.0 - h) * (a + b + c);\n    float d3 = (1.0 - h) * (a - b + c);\n    float d4 = (1.0 - h) * (a - b - c);\n    float d5 = (1.0 - h) * (a + b);\n    float d6 = (1.0 - h) * (a - b);\n    float d7 = (1.0 - h) * (b + c);\n    float d8 = (1.0 - h) * (b - c);\n    float d9 = (1.0 - h) * (a + c);\n    float d10 = (1.0 - h) * (a - c);\n    float d11 = (1.0 - h) * (b);\n    float d12 = (1.0 - h) * (a);\n    float d13 = (1.0 - h) * (c);\n    float d14 = (1.0 - h) * (1.0);\n    float d15 = (1.0 - h) * (0.0);\n    float d16 = (1.0 - h) * (1.0 - h);\n    float d17 = (1.0 - h) * (h);\n    float d18 = (1.0 - h) * (1.0 - h * h);", "\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, float alpha) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, float alpha, float time) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, float alpha, float time, float speed) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, float alpha, float time, float speed, float intensity) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, float alpha, float time, float speed, float intensity, float timeScale) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv", "\n    float t = dot( cen - ro, nor );\n    if( t < 0.0 ) return -1.0;\n    float b = dot( rd, nor );\n    if( b > 0.0 ) return -1.0;\n    float d = sqrt( t*t + b*b );\n    if( d > rad ) return -1.0;\n    return t - sqrt( rad*rad - d*d );\n}\n\n// ray-triangle intersection\nfloat", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t = max(max(k.x, k.y), k.z);\n    return vec2(t + min(max(k.x, max(k.y, k.z)), 0.0), t);\n}\n\n// ray-box intersection (simplified)\nvec", "\n    vec3  ba = pb-pa;\n    float l2 = dot(ba,ba);\n    float r2 = ra*ra;\n    float h2 = l2 - r2;\n    if( h2<=0.0 ) return bound3( pa, pb );\n    float h = sqrt(h2);\n    vec3  m = (pa+pb)*0.5;\n    vec3  u = ba*0.5/l2;\n    vec3  v = vec3(u.y,-u.x,0.0);\n    return bound3( m-h*v, m+h*v );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/conebbox/conebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  ba = pb-pa;\n    float l2 = dot(ba,ba);\n    float r2 = ra*ra;\n    float h2 = l2 - r2;\n    if( h2<=0.0 ) return bound3( pa, pb );\n    float h = sqrt(h2);\n    vec3  m = (pa+pb)*0.5;\n    vec3  u = ba*0.5/l2;\n    vec3  v = vec3(u.y,-u.x,0.0);\n    float r = sqrt(r2);\n    return bound3( m-h*v-r*u, m+h*v+r*u );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a torus (http://iquilezles.org/www/articles/torusboundingbox/torusboundingbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 TorusAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  ba = pb-pa;\n    float l2", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*dot(oa,oa) - baoa*baoa - ra*ra;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        vec3  n = (oa + t*rd) / ra;\n        return vec4( t, n );\n    }\n    return vec4(-1.0);\n}\n\n// ray-cone intersection (returns t and normal)\nvec", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t = max(max(k.x, k.y), k.z);\n    return vec2(t + min(max(k.x, max(k.y, k.z)), 0.0), t);\n}\n\n// ray-sphere intersection\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float rdoo = dot(rd,rd);\n    float oooc = dot(oc,oc);\n    float rdba = dot(rd,ba);\n    float rdbo = dot(rd,oc);\n    float rdrd = dot(rd,rd);\n    float babo = dot(ba,oc);\n    float bard2 = bard*bard;\n    float baba2 = baba*baba;\n    float baoc2 = baoc*baoc;\n    float rdoo2 = rdoo*rdoo;\n    float oooc2 = oooc*oooc;\n    float rdba2 = rdba*rdba;\n    float rdbo2 = rdbo*rdbo;\n    float rdrd2 = rdrd*rdrd;\n    float babo2 = babo*babo;\n    float k256 = 256.0*rdoo2*baba2;\n    float k192 = -192.0*rdoo*baba*bard;\n    float k128 = 128.0*rdoo2*baoc2 - k512;\n    float k64 = -64.0*rdoo*baoc*bard + k384;\n    float k32 = k128*baba2 - 256.0*rdoo2*baoc*baoc + k1024;\n    float k16 = -16.0*rdoo*baoc*baba*bard + k768;\n    float k8 = k32*baba2 - 128.0*rdoo2*baoc2 + k1536;\n    float k4 = -4.0*rdoo*baoc*baba*bard + k1536;\n    float k2 = k8*", "\n    vec3 n = normalize( cross( a-pos, b-pos ) );\n    if( dot( n, pos ) > r ) n = -n;\n    return n;\n}\n\n// compute normal\nvec", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec", "\n    float tmin = 1.0;\n    float tmax = 2000.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( t < tmin || t > tmax ) break;\n\n        vec2 res = map( ro+rd*t );\n        m = res.y;\n        t += res.x;\n    }\n\n    if( t>tmax ) m=-1.0;\n\n    return vec4( t, m, 0.0, 0.0 );\n}\n\n// normal\nvec", "\n    float phi = (i + 0.5) * 2.0 * PI / n;\n    float theta = acos(1.0 - 2.0 * i / n);\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\n// inverse spherical fibonacci mapping\n// more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nfloat", "\n    float t = 0.0;\n    float d = 0.0;\n    float h = 0.0;\n    float s = 0.0;\n    float s2 = 0.0;\n    float s3 = 0.0;\n    float s4 = 0.0;\n    float s5 = 0.0;\n    float s6 = 0.0;\n    float s7 = 0.0;\n    float s8 = 0.0;\n    float s9 = 0.0;\n    float s10 = 0.0;\n    float s11 = 0.0;\n    float s12 = 0.0;\n    float s13 = 0.0;\n    float s14 = 0.0;\n    float s15 = 0.0;\n    float s16 = 0.0;\n    float s17 = 0.0;\n    float s18 = 0.0;\n    float s19 = 0.0;\n    float s20 = 0.0;\n    float s21 = 0.0;\n    float s22 = 0.0;\n    float s23 = 0.0;\n    float s24 = 0.0;\n    float s25 = 0.0;\n    float s26 = 0.0;\n    float s27 = 0.0;\n    float s28 = 0.0;\n    float s29 = 0.0;\n    float s30 = 0.0;\n    float s31 = 0.0;\n    float s32 = 0.0;\n    float s33 = 0.0;\n    float s34 = 0.0;\n    float s35 = 0.0;\n    float s36 = 0.0;\n    float s37 = 0.0;\n    float s38 = 0.0;\n    float s39 = 0.0;\n    float s40 = 0.0;\n    float s41 = 0.0;\n    float s42 = 0.0;\n    float s43 = 0.0;\n    float s44 = 0.0;\n    float s45 = 0.0;", "\n    vec3 n = vec3(0.0);\n    n.x = noised(p);\n    n.y = noised(p+vec2(1.0,0.0));\n    n.z = noised(p+vec2(0.0,1.0));\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec", "\n    vec2 d = abs(p) - size + radius;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat", "\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n    uv *= orient;\n    float d = dot(uv, uv);\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float f = fract(a * 10.0);\n    float w = fwidth(f);\n    float m = smoothstep(0.0, w, f);\n    col = vec3(m);\n    return col;\n}\n\n// Pattern 2\nvec", "\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, s, -s, c);\n    uv *= rot;\n    uv *= orient;\n    float d = dot(uv, uv);\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float f = fract(a * 10.0);\n    float w = fwidth(a) * 10.0;\n    float m = smoothstep(0.0, w, f);\n    col = vec3(m);\n    return col;\n}\n\n// Pattern 3\nvec", "\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 grid = abs(fract(p*w - 0.5*w) - 0.5);\n    return 1.0 - smoothstep(0.0, 0.1, min(grid.x, grid.y));\n}\n\n// grid ratio\nfloat", "\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ) );\n}\n\n//--------------------------------------------------------------------------\n// raymarching\n//--------------------------------------------------------------------------\n\n// raymarching\nfloat", "\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//and this is the main function:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //get the ray direction:\n    vec2 uv=(fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    v33 ray=v33(uv,1.);\n    //get the camera position:\n    v33 cam=v33(0.,0.,-1.);\n    //get the ray-transpose matrix:\n    v33 rayT=ray;\n    rayTransp(ray,rayT);\n    //get the camera-transpose matrix:\n    v33 camT=cam;\n    rayTransp(cam,camT);\n    //get the ray-camera matrix:\n    v33 rayCam=rayT*camT;\n    //get the ray-camera matrix transpose:\n    v33 rayCamT=rayCam;\n    rayTransp(rayCam,rayCamT);\n    //get the ray-camera matrix inverse:\n    v33 rayCamInv=rayCamT;\n    rayTransp(rayCamInv,rayCamInv);\n    //get the ray-camera matrix inverse transpose:\n    v33 rayCamInvT=rayCamInv;\n    rayTransp(rayCamInv,rayCamInvT);\n    //get the ray-camera matrix inverse transpose transpose:\n    v33 rayCamInvTT=rayCamInvT;\n    rayTransp(rayCamInvT,rayCamInvTT);\n    //get the ray-camera matrix inverse transpose transpose transpose:\n    v33 rayCamInvTTT=rayCamInvTT;\n    rayTransp(rayCamInvTT,rayCamInvTTT);\n    //get the ray-camera matrix inverse transpose transpose transpose transpose:\n    v33 rayCamInvTTTT=rayCamInvTTT;\n    rayTransp(rayCamInvTTT,rayCamInvTTTT);\n    //get the ray-camera matrix inverse transpose transpose trans", "\n    return (v33){\n       .a = a.a,\n       .b = a.b,\n       .c = a.c,\n       .d = a.d,\n       .e = a.e,\n       .f = a.f,\n       .g = a.g,\n       .h = a.h,\n       .i = a.i,\n       .j = a.j,\n       .k = a.k,\n       .l = a.l,\n       .m = a.m,\n       .n = a.n,\n       .o = a.o,\n       .p = a.p,\n       .q = a.q,\n       .r = a.r,\n       .s = a.s,\n       .t = a.t,\n       .u = a.u,\n       .v = a.v,\n       .w = a.w,\n       .x = a.x,\n       .y = a.y,\n       .z = a.z,\n       .A = a.A,\n       .B = a.B,\n       .C = a.C,\n       .D = a.D,\n       .E = a.E,\n       .F = a.F,\n       .G = a.G,\n       .H = a.H,\n       .I = a.I,\n       .J = a.J,\n       .K = a.K,\n       .L = a.L,\n       .M = a.M,\n       .N = a.N,\n       .O = a.O,\n       .P = a.P,\n       .Q = a.Q,\n       .R = a.R,\n       .S = a.S,\n       .T = a.T,\n       .U = a.U,\n       .V = a.V,\n       .W = a.W,\n       .X = a.X,\n       .Y = a.Y,\n       .Z = a.Z,\n       .a = b.x,\n       .b = b.y,\n       .c = b.z,\n       .d = a.d,", "\n    v33 c;\n    c.x=a.x-b.x;\n    c.y=a.y-b.y;\n    c.z=a.z-b.z;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale(v33 a,float b){\n    v33 c;\n    c.x=a.x*b;\n    c.y=a.y*b;\n    c.z=a.z*b;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale2(v33 a,float b){\n    v33 c;\n    c.x=a.x*b;\n    c.y=a.y*b;\n    c.z=a.z*b;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale3(v33 a,float b){\n    v33 c;\n    c.x=a.x*b;\n    c.y=a.y*b;\n    c.z=a.z*b;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale4(v33 a,float b){\n    v33 c;\n    c.x=a.x*b;\n    c.y=a.y*b;\n    c.z=a.z*b;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale5(v33 a,float b){\n    v33 c;\n    c.x=a.x*b;\n    c.y=a.y*b;\n    c.z=a.z*b;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale6(v33 a,float b){\n    v33 c;\n    c.x=a.x*b;\n    c.y=a.y*b;\n    c.z=a.z*b;\n    return c;\n}\n\n//scale ray by a scalar\nv33 scale7(v33 a", "\n    return vec2(\n        (b.x-a.x)/(b.z-a.z),\n        (b.y-a.y)/(b.z-a.z)\n    );\n}\n\n//v33-differentials for BB\nvec", "\n    return vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotproduct on v33s\nvec", "\n    return v33(a.x*b.x,a.y*b.y,a.z*b.x*b.y);\n}\n\n//dual mult\nv33 mul(vec2 a,v33 b){\n    return v33(a.x*b.x,a.y*b.y,a.x*a.y*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b){\n    return v33(a.x*b.x,a.y*b.y,a.x*a.y*b.z+a.z*b.x+a.x*b.y);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c){\n    return v33(a.x*b.x*c.x,a.y*b.y*c.y,a.x*a.y*c.z+a.z*b.x*c.x+a.x*b.y*c.y);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c,v33 d){\n    return v33(a.x*b.x*c.x*d.x,a.y*b.y*c.y*d.y,a.x*a.y*c.z*d.x+a.z*b.x*c.x*d.y+a.x*b.y*c.y*d.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return v33(a.x*b.x*c.x*d.x*e.x,a.y*b.y*c.y*d.y*e.y,a.x*a.y*c.z*d.x*e.x+a.z*b.x*c.x*d.y*e.y+a", "\n    vec3 q=floor(p);\n    vec3 r=fract(p);\n    float k=mod(q.x+q.y+q.z,2.0);\n    float s=k*(k*r.x+r.y+r.z);\n    return s;\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat", "\n    vec3 q=p+w*.5;\n    vec3 r=p-w*.5;\n    return tri(a,Fb,q)+tri(a,Fb,r);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat", "\n    float t=intersect(r,s);\n    if(t<0.0)return 0.0;\n    v33 p=r.o+r.d*t;\n    float d=length(p-s.xyz);\n    return 1.0-smoothstep(s.w,0.0,d);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat", "\n    float d=length(u-s.xyz);\n    float r=s.w;\n    float a=dot(n,u-s.xyz);\n    float b=r*r-a*a;\n    float c=d*d-b;\n    float e=sqrt(c);\n    float f=a-e;\n    float g=a+e;\n    float h=min(f,g);\n    float i=max(h,0.0);\n    return i/d;\n}\n\n//box occlusion\nfloat", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d0d1 = d0 * d1;\n    vec2 d1d2 = d1 * d2;\n    vec2 d2d0 = d2 * d0;\n\n    vec2 d0d1d2 = d0d1 * d2;\n    vec2 d1d2d0 = d1d2 * d0;\n    vec2 d2d0d1 = d2d0 * d1;\n\n    vec2 d0d1d2d0 = d0d1d2 * d0;\n    vec2 d1d2d0d1 = d1d2d0 * d1;\n    vec2 d2d0d1d2 = d2d0d1 * d2;\n\n    vec2 d0d1d2d0d1 = d0d1d2d0 * d1;\n    vec2 d1d2d0d1d2 = d1d2d0d1 * d2;\n    vec2 d2d0d1d2d0 = d2d0d1d2 * d0;\n\n    vec2 d0d1d2d0d1d2 = d0d1d2d0d1 * d2;\n    vec2 d1d2d0d1d2d0 = d1d2d0d1d2 * d0;\n    vec2 d2d0d1d2d0d1 = d2d0d1d2d0 * d1;\n\n    vec2 d0d1d2d0d1d2d0 = d0d1d2d0d1d2 * d0;\n    vec2 d1d2d0d1d2d0d1 = d1d2d0d1d2d0 * d1;\n    vec2 d2d0d1d2d0d1d2 = d2d0d1d2d0d1", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d01 = p1 - p0;\n    vec2 d12 = p2 - p1;\n    vec2 d20 = p0 - p2;\n\n    vec2 d012 = p1 - p0;\n    vec2 d120 = p0 - p1;\n    vec2 d201 = p1 - p0;\n\n    vec2 d0120 = p0 - p1;\n    vec2 d1201 = p1 - p0;\n    vec2 d2012 = p2 - p0;\n\n    vec2 d01201 = p0 - p1;\n    vec2 d12012 = p1 - p0;\n    vec2 d20120 = p2 - p0;\n\n    vec2 d012012 = p0 - p1;\n    vec2 d120120 = p1 - p0;\n    vec2 d201201 = p2 - p0;\n\n    vec2 d0120120 = p0 - p1;\n    vec2 d1201201 = p1 - p0;\n    vec2 d2012012 = p2 - p0;\n\n    vec2 d01201201 = p0 - p1;\n    vec2 d12012012 = p1 - p0;\n    vec2 d20120120 = p2 - p0;\n\n    vec2 d012012012 = p0 - p1;\n    vec2 d120120120 = p1 - p0;\n    vec2 d201201201 = p2 - p0;\n\n    vec2 d0120120120 =", "\n    vec3 p01 = mix(p0,p1,0.5);\n    vec3 p12 = mix(p1,p2,0.5);\n    vec3 p23 = mix(p2,p3,0.5);\n    vec3 p012 = mix(p01,p12,0.5);\n    vec3 p123 = mix(p12,p23,0.5);\n    vec3 p0123 = mix(p012,p123,0.5);\n    vec3 pmin = min(min(min(p0,p1),p2),p3);\n    vec3 pmax = max(max(max(p0,p1),p2),p3);\n    pmin = min(min(min(pmin,p01),p12),p012);\n    pmax = max(max(max(pmax,p01),p12),p012);\n    pmin = min(min(min(pmin,p123),p23),p0123);\n    pmax = max(max(max(pmax,p123),p23),p0123);\n    return bound3(pmin,pmax);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec4 p )\n{\n    return BezierAABB(p.xyz,p.yzw,p.zwz,p.www);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4 )\n{\n    vec3", "\n    vec2 p01 = p0 + (p1 - p0) * 0.5;\n    vec2 p12 = p1 + (p2 - p1) * 0.5;\n    vec2 p23 = p2 + (p3 - p2) * 0.5;\n\n    vec2 p012 = p01 + (p12 - p01) * 0.5;\n    vec2 p123 = p12 + (p23 - p12) * 0.5;\n\n    vec2 p0123 = p012 + (p123 - p012) * 0.5;\n\n    vec2 min = p0;\n    vec2 max = p0;\n\n    min = min2(min, p1);\n    min = min2(min, p2);\n    min = min2(min, p3);\n    min = min2(min, p01);\n    min = min2(min, p12);\n    min = min2(min, p23);\n    min = min2(min, p012);\n    min = min2(min, p123);\n    min = min2(min, p0123);\n\n    max = max2(max, p1);\n    max = max2(max, p2);\n    max = max2(max, p3);\n    max = max2(max, p01);\n    max = max2(max, p12);\n    max = max2(max, p23);\n    max = max2(max, p012);\n    max = max2(max, p123);\n    max = max2(max, p0123);\n\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec", "\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(a, b, pos.x);\n    vec2 e = mix(b, c, pos.x);\n    return mix(d, e, pos.x);\n}\n\nvec", "\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3 n = cross( v1v0, v2v0 );\n\n    float d = dot( n, rd );\n\n    // Backfacing.\n    if( d < 0.0 )\n        return vec3( -1.0 );\n\n    float invD = 1.0 / d;\n    vec3 uv = vec3( dot( v2v0, rov0 ), dot( v1v0, rov0 ), -dot( n, rov0 ) ) * invD;\n\n    if( uv.x < 0.0 || uv.y < 0.0 || uv.z < 0.0 )\n        return vec3( -1.0 );\n\n    return vec3( dot( n, rov0 ) * invD, uv );\n}\n\n// Raymarching.\nfloat", "\n    vec3 v01 = v1 - v0;\n    vec3 v02 = v2 - v0;\n    vec3 v0p = pos - v0;\n    vec3 nor0 = cross( v01, v02 );\n    float d = dot( nor0, nor );\n    if( d < 0.0 ) return 0.0;\n    float s = dot( cross( v01, v0p ), nor0 ) / d;\n    if( s < 0.0 ) return 0.0;\n    float t = dot( cross( v02, v0p ), nor0 ) / d;\n    if( t < 0.0 ) return 0.0;\n    if( s + t > 1.0 ) return 0.0;\n    return 1.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a*2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    vec3 res = vec3(\n        dot(d,d) - kx*kx,\n        2.0*dot(d,a) - 3.0*kx*ky,\n        3.0*dot(a,a) - kx*ky - ky*ky\n    );\n\n    vec3 s = sign(res);\n    res = abs(res);\n    res = pow(res, vec3(2.0,3.0,4.0));\n\n    float d = min(min(res.x, res.y), res.z);\n    float h = max(0.0, kz+s.z*sqrt(res.z-ky*ky));\n    float r = sqrt(h*h+d);\n\n    float t = r*r/(d+h);\n    float aa = sqrt(t);\n    float bb = h/sqrt(t);\n\n    vec2 q = vec2(aa,bb);\n    vec2 kc = vec2(t-d, sqrt(2.0)*aa*bb);\n    vec2 kd2 = kc*dot(d,kc)/dot(kc,kc);\n    float kd = sqrt(dot(kd2,kd2));\n\n    vec2 pa1 = q - vec2(kx, ky) + kd*s;\n    vec2 pa2 = q + vec2(kx, ky) + kd*s;\n    vec2 pb1 = q - vec2(kx", "\n    float a = (r2-r1)/he;\n    float b = r1;\n    float c = r2-a*he;\n    float q = p.x/he;\n    float k = clamp( -r1/(r2-r1), -1.0, 1.0 );\n    float d = max(q*q*(a*q+b)+c,q*(a*q+b)+c,q*q*(a*q-b)+c);\n    float s = -sign(d)*sqrt(max(0.0,d))/abs(a);\n    float t = max(sign(q)*k-s,sign(q)*k+s);\n    float h = r1-he*t;\n    float r = sqrt(h*h+t*t);\n    return max(r,p.y)*sign(p.y);\n}\n\n//----------------------------------------------------------------------------------------\nfloat", "\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h ) - ra;\n    d = max(d, -length( pb ) + rb);\n    return d;\n}\n\n//----------------------------------------------------------------------------------------\nfloat", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sdf(pos+h.xyy) - sdf(pos-h.xyy),\n                           sdf(pos+h.yxy) - sdf(pos-h.yxy),\n                           sdf(pos+h.yyx) - sdf(pos-h.yyx) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash\nfloat", "\n    vec2 p2 = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p2.x + p2.y*57.0;\n\n    float res = mix(mix( hash(n+p), hash(n+p+1.0),f.x),\n                    mix( hash(n+57.0+p), hash(n+58.0+p),f.x),f.y);\n\n    return res;\n}\n\n// 2D value noise\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < p; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D rotation\nmat", "\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/Xds3Dl\nfloat", "\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k2 = k0*k0 + k1*k1;\n    float k3 = k2*(k2 + r.x*r.x) + r.y*r.y;\n    return sqrt(k2)*sqrt(k3) - k3;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D distance functions\n//----------------------------------------------------------------------------------------\n\n// 2D box\nfloat", "\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - better approximated distance\nfloat", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic torus - improved approximated distance\nfloat", "\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    return (x * (1.0 - a)) / (x * (1.0 - a) + (1.0 - x) * a);\n}\n\n// Schlick approximation of the GGX shadowing-masking function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat", "\n    return (x - floor(x + p)) * (1.0 / p);\n}\n\n// biased triangle\nfloat", "\n    float r = h;\n    float g = h;\n    float b = h;\n\n    if (h < 0.25)\n    {\n        r = 0.0;\n        g = 4.0 * h;\n    }\n    else if (h < 0.5)\n    {\n        r = 0.0;\n        b = 1.0 + 4.0 * (0.25 - h);\n    }\n    else if (h < 0.75)\n    {\n        r = 4.0 * (h - 0.5);\n        b = 0.0;\n    }\n    else\n    {\n        g = 1.0 + 4.0 * (0.75 - h);\n        b = 0.0;\n    }\n\n    return vec3(r, g, b);\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    float t = u_time * 0.5;\n\n    vec3 col = vec3(0.0);\n\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n\n    float h = abs(sin(a * 10.0 - t * 10.0));\n    h = smoothstep(0.0, 1.0, h);\n\n    col = smooth_dlmf(h);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 ba = pb-pa;\n    vec3 oa = ro-pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b-a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        if( y>0.0 && y<baba )\n            return t;\n    }\n    return -1.0;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = clamp(paba / baba, 0.0, 1.0);\n    float dx = paba - x * baba;\n    float dy = length(pa - ba * x) - (x <.5? ra : rb);\n    float e = length(max(vec2(dx, dy), 0.0));\n    float i = (min(max(dx, dy), 0.0) + e);\n    return sqrt(i * i + e * e);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    vec3 ba = b - a;\n    vec3 oa = ro - a;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float aard = dot(a,rd);\n    float aaoa = dot(a,oa);\n    float rr = r*r;\n\n    float c = baba - rr;\n    float h = (baba*rdoa - baoa*bard) / c;\n    float d = (rdoa + h*bard) / baba;\n    float e = (oaoa + h*baoa + d*(aard - oaoa)) / c;\n\n    float x = h*d - e;\n    float y = oaoa + e*bard + x*baoa;\n    float z = e*baba + x*bard;\n    float w = e*baba - x*bard + d*(aard*baba - oaoa*ba);\n\n    float D = max(w,0.0);\n    float E = min(D,z);\n    float u = E / (E + k*E*E +.1);\n    float t = e - u*d;\n\n    return t;\n}\n\n// fakesoft shadow occlusion\nfloat", "\n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    float d = abs(r - rad1);\n    float d2 = abs(r - rad2);\n    float d3 = abs(r - th);\n    float d4 = abs(r - (rad1 + th));\n    float d5 = abs(r - (rad2 + th));\n    float d6 = abs(r - (rad1 + th * 2.0));\n    float d7 = abs(r - (rad2 + th * 2.0));\n    float d8 = abs(r - (rad1 + th * 3.0));\n    float d9 = abs(r - (rad2 + th * 3.0));\n    float d10 = abs(r - (rad1 + th * 4.0));\n    float d11 = abs(r - (rad2 + th * 4.0));\n    float d12 = abs(r - (rad1 + th * 5.0));\n    float d13 = abs(r - (rad2 + th * 5.0));\n    float d14 = abs(r - (rad1 + th * 6.0));\n    float d15 = abs(r - (rad2 + th * 6.0));\n    float d16 = abs(r - (rad1 + th * 7.0));\n    float d17 = abs(r - (rad2 + th * 7.0));\n    float d18 = abs(r - (rad1 + th * 8.0));\n    float d19 = abs(r - (rad2 + th * 8.0));\n    float d20 = abs(r - (rad1 + th * 9.0));\n    float d21 = abs(r - (rad2 + th * 9.0));\n    float d22 = abs(r - (rad1 + th * 10.0));\n    float d23 = abs(r - (rad2 + th * 10.0));\n    float d24 = abs(r - (rad1 + th * 11.0));", "\n    return length(p)-r;\n}\n\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// ", "\n    float r = length(pos);\n    return pos * (4.0*r - 4.0*r*r*r);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^6 + y^6 + z^6 - ra^6\nvec", "\n    p.x = abs(p.x);\n    float k = (sca.y*p.x>sca.x*p.y)? dot(p,sca) : dot(p,scb);\n    k = k*k/sca.x/sca.y;\n    float d = (k>ra*ra && k<rb*rb)? dot(p,vec2(abs(k)<1.0? 1.0 : -1.0)) : length(p)*(k>ra*ra? 1.0 : 0.0) + sqrt(max(0.0,k));\n    return d;\n}\n\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 p_rcp = 1.0/p;\n    vec2 dpdx_rcp = 1.0/(p+dpdx);\n    vec2 dpdy_rcp = 1.0/(p+dpdy);\n    float p_mod2 = mod( mod(p.x,2.0)*0.5+mod(p.y,2.0), 2.0 );\n    float dpdx_mod2 = mod( mod(p.x+dpdx.x,2.0)*0.5+mod(p.y+dpdx.y,2.0), 2.0 );\n    float dpdy_mod2 = mod( mod(p.x+dpdy.x,2.0)*0.5+mod(p.y+dpdy.y,2.0), 2.0 );\n    float p_cross = p_mod2*dpdx_mod2 + (1.0-p_mod2)*(1.0-dpdx_mod2);\n    float dpdx_cross = dpdx_mod2*dpdy_mod2 + (1.0-dpdx_mod2)*(1.0-dpdy_mod2);\n    float dpdy_cross = p_mod2*dpdy_mod2 + (1.0-p_mod2)*(1.0-dpdy_mod2);\n    float p_ddx = p_rcp.x*dpdx_rcp.x*p_cross + p_rcp.y*dpdx_rcp.y*dpdx_cross;\n    float p_ddy = p_rcp.x*dpdy_rcp.x*p_cross + p_rcp.y*dpdy_rcp.y*dpdy_cross;\n    return 0.25*p_ddx + 0.25*p_ddy;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    return floor(x*k)/k;\n}\n\n//\n// Smoothstep function y=f(x)\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat", "\n    vec3 sample_dir = normalize(sample_pos - surface_pos);\n    float sample_dist = length(sample_pos - surface_pos);\n    float sample_angle = dot(sample_dir, surface_normal);\n\n    float sample_attenuation = pow(max(0.0, 1.0 - sample_dist / atmosphere_radius), 2.0);\n    float sample_intensity = max(0.0, dot(sample_dir, light_dir));\n\n    return sample_attenuation * sample_intensity * background_col;\n}\n\n/*\nThis is the main function that renders the scene.\n\nIt takes in the ray direction and the current pixel position, and returns the color of the pixel.\n*/\nvec", "\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    float depth = 0.0;\n    float shadow = 0.0;\n    float shadow_dist = 0.0;\n    float shadow_depth = 0.0;\n    float shadow_shadow = 0.0;\n    float shadow_shadow_dist = 0.0;\n    float shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_", "\n    vec2 uv = (coord - resolution.xy * 0.5) / resolution.x;\n    vec3 camera_vector = normalize(vec3(uv, 1.0));\n    return camera_vector;\n}\n\n/*\nnow we can calculate the scattering function for a given pixel\n*/\nvec", "\n    float d = length(p);\n    float m2 = c.x*c.x - c.y*c.y;\n    float p2 = d*d*m2;\n    float p1 = sqrt(abs(p2));\n    float k0 = atan2(p1, p.z*c.x - p.x*c.y);\n    float k1 = atan2(p.z*c.y + p.x*c.x, p.z*c.x + p.x*c.y);\n    return (k0 + k1) * ra / (2.0 * PI);\n}\n\n// cone angle in radians\nfloat", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (material == 1) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    if (material == 2) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    if (material == 3) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    if (material == 4) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    if (material == 5) {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    if (material == 6) {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    if (material == 7) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (material == 8) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 9) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 10) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 11) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 12) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 13) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 14) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 15) {\n       ", "\n    return materials[material].reflectivity;\n}\n\n// Get the color of a material.\n// The color is a 3-tuple of floats in the range [0.0, 1.0].\nvoid get_material_color(int material, float *r, float *g, float *b) {\n    *r = materials[material].color[0];\n    *g = materials[material].color[1];\n    *b = materials[material].color[2];\n}\n\n// Get the specular exponent of a material.\n// The specular exponent is a float in the range [0.0, 100.0].\nfloat", "\n    return materials[material].refraction;\n}\n\n// Get color of a material.\nvec", "\n    return 1.0;\n}\n\n// Get the color of a material.\n// The color is a 3-component vector of floats in the range [0, 1].\nvec", "\n    vec3 line_ab = line_b - line_a;\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 pvec = cross(line_ab, tri_ab);\n    float det = dot(tri_ac, pvec);\n    if (abs(det) < 0.000001) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float inv_det = 1.0 / det;\n    vec3 tvec = line_a - tri_a;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    vec3 qvec = cross(tvec, tri_ab);\n    float v = dot(line_ab, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float t = dot(tri_ac, qvec) * inv_det;\n    return vec3(1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given a point and a plane, compute the distance from the point to the plane.\n// https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane\nfloat", "\n    vec3 camera_forward = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(camera_forward, vec3(0.0, 1.0, 0.0)));\n    vec3 camera_up = normalize(cross(camera_right, camera_forward));\n\n    return mat3(camera_right, camera_up, camera_forward);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix\nmat", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = INFINITY;\n    result.triangle = NULL;\n\n    for (int i = 0; i < scene.num_triangles; i++) {\n        triangle *t = &scene.triangles[i];\n        float distance;\n        if (intersect_ray_triangle(ray_origin, ray_target, t, &distance)) {\n            if (distance < result.distance) {\n                result.hit = true;\n                result.distance = distance;\n                result.triangle = t;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Check if a ray intersects a triangle.\n// Return true if there is an intersection, false otherwise.\n// If there is an intersection, return the distance to the intersection.\nbool intersect_ray_triangle(vec3 ray_origin, vec3 ray_target, triangle *t, float *distance) {\n    vec3 e1 = vec3_sub(t->v1, t->v0);\n    vec3 e2 = vec3_sub(t->v2, t->v0);\n    vec3 p = vec3_cross(ray_target, e2);\n    float det = vec3_dot(e1, p);\n    if (det > -EPSILON && det < EPSILON) {\n        return false;\n    }\n\n    float inv_det = 1.0f / det;\n    vec3 s = vec3_sub(ray_origin, t->v0);\n    float u = vec3_dot(s, p) * inv_det;\n    if (u < 0.0f || u > 1.0f) {\n        return false;\n    }\n\n    vec3 q = vec3_cross(s, e1);\n    float v = vec3_dot(ray_target, q) * inv_det;\n    if (v < 0.0f || u + v > 1.0f) {\n        return false;\n    }\n\n    float tt = vec3_dot(e", "\n    float shadow_factor = 1.0;\n    float t = 0.0;\n    float t_max = 1.0;\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {\n        t += t_max;\n        vec3 p = ray_origin + t * ray_direction;\n        float d = map(p);\n        if (d < EPSILON) {\n            shadow_factor = 0.0;\n            break;\n        }\n        t_max = d;\n    }\n    return shadow_factor;\n}\n\n// Calculate the color of a surface at a given point.\n// Considers opacity, but not refraction.\nvec", "\n    return frac(53.589891*sin(x) + 43758.5453);\n}\n\n// Interpolated noise\nfloat", "\n    float f = p;\n    f = f * 12.9898 + dot(vec2(f,f), vec2(127.1,311.7));\n    return fract(sin(f) * 43758.5453);\n}\n\n// Gradient noise\nfloat", "\n    n = (n<<13) ^ n;\n    return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);    \n}\n\n// returns a random number between 0 and 1\nfloat", "\n    float fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rnoise( fl ),\n\t\t\t\trnoise( fl + 1.0 ),\n\t\t\t\tfc);\n}\n\n// 2D rotation\nmat", "\n    float f = 0.0;\n    float w = 0.5;\n    float A = 0.5;\n    for( int i=0; i<5; i++ )\n    {\n        f += A * noise( x );\n        x *= G;\n        A *= 0.5;\n    }\n    return f;\n}\n\n// 2D fbm\nfloat", "\n    float t = time;\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float d = asin(p.z/r);\n    float f = cos(a*10.0-t*10.0)*0.5+0.5;\n    float g = cos(d*10.0-t*10.0)*0.5+0.5;\n    float b = cos(a*10.0+d*10.0-t*10.0)*0.5+0.5;\n    return vec3(f,g,b);\n}\n\n// Return the normal of the sphere at point p\nvec", "\n    vec3 p = pb * 2.0;\n    float a = p.x;\n    float b = p.y;\n    float c = p.z;\n    float d = a*a*a - 6.0*a*b + 11.0*b*b - 6.0*c;\n    float e = 27.0*a*a - 18.0*a*b + 3.0*b*b + 2.0*c;\n    float f = -81.0*a + 18.0*b + 2.0*c;\n    float g = 27.0 - 9.0*a + 3.0*b;\n    float h = 81.0*a - 27.0*b;\n    float i = e*e - 4.0*f*g;\n    float j = sqrt(abs(i));\n    float k = acos(-e/(2.0*j));\n    float l = cos(k/3.0);\n    float m = sqrt(3.0)*sin(k/3.0);\n    float n = (j+e)/(2.0*sqrt(i));\n    float o = sqrt(n);\n    float p1 = (l+m+n)/3.0;\n    float q1 = (l+m-n)/3.0;\n    float r1 = (l-m+n)/3.0;\n    float s1 = -(l+m+n)/3.0;\n    float t1 = (l-m+n)/3.0;\n    float u1 = (l+m-n)/3.0;\n    float v1 = -(l-m+n)/3.0;\n    float w1 = (l+m-n)/3.0;\n    float x1 = (l-m+n)/3.0;\n    float y1 = -(l+m-n)/3.0;\n    float z1 = (l+m+n)/3.0;\n    float A1 = sqrt(3.0)/2.0;\n    float B1 = sqrt(3.0", "\n    vec3 m = ro - cen;\n    vec3 n = m * (rd * rd);\n    vec3 k = abs(m) - rad;\n    float s = max(k.x,max(k.y,k.z));\n    float a = max(n.x,max(n.y,n.z));\n    float b = a*a + s*s;\n    float d = sqrt( b );\n    float t = -a - d;\n    float p = (t < 0.0)? 1.0 : 0.0;\n    t = max(t,0.0);\n    return vec4( t, p, d, 0.0 );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec", "\n    vec3 m = ro - cen;\n    vec3 q = abs(m) - rad;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    return max(d,0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e20;\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n        if (h < 0.001)\n            return 0.0;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h + y * y);\n        res = min(res, 10.0 * d / max(0.0, t - y));\n        ph = h;\n        t += h;\n        if (res < w || t > tmax)\n            break;\n    }\n    return res;\n}\n\n//------------------------------------------------------------------\n//\n// Raymarching\n//\nfloat", " return seed = (seed * 1.61803398875f) - floor(seed * 1.61803398875f); }\n\nfloat", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's IQ Palette\n//https://www.shadertoy.com/view/ll2GD3\nvec", "\n    p.xz *= mat2(cos(ra), sin(ra), -sin(ra), cos(ra));\n    vec2 b = vec2(la, lb);\n    float hh = clamp(0.5 + 0.5 * (p.z - h) / h, 0.0, 1.0);\n    return vec4(length(p.xz), p.y, hh, 1.0).x - mix(b.x, b.y, hh) * (1.0 - hh);\n}\n\n// p=position, la,lb=semi axis, h=height, ra=corner\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float x = length( pa - ba*clamp(h-band,0.0,1.0) );\n    float y = length( pa - ba*clamp(h+band,0.0,1.0) );\n    float z = x + y;\n    float w = (d<r)? -d+r : d;\n    return vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    p = abs(p)-b+r;\n    vec2 q = abs(p+s)-s;\n    return vec4( length(max(vec2(0.0),p)) + min(0.0,max(p.x,p.y)),\n                 length(max(vec2(0.0),q)) + min(0.0,max(q.x,q.y)),\n                 length(p) + length(q) - r,\n                 length(max(vec2(0.0),p)) );\n}\n\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------\n// 2D SDFs\n//----------------------------------------------------------------------------------------", "\n    vec2 d = abs(p)-b;\n    float m = max(d.x,d.y);\n    float n = (m<0.0)?0.0:((m>0.0)?1.0:0.5)-0.5;\n    return vec3( m, n*sign(d.x-d.y), n*sign(d.y-d.x) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    float d = length(p) - r;\n    float a = atan(p.y,p.x);\n    float da = abs(a - floor(a/band)*band);\n    float b = (1.0-smoothstep(0.0,band,da))*r;\n    return vec4(d,b,r,d);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    float d = dot(p-verts[0],p-verts[0]);\n    for( int i=0; i<4; i++ )\n    {\n        vec2 e = verts[i+1]-verts[i];\n        vec2 w = p-verts[i];\n        vec2 b = w-e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b)+r*r );\n    }\n    return sqrt(d);\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat", "\n    vec2 d = p;\n    float dd = dot(d,d);\n    float dd2 = dd*dd;\n    float dd3 = dd2*dd;\n    float dd4 = dd2*dd2;\n    float dd5 = dd4*dd;\n    float dd6 = dd4*dd2;\n    float dd7 = dd6*dd;\n    float dd8 = dd4*dd4;\n    float dd9 = dd8*dd;\n    float dd10 = dd8*dd2;\n    float dd11 = dd10*dd;\n    float dd12 = dd8*dd4;\n    float dd13 = dd12*dd;\n    float dd14 = dd12*dd2;\n    float dd15 = dd14*dd;\n    float dd16 = dd12*dd4;\n    float dd17 = dd16*dd;\n    float dd18 = dd16*dd2;\n    float dd19 = dd18*dd;\n    float dd20 = dd16*dd4;\n    float dd21 = dd20*dd;\n    float dd22 = dd20*dd2;\n    float dd23 = dd22*dd;\n    float dd24 = dd20*dd4;\n    float dd25 = dd24*dd;\n    float dd26 = dd24*dd2;\n    float dd27 = dd26*dd;\n    float dd28 = dd24*dd4;\n    float dd29 = dd28*dd;\n    float dd30 = dd28*dd2;\n    float dd31 = dd30*dd;\n    float dd32 = dd28*dd4;\n    float dd33 = dd32*dd;\n    float dd34 = dd32*dd2", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa - ba*h), -ba.y, ba.x );\n}\n\n// Distance to a line segment\nfloat", "\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return vec3(length(p)*sign(p.y), p);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 e = normalize(X[0]);\n    vec3 f = normalize(X[1]);\n    vec3 g = normalize(X[2]);\n    vec3 e2 = e*e;\n    vec3 f2 = f*f;\n    vec3 g2 = g*g;\n    vec3 e3 = e*e2;\n    vec3 f3 = f*f2;\n    vec3 g3 = g*g2;\n    vec3 e4 = e*e3;\n    vec3 f4 = f*f3;\n    vec3 g4 = g*g3;\n    vec3 e5 = e*e4;\n    vec3 f5 = f*f4;\n    vec3 g5 = g*g4;\n    vec3 e6 = e*e5;\n    vec3 f6 = f*f5;\n    vec3 g6 = g*g5;\n    vec3 e7 = e*e6;\n    vec3 f7 = f*f6;\n    vec3 g7 = g*g6;\n    vec3 e8 = e*e7;\n    vec3 f8 = f*f7;\n    vec3 g8 = g*g7;\n    vec3 e9 = e*e8;\n    vec3 f9 = f*f8;\n    vec3 g9 = g*g8;\n    vec3 e10 = e*e9;\n    vec3 f10 = f*f9;\n    vec3 g10 = g*g9;\n    vec3 e11 = e*e10;\n    vec3 f11 = f*f10;\n    vec3 g11 = g*g10;\n    vec3 e12 = e*e11;\n    vec3 f12 = f*f11;\n    vec3 g12 = g*g11;\n    vec3 e13 = e*e12;\n    vec3 f13 = f*f12", "\n    if (b.x == 0.0) b.x = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        vec3(c, 0.0, -s),\n        vec3(0.0, 1.0, 0.0),\n        vec3(s, 0.0, c)\n    );\n    return m * p;\n}\n\nvec", "\n    float x2 = x * x;\n    float x3 = x2 * x;\n    return 1.0 - x3 / (R * R * R);\n}\n\n// Calculate the light attenuation factor\n// x: distance\n// R: radius\nfloat", "\n    return 1.0f / (1.0f - e) * R;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat", "\n    float k = (a - b) / (R * R);\n    return k * (1.0f - e) + b;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat", "\n    float d = length(p - c) - R;\n    return e * exp(-d * d);\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    float ab2 = dot(ab, ab);\n    float ac2 = dot(ac, ac);\n    float abac = dot(ab, ac);\n    float e2 = e * e;\n    float R2 = R * R;\n    float eab2 = e2 * ab2;\n    float eac2 = e2 * ac2;\n    float eabac = e2 * abac;\n    float eabac2 = eabac * eabac;\n    float eabac4 = eabac2 * eabac2;\n    float eabac6 = eabac4 * eabac2;\n    float eabac8 = eabac6 * eabac2;\n    float eabac10 = eabac8 * eabac2;\n    float eabac12 = eabac10 * eabac2;\n    float eabac14 = eabac12 * eabac2;\n    float eabac16 = eabac14 * eabac2;\n    float eabac18 = eabac16 * eabac2;\n    float eabac20 = eabac18 * eabac2;\n    float eabac22 = eabac20 * eabac2;\n    float eabac24 = eabac22 * eabac2;\n    float eabac26 = eabac24 * eabac2;\n    float eabac28 = eabac26 * eabac2;\n    float eabac30 = eabac28 * eabac2;\n    float eabac32 = eabac30 * eabac2;\n    float eabac34 = eabac32 * eabac2;\n    float eabac36 = eabac34 * eabac2;\n    float eabac38 = eabac36 * eabac2;\n    float eabac40 = eabac38 * eabac2;\n    float eabac", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.2);\n    d", "\n    return length(a - b);\n}\n\n// K root\nfloat", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ).x );\n}\n\n// Raymarching\nfloat", "\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + u * t;\n        float d = map(p);\n        if (d < EPS)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + u * t;\n        float d = map(p);\n        if (d < EPS)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n    return vec3(0.0);\n}\n\nvec", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0)? -min(x2, y2) : (((x > 0.0)? x2 : 0.0) + ((y > 0.0)? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n}\n\n// signed distance to a box\nfloat", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    return (coord - 0.5) * 2.0;\n}\n\n// normalized fragment coordinate\nvec", "\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ) );\n    return vec3(sqrt(d.x), d.y, 0.0);\n}\n\n// Distance to a triangle with base at (0,0)\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p - vec2(0.0, d);\n    float r2 = r * r;\n    float q2 = dot(q, q);\n    float r2mq2 = r2 - q2;\n    float r2pq2 = r2 + q2;\n    float h = sqrt(r2mq2 * r2pq2);\n    float t = atan(q.y, q.x) - atan(h, r2mq2);\n    float s = r2pq2 * (r2mq2 * (r2mq2 * r2mq2 - 3.0 * r2 * q2) + r2pq2 * q2) / (r2mq2 * r2mq2 * r2mq2 * r2mq2);\n    float c = (r2mq2 * r2mq2 - 3.0 * r2 * q2) / (r2mq2 * r2mq2 * r2mq2);\n    float a = r2mq2 * r2mq2 * r2mq2;\n    float b = -3.0 * r2 * r2mq2 * r2mq2;\n    float e = r2pq2 * r2pq2 * r2pq2;\n    float f = -3.0 * r2 * r2pq2 * r2pq2;\n    float g = r2mq2 * r2mq2 * r2mq2 * r2mq2;\n    float h2 = h * h;\n    float h3 = h2 * h;\n    float h4 = h2 * h2;\n    float h5 = h2 * h3;\n    float h6 = h2 * h4;\n    float h7 = h2 * h5;\n    float h8 = h2 * h6;\n    float h9 = h2 * h7;\n    float h10 = h2 * h8;\n    float h11 = h2 * h9;\n    float h12 = h2 * h10;\n    float h13 = h", "\n    p -= c;\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    float d = l - r;\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(d, s, c);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec", "\n    vec2 e0 = v[1]-v[0];\n    vec2 e1 = v[2]-v[1];\n    vec2 e2 = v[0]-v[2];\n    vec2 v0 = p - v[0];\n    vec2 v1 = p - v[1];\n    vec2 v2 = p - v[2];\n    vec2 e02 = e0 - e2;\n    vec2 e12 = e1 - e2;\n    vec2 e20 = e2 - e0;\n    vec2 e01 = e0 - e1;\n    vec2 e10 = e1 - e0;\n    vec2 e21 = e2 - e1;\n    vec3 w;\n    w.x = sign(e0.x*e21.y - e0.y*e21.x);\n    w.y = sign(e1.x*e02.y - e1.y*e02.x);\n    w.z = sign(e2.x*e10.y - e2.y*e10.x);\n    vec3 a;\n    a.x = dot(v0,v0);\n    a.y = dot(v1,v1);\n    a.z = dot(v2,v2);\n    vec3 b;\n    b.x = dot(v0,v1);\n    b.y = dot(v1,v2);\n    b.z = dot(v2,v0);\n    vec3 c;\n    c.x = dot(e0,v0);\n    c.y = dot(e1,v1);\n    c.z = dot(e2,v2);\n    vec3 s;\n    s.x = -dot(e0,e0);\n    s.y = -dot(e1,e1);\n    s.z = -dot(e2,e2);\n    vec3 d;\n    d.x = dot(e0,e1);\n    d.y = dot(e1,e2);\n", "\n    vec2 pa = p - sca;\n    vec2 ba = scb - sca;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 c = sca + h*ba;\n    vec2 v = pa - ba*h;\n    float d = length(v) - ra;\n    float a = atan(v.y,v.x) - atan(ba.y,ba.x);\n    float k = clamp(a/(2.0*PI), -1.0, 1.0 );\n    return vec3( d, d*v.x, d*v.y, k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec", " return a.x*b.y - a.y*b.x; }\nfloat", "\n    p = p / ab;\n    float k0 = length(p);\n    float k1 = k0*k0/2.0;\n    vec2  k2 = k0*p/2.0;\n    float x  = p.x*k2.x - p.y*k2.y;\n    float y  = p.x*k2.y + p.y*k2.x;\n    float z  = k1 - 1.0;\n    return vec3( sqrt(x*x+y*y)*(k0<1.0?1.0:0.0) - z, x, y );\n}\n\n//--------------------------------------------------------------------------\n// 2D distance functions\n//--------------------------------------------------------------------------\n\n// 2D distance function for a circle\nfloat", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,normalize(vec3(q,p.x)));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab );\n    vec3 c = ap - t * ab / dot( ab, ab );\n    float h = clamp( t / dot( ab, ab ), 0.0, 1.0 );\n    float r2 = r * r;\n    float d = ( length( c ) + r2 - r2 * h ) / ( 1.0 - h );\n    float s = ( t > 0.0 && t < dot( ab, ab ) )? 1.0 : 0.0;\n    return vec4( d, s, 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    p.x = abs(p.x) - wi;\n    p.y = p.y + he*sk;\n    vec2 b = vec2(wi,he);\n    vec2 q = vec2( dot(p,vec2(sk,1.0)), abs(p.y) - he*sk );\n    float s = (q.x<0.0 || q.y<0.0)? length(max(q,0.0)) : min(max(q.x,q.y),0.0);\n    return s + length(max(vec2(b.x*sk,b.y*sk)-p,0.0));\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat", "\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(vec2(wi,he),p),0.0)*vec2(wi,he)/dot(vec2(wi,he),vec2(wi,he));\n    p.x *= sign(wi);\n    p.y -= min(max(p.x/wi,p.y/he),0.0)*sk/he;\n    return vec3( length(p)-sk, p.y/he, -p.x/wi );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\t\treturn p * c;\n\t}\n\nfloat", "\n    float h = k * (b - a);\n    return (a + b) * 0.5 - h * h * 0.29289321881345243 / (8.0 * k);\n}\n\n// IQ's polynominal max\nfloat", "\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// http://mercury.sexy/hg_sdf/\nvec", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(u_time, 1.0, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h<0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// IQ's ray box intersection\nvec", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tN, tF);\n}\n\n// IQ's ray box intersection\nvec", "\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec2(p1.x, p2.y);\n    e3 = p2 - vec2(p2.x, p1.y);\n    e4 = p2 - vec2(p1.x, p1.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    vec3 p1 = p - d;\n    vec3 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec3(p1.x, p2.y, p1.z);\n    e3 = p2 - vec3(p2.x, p1.y, p1.z);\n    e4 = p2 - vec3(p1.x, p1.y, p2.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec4 p, vec4 d, inout vec4 e1, inout vec4 e2, inout vec4 e3, inout vec4 e4) {\n    vec4 p1 = p - d;\n    vec4 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec4(p1.x, p2.y, p1.z, p1.w);\n    e3 = p2 - vec4(p2.x, p1.y, p1.z, p1.w);\n    e4 = p2 - vec4(p1.x, p1.y, p2.z, p1.w);", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float f = floor(a / 0.7853981633974483);\n    float l = linedist(p, vec2(cos(f * 0.7853981633974483), sin(f * 0.7853981633974483)), vec2(cos((f + 1.0) * 0.7853981633974483), sin((f + 1.0) * 0.7853981633974483)));\n    float c = smoothstep(0.0, 0.005, l);\n    float m = smoothstep(0.0, 0.005, d - 0.4);\n    float s = smoothstep(0.0, 0.005, d - 0.2);\n    float b = smoothstep(0.0, 0.005, d - 0.1);\n    float r = smoothstep(0.0, 0.005, d - 0.05);\n    float g = smoothstep(0.0, 0.005, d - 0.025);\n    float y = smoothstep(0.0, 0.005, d - 0.0125);\n    float o = smoothstep(0.0, 0.005, d -", "\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h ) - w1;\n    float t = w2/length(ba);\n    return min( d, abs(h-1.0)*t );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 t = rayTorusIntersection(ro, rd, tor);\n    return (t.x < t.y)? t.x : t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    return normalize(e.xyy * torus(pos + e.xyy, tor) +\n                     e.yyx * torus(pos + e.yyx, tor) +\n                     e.yxy * torus(pos + e.yxy, tor) +\n                     e.xxx * torus(pos + e.xxx, tor));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec", "\n    float x2 = x * x;\n    return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    col = col * (0.69470171 + col * (0.2362743 + col * (0.04757511)));\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec", "\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat", "\n    return length(p-c)-r;\n}\n\n// signed distance to a box\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line\nfloat", " return a.x*b.y - a.y*b.x; }\nfloat", "\n    return sdRoundRect(p, vec2(s,s), r);\n}\n\n// s = side length\n// r = corner radius\nfloat", "\n    return x / (1.0 + x);\n}\n\n// This is the same as the above, but with a different curve\nvec", "\n    return vec3(\n        -0.5 * x.x * x.x * x.x + 1.5 * x.x * x.x - 2.5 * x.x + 1.0,\n        -0.5 * x.y * x.y * x.y + 1.5 * x.y * x.y - 2.5 * x.y + 1.0,\n        -0.5 * x.z * x.z * x.z + 1.5 * x.z * x.z - 2.5 * x.z + 1.0\n    );\n}\n\n// derivative of s-curve\nvec", "\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = a*k/2.0/PI;\n    return abs(r-t*w);\n}\n\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n", "\n    return exp(-opticalDepth * g_Scattering.Absorption);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec", "\n    // Calculate the optical depth along the ray.\n    float opticalDepth = CalculateOpticalDepth(rayStart, rayDir, rayLength);\n\n    // Calculate the transmittance.\n    transmittance = exp(-opticalDepth * lightColor);\n\n    // Calculate the scattering.\n    return lightColor * transmittance * scatteringCoefficient;\n}\n\n// Calculate the scattering for a single directional light source.\nvec", "\n    vec3 p = p2;\n    p.z -= d;\n    float b = length(p)-ra;\n    float a = max(b,length(p-vec3(0.0,0.0,d))-rb);\n    float k = ra-rb;\n    return max(a,b*k);\n}\n\n//------------------------------------------------------------------\n// 3D distance function for a sphere\n//------------------------------------------------------------------\nfloat", "\n    return max( length(p)-r, abs(h-length(p))-t );\n}\n\n// p = point\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec", "\n    return length(p.xy) - r - h;\n}\n\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//------------------------------------------------------------------\n// 2D SDFs\n//", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sdf(pos+h.xyy) - sdf(pos-h.xyy),\n                           sdf(pos+h.yxy) - sdf(pos-h.yxy),\n                           sdf(pos+h.yyx) - sdf(pos-h.yyx) ) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    return max( abs(length(p)-r), abs(p.y)-h );\n}\n\n// r=radius, h=height\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 2d noise function\nfloat", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat", "\n\tp3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//3D value noise\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    // Draw a circle\n    float dist = distance(uv, vec2(0.5, 0.5));\n    if (dist < 0.25)\n    {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Draw a square\n    if (uv.x > 0.25 && uv.x < 0.75 && uv.y > 0.25 && uv.y < 0.75)\n    {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n\n    // Draw a triangle\n    if (uv.x > 0.25 && uv.x < 0.75 && uv.y > 0.75)\n    {\n        col = vec3(0.0, 0.0, 1.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  vec3 color = hsv2rgb(vec3(uv.x, 1.0, 1.0));\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float h = clamp(0.5 + 0.5 * (size - p) / size, 0.0, 1.0);\n    p -= h * size;\n    return h;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat", "\n    return fract(sin(co * 12.9898) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    return t <= 0.0031308? 12.92 * t : (1.055 * pow(t, 0.41666) - 0.055);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return mix(1.055 * pow(c, vec3(0.4166667)) - 0.055, c * 12.92, lessThanEqual(c, vec3(0.0031308)));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if(t1>t2) {\n        float tmp = t1;\n        t1 = t2;\n        t2 = tmp;\n    }\n    if(t1<0.0) {\n        t1 = t2;\n        if(t1<0.0) return -1.0;\n    }\n    if(t1<dbuffer) return t1;\n    return t2;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat", "\n    vec4 q = p;\n    float t = 0.0;\n    for (int i = 0; i < 10; i++) {\n        q = p + 0.5 * q * (1.0 - 1.0 / length(q));\n        t += 1.0;\n    }\n    return vec4(t * log(length(q)) / log(2.0), q);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    vec4 res = vec4(-k0, k0*p.x/r.x, k0*p.y/r.y, k0*p.z/r.z);\n\n    if (k1 < 1.0)\n    {\n        float m = (1.0-k1*k1)/k1;\n        vec3 n = res.yzw*m;\n        res = vec4(sqrt(m*(2.0+m)), n.x, n.y, n.z);\n    }\n\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return front + (back * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    return (front.rgb * front.a) + (back * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    p = abs(p);\n    return max(p.x+p.y*0.866025404,p.y*1.5)-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    return clamp(v * (2.51 * v + 0.03) / (v * (2.43 * v + 0.59) + 0.14), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec3 col = vec3(0.0);\n    col.r = clamp(pow(Temp, -0.145) * 1.33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix( dot( hash22(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                    dot( hash22(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n               mix( dot( hash22(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                    dot( hash22(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2(-b-h, -b+h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    p = p*p;\n    float r = p.x + p.y;\n    float a = r*r;\n    float b = r*a;\n    float c = (2.0*b - a)*r + a*a;\n    float d = c*r + b;\n    float e = d*r + a;\n    float f = e*r - b;\n    float g = f*r - c;\n    float h = g*r + d;\n    float k = h*r + e;\n    float l = k*r - f;\n    float m = l*r - g;\n    float x = m*r + h;\n    float y = x*r + k;\n    float z = y*r - l;\n    float w = z*r - m;\n    float q = w*r + l;\n    float t = q*r + m;\n    float u = t*r - l;\n    float v = u*r - m;\n    float w2 = v*r + l;\n    float t2 = w2*r + m;\n    float u2 = t2*r - l;\n    float v2 = u2*r - m;\n    float w3 = v2*r + l;\n    float t3 = w3*r + m;\n    float u3 = t3*r - l;\n    float v3 = u3*r - m;\n    float w4 = v3*r + l;\n    float t4 = w4*r + m;\n    float u4 = t4*r - l;\n    float v4 = u4*r - m;\n    float w5 = v4*r + l;\n    float t5 = w5*r + m;\n    float u5 = t5*r - l;\n    float v5 = u5*r - m;\n    float w6 = v5*r + l;\n    float t6 = w6*r + m;\n    float u6 = t6*r - l;\n    float v6 = u6*r - m;\n    float w7 = v6*r + l;\n    float t7", "\n    return x - t * t * 0.25;\n}\n\n// generalization of Devil's Staircase\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    float d = p.y;\n    for (int i = 0; i < 5; i++) {\n        p = p.xzy * mat3(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0, 0.0);\n        p.xz *= mat2(cos(0.1), sin(0.1), -sin(0.1), cos(0.1));\n        p.xz -= vec2(0.5, 0.5);\n        p.xz *= 1.0 + dot(p.xz, p.xz) * 0.5;\n        p.xz += vec2(0.5, 0.5);\n        p.xz *= mat2(cos(0.1), sin(0.1), -sin(0.1), cos(0.1));\n        p.xz += vec2(0.5, 0.5);\n        p.xz *= mat2(cos(0.1), sin(0.1), -sin(0.1), cos(0.1));\n        p.xz -= vec2(0.5, 0.5);\n        p.xz *= 1.0 + dot(p.xz, p.xz) * 0.5;\n        p.xz += vec2(0.5, 0.5);\n        p.xz *= mat2(cos(0.1), sin(0.1), -sin(0.1), cos(0.1));\n        p.xz += vec2(0.5, 0.5);\n        p.xz *= mat2(cos(0.1), sin(0.1), -sin(0.1), cos(0.1));\n        p.xz -= vec2(0.5, 0.5);\n        p.xz *= 1.0 + dot(p.xz, p.xz) * 0.5;\n        p.xz += vec2(0.5, 0", "\n    float a = y / x;\n    float a2 = a * a;\n    float a4 = a2 * a2;\n    float a8 = a4 * a4;\n    float a16 = a8 * a8;\n    float a32 = a16 * a16;\n    float a64 = a32 * a32;\n    float a128 = a64 * a64;\n    float a256 = a128 * a128;\n    float a512 = a256 * a256;\n    float a1024 = a512 * a512;\n    float a2048 = a1024 * a1024;\n    float a4096 = a2048 * a2048;\n    float a8192 = a4096 * a4096;\n    float a16384 = a8192 * a8192;\n    float a32768 = a16384 * a16384;\n    float a65536 = a32768 * a32768;\n    float a131072 = a65536 * a65536;\n    float a262144 = a131072 * a131072;\n    float a524288 = a262144 * a262144;\n    float a1048576 = a524288 * a524288;\n    float a2097152 = a1048576 * a1048576;\n    float a4194304 = a2097152 * a2097152;\n    float a8388608 = a4194304 * a4194304;\n    float a16777216 = a8388608 * a83", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n    return vec2(atanh(z.x), atanh(z.y));\n}\n\n// Inverse hyperbolic tangent \nvec", "\n    float e = exp(z.x);\n    return vec2(e * cos(z.y), e * sin(z.y));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n    float e = exp(z.x);\n    return vec2(e * cos(z.y), e * sin(z.y));\n}\n\nvec", "\n    return vec4(smoothstep(0.0, 1.0, alpha.r),\n                smoothstep(0.0, 1.0, alpha.g),\n                smoothstep(0.0, 1.0, alpha.b),\n                smoothstep(0.0, 1.0, alpha.a));\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec", "\n    p = abs(p);\n    float c = p.x;\n    float b = p.y;\n    float a = p.z;\n    float k = max(c, max(b, a));\n    float m = min(c, min(b, a));\n    float d = (7.0 * m - k) / 7.0;\n    float e = (k - 3.0 * m) / 7.0;\n    float f = (k + m) / 3.0;\n    return (k + d + e + f) / 4.0;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat", "\n    uvw = abs(uvw);\n    vec3 p = uvw;\n    vec3 q = uvw;\n    vec3 r = uvw;\n    vec3 s = uvw;\n    vec3 t = uvw;\n    vec3 u = uvw;\n    vec3 v = uvw;\n    vec3 w = uvw;\n    vec3 x = uvw;\n    vec3 y = uvw;\n    vec3 z = uvw;\n    vec3 a = uvw;\n    vec3 b = uvw;\n    vec3 c = uvw;\n    vec3 d = uvw;\n    vec3 e = uvw;\n    vec3 f = uvw;\n    vec3 g = uvw;\n    vec3 h = uvw;\n    vec3 i = uvw;\n    vec3 j = uvw;\n    vec3 k = uvw;\n    vec3 l = uvw;\n    vec3 m = uvw;\n    vec3 n = uvw;\n    vec3 o = uvw;\n    vec3 p1 = uvw;\n    vec3 q1 = uvw;\n    vec3 r1 = uvw;\n    vec3 s1 = uvw;\n    vec3 t1 = uvw;\n    vec3 u1 = uvw;\n    vec3 v1 = uvw;\n    vec3 w1 = uvw;\n    vec3 x1 = uvw;\n    vec3 y1 = uvw;\n    vec3 z1 = uvw;\n    vec3 a1 = uvw;\n    vec3 b1 = uvw;\n    vec3 c1 = uvw;\n    vec3 d1 = uvw;\n    vec3 e1 = uvw;\n    vec3 f1 = uvw;\n    vec3 g1 = uvw", "\n    // 1.0 - 1.0/gridRes\n    float scale = 1.0 - 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale2 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale3 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale4 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale5 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale6 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale7 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale8 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale9 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale10 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale11 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale12 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale13 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale14 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale15 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale16 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale17 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale18 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale19 = 1.0/gridRes;\n    // 1.0/gridRes\n    float offsetScale", "\n    uvw *= gridRes;\n    uvw = floor(uvw);\n    uvw /= gridRes;\n    uvw = uvw * 2.0 - 1.0;\n    uvw = contrast * uvw;\n    return uvw;\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec", "\n    p = abs(p);\n    return (p.x + p.y + p.z - 1.0) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat", "\n    return vec3(\n        mix(0.0, 0.3, t),\n        mix(0.0, 0.3, t),\n        mix(0.0, 0.3, t)\n    );\n}\n\n// makes Warm colormap with polynimal 6\nvec", "\n    a = a * (PI / 180.0);\n    mat3 m = mat3(\n        cos(a.y) * cos(a.z),\n        sin(a.x) * sin(a.y) * cos(a.z) - cos(a.x) * sin(a.z),\n        cos(a.x) * sin(a.y) * cos(a.z) + sin(a.x) * sin(a.z),\n        cos(a.y) * sin(a.z),\n        sin(a.x) * sin(a.y) * sin(a.z) + cos(a.x) * cos(a.z),\n        cos(a.x) * sin(a.y) * sin(a.z) - sin(a.x) * cos(a.z),\n        -sin(a.y),\n        sin(a.x) * cos(a.y),\n        cos(a.x) * cos(a.y)\n    );\n    return m * v;\n}\n\n// returns the distance to the nearest object\nfloat", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    p = abs(p);\n    return max(p.x, p.y) + (sqrt(3.0) / 2.0) * min(p.x, p.y);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat", "\n    vec2 p = uv * 2.0 - 1.0;\n    vec2 h = vec2(1.0, 0.57735027);\n    vec2 a = p - dot(p, h.yx) * h;\n    vec2 b = abs(p) - 1.0;\n    vec2 c = clamp(a, -b, b);\n    vec2 d = max(0.0, c.x) * h.x + max(0.0, c.y) * h.y;\n    vec2 e = d.yx;\n    vec2 f = max(0.0, e.x) * h.x + max(0.0, e.y) * h.y;\n    vec2 g = max(0.0, f.x) * h.x + max(0.0, f.y) * h.y;\n    vec2 hh = abs(g);\n    vec2 i = vec2(p.x > 0.0? hh.x : -hh.x, p.y > 0.0? hh.y : -hh.y);\n    vec2 j = i * 2.0 / dot(i, i);\n    vec2 k = j * dot(j, i);\n    vec2 l = k * 2.0 / dot(k, k);\n    vec2 m = l * dot(l, k);\n    vec2 n = m * 2.0 / dot(m, m);\n    vec2 o = n * dot(n, m);\n    vec2 p = o * 2.0 / dot(o, o);\n    vec2 q = p * dot(p, o);\n    vec2 r = q * 2.0 / dot(q, q);\n    vec2 s = r * dot(r, q);\n    vec2 t = s * 2.0 / dot(s, s);\n    vec2 u = t * dot(t, s);\n    vec2 v = u * 2.0 / dot(u,", "\n    float r = clamp(t, 0.0, 1.0);\n    return vec3(\n        r * 1.9618627450980392 - 0.8646647278958118,\n        r * -0.1451073163352053 + 1.5292943054092958,\n        r * -0.0125228781065947 + 1.9843747670250884\n    );\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat", "\n    float cell = floor(uv.x / gridRes) + floor(uv.y / gridRes);\n    float cellTime = time * 0.05 + cell * 0.05;\n    float cellOffset = cell * gridRes;\n    float cellUv = uv.x - cellOffset;\n    float cellUv2 = uv.y - cellOffset;\n    float cellUv3 = uv.x - cellOffset;\n    float cellUv4 = uv.y - cellOffset;\n    float cellUv5 = uv.x - cellOffset;\n    float cellUv6 = uv.y - cellOffset;\n    float cellUv7 = uv.x - cellOffset;\n    float cellUv8 = uv.y - cellOffset;\n    float cellUv9 = uv.x - cellOffset;\n    float cellUv10 = uv.y - cellOffset;\n    float cellUv11 = uv.x - cellOffset;\n    float cellUv12 = uv.y - cellOffset;\n    float cellUv13 = uv.x - cellOffset;\n    float cellUv14 = uv.y - cellOffset;\n    float cellUv15 = uv.x - cellOffset;\n    float cellUv16 = uv.y - cellOffset;\n    float cellUv17 = uv.x - cellOffset;\n    float cellUv18 = uv.y - cellOffset;\n    float cellUv19 = uv.x - cellOffset;\n    float cellUv20 = uv.y - cellOffset;\n    float cellUv21 = uv.x - cellOffset;\n    float cellUv22 = uv.y - cellOffset;\n    float cellUv23 = uv.x - cellOffset;\n    float cellUv24 = uv.y - cellOffset;\n    float cellUv25 = uv.x - cellOffset;\n    float cellUv26 = uv.y - cellOffset;\n    float cellUv27 = uv.x - cellOffset;\n    float cellUv", "\n    float t = time * 0.5;\n    float t2 = time * 0.25;\n    float t3 = time * 0.125;\n    float t4 = time * 0.0625;\n    float t5 = time * 0.03125;\n    float t6 = time * 0.015625;\n    float t7 = time * 0.0078125;\n    float t8 = time * 0.00390625;\n    float t9 = time * 0.001953125;\n    float t10 = time * 0.0009765625;\n    float t11 = time * 0.00048828125;\n    float t12 = time * 0.000244140625;\n    float t13 = time * 0.0001220703125;\n    float t14 = time * 0.00006103515625;\n    float t15 = time * 0.000030517578125;\n    float t16 = time * 0.0000152587890625;\n    float t17 = time * 0.00000762939453125;\n    float t18 = time * 0.000003814697265625;\n    float t19 = time * 0.0000019073486328125;\n    float t20 = time * 0.00000095367431640625;\n    float t21 = time * 0.000000476837158203125;\n    float t22 = time * 0.000000", "\n    float angle = time * 0.5;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.x * sin(angle) + point.y * cos(angle);\n    return vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec", "\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec", "\n    vec2 d = p2 - p1;\n    vec2 w = p - p1;\n    float b = dot(w, d);\n    if (b <= 0.0) return length(w);\n    float c = dot(d, d);\n    if (b >= c) return length(p - p2);\n    return length(w - d * clamp(b / c, 0.0, 1.0));\n}\n\n// Computes the signed distance from a circle\nfloat", "\n    float d = length(p) - 0.5;\n    float a = atan(v.y, v.x);\n    float da = atan(p.y, p.x) - a;\n    float l = length(p);\n    float w = abs(da) * l;\n    return max(d, -w);\n}\n\n// Returns a signed distance from the arrow\nfloat", "\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius * spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a circle swirl centered on point\nvec", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    float t = time;\n    float s = sp;\n    float r = sdRoundBox(p, vec2(s,s), 0.05);\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU(r, sdRoundBox(p, vec2(s,s), 0.05));\n    r = opU", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float c = floor(a/sp);\n    float s = sin(c*sp);\n    float t = cos(c*sp);\n    float r0 = r - (s*ra + t*ra);\n    float r1 = r - (s*ra - t*ra);\n    float r2 = r - (-s*ra - t*ra);\n    float r3 = r - (-s*ra + t*ra);\n    float r4 = r - (s*ra + t*ra);\n    float r5 = r - (s*ra - t*ra);\n    float r6 = r - (-s*ra - t*ra);\n    float r7 = r - (-s*ra + t*ra);\n    float r8 = r - (s*ra + t*ra);\n    float r9 = r - (s*ra - t*ra);\n    float r10 = r - (-s*ra - t*ra);\n    float r11 = r - (-s*ra + t*ra);\n    float r12 = r - (s*ra + t*ra);\n    float r13 = r - (s*ra - t*ra);\n    float r14 = r - (-s*ra - t*ra);\n    float r15 = r - (-s*ra + t*ra);\n    float r16 = r - (s*ra + t*ra);\n    float r17 = r - (s*ra - t*ra);\n    float r18 = r - (-s*ra - t*ra);\n    float r19 = r - (-s*ra + t*ra);\n    float r20 = r - (s*ra + t*ra);\n    float r21 = r - (s*ra - t*ra);\n    float r22 = r - (-s*ra - t*ra);\n    float r23 = r - (-s*ra + t*ra);\n    float r24 = r - (s*ra + t*ra);\n    float r25 = r - (s*ra -", "\n    uvw = abs(uvw);\n    float d = uvw.x;\n    d = max(d, uvw.y);\n    d = max(d, uvw.z);\n    return d;\n}\n\n//edge distance of a Cube\nfloat", "\n    vec3 absUvw = abs(uvw);\n    float m = max(absUvw.x, max(absUvw.y, absUvw.z));\n    vec3 uvw2 = uvw / m;\n    return texture(tex, uvw2);\n}\n\n// Cube Tiling with Rotation\nvec", "\n    vec3 uvw_ = uvw * gridRes + offset;\n    vec3 uvw_f = floor(uvw_);\n    vec3 uvw_c = ceil(uvw_);\n    vec3 uvw_m = uvw_ - uvw_f;\n\n    vec4 x0y0z0 = texture(tex, uvw_f / gridRes);\n    vec4 x1y0z0 = texture(tex, (uvw_c.xxy + offset) / gridRes);\n    vec4 x0y1z0 = texture(tex, (uvw_c.xyx + offset) / gridRes);\n    vec4 x1y1z0 = texture(tex, (uvw_c + offset) / gridRes);\n\n    vec4 x0y0z1 = texture(tex, (uvw_f.xyy + offset) / gridRes);\n    vec4 x1y0z1 = texture(tex, (uvw_c.xxy + offset.yxz) / gridRes);\n    vec4 x0y1z1 = texture(tex, (uvw_c.xyx + offset.yxz) / gridRes);\n    vec4 x1y1z1 = texture(tex, (uvw_c + offset.yxz) / gridRes);\n\n    vec4 x0y0 = mix(x0y0z0, x0y0z1, uvw_m.z);\n    vec4 x1y0 = mix(x1y0z0, x1y0z1, uvw_m.z);\n    vec4 x0y1 = mix(x0y1z0, x0y1z1, uvw_m.z);\n    vec4 x1y1 = mix(x1y1z0, x1y1z1, uvw_m.z);\n\n    vec4 x0 = mix(x0y0, x0y1, uvw_m.y);\n    vec4 x1 = mix(x1y0, x1y1, uv", "\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes RdYlBu_r colormap with polynimal 7 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n    p = abs(p);\n    return max(p.x, max(p.y, p.z));\n}\n\n//Distance from the Edge of Cube\nfloat", "\n    return mix(vec3(0.0, 0.0, 0.5), vec3(0.0, 0.5, 1.0), t);\n}\n\n// makes summer colormap with polynimal 6\nvec", "\n    return vec3(uv, 0.0);\n}\n\n// simple square Tiling\nvec", "\n    vec2 r = vec2(1.0, 1.0);\n    vec2 d = abs(fract(uv.x * r.x) - 0.5) + abs(fract(uv.y * r.y) - 0.5);\n    return vec3(d, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec", "\n    vec2 grid = floor(uv * gridRes) / gridRes;\n    return vec3(grid.x + grid.y, grid.x + grid.y, grid.x + grid.y);\n}\n\n// nakes a square pixelized pattern\nvec", "\n    vec2 p = floor(uv * gridRes) / gridRes;\n    return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec", "\n    vec2 cell = floor(uv * gridRes) + offset;\n    float cellTime = time * 0.001;\n    float cellTime2 = cellTime * 0.5;\n    float cellTime3 = cellTime * 0.333;\n    float cellTime4 = cellTime * 0.25;\n    float cellTime5 = cellTime * 0.166;\n    float cellTime6 = cellTime * 0.125;\n    float cellTime7 = cellTime * 0.0833;\n    float cellTime8 = cellTime * 0.0625;\n    float cellTime9 = cellTime * 0.048;\n    float cellTime10 = cellTime * 0.038;\n    float cellTime11 = cellTime * 0.032;\n    float cellTime12 = cellTime * 0.027;\n    float cellTime13 = cellTime * 0.023;\n    float cellTime14 = cellTime * 0.02;\n    float cellTime15 = cellTime * 0.018;\n    float cellTime16 = cellTime * 0.016;\n    float cellTime17 = cellTime * 0.014;\n    float cellTime18 = cellTime * 0.012;\n    float cellTime19 = cellTime * 0.011;\n    float cellTime20 = cellTime * 0.01;\n    float cellTime21 = cellTime * 0.009;\n    float cellTime22 = cellTime * 0.008;\n    float cellTime23 = cellTime * 0.007;\n    float cellTime24 = cellTime * 0.006;\n    float cellTime25 = cellTime * 0.005;\n    float cellTime26 = cellTime * 0.004;\n    float cellTime27 = cellTime * 0.003;\n    float cellTime28 = cellTime * 0.002;\n    float cellTime", "\n    float t = time * 0.05;\n    float r = len * 0.05;\n    float s = sin(uv.x * gridRes + t) * sin(uv.y * gridRes + t) * r;\n    return s;\n}\n\n// generates pixelated directional waves\nfloat", "\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 aa = vec2(0.0);\n    aa.x = max(0.5*(w.x+w.y)-p.x,0.0);\n    aa.y = max(0.5*(w.x+w.y)-p.y,0.0);\n    return 1.0-smoothstep(aa,aa+vec2(0.5),p);\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat", "\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p = p * 2.0 - 1.0;\n    vec2 cell = floor(p + dot(p, p) * 0.316316158);\n    vec2 cell_id = cell + cell * cell * 0.333333333;\n    p = cell + (p - cell) * 0.577350269;\n    return cell_id;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec", "\n    return 0.5 + 0.5*sin(x*10.0);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat", "\n    return mix(1.055 * pow(t, vec3(0.4166667)) - 0.055, t * 12.92, lessThanEqual(t, vec3(0.0031308)));\n}\n\nvec", "\n    return df(p, 0.0);\n}\n\nfloat", "\n    p = p*2.0 - 1.0;\n    float a = atan(p.x, p.y) / 3.14159265359;\n    float r = length(p);\n    float d = abs(a - floor(a + 0.5));\n    float w = fwidth(a) * 2.0;\n    float m = smoothstep(0.0, -w, d);\n    float n = smoothstep(0.0, w, d);\n    return (r * m + (1.0 - r) * n) * 1.41421356237;\n}\n\n// Multiscale truchet\nfloat", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*v0.y - e0.y*v0.x;\n    vec3 c;\n\n    c.x = sign( s );\n    c.y = sign( e0.x*v0.y - e0.y*v0.x );\n    c.z = sign( e1.x*v1.y - e1.y*v1.x );\n\n    vec3 a = max( c.xxx, c.yyy );\n    float d = min( min( dot2( pq0 ), dot2( pq1 ) ), dot2( pq2 ) );\n    float da = max( a.x, max( a.y*abs(c.z), a.z*abs(c.y) ) );\n\n    return -sqrt(d)*sign(da);\n}\n\n// signed distance to a 2D quad\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if(t1>t2) {\n        float tmp = t1;\n        t1 = t2;\n        t2 = tmp;\n    }\n    if(t1<0.0) {\n        t1 = t2;\n        if(t1<0.0) return -1.0;\n    }\n    if(t1<dbuffer) return t1;\n    return t2;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat", "\n    return length(p - vec2(clamp(p.x, -w, w), 0.0)) - r;\n}\n\nfloat", "\n    float r = length(p);\n    float a = atan(p.x,p.y) / (2.0*k);\n    float c = cos(a);\n    float s = sin(a);\n    float d = abs(r*c*s - 1.0);\n    float t = pow(r,2.0)*(c*c + s*s);\n    return sqrt(d*d + t);\n}\n\n// k in (0,1) range\nfloat", "\n    float d = sdOOX(p.x,p.y);\n    return d;\n}\n\n// distance to y=1/x\nfloat", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n    a = a * a;\n    a = a * a;\n    return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a", "\n    p = (p - 0.25) * 2.0;\n    float a = length(p);\n    float b = atan(p.y, p.x);\n    float c = length(p * vec2(cos(b), -sin(b)));\n    return (a * a * a - 3.0 * a * c) / (a - 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat", "\n    vec2 P = pos - A;\n    vec2 Q = B - A;\n    vec2 R = C - A;\n    vec2 S = P - Q - R;\n    float t = dot(P,Q) + dot(R,S);\n    float a = dot(P,R);\n    float b = dot(Q,S);\n    float c = dot(Q,R);\n    float d = dot(P,S);\n    float e = dot(P,Q);\n    float det = a*e - d*b;\n    float u = (t*e - d*c) / det;\n    float v = (a*b - t*c) / det;\n    float w = 1.0 - u - v;\n    vec2 dPdu = -R - 2.0*u*Q - 2.0*v*S;\n    vec2 dPdv = -S - 2.0*u*P - 2.0*w*R;\n    float du = dot(dPdu,dPdu);\n    float dv = dot(dPdv,dPdv);\n    float d = min(min(du,dv),1.0);\n    float dist = sqrt(d);\n    vec2 dP = dPdu*sqrt(du) + dPdv*sqrt(dv);\n    return vec3(dist,dP.x,dP.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec", "\n    vec2 p = pos;\n    float w = wi;\n    float h = he;\n    float k = (w*w+h*h)/(w*w);\n    vec2 c = vec2(-w*h*h/w,0.0);\n    vec2 v = p-c;\n    vec2 d = v*mat2(k,h,h,-k);\n    float s = sign(d.x);\n    vec2 r = v-s*d*mat2(k,-h,h,k);\n    float l = sign(r.x)*length(r);\n    float m = s*sqrt(dot(v,v)-l*l);\n    float t = atan(m,l);\n    float a = t/w;\n    float x = cos(a)*l;\n    float y = sin(a)*l;\n    vec2 e = vec2(x,y);\n    vec2 q = p-c-e;\n    float b = atan(q.y,q.x);\n    float z = cos(b);\n    float w = sin(b);\n    float l2 = length(q);\n    float l3 = l2*l2;\n    float l4 = l2*l3;\n    float l5 = l4*l2;\n    float l6 = l5*l2;\n    float l7 = l6*l2;\n    float l8 = l7*l2;\n    float l9 = l8*l2;\n    float l10 = l9*l2;\n    float l11 = l10*l2;\n    float l12 = l11*l2;\n    float l13 = l12*l2;\n    float l14 = l13*l2;\n    float l15 = l14*l2;\n    float l16 = l15*l2;\n    float l17 = l16*l2;\n    float l18 = l17*l2;\n    float l19 = l18*l2;\n    float l20 = l1", "\n    vec2 w = pos*pos;\n    vec2 a = vec2(w.x-w.y/k,3.0*w.x*w.y);\n    float h = k*(w.x+w.y);\n    vec3 g = vec3(a.x+a.y*h,a.y*h,2.0*a.x);\n    return vec3(dot(g,g),g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float b = atan(rb*sin(a), ra*cos(a));\n    float f = cos(b);\n    float g = sin(b);\n    float h = r - d;\n    float k = sqrt(h*h + f*f);\n    float l = atan(g, h);\n    float m = atan(f, h);\n    float n = l - m;\n    float o = k*sign(n);\n    float q = o/k;\n    float t = atan(q);\n    float u = t - b;\n    float v = cos(u);\n    float w = sin(u);\n    float x = r*v;\n    float y = r*w;\n    float z = p.x*v + p.y*w;\n    return vec3(sqrt(x*x + y*y), x, y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v >> 16);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v >> 16);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nfloat", "\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nvec", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    vec3 res = vec3(dot(d, d), ky * ky - 4.0 * kx * kz, 2.0 * ky * kz - kx * kx - kx * ky);\n    res.x = res.y * res.y - 4.0 * res.z;\n    res.y = sqrt(max(0.0, res.y));\n\n    float x0 = -2.0 * res.z / (res.y + res.x);\n    float x1 = (res.y - res.x) / (res.y + res.x);\n    float k0 = sign(x0) * pow(abs(x0), 0.25);\n    float k1 = sign(x1) * pow(abs(x1), 0.25);\n    float s = (k0 + k1) * 0.5;\n    float t = (k0 - k1) * 0.5;\n\n    vec2 p = s * s * a + t * t * b + s * t * c + d;\n    return sign(p.x) * sqrt(dot(p, p)) / abs(s);\n}\n\n// signed distance to a cubic bezier\nfloat", "\n    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat", "\n    vec3 p = ro - vec3(0.0,0.0,s.z*0.5);\n    vec3 q = p - vec3(0.0,s.y*0.5,0.0);\n    vec3 v = vec3(0.0,s.y,s.z);\n    vec3 w = vec3(s.x,0.0,0.0);\n    vec3 u = normalize(cross(v,w));\n    vec3 v = normalize(cross(w,u));\n    vec3 n = normalize(cross(u,v));\n    vec3 r = cross(rd,n);\n    vec3 s = cross(r,rd);\n    float t = dot(q,s)/dot(r,s);\n    vec3  p = ro + rd*t;\n    vec3  d = p - q;\n    float x = dot(d,u);\n    float y = dot(d,v);\n    float z = dot(d,w);\n    float d = max(max(abs(x),abs(y)),abs(z));\n    float e = step(0.0,d);\n    float i = step(0.0,t);\n    float h = clamp(e*i*sign(t-d),0.0,1.0);\n    float l = length(d);\n    return vec4( l*h, n );\n}\n\n//--------------------------------------------------------------------------\n// iBox\n//\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec", "\n    int a_i = a;\n    int b_i = int(b*float(1<<24));\n    int x_i = int(x*float(1<<24));\n    int ret_i = a_i*b_i+x_i;\n    ret_n = ret_i>>24;\n    return float(ret_i&0x007fffff)/float(1<<24);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat", "\n    vec3 m = vec3( min(a.x,b.x) - k, step(a.x,b.x) * a.yz + step(b.x,a.x) * b.yz );\n    return vec3( min(m.x,m.y), m.yz );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float r = sqrt(x*x + y*y);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r6*r2;\n    float r10 = r8*r2;\n    float r12 = r10*r2;\n    float r14 = r12*r2;\n    float r16 = r14*r2;\n    float r18 = r16*r2;\n    float r20 = r18*r2;\n    float r22 = r20*r2;\n    float r24 = r22*r2;\n    float r26 = r24*r2;\n    float r28 = r26*r2;\n    float r30 = r28*r2;\n    float r32 = r30*r2;\n    float r34 = r32*r2;\n    float r36 = r34*r2;\n    float r38 = r36*r2;\n    float r40 = r38*r2;\n    float r42 = r40*r2;\n    float r44 = r42*r2;\n    float r46 = r44*r2;\n    float r48 = r46*r2;\n    float r50 = r48*r2;\n    float r52 = r50*r2;\n    float r54 = r52*r2;\n    float r56 = r54*r2;\n    float r58 = r56*r2;\n    float r60 = r58*r2;\n    float r62 = r60*r2;\n    float r64 = r62*r2;\n    float r66 = r64*r2;\n    float r68 = r6", "\n    float c = a + b;\n    return c;\n}\n\n//precision loss testing\nfloat", "\n    vec2  h = p - ab;\n    float d = dot(h,h);\n    float k = s1*s1 - s2*s2;\n    float a = sqrt( (d+k)*(d-k) );\n    float x = sqrt( 0.5*(d+k) );\n    float y = sqrt( 0.5*a );\n    return vec2( x,y ) - h*inversesqrt(d);\n}\n\n//for highlighting individual solutions\nvec", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = baba - paba * paba / baba;\n    float y = dot(pa, ba) - paba * baba / baba;\n    float z = y * y - x * (baba - ra * ra - rb * rb);\n    if (z >= 0.0)\n    {\n        float pz = -y + sqrt(z);\n        float pz2 = pz * pz / x;\n        float y2 = y * y;\n        float z2 = z * 0.5;\n        float v = (pz2 > y2)? sqrt(pz2 - y2) - y : z2 / pz;\n        return vec4(v, pz, pz2 < y2? pz * ba / baba + a : ba * (y + v) / sqrt(x) + a);\n    }\n    return vec4(sqrt(max(x * y - z, 0.0)) / abs(x) - y, y, 0.0, 0.0);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    float res = 1.0;\n    float t = 0.001;\n    float h = 1.0;\n    float k = 0.1;\n    for( int i=0; i<10; i++ )\n    {\n        if( h<0.001 || t>10.0 ) break;\n        h = map( ro + rd*t );\n        if( showSurface )\n        {\n            if( h<0.001 )\n            {\n                res = min( res, k*h/t );\n            }\n        }\n        else\n        {\n            res = min( res, k*h/t );\n        }\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat", "\n    float h = ra - rb;\n    float t = clamp( (p.x-ra)/h, 0.0, 1.0 );\n    float r = mix( ra, rb, t );\n    float d = length( p ) - r;\n    ocl = p;\n    return vec3( d, -p.y, p.x );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\n//--------------------------------------------------------------------------------\n// 2D Primitives\n//--------------------------------------------------------------------------------\n\n// 2D box\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat", " return dot(v,v); }\nfloat", "\n    vec2 d = max(p - minCorner, vec2(0.0)) - max(maxCorner - p, vec2(0.0));\n    return dot(d, d);\n}\n\n// Squared distance to a circle\nfloat", "\n    vec2 uv2 = uv;\n    uv2.x += time * 0.001;\n    uv2.y += time * 0.001;\n    float n = noise(uv2);\n    float n2 = noise(uv2 * 2.0);\n    float n3 = noise(uv2 * 4.0);\n    float n4 = noise(uv2 * 8.0);\n    float n5 = noise(uv2 * 16.0);\n    float n6 = noise(uv2 * 32.0);\n    float n7 = noise(uv2 * 64.0);\n    float n8 = noise(uv2 * 128.0);\n    float n9 = noise(uv2 * 256.0);\n    float n10 = noise(uv2 * 512.0);\n    float n11 = noise(uv2 * 1024.0);\n    float n12 = noise(uv2 * 2048.0);\n    float n13 = noise(uv2 * 4096.0);\n    float n14 = noise(uv2 * 8192.0);\n    float n15 = noise(uv2 * 16384.0);\n    float n16 = noise(uv2 * 32768.0);\n    float n17 = noise(uv2 * 65536.0);\n    float n18 = noise(uv2 * 131072.0);\n    float n19 = noise(uv2 * 262144.0);\n    float n20 = noise(uv2 * 524288.0);\n    float n21 = noise(uv2 * 1048576.0);\n    float n22 = noise(uv2 * 2097152.0);\n    float n23 = noise(uv2 * 4194304.0);\n    float n24 = noise(uv2 * 8388608.0);\n", "\n    vec3 ray = vec3(uv, 1.0);\n    ray = (2.0 * ray - 1.0) * vec3(1.0, -1.0, 1.0);\n    ray.z = -1.0 / tan(radians(fov) / 2.0);\n    return normalize(ray);\n}\n\n// Ray-sphere intersection\nfloat", "\n    return v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Quaternion-quaternion multiplication\nvec", "\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    return (m.x<d)? m : vec2(d,a);\n}\n\nvec", "\n    float a = dot(rd,rd);\n    float b = 2.0*dot(rd,ro);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 )\n    {\n        p1 = vec4(-1.0);\n        p2 = vec4(-1.0);\n        return;\n    }\n    h = sqrt(h);\n    a = 2.0*a;\n    p1 = vec4(-b-h, -b+h, a, a);\n    p1.xy = p1.xy/p1.w;\n    p2 = p1;\n    p1.z = min(p1.z,p1.w);\n    p1.w = max(p1.z,-p1.w);\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCapsule( in vec3 ro, in vec3 rd, in float ra, in float rb, in float h, out vec4 p1, out vec4 p2 )\n{\n    vec3 oc = ro - vec3(0.0,0.0,h*0.5);\n    float k = length(rd.xz);\n    if( k<1e-4 )\n    {\n        intersectCylinder( ro, rd, ra, rb, h, p1, p2 );\n        return;\n    }\n    rd /= k;\n    float a = dot(rd.xz,rd.xz);\n    float b = dot(rd.xz,oc.xz);\n    float c = dot(oc.xz,oc.xz) - ra*ra;\n    float h2 = b*b - a*c;\n    if( h2<0.0 )\n    {\n        p1 = vec4(-1.0);\n        p2 = vec4(-1.0);\n        return;\n    }\n    h2 = sqrt(h2);\n    a = 1.0/a;\n", "\n    vec2 d = p - c;\n    float a = atan(d.y, d.x);\n    float l = length(d) - r;\n    return vec3(l, cos(a), sin(a));\n}\n\nvec", "\n    vec2 d = abs(p)-b;\n    float m = max(d.x,d.y);\n    float f = m<0.0? 0.0 : m;\n    vec2 g = m<0.0? d : vec2(0.0);\n    return vec3(f,g);\n}\n\nvec", "\n    vec3 q = vec3(p,0.0);\n    q.y -= 0.25;\n    q.y *= 2.0;\n    q.x *= 0.5;\n    q.x -= 0.5;\n    q.x *= 2.0;\n    q.yz = vec2(q.y*q.y-q.x*q.x,2.0*q.x*q.y);\n    float r = dot(q.yz,q.yz);\n    float d = (r+q.x*q.x-0.25);\n    d = (d*d+q.y*q.y*0.25);\n    d = sqrt(d);\n    d = (d-q.x*q.y)/(r+1.0);\n    d = (d*d+1.0);\n    d = sqrt(d);\n    d = d-1.0;\n    d = (d*d);\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d = d*d;\n    d =", "\n    float t = x / (a1 + a2);\n    float y = (1.0 - t) * b1 + t * b2;\n    return y;\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/qjqjqjqjqj\nfloat", "\n    return pow(abs(x), n) / pow(a, n) + b;\n}\n\n// Fast push -> wobble (red)\n// https://www.desmos.com/calculator/qjqjqjqjqj\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                float noise = 0.0;\n                float scale = 1.0;\n                for(int i = 0; i < 5; i++){\n                    noise += texture(iChannel0, uv * scale).x * scale;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n\n            float paperNoise(vec2 uv, float time){\n                float noise = 0.0;\n                float scale = 1.0;\n                for(int i = 0; i < 5; i++){\n                    noise += texture(iChannel0, uv * scale + time * 0.01).x * scale;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n\n            float paperNoise(vec2 uv, float time, float scale){\n                float noise = 0.0;\n                for(int i = 0; i < 5; i++){\n                    noise += texture(iChannel0, uv * scale + time * 0.01).x * scale;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n\n            float paperNoise(vec2 uv, float time, float scale, float offset){\n                float noise = 0.0;\n                for(int i = 0; i < 5; i++){\n                    noise += texture(iChannel0, uv * scale + time * 0.01 + offset).x * scale;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n\n            float paperNoise(vec2 uv, float time, float scale, float offset, float scale2){\n                float noise = 0.0;\n                for(int i = 0; i < 5; i++){\n                    noise += texture(iChannel0, uv * scale + time * 0.01 + offset).x * scale;\n                    scale *= scale2;\n                }\n                return noise;\n            }\n\n            float paperNoise(vec2 uv, float time, float scale, float offset, float scale2, float scale3){\n                float noise = 0.0;\n                for(int i = 0; i < 5; i++){\n", "\n    vec3 c = vec3( 0.0, 0.0, 0.0 );\n    float t = 0.0;\n    for( int i = 0; i < 14; i++ )\n    {\n        c = c + vec3( 1.0, 1.0, 1.0 ) / ( vec3( x, y, 1.0 ) + vec3( 0.0, 0.0, t ) );\n        t = t + 1.0;\n    }\n    return c;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 c = compute( int( uv.x * resolution.x ), int( uv.y * resolution.y ) );\n    gl_FragColor = vec4( c, 1.0 );\n}\n", "\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n    vec2 pa = p-a, ba = b-a;\n    float h2 = h*h;\n    float px = dot(pa,ba)/dot(ba,ba);\n    px = clamp(px, 0.0, 1.0);\n    vec2  c = a + px*ba;\n    float xc = pa.x, yc = pa.y;\n    float d2 = xc*xc + yc*yc;\n    float rx = sqrt(d2-h2);\n    float s = max(d2min, rx-h*px);\n    float t = length(pa-c)-h*px;\n    float a = max(s, t);\n    float b = sqrt(d2);\n    float f = clamp( (b-h)*px/b, 0.0, 1.0 );\n    return vec2( sqrt(a*a + 0.25*f*(b*b-h2)), 1.0-f );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n    float d = sdLine(p, kType[0], kPath[0], kPath[1], kPath[2], kPath[3]);\n    for (int i = 1; i < 7; i++)\n    {\n        d = opU(d, sdLine(p, kType[i], kPath[4*i], kPath[4*i+1], kPath[4*i+2], kPath[4*i+3]));\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat", "\n    float d = sdBox(p, vec2(1.0));\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.0), 0.1);\n    d = sdRoundBox(p, vec2(1.", "\n    float k = 1.0;\n    float s = sdBox(p,vec3(1.0));\n    for( int m=0; m<5; m++ )\n    {\n        vec2 r = vec2( sdBox(p-vec3(0.0,0.0,k),vec3(1.0)),\n                       sdBox(p+vec3(0.0,0.0,k),vec3(1.0)) );\n        s = opU(s,min(r.x,r.y));\n        k *= 3.0;\n    }\n    return s;\n}\n\n//------------------------------------------------------------------\n// 2D distance function\n//------------------------------------------------------------------\nfloat", "\n    // Scale the input space to the 0-1 range.\n    uv *= 10.0;\n\n    // Create triangular waves.\n    float f = tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the coordinate system by 2x2.\n    uv *= 2.0;\n\n    // Create triangular waves.\n    f += tri( uv.x ) + tri( uv.y );\n\n    // Scale the", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Distance to segment\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat", "\n    vec2 q = clamp(p, -b, b) - p;\n    return p + sign(q)*max(0.0, dot(q, q) - r*r);\n}\n\n// closest point on rounded box\nvec", "\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to sphere\nfloat", "\n    p = 50.0*fract(p*0.3183099+.1);\n    return -1.0+2.0*fract(p.x*p.y*(p.x+p.y));\n}\n\n// 2D Noise\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// A 3D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    float n = fbm(uv * 10.0);\n    vec3 col = vec3(n);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 100.0;\n    float va = 0.0;\n    float wt = 0.0;\n\n    for (int j = -1; j <= 1; j++)\n    {\n        for (int i = -1; i <= 1; i++)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash22(p + g);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            float ww = pow(1.0 - smoothstep(0.0, 1.414, sqrt(d)), k);\n            va += o.x * ww;\n            wt += ww;\n        }\n    }\n\n    return va / wt;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    float t = u_time * 0.5;\n    vec2 p = uv * 1.5;\n    p.x += t * 0.5;\n\n    float v = pattern(p);\n    v = smoothstep(0.0, 1.0, v);\n\n    vec3 col = vec3(v);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    float r = sqrt(x * x + y * y);\n    float theta = atan(r);\n    float area = theta * r;\n    return area;\n}\n\nfloat", "\n\tp3 = fract(p3 * vec3(.1031,.1030,.0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec", "\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0 * G3;\n    vec3 x3 = x - 1.0 + 3.0 * G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(rand3(s), x);\n    d.y = dot(rand3(s + i1), x1);\n    d.z = dot(rand3(s + i2), x2);\n    d.w = dot(rand3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\n\nfloat", "\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// 2D noise based on improved simplex hash\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//----------------------------------------------------------------------------------------\nfloat", "\n    vec2 d = abs(p)-b+r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.y;\n}\n\n// This is the final form\nfloat", "\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#Distance_from_a_point_to_the_ellipse\n    // https://en.wikipedia.org/", "\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    float a = atan(p.y, p.x);\n    float d = length(p) - r;\n    float n = floor(m);\n    float en = n * an;\n    float iq = floor(a / en);\n    float iq2 = iq + 0.5;\n    float iq3 = iq + 1.0;\n    float iq4 = iq + 1.5;\n    float iq5 = iq + 2.0;\n    float iq6 = iq + 2.5;\n    float iq7 = iq + 3.0;\n    float iq8 = iq + 3.5;\n    float iq9 = iq + 4.0;\n    float iq10 = iq + 4.5;\n    float iq11 = iq + 5.0;\n    float iq12 = iq + 5.5;\n    float iq13 = iq + 6.0;\n    float iq14 = iq + 6.5;\n    float iq15 = iq + 7.0;\n    float iq16 = iq + 7.5;\n    float iq17 = iq + 8.0;\n    float iq18 = iq + 8.5;\n    float iq19 = iq + 9.0;\n    float iq20 = iq + 9.5;\n    float iq21 = iq + 10.0;\n    float iq22 = iq + 10.5;\n    float iq23 = iq + 11.0;\n    float iq24 = iq + 11.5;\n    float iq25 = iq + 12.0;\n    float iq26 = iq + 12.5;\n    float iq27 = iq + 13.0;\n    float iq28 = iq + 13.5;\n    float iq29 = iq + 14.0;\n    float iq30 = iq + 14.5;\n    float iq31 = iq + 15.0;\n", "\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n\t\t\t\t\t  k.yyx*map( p + k.yyx*h ).x + \n\t\t\t\t\t  k.yxy*map( p + k.yxy*h ).x + \n\t\t\t\t\t  k.xxx*map( p + k.xxx*h ).x );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n    float res = 1.0;\n    float t = t0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (t > t1)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Calculate the normal of the surface at the given point\nvec", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat", "\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat3(\n        t * x * x + c, t * x * y - s * z, t * x * z + s * y,\n        t * x * y + s * z, t * y * y + c, t * y * z - s * x,\n        t * x * z - s * y, t * y * z + s * x, t * z * z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat", "\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    ray = mat3(u, v, w) * ray;\n    return ray;\n}\n\n// Helper function that returns the color of the sky\nvec", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash3d(n+0.0), hash3d(n+1.0),f.x),\n                   mix( hash3d(n+57.0), hash3d(n+58.0),f.x),f.y),\n               mix(mix( hash3d(n+113.0), hash3d(n+114.0),f.x),\n                   mix( hash3d(n+170.0), hash3d(n+171.0),f.x),f.y),f.z);\n}\n\n// 2D value noise\nfloat", "\n    float n = 0.0;\n    n += snoise(p);\n    n += snoise(p*2.0);\n    n += snoise(p*4.0);\n    n += snoise(p*8.0);\n    n /= 4.0;\n    return n;\n}\n\n// 2D simplex noise, cool trick\nfloat", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f/0.9375;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat", "\n    vec2 density = vec2(0.0);\n    float density_sum = 0.0;\n    float density_sum_weight = 0.0;\n    float density_sum_weight_inv = 0.0;\n    float density_sum_weight_inv_sq = 0.0;\n    float density_sum_weight_inv_cube = 0.0;\n    float density_sum_weight_inv_quart = 0.0;\n    float density_sum_weight_inv_quart_sq = 0.0;\n    float density_sum_weight_inv_quart_cube = 0.0;\n    float density_sum_weight_inv_quart_quart = 0.0;\n    float density_sum_weight_inv_quart_quart_sq = 0.0;\n    float density_sum_weight_inv_quart_quart_cube = 0.0;\n    float density_sum_weight_inv_quart_quart_quart = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_sq = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_cube = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart_sq = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart_cube = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart_quart = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart_quart_sq = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart_quart_cube = 0.0;\n    float density_sum_weight_inv_quart_quart_quart_quart_quart_quart = 0.0;\n    float density_", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = vec3(0.0, 1.0, 0.0);\n\tfloat shadow = 0.0;\n\tfloat coverage = 0.0;\n\tfloat shadowDist = 0.0;\n\tfloat shadowFactor = 0.0;\n\tfloat shadowFactor2 = 0.0;\n\tfloat shadowFactor3 = 0.0;\n\tfloat shadowFactor4 = 0.0;\n\tfloat shadowFactor5 = 0.0;\n\tfloat shadowFactor6 = 0.0;\n\tfloat shadowFactor7 = 0.0;\n\tfloat shadowFactor8 = 0.0;\n\tfloat shadowFactor9 = 0.0;\n\tfloat shadowFactor10 = 0.0;\n\tfloat shadowFactor11 = 0.0;\n\tfloat shadowFactor12 = 0.0;\n\tfloat shadowFactor13 = 0.0;\n\tfloat shadowFactor14 = 0.0;\n\tfloat shadowFactor15 = 0.0;\n\tfloat shadowFactor16 = 0.0;\n\tfloat shadowFactor17 = 0.0;\n\tfloat shadowFactor18 = 0.0;\n\tfloat shadowFactor19 = 0.0;\n\tfloat shadowFactor20 = 0.0;\n\tfloat shadowFactor21 = 0.0;\n\tfloat shadowFactor22 = 0.0;\n\tfloat shadowFactor23 = 0.0;\n\tfloat shadowFactor24 = 0.0;\n\tfloat shadowFactor25 = 0.0;\n\tfloat shadowFactor26 = 0.0;\n\tfloat shadowFactor27 = 0.0;\n\tfloat shadowFactor28 = 0.0;\n\tfloat shadowFactor29 = 0.0;\n\tfloat shadowFactor30 = 0.0;\n\tfloat shadowFactor31 = 0.0;\n\tfloat shadowFactor32 = 0.0;\n\tfloat shadowFactor33 = 0.0;\n\tfloat shadowFactor34 = 0.0;\n\tfloat shadowFactor35 = 0.0;\n", "\n    vec3 ray = normalize(pointEnd - pointStart);\n    float d = rayMarch(pointStart, ray, dist);\n    float fog = exp(-d * 0.00005);\n    vec3 col = vec3(0.0);\n    if(d < dist){\n        col = vec3(0.0, 0.0, 0.0);\n        col = mix(col, vec3(0.0, 0.0, 0.0), fog);\n    }\n    return mix(background, col, 0.5);\n}\n\n// Render the clouds, apply fog, alpha blend with the background, return\nvec", "\n    color *= 0.6;\n    color = clamp(color, 0.0, 1.0);\n    color = (color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14);\n    return color;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution;\n    vec3 color = texture(u_texture, uv).rgb;\n    color = aces_tonemap(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    FragColor = vec4(color, 1.0);\n}\n"]}