{"generations": [" return 0.282095; }\nfloat SH_1_0( in vec3 s ) { return 0.488603 * s.z; }\nfloat SH_1_1( in vec3 s ) { return 0.488603 * s.x; }\nfloat SH_2_0( in vec3 s ) { return 0.488603 * s.y; }\nfloat SH_2_1( in vec3 s ) { return 1.092548 * s.x * s.z; }\nfloat SH_2_2( in vec3 s ) { return 0.946178 * (s.x * s.x - s.y * s.y); }\nfloat SH_3_0( in vec3 s ) { return 0.488603 * s.z; }\nfloat SH_3_1( in vec3 s ) { return 1.092548 * s.x * s.y; }\nfloat SH_3_2( in vec3 s ) { return 0.315392 * s.y * s.z; }\nfloat SH_3_3( in vec3 s ) { return 0.546274 * (s.x * s.x - s.y * s.y); }\nfloat SH_4_0( in vec3 s ) { return 0.222521 * s.z; }\nfloat SH_4_1( in vec3 s ) { return 0.519842 * s.x * s.z; }\nfloat SH_4_2( in vec3 s ) { return 0.373177 * s.y * s.z; }\nfloat SH_4_3( in vec3 s ) { return 0.473087 * s.x * s.y; }\nfloat SH_4_4( in vec3 s ) { return 0.154303 * (3.0 * s.z * s.z - 1.0); }\nfloat", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(", "\n    return (v.x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n    return (v.x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n    return (v.x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nmat2 flipIfNeg( in mat2 v, in mat2 r )\n{\n    return (v[0].x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nmat3 flipIfNeg( in mat3 v, in mat3 r )\n{\n    return (v[0].x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nmat4 flipIfNeg( in mat4 v, in mat4 r )\n{\n    return (v[0].x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nquat flipIfNeg( in quat v, in quat r )\n{\n    return (v.x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\ndquat flipIfNeg( in dquat v, in dquat r )\n{\n    return (v.x<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nbvec2 flipIfNeg( in bvec2 v,", "\n    return dot(v,r) < 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return dot(v,r) < 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return dot(v,r) < 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return dot(v,r) > 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    return dot(v,r) > 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{\n    return dot(v,r) > 0.0? v - 2.0*dot(v,r)*r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float eps )\n{\n    return dot(v,r) < eps? v - 2.0*dot(v,r)*r : v;\n}\n", "\n    vec2 q = v - r;\n    return v - q * clamp( dot( q, r ) / dot( r, r ), 0.0, 1.0 );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n    vec3 q = v - r;\n    return v - q * clamp( dot( q, r ) / dot( r, r ), 0.0, 1.0 );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n    vec4 q = v - r;\n    return v - q * clamp( dot( q, r ) / dot( r, r ), 0.0, 1.0 );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    vec2 q = v - r;\n    return v - q * clamp( dot( q, r ) / dot( r, r ), 0.0, 1.0 );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    vec3 q = v - r;\n    return v - q * clamp( dot( q, r ) / dot( r, r ), 0.0, 1.0 );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    vec4 q = v - r;\n    return v - q * clamp( dot( q, r ) / dot( r, r ), 0.0, 1.0 );\n}\n\n// Clip v if in the negative half", "\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2*h;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3 )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2*h - w3*h*(1.0-h);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4 )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2*h - w3*h*(1.0-h) - w4*h*h*(1.0-h);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4, float w5 )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2*h - w3*h*(1.0-h) - w4*h*h*(1.0-h) - w5*h*h*h*(1.0-h);\n}\n\nfloat sdArrow( in vec2 p", "\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = sunDot * sunDot;\n    float sunDot3 = sunDot2 * sunDot;\n    float sunDot4 = sunDot3 * sunDot;\n    float sunDot5 = sunDot4 * sunDot;\n    float sunDot6 = sunDot5 * sunDot;\n    float sunDot7 = sunDot6 * sunDot;\n    float sunDot8 = sunDot7 * sunDot;\n    float sunDot9 = sunDot8 * sunDot;\n    float sunDot10 = sunDot9 * sunDot;\n    float sunDot11 = sunDot10 * sunDot;\n    float sunDot12 = sunDot11 * sunDot;\n    float sunDot13 = sunDot12 * sunDot;\n    float sunDot14 = sunDot13 * sunDot;\n    float sunDot15 = sunDot14 * sunDot;\n    float sunDot16 = sunDot15 * sunDot;\n    float sunDot17 = sunDot16 * sunDot;\n    float sunDot18 = sunDot17 * sunDot;\n    float sunDot19 = sunDot18 * sunDot;\n    float sunDot20 = sunDot19 * sunDot;\n    float sunDot21 = sunDot20 * sunDot;\n    float sunDot22 = sunDot21 * sunDot;\n    float sunDot23 = sunDot22 * sunDot;\n    float sunDot24 = sunDot23 * sunDot;\n    float sunDot25 = sunDot24 * sunDot;\n    float sunDot26 = sunDot25 * sunDot;\n    float sunDot27 = sunDot26 * sunDot;\n    float sunDot28 = sunDot27 * sunDot;\n   ", "\n    vec4 a = 2.0 * p1;\n    vec4 b = p2 - p0;\n    vec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    vec4 pos = 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n    return pos;\n}\n\n// This is a spline used for the camera path\nvec3 CatmullRom(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n    vec3 a = 2.0 * p1;\n    vec3 b = p2 - p0;\n    vec3 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec3 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    vec3 pos = 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n    return pos;\n}\n\n// This is a spline used for the camera path\nvec3 CatmullRom(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, out vec3 tangent)\n{\n    vec3 a = 2.0 * p1;\n    vec3 b = p2 - p0;\n    vec3 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec3 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    vec3 pos = 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n    tangent = 1.0 * (b + (", "\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += snoise(p.xyz * iter) / iter;\n\t\titer = iter * 2.0;\n\t\tp = p.yzx * mat3(cos(nudge), sin(nudge), 0.0, -sin(nudge), cos(nudge), 0.0, 0.0, 0.0, 1.0);\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D version of the 1D value noise function.\n// It is the same principle as the 2D SpiralNoise, but on 3 axes.\nfloat SpiralNoise3D(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += snoise(p.xyz * iter) / iter;\n\t\titer = iter * 2.0;\n\t\tp = p.yzx * mat3(cos(nudge), sin(nudge), 0.0, -sin(nudge), cos(nudge), 0.0, 0.0, 0.0, 1.0);\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D version of the 1D value noise function.\n// It is the same principle as the 2D SpiralNoise, but on 3 axes.\n// It is the same as SpiralNoise3D, but with a different hash function.\nfloat SpiralNoise3D_2(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += snoise(p.xyz * iter) / iter;\n\t\titer = iter * 2.0;\n\t\tp = p.yzx * mat3(cos(nudge), sin(nudge), 0.0, -sin(nudge), cos(nudge", "\n    // find the segment\n    int i = int(t);\n    t = t - float(i);\n\n    // find the points\n    int p0 = i - 1;\n    int p1 = i;\n    int p2 = i + 1;\n    int p3 = i + 2;\n\n    // clamp the points\n    if (p0 < 0)\n    {\n        p0 = 0;\n        p1 = 1;\n        p2 = 2;\n        p3 = 3;\n    }\n    if (p3 > NUM_CAM_POINTS - 1)\n    {\n        p0 = NUM_CAM_POINTS - 4;\n        p1 = NUM_CAM_POINTS - 3;\n        p2 = NUM_CAM_POINTS - 2;\n        p3 = NUM_CAM_POINTS - 1;\n    }\n\n    // get the points\n    vec4 p0v = cam_path[p0];\n    vec4 p1v = cam_path[p1];\n    vec4 p2v = cam_path[p2];\n    vec4 p3v = cam_path[p3];\n\n    // calculate the tangents\n    vec4 m0 = p1v - p0v;\n    vec4 m1 = p2v - p1v;\n    vec4 m2 = p3v - p2v;\n\n    // calculate the Catmull-Rom point\n    vec4 t = (2.0 * p1v) + (-m0 + m2) * t + (2.0 * m0 - 5.0 * m1 + 4.0 * m2) * t * t + (-m0 + 3.0 * m1 - 3.0 * m2 + m3) * t * t * t;\n\n    return t;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamDir(float t)\n{\n    // find the segment\n    int i = int(t);\n    t =", "\n    return frac(sin(u) * 43758.5453123);\n}\n\nfloat Hash2d(vec2 uv)\n{\n    return frac(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat Hash3d(vec3 uv)\n{\n    return frac(sin(dot(uv, vec3(12.9898, 78.233, 151.7182))) * 43758.5453123);\n}\n\nfloat Hash4d(vec4 uv)\n{\n    return frac(sin(dot(uv, vec4(12.9898, 78.233, 151.7182, 124.354))) * 43758.5453123);\n}\n\nfloat Noise1d(float u)\n{\n    float uFloor = floor(u);\n    float uFrac = fract(u);\n\n    float v0 = Hash1d(uFloor);\n    float v1 = Hash1d(uFloor + 1.0);\n\n    return mix(v0, v1, uFrac);\n}\n\nfloat Noise2d(vec2 uv)\n{\n    vec2 uvFloor = floor(uv);\n    vec2 uvFrac = fract(uv);\n\n    float v00 = Hash2d(uvFloor);\n    float v10 = Hash2d(uvFloor + vec2(1.0, 0.0));\n    float v01 = Hash2d(uvFloor + vec2(0.0, 1.0));\n    float v11 = Hash2d(uvFloor + vec2(1.0, 1.0));\n\n    float vx0 = mix(v00, v10, uvFrac.x);\n    float vx1 = mix(", "\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tn += snoise(p) * iter;\n\t\titer = iter * 0.5;\n\t\tp = p * 2.0 + vec3(1.0, 57.0, 113.0);\n\t}\n\treturn n;\n}\n\n// This is a 3D version of the 2D value noise function.\n// It is the same principle, just done in 3D and including some simple rotation.\nfloat ValueNoise3D(vec3 p)\n{\n\tvec3 pi = floor(p);\n\tvec3 pf = fract(p);\n\n\tfloat res = -8.0;\n\tfor (int k = -1; k <= 1; k++)\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t\tfor (int i = -1; i <= 1; i++)\n\t\t\t{\n\t\t\t\tvec3 o = vec3(float(i), float(j), float(k));\n\t\t\t\tvec3 r = pf + o - 0.5;\n\t\t\t\tfloat v = dot(r, r);\n\t\t\t\tres = max(res, -v);\n\t\t\t}\n\treturn res;\n}\n\n// This is a 3D version of the 2D perlin noise function.\n// It is the same principle, just done in 3D and including some simple rotation.\nfloat PerlinNoise3D(vec3 p)\n{\n\tvec3 pi = floor(p);\n\tvec3 pf = fract(p);\n\n\tfloat res = 0.0;\n\tfor (int k = -1; k <= 1; k++)\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t\tfor (int i = -1; i <= 1; i++)\n\t\t\t{\n\t\t\t\tvec3 o = vec3(float(i), float(j), float(k));\n\t\t\t\tvec3 r = pf + o - 0.5;\n\t\t\t\tfloat v = dot(r, r);\n\t\t\t\tres += (sin(v*", "\n    float d = p.y;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d = p.y - r;\n        r = r * 3.0;\n        p = abs(p) / dot(p, p) * r;\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    float d = p.y;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d = p.y - r;\n        r = r * 3.0;\n        p = abs(p) / dot(p, p) * r;\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    float d = p.y;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d = p.y - r;\n        r = r * 3.0;\n        p = abs(p) / dot(p, p) * r;\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    float d = p.y;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d = p.y - r;\n        r = r * 3.0;\n        p = abs(p) / dot(p, p) * r;\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    float d = p.y;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d = p.y - r;\n        r = r * 3", "\n    // Softbox\n    float t = RayBox(rayDir, vec3(0.0), vec3(1000.0), 0.0);\n    if (t > 0.0)\n    {\n        vec3 pos = rayDir * t;\n        vec3 normal = GetBoxNormal(pos, vec3(0.0), vec3(1000.0));\n        return GetSoftboxColor(pos, normal, rayDir, sunDir);\n    }\n\n    // Lights\n    float t1 = RayBox(rayDir, vec3(0.0, 0.0, -100.0), vec3(100.0, 100.0, 100.0), 0.0);\n    float t2 = RayBox(rayDir, vec3(0.0, 0.0, -100.0), vec3(100.0, 100.0, 100.0), 1.0);\n    float t3 = RayBox(rayDir, vec3(0.0, 0.0, -100.0), vec3(100.0, 100.0, 100.0), 2.0);\n    float t4 = RayBox(rayDir, vec3(0.0, 0.0, -100.0), vec3(100.0, 100.0, 100.0), 3.0);\n    float t5 = RayBox(rayDir, vec3(0.0, 0.0, -100.0), vec3(100.0, 100.0, 100.0), 4.0);\n    float t6 = RayBox(rayDir, vec3(0.0, 0.0, -100.0), vec3(100.0, 100.0, 100.0), 5.0);\n    float t7 = RayBox(rayDir, vec3(0.0, 0", "\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nvec2 smax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a.x-b.x)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec3 smin( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a.x-b.x)/k, 0.0, 1.0 );\n    return mix( a, b, h", "\n\tvec3 L = spherePos - pos;\n\tfloat tca = dot(L, dirVecPLZNormalizeMeFirst);\n\tfloat d2 = dot(L, L) - tca * tca;\n\tif (d2 > rad * rad) return -1.0;\n\tfloat thc = sqrt(rad * rad - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\tif (t0 > t1)\n\t{\n\t\tfloat tmp = t0;\n\t\tt0 = t1;\n\t\tt1 = tmp;\n\t}\n\tif (t0 < 0)\n\t{\n\t\tt0 = t1; // if t0 is negative, let's use t1 instead\n\t\tif (t0 < 0) return -1.0; // both t0 and t1 are negative\n\t}\n\treturn t0;\n}\n\nfloat PlaneIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos, vec3 planeNormal)\n{\n\tfloat denom = dot(planeNormal, dirVecPLZNormalizeMeFirst);\n\tif (abs(denom) > 0.0001)\n\t{\n\t\tfloat t = dot(planePos - pos, planeNormal) / denom;\n\t\tif (t >= 0.0)\n\t\t{\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nfloat CylinderIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 cylPos, vec3 cylDir, float cylRad, float cylHeight)\n{\n\tvec3 L = cylPos - pos;\n\tfloat tca = dot(L, dirVecPLZNormalizeMeFirst);\n\tfloat d2 = dot(L, L) - tca * tca;\n\tif (d2 > cylRad * cylRad) return -1.0;\n\tfloat thc = sqrt(cylRad * cylRad - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\tif (t0 > t1)\n\t{\n\t\tfloat", "\n    // The distance to the object is the distance to the surface of the sphere.\n    // The distance to the surface of the sphere is the distance to the center of the sphere minus the radius of the sphere.\n    // The distance to the center of the sphere is the distance to the origin minus the position of the sphere.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n    // The distance to the point is the length of the vector from the point to the origin.\n    // The distance to the origin is the length of the vector from the origin to the point.\n   ", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n    return", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (jerk)\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (snap)\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (crackle)\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (pop)\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (splat)\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (splosh)\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (splosh)\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (splosh)\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (splosh)\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (splosh)\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve seventh derivative (toot)\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve eighth derivative (doink)\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve ninth derivative (blip)\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve tenth derivative (snap)\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve eleventh derivative (crackle)\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve twelfth derivative (pop)\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve thirteenth derivative (toot)\nvec3 mapD13(float t)\n{\n    return vec3", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return vec2( length( p - c ), t );\n}\n\n// signed squared distance between point and segment\nfloat ssqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return length( p - c ) * sign( dot( cross( ab, ap ), cross( ab, c ) ) );\n}\n\n// signed squared distance between point and segment\nfloat ssqdPointSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec2 c = a + t * ab;\n    return length( p - c ) * sign( dot( ab, ap ) - dot( ab, c ) );\n}\n\n// signed squared distance between point and segment\nfloat ssqdPointSegment( in vec2 p, in vec2 a, in vec2 b, out float t )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    t = dot( ap, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec2 c = a + t * ab;\n    return length( p - c ) * sign( dot( ab, ap ) - dot( ab, c ) );\n}\n", "\n    vec3 ab = b - a;\n    vec3 oa = a - o;\n    float t = dot( oa, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return vec2( length( c - o ), length( c - o ) / length( d ) );\n}\n\n// signed squared distance between ray and segment\nfloat ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec3 ab = b - a;\n    vec3 oa = a - o;\n    float t = dot( oa, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return length( c - o ) * sign( dot( cross( ab, oa ), d ) );\n}\n\n// signed squared distance between ray and segment\nfloat ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out float t )\n{\n    vec3 ab = b - a;\n    vec3 oa = a - o;\n    t = dot( oa, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 c = a + t * ab;\n    return length( c - o ) * sign( dot( cross( ab, oa ), d ) );\n}\n\n// signed squared distance between ray and segment\nfloat ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out float t, out vec3 c )\n{\n    vec3 ab = b - a;\n    vec3 oa = a - o;\n    t = dot( oa, ab ) / dot( ab, ab );\n    t = clamp( t, 0.0, 1.0 );\n    c = a + t * ab;\n    return length(", "\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    return sdRoundBox(p, b, vec4(r,r,r,r));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b ) \n{\n    return sdRoundBox(p, b, 0.0);\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{\n    r.xyz = (p.x>0.0)?r.xyz : r.zxy;\n    r.x   = (p.y>0.0)?r.x   : r.y;\n    vec3 q = abs(p)-b+r.x;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    return sdRoundBox(p, b, vec4(r,r,r,r));\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b ) \n{\n    return sdRoundBox(p, b, 0.0);\n}\n\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r ) \n{\n    r.xyzw = (p.x>0.0)?r.xyzw : r.wzyx;\n    r.xwz  = (p.y>", "\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = sunDot * sunDot;\n    float sunDot3 = sunDot2 * sunDot;\n    float sunDot4 = sunDot3 * sunDot;\n    float sunDot5 = sunDot4 * sunDot;\n    float sunDot6 = sunDot5 * sunDot;\n    float sunDot7 = sunDot6 * sunDot;\n    float sunDot8 = sunDot7 * sunDot;\n    float sunDot9 = sunDot8 * sunDot;\n    float sunDot10 = sunDot9 * sunDot;\n    float sunDot11 = sunDot10 * sunDot;\n    float sunDot12 = sunDot11 * sunDot;\n    float sunDot13 = sunDot12 * sunDot;\n    float sunDot14 = sunDot13 * sunDot;\n    float sunDot15 = sunDot14 * sunDot;\n    float sunDot16 = sunDot15 * sunDot;\n    float sunDot17 = sunDot16 * sunDot;\n    float sunDot18 = sunDot17 * sunDot;\n    float sunDot19 = sunDot18 * sunDot;\n    float sunDot20 = sunDot19 * sunDot;\n    float sunDot21 = sunDot20 * sunDot;\n    float sunDot22 = sunDot21 * sunDot;\n    float sunDot23 = sunDot22 * sunDot;\n    float sunDot24 = sunDot23 * sunDot;\n    float sunDot25 = sunDot24 * sunDot;\n    float sunDot26 = sunDot25 * sunDot;\n    float sunDot27 = sunDot26 * sunDot;\n    float sunDot28 = sunDot27 * sunDot;\n   ", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This is the function that actually does the raymarching.\n// It basically takes a ray and march it along the ray until it hits something.\n// It also returns the distance to the object it hit.\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( h<0.001 ) break;\n        t += h;\n    }\n    return t;\n}\n\n// This is the function that actually does the raymarching.\n// It basically takes a ray and march it along the ray until it hits something.\n// It also returns the distance to the object it hit.\nfloat raymarch( in vec3 ro, in vec3 rd, in float maxd )\n{\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( h<0.001 ) break;\n        t += h;\n        if( t>maxd ) break;\n    }\n    return t;\n}\n\n// This is the function that actually does the raymarching.\n// It basically takes a ray and march it along the ray until it hits something.\n// It also returns the distance to the object it hit.\nfloat raymarch( in vec3 ro, in vec3 rd, in float maxd, in float precis )\n{\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n   ", "\n\n    float balloonRadius = 0.05;\n    float balloonHeight = 0.1;\n\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n\n    vec3 balloonToCurrentRayPosition = currentRayPosition - balloonPosition;\n\n    float balloonToCurrentRayPositionLength = length(balloonToCurrentRayPosition);\n\n    float balloonToCurrentRayPositionLengthSquared = balloonToCurrentRayPositionLength * balloonToCurrentRayPositionLength;\n\n    float balloonToCurrentRayPositionLengthSquaredMinusBalloonRadiusSquared = balloonToCurrentRayPositionLengthSquared - (balloonRadius * balloonRadius);\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeight = balloonToCurrentRayPositionLength - balloonHeight;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquared = balloonToCurrentRayPositionLengthMinusBalloonHeight * balloonToCurrentRayPositionLengthMinusBalloonHeight;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquared - (balloonRadius * balloonRadius);\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared * balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquaredSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquared * balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusS", "\n    float distance1 = distance( thing1, mousePosition );\n    float distance2 = distance( thing2, mousePosition );\n    if( distance1 < distance2 ){\n        return thing1;\n    }else{\n        return thing2;\n    }\n}\n\n// 'WHICH THING AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nfloat whichThingAmICloserTo( float thing1, float thing2 ){\n    if( thing1 < thing2 ){\n        return thing1;\n    }else{\n        return thing2;\n    }\n}\n\n// 'WHICH THING AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nvec3 whichThingAmICloserTo( vec3 thing1, vec3 thing2 ){\n    float distance1 = distance( thing1, mousePosition );\n    float distance2 = distance( thing2, mousePosition );\n    if( distance1 < distance2 ){\n        return thing1;\n    }else{\n        return thing2;\n    }\n}\n\n// 'WHICH THING AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nvec4 whichThingAmICloserTo( vec4 thing1, vec4 thing2 ){\n    float distance1 = distance( thing1, mousePosition );\n    float distance2 = distance( thing2, mousePosition );\n    if( distance1 < distance2 ){\n        return thing1;\n    }else{\n        return thing2;\n    }\n}\n\n// 'WHICH THING AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nvec2 whichThingAmICloserTo( vec", "\n\n    // The distance to the closest object in the world\n    float closestDistance = INFINITY;\n\n    // The index of the closest object in the world\n    int closestObjectIndex = -1;\n\n    // Loop through all the objects in the world\n    for( int i = 0; i < NUM_OBJECTS; i++ ){\n\n        // Get the distance to the current object\n        float distanceToObject = distanceToObject( currentRayPosition, objects[i] );\n\n        // If the distance to the current object is less than the closest distance\n        if( distanceToObject < closestDistance ){\n\n            // Set the closest distance to the distance to the current object\n            closestDistance = distanceToObject;\n\n            // Set the closest object index to the current object index\n            closestObjectIndex = i;\n        }\n    }\n\n    // Return the closest distance and closest object index\n    return vec2( closestDistance, float(closestObjectIndex) );\n}\n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition, vec3 currentRayDirection ){\n\n    // The distance to the closest object in the world\n    float closestDistance = INFINITY;\n\n    // The index of the closest object in the world\n    int closestObjectIndex = -1;\n\n    // Loop through all the objects in the world\n    for( int i = 0; i < NUM_OBJECTS; i++ ){\n\n        // Get the distance to the current object\n        float distanceToObject = distanceToObject( currentRayPosition, objects[i], currentRayDirection );\n\n        // If the distance to the current object is less than the closest distance\n        if( distanceToObject < closestDistance ){\n\n            // Set the closest distance to the distance to the current object\n            closestDistance = distanceToObject;\n\n            // Set the closest object index to the current object index\n            closestObjectIndex = i;\n        }\n    }\n\n    // Return the closest distance and closest object index\n    return vec2(", "\n\n    // We are going to use the gradient of the SDF to figure out\n    // the normal of the surface.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of the fastest increase of the SDF.\n    // The gradient is the direction of", "\n    return vec3(0.0);\n}\n\n// this is the function that does the actual\n// raymarching. it returns the distance to the\n// nearest object, and also sets the color\n// of the fragment.\nfloat doRaymarch(inout vec3 color){\n    // start at the camera\n    vec3 pos = camPos;\n    // start at the origin\n    vec3 dir = normalize(vec3(uv, 1.0));\n    // start at the distance of 0\n    float dist = 0.0;\n    // start at the distance of 0\n    float totalDist = 0.0;\n    // start at the distance of 0\n    float lastDist = 0.0;\n    // start at the distance of 0\n    float lastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastLastLastLastLastLastDist = 0.0;\n    // start at the distance of 0\n    float lastLastLastLastLastLastLastLastLastLast", "\n    return vec3(0.5,0.5,0.5) + 0.5*normalOfSurface;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n//\n// We also use the position of the hit, to make the\n// color change over time.\nvec3 doBoxColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return vec3(0.5,0.5,0.5) + 0.5*normalOfSurface + 0.5*sin(positionOfHit.x+positionOfHit.y+positionOfHit.z);\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n//\n// We also use the position of the hit, to make the\n// color change over time.\n//\n// We also use the distance of the hit, to make the\n// color change over time.\nvec3 doBoxColor(vec3 positionOfHit, vec3 normalOfSurface, float distanceOfHit ){\n    return vec3(0.5,0.5,0.5) + 0.5*normalOfSurface + 0.5*sin(positionOfHit.x+positionOfHit.y+positionOfHit.z+distanceOfHit);\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n//\n// We also use the position of the hit, to make the\n// color change over time.\n//\n// We also use the distance of the hit, to make the\n// color change over time.\n//\n// We also use the uv coordinates of the hit, to make the\n// color change over time.\nvec3 doBoxColor(vec3 positionOfHit, vec3 normalOfSurface, float distanceOfHit, vec2 uvOfHit ){\n    return vec3(0.5,0.5,0.5) + 0.5*normalOfSurface + 0.5*sin(positionOfHit.x+", "\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition", "\n    return x / (x * b + (1.0 - b));\n}\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat gain(float x, float b) {\n    return x / (1.0 - (1.0 - x) * (1.0 - b));\n}\n\n// https://www.desmos.com/calculator/qzqzqzqzqz\nfloat smoothstep(float x) {\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// https://www.desmos.com/calculator/qzqzqzqzqz\nfloat smootherstep(float x) {\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n// https://www.desmos.com/calculator/qzqzqzqzqz\nfloat smootheststep(float x) {\n    return x * x * x * x * (x * (x * 15.0 - 45.0) + 60.0);\n}\n\n// https://www.desmos.com/calculator/qzqzqzqzqz\nfloat smootheststep2(float x) {\n    return x * x * x * x * x * (x * (x * 20.0 - 60.0) + 60.0);\n}\n\n// https://www.desmos.com/calculator/qzqzqzqzqz\nfloat smootheststep3(float x) {\n    return x * x * x * x * x * x * (x * (x * 25.0 - 70.0) + 60.", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates a smooth noise in the range 0..1 including 0 excluding 1\nfloat randSmooth(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 cubic = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\n// creates a smooth noise in the range 0..1 including 0 excluding 1\nfloat randSmooth(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    float a = rand(i.xy);\n    float b = rand(i.xy + vec2(1.0, 0.0));\n    float c = rand(i.xy + vec2(0.0, 1.0));\n    float d = rand(i.xy + vec2(1.0, 1.0));\n\n    float e = rand(i.xz);\n    float f = rand(i.xz + vec2(1.0, 0.0));\n    float g = rand(i.xz + vec2(0.0, 1.0));\n    float h = rand(i.xz + vec2(1.0, 1.0));\n\n    float i = rand(i.zy);\n    float j = rand(i.", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range -1..1\nfloat rand_centered(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1\nfloat rand_inclusive(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// creates white noise in the range -1..1\nfloat rand_centered(float p){\n    return fract(sin(p) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1\nfloat rand_inclusive(float p, float seed){\n    return fract(sin(p + seed) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(float p, float seed){\n    return fract(sin(p + seed) * 43758.5453);\n}\n\n// creates white noise in the range -1..1\nfloat rand_centered(float p, float seed){\n    return fract(sin(p + seed", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to size of box\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input r1 --> is torus radius\n// input r2 --> is torus tube radius\n// pretty simple, just compare point to radius of torus\nfloat sdTorus(vec3 p, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    return length(q) - r2;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to radius of cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r1 --> is cone radius at base\n// input r2 --> is cone radius at apex\n// input h --> is cone height\n// pretty simple, just compare point to radius of cone\nfloat sdCone(vec3 p, float r1, float r2, float h)\n{\n    float q = length(p.xy);\n    return max(length(p.xy) * (r2 / r1) - h, q * (r1 / h) - r2);\n}\n\n// ~~~~~~~ signed fistance fuction for plane\n// input n --> is plane normal\n// input", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z = box depth\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input r --> sphere radius\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\nfloat sdCylinder(vec3 p, vec2 c)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - c;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input c --> cone specs where:\n// \tc.x = cone radius at base\n//\tc.y = cone radius at apex\n//\tc.z = cone height\nfloat sdCone(vec3 p, vec3 c)\n{\n\tfloat q = length(p.xy);\n\treturn dot(c.xy, vec2(q, p.z));\n}\n\n// ~~~~~~~ signed distance function for a torus knot\n// input t --> torus knot specs where:\n// \tt.x = torus knot thickness\n//\tt.y = torus knot p\n//\tt.z = torus knot q\nfloat sdTorusKnot(vec3 p, vec3 t)\n{\n\tfloat c = length(p.xz);", "\n    float k = 0.1;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float h)\n{\n    h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float h, float m)\n{\n    h = clamp( 0.5 + 0.5", "\n    float k = sin(u_time*0.5);\n    return normalize(d1*k+d2*(1.0-k));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float k = sin(u_time*0.5);\n    return normalize(d1*k+d2*(1.0-k));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float k = sin(u_time*0.5);\n    return normalize(d1*k+d2*(1.0-k));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float k = sin(u_time*0.5);\n    return normalize(d1*k+d2*(1.0-k));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float k = sin(u_time*0.5);\n    return normalize(d1*k+d2*(1.0-k));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d", "\n    float  c = cos(t*p.y);\n    float  s = sin(t*p.y);\n    mat2   m = mat2(c,-s,s,c);\n    vec3   q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch )\n{\n    float  c = cos(t*p.y);\n    float  s = sin(t*p.y);\n    mat2   m = mat2(c,-s,s,c);\n    vec3   q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch, float roll )\n{\n    float  c = cos(t*p.y);\n    float  s = sin(t*p.y);\n    mat2   m = mat2(c,-s,s,c);\n    vec3   q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch, float roll, float yaw2 )\n{\n    float  c = cos(t*p.y);\n", "\n    return (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\n    return (o1.x > o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n    return (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opN(vec2 o1, vec2 o2)\n{\n    return (o1.x > -o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opD(vec2 o1, vec2 o2)\n{\n    return (o1.x > o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opM(vec2 o1, vec2 o2)\n{\n    return (o1.x < -o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do", "\n    // ~~~~~~~ sphere\n    // sphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    // return vec2(length(p) - 1.0, 1.0);\n\n    // ~~~~~~~ plane\n    // return vec2(p.y, 2.0);\n\n    // ~~~~~~~ box\n    // return vec2(length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.1, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length(vec2(length(p.xz) - 2.0, p.y)) - 0.5, 1.0);\n\n    // ~~~~~~~ torus\n    // return vec2(length", "\n\tfloat tmin = 1000.0;\n\tfloat tmax = 2000.0;\n\t\n\tfloat t = tmin;\n\t\n\tfor (int i = 0; i < NUM_OBJECTS; i++)\n\t{\n\t\tfloat d = objects[i].sdf(ro);\n\t\tif (d < t)\n\t\t{\n\t\t\tt = d;\n\t\t\thitID = i;\n\t\t}\n\t}\n\t\n\treturn vec2(t, hitID);\n}\n\n// ~~~~~~~ get normal of the object at the hit point\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input t --> distance travelled by ray\n// output is normal of the object at the hit point\n//\nvec3 getNormal(vec3 ro, vec3 rd, float t)\n{\n\tvec2 e = vec2(0.001, 0.0);\n\t\n\tvec3 n = vec3(0.0);\n\tn.x = objects[hitID].sdf(ro + e.xyy) - objects[hitID].sdf(ro - e.xyy);\n\tn.y = objects[hitID].sdf(ro + e.yxy) - objects[hitID].sdf(ro - e.yxy);\n\tn.z = objects[hitID].sdf(ro + e.yyx) - objects[hitID].sdf(ro - e.yyx);\n\t\n\treturn normalize(n);\n}\n\n// ~~~~~~~ get color of the object at the hit point\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input t --> distance travelled by ray\n// output is color of the object at the hit point\n//\nvec3 getColor(vec3 ro, vec3 rd, float t)\n{\n\tvec3 n = getNormal(ro, rd, t);\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tcolor = objects[hitID].color;\n\t\n\treturn color;\n}\n\n// ~~~~~~~ get the color of", "\n    // raymarching\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < EPS)\n        {\n            break;\n        }\n        t += d;\n    }\n\n    // if raymarching didn't hit anything\n    if (d > EPS)\n    {\n        return vec3(0.0);\n    }\n\n    // if raymarching hit something\n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n    vec3 c = vec3(0.0);\n\n    // if raymarching hit a sphere\n    if (d < EPS)\n    {\n        c = vec3(1.0, 0.0, 0.0);\n    }\n    // if raymarching hit a plane\n    else if (d < EPS)\n    {\n        c = vec3(0.0, 1.0, 0.0);\n    }\n    // if raymarching hit a cube\n    else if (d < EPS)\n    {\n        c = vec3(0.0, 0.0, 1.0);\n    }\n\n    return c;\n}\n\n// ~~~~~~~ main --> render the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0, -iResolution.x));\n\n    // render\n    vec3 c = render(ro, rd);\n\n    // output\n    fragColor = vec4(c, 1.0);\n}", "\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camRight = normalize( cross(camDir, vec3(0.0, 1.0, 0.0)) );\n    vec3 camUp = normalize( cross(camRight, camDir) );\n\n    mat3 camMatrix = mat3( camRight, camUp, camDir );\n\n    return camMatrix;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 camUp, float roll )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camRight = normalize( cross(camDir, camUp) );\n    vec3 camUp2 = normalize( cross(camRight, camDir) );\n\n    mat3 camMatrix = mat3( camRight, camUp2, camDir );\n\n    return camMatrix;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 camUp, in vec3 camRight, float roll )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camUp2 = normalize( cross(camRight, camDir) );\n\n    mat3 camMatrix = mat3( camRight, camUp2, camDir );\n\n    return camMatrix;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos,", "\n    if(id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if(id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if(id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if(id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if(id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if(id == 7.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if(id == 8.0)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if(id == 9.0)\n    {\n        return vec3(0.75, 0.75, 0.75);\n    }\n    else if(id == 10.0)\n    {\n        return vec3(0.25, 0.25, 0.25);\n    }\n    else if(id == 11.0)\n    {\n        return vec3(0.5, 0.5, 0.0);\n    }\n    else if(id == 12.0)\n    {\n        return vec3(0.5, 0.0, 0.5);\n    }\n    else if(id == 13.", "\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus knot\n// input t --> torus knot specs where:\n//  t.x = torus knot thickness\n//  t.y = torus knot pinches\n//  t.z = torus knot radius\n//  t.w = torus knot pinches\n// \n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus knot radius\n// then simply subtract the torus knot thickness from that \nfloat sdTorusKnot(vec3 p, vec4 t)\n{\n    vec3 q = vec3(length(p.xz) - t.z, p.y, t.w - t.z);\n    return length(q) - t.x;\n}\n\n// ~~~~~~~ signed distance function for torus knot\n// input t --> torus knot specs where:\n//  t.x = torus knot thickness\n//  t.y = torus knot pinches\n//  t.z = torus knot radius\n//  t.w = torus knot pinches\n// \n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus knot radius\n// then simply subtract the torus knot thickness from that \nfloat sdTorusKnot(vec3 p, vec4 t)\n{\n    vec3 q = vec3(length(p.xz) - t.z, p.y, t.w - t.z);\n    return length(q) - t.x;\n}\n\n// ~~~~~~~ signed distance function for torus knot\n// input t --> torus knot specs where:\n//  t.x = torus knot thickness\n//  t.y = torus knot pinches\n//  t.z = torus knot radius\n//  t.w = torus knot pinches\n// \n// first flatten the y axis of p (by using p.", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\nfloat sdSphere(vec3 p)\n{\n    return length(p) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\nfloat sdBox(vec3 p)\n{\n    vec3 d = abs(p) - ps.xyz;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> major radius\n//        ps.y --> minor radius\nfloat sdTorus(vec3 p)\n{\n    return length(vec2(length(p.xz) - ps.x, p.y)) - ps.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> height\n//        ps.y --> radius\nfloat sdCylinder(vec3 p)\n{\n    return max(length(p.xz) - ps.y, abs(p.y) - ps.x);\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> height\n//        ps.y --> radius\nfloat sdCone(vec3 p)\n{\n    float q = length(p.xz);\n    return max(dot(p.xy,vec2(-0.57735027,0.57735027)),-p.y) - ps.y*ps.x/q;\n}\n\n// ~~~~~~~ signed distance function for rounded box\n//  input ps --> specs of rounded box\n//        ps.x --> size x\n//        ps.y --", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp(", "\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec4 c1 = o1.yzwx;\n    vec4 c2 = o2.yzwx;\n    vec4 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec4 c1 = o1.yzwx;\n    vec4 c2 = o2.yzwx;\n    vec4 c = mix(c1, c2, bf2);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2, float bf3)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec4 c1 = o1.yzwx;\n    vec4 c2 = o2.", "\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// ~~~~~~~ do shape intersection, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDifference(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape smooth union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape smooth intersection, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance ", "\n    // generate random number between 0 and 1\n    float rand1 = rand(gl_FragCoord.xy);\n    float rand2 = rand(gl_FragCoord.xy + vec2(1.0, 0.0));\n    float rand3 = rand(gl_FragCoord.xy + vec2(0.0, 1.0));\n\n    // generate random number between 0 and 1\n    float rand4 = rand(gl_FragCoord.xy + vec2(1.0, 1.0));\n    float rand5 = rand(gl_FragCoord.xy + vec2(1.0, 2.0));\n    float rand6 = rand(gl_FragCoord.xy + vec2(2.0, 1.0));\n\n    // generate random number between 0 and 1\n    float rand7 = rand(gl_FragCoord.xy + vec2(2.0, 2.0));\n    float rand8 = rand(gl_FragCoord.xy + vec2(2.0, 3.0));\n    float rand9 = rand(gl_FragCoord.xy + vec2(3.0, 2.0));\n\n    // generate random number between 0 and 1\n    float rand10 = rand(gl_FragCoord.xy + vec2(3.0, 3.0));\n    float rand11 = rand(gl_FragCoord.xy + vec2(3.0, 4.0));\n    float rand12 = rand(gl_FragCoord.xy + vec2(4.0, 3.0));\n\n    // generate random number between 0 and 1\n    float rand13 = rand(gl_FragCoord.xy + vec2(4.0, 4.0));\n    float rand14 = rand(gl_FragCoord.xy + vec2(4.0, 5.0));\n    float rand15 =", "\n    // ~~~~~~~ sphere\n    float sd = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    vec3 sColor = vec3(1.0, 0.0, 0.0);\n\n    // ~~~~~~~ plane\n    float pd = p.y;\n    vec3 pColor = vec3(0.0, 1.0, 0.0);\n\n    // ~~~~~~~ box\n    float bd = sdBox(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec3 bColor = vec3(0.0, 0.0, 1.0);\n\n    // ~~~~~~~ union\n    float ud = opUnion(sd, pd);\n    vec3 uColor = vec3(1.0, 1.0, 0.0);\n\n    // ~~~~~~~ intersection\n    float id = opIntersection(sd, pd);\n    vec3 iColor = vec3(1.0, 0.0, 1.0);\n\n    // ~~~~~~~ difference\n    float dd = opDifference(sd, pd);\n    vec3 dColor = vec3(0.0, 1.0, 1.0);\n\n    // ~~~~~~~ blend\n    float blend = smoothstep(0.0, 0.01, ud);\n    vec3 color = mix(sColor, uColor, blend);\n\n    return vec4(color, 1.0);\n}\n\n// ~~~~~~~ ray march\n// input p --> is ray position\n// input rd --> is ray direction\n// outputs distance to the closest object\nfloat rayMarch(vec3 p, vec3 rd)\n{\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 res = map(p);\n        float dS = res.x;\n       ", "\n    float tmin = 1000.0;\n    float tmax = 2000.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 res = map(ro + rd * t);\n        if (res.x < EPSILON)\n        {\n            m = res.y;\n            break;\n        }\n        t += res.x;\n        if (t > tmax)\n        {\n            break;\n        }\n    }\n\n    if (m == -1.0)\n    {\n        return vec4(t, m, itterRatio, 0.0);\n    }\n\n    vec3 n = calcNormal(ro + rd * t);\n    vec3 r = reflect(rd, n);\n    float f = calcFresnel(n, rd, r);\n    float fresnel = f * f;\n\n    vec3 l = vec3(0.0, 0.0, 1.0);\n    float diff = max(dot(n, l), 0.0);\n\n    vec3 h = normalize(l - rd);\n    float spec = pow(max(dot(h, n), 0.0), 16.0);\n\n    vec3 col = vec3(0.0);\n    if (m == 0.0)\n    {\n        col = vec3(0.8, 0.3, 0.3);\n    }\n    else if (m == 1.0)\n    {\n        col = vec3(0.3, 0.3, 0.8);\n    }\n    else if (m == 2.0)\n    {\n        col = vec3(0.8, 0.8, 0.3);\n    }\n    else if (m == 3.0)\n    {\n        col = vec3(0.3, 0.8, 0.3);\n    }\n    else if (m == 4.0)\n    {\n       ", "\n    vec3 rd = normalize(lp - sp);\n    float t = 0.001;\n    float res = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = map(sp + rd * t);\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 10.0 * h / t);\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow_2(vec3 sp, vec3 lp)\n{\n    vec3 rd = normalize(lp - sp);\n    float t = 0.001;\n    float res = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = map(sp + rd * t);\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 10.0 * h / t);\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftSh", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + sp;\n        float dd = map(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// ~~~~~~~ normal\n// get normal from distance field\nvec3 calcNormal(vec3 pos)\n{\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(pos+e.xyy) - map(pos-e.xyy),\n                          map(pos+e.yxy) - map(pos-e.yxy),\n                          map(pos+e.yyx) - map(pos-e.yyx)));\n}\n\n// ~~~~~~~ lighting\n// basic phong lighting\nvec3 calcLight(vec3 pos, vec3 nor)\n{\n    vec3 lightPos = vec3(0.0, 10.0, 10.0);\n    vec3 lightCol = vec3(1.0, 1.0, 1.0);\n    vec3 lightDir = normalize(lightPos - pos);\n    float amb = clamp(0.5+0.5*nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lightDir), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(0.0, -1.0, 0.0))), 0.0, 1.0)*clamp(1.0-pos.y, 0.0, 1.0);\n    float spe = pow(clamp(dot(reflect(-lightDir, nor), normalize(-pos)), ", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float w = 0.0;\n    float wSum = 0.0;\n    float dSum = 0.0;\n    float dMax = 0.0;\n    float dMin = 1000000.0;\n    float dMinSum = 0.0;\n    float dMaxSum = 0.0;\n    float dMinMaxSum = 0.0;\n    float dMinMaxSum2 = 0.0;\n    float dMinMaxSum3 = 0.0;\n    float dMinMaxSum4 = 0.0;\n    float dMinMaxSum5 = 0.0;\n    float dMinMaxSum6 = 0.0;\n    float dMinMaxSum7 = 0.0;\n    float dMinMaxSum8 = 0.0;\n    float dMinMaxSum9 = 0.0;\n    float dMinMaxSum10 = 0.0;\n    float dMinMaxSum11 = 0.0;\n    float dMinMaxSum12 = 0.0;\n    float dMinMaxSum13 = 0.0;\n    float dMinMaxSum14 = 0.0;\n    float dMinMaxSum15 = 0.0;\n    float dMinMaxSum16 = 0.0;\n    float dMinMaxSum17 = 0.0;\n    float dMinMaxSum18 = 0.0;\n    float dMinMaxSum19 = 0.0;\n    float dMinMaxSum20 = 0.0;\n    float dMinMaxSum21 = 0.0;\n    float dMinMaxSum22 = 0.0;\n    float dMinMaxSum23 = 0.0;\n    float dMinMaxSum24 = 0.0;\n    float dMinMaxSum25 = 0.0;\n    float dMinMaxSum26 = 0.0;\n    float dMinMaxSum27 = 0.0;\n    float dMinMaxSum28 = 0.0;\n    float dMinMaxSum29 = 0.0;\n    float dMinMaxSum30 = 0.0;\n", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n   ", "\n    float f = clamp(1.0 - exp(-fs.x*d),0.0,1.0);\n    vec3  l = normalize(lRD);\n    float ld = max(0.0,dot(l,cRD));\n    float lf = clamp(1.0 - exp(-fs.x*ld),0.0,1.0);\n    float lc = mix(lf,1.0,fs.y);\n    return mix(mix(c,fc1,f),fc2,lc);\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float f = clamp(1.0 - exp(-fs.x*d),0.0,1.0);\n    vec3  l = normalize(lRD);\n    float ld = max(0.0,dot(l,cRD));\n    float lf = clamp(1.0 - exp(-fs.x*ld),0.0,1.0);\n    float lc = mix(lf,1.0,fs.y);\n    return mix(mix(c,fc1,f),fc2,lc);\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.ht", "\n    return 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d0)\n{\n    return 1.0 / (cF + lF * (d - d0) + qF * (d - d0) * (d - d0));\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d0, float d1)\n{\n    return 1.0 / (cF + lF * (d - d0) + qF * (d - d0) * (d - d1));\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d0, float d1, float d2)\n{\n    return 1.0 / (cF + lF * (d - d0) + qF * (d -", "\n    vec3 rayDir = vec3(fCoord, 1.0);\n    rayDir = cMatrix * rayDir;\n    return normalize(rayDir);\n}\n\n// ~~~~~~~ calculate the intersection of the ray and the sphere\n// input rayDir --> ray direction\n// input spherePos --> sphere position\n// input sphereRadius --> sphere radius\n// output --> intersection point\nvec3 calculateIntersection(vec3 rayDir, vec3 spherePos, float sphereRadius)\n{\n    float b = dot(rayDir, spherePos);\n    float c = dot(spherePos, spherePos) - sphereRadius * sphereRadius;\n    float delta = b * b - c;\n    if (delta < 0.0)\n    {\n        return vec3(0.0);\n    }\n    float t = -b - sqrt(delta);\n    if (t < 0.0)\n    {\n        t = 0.0;\n    }\n    return rayDir * t;\n}\n\n// ~~~~~~~ calculate the normal of the sphere at the intersection point\n// input intersection --> intersection point\n// input spherePos --> sphere position\n// output --> normal\nvec3 calculateNormal(vec3 intersection, vec3 spherePos)\n{\n    return normalize(intersection - spherePos);\n}\n\n// ~~~~~~~ calculate the color of the sphere at the intersection point\n// input normal --> normal\n// input sphereColor --> sphere color\n// output --> color\nvec3 calculateColor(vec3 normal, vec3 sphereColor)\n{\n    return sphereColor * dot(normal, vec3(0.0, 0.0, 1.0));\n}\n\n// ~~~~~~~ calculate the color of the sphere at the intersection point\n// input normal --> normal\n// input sphereColor --> sphere color\n// output --> color\nvec3 calculateColor(vec3 normal, vec3 sphereColor)\n{\n    return sphereColor * dot(normal, vec3(0.0, 0.0, 1.0));\n}\n\n// ~~~~~~~ calculate the color of the sphere at the intersection point\n// input normal --> normal\n// input sphereColor -->", "\n    // ~~~~~~~ get pixel's march count\n    float marchCount = march(cPos,cMat,fCoord);\n\n    // ~~~~~~~ get pixel's color\n    vec3 color = getColor(marchCount);\n\n    // ~~~~~~~ get pixel's antialiased color\n    color = antialias(color,marchCount);\n\n    return color;\n}\n\n// ~~~~~~~ render normal, based on pixel's itteration/march count\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec3 render_N(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    // ~~~~~~~ get pixel's march count\n    float marchCount = march(cPos,cMat,fCoord);\n\n    // ~~~~~~~ get pixel's color\n    vec3 color = getColor(marchCount);\n\n    return color;\n}\n\n// ~~~~~~~ render normal, based on pixel's itteration/march count\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec3 render_N_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    // ~~~~~~~ get pixel's march count\n    float marchCount = march(cPos,cMat,fCoord);\n\n    // ~~~~~~~ get pixel's color\n    vec3 color = getColor(marchCount);\n\n    // ~~~~~~~ get pixel's antialiased color\n    color = antialias(color,marchCount);\n\n    return color;\n}\n\n// ~~~~~~~ render normal, based on pixel's itteration/march count\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec3 render_N_AA_S(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n   ", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Iterate through the Mandelbrot set\n    float x = -1.0 + 2.0 * uv.x;\n    float y = -1.0 + 2.0 * uv.y;\n    float x0 = x;\n    float y0 = y;\n    float x1 = x;\n    float y1 = y;\n    float x2 = x;\n    float y2 = y;\n    float x3 = x;\n    float y3 = y;\n    float x4 = x;\n    float y4 = y;\n    float x5 = x;\n    float y5 = y;\n    float x6 = x;\n    float y6 = y;\n    float x7 = x;\n    float y7 = y;\n    float x8 = x;\n    float y8 = y;\n    float x9 = x;\n    float y9 = y;\n    float x10 = x;\n    float y10 = y;\n    float x11 = x;\n    float y11 = y;\n    float x12 = x;\n    float y12 = y;\n    float x13 = x;\n    float y13 = y;\n    float x14 = x;\n    float y14 = y;\n    float x15 = x;\n    float y15 = y;\n    float x16 = x;\n    float y16 = y;\n    float x17 = x;\n    float y17 = y;\n    float x18 = x;\n    float y18 = y;\n    float x19 = x;\n    float y19 = y;\n    float x20 = x;\n    float y20 = y;\n    float x21 = x;\n    float y21 = y;\n    float x22 = x;\n    float y22 = y;\n    float x23 = x;\n   ", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 radius)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - radius;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float radius)\n{\n    return length(p.xz) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float radius, float thickness)\n{\n    return length(p.xz) - radius - thickness;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float radius, float thickness, float thickness2)\n{\n    return length(p.xz) - radius - thickness - thickness2;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float radius, float thickness, float thickness2, float thickness3)\n{\n    return length(p.xz) - radius - thickness - thickness2 - thickness3;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float radius, float thickness, float thickness2, float thickness3, float thickness4)\n{\n    return length(p.xz) - radius - thickness - thickness2 - thickness3 - thickness4;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float radius,", "\n    return length(p) - r;\n}\n\n// simple cone distance field\nfloat cone(vec2 p, float r1, float r2)\n{\n    float q = length(p);\n    return max(q*q + r1*r1 - r2*r2, q - r1);\n}\n\n// simple torus distance field\nfloat torus(vec2 p, float r1, float r2)\n{\n    vec2 q = vec2(length(p.x), p.y);\n    return length(q) - r1 + r2;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec4 p, vec4 b, float r)\n{\n    vec4 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, max(q.z, q.w))), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, vec2 r)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q", "\n    // The distance to the nearest surface\n    float d = -1.0;\n\n    // The material number\n    int material = 0;\n\n    // The distance to the nearest surface\n    float d1 = Sphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    float d2 = Sphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n\n    // The material number\n    int material1 = 1;\n    int material2 = 2;\n\n    // The distance to the nearest surface\n    float d3 = Box(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n    // The material number\n    int material3 = 3;\n\n    // The distance to the nearest surface\n    float d4 = Plane(p, vec3(0.0, 1.0, 0.0), 0.0);\n\n    // The material number\n    int material4 = 4;\n\n    // The distance to the nearest surface\n    float d5 = Cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.5);\n\n    // The material number\n    int material5 = 5;\n\n    // The distance to the nearest surface\n    float d6 = Cone(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.5);\n\n    // The material number\n    int material6 = 6;\n\n    // The distance to the nearest surface\n    float d7 = Torus(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.5, 0.1);\n\n    // The material number\n    int material7 = 7;\n\n    // The distance to the nearest surface\n", "\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r5 = pow(r, 5.0);\n    float theta5 = theta * 5.0;\n    float x = r5 * cos(theta5);\n    float y = r5 * sin(theta5);\n    return vec2(x, y);\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower6(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r6 = pow(r, 6.0);\n    float theta6 = theta * 6.0;\n    float x = r6 * cos(theta6);\n    float y = r6 * sin(theta6);\n    return vec2(x, y);\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r7 = pow(r, 7.0);\n    float theta7 = theta * 7.0;\n    float x = r7 * cos(theta7);\n    float y = r7 * sin(theta7);\n    return vec2(x, y);\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r8 = pow(r, 8.0);\n    float theta8 = theta * 8.0;\n    float x = r8 * cos(theta8);\n    float y = r8 * sin(theta8);\n    return vec2(x, y);\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.", "\n    vec2 pos = coord;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n    float f = fract(a / 3.1415926535897932384626433832795);\n    float g = fract(a / 3.1415926535897932384626433832795 + 0.5);\n    float b = fract(a / 3.1415926535897932384626433832795 + 1.0);\n    float c = fract(a / 3.1415926535897932384626433832795 + 1.5);\n    float d = fract(a / 3.1415926535897932384626433832795 + 2.0);\n    float e = fract(a / 3.1415926535897932384626433832795 + 2.5);\n    float f2 = fract(a / 3.1415926535897932384626433832795 + 3.0);\n    float g2 = fract(a / 3.1415926535897932384626433832795 + 3.5);\n    float h = fract(a / 3.1415926535897932384626433832795 + 4.0);\n    float i = fract(a / 3.1415926535897932384626433832795 + 4.5);", "\n\tvec2 uv2 = uv * 2.0;\n\tvec2 uv3 = uv * 3.0;\n\tvec2 uv4 = uv * 4.0;\n\tvec2 uv5 = uv * 5.0;\n\tvec2 uv6 = uv * 6.0;\n\tvec2 uv7 = uv * 7.0;\n\tvec2 uv8 = uv * 8.0;\n\tvec2 uv9 = uv * 9.0;\n\tvec2 uv10 = uv * 10.0;\n\tvec2 uv11 = uv * 11.0;\n\tvec2 uv12 = uv * 12.0;\n\tvec2 uv13 = uv * 13.0;\n\tvec2 uv14 = uv * 14.0;\n\tvec2 uv15 = uv * 15.0;\n\tvec2 uv16 = uv * 16.0;\n\tvec2 uv17 = uv * 17.0;\n\tvec2 uv18 = uv * 18.0;\n\tvec2 uv19 = uv * 19.0;\n\tvec2 uv20 = uv * 20.0;\n\tvec2 uv21 = uv * 21.0;\n\tvec2 uv22 = uv * 22.0;\n\tvec2 uv23 = uv * 23.0;\n\tvec2 uv24 = uv * 24.0;\n\tvec2 uv25 = uv * 25.0;\n\tvec2 uv26 = uv * 26.0;\n\tvec2 uv27 = uv * 27.0;\n\tvec2 uv28 = uv * 28.0;\n\tvec2 uv29 = uv * 29.0;\n\tvec2 uv30 = uv * 30.0;\n\tvec2 uv", "\n    return fract(x);\n}\n\nfloat repeat(float x, float period) {\n    return repeat(x / period) * period;\n}\n\nfloat repeat(float x, float period, float offset) {\n    return repeat(x - offset, period) + offset;\n}\n\nfloat triangle(float x) {\n    return abs(repeat(x, 2.0) - 1.0);\n}\n\nfloat triangle(float x, float period) {\n    return triangle(x / period) * period;\n}\n\nfloat triangle(float x, float period, float offset) {\n    return triangle(x - offset, period) + offset;\n}\n\nfloat triangle(float x, float period, float offset, float phase) {\n    return triangle(x - offset, period, phase) + offset;\n}\n\nfloat triangle(float x, float period, float offset, float phase, float scale) {\n    return triangle(x - offset, period, phase) * scale + offset;\n}\n\nfloat triangle(float x, float period, float offset, float phase, float scale, float bias) {\n    return triangle(x - offset, period, phase) * scale + offset + bias;\n}\n\nfloat triangle(float x, float period, float offset, float phase, float scale, float bias, float biasScale) {\n    return triangle(x - offset, period, phase) * scale + offset + bias * biasScale;\n}\n\nfloat triangle(float x, float period, float offset, float phase, float scale, float bias, float biasScale, float biasOffset) {\n    return triangle(x - offset, period, phase) * scale + offset + bias * biasScale + biasOffset;\n}\n\nfloat triangle(float x, float period, float offset, float phase, float scale, float bias, float biasScale, float biasOffset, float biasScale2) {\n    return triangle(x - offset, period, phase) * scale + offset + bias * biasScale + biasOffset + biasScale2;\n}\n\nfloat triangle(float x, float period, float offset, float phase, float scale, float bias, float biasScale, float biasOffset, float biasScale2, float biasOffset2) {\n    return triangle(x - offset, period,", "\n    vec2 dir = pB - pA;\n    vec2 dirN = normalize(dir);\n    vec2 dirP = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90 = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P90 = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90N90 = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P90N90 = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N90P90N90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N90P90N90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90N90P90N90 =", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float thickness = thick.x * 0.5;\n    float halfThickness = thickness * 0.5;\n    float halfThicknessSq = halfThickness * halfThickness;\n    float halfThicknessSqRounded = halfThicknessSq - rounded;\n    float halfThicknessSqRoundedSq = halfThicknessSqRounded * halfThicknessSqRounded;\n    float halfThicknessSqRoundedSqRoot = sqrt(halfThicknessSqRoundedSq);\n    float halfThicknessSqRoundedSqRootSq = halfThicknessSqRoundedSqRoot * halfThicknessSqRoundedSqRoot;\n    float halfThicknessSqRoundedSqRootSqRoot = sqrt(halfThicknessSqRoundedSqRootSq);\n    float halfThicknessSqRoundedSqRootSqRootSq = halfThicknessSqRoundedSqRootSq * halfThicknessSqRoundedSqRootSq;\n    float halfThicknessSqRoundedSqRootSqRootSqRoot = sqrt(halfThicknessSqRoundedSqRootSqRootSq);\n    float halfThicknessSqRoundedSqRootSqRootSqRootSq = halfThicknessSqRoundedSqRootSqRootSqRootSq * halfThicknessSqRoundedSqRootSqRootSqRootSq;\n    float halfThicknessSqRoundedSqRootSqRootSqRootSqRoot = sqrt(halfThicknessSqRoundedSqRootSqRootSqRootSqRootSq);\n    float halfThicknessSqRoundedSqRootSqRootSqRootSqRootSq = halfThicknessSqRoundedSqRootSqRootSqRootSqRootSqRootSq * halfThicknessSqRoundedSqRootSqRootSqRootSqRootSq", "\n    float line = Line(uv, pA, pB, thick, rounded);\n    float outline = Line(uv, pA, pB, thick + outlineThick, rounded);\n    return outline - line;\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n    return DrawOutlinePix(uv, pA, pB, vec2(thick, thick), rounded, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float outlineThick) {\n    return DrawOutlinePix(uv, pA, pB, vec2(thick, thick), 0.0, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float outlineThick) {\n    return DrawOutlinePix(uv, pA, pB, 1.0, 0.0, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB) {\n    return DrawOutlinePix(uv, pA, pB, 1.0, 0.0, 1.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n    return DrawOutlinePix(uv, pA, pB, thick, 0.0, 1.0);\n}\n\n// This makes", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float thickness = thick.x + thick.y * (uv.x - pA.x) / (pB.x - pA.x);\n    float halfThickness = thickness * 0.5;\n    float d = abs(dot(dir, uv - pA)) - halfThickness;\n    float result = clamp(d + halfThickness - rounded, 0.0, 1.0);\n    result *= step(0.0, len - thickness);\n    return result;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    return FillLine(uv, pA, pB, vec2(thick, 0.0), rounded);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    return FillLine(uv, pA, pB, vec2(thick, 0.0), 0.0);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB) {\n    return FillLine(uv, pA, pB, vec2(1.0, 0.0), 0.0);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n    return FillLine(uv, pA, pB, thick, 0.0);\n}\n\n// This makes a line in UV", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    vec2 p = uv - pA;\n    float d = dot(p, dir);\n    float d2 = d - thick.x;\n    float d3 = d + thick.y;\n    float d4 = len - d;\n    float d5 = len - d2;\n    float d6 = len - d3;\n    float d7 = len - d4;\n    float d8 = len - d5;\n    float d9 = len - d6;\n    float d10 = len - d7;\n    float d11 = len - d8;\n    float d12 = len - d9;\n    float d13 = len - d10;\n    float d14 = len - d11;\n    float d15 = len - d12;\n    float d16 = len - d13;\n    float d17 = len - d14;\n    float d18 = len - d15;\n    float d19 = len - d16;\n    float d20 = len - d17;\n    float d21 = len - d18;\n    float d22 = len - d19;\n    float d23 = len - d20;\n    float d24 = len - d21;\n    float d25 = len - d22;\n    float d26 = len - d23;\n    float d27 = len - d24;\n    float d28 = len - d25;\n    float d29 = len - d26;\n    float d30 = len - d27;\n    float d31 = len - d28;\n    float d32 = len - d29;\n    float d33 = len - d30;\n    float d34 = len - d31;\n    float d35 = len - d32;\n    float d36 = len - d33;\n    float d37 = len - d34;\n    float d38 = len -", "\n    vec2 pa = pA - uv;\n    vec2 ba = pB - pA;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h);\n    float r = length(ba) * 0.5;\n    float a = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float b = (1.0 - h) * acos((r - d) / r) / (2.0 * PI);\n    float c = (1.0 - h) * acos((r - d) / r) / (2.0 * PI);\n    float d = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float e = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float f = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float g = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float h = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float i = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float j = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float k = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float l = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float m = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float n = (1.0 - h) * acos(d / r) / (2.0 * PI);\n    float o = (1.0 - h) * acos", "\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, vec3 color) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, vec3 color, float alpha) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, vec3 color, float alpha, float time) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, vec3 color, float alpha, float time, float speed) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col, float size, vec3 color, float alpha, float time, float speed, float intensity) {\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.", "\n    float t = dot( cen - ro, nor );\n    if( t < 0.0 ) return -1.0;\n    float b = dot( rd, nor );\n    if( b > 0.0 ) return -1.0;\n    float d = sqrt( rad*rad - t*t );\n    if( d < 0.0 ) return -1.0;\n    return t - d;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    float t = dot( p.xyz, p.xyz ) / dot( rd, p.xyz );\n    if( t < 0.0 ) return -1.0;\n    return t;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 s )\n{\n    vec3 oc = ro - s.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - s.w*s.w;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = -b - h;\n    if( t < 0.0 ) return -1.0;\n    return t;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 box )\n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * box;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return -1.0;\n    return tN;\n", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t1 = max( max( k.x, k.y ), k.z );\n    float t2 = min( min( k.x, k.y ), k.z );\n    return vec2( max( t1, t2 ), min( t1, t2 ) );\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) \n{\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t1 = max( max( k.x, k.y ), k.z );\n    float t2 = min( min( k.x, k.y ), k.z );\n    return vec2( max( t1, t2 ), min( t1, t2 ) ) * (t1 > t2? 1.0 : -1.0);\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmin, in float tmax ) \n{\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t1 = max( max( k.x, k.y ), k.z );\n    float t2 = min( min( k.x, k.y ), k.z );\n    return vec2( max( t1, t2 ), min( t1, t2 ) ) * (t1 > t2? 1.0 : -1.0);\n}\n\n// ray-box intersection (simplified)\nvec2 i", "\n    vec3  ba = pb-pa;\n    float l2 = dot(ba,ba);\n    float r2 = ra*ra;\n    float h2 = l2 - r2;\n    float h  = sqrt(h2);\n    float r  = sqrt(r2);\n    float l  = sqrt(l2);\n    vec3  mc = (pa+pb)*0.5;\n    vec3  u  = ba*0.5/l;\n    vec3  v  = vec3(u.z,0.0,-u.x);\n    vec3  w  = vec3(u.y,-u.x,0.0);\n    vec3  p0 = mc - v*h - w*r;\n    vec3  p1 = mc + v*h - w*r;\n    vec3  p2 = mc + v*h + w*r;\n    vec3  p3 = mc - v*h + w*r;\n    return bound3( min(min(min(p0,p1),p2),p3), max(max(max(p0,p1),p2),p3) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 c, in float r )\n{\n    return bound3( c-r, c+r );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 pmin, in vec3 pmax )\n{\n    return bound3( pmin, pmax );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a torus\n//---------------------------------------------------------------------------------------\nbound3 TorusAABB( in vec3 c, in float ra, in float rb )\n{\n    return bound3( c-vec3(ra+rb,ra+rb,ra+rb), c+vec3(ra+rb,ra+rb,ra+rb) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone\n//---------------------------------------------------------------------------------------\nbound3 C", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*rdoa*rdoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        vec3  p = ro + t*rd;\n        vec3  n = (p-pa) - ba*dot(p-pa,ba)/baba;\n        return vec4( t, n );\n    }\n    return vec4( -1.0 );\n}\n\n// ray-cone intersection (returns t and normal)\nvec4 iCone( in vec3 ro, in vec3 rd, \n            in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*rdoa*rdoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        vec3  p = ro + t*rd;\n        vec3  n", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) + abs(n);\n    float s = max(k.x,max(k.y,k.z));\n    return vec2( -s*s + dot(m,m), s );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2( -1.0 );\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 p ) \n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// ray-triangle intersection\nfloat iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 n = cross( rd, e2 );\n    float d = dot( e1, n );\n    if( d<0.0 ) return 1e5;\n    vec3 s = ro - v0;\n    float u = dot( s, n ) / d;\n    if( u<0.0 || u>1.0 ) return 1e5;\n    vec3 q = cross( s, e1 );\n    float v = dot( rd, q ) / d;\n    if( v<0.0 || u+v>1.0", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        if( t>0.0 )\n        {\n            float y = baoa + t*bard;\n            if( y>0.0 && y<baba )\n                return t;\n        }\n        t = (-b + sqrt(h)) / a;\n        if( t>0.0 )\n        {\n            float y = baoa + t*bard;\n            if( y>0.0 && y<baba )\n                return t;\n        }\n    }\n    return 1e5;\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r, inout float t )\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float a = baba", "\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    if( dot( n, pos ) > r ) n = -n;\n    return n;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float r2 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    if( dot( n, pos ) > r ) n = -n;\n    if( dot( n, pos ) < r2 ) n = -n;\n    return n;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float r2, in float r3 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    if( dot( n, pos ) > r ) n = -n;\n    if( dot( n, pos ) < r2 ) n = -n;\n    if( dot( n, pos ) > r3 ) n = -n;\n    return n;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float r2, in float r3, in float r4 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    if( dot( n, pos ) > r ) n = -n;\n    if( dot( n, pos ) < r2 ) n = -n;\n    if( dot( n, pos ) > r3 ) n = -n;\n    if( dot( n, pos ) < r4 ) n = -n;\n    return n;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float r2, in float r3, in float r4, in float r5 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    if", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-pos);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos, in vec3 rot ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-pos);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in", "\n    float t = 0.0;\n    float d = 1.0;\n    float h = 1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(d)<.001 || t>100.0 ) break;\n        t += h;\n        vec3 p = ro + rd*t;\n        d = map(p);\n        h = d*0.5;\n    }\n    if( t>100.0 ) d=0.0;\n    return vec4( t, d, 0.0, 0.0 );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    float d = 1.0;\n    float h = 1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(d)<.001 || t>100.0 ) break;\n        t += h;\n        vec3 p = ro + rd*t;\n        d = map(p);\n        h = d*0.5;\n    }\n    if( t>100.0 ) d=0.0;\n    return vec4( t, d, 0.0, 0.0 );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    float d = 1.0;\n    float h = 1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(d)<.001 || t>100.0 ) break;\n        t += h;\n        vec3 p = ro + rd*t;\n        d = map(p);\n        h = d*0.5;\n    }\n    if( t>100.0 ) d=0.0;\n    return vec4( t, d, 0.0, ", "\n    float phi = (i + 1.0) * 3.1415926535897932384626433832795 / n;\n    float theta = acos(1.0 - 2.0 * mod(i, 2.0) / n);\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\nvec3 forwardSF( float i, float n, float r) \n{\n    float phi = (i + 1.0) * 3.1415926535897932384626433832795 / n;\n    float theta = acos(1.0 - 2.0 * mod(i, 2.0) / n);\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta)) * r;\n}\n\nvec3 forwardSF( float i, float n, float r, float s) \n{\n    float phi = (i + 1.0) * 3.1415926535897932384626433832795 / n;\n    float theta = acos(1.0 - 2.0 * mod(i, 2.0) / n);\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta)) * r * s;\n}\n\nvec3 forwardSF( float i, float n, float r, float s, float t) \n{\n    float phi = (i + 1.0) * 3.1415926535897932384626433832795 / n;\n    float theta = acos(1.0 - 2.0 * mod(i, 2.0) / n);\n    return vec3(cos(phi) * sin(theta), sin(phi) *", "\n    float t = 0.0;\n    float d = 0.0;\n    float h = 0.0;\n    float s = 0.0;\n    float s2 = 0.0;\n    float s3 = 0.0;\n    float s4 = 0.0;\n    float s5 = 0.0;\n    float s6 = 0.0;\n    float s7 = 0.0;\n    float s8 = 0.0;\n    float s9 = 0.0;\n    float s10 = 0.0;\n    float s11 = 0.0;\n    float s12 = 0.0;\n    float s13 = 0.0;\n    float s14 = 0.0;\n    float s15 = 0.0;\n    float s16 = 0.0;\n    float s17 = 0.0;\n    float s18 = 0.0;\n    float s19 = 0.0;\n    float s20 = 0.0;\n    float s21 = 0.0;\n    float s22 = 0.0;\n    float s23 = 0.0;\n    float s24 = 0.0;\n    float s25 = 0.0;\n    float s26 = 0.0;\n    float s27 = 0.0;\n    float s28 = 0.0;\n    float s29 = 0.0;\n    float s30 = 0.0;\n    float s31 = 0.0;\n    float s32 = 0.0;\n    float s33 = 0.0;\n    float s34 = 0.0;\n    float s35 = 0.0;\n    float s36 = 0.0;\n    float s37 = 0.0;\n    float s38 = 0.0;\n    float s39 = 0.0;\n    float s40 = 0.0;\n    float s41 = 0.0;\n    float s42 = 0.0;\n    float s43 = 0.0;\n    float s44 = 0.0;\n    float s45 = 0.0;", "\n    vec3 n = vec3(0.0);\n    n.x = snoise(p);\n    n.y = snoise(p+vec2(1.0,0.0));\n    n.z = snoise(p+vec2(0.0,1.0));\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    vec3 n = vec3(0.0);\n    n.x = snoise(p);\n    n.y = snoise(p+vec3(1.0,0.0,0.0));\n    n.z = snoise(p+vec3(0.0,1.0,0.0));\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec4 noised( in vec4 p )\n{\n    vec4 n = vec4(0.0);\n    n.x = snoise(p);\n    n.y = snoise(p+vec4(1.0,0.0,0.0,0.0));\n    n.z = snoise(p+vec4(0.0,1.0,0.0,0.0));\n    n.w = snoise(p+vec4(0.0,0.0,1.0,0.0));\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec2 noised( in vec2 p, float t )\n{\n    vec2 n = vec2(0.0);\n    n.x = snoise(p,t);\n    n.y = snoise(p+vec2(1.0,0.0),t);\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p, float t )\n{\n    vec3 n = vec3(0.0);\n    n.x = snoise(p,t);\n    n.y =", "\n    vec2 d = abs(p) - size + radius;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c)\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.", "\n    vec3 col = vec3(0.0);\n    float t = uv.x;\n    float s = uv.y;\n    float r = orient.x;\n    float b = orient.y;\n    float a = (r - t) / (b - s);\n    float bb = (b - t) / (r - s);\n    float aa = (a - bb) / (1.0 + a * bb);\n    float bb2 = bb * bb;\n    float aa2 = aa * aa;\n    float a2 = a * a;\n    float b2 = b * b;\n    float a3 = a2 * a;\n    float b3 = b2 * b;\n    float a4 = a2 * a2;\n    float b4 = b2 * b2;\n    float a5 = a2 * a3;\n    float b5 = b2 * b3;\n    float a6 = a2 * a4;\n    float b6 = b2 * b4;\n    float a7 = a2 * a5;\n    float b7 = b2 * b5;\n    float a8 = a2 * a6;\n    float b8 = b2 * b6;\n    float a9 = a2 * a7;\n    float b9 = b2 * b7;\n    float a10 = a2 * a8;\n    float b10 = b2 * b8;\n    float a11 = a2 * a9;\n    float b11 = b2 * b9;\n    float a12 = a2 * a10;\n    float b12 = b2 * b10;\n    float a13 = a2 * a11;\n    float b13 = b2 * b11;\n    float a14 = a2 * a12;\n    float b14 = b2 * b12;\n    float a15 = a2 * a13;\n    float b15 = b2 * b13;\n    float a16 = a2 * a14;\n    float b16 = b2 * b14", "\n    vec3 col = vec3(0.0);\n    float t = uv.x;\n    float s = uv.y;\n    float r = orient.x;\n    float b = orient.y;\n    float a = (t-r)/(b-r);\n    float bb = (s-r)/(b-r);\n    float aa = (t-s)/(b-r);\n    float bb2 = (s-r)/(b-s);\n    float aa2 = (t-s)/(b-s);\n    float aa3 = (t-r)/(b-s);\n    float bb3 = (s-r)/(b-s);\n    float aa4 = (t-r)/(b-t);\n    float bb4 = (s-r)/(b-t);\n    float aa5 = (t-s)/(b-t);\n    float bb5 = (s-r)/(b-t);\n    float aa6 = (t-s)/(b-r);\n    float bb6 = (s-t)/(b-r);\n    float aa7 = (t-r)/(b-r);\n    float bb7 = (s-t)/(b-r);\n    float aa8 = (t-s)/(b-r);\n    float bb8 = (s-t)/(b-r);\n    float aa9 = (t-r)/(b-s);\n    float bb9 = (s-t)/(b-s);\n    float aa10 = (t-s)/(b-s);\n    float bb10 = (s-t)/(b-s);\n    float aa11 = (t-r)/(b-t);\n    float bb11 = (s-t)/(b-t);\n    float aa12 = (t-s)/(b-t);\n    float bb12 = (s-t)/(b-t);\n    float aa13 = (t-s)/(b-r);\n    float bb13 = (s-t)/(", "\n    vec2 grid = fract(p);\n    vec2 d = abs(ddx) + abs(ddy);\n    vec2 offset = vec2(0.5, 0.5) - grid;\n    vec2 r = vec2(\n        dot2(greaterThan(d.xy, offset.xy)),\n        dot2(greaterThan(d.yx, offset.yx))\n    );\n    return r.x * r.y;\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 grid = fract(p);\n    vec2 d = abs(ddx) + abs(ddy);\n    vec2 offset = vec2(0.5, 0.5) - grid;\n    vec2 r = vec2(\n        dot2(greaterThan(d.xy, offset.xy)),\n        dot2(greaterThan(d.yx, offset.yx))\n    );\n    return r.x * r.y;\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p )\n{\n    vec2 grid = fract(p);\n    vec2 offset = vec2(0.5, 0.5) - grid;\n    vec2 r = vec2(\n        dot2(greaterThan(grid.xy, offset.xy)),\n        dot2(greaterThan(grid.yx, offset.yx))\n    );\n    return r.x * r.y;\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p, in float scale )\n{\n    vec2 grid = fract(p * scale);\n    vec2 offset = vec2(0.5, 0.5) - grid;\n    vec2 r = vec2(\n        dot2(greaterThan(grid.xy, offset.xy)),\n        dot2(greaterThan(grid.yx, offset.yx))\n    );\n    return r.x * r.y;\n}\n\n// grid ratio", "\n    vec3 e = vec3(0.001,0.0,0.0);\n    return vec3( map(p+e.xyy).x - map(p-e.xyy).x,\n                 map(p+e.yxy).x - map(p-e.yxy).x,\n                 map(p+e.yyx).x - map(p-e.yyx).x ) / (2.0*e.x);\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 e )\n{\n    return vec3( map(p+e.xyy).x - map(p-e.xyy).x,\n                 map(p+e.yxy).x - map(p-e.yxy).x,\n                 map(p+e.yyx).x - map(p-e.yyx).x ) / (2.0*e.x);\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in float e )\n{\n    return vec3( map(p+vec3(e,0.0,0.0)).x - map(p-vec3(e,0.0,0.0)).x,\n                 map(p+vec3(0.0,e,0.0)).x - map(p-vec3(0.0,e,0.0)).x,\n                 map(p+vec3(0.0,0.0,e)).x - map(p-vec3(0.0,0.0,e)).x ) / (2.0*e);\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 e, in float e2 )\n{\n    return vec3( map(p+e.xyy).x - map(p-e.xyy).x,\n                 map(p+e.yxy).x - map(p-e.yxy).x,\n                 map(p+e.yyx).x -", "\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main ray-transpose function:\nvoid rayTransp(inout v33 a,inout v33 b){\n    v33 c=a", "\n    return v33(a.a-b,a.b-b,a.c-b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,v33 b){\n    return v33(a-b.a,a-b.b,a-b.c);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){\n    return v33(a.a-b.a,a.b-b.b,a.c-b.c);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,vec3 b){\n    return v33(a-b,a-b,a-b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return v33(a.a-b,a.b-b,a.c-b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,v33 b){\n    return v33(a-b.a,a-b.b,a-b.c);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){\n    return v33(a.a-b.a,a.b-b.b,a.c-b.c);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,vec3 b){\n    return v33(a-b,a-b,a-b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return v33(a", "\n    v33 c;\n    c.x=a.x-b.x;\n    c.y=a.y-b.y;\n    c.z=a.z-b.z;\n    return c;\n}\n\n//component wise ray addition\nv33 addc(v33  a,v33 b){\n    v33 c;\n    c.x=a.x+b.x;\n    c.y=a.y+b.y;\n    c.z=a.z+b.z;\n    return c;\n}\n\n//component wise ray multiplication\nv33 mulc(v33  a,v33 b){\n    v33 c;\n    c.x=a.x*b.x;\n    c.y=a.y*b.y;\n    c.z=a.z*b.z;\n    return c;\n}\n\n//component wise ray division\nv33 divc(v33  a,v33 b){\n    v33 c;\n    c.x=a.x/b.x;\n    c.y=a.y/b.y;\n    c.z=a.z/b.z;\n    return c;\n}\n\n//component wise ray division\nv33 divc2(v33  a,float b){\n    v33 c;\n    c.x=a.x/b;\n    c.y=a.y/b;\n    c.z=a.z/b;\n    return c;\n}\n\n//component wise ray division\nv33 divc3(float a,v33 b){\n    v33 c;\n    c.x=a/b.x;\n    c.y=a/b.y;\n    c.z=a/b.z;\n    return c;\n}\n\n//component wise ray division\nv33 divc4(v33  a,float b){\n    v33 c;\n    c.x=a.x/b;\n    c.y=a.y/b;\n    c.z=a.z/", "\n  return v2(\n    (b.x-a.x)/(b.z-a.z),\n    (b.y-a.y)/(b.z-a.z)\n  );\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c){\n  return v2(\n    (b.x-a.x)/(b.z-a.z),\n    (b.y-a.y)/(b.z-a.z)\n  )+v2(\n    (c.x-b.x)/(c.z-b.z),\n    (c.y-b.y)/(c.z-b.z)\n  );\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n  return v2(\n    (b.x-a.x)/(b.z-a.z),\n    (b.y-a.y)/(b.z-a.z)\n  )+v2(\n    (c.x-b.x)/(c.z-b.z),\n    (c.y-b.y)/(c.z-b.z)\n  )+v2(\n    (d.x-c.x)/(d.z-c.z),\n    (d.y-c.y)/(d.z-c.z)\n  );\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n  return v2(\n    (b.x-a.x)/(b.z-a.z),\n    (b.y-a.y)/(b.z-a.z)\n  )+v2(\n    (c.x-b.x)/(c.z-b.z),\n    (c.y-b.y)/(c.z-b.z)\n  )+v2(\n    (d.x-", "\n    return vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotproduct on v33s\nvec2 dt(vec3 a,v33 b){\n    return vec2(dot(a,b.x),dot(a,b.y));\n}\n\n//dual dotproduct on v33s\nvec2 dt(v33 a,v33 b){\n    return vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotproduct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n    return vec2(dot(a.x,b.x)*c.x.x+dot(a.x,b.y)*c.x.y+dot(a.x,b.z)*c.x.z,\n                dot(a.y,b.x)*c.y.x+dot(a.y,b.y)*c.y.y+dot(a.y,b.z)*c.y.z);\n}\n\n//dual dotproduct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n    return vec2(dot(a.x,b.x)*c.x.x*d.x.x+dot(a.x,b.x)*c.x.y*d.x.y+dot(a.x,b.x)*c.x.z*d.x.z+\n                dot(a.x,b.y)*c.y.x*d.x.x+dot(a.x,b.y)*c.y.y*d.x.y+dot(a.x,b.y)*c.y.z*d.x.z+\n                dot(a.x,b.z)*c.z.x*d.x.x+dot(a.x,b.z)*c.z.y*d.x.y+dot(a.x,b.z)*c.z.z*d.x.z", "\n    return v33(a.x*b.x,a.y*b.y,a.z*b.x*b.y);\n}\n\n//dual mult\nv33 mul(vec2 a,v33 b){\n    return v33(a.x*b.x,a.y*b.y,a.x*a.y*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b){\n    return v33(a.x*b.x,a.y*b.y,a.x*a.y*b.z+a.z*b.x+a.x*b.y);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c){\n    return v33(a.x*b.x*c.x,a.y*b.y*c.y,a.x*a.y*c.z+a.z*b.x*c.x+a.x*b.y*c.y);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c,v33 d){\n    return v33(a.x*b.x*c.x*d.x,a.y*b.y*c.y*d.y,a.x*a.y*c.z*d.x+a.z*b.x*c.x*d.y+a.x*b.y*c.y*d.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return v33(a.x*b.x*c.x*d.x*e.x,a.y*b.y*c.y*d.y*e.y,a.x*a.y*c.z*d.x*e.x+a.z*b.x*c.x*d.y*e.y+a", "\n    vec3 q=floor(p);\n    vec3 r=fract(p);\n    float k=mod(q.x+q.y+q.z,2.0);\n    float s=k*(k*r.x+r.y+r.z);\n    return s;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=floor(p);\n    vec3 r=fract(p);\n    float k=mod(q.x+q.y+q.z,2.0);\n    float s=k*(k*r.x+r.y+r.z);\n    return s;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=floor(p);\n    vec3 r=fract(p);\n    float k=mod(q.x+q.y+q.z,2.0);\n    float s=k*(k*r.x+r.y+r.z);\n    return s;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=floor(p);\n    vec3 r=fract(p);\n    float k=mod(q.x+q.y+q.z,2.0);\n    float s=k*(k*r.x+r.y+r.z);\n    return s;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 q=floor(p);\n    vec3 r=fract(p);\n    float k=mod(q.x+q.y+q.z,2.0);\n    float s=k*(k*r", "\n    vec3 q=p/w;\n    vec3 r=fract(q);\n    float k=smoothstep(0.0,1.0,r.x);\n    float s=smoothstep(0.0,1.0,r.y);\n    float t=smoothstep(0.0,1.0,r.z);\n    return k*s*t+(1.0-k)*(1.0-s)*(1.0-t);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF4(vec3 p,vec3 w){\n    vec3 q=p/w;\n    vec3 r=fract(q);\n    float k=smoothstep(0.0,1.0,r.x);\n    float s=smoothstep(0.0,1.0,r.y);\n    float t=smoothstep(0.0,1.0,r.z);\n    return k*s*t+(1.0-k)*(1.0-s)*(1.0-t);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF5(vec3 p,vec3 w){\n    vec3 q=p/w;\n    vec3 r=fract(q);\n    float k=smoothstep(0.0,1.0,r.x);\n    float s=smoothstep(0.0,1.0,r.y);\n    float t=smoothstep(0.0,1.0,r.z);\n    return k*s*t+(1.0-k)*(1.0-s)*(1.0-t);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF6(vec3 p,vec3 w", "\n    float t=intersect(r,s);\n    if(t<0.0)return 1.0;\n    float d=length(r.o+r.d*t-s.xyz);\n    return d<s.w?0.0:1.0;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k){\n    float t=intersect(r,s);\n    if(t<0.0)return 1.0;\n    float d=length(r.o+r.d*t-s.xyz);\n    return d<s.w?0.0:1.0-pow(1.0-d/s.w,k);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float f){\n    float t=intersect(r,s);\n    if(t<0.0)return 1.0;\n    float d=length(r.o+r.d*t-s.xyz);\n    return d<s.w?0.0:1.0-pow(1.0-d/s.w,k*f);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float f,float g){\n    float t=intersect(r,s);\n    if(t<0.0)return 1.0;\n    float d=length(r.o+r.d*t-s.xyz);\n    return d<s.w?0.0:1.0-pow(1.0-d/s.w,k*f*g);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float f,float g,float h){\n    float t=intersect(r,s);\n    if(t<0.0)return 1.0;\n    float d=length(r.o+r.d", "\n    float d=length(u-s.xyz);\n    float r=s.w;\n    float a=dot(u-s.xyz,n);\n    float b=r*r-a*a;\n    float c=d*d-b;\n    float e=sqrt(c);\n    float f=a-e;\n    float g=a+e;\n    float h=min(f,g);\n    float i=max(f,g);\n    float j=max(h,0.0);\n    float k=min(i,r);\n    float l=max(j,k);\n    return l/r;\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 b){\n    vec3 v=abs(u-b.xyz)-b.w;\n    float p=max(v.x,max(v.y,v.z));\n    float q=min(max(v.x,0.0),max(v.y,max(v.z,0.0)));\n    return max(q,p)/b.w;\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 c){\n    float a=dot(u,c.xyz);\n    float b=c.w;\n    float d=dot(n,c.xyz);\n    float e=a/d;\n    float f=sqrt(1.0-d*d);\n    float g=e*f;\n    float h=e+g;\n    float i=e-g;\n    float j=min(h,i);\n    float k=max(j,0.0);\n    float l=max(k,b);\n    return l/b;\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 c){\n    float a=dot(u,c.xyz);\n    float b=c.w;\n    float d=dot(n,c.xyz);\n    float e=a/d;\n    float f=sqrt(1.0-d*d", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d0d1 = d0 * d1;\n    vec2 d1d2 = d1 * d2;\n    vec2 d2d0 = d2 * d0;\n\n    vec2 d0d1d2 = d0d1 * d2;\n    vec2 d1d2d0 = d1d2 * d0;\n    vec2 d2d0d1 = d2d0 * d1;\n\n    vec2 d0d1d2d0 = d0d1d2 * d0;\n    vec2 d1d2d0d1 = d1d2d0 * d1;\n    vec2 d2d0d1d2 = d2d0d1 * d2;\n\n    vec2 d0d1d2d0d1 = d0d1d2d0 * d1;\n    vec2 d1d2d0d1d2 = d1d2d0d1 * d2;\n    vec2 d2d0d1d2d0 = d2d0d1d2 * d0;\n\n    vec2 d0d1d2d0d1d2 = d0d1d2d0d1 * d2;\n    vec2 d1d2d0d1d2d0 = d1d2d0d1d2 * d0;\n    vec2 d2d0d1d2d0d1 = d2d0d1d2d0 * d1;\n\n    vec2 d0d1d2d0d1d2d0 = d0d1d2d0d1d2 * d0;\n    vec2 d1d2d0d1d2d0d1 = d1d2d0d1d2d0 * d1;\n    vec2 d2d0d1d2d0d1d2 = d2d0d1d2d0d1", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d01 = p1 - p0;\n    vec2 d12 = p2 - p1;\n    vec2 d20 = p0 - p2;\n\n    vec2 d012 = p1 - p0;\n    vec2 d120 = p0 - p1;\n    vec2 d201 = p1 - p0;\n\n    vec2 d0120 = p0 - p1;\n    vec2 d1201 = p1 - p0;\n    vec2 d2012 = p2 - p0;\n\n    vec2 d01201 = p0 - p1;\n    vec2 d12012 = p1 - p0;\n    vec2 d20120 = p2 - p0;\n\n    vec2 d012012 = p0 - p1;\n    vec2 d120120 = p1 - p0;\n    vec2 d201201 = p2 - p0;\n\n    vec2 d0120120 = p0 - p1;\n    vec2 d1201201 = p1 - p0;\n    vec2 d2012012 = p2 - p0;\n\n    vec2 d01201201 = p0 - p1;\n    vec2 d12012012 = p1 - p0;\n    vec2 d20120120 = p2 - p0;\n\n    vec2 d012012012 = p0 - p1;\n    vec2 d120120120 = p1 - p0;\n    vec2 d201201201 = p2 - p0;\n\n    vec2 d0120120120 =", "\n    vec3 p01 = mix(p0,p1,0.5);\n    vec3 p12 = mix(p1,p2,0.5);\n    vec3 p23 = mix(p2,p3,0.5);\n    vec3 p012 = mix(p01,p12,0.5);\n    vec3 p123 = mix(p12,p23,0.5);\n    vec3 p0123 = mix(p012,p123,0.5);\n    vec3 p01234 = mix(p0123,p3,0.5);\n    return bound3(p01234-vec3(0.001),p01234+vec3(0.001));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t )\n{\n    vec3 p01 = mix(p0,p1,t);\n    vec3 p12 = mix(p1,p2,t);\n    vec3 p23 = mix(p2,p3,t);\n    vec3 p012 = mix(p01,p12,t);\n    vec3 p123 = mix(p12,p23,t);\n    vec3 p0123 = mix(p012,p123,t);\n    vec3 p01234 = mix(p0123,p3,t);\n    return bound3(p01234-vec3(0.001),p01234+vec3(0.001));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/", "\n    vec2 p01 = p0 + p1;\n    vec2 p12 = p1 + p2;\n    vec2 p23 = p2 + p3;\n    vec2 p012 = p01 + p12;\n    vec2 p123 = p12 + p23;\n    vec2 p0123 = p012 + p123;\n    vec2 p01234 = p0123 + p0123;\n\n    vec2 min = p01234;\n    vec2 max = p01234;\n\n    min.x = min(min.x, p0.x);\n    min.x = min(min.x, p1.x);\n    min.x = min(min.x, p2.x);\n    min.x = min(min.x, p3.x);\n\n    min.y = min(min.y, p0.y);\n    min.y = min(min.y, p1.y);\n    min.y = min(min.y, p2.y);\n    min.y = min(min.y, p3.y);\n\n    max.x = max(max.x, p0.x);\n    max.x = max(max.x, p1.x);\n    max.x = max(max.x, p2.x);\n    max.x = max(max.x, p3.x);\n\n    max.y = max(max.y, p0.y);\n    max.y = max(max.y, p1.y);\n    max.y = max(max.y, p2.y);\n    max.y = max(max.y, p3.y);\n\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezierSimple(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3 )\n{\n    vec3 p01 = p0 + p1", "\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(a, b, pos.x);\n    vec2 e = mix(b, c, pos.x);\n    vec2 f = mix(d, e, pos.x);\n    return mix(f, pos.y, pos.x);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(a, b, pos.x);\n    vec2 e = mix(b, c, pos.x);\n    vec2 f = mix(d, e, pos.x);\n    return mix(f, pos.y, pos.x);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec2 pos)\n{\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(p3, p4, pos.x);\n    vec2 e = mix(a, b, pos.x);\n    vec2 f = mix(b, c, pos.x);\n    vec2 g = mix(c, d, pos.x);\n    vec2 h = mix(e, f, pos.x);\n    vec2 i = mix(f, g, pos.x);\n    vec2 j = mix(h, i, pos.x);", "\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3 n = cross( v1v0, v2v0 );\n\n    float d = dot( n, rd );\n\n    // Backfacing.\n    if( d < 0.0 ) return vec3( -1.0 );\n\n    float invD = 1.0 / d;\n    vec3 uv = vec3( dot( v2v0, rov0 ), dot( v1v0, rov0 ), -dot( n, rov0 ) ) * invD;\n\n    if( uv.x < 0.0 || uv.y < 0.0 || uv.z < 0.0 ) return vec3( -1.0 );\n\n    return vec3( dot( n, rov0 ) * invD, uv );\n}\n\n// Ray-marching.\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n\n    for( int i = 0; i < 128; i++ )\n    {\n        vec3 p = ro + rd * t;\n        float d = map( p );\n        t += d;\n        if( d < 0.0001 || t > 100.0 ) break;\n    }\n\n    return t;\n}\n\n// Ray-marching.\nfloat raymarch( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\n    for( int i = 0; i < 128; i++ )\n    {\n        vec3 p = ro + rd * t;\n        float d = map( p );\n        t += d;\n        if( d < 0.0001 || t > tmax ) break;\n    }\n\n    return t;\n}\n\n// Ray-marching.\nfloat raymarch( in vec3 ro, in ve", "\n    vec3 v01 = v1 - v0;\n    vec3 v02 = v2 - v0;\n    vec3 v0p = pos - v0;\n    vec3 nor0 = cross( v01, v02 );\n    float d = dot( nor0, nor );\n    if( d < 0.0 ) return 0.0;\n    float s = dot( cross( v01, v0p ), nor0 ) / d;\n    if( s < 0.0 ) return 0.0;\n    float t = dot( cross( v02, v0p ), nor0 ) / d;\n    if( t < 0.0 ) return 0.0;\n    if( s + t > 1.0 ) return 0.0;\n    return 1.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 v01 = v1 - v0;\n    vec3 v02 = v2 - v0;\n    vec3 v03 = v3 - v0;\n    vec3 v0p = pos - v0;\n    vec3 nor0 = cross( v01, v02 );\n    float d = dot( nor0, nor );\n    if( d < 0.0 ) return 0.0;\n    float s = dot( cross( v01, v0p ), nor0 ) / d;\n    if( s < 0.0 ) return 0.0;\n    float t = dot( cross( v02, v0p ), nor0 ) / d;\n    if( t < 0.0 ) return 0.0;\n    if( s + t > 1.0 ) return 0.0;\n    float u = dot( cross( v03, v0p ), nor0 ) / d;\n    if( u < 0.0 ) return 0.0;\n    if( s + t + u > 1.0 ) return", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a*2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    vec3 res = vec3(\n        dot(d,d) - kx*kz,\n        ky*kz - ky*ky,\n        kz*kz - kx*ky\n    );\n\n    float res2 = dot(res,res);\n    float s = sqrt(res2);\n    vec2 uv = max(vec2(-kx+s, -ky+s), vec2(0.0));\n    uv /= vec2(2.0*dot(a,a), dot(a,b));\n\n    vec2 q = vec2(1.0-uv.x-uv.y, uv.x);\n    float d2 = dot(q,q);\n    float z = sqrt(d2);\n    vec2 v = vec2(\n        dot(a,q) / (z*z*z),\n        dot(b,q) / (z*z)\n    );\n\n    vec2 p = vec2(\n        v.x + 2.0*q.x*v.y + q.x*q.x,\n        v.y + q.y*q.y\n    );\n\n    return sqrt(dot(p,p)) * sign(p.x);\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2", "\n    float d1 = p.y - r1;\n    float d2 = p.y - r2;\n    float d3 = p.x - max( r1, r2 );\n    float d4 = p.x + min( r1, r2 );\n    float d5 = (r1-r2)/he;\n    float q = clamp( (d1-d5*d3)/(d5*(d2-d5*d4)), -1.0, 1.0 );\n    float d6 = d1 - d5*d4 - he*q;\n    float d7 = d2 - d5*d3 + he*(q-1.0);\n    float d8 = max( d1, d2 );\n    float d9 = max( d6, d7 );\n    float d = sqrt( d9*d9 + d8*d8 );\n    return d * sign( d6 );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    float d1 = p.x - r1;\n    float d2 = p.x - r2;\n    float d3 = p.y - max( r1, r2 );\n    float d4 = p.y + min( r1, r2 );\n    float d5 = (r1-r2)/he;\n    float q = clamp( (d1-d5*d3)/(d5*(d2-d5*d4)), -1.0, 1.0 );\n    float d6 = d1 - d5*d4 - he*q;\n    float d7 = d2 - d5*d3 + he*(q-1.0);\n    float d8 = max( d1, d2 );\n    float d9 = max( d6, d7 );\n    float d = sqrt( d9*d9 + d8*d8 );\n    return d * sign( d6 );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in ve", "\n    vec2  ba = b - a;\n    float h  = clamp( dot( p - a, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec2  c  = a + h * ba;\n    float d  = length( p - c );\n    float bh = ra - rb;\n    float k1 = rb / ( ra - bh );\n    float k2 = bh / ra;\n    float k3 = rb / ra;\n    float k4 = clamp( ( d - rb ) / ( ra - rb ), 0.0, 1.0 );\n    float s  = ( ( k1 * p.x + k2 * p.y ) * ( k1 * p.x + k2 * p.y ) + k3 * k3 * ( p.x * p.x + p.y * p.y - 2.0 * k1 * p.x - 2.0 * k2 * p.y ) );\n    float t  = clamp( ( d * d - rb * rb ) / ( ra * ra - rb * rb ), 0.0, 1.0 );\n    float u  = step( 0.0, ra - rb ) * step( 0.0, t ) * step( s, 1.0 );\n    float v  = step( 0.0, ra - rb ) * step( 0.0, k4 ) * step( s, 1.0 );\n    float w  = step( 0.0, ra - rb ) * step( t, 1.0 ) * step( s, 1.0 );\n    float x  = step( 0.0, ra - rb ) * step( k4, 1.0 ) * step( s, 1.0 );\n    float y  = ra - rb;\n    float z  = ra;\n    float e  = min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sdf(pos+h.xyy) - sdf(pos-h.xyy),\n                           sdf(pos+h.yxy) - sdf(pos-h.yxy),\n                           sdf(pos+h.yyx) - sdf(pos-h.yyx) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdf(vec3 pos)\n{\n    float d = length(pos) - 1.0;\n   ", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 calcColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = vec3(0.8,0.9,1.0) - 0.15*nor.y;\n    col *= 0.95;\n    col += 0.05*sin( 10.0*pos.y );\n    col *= calc", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash\nfloat hash( in float q )\n{\n    return fract(sin(q)*43758.5453);\n}\n\n// random hash\nfloat hash( in vec2 q )\n{\n    return fract(sin(dot(q,vec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash\nfloat hash( in vec3 q )\n{\n    return fract(sin(dot(q,vec3(127.1,311.7,191.999)))*43758.5453);\n}\n\n// random hash\nfloat hash( in vec4 q )\n{\n    return fract(sin(dot(q,vec4(127.1,311.7,191.999,978.233)))*43758.5453);\n}\n\n// random hash\nfloat hash( in vec2 q, in float t )\n{\n    return hash(q.x+q.y*t);\n}\n\n// random hash\nfloat hash( in vec3 q, in float t )\n{\n    return hash(q.x+q.y*t+q.z*t*t);\n}\n\n// random hash\nfloat hash( in vec4 q, in float t )\n{\n    return hash(q.x+q.y*t+q.z*t*t+q.w*t*t*t);\n}\n\n// random hash\nfloat hash( in vec2 q, in vec2 t )\n{\n    return hash(q.x+q.y*t.x+t.y);\n}\n\n// random hash\nfloat hash( in vec3 q, in vec3 t )\n{\n    return hash(q.x+q.y*t.x+q.z*t.y+t.z);\n", "\n    vec2 p2 = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p2.x + p2.y*157.0;\n\n    float res = mix(mix( hash(n+p), hash(n+1+p),f.x),\n                    mix( hash(n+157.0+p), hash(n+158.0+p),f.x),f.y);\n    return res;\n}\n\n// 2D value noise\nfloat noise( in vec2 x )\n{\n    return noise(x, 0);\n}\n\n// 2D value noise\nfloat noise( in vec2 x, in float time )\n{\n    return noise(x, int(time*1000.0));\n}\n\n// 2D value noise\nfloat noise( in vec2 x, in float time, in float freq )\n{\n    return noise(x*freq, int(time*1000.0));\n}\n\n// 2D value noise\nfloat noise( in vec2 x, in float time, in float freq, in float amp )\n{\n    return noise(x*freq, int(time*1000.0))*amp;\n}\n\n// 2D value noise\nfloat noise( in vec2 x, in float time, in float freq, in float amp, in float offset )\n{\n    return noise(x*freq, int(time*1000.0))*amp + offset;\n}\n\n// 2D value noise\nfloat noise( in vec2 x, in float time, in float freq, in float amp, in float offset, in float scale )\n{\n    return noise(x*freq, int(time*1000.0))*amp + offset;\n}\n\n// 2D value noise\nfloat noise( in vec2 x, in float time, in float freq, in float amp, in float offset, in float scale, in float bias )\n{\n    return noise(x*freq, int", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < p; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 x )\n{\n    const vec2 step = vec2(110.0, 241.0);\n\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // For performance, compute the base noise value once and re-use it for the 8\n    // surrounding pixels\n    float n = dot(i, step);\n\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix( dot( hash22(n + dot(i, step)), f - vec2(0.0, 0.0) ),\n                    dot( hash22(n + dot(i, step) + vec2(1.0, 0.0)), f - vec2(1.0, 0.0) ), u.x),\n               mix( dot( hash22(n + dot(i, step) + vec2(0.0, 1.0)), f - vec2(0.0, 1.0) ),\n                    dot( hash22(n + dot(i, step) + vec2(1.0, 1.0)), f - vec2(1.0, 1.0) ), u.x), u.y);\n}\n\n// 2D simplex noise\nfloat snoise( in vec3 x )\n{\n    const vec3 step = vec3(110.0, 241.0, 17", "\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k ) \n{\n    float l = length( p/r );\n    return (l-r.x*k)*(l-r.y*k)*(l-r.z*k)/(l*l*l);\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float d ) \n{\n    float l = length( p/r );\n    return (l-r.x*k)*(l-r.y*k)*(l-r.z*k)/(l*l*l) - d;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float d, in float s ) \n{\n    float l = length( p/r );\n    return (l-r.x*k)*(l-r.y*k)*(l-r.z*k)/(l*l*l) - d - s;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float d, in float s, in float t ) \n{\n    float l = length( p/r );\n    return (l-r.x*k)*(l-r.y*k)*(l-r.z*k)/(l*l*l) - d - s - t;", "\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k2 = k0*k0 + k1*k1;\n    float k3 = k2*(k2 + r.x*r.x) + r.y*r.y;\n    return sqrt(k2)*sqrt(k3) - k2;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.yz);\n    float k1 = p.x;\n    float k2 = k0*k0 + k1*k1;\n    float k3 = k2*(k2 + r.x*r.x) + r.y*r.y;\n    return sqrt(k2)*sqrt(k3) - k2;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.zx);\n    float k1 = p.y;\n    float k2 = k0*k0 + k1*k1;\n    float k3 = k2*(k2 + r.x*r.x) + r.y*r.y;\n    return sqrt(k2)*sqrt(k3) - k2;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.xy);\n    float k1 = p.z;\n    float k2 = k0*k0 + k1*k1;\n    float k3 = k2*(k2 + r.x*r.x) + r.y*r.y;\n    return sqrt(k2)*sqrt(k3) - k2;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYZX( in vec3 p, in vec", "\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-k)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float k2 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-k)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float k2, in float k3 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-k)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float k2, in float k3, in float k4 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-k)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, in float k2, in float k3, in float k4, in float k5 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-k)/k1;", "\n    // filter kernel\n    const vec2 w = vec2(1.0);\n    // analytical integral (box filter)\n    // vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    bvec2 b = bvec2( mod( floor(p.x), 2.0 ) == mod( floor(p.y), 2.0 ) );\n    float i = float( b.x == b.y );\n    return i;\n}\n\nfloat checkersGrad( in vec2 p )\n{\n    // filter kernel\n    const vec2 w = vec2(1.0);\n    // analytical integral (box filter)\n    // vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    bvec2 b = bvec2( mod( floor(p.x), 2.0 ) == mod( floor(p.y), 2.0 ) );\n    float i = float( b.x == b.y );\n    return i;\n}\n\nfloat checkers( in vec2 p )\n{\n    // filter kernel\n    const vec2 w = vec2(1.0);\n    // analytical integral (box filter)\n    // vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    bvec2 b = bvec2( mod( floor(p.x), 2.0 ) == mod( floor(p.y), 2.0 ) );\n    float i = float( b.x == b.y );\n    return i;\n}\n\nfloat checkers( in vec2 p, float scale )\n{\n    // filter", "\n    return x / (x * (a - 1.0) + 1.0);\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain( float a, float x )\n{\n    return x * (a - 1.0) / (x * (a - 1.0) + 1.0);\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain_inv( float a, float x )\n{\n    return (x * (a - 1.0) + 1.0) / x;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain_inv_approx( float a, float x )\n{\n    return 1.0 / (x * (a - 1.0) + 1.0);\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain_approx( float a, float x )\n{\n    return x / (x * (a - 1.0) + 1.0);\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain_approx_inv( float a, float x )\n{\n    return (x * (a - 1.0) + 1.0) / x;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain_approx_inv_approx( float a, float x )\n{\n    return 1.0 / (x * (", "\n    return (x - floor(x + p)) / p;\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return abs(my_saw(x, p));\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return my_tri(x, p) * 2.0 - 1.0;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x + p)) / p;\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return abs(my_saw(x, p));\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return my_tri(x, p) * 2.0 - 1.0;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x + p)) / p;\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return abs(my_saw(x, p));\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return my_tri(x, p) * 2.0 - 1.0;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x + p)) / p;\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return abs(my_saw(x, p));\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return my_tri(x, p) * 2.0 - 1.0;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x + p)) / p;\n}\n\n// biased triangle\nfloat my_tri", "\n    float r = h;\n    float g = h;\n    float b = h;\n\n    if (h < 0.25)\n    {\n        r = 0.0;\n        g = 4.0 * h;\n    }\n    else if (h < 0.5)\n    {\n        r = 0.0;\n        b = 1.0 + 4.0 * (0.25 - h);\n    }\n    else if (h < 0.75)\n    {\n        r = 4.0 * (h - 0.5);\n        b = 0.0;\n    }\n    else\n    {\n        g = 1.0 + 4.0 * (0.75 - h);\n        b = 0.0;\n    }\n\n    return vec3(r, g, b);\n}\n\nvec3 smooth_dlmf( vec3 h )\n{\n    return smooth_dlmf(h.r) * smooth_dlmf(h.g) * smooth_dlmf(h.b);\n}\n\nvec3 smooth_dlmf( vec4 h )\n{\n    return smooth_dlmf(h.r) * smooth_dlmf(h.g) * smooth_dlmf(h.b) * smooth_dlmf(h.a);\n}\n\nvec3 smooth_dlmf( vec2 h )\n{\n    return smooth_dlmf(h.r) * smooth_dlmf(h.g);\n}\n\nvec3 smooth_dlmf( float h, float s, float v )\n{\n    return smooth_dlmf(vec3(h, s, v));\n}\n\nvec3 smooth_dlmf( vec3 h, float s, float v )\n{\n    return smooth_dlmf(h.r, s, v) * smooth_dlmf(h.g, s, v) * smooth_dlmf(h.b, s, v);\n}\n\nvec3 smooth_dlmf( vec4 h, float s, float v )\n{\n    return smooth_dlmf(h.r, s, v) * smooth_dlmf(h.g, s, v) * smooth_dlmf(", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        float y = baoa + t*bard;\n        if( y>0.0 && y<baba )\n            return t;\n    }\n    return -1.0;\n}\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r, in float tmax )\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        float y = baoa + t*bard;\n        if( y>0.0 && y<baba && t<tmax )\n            return t;\n    }\n   ", "\n    vec3 ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(p - a, ba);\n    float x = clamp(paba / baba, 0.0, 1.0);\n    float dx = paba - x * baba;\n    float d = sqrt(dx * dx + ra * ra);\n    float y = sqrt(baba) * x + ra;\n    float dy = y - rb;\n    return sqrt(d * d + dy * dy);\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h)\n{\n    vec3 ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(p - a, ba);\n    float x = clamp(paba / baba, 0.0, 1.0);\n    float dx = paba - x * baba;\n    float d = sqrt(dx * dx + ra * ra);\n    float y = sqrt(baba) * x + ra;\n    float dy = y - rb;\n    float d2 = sqrt(d * d + dy * dy);\n    float c = (x * baba - paba) / baba;\n    float s = c * ra / rb;\n    float d3 = (dy < 0.0 && s > -h && s < h)? 0.0 : d2;\n    return (d < rb)? -d3 : d3;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float rc)\n{\n    vec3 ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(p - a, ba);\n    float x = clamp(paba / baba, 0.0, 1.0);\n    float dx = paba - x * baba;\n    float d = sqrt(dx * dx + ra * ra);\n    float y =", "\n    vec3 ba = b - a;\n    vec3 oa = ro - a;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float aard = dot(a,rd);\n    float aaoa = dot(a,oa);\n    float rr = r*r;\n    float aa = baba - rr;\n    float bb = bard*bard - aa*rdrd;\n    float cc = baoa*bard - aaoa - rr*rdrd;\n    float dd = baoa*baoa - aaoa*aard - rr*oaoa;\n    float ee = aaoa*(aard - rr) + oaoa*bard + rdoa*baba;\n    float ff = aaoa*aard + oaoa*bard + rdoa*baba;\n    float gg = rdoa*baba - aaoa*aard + oaoa*bard;\n    float hh = -rdoa*baba*k;\n    float i = bb*bb - k*aa*cc;\n    float j = bb*gg - k*aa*ff;\n    float kk = bb*hh - k*aa*ee;\n    float l = cc*cc - 4.0*bb*i;\n    float m = cc*j - 2.0*bb*kk;\n    float n = cc*m - 4.0*i*kk;\n    float o = dd*dd - 4.0*bb*f;\n    float p = dd*j - 2.0*bb*hh;\n    float q = dd*p - 4.0*f*hh;\n    float r = ee*ee;\n    float s = ee*p - 2.0*r*hh;\n    float t = ee*q -", "\n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    float d = abs(r - rad1);\n    float d2 = abs(r - rad2);\n    float d3 = abs(r - th);\n    float d4 = abs(r - (rad1 + th));\n    float d5 = abs(r - (rad2 + th));\n    float d6 = abs(r - (rad1 + th * 2.0));\n    float d7 = abs(r - (rad2 + th * 2.0));\n    float d8 = abs(r - (rad1 + th * 3.0));\n    float d9 = abs(r - (rad2 + th * 3.0));\n    float d10 = abs(r - (rad1 + th * 4.0));\n    float d11 = abs(r - (rad2 + th * 4.0));\n    float d12 = abs(r - (rad1 + th * 5.0));\n    float d13 = abs(r - (rad2 + th * 5.0));\n    float d14 = abs(r - (rad1 + th * 6.0));\n    float d15 = abs(r - (rad2 + th * 6.0));\n    float d16 = abs(r - (rad1 + th * 7.0));\n    float d17 = abs(r - (rad2 + th * 7.0));\n    float d18 = abs(r - (rad1 + th * 8.0));\n    float d19 = abs(r - (rad2 + th * 8.0));\n    float d20 = abs(r - (rad1 + th * 9.0));\n    float d21 = abs(r - (rad2 + th * 9.0));\n    float d22 = abs(r - (rad1 + th * 10.0));\n    float d23 = abs(r - (rad2 + th * 10.0));\n    float d24 = abs(r - (rad1 + th * 11.0));", "\n    return length(p) - r - dot(p,c);\n}\n\nfloat sdPie( in vec2 p, in float c, in float r )\n{\n    return sdPie(p,vec2(c,sqrt(1.0-c*c)),r);\n}\n\nfloat sdPie( in vec2 p, in float c, in float r, in float w )\n{\n    return sdPie(p,vec2(c,sqrt(1.0-c*c)),r) - w;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w )\n{\n    return sdPie(p,c,r) - w;\n}\n\nfloat sdPie( in vec2 p, in float c, in float r, in float w, in float h )\n{\n    return sdPie(p,c,r,w) - h;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w, in float h )\n{\n    return sdPie(p,c,r,w) - h;\n}\n\nfloat sdPie( in vec2 p, in float c, in float r, in float w, in float h, in float a )\n{\n    return sdPie(p,c,r,w,h) - a;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w, in float h, in float a )\n{\n    return sdPie(p,c,r,w,h) - a;\n}\n\nfloat sdPie( in vec2 p, in float c, in float r, in float w, in float h, in float a, in float b )\n{\n    return sdPie(p,c,r,w,h,a) - b;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w, in float h, in float a, in float b", "\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb, in float rc )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb, in float rc, in float rd )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb, in float rc", "\n    p.x = abs(p.x);\n    float k = (sca.y*p.x>sca.x*p.y)? dot(p,sca) : dot(p,scb);\n    k = k*k/sca.x/sca.y;\n    float d = (k>ra*ra && k<rb*rb)? dot(p,vec2(abs(k)<1.0? 1.0 : -1.0)) : length(p) - ra;\n    return d;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float angle )\n{\n    p.x = abs(p.x);\n    float k = (sca.y*p.x>sca.x*p.y)? dot(p,sca) : dot(p,scb);\n    k = k*k/sca.x/sca.y;\n    float d = (k>ra*ra && k<rb*rb)? dot(p,vec2(abs(k)<1.0? 1.0 : -1.0)) : length(p) - ra;\n    return d;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float angle, in float offset )\n{\n    p.x = abs(p.x);\n    float k = (sca.y*p.x>sca.x*p.y)? dot(p,sca) : dot(p,scb);\n    k = k*k/sca.x/sca.y;\n    float d = (k>ra*ra && k<rb*rb)? dot(p,vec2(abs(k)<1.0? 1.0 : -1.0)) : length(p) - ra;\n    return d;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float r", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 calcColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = vec3(0.8,0.9,1.0) + map(pos)*0.1;\n    col = mix( col, vec3(0.7,0.7,0.8), 1.0-calcAO( pos,", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n}\n\nvec3 calcNormal( in vec3 pos, in float time, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n}\n\nvec3 calcNormal( in vec3 pos, in float time, in vec3 eps )\n{\n    return normalize( eps.xyy*map( pos + eps.xyy, time ).x + \n\t\t\t\t\t  eps.yyx*map( pos + eps.yyx, time ).x + \n\t\t\t\t\t  eps.yxy*map( pos + eps.yxy, time ).x + \n\t\t\t\t\t  eps.xxx*map( pos + eps.xxx, time ).x );\n}\n\nvec3 calcNormal( in vec3 pos, in float time, in vec3 eps, in float eps2 )\n{\n    return normalize( eps.xyy*map( pos + eps.xyy, time ).x + \n\t\t\t\t\t  eps.yyx*map( pos + eps.yyx, time ).x + \n\t\t\t\t\t  eps.yxy*map( pos + eps.yxy, time ).x + \n\t\t\t\t\t  eps.xxx*map( pos + eps.xxx, time ).x );\n}\n\nvec3 calc", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, time );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n}\n\nvec3 calcColor( in vec3 pos, in vec3 nor, in float time )\n{\n    vec3 col = vec3(0.0);\n    vec3 brdf = vec3(0.0);\n    vec3 lig = normal", "\n    vec2  p_rcp = 1.0 / p;\n    vec2  dpdx_rcp = 1.0 / dpdx;\n    vec2  dpdy_rcp = 1.0 / dpdy;\n    vec2  p_fract = p - floor(p + 0.5);\n    vec2  dpdx_fract = p_fract * dpdx_rcp;\n    vec2  dpdy_fract = p_fract * dpdy_rcp;\n    float x = max( abs(dpdx_fract.x), abs(dpdy_fract.x) );\n    float y = max( abs(dpdx_fract.y), abs(dpdy_fract.y) );\n    float r = min(x, y);\n    return r;\n}\n\nfloat checkers( in vec2 p, in float scale )\n{\n    vec2  p_rcp = 1.0 / p;\n    vec2  p_fract = p - floor(p + 0.5);\n    float x = abs(p_fract.x);\n    float y = abs(p_fract.y);\n    float r = min(x, y);\n    return r;\n}\n\nfloat checkers( in vec2 p, in vec2 scale )\n{\n    vec2  p_rcp = 1.0 / p;\n    vec2  p_fract = p - floor(p + 0.5);\n    float x = abs(p_fract.x);\n    float y = abs(p_fract.y);\n    float r = min(x, y);\n    return r;\n}\n\nfloat checkers( in vec2 p, in vec2 scale, in float offset )\n{\n    vec2  p_rcp = 1.0 / p;\n    vec2  p_fract = p - floor(p + 0.5);\n    float x = abs(p_fract.x);\n    float y = abs(p_fract.y);\n    float r = min(x, y);\n", "\n    return floor(x*k)/k;\n}\n\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float n )\n{\n    return floor(x*k*n)/k/n;\n}\n\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float n, in float m )\n{\n    return floor(x*k*n*m)/k/n/m;\n}\n\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float n, in float m, in float l )\n{\n    return floor(x*k*n*m*l)/k/n/m/l;\n}\n\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float n, in float m, in float l, in float p )\n{\n    return floor(x*k*n*m*l*p)/k/n/m/l/p;\n}\n\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float n, in float m, in float l, in float p, in float q )\n{\n    return floor(x*k*n*m*l*p*q)/k/n/m/l/p/q;\n}\n\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float n, in float m, in float", "\n    vec3 sample_dir = normalize(sample_pos - surface_normal);\n    float sample_dist = length(sample_pos - surface_normal);\n    float sample_angle = dot(sample_dir, light_dir);\n    float sample_attenuation = pow(sample_angle, 100.0);\n    float sample_intensity = sample_attenuation * sample_dist;\n    return background_col * sample_intensity;\n}\n\n/*\nThis is the main function that renders the planet.\n\nIt takes in the position of the planet, the camera, the light direction, the background color, and the time.\n\nIt returns the color of the planet.\n*/\nvec3 render_planet(vec3 planet_pos, vec3 camera_pos, vec3 light_dir, vec3 background_col, float time) {\n    // Calculate the distance from the planet to the camera\n    float dist = length(planet_pos - camera_pos);\n\n    // Calculate the surface normal at the camera position\n    vec3 surface_normal = normalize(planet_pos - camera_pos);\n\n    // Calculate the color of the planet\n    vec3 planet_col = vec3(0.5, 0.5, 0.5);\n\n    // Calculate the color of the atmosphere\n    vec3 atmosphere_col = vec3(0.5, 0.5, 0.5);\n\n    // Calculate the color of the skylight\n    vec3 skylight_col = skylight(planet_pos, surface_normal, light_dir, background_col);\n\n    // Calculate the color of the planet\n    vec3 color = planet_col * (1.0 - atmosphere_col) + skylight_col * atmosphere_col;\n\n    return color;\n}\n\n/*\nThis is the main function that renders the scene.\n\nIt takes in the position of the planet, the camera, the light direction, the background color, and the time.\n\nIt returns the color of the scene.\n*/\nvec3 render_scene(vec3 planet_pos, vec3 camera_pos, vec3 light_dir, ve", "\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    float depth = 0.0;\n    float shadow = 0.0;\n    float shadow_dist = 0.0;\n    float shadow_depth = 0.0;\n    float shadow_shadow = 0.0;\n    float shadow_shadow_dist = 0.0;\n    float shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_", "\n    vec3 camera_vector = vec3(coord.x - resolution.x / 2.0, coord.y - resolution.y / 2.0, resolution.z);\n    camera_vector = normalize(camera_vector);\n    return camera_vector;\n}\n\n/*\nnow we need a way to calculate the scattering function\n\nthis function calculates the scattering function for a given camera vector\n*/\nfloat get_scattering_function(vec3 camera_vector) {\n    float scattering_function = dot(camera_vector, vec3(0.0, 0.0, 1.0));\n    scattering_function = scattering_function * scattering_function;\n    return scattering_function;\n}\n\n/*\nnow we need a way to calculate the color of the pixel\n\nthis function calculates the color of the pixel for a given scattering function\n*/\nvec3 get_color(float scattering_function) {\n    vec3 color = vec3(scattering_function, scattering_function, scattering_function);\n    return color;\n}\n\n/*\nnow we need a way to calculate the final color of the pixel\n\nthis function calculates the final color of the pixel for a given resolution and coordinate\n*/\nvec3 get_final_color(vec3 resolution, vec2 coord) {\n    vec3 camera_vector = get_camera_vector(resolution, coord);\n    float scattering_function = get_scattering_function(camera_vector);\n    vec3 color = get_color(scattering_function);\n    return color;\n}\n\n/*\nnow we need a way to calculate the final color of the pixel\n\nthis function calculates the final color of the pixel for a given resolution and coordinate\n*/\nvec3 get_final_color_2(vec3 resolution, vec2 coord) {\n    vec3 camera_vector = get_camera_vector(resolution, coord);\n    float scattering_function = get_scattering_function(camera_vector);\n    vec3 color = get_color(scattering_function);\n    return color;\n}\n\n/*\nnow we need a way to calculate the final color of the pixel\n\nthis function calculates the final color of the", "\n    float d = length(p);\n    float m2 = c.x*c.x - c.y*c.y;\n    float pz = -sqrt(max(0., 1. - m2));\n    float a = atan(c.y, c.x);\n    float sa2 = (sin(a) * sin(a) * m2 + cos(a) * cos(a)) / m2;\n    float dz = p.z - pz;\n    float b = (d*d + dz*dz - ra*ra) / (2. * d * dz);\n    b = clamp(b, -1., 1.);\n    float s = sqrt(max(0., 1. - b*b));\n    float sa = sqrt(sa2 - s*s);\n    return length(p - vec3(d*c.x, d*c.y, pz)) / sa;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb)\n{\n    float d = length(p);\n    float m2 = c.x*c.x - c.y*c.y;\n    float pz = -sqrt(max(0., 1. - m2));\n    float a = atan(c.y, c.x);\n    float sa2 = (sin(a) * sin(a) * m2 + cos(a) * cos(a)) / m2;\n    float dz = p.z - pz;\n    float b = (d*d + dz*dz - ra*ra) / (2. * d * dz);\n    b = clamp(b, -1., 1.);\n    float s = sqrt(max(0., 1. - b*b));\n    float sa = sqrt(sa2 - s*s);\n    float h = length(p - vec3(d*c.x, d*c.y, pz));\n    return (h - rb) / sa;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (material == 1) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (material == 2) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (material == 3) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (material == 4) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (material == 5) {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (material == 6) {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (material == 7) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (material == 8) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (material == 9) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (material == 10) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (material == 11) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (material == 12) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (material == 13) {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (material == 14) {\n        return vec3(0.0, 1.0, 1.0);\n", "\n    if (material == MATERIAL_GLASS) {\n        return 0.9;\n    } else if (material == MATERIAL_MIRROR) {\n        return 1.0;\n    } else {\n        return 0.0;\n    }\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    if (material == MATERIAL_GLASS) {\n        return vec3(0.9, 0.9, 0.9);\n    } else if (material == MATERIAL_MIRROR) {\n        return vec3(0.9, 0.9, 0.9);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// Get the color of a material.\nvec3 get_material_color_from_normal(vec3 normal) {\n    return normal * 0.5 + 0.5;\n}\n\n// Get the color of a material.\nvec3 get_material_color_from_normal_and_material(vec3 normal, int material) {\n    if (material == MATERIAL_GLASS) {\n        return normal * 0.5 + 0.5;\n    } else if (material == MATERIAL_MIRROR) {\n        return normal * 0.5 + 0.5;\n    } else {\n        return normal * 0.5 + 0.5;\n    }\n}\n\n// Get the color of a material.\nvec3 get_material_color_from_normal_and_material_and_position(vec3 normal, int material, vec3 position) {\n    if (material == MATERIAL_GLASS) {\n        return normal * 0.5 + 0.5;\n    } else if (material == MATERIAL_MIRROR) {\n        return normal * 0.5 + 0.5;\n    } else {\n        return normal * 0.5 + 0.5;\n    }\n}\n\n// Get the color of a material.\nvec3 get_material_color_", "\n    if (material == MATERIAL_AIR) {\n        return 1.0;\n    } else if (material == MATERIAL_GLASS) {\n        return 1.5;\n    } else if (material == MATERIAL_DIAMOND) {\n        return 2.4;\n    } else if (material == MATERIAL_WATER) {\n        return 1.33;\n    } else if (material == MATERIAL_ICE) {\n        return 1.309;\n    } else if (material == MATERIAL_GLASS_BLUE) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_RED) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_GREEN) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_YELLOW) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_PURPLE) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_CYAN) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_WHITE) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_BLACK) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_ORANGE) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_PINK) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_BROWN) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_LIGHT_BLUE) {\n        return 1.5;\n    } else if (material == MATERIAL_GLASS_LIGHT_GREEN) {\n        return 1.5;\n    } else if (", "\n    if (material == MATERIAL_AIR) {\n        return 0.0;\n    }\n    if (material == MATERIAL_GLASS) {\n        return 0.5;\n    }\n    if (material == MATERIAL_METAL) {\n        return 0.8;\n    }\n    if (material == MATERIAL_WATER) {\n        return 0.5;\n    }\n    if (material == MATERIAL_GRASS) {\n        return 0.5;\n    }\n    if (material == MATERIAL_SAND) {\n        return 0.5;\n    }\n    if (material == MATERIAL_SNOW) {\n        return 0.5;\n    }\n    if (material == MATERIAL_ROCK) {\n        return 0.5;\n    }\n    if (material == MATERIAL_DIRT) {\n        return 0.5;\n    }\n    if (material == MATERIAL_WALL) {\n        return 0.5;\n    }\n    if (material == MATERIAL_FLOOR) {\n        return 0.5;\n    }\n    if (material == MATERIAL_CEILING) {\n        return 0.5;\n    }\n    if (material == MATERIAL_WINDOW) {\n        return 0.5;\n    }\n    if (material == MATERIAL_DOOR) {\n        return 0.5;\n    }\n    if (material == MATERIAL_BED) {\n        return 0.5;\n    }\n    if (material == MATERIAL_TABLE) {\n        return 0.5;\n    }\n    if (material == MATERIAL_CHAIR) {\n        return 0.5;\n    }\n    if (material == MATERIAL_LAMP) {\n        return 0.5;\n    }\n    if (material == MATERIAL_CANDLE) {\n        return 0.5;\n    }\n    if (material == MATERIAL_", "\n    vec3 line_ab = line_b - line_a;\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 pvec = cross(line_ab, tri_ab);\n    float det = dot(tri_ac, pvec);\n    if (abs(det) < 0.0001) {\n        return vec3(0.0);\n    }\n    float inv_det = 1.0 / det;\n    vec3 tvec = line_a - tri_a;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(0.0);\n    }\n    vec3 qvec = cross(tvec, tri_ab);\n    float v = dot(line_ab, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(0.0);\n    }\n    float t = dot(tri_ac, qvec) * inv_det;\n    return vec3(1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_n) {\n    vec3 line_ab = line_b - line_a;\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 pvec = cross(line_ab, tri_ab);\n    float det = dot(tri_ac, pvec);\n    if (abs(det) < 0.0001) {\n        return vec3(0.0", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given a point and a triangle, compute the barycentric coordinates of the point\n// with respect to the triangle.\n// https://en.wikipedia.org/wiki/Barycentric_coordinate_system#targetText=Barycentric%20coordinates%20are%20a,%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20%2C%20", "\n    vec3 camera_forward = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(camera_forward, vec3(0.0, 1.0, 0.0)));\n    vec3 camera_up = normalize(cross(camera_right, camera_forward));\n\n    return mat3(camera_right, camera_up, camera_forward);\n}\n\n// Generate a perspective projection matrix based on a field of view,\n// aspect ratio, and near and far clipping planes.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix\nmat4 perspective_matrix(float fov, float aspect_ratio, float near, float far) {\n    float tan_half_fov = tan(fov / 2.0);\n    float z_range = near - far;\n\n    return mat4(\n        1.0 / (aspect_ratio * tan_half_fov), 0.0, 0.0, 0.0,\n        0.0, 1.0 / tan_half_fov, 0.0, 0.0,\n        0.0, 0.0, (-near - far) / z_range, 2.0 * near * far / z_range,\n        0.0, 0.0, 1.0, 0.0\n    );\n}\n\n// Generate a perspective projection matrix based on a field of view,\n// aspect ratio, and near and far clipping planes.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-orthographic-projection-matrix\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    float width = right - left;\n    float height = top - bottom;\n    float depth = far - near;\n\n    return mat4(\n        2.0 / width, 0.0", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = INFINITY;\n    result.triangle = -1;\n    result.intersection = vec3(0.0);\n    result.normal = vec3(0.0);\n\n    for (int i = 0; i < triangles.size(); i++) {\n        vec3 intersection;\n        vec3 normal;\n        float distance;\n        if (intersect_triangle(ray_origin, ray_target, triangles[i], intersection, normal, distance)) {\n            if (distance < result.distance) {\n                result.hit = true;\n                result.distance = distance;\n                result.triangle = i;\n                result.intersection = intersection;\n                result.normal = normal;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Check if a ray intersects a triangle.\n// If there is an intersection, return the distance to the intersection,\n// the intersection point, and the normal at the intersection.\nbool intersect_triangle(vec3 ray_origin, vec3 ray_target, triangle triangle, vec3& intersection, vec3& normal, float& distance) {\n    vec3 edge1 = triangle.v1 - triangle.v0;\n    vec3 edge2 = triangle.v2 - triangle.v0;\n    vec3 h = cross(ray_target, edge2);\n    float a = dot(edge1, h);\n    if (a > -EPSILON && a < EPSILON)\n        return false;\n    float f = 1.0 / a;\n    vec3 s = ray_origin - triangle.v0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0)\n        return false;\n    vec3 q = cross(s, edge1);\n    float v = f * dot(ray_target, q);\n    if (v < 0.0 || u + v > 1.0)\n        return false;\n    float t = f * dot(edge2, q);\n    if (t > EPSILON) {\n       ", "\n    float shadow_factor = 1.0;\n    float shadow_distance = length(light_source - ray_origin);\n    vec3 shadow_ray_direction = normalize(light_source - ray_origin);\n    vec3 shadow_ray_origin = ray_origin;\n    for (int i = 0; i < MAX_SHADOW_RAY_STEPS; i++) {\n        float shadow_distance_to_surface = scene_sdf(shadow_ray_origin);\n        if (shadow_distance_to_surface < EPSILON) {\n            shadow_factor = 0.0;\n            break;\n        }\n        shadow_ray_origin += shadow_ray_direction * shadow_distance_to_surface;\n        shadow_distance -= shadow_distance_to_surface;\n        if (shadow_distance < EPSILON) {\n            break;\n        }\n    }\n    return shadow_factor;\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray_with_opacity(vec3 ray_origin, vec3 ray_target) {\n    float shadow_factor = 1.0;\n    float shadow_distance = length(light_source - ray_origin);\n    vec3 shadow_ray_direction = normalize(light_source - ray_origin);\n    vec3 shadow_ray_origin = ray_origin;\n    for (int i = 0; i < MAX_SHADOW_RAY_STEPS; i++) {\n        float shadow_distance_to_surface = scene_sdf(shadow_ray_origin);\n        if (shadow_distance_to_surface < EPSILON) {\n            shadow_factor = 0.0;\n            break;\n        }\n        shadow_ray_origin += shadow_ray_direction * shadow_distance_to_surface;\n        shadow_distance -= shadow_distance_to_surface;\n        if (shadow_distance < EPSILON) {\n            break;\n        }\n    }\n    return shadow_factor;\n}\n\n// Cast a ray from a surface toward", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 1D noise\nfloat noise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.-2.*f);\n    return mix( bnoise(i), bnoise(i+1.0), u);\n}\n\n// 2D noise\nfloat noise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( bnoise(i.x+i.y*57.0), bnoise(i.x+1.0+i.y*57.0), u.x),\n                mix( bnoise(i.x+(i.y+1.0)*57.0), bnoise(i.x+1.0+(i.y+1.0)*57.0), u.x), u.y);\n}\n\n// 3D noise\nfloat noise( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.-2.*f);\n    return mix( mix( mix( bnoise(i.x+i.y*57.0+i.z*57.0), bnoise(i.x+1.0+i.y*57.0+i.z*57.0), u.x),\n                     mix( bnoise(i.x+i.y*57.0+(i.z+1.0)*57.0), bnoise(i.x+1.0+i.y*57.0+(i.z+1.0)*57.0), u.x), u.y),\n                mix( mix( bnoise(i.x+(i.y+1.0)*57.0+i.z*57.0), bnoise(i.x+1.0+(i.y", "\n    vec2 p2 = fract(p * vec2(127.1, 311.7));\n    p2 += dot(p2.yx, p2.xy + vec2(21.535, 147.239));\n    return fract((p2.x + p2.y) * p2.y);\n}\n\n// Gradient noise with improved contrast\nfloat gnoise( in vec2 p )\n{\n    vec2 p2 = fract(p * vec2(127.1, 311.7));\n    p2 += dot(p2.yx, p2.xy + vec2(21.535, 147.239));\n    return fract((p2.x + p2.y) * p2.y);\n}\n\n// Gradient noise with improved contrast and rotation\nfloat gnoise( in vec2 p, in float rot )\n{\n    vec2 p2 = fract(p * vec2(127.1, 311.7));\n    p2 += dot(p2.yx, p2.xy + vec2(21.535, 147.239));\n    return fract((p2.x + p2.y) * p2.y + rot);\n}\n\n// Gradient noise with improved contrast and rotation\nfloat gnoise( in vec3 p, in float rot )\n{\n    vec3 p2 = fract(p * vec3(127.1, 311.7, 191.999));\n    p2 += dot(p2.yxz, p2.xyz + vec3(21.535, 147.239, 289.154));\n    return fract((p2.x + p2.y) * p2.y + rot);\n}\n\n// Gradient noise with improved contrast and rotation\nfloat gnoise( in vec3 p, in vec3 rot )\n{\n    vec3 p2 = fract(p * vec3(127.", "\n    n = (n<<13) ^ n;\n    float f = 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;\n    return f - floor(f);\n}\n\n// 2D noise copied from Hugo Elias\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    float a = hash( i.x + hash( i.y ) );\n    float b = hash( i.x + 1.0 + hash( i.y ) );\n    float c = hash( i.x + hash( i.y + 1.0 ) );\n    float d = hash( i.x + 1.0 + hash( i.y + 1.0 ) );\n\n    vec2 cubic = f * f * (3.0 - 2.0 * f);\n\n    return mix( a, b, cubic.x ) + ( c - a ) * cubic.y * ( 1.0 - cubic.x ) + ( d - b ) * cubic.x * cubic.y;\n}\n\n// 3D noise copied from Hugo Elias\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    float a = hash( i.x + hash( i.y + hash( i.z ) ) );\n    float b = hash( i.x + 1.0 + hash( i.y + hash( i.z ) ) );\n    float c = hash( i.x + hash( i.y + 1.0 + hash( i.z ) ) );\n    float d = hash( i.x + 1.0 + hash( i.y + 1.0 + hash( i.z ) ) );\n    float e = hash( i.x + hash( i.y + hash( i.z + 1.0 ) ) );\n    float f = hash( i.x + 1.0 + hash( i", "\n    float f = floor(p);\n    float s = p - f;\n    float u = s*s*(3.-2.*s);\n\n    return mix( mix( hash(f), hash(f+1.0), u),\n                mix( hash(f+1.0), hash(f+2.0), u),\n                step(0.5,s) );\n}\n\n// gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = p - i;\n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ),\n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ),\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = p - i;\n    vec3 u = f*f*(3.-2.*f);\n\n    return mix( mix( mix( hash( i + vec3(0.0,0.0,0.0) ),\n                          hash( i + vec3(1.0,0.0,0.0) ), u.x),\n                     mix( hash( i + vec3(0.0,1.0,0.0) ),\n                          hash( i + vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( hash( i + vec3(0.0,0.0,1.0) ),\n                          hash( i + vec3(1.0,0.0,1.0) ), u.x),\n                     mix( hash( i + vec3(0.0,1.0,1.0) ),\n                          hash( i + vec3(1.0,1.0", "\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    float t = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( vec2(x,t) );\n        w *= 0.5;\n        a *= G;\n        t *= 2.0;\n        x *= 2.0;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec2 p, in float G )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    vec2  t = vec2(1.0);\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( p * t );\n        w *= 0.5;\n        a *= G;\n        t *= 2.0;\n        p *= 2.0;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec3 p, in float G )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    vec3  t = vec3(1.0);\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( p * t );\n        w *= 0.5;\n        a *= G;\n        t *= 2.0;\n        p *= 2.0;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec4 p, in float G )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    vec4  t = vec4(1.0);\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( p * t );\n        w *= 0.5;\n        a *= G;\n        t *", "\n    float t = time;\n    float r = length(p);\n    float a = r*r*r*r;\n    float b = r*r*r;\n    float c = r*r;\n    float d = r;\n    float e = 1.0;\n    float f = t;\n    float g = t*t;\n    float h = t*t*t;\n    float i = t*t*t*t;\n    float j = t*t*t*t*t;\n    float k = t*t*t*t*t*t;\n    float l = t*t*t*t*t*t*t;\n    float m = t*t*t*t*t*t*t*t;\n    float n = t*t*t*t*t*t*t*t*t;\n    float o = t*t*t*t*t*t*t*t*t*t;\n    float p = t*t*t*t*t*t*t*t*t*t*t;\n    float q = t*t*t*t*t*t*t*t*t*t*t*t;\n    float r = t*t*t*t*t*t*t*t*t*t*t*t*t;\n    float s = t*t*t*t*t*t*t*t*t*t*t*t*t*t;\n    float t = t*t*t*t*t*t*t*t*t*t*t*t*t*t*t;\n    float u = t*t*t*t*t*t*t*t*t*t*t*t*t*t*t*t;\n    float v = t*t*t*t*t*t*t*t*t*t*t*t*t*t*t*t*t;\n    float w = t*t*t*t*t*t*t*t*t*t*t*t*t*t*t*t*t*t;\n    float x = t*t*t*t*t*", "\n    vec3 p = pb * 0.5 + 0.5;\n    vec3 c = vec3(0.0);\n    float a = p.x;\n    float b = p.y;\n    float c = p.z;\n    float d = 1.0 - a*a - b*b - c*c;\n    if( d > 0.0 )\n    {\n        d = sqrt(d);\n        float e = a*b;\n        float f = a*c;\n        float g = b*c;\n        float h = a*d;\n        float i = b*d;\n        float j = c*d;\n        float k = a*e;\n        float l = b*e;\n        float m = c*e;\n        float n = a*f;\n        float o = b*f;\n        float p = c*f;\n        float q = a*g;\n        float r = b*g;\n        float s = c*g;\n        float t = a*h;\n        float u = b*h;\n        float v = c*h;\n        float w = a*i;\n        float x = b*i;\n        float y = c*i;\n        float z = a*j;\n        float A = b*j;\n        float B = c*j;\n        float C = a*k;\n        float D = b*k;\n        float E = c*k;\n        float F = a*l;\n        float G = b*l;\n        float H = c*l;\n        float I = a*m;\n        float J = b*m;\n        float K = c*m;\n        float L = a*n;\n        float M = b*n;\n        float N = c*n;\n        float O = a*o;\n        float P = b*o;\n        float Q = c*o;\n        float R = a*p;\n        float S = b*p;\n        float T = c*p;\n        float U = a*q;\n        float V = b*q;\n        float W = c*q;\n        float", "\n    vec3 m = ro - cen;\n    vec3 n = m * (rd / (abs(m) + rad));\n    float s = length(max(n,0.0));\n    float l = length(m+n*s) - rad.x;\n    float h = sqrt( s*(s+2.0*l) );\n    vec2 res = vec2( -1.0, 0.0 );\n    res.x = min( res.x, l );\n    res.x = min( res.x, h );\n    res.y = min( res.y, h );\n    return vec4( res, s );\n}\n\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) \n{\n    vec3 m = ro - cen;\n    vec3 n = m * (rd / (abs(m) + rad));\n    float s = length(max(n,0.0));\n    float l = length(m+n*s) - rad.x;\n    float h = sqrt( s*(s+2.0*l) );\n    vec2 res = vec2( -1.0, 0.0 );\n    res.x = min( res.x, l );\n    res.x = min( res.x, h );\n    res.y = min( res.y, h );\n    if ( res.x > tmax ) return vec4( -1.0 );\n    return vec4( res, s );\n}\n\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmin, in float tmax ) \n{\n    vec3 m = ro - cen;\n    vec3 n = m * (rd / (abs(m) + rad));\n    float s = length(max(n,0.0));\n    float l = length(m+n*s) - rad.x;\n    float h = sqrt( s*(s+2.0*l", "\n    vec3 m = (ro-cen)/rd;\n    vec3 n = m - rad;\n    float p = max( max( n.x, n.y ), n.z );\n    float b = min( min( m.x, m.y ), m.z );\n    float d = max( p, b );\n    return d;\n}\n\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = (ro-cen)/rd;\n    vec3 n = m - rad;\n    float p = max( max( n.x, n.y ), n.z );\n    float b = min( min( m.x, m.y ), m.z );\n    float d = max( p, b );\n    return d;\n}\n\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, out float t ) \n{\n    vec3 m = (ro-cen)/rd;\n    vec3 n = m - rad;\n    float p = max( max( n.x, n.y ), n.z );\n    float b = min( min( m.x, m.y ), m.z );\n    float d = max( p, b );\n    t = d;\n    return d;\n}\n\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, out float t, out float t2 ) \n{\n    vec3 m = (ro-cen)/rd;\n    vec3 n = m - rad;\n    float p = max( max( n.x, n.y ), n.z );\n    float b = min( min( m.x, m.y ), m.z );\n    float d = max( p, b );\n    t = d;\n    t2 = d;\n    return d;\n}\n\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, out float t", "\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e20;\n    for( int i=0; i<100; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 32.0*d/max(0.001,t) );\n        ph = h;\n        t += h;\n        if( res<0.001 || t>tmax )\n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e20;\n    for( int i=0; i<100; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 32.0*d/max(0.001,t) );\n        ph = h;\n        t += h;\n        if( res<0.001 || t>tmax )\n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//------------------------------------------------------------------\n//", " seed = seed * 1.1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//", "\n    p.xz *= mat2(cos(ra), sin(ra), -sin(ra), cos(ra));\n    vec2 b = vec2(la, lb);\n    p.xz = abs(p.xz) - b;\n    p.xz.x *= 0.57735027;\n    p.xz.y *= 0.57735027;\n    p.xz -= clamp(dot(p.xz, vec2(b.x / b.y, b.y / b.x)), 0.0, 1.0) * vec2(b.x / b.y, b.y / b.x);\n    return length(p.xz) * sign(p.y - h);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p.xz *= mat2(cos(ra), sin(ra), -sin(ra), cos(ra));\n    vec2 b = vec2(la, lb);\n    p.xz = abs(p.xz) - b;\n    p.xz.x *= 0.57735027;\n    p.xz.y *= 0.57735027;\n    p.xz -= clamp(dot(p.xz, vec2(b.x / b.y, b.y / b.x)), 0.0, 1.0) * vec2(b.x / b.y, b.y / b.x);\n    return length(p.xz) * sign(p.y - h);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p.xz *= mat2(cos(ra), sin(ra), -sin(ra), cos(ra));\n    vec", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 c = a + h*ba;\n    float s = dot( pa, vec2( -ba.y, ba.x ) );\n    float t = dot( pa, vec2( ba.y, -ba.x ) );\n    float d = sqrt( s*s + t*t );\n    float bx = clamp( (d-r)/band, 0.0, 1.0 );\n    float k = clamp( (d-r)/r, 0.0, 1.0 );\n    float x = d*k + bx*(1.0-k);\n    float y = (r-d)*(1.0-k) + bx*k;\n    float z = x+y;\n    float w = sqrt( dot(p-c,p-c) ) - r;\n    return vec4( x, y, z, w );\n}\n\nvec4 paCircle( in vec2 p, vec2 c, float r, float band )\n{\n    float d = length(p-c) - r;\n    float x = clamp( (d+r)/band, 0.0, 1.0 );\n    float y = clamp( (d-r)/band, 0.0, 1.0 );\n    float z = x+y;\n    float w = d;\n    return vec4( x, y, z, w );\n}\n\nvec4 paRect( in vec2 p, vec2 c, vec2 s, float band )\n{\n    vec2 d = abs(p-c) - s;\n    float x = max( d.x, d.y );\n    float y = max( d.x+s.y, d.y+s.x );\n    float z = x+y;\n    float w = max( d.x, d.y );\n    return vec4( x, y, z, w );\n}\n\nvec", "\n    p = abs(p)-b+r;\n    vec2 q = abs(p+s)-s;\n    return vec4( length(max(vec2(0.0),p)) + min(max(p.x,p.y),0.0),\n                 length(max(vec2(0.0),q)) + min(max(q.x,q.y),0.0),\n                 length(p) + length(q) - r,\n                 length(max(vec2(0.0),p)) + length(max(vec2(0.0),q)) );\n}\n\nvec4 paBox( in vec3 p, \n            in vec3 b, in float r, \n            in float s )\n{\n    p = abs(p)-b+r;\n    vec3 q = abs(p+s)-s;\n    return vec4( length(max(vec3(0.0),p)) + min(max(p.x,max(p.y,p.z)),0.0),\n                 length(max(vec3(0.0),q)) + min(max(q.x,max(q.y,q.z)),0.0),\n                 length(p) + length(q) - r,\n                 length(max(vec3(0.0),p)) + length(max(vec3(0.0),q)) );\n}\n\nvec4 paBox( in vec4 p, \n            in vec4 b, in float r, \n            in float s )\n{\n    p = abs(p)-b+r;\n    vec4 q = abs(p+s)-s;\n    return vec4( length(max(vec4(0.0),p)) + min(max(p.x,max(p.y,max(p.z,p.w))),0.0),\n                 length(max(vec4(0.0),q)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0),\n                 length(p) + length(q) - r,\n                 length(max(vec4(0", "\n    vec2 d = abs(p)-b;\n    vec2 dd = max(d,0.0);\n    float m = min(max(d.x,d.y),0.0);\n    float s = m+length(dd);\n    vec2 r = vec2(s,m);\n    vec3 res = vec3(r.x,r.x>0.0?r.yx:r.xy);\n    res.z = sdBox(p,b);\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    vec3 dd = max(d,0.0);\n    float m = min(max(d.x,max(d.y,d.z)),0.0);\n    float s = m+length(dd);\n    vec2 r = vec2(s,m);\n    vec3 res = vec3(r.x,r.x>0.0?r.yx:r.xy);\n    res.z = sdBox(p,b);\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c )\n{\n    vec3 q = abs(p)-b;\n    vec3 qq = max(q,0.0);\n    float m = min(max(q.x,max(q.y,q.z)),0.0);\n    float s = m+length(qq);\n    ve", "\n    float d = length(p)-r;\n    float a = atan(p.y,p.x);\n    float da = abs(a-PI*0.5);\n    float b = abs(a-PI);\n    float x = (da<PI*0.5)? d : length(p-vec2(sign(p.x)*r,0.0));\n    float y = (b<PI*0.5)? d : length(p-vec2(0.0,sign(p.y)*r));\n    float z = min(x,y);\n    float w = (z<band)? length(p)-r : d;\n    return vec4(x,y,z,w);\n}\n\nvec4 paCircle( in vec2 p, float r ) \n{\n    float d = length(p)-r;\n    float a = atan(p.y,p.x);\n    float da = abs(a-PI*0.5);\n    float b = abs(a-PI);\n    float x = (da<PI*0.5)? d : length(p-vec2(sign(p.x)*r,0.0));\n    float y = (b<PI*0.5)? d : length(p-vec2(0.0,sign(p.y)*r));\n    float z = min(x,y);\n    float w = d;\n    return vec4(x,y,z,w);\n}\n\nvec4 paCircle( in vec2 p, float r, float band, float smoothing ) \n{\n    float d = length(p)-r;\n    float a = atan(p.y,p.x);\n    float da = abs(a-PI*0.5);\n    float b = abs(a-PI);\n    float x = (da<PI*0.5)? d : length(p-vec2(sign(p.x)*r,0.0));\n    float y = (b<PI*0.5)? d : length(p-vec2(0.0,sign(p.y)*r));\n    float z = min(x", "\n    float d = dot(p,verts[0]);\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i]-verts[0];\n        vec2 w = p-verts[0];\n        float b = dot(w,v);\n        float c = dot(v,v);\n        float dd = b*b/c;\n        float e = c*d-b*b;\n        if( dd>r*r && e>r*r ) return sqrt(dd)-r;\n        if( e>0.0 )\n        {\n            float da = acos(b/sqrt(c));\n            if( d>0.0 ) da = 2.0*PI-da;\n            float l = sqrt(c)-b;\n            float h = sqrt(r*r-e);\n            float dc = l*cos(da) - h*sin(da);\n            if( dc<d ) d = dc;\n        }\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5] ) \n{\n    float d = dot(p,verts[0]);\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i]-verts[0];\n        vec2 w = p-verts[0];\n        float b = dot(w,v);\n        float c = dot(v,v);\n        float dd = b*b/c;\n        float e = c*d-b*b;\n        if( dd>r*r && e>r*r ) return sqrt(dd)-r;\n        if( e>0.0 )\n        {\n            float da = acos(b/sqrt(c));\n            if( d>0.0 ) da = 2.0*PI-da;\n            float l = sqrt(c)-b;\n            float h = sqrt(r*r-e);\n            float dc = l*cos(da) - h*sin(da);\n            if", "\n    vec2 d = p;\n    float dd = dot(d,d);\n    float dd2 = dd*dd;\n    float dd3 = dd2*dd;\n    float dd4 = dd2*dd2;\n    float dd5 = dd4*dd;\n    float dd6 = dd4*dd2;\n    float dd7 = dd6*dd;\n    float dd8 = dd4*dd4;\n    float dd9 = dd8*dd;\n    float dd10 = dd8*dd2;\n    float dd11 = dd10*dd;\n    float dd12 = dd8*dd4;\n    float dd13 = dd12*dd;\n    float dd14 = dd12*dd2;\n    float dd15 = dd14*dd;\n    float dd16 = dd12*dd4;\n    float dd17 = dd16*dd;\n    float dd18 = dd16*dd2;\n    float dd19 = dd18*dd;\n    float dd20 = dd16*dd4;\n    float dd21 = dd20*dd;\n    float dd22 = dd20*dd2;\n    float dd23 = dd22*dd;\n    float dd24 = dd20*dd4;\n    float dd25 = dd24*dd;\n    float dd26 = dd24*dd2;\n    float dd27 = dd26*dd;\n    float dd28 = dd24*dd4;\n    float dd29 = dd28*dd;\n    float dd30 = dd28*dd2;\n    float dd31 = dd30*dd;\n    float dd32 = dd28*dd4;\n    float dd33 = dd32*dd;\n    float dd34 = dd32*dd2", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa - ba*h), -ba, pa - ba*h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    return vec3( length(d) - r, normalize(d), d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return vec3( max(d.x,d.y), normalize(d), d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(vec2(0.0), q)) + min(max(q.x, q.y), 0.0);\n    return vec3( d - r, normalize(q), q );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//", "\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p.x = abs(p.x) - r;\n    p.y = p.y + 0.5*r;\n    vec2 w = vec2( length(p.x*k.xy), p.y*k.z - p.x*k.y );\n    vec2 r0 = vec2( p.x, p.y - r );\n    vec2 r1 = vec2( p.x, p.y + r );\n    vec2 r2 = vec2( p.x - 2.0*r, p.y );\n    vec2 r3 = vec2( p.x + 2.0*r, p.y );\n    vec2 r4 = vec2( p.x - r, p.y - 2.0*r );\n    vec2 r5 = vec2( p.x + r, p.y - 2.0*r );\n    vec2 r6 = vec2( p.x - r, p.y + 2.0*r );\n    vec2 r7 = vec2( p.x + r, p.y + 2.0*r );\n    vec2 q = vec2( min(min(min(min(min(min(dot(r0,r0),dot(r1,r1)),dot(r2,r2)),dot(r3,r3)),dot(r4,r4)),dot(r5,r5)),dot(r6,r6)),dot(r7,r7) );\n    float s = (r0.x<0.0 && r0.y<0.0) || (r1.x>0.0 && r1.y<0.0) || (r2.x<0.0 && r2.y>0.0) || (r3.x>0.0 && r3.y>0.0) || (r4.x<0.0 && r4.y<0.0", "\n    vec3 pXp = p * X;\n    float a = dot(pXp, p);\n    float b = dot(pXp, p + p);\n    float d = b*b - 4.0*a;\n    if (d < 0.0) return false;\n    d = sqrt(d);\n    vec3 p1 = (-b - d) / (2.0*a) * p;\n    vec3 p2 = (-b + d) / (2.0*a) * p;\n    tan1 = normalize(p1 - p);\n    tan2 = normalize(p2 - p);\n    return true;\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2) {\n    vec3 pXp = p * X;\n    float a = dot(pXp, p);\n    float b = dot(pXp, p + p);\n    float d = b*b - 4.0*a;\n    if (d < 0.0) return false;\n    d = sqrt(d);\n    vec3 p1 = (-b - d) / (2.0*a) * p;\n    vec3 p2 = (-b + d) / (2.0*a) * p;\n    tan1 = normalize(p1 - p);\n    tan2 = normalize(p2 - p);\n    return true;\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2) {\n    vec3 pXp = p * X;\n    float a = dot(pXp, p);\n    float b = dot(pXp, p + p);\n    float d = b*b - 4.0*a;\n", "\n    if (b.x == 0.0) {\n        b.x = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 a)\n{\n    return RotateX(RotateY(RotateZ(p, a.z), a.y), a.x);\n}\n\nvec3 Translate(vec3 p, vec3 t)\n{\n    return p - t;\n}\n\nvec3 Scale(vec3 p, vec3 s)\n{\n    return p * s;\n}\n\nvec3 Scale(vec3 p, float s)\n{\n    return p * s;\n}\n\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return vec3(p.x * sx, p.y * sy, p.z * sz);\n}\n\nvec3 Scale(vec3 p, vec3 s)\n{\n    return vec3(p.x * s.x, p.y * s.y, p.z * s.z);\n}\n\nvec3 Scale(vec3 p, float sx, float sy)\n{\n    return vec3(p.x * sx, p.y * sy, p.z);\n}\n\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return vec3(p.", "\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float x4 = x2 * x2;\n    float x5 = x4 * x;\n    float x6 = x4 * x2;\n    float x7 = x6 * x;\n    float x8 = x4 * x4;\n    float x9 = x8 * x;\n    float x10 = x8 * x2;\n    float x11 = x10 * x;\n    float x12 = x8 * x4;\n    float x13 = x12 * x;\n    float x14 = x12 * x2;\n    float x15 = x14 * x;\n    float x16 = x12 * x4;\n    float x17 = x16 * x;\n    float x18 = x16 * x2;\n    float x19 = x18 * x;\n    float x20 = x16 * x4;\n    float x21 = x20 * x;\n    float x22 = x20 * x2;\n    float x23 = x22 * x;\n    float x24 = x20 * x4;\n    float x25 = x24 * x;\n    float x26 = x24 * x2;\n    float x27 = x26 * x;\n    float x28 = x24 * x4;\n    float x29 = x28 * x;\n    float x30 = x28 * x2;\n    float x31 = x30 * x;\n    float x32 = x28 * x4;\n    float x33 = x32 * x;\n    float x34 = x32 * x2;\n    float x35 = x34 * x;\n    float x36 = x32 * x4;\n    float x37 = x36 * x;\n    float x38 = x36 * x2;\n    float x39 = x38 * x;\n    float x40 = x36 * x4;\n    float x4", "\n    return 1.0f / (1.0f - e) * R;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float e0)\n{\n    return 1.0f / (1.0f - e) * R * (e0 / e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float e0, float e1)\n{\n    return 1.0f / (1.0f - e) * R * (e0 / e) * (e1 / e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float e0, float e1, float e2)\n{\n    return 1.0f / (1.0f - e) * R * (e0 / e) * (e1 / e) * (e2 / e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float e0, float e1, float e2, float e3)\n{\n    return 1.0f / (1.0f - e) * R * (e0 / e) * (e1 / e) * (e2 / e) * (e3 / e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float e0, float e1, float e2, float e3, float e4)\n{\n    return 1.0f / (1.0f - e) * R * (e0 / e) * (e1 / e) * (e2 / e) * (e3 / e) * (e4 / e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e:", "\n    float k = (a - b) / (R * R);\n    return k * (1.0f - e) + b;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float e0)\n{\n    float k = (a - b) / (R * R);\n    return k * (1.0f - e) + b;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float e0, float e1)\n{\n    float k = (a - b) / (R * R);\n    return k * (1.0f - e) + b;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float e0, float e1, float e2)\n{\n    float k = (a - b) / (R * R);\n    return k * (1.0f - e) + b;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float e0, float e1, float e2, float e3)\n{\n    float k = (a - b) / (R * R);\n    return k * (1.0f - e) + b;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b,", "\n    float d = length(p - c) - R;\n    return e * (1.0 - smoothstep(0.0, 1.0, d));\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c) - R;\n    return e * (1.0 - smoothstep(0.0, 1.0, d));\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Box(vec3 p, vec3 c, float R, float e)\n{\n    vec3 d = abs(p - c) - R;\n    return e * (1.0 - smoothstep(0.0, 1.0, max(d.x, max(d.y, d.z))));\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n    vec2 d = abs(vec2(length(p.xz - c.xz), p.y - c.y)) - R;\n    return e * (1.0 - smoothstep(0.0, 1.0, max(d.x, d.y)));\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n    vec2 d = vec2(length(p.xz - c.xz), p.y - c.y);\n    return e * (1.0 - smoothstep(0.0, 1.0, max(d.x - d.y, d.x / R)));\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    float ab2 = dot(ab, ab);\n    float ac2 = dot(ac, ac);\n    float abac = dot(ab, ac);\n    float R2 = R * R;\n    float e2 = e * e;\n    float eab2 = e2 * ab2;\n    float eac2 = e2 * ac2;\n    float eabac = e2 * abac;\n    float eabac2 = eabac * eabac;\n    float eabac4 = eabac2 * eabac2;\n    float eabac6 = eabac4 * eabac2;\n    float eabac8 = eabac6 * eabac2;\n    float eabac10 = eabac8 * eabac2;\n    float eabac12 = eabac10 * eabac2;\n    float eabac14 = eabac12 * eabac2;\n    float eabac16 = eabac14 * eabac2;\n    float eabac18 = eabac16 * eabac2;\n    float eabac20 = eabac18 * eabac2;\n    float eabac22 = eabac20 * eabac2;\n    float eabac24 = eabac22 * eabac2;\n    float eabac26 = eabac24 * eabac2;\n    float eabac28 = eabac26 * eabac2;\n    float eabac30 = eabac28 * eabac2;\n    float eabac32 = eabac30 * eabac2;\n    float eabac34 = eabac32 * eabac2;\n    float eabac36 = eabac34 * eabac2;\n    float eabac38 = eabac36 * eabac2;\n    float eabac40 = eabac38 * eabac2;\n    float eabac", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d", "\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k)\n{\n    return pow(length(a - b), k);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r)\n{\n    return pow(length(a - b) + r, k);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s)\n{\n    return pow(length(a - b) + r, k) + s;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s, float t)\n{\n    return pow(length(a - b) + r, k) + s + t;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s, float t, float u)\n{\n    return pow(length(a - b) + r, k) + s + t + u;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s, float t, float u, float v)\n{\n    return pow(length(a - b) + r, k) + s + t + u + v;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s, float t, float u, float v, float w)\n{\n    return pow(length(a - b) + r, k) + s + t + u + v + w;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s, float t, float u, float v, float w, float x)\n{\n    return pow(length(a - b) + r, k) + s + t + u + v + w + x;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float r, float s, float t, float u, float v", "\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ).x );\n}\n\n// Raymarching\nvec3 Raymarch( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n\n    float t = tmin;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        if( h<0.001*t || t>tmax ) break;\n        t += h;\n    }\n\n    // lighting\n    vec3 col = vec3(0.8,0.9,1.0) - 0.75*vec3(0.4,0.5,0.6)*rd.y;\n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = ObjectNormal(pos);\n        vec3 ref = reflect( rd, nor );\n        float dif = clamp( dot( nor, vec3(0.0,1.0,0.0) ), 0.0, 1.0 );\n        float spe = pow( clamp( dot( ref, vec3(0.0,1.0,0.0) ), 0.0, 1.0 ), 32.0 );\n        col = vec3(0.6,0.7,1.0)*dif + 1.5*vec3(1.0,0.9,0.8)*spe;\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\n", "\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = length(p) - 1.0;\n        if (d < 0.001)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayMarching(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = length(p) - 1.0;\n        if (d < 0.001)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayMarching(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = length(p) - 1.0;\n        if (d < 0.001)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Ray", "\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + u * t;\n        float d = map(p);\n        if (d < EPS)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Tracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + u * t;\n        float d = map(p);\n        if (d < EPS)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Tracing(vec3 o, vec3 u, out bool h, out int s, out float d)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + u * t;\n        d = map(p);\n        if (d < EPS)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n        s++;\n    }\n    return t", "\n    return vec3(0.0);\n}\n\nvec3 Surface(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro + rd * t;\n    vec3 n = normalize(p);\n    return vec3(0.5 + 0.5 * n.y);\n}\n\nvec3 Shade(vec3 ro, vec3 rd, float t)\n{\n    return Surface(ro, rd, t);\n}\n\n// Raymarching functions\nfloat Distance(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat Raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        float d = Distance(ro + rd * t);\n        if (d < 0.001)\n            return t;\n        t += d;\n    }\n    return -1.0;\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t = Raymarch(ro, rd);\n    if (t < 0.0)\n        fragColor = vec4(Background(rd), 1.0);\n    else\n        fragColor = vec4(Shade(ro, rd, t), 1.0);\n}", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0)? -min(x2, y2) : (((x > 0.0)? x2 : 0.0) + ((y > 0.0)? y2 : 0.0));\n    return sqrt(d) * sign(max(x, y));\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x2 = paba * paba - baba * (dot(pa, pa) - r1 * r1);\n    float y = sqrt(max(x2, 0.0)) - baba * 0.5;\n    float x = max(paba - baba * 0.5, -r1);\n    float x3 = x * x + y * y;\n    float d = (max(x, y) < 0.0)? -min(x2, x3) : (((x > 0.0)? x2 : 0.0) + ((y > 0.0)? x3 : 0.0));\n    return sqrt(d + paba * baba) * sign(max(x, y));\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * (ro - pos);\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos, in vec3 rot ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * (ro - pos);\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos, in vec3 rot, in ve", "\n    return (coord - 0.5) * 2.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size) {\n    return (coord - 0.5) * 2.0 / size;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset) {\n    return (coord - offset - 0.5) * 2.0 / size;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale) {\n    return (coord - offset - 0.5) * 2.0 / size * scale;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate) {\n    return (coord - offset - 0.5) * 2.0 / size * scale * rotate;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 skew) {\n    return (coord - offset - 0.5) * 2.0 / size * scale * rotate * skew;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 skew, vec2 translate) {\n    return (coord - offset - 0.5) * 2.0 / size * scale * rotate * skew * translate;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 skew, vec2 translate, vec2 anchor) {\n    return (coord - offset - 0.5) * 2.0 / size * scale * rotate * skew * translate * anchor;\n}\n\n// normalized fragment coordinate\nvec2 u", "\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ) );\n    return vec3(sqrt(d.x), d.y, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 q, in vec2 r )\n{\n    vec2 e0 = r-q;\n    vec2 e1 = q-p;\n    vec2 e2 = p-r;\n    vec2 v0 = p-r;\n    vec2 v1 = q-r;\n    vec2 v2 = r-p;\n    vec2 e02 = e0*e0;\n    vec2 e12 = e1*e1;\n    vec2 e22 = e2*e2;\n    vec2 v02 = v0*v0;\n    vec2 v12 = v1*v1;\n    vec2 v22 = v2*v2;\n    vec2 e0e1 = e0*e1;\n    vec2 e0e2 = e0*e2;\n    vec2 e1e2 = e1*e2;\n    vec2 v0v1 = v0*v1;\n    vec2 v", "\n    vec2 q = p;\n    q.x = abs(q.x) - r;\n    q.y = abs(q.y) - d;\n    float r2 = r * r;\n    float d2 = d * d;\n    float r2d2 = r2 * d2;\n    float r2d2_2 = r2d2 * 0.5;\n    float r2d2_4 = r2d2_2 * 0.5;\n    float r2d2_6 = r2d2_4 * 0.5;\n    float r2d2_8 = r2d2_6 * 0.5;\n    float r2d2_10 = r2d2_8 * 0.5;\n    float r2d2_12 = r2d2_10 * 0.5;\n    float r2d2_14 = r2d2_12 * 0.5;\n    float r2d2_16 = r2d2_14 * 0.5;\n    float r2d2_18 = r2d2_16 * 0.5;\n    float r2d2_20 = r2d2_18 * 0.5;\n    float r2d2_22 = r2d2_20 * 0.5;\n    float r2d2_24 = r2d2_22 * 0.5;\n    float r2d2_26 = r2d2_24 * 0.5;\n    float r2d2_28 = r2d2_26 * 0.5;\n    float r2d2_30 = r2d2_28 * 0.5;\n    float r2d2_32 = r2d2_30 * 0.5;\n    float r2d2_34 = r2d2_32 * 0.5;\n    float r2d2_36 = r2d2_34 * 0.5;\n    float r2d2_38 = r2d2_36", "\n    p.x = abs(p.x);\n    vec2 d = p-c*r;\n    float l = length(d);\n    vec2 a = d/l;\n    float m = l*r;\n    float n = m*c.x;\n    float k = m*c.y;\n    float x = sqrt(abs(n*n+k*k));\n    float y = atan(k,n);\n    float s = sign(a.x*c.y+a.y*c.x);\n    float e = s*sign(y);\n    float z = s*sign(sqrt(abs(n*n+k*k)-r*r));\n    return vec3(sqrt(l*l+z*z)-r,vec2(a.x*e,a.y*e));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec3 p, in vec2 c, in float r )\n{\n    p.xz = abs(p.xz);\n    vec2 d = p.xz-c*r;\n    float l = length(d);\n    vec2 a = d/l;\n    float m = l*r;\n    float n = m*c.x;\n    float k = m*c.y;\n    float x = sqrt(abs(n*n+k*k));\n    float y = atan(k,n);\n    float s = sign(a.x*c.y+a.y*c.x);\n    float e = s*sign(y);\n    float z = s*sign(sqrt(abs(n*n+k*k)-r*r));\n    return vec3(sqrt(l*l+z*z)-r,vec2(a.x*e,a.y*e));", "\n    vec2 e0 = v[1]-v[0];\n    vec2 e1 = v[2]-v[1];\n    vec2 e2 = v[0]-v[2];\n    vec2 v0 = p - v[0];\n    vec2 v1 = p - v[1];\n    vec2 v2 = p - v[2];\n    vec3 e01 = vec3(e0, dot(e0,v0));\n    vec3 e12 = vec3(e1, dot(e1,v1));\n    vec3 e20 = vec3(e2, dot(e2,v2));\n    vec3 v01 = vec3(v0, dot(v0,e0));\n    vec3 v12 = vec3(v1, dot(v1,e1));\n    vec3 v20 = vec3(v2, dot(v2,e2));\n    vec3 d = max(max(max(max(max(max(e01,e12),e20),v01),v12),v20),0.0);\n    return vec3(d.z*d.z*0.25/d.x, d.yz*sign(d.yz.y));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p-c;\n    float l = length(d);\n    return vec3(l-r, d/l);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = ", "\n    p.x = abs(p.x);\n    vec2 ba = sca - scb;\n    float f = clamp( dot(ba,ba), 0.0, 1.0 );\n    float k = (ra*ra-rb*rb+f*f)/(2.0*f);\n    vec2  c = sca + k*ba;\n    vec2  h = sqrt(ra*ra-k*k);\n    vec2  v = normalize(vec2(-h.y*ba.x,h.x*ba.x)-c);\n    vec2  w = p-c;\n    float d = dot(w,v);\n    vec2  q = w-d*v;\n    float s = (v.x*q.y-v.y*q.x);\n    float l = s/length(q);\n    float m = c.x + sign(s)*clamp(l, -h.x, h.y)/length(v);\n    float n = c.y + sign(s)*clamp(l, -h.y, h.x)/length(v);\n    float d1 = dot(p-vec2(m,n),p-vec2(m,n));\n    float d2 = (p.x-m)*(p.x-m)+(p.y-n)*(p.y-n);\n    float d3 = d1+d2;\n    float d4 = d1-d2;\n    float e = clamp(d4,-d3,d3);\n    float g = sqrt(d1*d1+e*e);\n    float r = sign(e)*g-ra;\n    float a = atan(q.y,q.x);\n    float b = atan(v.y,v.x);\n    float c1 = abs(a-b);\n    float c2 = 2.0*PI-c1;\n    float c3 = min(c1,c2);\n    float s1 = sign(sin(a)*cos(b)-cos(a)*sin(b));\n    float s2 = sign(sin(", " return a.x*b.y - a.y*b.x; }\nfloat dot2( in vec2 a ) { return dot(a,a); }\nfloat dot2( in vec3 a ) { return dot(a,a); }\nfloat dot2( in vec4 a ) { return dot(a,a); }\nfloat dot2( in vec2 a, in vec2 b ) { return dot(a,b); }\nfloat dot2( in vec3 a, in vec3 b ) { return dot(a,b); }\nfloat dot2( in vec4 a, in vec4 b ) { return dot(a,b); }\nfloat dot2( in vec2 a, in vec4 b ) { return dot(a,b.xy); }\nfloat dot2( in vec3 a, in vec4 b ) { return dot(a,b.xyz); }\nfloat dot2( in vec4 a, in vec2 b ) { return dot(a.xy,b); }\nfloat dot2( in vec4 a, in vec3 b ) { return dot(a.xyz,b); }\nfloat dot2( in vec4 a, in vec4 b ) { return dot(a.xyz,b.xyz); }\nfloat dot2( in vec2 a, in vec2 b, in vec2 c ) { return dot(a,b) + dot(a,c); }\nfloat dot2( in vec3 a, in vec3 b, in vec3 c ) { return dot(a,b) + dot(a,c); }\nfloat dot2( in vec4 a, in vec4 b, in vec4 c ) { return dot(a,b) + dot(a,c); }\nfloat dot2( in vec2 a, in vec2 b, in vec2 c, in vec2 d ) { return dot(a,b) + dot(a,c) + dot(a,d); }\nfloat dot2( in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return dot(a,b) + dot(a", "\n    p = p*2.0 - 1.0;\n    vec2 p2 = p*p;\n    vec2 a2 = ab*ab;\n    vec2 p2a2 = p2/a2;\n    float f = dot(p2a2,p2a2);\n    vec3 g = vec3(p.x*p2a2.x, p.y*p2a2.y, 1.0);\n    return vec3(f, g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( vec2 p, float r )\n{\n    p = p*2.0 - 1.0;\n    float f = dot(p,p) - r*r;\n    vec3 g = vec3(p, 0.0);\n    return vec3(f, g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( vec2 p, vec2 b )\n{\n    p = p*2.0 - 1.0;\n    vec2 d = abs(p) - b;\n    float f = max(d.x,d.y);\n    vec3 g = vec3(p.x, p.y, 0.0);\n    return vec3(f, g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRoundBox( vec2 p,", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,normalize(vec3(q,p.x)));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2(length(p.xz)-2.0*ra+rb,abs(p.y)-h);\n    return vec4(min(max(d.x,d.y),0.0) + length(max(d,0.0)), normalize(vec3(d.x>0.0? p.xz : vec2(p.z,-p.x), 0.0)));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float ra, float rb, float h )\n{\n    float m2 = (rb-ra)/h;\n    m2 *= m2;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 d = vec2( length(q-vec2(clamp(dot(q,vec2(m2,1.0)),0.0,ra),0.0))*sign(q.y-ra), q.y-clamp(q.y,ra,ra+h) );\n    vec2 s = -sign(d.yx);\n    d.x = s.x*sqrt(d", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r, -ba, h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4( length(p) - r, p );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec4( length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0), sign(p) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return vec4( length(q)-t.y, normalize(vec3(q,p.x)) );\n}\n\n//", "\n    p.x = abs(p.x) - wi;\n    p.y = abs(p.y) - he;\n    p.x = max(p.x,p.y*sk);\n    return ( (p.x+p.y*sk)*0.5 );\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    p.x = abs(p.x) - wi;\n    p.y = abs(p.y) - he;\n    p.x = max(p.x,p.y*sk);\n    return ( (p.x+p.y*sk)*0.5 );\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    p.x = abs(p.x) - wi;\n    p.y = abs(p.y) - he;\n    p.x = max(p.x,p.y*sk);\n    return ( (p.x+p.y*sk)*0.5 );\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    p.x = abs(p.x) - wi;\n    p.y = abs(p.y) - he;\n    p.x = max(p.x,p.y*sk);\n    return ( (p.x+p.y*sk)*0.5 );\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_5( in vec2 p, float wi, float he, float sk )\n{\n    p.x = abs(p.x) - wi;\n    p.y = abs(p.y) - he;\n    p.x =", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    vec2 q = p - vec2(clamp(p.x,0.0,wi), clamp(p.y,0.0,he));\n    float s = -sign(p.y-he);\n    float t = s*(p.x-wi);\n    float h = max(q.x,q.y);\n    float d = (h<0.0)? length(q) : (h>wi)? he+h : he;\n    return vec3( d, s*sign(t), s*sign(h-wi) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he )\n{\n    return sdgParallelogram( p, wi, he, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he, float sk, out float s )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    vec2 q = p - vec2(clamp(p.x,0.0,wi), clamp(p.y,0.0,he));\n    s = -sign(p.y-he);\n    float t = s*(p.x-wi);\n    float h = max(q.x,q.y);\n    float d = (h<0.0)? length(q) : (h>wi)? he+h : he;\n    return vec3( d", "\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep7D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep8D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep9D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep10D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep11D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep12D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep13D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep14D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep15D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\n// IQ's polynominal min\nvec2 pmin(vec2 a, vec2 b, float k) {\n    vec2 h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's polynominal max\nvec2 pmax(vec2 a, vec2 b, float k) {\n    vec2 h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\n// IQ's polynominal min\nvec3 pmin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's polynominal max\nvec3 pmax(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\n// IQ'", "\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r, float s) {\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n    vec3 a = abs(mod(q, 2.0 * s) - s) - s;\n    return length(max(vec3(d, a.x, a.y), 0.0)) + min(max(d, a.x), a.y);\n}\n\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    vec3 d = abs(p) - b;\n    vec3 a = abs(p) - b + e;\n    return min(min(\n        length(max(vec3(d.x, d.y, -d.z), 0.0)) + min(max(d.x, max(d.y, -d.z)), 0.0),\n        length(max(vec3(d.x, -d.y, d.z), 0.0)) + min(max(d.x, max(-d.y, d.z)), 0.0)\n   ", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec3 rgb2hsv(float r, float g, float b) {\n    return rgb2hsv(vec3(r, g, b));\n}\n\nvec3 hsv2rgb(vec4 hsv) {\n    return hsv2rgb(vec3(hsv.x, hsv.y, hsv.z));\n}\n\nvec3 rgb2hsv(vec3 rgb) {\n    return rgb2hsv(vec3(rgb.x, rgb.y, rgb.z));\n}\n\nvec3 hsv2rgb(", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w*s.w;\n    float h = b*b - c;\n    if(h<0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// IQ's ray box intersection\nvec2 rayBox( in vec3 ro, in vec3 rd, in vec3 boxpos, in vec3 boxsize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxsize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2(tN,tF);\n}\n\n// IQ's ray box intersection\nvec2 rayBox( in vec3 ro, in vec3 rd, in vec3 boxpos, in vec3 boxsize, in float tmin, in float tmax )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxsize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<tmin || tN>tmax ) return vec2(-1.0);\n    return vec2(tN", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tN, tF);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize )  {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    return vec2(tN, tF);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal, out vec3 outPoint )  {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max", "\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec2(p1.x, p2.y);\n    e3 = p2 - vec2(p2.x, p1.y);\n    e4 = p2 - vec2(p1.x, p1.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    vec3 p1 = p - d;\n    vec3 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec3(p1.x, p2.y, p1.z);\n    e3 = p2 - vec3(p2.x, p1.y, p1.z);\n    e4 = p2 - vec3(p1.x, p1.y, p2.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec4 p, vec4 d, inout vec4 e1, inout vec4 e2, inout vec4 e3, inout vec4 e4) {\n    vec4 p1 = p - d;\n    vec4 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec4(p1.x, p2.y, p1.z, p1.w);\n    e3 = p2 - vec4(p2.x, p1.y, p1.z, p1.w);\n    e4 = p2 - vec4(p1.x, p1.y, p2.z, p1.w);", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat dist(vec2 p) {\n    float d = linedist(p, vec2(0.0, 0.0), vec2(1.0, 0.0));\n    d = min(d, linedist(p, vec2(1.0, 0.0), vec2(1.0, 1.0)));\n    d = min(d, linedist(p, vec2(1.0, 1.0), vec2(0.0, 1.0)));\n    d = min(d, linedist(p, vec2(0.0, 1.0), vec2(0.0, 0.0)));\n    return d;\n}\n\nfloat dist2(vec2 p) {\n    float d = linedist(p, vec2(0.0, 0.0), vec2(1.0, 0.0));\n    d = min(d, linedist(p, vec2(1.0, 0.0), vec2(1.0, 1.0)));\n    d = min(d, linedist(p, vec2(1.0, 1.0), vec2(0.0, 1.0)));\n    d = min(d, linedist(p, vec2(0.0, 1.0), vec2(0.0, 0.0)));\n    return d * d;\n}\n\nfloat dist3(vec2 p) {\n    float d = linedist(p, vec2(0.0, 0.0), vec2(1.0, 0.0));\n    d = min(d, linedist(p, vec2(1.0, 0.0), vec2(1.0, 1.0)));\n    d = min(d, linedist(p, vec2(", "\n    vec2  ba = b - a;\n    float h = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  n = ba*h - (p-a);\n    float d = length(n)*sign(w1-w2) - w2;\n    float t = w1 - w2;\n    return  min( max(d,-t), max(d,t) ) + length(max(vec2(d,-t), vec2(0.0)))*sign(t);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec3 p, vec3 a, vec3 b, float w1, float w2 )\n{\n    vec3  ba = b - a;\n    float h = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  n = ba*h - (p-a);\n    float d = length(n)*sign(w1-w2) - w2;\n    float t = w1 - w2;\n    return  min( max(d,-t), max(d,t) ) + length(max(vec2(d,-t), vec2(0.0)))*sign(t);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec4 p, vec4 a, vec4 b, float w1, float w2 )\n{\n    vec4  ba = b - a;\n    float h = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec4  n = ba*h - (p-a);\n    float d = length(n)*sign(w1-w2) - w2;\n    float t = w1 - w2;\n    return  min( max(d,-t), max", "\n    vec2 t = rayTorusIntersection(ro, rd, tor);\n    return (t.x < t.y)? t.x : t.y;\n}\n\nfloat rayTorusIntersection(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 t = rayTorusIntersection2(ro, rd, tor);\n    return (t.x < t.y)? t.x : t.y;\n}\n\nvec2 rayTorusIntersection2(vec3 ro, vec3 rd, vec2 tor) {\n    vec3 oc = ro;\n    float r = tor.x;\n    float R = tor.y;\n    float k = dot(rd, rd);\n    float f = dot(oc, rd);\n    float g = dot(oc, oc) - r * r;\n    float h = f * f - k * g;\n    float i = sqrt(max(k * g - h * h, 0.0));\n    float j = (i + h) / k;\n    float t1 = j - sqrt(max(j * j - f * i / k, 0.0));\n    float t2 = j + sqrt(max(j * j - f * i / k, 0.0));\n    float t = (t1 < t2)? t1 : t2;\n    vec3 p = ro + rd * t;\n    float l = length(p) - R;\n    return vec2(t - l, t + l);\n}\n\nfloat rayTorusIntersection2(vec3 ro, vec3 rd, vec2 tor, out vec3 p) {\n    vec2 t = rayTorusIntersection2(ro, rd, tor);\n    p = ro + rd * t.x;\n    return t.x;\n}\n\nfloat rayTorusIntersection2(vec3 ro, vec3 rd, vec2 tor, out vec3 p, out float l) {\n    vec2 t = rayTorusIntersection2(ro, rd, tor);\n    p = ro + r", "\n    vec2 t = pos.xz;\n    float r = length(t);\n    float a = atan(t.y, t.x);\n    float d = (r - tor.x) / tor.y;\n    float x = d * cos(a);\n    float y = d * sin(a);\n    return vec3(x, y, -r);\n}\n\nvec3 torusNormal(vec3 pos, float r1, float r2) {\n    return torusNormal(pos, vec2(r1, r2));\n}\n\nvec3 torusNormal(vec3 pos, float r) {\n    return torusNormal(pos, r, r);\n}\n\nvec3 torusNormal(vec3 pos) {\n    return torusNormal(pos, 1.0, 0.5);\n}\n\nvec3 torusNormal(vec2 pos) {\n    return torusNormal(vec3(pos, 0.0), 1.0, 0.5);\n}\n\nvec3 torusNormal(float pos) {\n    return torusNormal(vec3(pos, 0.0, 0.0), 1.0, 0.5);\n}\n\nvec3 torusNormal(float pos, float r) {\n    return torusNormal(vec3(pos, 0.0, 0.0), r);\n}\n\nvec3 torusNormal(float pos, float r1, float r2) {\n    return torusNormal(vec3(pos, 0.0, 0.0), r1, r2);\n}\n\nvec3 torusNormal(vec2 pos, float r) {\n    return torusNormal(vec3(pos, 0.0), r);\n}\n\nvec3 torusNormal(vec2 pos, float r1, float r2) {\n    return torusNormal(vec3(pos, 0.0), r1, r2);\n}\n\nvec3 torusNormal(vec2 pos, vec2 tor) {\n    return torusNormal(vec3(pos, 0.0), tor);\n}\n\nvec3 torusNormal(vec3 pos,", "\n    float x2 = x * x;\n    return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative(float x) {\n    float x2 = x * x;\n    return 1.0f - x2 * (27.0f + 3.0f * x2) / (27.0f + 9.0f * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid(float x) {\n    return 1.0f / (1.0f + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_derivative(float x) {\n    float s = sigmoid(x);\n    return s * (1.0f - s);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu(float x) {\n    return x > 0.0f? x : 0.0f;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu_derivative(float x) {\n    return x > 0.0f? 1.0f : 0.0f;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu(float x) {\n    return x > 0.0f? x : 0.01f * x;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu_derivative(float x) {\n    return x > 0.0f? 1.0f : 0.01f;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat elu(float x) {\n    return x > 0.0f? x : exp(x) - 1.0f;\n}\n\n// License: Unknown, author: Unknown, found: don't", "\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    col = col * (0.6 + 0.4 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7));\n    col = col * (0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7));\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv).rgb;\n    col += texture(iChannel1, uv).rgb;\n    col += texture(iChannel2, uv).rgb;\n    col += texture(iChannel3, uv).rgb;\n    col += texture(iChannel4, uv).rgb;\n    col += texture(iChannel5, uv).rgb;\n    col += texture(iChannel6, uv).rgb;\n    col += texture(iChannel7, uv).rgb;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 - iGlobalTime;\n    vec3 tot = vec3(0.0);\n    for (int j = 0; j < 16; j++) {\n        float an = 0.5 + 6.2831 * (float(j) + (1.0 + 4.0 * mo.x) / 16.0) / 16", "\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r, float s) {\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n    vec3 a = abs(mod(q, 2.0 * s) - s) - s;\n    return length(max(vec3(d, a.x, a.y), 0.0)) + min(max(d, a.x), a.y);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r, float s, float e) {\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n    vec3 a = abs(mod(q, 2.0 * s) - s) - s;\n    float c = length(max(vec3(d, a.x, a.y), 0.0)) + min(max(d, a.x), a.y);\n    return mix(c, -sdBox(p", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 cubic = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nfloat fbm(vec2 uv) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 5; i++) {\n        value += noise(uv) * scale;\n        uv *= 2.0;\n        scale *= 0.5;\n    }\n\n    return value;\n}\n\nfloat pattern(vec2 uv, vec2 resolution, float scale) {\n    vec2 q = uv * resolution;\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n\n    vec2 p = vec2(0.5) - f;\n    float d = max(p.x, p.y);\n\n    float n = fbm(uv * scale);\n\n    return n + d;\n}\n\nfloat circle(vec2 uv, vec2 resolution, float radius) {\n    vec2 center = resolution / 2.0;\n    float dist = distance(uv, center);\n    return smoothstep(radius, radius - 0.01, dist);\n}\n\nfloat rect(vec2 uv, vec2 resolution, vec2 size", "\n    return length(p-c)-r;\n}\n\n// signed distance to a box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// signed distance to a rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// signed distance to a capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// signed distance to a cylinder\nfloat sdCylinder( in vec3 p, in vec3 c, in float h, in float r )\n{\n    vec2 d = abs(vec2(length(p.xz-c.xz),p.y-c.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a cone\nfloat sdCone( in vec3 p, in vec3 c, in float h, in float r1, in float r2 )\n{\n    float q = length(p.xz);\n    return max(dot(c.xy,vec2(q,p.", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*t );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b, out float t )\n{\n    vec3 pa = p-a, ba = b-a;\n    t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*t );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b, out float t )\n{\n    vec4 pa = p-a, ba = b-a;\n    t = clamp( dot(pa,ba)/dot(", " return a.x*b.y - a.y*b.x; }\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = vec2(e1.x*e2.y - e1.y*e2.x, e2.x*e0.y - e2.y*e0.x);\n\n    vec2 r = vec2( dot(pq0,pq0), dot(pq1,pq1) );\n\n    return sign(s)*sqrt(min(dot(pq0,d),dot(pq1,d))*r.x*r.y)/abs(s) +\n           0.5*sqrt(min(r.x,r.y));\n}\n\n// signed distance to a 2D rectangle\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0", "\n    return length(max(abs(p)-s+r,0.0))-r;\n}\n\nfloat sdRoundSquare( in vec2 p, in float s ) \n{\n    return sdRoundSquare(p, s, s*0.2);\n}\n\nfloat sdRoundSquare( in vec2 p ) \n{\n    return sdRoundSquare(p, 1.0);\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in float s, in float r ) \n{\n    return length(max(abs(p)-s+r,0.0))-r;\n}\n\nfloat sdRoundSquare( in vec3 p, in float s ) \n{\n    return sdRoundSquare(p, s, s*0.2);\n}\n\nfloat sdRoundSquare( in vec3 p ) \n{\n    return sdRoundSquare(p, 1.0);\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec4 p, in float s, in float r ) \n{\n    return length(max(abs(p)-s+r,0.0))-r;\n}\n\nfloat sdRoundSquare( in vec4 p, in float s ) \n{\n    return sdRoundSquare(p, s, s*0.2);\n}\n\nfloat sdRoundSquare( in vec4 p ) \n{\n    return sdRoundSquare(p, 1.0);\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in vec2 s, in float r ) \n{\n    return length(max(abs(p)-s+r,0.0))-r;\n}\n\nfloat sdRoundSquare( in vec2 p, in vec2 s ) \n{\n    return sdRoundSquare(p, s, s*0.2);\n}\n", "\n    return x / (1.0 + x);\n}\n\nvec3 s_curve_inv(vec3 x)\n{\n    return x / (1.0 - x);\n}\n\nvec3 s_curve_inv_deriv(vec3 x)\n{\n    return 1.0 / (1.0 - x * x);\n}\n\nvec3 s_curve_deriv(vec3 x)\n{\n    return 1.0 / (1.0 + x * x);\n}\n\nvec3 s_curve_deriv_inv(vec3 x)\n{\n    return -2.0 * x / (1.0 - x * x);\n}\n\nvec3 s_curve_deriv_inv_deriv(vec3 x)\n{\n    return 2.0 * (1.0 - x * x) / (1.0 - x * x) / (1.0 - x * x);\n}\n\nvec3 s_curve_deriv_deriv(vec3 x)\n{\n    return -2.0 * x * (1.0 + x * x) / (1.0 + x * x) / (1.0 + x * x);\n}\n\nvec3 s_curve_deriv_deriv_inv(vec3 x)\n{\n    return 2.0 * (1.0 - x * x) * (1.0 - x * x) / (1.0 - x * x) / (1.0 - x * x) / (1.0 - x * x);\n}\n\nvec3 s_curve_deriv_deriv_inv_deriv(vec3 x)\n{\n    return -2.0 * (1.0 - x * x) * (1.0 - x * x) * (1.0 - x * x) / (1.0 - x * x) / (1.0 - x * x) / (1.0 - x * x) / (1.0 - x * x);\n}\n\nvec3 s_curve_deriv_deriv_deriv(vec3 x)\n{\n    return 2.0 * x * (1.0 +", "\n    return vec3(\n        -0.5 * x.x * x.x * x.x + 1.5 * x.x * x.x - 2.5 * x.x + 1.0,\n        -0.5 * x.y * x.y * x.y + 1.5 * x.y * x.y - 2.5 * x.y + 1.0,\n        -0.5 * x.z * x.z * x.z + 1.5 * x.z * x.z - 2.5 * x.z + 1.0\n    );\n}\n\n// derivative of s-curve\nvec3 d2_s_curve(vec3 x)\n{\n    return vec3(\n        -1.5 * x.x * x.x + 3.0 * x.x - 2.5,\n        -1.5 * x.y * x.y + 3.0 * x.y - 2.5,\n        -1.5 * x.z * x.z + 3.0 * x.z - 2.5\n    );\n}\n\n// derivative of s-curve\nvec3 d3_s_curve(vec3 x)\n{\n    return vec3(\n        -3.0 * x.x + 3.0,\n        -3.0 * x.y + 3.0,\n        -3.0 * x.z + 3.0\n    );\n}\n\n// derivative of s-curve\nvec3 d4_s_curve(vec3 x)\n{\n    return vec3(\n        -3.0,\n        -3.0,\n        -3.0\n    );\n}\n\n// derivative of s-curve\nvec3 d5_s_curve(vec3 x)\n{\n    return vec3(\n        0.0,\n        0.0,\n        0.0\n    );\n}\n\n// derivative of s-curve\nvec3 d6_s_curve(vec3 x)\n{\n    return vec3(\n        0.0,\n        0.0,\n        0.0\n    );", "\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = a/w;\n    float f = fract(t);\n    float d = (0.5-f)*sign(k)*(1.0-f);\n    return d*r;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec3 p, float w, in float k )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = a/w;\n    float f = fract(t);\n    float d = (0.5-f)*sign(k)*(1.0-f);\n    return d*r;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float t )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float f = fract(t);\n    float d = (0.5-f)*sign(k)*(1.0-f);\n    return d*r;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec3 p, float w, in float k, in float t )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float f = fract(t);\n    float d = (0.5-f)*sign(k)*(1.0-f);\n    return d*r;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float t, in float r )\n{\n    float a = atan(p.y,p.x);\n    float f = fract(t);\n    float d = (0.5-f)*sign", "\n    return exp(-opticalDepth * g_Scattering.Absorption);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Scatter(vec3 opticalDepth)\n{\n    return exp(-opticalDepth * g_Scattering.Scattering);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Extinction(vec3 opticalDepth)\n{\n    return exp(-opticalDepth * g_Scattering.Extinction);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Transmittance(vec3 opticalDepth)\n{\n    return exp(-opticalDepth * g_Scattering.Extinction);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Transmittance(vec3 opticalDepth, vec3 transmittance)\n{\n    return transmittance * exp(-opticalDepth * g_Scattering.Extinction);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Transmittance(vec3 opticalDepth, vec3 transmittance, vec3 scattering)\n{\n    return transmittance * exp(-opticalDepth * g_Scattering.Extinction + scattering * g_Scattering.Scattering);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Transmittance(vec3 opticalDepth, vec3 transmittance, vec3 scattering, vec3 absorption)\n{\n    return transmittance * exp(-opticalDepth * g_Scattering.Extinction + scattering * g_Scattering.Scattering + absorption * g_Scattering.Absorption);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Transmittance(vec3 opticalDepth, vec3 transmittance, vec3 scattering, vec3 absorption, vec3 extinction)\n{\n    return transmittance * exp(-opticalDepth * extinction + scattering * g_Scattering.Scattering + absorption * g_Scattering.Absorption);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Transmittance(vec3 opticalDepth, ve", "\n    vec3 rayEnd = rayStart + rayDir * rayLength;\n    vec3 rayStep = rayDir * (rayLength / float(NUM_STEPS));\n\n    vec3 rayPos = rayStart;\n    vec3 rayScatter = vec3(0.0);\n    vec3 rayTransmittance = vec3(1.0);\n\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        float height = GetHeight(rayPos);\n        float density = GetDensity(rayPos, height);\n\n        // Calculate the optical depth along the ray.\n        float opticalDepth = density * rayStep.y;\n\n        // Calculate the transmittance along the ray.\n        rayTransmittance *= exp(-opticalDepth * lightColor);\n\n        // Calculate the scattering along the ray.\n        rayScatter += rayTransmittance * opticalDepth * lightColor;\n\n        rayPos += rayStep;\n    }\n\n    transmittance = rayTransmittance;\n    return rayScatter;\n}\n\n// Integrate scattering over a ray for multiple directional light sources.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDirs[NUM_LIGHTS], vec3 lightColors[NUM_LIGHTS])\n{\n    vec3 rayEnd = rayStart + rayDir * rayLength;\n    vec3 rayStep = rayDir * (rayLength / float(NUM_STEPS));\n\n    vec3 rayPos = rayStart;\n    vec3 rayScatter = vec3(0.0);\n\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        float height = GetHeight(rayPos);\n        float density = GetDensity(rayPos, height);\n\n        // Calculate the optical depth along the ray.\n        float opticalDepth = density * rayStep.y;\n\n        // Calculate the scattering along the ray.\n        for (int j = 0; j < NUM_LIGHTS; j++)\n        {\n            rayScatter += opticalDepth", "\n    vec3 p = p2;\n    p.z -= d;\n    float a = (ra-rb)/d;\n    float b = (ra*ra-rb*rb)/d;\n    float c = -ra*ra;\n    float h = b*b-a*c;\n    float t = (-b-sqrt(max(h,0.0)))/a;\n    float s = (t<0.0)?2.0:1.0;\n    vec3 q = p - s*t*normalize(vec3(p.x,p.y,0.0));\n    return length(q)*sign(q.z) - rb;\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar2( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec3 p = p2;\n    p.z -= d;\n    float a = (ra-rb)/d;\n    float b = (ra*ra-rb*rb)/d;\n    float c = -ra*ra;\n    float h = b*b-a*c;\n    float t = (-b-sqrt(max(h,0.0)))/a;\n    float s = (t<0.0)?2.0:1.0;\n    vec3 q = p - s*t*normalize(vec3(p.x,p.y,0.0));\n    return length(q)*sign(q.z) - rb;\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar3( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec3 p = p2;\n    p.z -= d;\n    float a = (ra-rb)/d;\n    float b = (ra*ra-rb*rb)/d;\n    float c = -ra*ra;\n    float h = b*b-a*c;\n   ", "\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSphere( vec3 p, float r, float h, float t )\n{\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSphere( vec3 p, float r, float h, float t )\n{\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSphere( vec3 p, float r, float h, float t )\n{\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    return max( length(p.xz)-r, abs(p.y)-h-t );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCut", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float tmax, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float tmax, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in", "\n    return length(p.xy) - r - h;\n}\n\nfloat sdCutSphere( in vec3 p, in float r )\n{\n    return length(p.xy) - r;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2 )\n{\n    return length(p.xy) - r - h - r2;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2, in float r3 )\n{\n    return length(p.xy) - r - h - r2 - r3;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2, in float r3, in float r4 )\n{\n    return length(p.xy) - r - h - r2 - r3 - r4;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2, in float r3, in float r4, in float r5 )\n{\n    return length(p.xy) - r - h - r2 - r3 - r4 - r5;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2, in float r3, in float r4, in float r5, in float r6 )\n{\n    return length(p.xy) - r - h - r2 - r3 - r4 - r5 - r6;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2, in float r3, in float r4, in float r5, in float r6, in float r7 )\n{\n    return length(p.xy) - r - h - r2 - r3 - r4 - r5 - r6 - r7;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float r2, in float r3, in float r4, in float r5, in float r6", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sdf(pos+h.xyy) - sdf(pos-h.xyy),\n                           sdf(pos+h.yxy) - sdf(pos-h.yxy),\n                           sdf(pos+h.yyx) - sdf(pos-h.yyx) ) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdf(vec2 p)\n{\n    float d = length(p) - 1.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    return d;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdf(vec3 p)\n{\n    float d = length(p) - 1.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    d = max(d, abs(p.z) - 0.5);\n    return d;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdf(vec4 p)\n{\n    float d = length(p) - 1.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    d = max(d, abs(p.z) - 0.5);\n    d = max(d, abs(p.w) - 0.5);\n    return d;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdf(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/dist", "\n    return max( length(p)-r, abs(p.y)-h );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r, in float h )\n{\n    return max( length(p.xy)-r, abs(p.z)-h );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec4 p, in float r, in float h )\n{\n    return max( length(p.xy)-r, abs(p.w)-h );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec2 p, in vec2 r, in float h )\n{\n    return max( length(p)-r.x, abs(p.y)-h );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec3 p, in vec2 r, in float h )\n{\n    return max( length(p.xy)-r.x, abs(p.z)-h );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec4 p, in vec2 r, in float h )\n{\n    return max( length(p.xy)-r.x, abs(p.w)-h );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in vec2 h )\n{\n    return max( length(p)-r, abs(p.y)-h.x );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r, in vec2 h )\n{\n    return max( length(p.xy)-r, abs(p.z)-h.x );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec4 p, in float r, in vec2 h )\n{\n    return max( length(p.xy)-r, abs(p.w)-h.x );\n}\n\n// r=radius, h=height\nfloat sdCutDisk( in vec2 p,", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 2d noise function\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 1d noise function\nfloat noise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(i+  0.0), hash(i+  1.0),f);\n}\n\n// 3d noise function with octaves\nfloat noise( in vec3 x, in int octaves )\n{\n    float n = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n\n    for( int i=0; i<octaves; i++ )\n    {\n        n += amp*noise(freq", "\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( p );\n        p = p * 2.0;\n        a *= w;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( p );\n        p = p * 2.0;\n        a *= w;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( p );\n        p = p * 2.0;\n        a *= w;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( p );\n        p = p * 2.0;\n        a *= w;\n    }\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float w = 0.5;\n    float a = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( p );", "\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash32(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash33(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash34(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash35(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash36(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash37(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3,", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv).rgb;\n    col += texture(iChannel1, uv).rgb;\n    col += texture(iChannel2, uv).rgb;\n    col += texture(iChannel3, uv).rgb;\n    col += texture(iChannel4, uv).rgb;\n    col += texture(iChannel5, uv).rgb;\n    col += texture(iChannel6, uv).rgb;\n    col += texture(iChannel7, uv).rgb;\n    col += texture(iChannel8, uv).rgb;\n    col += texture(iChannel9, uv).rgb;\n    col += texture(iChannel10, uv).rgb;\n    col += texture(iChannel11, uv).rgb;\n    col += texture(iChannel12, uv).rgb;\n    col += texture(iChannel13, uv).rgb;\n    col += texture(iChannel14, uv).rgb;\n    col += texture(iChannel15, uv).rgb;\n    col += texture(iChannel16, uv).rgb;\n    col += texture(iChannel17, uv).rgb;\n    col += texture(iChannel18, uv).rgb;\n    col += texture(iChannel19, uv).rgb;\n    col += texture(iChannel20, uv).rgb;\n    col += texture(iChannel21, uv).rgb;\n    col += texture(iChannel22, uv).rgb;\n    col += texture(iChannel23, uv).rgb;\n    col += texture(iChannel24, uv).rgb;\n    col += texture(iChannel25, uv).rgb;\n    col += texture(iChannel26, uv).rgb;\n    col += texture(iChannel27, uv).rgb;\n    col += texture(iChannel28,", "\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  vec3 color = hsv2rgb(vec3(uv.x, 1.0, 1.0));\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float h = clamp(0.5 + 0.5 * (size - abs(p)), 0.0, 1.0);\n    p -= h * (size + size);\n    return h;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c) {\n    float q = length(p.xy);\n    return dot(c.xy, vec2(q, p.z));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n    vec2 d = vec2(\n        length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n        p.z - h.y\n    );\n   ", "\n    return fract(sin(co * 12.9898) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i.x);\n    float b = hash(i.y);\n\n    float u = f.x * f.x * (3.0 - 2.0 * f.x);\n    float v = f.y * f.y * (3.0 - 2.0 * f.y);\n\n    return mix(a, b, u) + (c - a) * v * (1.0 - u);\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return value;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    float n = fbm(uv * 10.0);\n    float c = n * 0.5 + 0.5;\n\n    gl_FragColor = vec4(vec3(c), 1.0);\n}\n", "\n    return t <= 0.0031308? 12.92 * t : (1.055 * pow(t, 0.41666) - 0.055);\n}\n\nvec3 sRGB(vec3 t) {\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\nvec3 sRGB(vec4 t) {\n    return sRGB(t.rgb);\n}\n\nvec3 sRGB(vec2 t) {\n    return sRGB(t.rgb);\n}\n\nvec3 sRGB(float t, float g, float b) {\n    return sRGB(vec3(t, g, b));\n}\n\nvec3 sRGB(float t, float g, float b, float a) {\n    return sRGB(vec4(t, g, b, a));\n}\n\nvec3 sRGB(float t, vec3 gb) {\n    return sRGB(vec4(t, gb));\n}\n\nvec3 sRGB(float t, vec3 gb, float a) {\n    return sRGB(vec4(t, gb, a));\n}\n\nvec3 sRGB(vec3 t, float g, float b) {\n    return sRGB(vec4(t, g, b));\n}\n\nvec3 sRGB(vec3 t, float g, float b, float a) {\n    return sRGB(vec4(t, g, b, a));\n}\n\nvec3 sRGB(vec3 t, vec3 gb) {\n    return sRGB(vec4(t, gb));\n}\n\nvec3 sRGB(vec3 t, vec3 gb, float a) {\n    return sRGB(vec4(t, gb, a));\n}\n\nvec3 sRGB(vec4 t, float g, float b) {\n    return sRGB(vec4(t, g, b));\n}\n\nvec3 sRGB(vec4 t, float", "\n    return mix(1.055 * pow(c, vec3(0.4166667)) - 0.055, c * 12.92, lessThanEqual(c, vec3(0.0031308)));\n}\n\nvec3 linear(in vec3 c) {\n    return mix(pow((c + 0.055) / 1.055, vec3(2.4)), c / 12.92, lessThanEqual(c, vec3(0.04045)));\n}\n\nvec3 sRGB(in vec4 c) {\n    return sRGB(c.rgb);\n}\n\nvec3 linear(in vec4 c) {\n    return linear(c.rgb);\n}\n\nvec3 sRGB(in vec2 c) {\n    return sRGB(vec3(c, 0.0));\n}\n\nvec3 linear(in vec2 c) {\n    return linear(vec3(c, 0.0));\n}\n\nvec3 sRGB(in float c) {\n    return sRGB(vec3(c, 0.0, 0.0));\n}\n\nvec3 linear(in float c) {\n    return linear(vec3(c, 0.0, 0.0));\n}\n\nvec4 sRGB(in vec4 c) {\n    return vec4(sRGB(c.rgb), c.a);\n}\n\nvec4 linear(in vec4 c) {\n    return vec4(linear(c.rgb), c.a);\n}\n\nvec4 sRGB(in vec3 c) {\n    return vec4(sRGB(c), 1.0);\n}\n\nvec4 linear(in vec3 c) {\n    return vec4(linear(c), 1.0);\n}\n\nvec4 sRGB(in vec2 c) {\n    return vec4(sRGB(c), 0.0, 1.0);\n}\n\nvec4 linear", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b, float k, float m) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h) - m * h;\n}\n\nfloat smin(float a, float b, float k, float m) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h) + m * h;\n}\n\nfloat smin(float a, float b, float k, float m, float n) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if( t1>dbuffer ) return t1;\n    if( t2>dbuffer ) return t2;\n    return -1.0;\n}\n\nfloat sphsdf(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if( t1<0.0 ) return t2;\n    if( t2<0.0 ) return t1;\n    return min(t1, t2);\n}\n\nfloat sphsdf(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if( t1<0.0 ) return t2;\n    if( t2<0.0 ) return t1;\n    return min(t1, t2);\n}\n\nfloat sphsdf(vec3 ro, ve", "\n    p.yz = p.yz*mat2(cos(p.x),sin(p.x),-sin(p.x),cos(p.x));\n    p.xz = p.xz*mat2(cos(p.y),sin(p.y),-sin(p.y),cos(p.y));\n    p.xy = p.xy*mat2(cos(p.z),sin(p.z),-sin(p.z),cos(p.z));\n    return p;\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n    p.yz = p.yz*mat2(cos(p.x),sin(p.x),-sin(p.x),cos(p.x));\n    p.xz = p.xz*mat2(cos(p.y),sin(p.y),-sin(p.y),cos(p.y));\n    p.xy = p.xy*mat2(cos(p.z),sin(p.z),-sin(p.z),cos(p.z));\n    return p;\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n    p.yz = p.yz*mat2(cos(p.x),sin(p.x),-sin(p.x),cos(p.x));\n    p.xz = p.xz*mat2(cos(p.y),sin(p.y),-sin(p.y),cos(p.y));\n    p.xy = p.xy*mat2(cos(p.z),sin(p.z),-sin(p.z),cos(p.z));\n    return p;\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n    p.yz = p.yz", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec4( k0*(k0-1.0)/k1, p/r, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r, float k )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec4( k0*(k0-k)/k1, p/r, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r, float k, float k2 )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec4( k0*(k0-k)/k1, p/r, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r, float k, float k2, float k3 )\n{\n    float k0 = length(p/r);\n    float", "\n    return front + back * (1.0 - front.a);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return front + back * (1.0 - front.a) * alpha;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha) {\n    return front + back * (1.0 - front.a) * alpha.a;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, float alpha2) {\n    return front + back * (1.0 - front.a) * alpha.a * alpha2;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2) {\n    return front + back * (1.0 - front.a) * alpha.a * alpha2.a;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, float alpha3) {\n    return front + back * (1.0 - front.a) * alpha.a * alpha2.a * alpha3;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3) {\n    return front + back * (1.0 - front.a) * alpha.a * alpha2.a * alpha3.a;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3, float alpha4) {\n    return front + back * (1.0 - front.a) * alpha.a * alpha2.a * alpha3.a * alpha4;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3, vec4 alpha4) {\n    return front + back * (1.0 - front.a) * alpha.a * alpha2.a * alpha3.a * alpha4.a;\n}\n\nvec4 alphaBlend(vec4", "\n    return back * (1.0 - front.a) + front.rgb * front.a;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return back * (1.0 - front.a) + front.rgb * front.a;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return back * (1.0 - alpha) + front * alpha;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha) {\n    return back * (1.0 - alpha) + front * alpha;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha) {\n    return back * (1.0 - alpha.a) + front * alpha.a;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, float alpha2) {\n    return back * (1.0 - alpha2) + front * alpha2;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 alpha2) {\n    return back * (1.0 - alpha2) + front * alpha2;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec4 alpha2) {\n    return back * (1.0 - alpha2.a) + front * alpha2.a;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha, float alpha2) {\n    return back * (1.0 - alpha2) + front * alpha2;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha, vec3 alpha2) {\n    return back * (1.0 - alpha2) + front * alpha2;\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha, vec4 alpha2) {\n    return back * (1.0 - alpha2.a) + front * alpha2.a;\n}\n\nvec3 alphaBlend(vec3", "\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r) {\n    return hex(p, r);\n}\n\nfloat hexagon(vec2 p, float r, float thickness) {\n    return max(hex(p, r), -hex(p, r - thickness));\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float feather) {\n    return max(hex(p, r), -hex(p, r - thickness)) - feather;\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float feather, float feather2) {\n    return max(hex(p, r), -hex(p, r - thickness)) - feather - feather2;\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float feather, float feather2, float feather3) {\n    return max(hex(p, r), -hex(p, r - thickness)) - feather - feather2 - feather3;\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float feather, float feather2, float feather3, float feather4) {\n    return max(hex(p, r), -hex(p, r - thickness)) - feather - feather2 - feather3 - feather4;\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float feather, float feather2, float feather3, float feather4, float feather5) {\n    return max(hex(p, r), -hex(p, r - thickness)) - feather - feather2 - feather3 - feather4 - feather5;\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float feather, float feather2, float feather3, float feather4, float feather5, float feather6) {\n    return max(hex(p, r), -hex(p, r - thickness)) - feather - feather2 - feather3 - feather4 - feather5 - feather6;\n}\n\nfloat hexagon(vec2 p, float r, float thickness, float", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\nvec3 aces_approx_2(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\nvec3 aces_approx_3(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\nvec3 aces_approx_4(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\nvec3 aces_approx_5(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)), dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x), mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)), dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p);\n    p *= 2.0;\n    f += 0.2500 * noise(p);\n    p *= 2.0;\n    f += 0.1250 * noise(p);\n    p *= 2.0;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\nfloat fbm2(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p);\n    p *= 2.0;\n    f += 0.2500 * noise(p);\n    p *= 2.0;\n    f += 0.1250 * noise(p);\n    p *= 2.0;\n    f += 0.062", "\n    vec3 col;\n    col.r = clamp(pow(Temp, -0.143), 0.0, 1.0);\n    col.g = clamp(pow(Temp, -0.0795), 0.0, 1.0);\n    col.b = clamp(pow(Temp, -0.034), 0.0, 1.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = blackbody(uv.x);\n    fragColor = vec4(col,1.0);\n}", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                    dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n               mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                    dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.01;\n    f += 0.2500*noise(p); p = p*2.02;\n    f += 0.1250*noise(p); p = p*2.03;\n    f += 0.0625*noise(p); p = p*2.01;\n    return f/0.9375;\n}\n\nfloat fbm2(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.01;\n    f += 0.2500*noise(p); p = p*2.02;\n    f += 0.1250*noise(p); p = p*2.03;\n    f += 0.0625*noise(p); p = p*2.01;\n    return f/0.9375;\n}\n\nfloat fbm3(vec2 p) {\n    float f = ", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2(-b-h, -b+h);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sph, float r) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2(-b-h, -b+h);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sph, float r, out vec3 p) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    p = -b*rd + oc;\n    return vec2(-b-h, -b+h);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sph, float r, out vec3 p, out vec3 n) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    p = -b*rd + oc;\n    n = p/r;\n", "\n    p = p*p;\n    float r = p.x + p.y;\n    float a = pow(r, n);\n    float b = pow(r, 0.5*n);\n    float c = pow(r, 0.25*n);\n    float d = pow(r, -0.25*n);\n    float e = pow(r, -0.5*n);\n    float f = pow(r, -n);\n    float g = pow(r, -2.0*n);\n    float h = pow(r, -4.0*n);\n    float i = pow(r, -8.0*n);\n    float j = pow(r, -16.0*n);\n    float k = pow(r, -32.0*n);\n    float l = pow(r, -64.0*n);\n    float m = pow(r, -128.0*n);\n    float n = pow(r, -256.0*n);\n    float o = pow(r, -512.0*n);\n    float p = pow(r, -1024.0*n);\n    float q = pow(r, -2048.0*n);\n    float r = pow(r, -4096.0*n);\n    float s = pow(r, -8192.0*n);\n    float t = pow(r, -16384.0*n);\n    float u = pow(r, -32768.0*n);\n    float v = pow(r, -65536.0*n);\n    float w = pow(r, -131072.0*n);\n    float x = pow(r, -262144.0*n);\n    float y = pow(r, -524288.0*n);\n    float z = pow(r, -1048576.0*n);\n    float A = pow(r, -2097152.0*n);\n    float B = pow", "\n    return floor(x) + t - x;\n}\n\nfloat cantor( float x )\n{\n    return cantor(x, 0.0);\n}\n\nfloat cantor( float x, float t, float s )\n{\n    return cantor(x, t) * s;\n}\n\nfloat cantor( float x, float t, float s, float r )\n{\n    return cantor(x, t, s) * r;\n}\n\nfloat cantor( float x, float t, float s, float r, float g )\n{\n    return cantor(x, t, s, r) * g;\n}\n\nfloat cantor( float x, float t, float s, float r, float g, float b )\n{\n    return cantor(x, t, s, r, g) * b;\n}\n\nfloat cantor( float x, float t, float s, float r, float g, float b, float a )\n{\n    return cantor(x, t, s, r, g, b) * a;\n}\n\nfloat cantor( float x, float t, float s, float r, float g, float b, float a, float y )\n{\n    return cantor(x, t, s, r, g, b, a) * y;\n}\n\nfloat cantor( float x, float t, float s, float r, float g, float b, float a, float y, float u )\n{\n    return cantor(x, t, s, r, g, b, a, y) * u;\n}\n\nfloat cantor( float x, float t, float s, float r, float g, float b, float a, float y, float u, float i )\n{\n    return cantor(x, t, s, r, g, b, a, y, u) * i;\n}\n\nfloat cantor( float x, float t, float s, float r, float g, float b, float a, float y, float u, float i, float p )\n{\n    return cantor(x, t, s, r, g, b, a, y, u, i) * p;\n}\n\nfloat cant", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w*0.5;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w, float s )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w*0.5 + s;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w, float s, float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w*0.5 + s + t;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w, float s, float t, float", "\n    float d = sdSphere(p, 1.0);\n    for (int i = 0; i < 10; i++) {\n        p = opRep(p, 2.0);\n        p = opRotate(p, vec3(0.0, 0.0, 1.0), 0.1);\n        p = opRotate(p, vec3(0.0, 1.0, 0.0), 0.1);\n        p = opRotate(p, vec3(1.0, 0.0, 0.0), 0.1);\n        d = opUnion(d, sdSphere(p, 1.0));\n    }\n    return d;\n}\n\n// main raymarching func\nvec3 raymarch(in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p, i);\n        if (d < 0.001) break;\n        t += d;\n    }\n    return vec3(t, d, 0.0);\n}\n\n// main raymarching func\nvec3 raymarch(in vec3 ro, in vec3 rd, in int idx) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p, i);\n        if (d < 0.001) break;\n        t += d;\n    }\n    return vec3(t, d, 0.0);\n}\n\n// main raymarching func\nvec3 raymarch(in vec3 ro, in vec3 rd, in int idx, in float tmin, in float tmax) {\n    float t = tmin;\n    float d = 0.0;\n    for", "\n    float a = y / x;\n    float a2 = a * a;\n    float a4 = a2 * a2;\n    float a6 = a4 * a2;\n    float a8 = a4 * a4;\n    float a10 = a8 * a2;\n    float a12 = a8 * a4;\n    float a14 = a12 * a2;\n    float a16 = a12 * a4;\n    float a18 = a16 * a2;\n    float a20 = a16 * a4;\n    float a22 = a20 * a2;\n    float a24 = a20 * a4;\n    float a26 = a24 * a2;\n    float a28 = a24 * a4;\n    float a30 = a28 * a2;\n    float a32 = a28 * a4;\n    float a34 = a32 * a2;\n    float a36 = a32 * a4;\n    float a38 = a36 * a2;\n    float a40 = a36 * a4;\n    float a42 = a40 * a2;\n    float a44 = a40 * a4;\n    float a46 = a44 * a2;\n    float a48 = a44 * a4;\n    float a50 = a48 * a2;\n    float a52 = a48 * a4;\n    float a54 = a52 * a2;\n    float a56 = a52 * a4;\n    float a58 = a56 * a2;\n    float a60 = a56 * a4;\n    float a62 = a60 * a2;\n    float a64 = a60 * a4;\n    float a66 = a64 * a2;\n    float a68 = a64 * a4;\n    float a70 = a68 * a2;\n    float a72 = a68 * a4;\n    float a74 = a72 *", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d = w.x*w.x + w.y*w.y;\n    return vec2((z.x*w.x + z.y*w.y)/d, (z.y*w.x - z.x*w.y)/d);\n}\n\nvec2 csqrt(vec2 z) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    return vec2(sqrt(a)*cos(b/2.0), sqrt(a)*sin(b/2.0));\n}\n\nvec2 cpow(vec2 z, float n) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    return vec2(pow(a, n)*cos(n*b), pow(a, n)*sin(n*b));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    float c = length(w);\n    float d = atan(w.y, w.x);\n    return vec2(pow(a, c)*cos(c*b + d), pow(a, c)*sin(c*b + d));\n}\n\nvec2 cpow(vec2 z, vec2 w, float n) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    float c = length(w);\n    float d = atan(w.y, w.x);\n    return vec2(pow(a, c)*cos(c*b + d*n), pow(a, c)*sin(c*b + d*n));\n}\n\nvec2 cpow(vec2 z, float n, float m) {\n    float a = length(z);\n", "\n    return vec2(0.5 * log((z.x + 1.0) / (z.x - 1.0)), atan(z.y, z.x));\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z) {\n    return vec3(0.5 * log((z.x + 1.0) / (z.x - 1.0)), atan(z.y, z.x), atan(z.z, z.x));\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z) {\n    return vec4(0.5 * log((z.x + 1.0) / (z.x - 1.0)), atan(z.y, z.x), atan(z.z, z.x), atan(z.w, z.x));\n}\n\n// Inverse hyperbolic tangent \nmat2 catanh(mat2 m) {\n    return mat2(catanh(m[0]), catanh(m[1]));\n}\n\n// Inverse hyperbolic tangent \nmat3 catanh(mat3 m) {\n    return mat3(catanh(m[0]), catanh(m[1]), catanh(m[2]));\n}\n\n// Inverse hyperbolic tangent \nmat4 catanh(mat4 m) {\n    return mat4(catanh(m[0]), catanh(m[1]), catanh(m[2]), catanh(m[3]));\n}\n\n// Inverse hyperbolic tangent \nmat2x3 catanh(mat2x3 m) {\n    return mat2x3(catanh(m[0]), catanh(m[1]));\n}\n\n// Inverse hyperbolic tangent \nmat2x4 catanh(mat2x4 m) {\n    return mat2x4(catanh(m[0]), catanh(m[1]));\n}\n\n// Inverse hyperbolic tangent \nmat3x2 catanh(mat3", "\n    float e = exp(z.x);\n    return vec2(e * cos(z.y), e * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    float e = exp(2.0 * z.x);\n    return vec2(0.5 * (e - 1.0 / e), z.y);\n}\n\nvec2 ctanh_deriv(vec2 z) {\n    float e = exp(2.0 * z.x);\n    return vec2(0.25 * (e + 1.0 / e) * e * e, 1.0);\n}\n\nvec2 ctanh_iter(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh_deriv(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv_approx(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh_deriv(zn) * ctanh(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv_approx_2(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh_deriv(zn) * ctanh(zn) * ctanh(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv_approx_3(vec2 z, int n) {\n    vec2 zn = z;\n   ", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d = w.x*w.x + w.y*w.y;\n    return vec2((z.x*w.x + z.y*w.y)/d, (z.y*w.x - z.x*w.y)/d);\n}\n\nvec2 csqrt(vec2 z) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    return vec2(sqrt(a)*cos(b/2.0), sqrt(a)*sin(b/2.0));\n}\n\nvec2 cpow(vec2 z, float n) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    return vec2(pow(a, n)*cos(n*b), pow(a, n)*sin(n*b));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    float a = length(z);\n    float b = atan(z.y, z.x);\n    float c = length(w);\n    float d = atan(w.y, w.x);\n    return vec2(pow(a, c)*cos(c*b + d), pow(a, c)*sin(c*b + d));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x)*cos(z.y), cosh(z.x)*sin(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x)*cos(z.y), sinh(z.x)*sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    float a = cosh(z.x);\n    float b = sinh(z.x);\n    float c = cos", "\n    float e = exp(z.x);\n    return vec2(e * cos(z.y), e * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    float e = exp(2.0 * z.x);\n    return vec2(0.5 * (e - 1.0 / e), z.y);\n}\n\nvec2 ctanh_deriv(vec2 z) {\n    float e = exp(2.0 * z.x);\n    return vec2(0.25 * (e + 1.0 / e) * e * e, 1.0);\n}\n\nvec2 ctanh_iter(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh_deriv(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv_approx(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh_deriv(zn) * ctanh(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv_approx_2(vec2 z, int n) {\n    vec2 zn = z;\n    for (int i = 0; i < n; i++) {\n        zn = ctanh_deriv(zn) * ctanh(zn) * ctanh(zn);\n    }\n    return zn;\n}\n\nvec2 ctanh_iter_deriv_approx_3(vec2 z, int n) {\n    vec2 zn = z;\n   ", "\n    return vec4(1.0 - exp(-alpha.r * contrast), 1.0 - exp(-alpha.g * contrast), 1.0 - exp(-alpha.b * contrast), 1.0);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrast2) {\n    return vec4(1.0 - exp(-alpha.r * contrast), 1.0 - exp(-alpha.g * contrast2), 1.0 - exp(-alpha.b * contrast), 1.0);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrast2, float contrast3) {\n    return vec4(1.0 - exp(-alpha.r * contrast), 1.0 - exp(-alpha.g * contrast2), 1.0 - exp(-alpha.b * contrast3), 1.0);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrast2, float contrast3, float contrast4) {\n    return vec4(1.0 - exp(-alpha.r * contrast), 1.0 - exp(-alpha.g * contrast2), 1.0 - exp(-alpha.b * contrast3), 1.0 - exp(-alpha.a * contrast4));\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrast2", "\n    p = abs(p);\n    float c = p.x - p.y;\n    float d = p.x - p.z;\n    float e = p.y - p.z;\n    float m = max(c, max(d, e));\n    float s = (c + d + e + m) * 0.25;\n    float t = sqrt(s * (s - c) * (s - d) * (s - e));\n    return 3.0 * t / m;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r) {\n    p = abs(p);\n    float c = p.x - p.y;\n    float d = p.x - p.z;\n    float e = p.y - p.z;\n    float m = max(c, max(d, e));\n    float s = (c + d + e + m) * 0.25;\n    float t = sqrt(s * (s - c) * (s - d) * (s - e));\n    return 3.0 * t / m - r;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r, float s) {\n    p = abs(p);\n    float c = p.x - p.y;\n    float d = p.x - p.z;\n    float e = p.y - p.z;\n    float m = max(c, max(d, e));\n    float t = sqrt(s * (s - c) * (s - d) * (s - e));\n    return 3.0 * t / m - r;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r, float s, float t) {\n    p = abs(p);\n    float c = p.x - p.y;\n    float d = p.x - p.z;\n    float e = p.y - p.z;\n    float m = max(c, max(", "\n    uvw = abs(uvw);\n    float a = uvw.x;\n    float b = uvw.y;\n    float c = uvw.z;\n    float d = (a + b + c) / 3.0;\n    float e = (a + b - c) / 2.0;\n    float f = (a - b + c) / 2.0;\n    float g = (a - b - c) / 2.0;\n    float h = (a + b + c) / 3.0;\n    float i = (a + b - c) / 2.0;\n    float j = (a - b + c) / 2.0;\n    float k = (a - b - c) / 2.0;\n    float l = (a + b + c) / 3.0;\n    float m = (a + b - c) / 2.0;\n    float n = (a - b + c) / 2.0;\n    float o = (a - b - c) / 2.0;\n    float p = (a + b + c) / 3.0;\n    float q = (a + b - c) / 2.0;\n    float r = (a - b + c) / 2.0;\n    float s = (a - b - c) / 2.0;\n    float t = (a + b + c) / 3.0;\n    float u = (a + b - c) / 2.0;\n    float v = (a - b + c) / 2.0;\n    float w = (a - b - c) / 2.0;\n    float x = (a + b + c) / 3.0;\n    float y = (a + b - c) / 2.0;\n    float z = (a - b + c) / 2.0;\n    float A = (a + b - c) / 2.0;\n    float B = (a - b + c) / 2.0;\n    float C = (a - b - c) / 2.0;", "\n    vec3 p = uvw * gridRes + offset;\n    vec3 q = p * (1.0 / gridRes);\n    vec3 r = p - q * gridRes;\n    vec3 s = r - q;\n    vec3 t = s - r;\n    vec3 u = t - s;\n    vec3 v = u - t;\n    vec3 w = v - u;\n    vec3 x = w - v;\n    vec3 y = x - w;\n    vec3 z = y - x;\n    vec3 a = z - y;\n    vec3 b = a - z;\n    vec3 c = b - a;\n    vec3 d = c - b;\n    vec3 e = d - c;\n    vec3 f = e - d;\n    vec3 g = f - e;\n    vec3 h = g - f;\n    vec3 i = h - g;\n    vec3 j = i - h;\n    vec3 k = j - i;\n    vec3 l = k - j;\n    vec3 m = l - k;\n    vec3 n = m - l;\n    vec3 o = n - m;\n    vec3 p1 = o - n;\n    vec3 q1 = p1 - o;\n    vec3 r1 = q1 - p1;\n    vec3 s1 = r1 - q1;\n    vec3 t1 = s1 - r1;\n    vec3 u1 = t1 - s1;\n    vec3 v1 = u1 - t1;\n    vec3 w1 = v1 - u1;\n    vec3 x1 = w1 - v1;\n    vec3 y1 = x1 - w1;\n    vec3 z1 = y1 - x1;\n    vec3 a1 = z1 - y1;\n    vec3 b1 = a1 - z1;\n    vec3 c1 = b1 - a1;\n    vec3 d1 = c1 - b1;\n    vec3", "\n  uvw = abs(uvw);\n  uvw = uvw * gridRes;\n  uvw = floor(uvw);\n  uvw = uvw / gridRes;\n  uvw = uvw * 2.0 - 1.0;\n  uvw = contrast * uvw;\n  return uvw;\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes) {\n  return quadGrid(uvw, gridRes, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw) {\n  return quadGrid(uvw, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(float contrast) {\n  return quadGrid(uvw, 1.0, contrast);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid() {\n  return quadGrid(uvw, 1.0, 1.0);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float scale) {\n  uvw = abs(uvw);\n  uvw = uvw * gridRes;\n  uvw = floor(uvw);\n  uvw = uvw / gridRes;\n  uvw = uvw * 2.0 - 1.0;\n  uvw = contrast * uvw;\n  uvw = uvw * scale;\n  return uvw;\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n  return quadGrid(uvw, gridRes, contrast, 1.0);\n", "\n    p = abs(p);\n    return (p.x + p.y + p.z - 1.0) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec2 p) {\n    p = abs(p);\n    return (p.x + p.y - 1.0) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p) {\n    p = abs(p);\n    return (p - 1.0) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r) {\n    p = abs(p);\n    return (p.x + p.y + p.z - r) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec2 p, float r) {\n    p = abs(p);\n    return (p.x + p.y - r) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float r) {\n    p = abs(p);\n    return (p - r) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 r) {\n    p = abs(p);\n    return (p.x + p.y + p.z - r.x - r.y - r.z) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec2 p, vec2 r) {\n    p = abs(p);\n    return (p.x + p.y - r.x - r.y) * 0.57735027;\n}\n\n//Icosahedron Distance from Center\n", "\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(", "\n    a = a * (3.141592653589793 / 180.0);\n    mat3 m = mat3(\n        cos(a.y) * cos(a.z),\n        sin(a.x) * sin(a.y) * cos(a.z) - cos(a.x) * sin(a.z),\n        cos(a.x) * sin(a.y) * cos(a.z) + sin(a.x) * sin(a.z),\n        cos(a.y) * sin(a.z),\n        sin(a.x) * sin(a.y) * sin(a.z) + cos(a.x) * cos(a.z),\n        cos(a.x) * sin(a.y) * sin(a.z) - sin(a.x) * cos(a.z),\n        -sin(a.y),\n        sin(a.x) * cos(a.y),\n        cos(a.x) * cos(a.y)\n    );\n    return m * v;\n}\n\n// returns a random number from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// returns a random number from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n// returns a random number from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.5432)))", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 cubic = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return value;\n}\n\nfloat fbm2(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return value;\n}\n\nfloat fbm3(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n\n", "\n    p.x = abs(p.x) - p.y/2.0;\n    p.y = abs(p.y);\n    if (p.x + p.y < 0.0) p = vec2(p.x,-p.y);\n    return length(p);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p) {\n    p.x = abs(p.x) - p.y/2.0;\n    p.y = abs(p.y);\n    if (p.x + p.y < 0.0) p = vec3(p.x,-p.y,p.z);\n    return length(p);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec4 p) {\n    p.x = abs(p.x) - p.y/2.0;\n    p.y = abs(p.y);\n    if (p.x + p.y < 0.0) p = vec4(p.x,-p.y,p.z,p.w);\n    return length(p);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float r) {\n    p.x = abs(p.x) - p.y/2.0;\n    p.y = abs(p.y);\n    if (p.x + p.y < 0.0) p = vec2(p.x,-p.y);\n    return length(p) - r;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p, float r) {\n    p.x = abs(p.x) - p.y/2.0;\n    p.y = abs(p.y);\n    if (p.x + p.y < 0.0) p = vec3(p.x,-p.y,p.z);\n    return length(p) - r;\n}\n\n// Hexagonal Distanstance from the", "\n    vec2 p = uv;\n    vec2 h = vec2(1, 0);\n    float a = atan(p.x, p.y) / 3.14159265 + 0.5;\n    float s = a - floor(a);\n    vec2 r = vec2(cos(3.14159265 * (s * 6.0 - 0.5)), sin(3.14159265 * (s * 6.0 - 0.5)));\n    vec2 id = floor(p + (r.x > r.y? h : -h) * a);\n    return hexParams(id,\n        id * 1.5707963267948966 + (r.x > r.y? h : -h) * a,\n        id * 1.5707963267948966 + (r.x > r.y? h : -h) * a - 1.5707963267948966,\n        id * 1.5707963267948966 + (r.x > r.y? h : -h) * a + 1.5707963267948966);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexInverse(hexParams h) {\n    vec2 p = h.id;\n    vec2 h = vec2(1, 0);\n    float a = atan(p.x, p.y) / 3.14159265 + 0.5;\n    float s = a - floor(a);\n    vec2 r = vec2(cos(3.14159265 * (s * 6.0 - 0.5)), sin(3.14159265 * (s * 6.0 - 0.5", "\n    vec3 col = vec3(0.0);\n    if (t < 0.267) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.333) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.4) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.467) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.533) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.6) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.667) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.733) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.8) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.867) {\n        col.r = 0.0;\n        col.g = 0.0;\n        col.b = 0.502;\n    } else if (t < 0.933) {\n        col.r = 0.0;\n        col.g = 0.0;", "\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to0(float x) {\n    return (x - 1) / 2;\n}\n\n//shifts value range from 0-1 to 0-255\nint make0to255(float x) {\n    return (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make255to0(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make0to255(float x) {\n    return (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make255to0(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make0to255(float x) {\n    return (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make255to0(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make0to255(float x) {\n    return (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make255to0(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-1 to 0-255\nint make0to255(float x) {\n    return (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make255to0(int x) {", "\n    vec2 cell = floor(uv * gridRes) + offset;\n    vec2 cellCenter = (cell + vec2(0.5)) / gridRes;\n    vec2 cellUV = (uv - cellCenter) * gridRes;\n    float cellAngle = atan(cellUV.y, cellUV.x);\n    float cellDist = length(cellUV);\n    float cellTime = time * 0.001 * cellDist;\n    float cellWave = sin(cellTime + cellAngle);\n    float cellWave2 = sin(cellTime + cellAngle + PI * 0.5);\n    float cellWave3 = sin(cellTime + cellAngle + PI);\n    float cellWave4 = sin(cellTime + cellAngle + PI * 1.5);\n    float cellWave5 = sin(cellTime + cellAngle + PI * 2.0);\n    float cellWave6 = sin(cellTime + cellAngle + PI * 2.5);\n    float cellWave7 = sin(cellTime + cellAngle + PI * 3.0);\n    float cellWave8 = sin(cellTime + cellAngle + PI * 3.5);\n    float cellWave9 = sin(cellTime + cellAngle + PI * 4.0);\n    float cellWave10 = sin(cellTime + cellAngle + PI * 4.5);\n    float cellWave11 = sin(cellTime + cellAngle + PI * 5.0);\n    float cellWave12 = sin(cellTime + cellAngle + PI * 5.5);\n    float cellWave13 = sin(cellTime + cellAngle + PI * 6.0);\n    float cellWave14 = sin(cellTime + cellAngle + PI * 6.5);\n    float cellWave15 = sin(cellTime + cellAngle + PI * 7.0);\n    float cellWave16 = sin(cellTime + cellAngle + PI * 7.5);\n    float cellWave17 = sin(cell", "\n    float t = time * 0.5;\n    float s = sin(t);\n    float c = cos(t);\n    float r = s * s + c * c;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r2 * r2;\n    float r5 = r4 * r;\n    float r6 = r4 * r2;\n    float r7 = r6 * r;\n    float r8 = r6 * r2;\n    float r9 = r8 * r;\n    float r10 = r8 * r2;\n    float r11 = r10 * r;\n    float r12 = r10 * r2;\n    float r13 = r12 * r;\n    float r14 = r12 * r2;\n    float r15 = r14 * r;\n    float r16 = r14 * r2;\n    float r17 = r16 * r;\n    float r18 = r16 * r2;\n    float r19 = r18 * r;\n    float r20 = r18 * r2;\n    float r21 = r20 * r;\n    float r22 = r20 * r2;\n    float r23 = r22 * r;\n    float r24 = r22 * r2;\n    float r25 = r24 * r;\n    float r26 = r24 * r2;\n    float r27 = r26 * r;\n    float r28 = r26 * r2;\n    float r29 = r28 * r;\n    float r30 = r28 * r2;\n    float r31 = r30 * r;\n    float r32 = r30 * r2;\n    float r33 = r32 * r;\n    float r34 = r32 * r2;\n    float r35 = r34 * r;\n    float r36 = r34 * r2;\n    float r37 = r36 * r;\n   ", "\n    float angle = time * 0.5;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.x * sin(angle) + point.y * cos(angle);\n    float r = length(point);\n    float a = atan(y, x);\n    float d = r - radius;\n    float x2 = d * cos(a);\n    float y2 = d * sin(a);\n    return vec2(x2, y2);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed) {\n    float angle = time * speed;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.x * sin(angle) + point.y * cos(angle);\n    float r = length(point);\n    float a = atan(y, x);\n    float d = r - radius;\n    float x2 = d * cos(a);\n    float y2 = d * sin(a);\n    return vec2(x2, y2);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed, float scale) {\n    float angle = time * speed;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.x * sin(angle) + point.y * cos(angle);\n    float r = length(point);\n    float a = atan(y, x);\n    float d = r - radius;\n    float x2 = d * cos(a);\n    float y2 = d * sin(a);\n    return vec2(x2, y2) * scale;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed, float scale, float offset) {\n    float angle = time * speed;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n", "\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileOffset) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, float tileOffset) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, vec2 tileOffset) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileOffsetX, float tileOffsetY) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + vec2(tileOffsetX, tileOffsetY);\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, float tile", "\n    vec2 d = p2 - p1;\n    vec2 w = p - p1;\n    float b = dot(w, d);\n    float c = dot(w, w);\n    float r = b / c;\n    vec2 pb = p1 + r * d;\n    return length(p - pb);\n}\n\n// Computes the signed distance from a rectangle\nfloat rect(vec2 p, vec2 p1, vec2 p2) {\n    vec2 d = abs(p - p1) - p2;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\n// Computes the signed distance from a polygon\nfloat poly(vec2 p, vec2[] pts) {\n    float d = line(p, pts[0], pts[1]);\n    for (int i = 1; i < pts.length; i++) {\n        d = min(d, line(p, pts[i - 1], pts[i]));\n    }\n    return d;\n}\n\n// Computes the signed distance from a triangle\nfloat tri(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p3 - p1;\n    vec2 q = p - p1;\n    vec2 d1 = q - e1 * clamp(dot(q, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 d2 = q - e2 * clamp(dot(q, e2) / dot(e2, e2), 0.0, 1.0);\n    return min(min(length(d1), length(d2)), length(q - e1 * clamp(dot(e1, q) / dot(e1", "\n    float d = length(p) - v.x;\n    float a = atan(p.y, p.x) - v.y;\n    return d * sign(cos(a)) - abs(sin(a)) * length(p);\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p) {\n    return arrow(p, arrowTileCenterCoord(p));\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float v) {\n    return arrow(p, vec2(v, 0.0));\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float v, float a) {\n    return arrow(p, vec2(v, a));\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float a) {\n    return arrow(p, v.x, a);\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float v, vec2 a) {\n    return arrow(p, v, a.x);\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, vec2 a) {\n    return arrow(p, v.x, a.x);\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float v, float a, float s) {\n    return arrow(p, v, a) * s;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float a, float s) {\n    return arrow(p, v, a) * s;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, float v, vec2 a, float s) {\n    return arrow(p, v, a) * s;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, vec2 a, float s) {\n    return arrow(p, v, a) * s;\n}\n\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p,", "\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec2 make0to255(vec2 x) {\n    return x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec2 make255to0(vec2 x) {\n    return x / 255.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec2 make0to255(vec2 x) {\n    return x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec2 make255to0(vec2 x) {\n    return x / 255.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec2 make0to255(vec2 x) {\n    return x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec2 make255to0(vec2 x) {\n    return x / 255.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec2 make0to255(vec2 x) {\n    return x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec2 make255to0(vec2 x) {\n    return x / 255.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec2 make0to255(vec2 x) {\n    return x * 255.0;\n}\n\n//shifts value range from 0-255 to 0", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius * spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a circle centered on point\nvec2 circleFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius * spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a square centered on point\nvec2 squareFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius * spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a triangle centered on point\nvec2 triangleFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius * spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a pentagon centered on point\nvec2 pentagonFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius * spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdRoundedBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p)-b+r;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(ra, rb, h);\n}\n\nfloat sdCyl", "\n    float t = time;\n    float s = sp;\n    float r = sdRoundedBox(p, vec2(s,s), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(s,0.0), vec2(s,s), 0.1), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(0.0,s), vec2(s,s), 0.1), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(s,s), vec2(s,s), 0.1), 0.1);\n    return r;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp, in float time )\n{\n    float t = time;\n    float s = sp;\n    float r = sdRoundedBox(p, vec2(s,s), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(s,0.0), vec2(s,s), 0.1), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(0.0,s), vec2(s,s), 0.1), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(s,s), vec2(s,s), 0.1), 0.1);\n    return r;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp, in float time )\n{\n    float t = time;\n    float s = sp;\n    float r = sdRoundedBox(p, vec2(s,s), 0.1);\n    r = opSmoothUnion(r, sdRoundedBox(p-vec2(s,0.0", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float c = floor(a/sp);\n    float d = mod(a,sp);\n    float r0 = r - c*ra;\n    float r1 = r - (c+1.0)*ra;\n    float r2 = r - (c+2.0)*ra;\n    float r3 = r - (c+3.0)*ra;\n    float r4 = r - (c+4.0)*ra;\n    float r5 = r - (c+5.0)*ra;\n    float r6 = r - (c+6.0)*ra;\n    float r7 = r - (c+7.0)*ra;\n    float r8 = r - (c+8.0)*ra;\n    float r9 = r - (c+9.0)*ra;\n    float r10 = r - (c+10.0)*ra;\n    float r11 = r - (c+11.0)*ra;\n    float r12 = r - (c+12.0)*ra;\n    float r13 = r - (c+13.0)*ra;\n    float r14 = r - (c+14.0)*ra;\n    float r15 = r - (c+15.0)*ra;\n    float r16 = r - (c+16.0)*ra;\n    float r17 = r - (c+17.0)*ra;\n    float r18 = r - (c+18.0)*ra;\n    float r19 = r - (c+19.0)*ra;\n    float r20 = r - (c+20.0)*ra;\n    float r21 = r - (c+21.0)*ra;\n    float r22 = r - (c+22.0)*ra;\n    float r23 = r - (c+23.0)*ra;\n    float r24 = r - (c+24.0)*ra;\n    float r25 = r - (c+25.", "\n    uvw = abs(uvw);\n    return max(uvw.x, max(uvw.y, uvw.z));\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw) - 1.0;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    return length(vec2(length(uvw.xz) - 1.0, uvw.y)) - 0.2;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return max(length(uvw.xz) - 1.0, abs(uvw.y) - 0.5);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float q = length(uvw.xz);\n    return max(q * (uvw.y + 1.0), -uvw.y);\n}\n\n//edge distance of a Plane\nfloat planeDist(vec3 uvw) {\n    return uvw.y;\n}\n\n//edge distance of a Tetrahedron\nfloat tetrahedronDist(vec3 uvw) {\n    uvw = abs(uvw);\n    return (uvw.x + uvw.y + uvw.z - 1.0) * 0.57735027;\n}\n\n//edge distance of a Octahedron\nfloat octahedronDist(vec3 uvw) {\n    uvw = abs(uvw);\n    return (uvw.x + uvw.y + uvw.z - 1.0) * 0.57735027;\n}\n\n//edge distance of a Dodecahedron\nfloat dodecahedronDist(vec3 uvw) {\n    uvw = abs(uvw);\n    return (uvw.x + uvw.y + uvw.z - 1.0) * 0.57735027", "\n    vec3 uv = uvw;\n    float u = uv.x;\n    float v = uv.y;\n    float w = uv.z;\n    float u2 = u * u;\n    float v2 = v * v;\n    float w2 = w * w;\n    float u2v2 = u2 + v2;\n    float u2w2 = u2 + w2;\n    float v2w2 = v2 + w2;\n    float u2v2w2 = u2v2 + w2;\n    float u2v2w2_2 = u2v2w2 + u2v2w2;\n    float u2v2w2_4 = u2v2w2_2 + u2v2w2_2;\n    float u2v2w2_8 = u2v2w2_4 + u2v2w2_4;\n    float u2v2w2_16 = u2v2w2_8 + u2v2w2_8;\n    float u2v2w2_32 = u2v2w2_16 + u2v2w2_16;\n    float u2v2w2_64 = u2v2w2_32 + u2v2w2_32;\n    float u2v2w2_128 = u2v2w2_64 + u2v2w2_64;\n    float u2v2w2_256 = u2v2w2_128 + u2v2w2_128;\n    float u2v2w2_512 = u2v2w2_256 + u2v2w2_256;\n    float u2v2w2_1024 = u2v2w2_512 + u2v2w2_512;\n    float u2v2w2_2048 = u2v2w2_1024 + u2v2w2_1024;\n    float u2v2w2_4096 =", "\n    vec3 uvw_ = uvw * gridRes + offset;\n    vec3 uvw_abs = abs(uvw_);\n    float m = max(uvw_abs.x, max(uvw_abs.y, uvw_abs.z));\n    vec3 uvw_scaled = uvw_ / m;\n    return texture(cubeTex, uvw_scaled);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset) {\n    return cubeCell(uvw, offset, 1.0);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw) {\n    return cubeCell(uvw, vec3(0.0), 1.0);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, float gridRes) {\n    return cubeCell(uvw, vec3(0.0), gridRes);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes, float gridRes2) {\n    vec3 uvw_ = uvw * gridRes + offset;\n    vec3 uvw_abs = abs(uvw_);\n    float m = max(uvw_abs.x, max(uvw_abs.y, uvw_abs.z));\n    vec3 uvw_scaled = uvw_ / m;\n    return texture(cubeTex, uvw_scaled);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes, float gridRes2, float gridRes3) {\n    vec3 uvw_ = uvw * gridRes + offset;\n    vec3 uvw_abs = abs(uvw_);\n    float m = max(uvw_abs.x, max(uvw_abs.y, uvw_abs.z));\n    vec3 uvw_", "\n    vec3 RdYlBu_r = vec3(0.0);\n    if (t < 0.25) {\n        RdYlBu_r = vec3(0.0, 2.0 / 3.0, 1.0) * (4.0 * t) + vec3(0.0, 0.0, 1.0);\n    } else if (t < 0.5) {\n        RdYlBu_r = vec3(0.0, 2.0 / 3.0, 1.0) * (4.0 * (0.5 - t)) + vec3(0.0, 1.0, 1.0);\n    } else if (t < 0.75) {\n        RdYlBu_r = vec3(0.0, 1.0, 2.0 / 3.0) * (4.0 * (t - 0.5)) + vec3(0.0, 1.0, 0.0);\n    } else {\n        RdYlBu_r = vec3(2.0 / 3.0, 1.0, 0.0) * (4.0 * (1.0 - t)) + vec3(1.0, 1.0, 0.0);\n    }\n    return RdYlBu_r;\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    vec3 RdYlBu_r = vec3(0.0);\n    if (t < 0.25) {\n        RdYlBu_r = vec3(0.0, 2.0 / 3.0, 1.0) * (4.0 * t) + vec3(0.0, 0.0, 1.0);\n    } else if (t < 0.5) {\n        RdYlBu_r = vec3(0.0, 2.0 / 3.", "\n    p = abs(p);\n    return (p.x + p.y + p.z - 1.0);\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    p = abs(p);\n    return (p.x + p.y + p.z - 1.0);\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    p = abs(p);\n    return (p.x + p.y + p.z - 1.0);\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n    const float k = 1.73205080756887729352;\n    p = abs(p);\n    return (p.x + p.y + p.z - k) * 0.577350269189625731058;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecDist(vec3 p) {\n    const float k = 1.259921049894873164767;\n    p = abs(p);\n    return (p.x + p.y + p.z - k) * 0.707106781186547524401;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n    const float k = 1.73205080756887729352;\n    p = abs(p);\n    return (p.x + p.y + p.z - k) * 0.577350269189625731058;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecDist(vec3 p) {\n    const float k = 1.2599210498948731647", "\n    vec3 c1 = vec3(0.0, 0.0, 0.5);\n    vec3 c2 = vec3(0.0, 0.5, 1.0);\n    vec3 c3 = vec3(0.5, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 0.5);\n    vec3 c5 = vec3(1.0, 0.5, 0.0);\n    vec3 c6 = vec3(0.5, 0.0, 0.0);\n\n    if (t < 1.0/6.0) {\n        return mix(c1, c2, t*6.0);\n    } else if (t < 2.0/6.0) {\n        return mix(c2, c3, t*6.0-1.0);\n    } else if (t < 3.0/6.0) {\n        return mix(c3, c4, t*6.0-2.0);\n    } else if (t < 4.0/6.0) {\n        return mix(c4, c5, t*6.0-3.0);\n    } else if (t < 5.0/6.0) {\n        return mix(c5, c6, t*6.0-4.0);\n    } else {\n        return mix(c6, c1, t*6.0-5.0);\n    }\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    vec3 c1 = vec3(0.5, 0.0, 0.0);\n    vec3 c2 = vec3(1.0, 0.5, 0.0);\n    vec3 c3 = vec3(1.0, 1.0, 0.5);\n    vec3 c4 = vec3(0.5, 1.0, 1.0);\n    vec3 c5 = vec3(0", "\n    return vec3(uv, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale) {\n    return vec3(uv * scale, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset) {\n    return vec3(uv * scale + offset, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation) {\n    return vec3(uv * scale + offset, rotation);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation, float time) {\n    return vec3(uv * scale + offset, rotation + time);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation, float time, float speed) {\n    return vec3(uv * scale + offset, rotation + time * speed);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation, float time, float speed, float timeOffset) {\n    return vec3(uv * scale + offset, rotation + time * speed + timeOffset);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation, float time, float speed, float timeOffset, float timeScale) {\n    return vec3(uv * scale + offset, rotation + time * speed + timeOffset * timeScale);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation, float time, float speed, float timeOffset, float timeScale, float timeOffset2) {\n    return vec3(uv * scale + offset, rotation + time * speed + timeOffset * timeScale + timeOffset2);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float scale, float offset, float rotation, float time, float speed, float timeOffset, float timeScale, float timeOffset2, float timeScale2) {", "\n    vec2 p = uv;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return vec3(p, 1.0 - max(p.x, p.y));\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale) {\n    vec2 p = uv * scale;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return vec3(p, 1.0 - max(p.x, p.y));\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset) {\n    vec2 p = uv * scale;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return vec3(p, 1.0 - max(p.x, p.y) + offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float rotation) {\n    vec2 p = uv * scale;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return vec3(p, 1.0 - max(p.x, p.y) + offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float rotation, float rotationOffset) {\n    vec2 p = uv * scale;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return vec3(p, 1.0 - max(p.x, p.y) + offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float rotation, float rotationOffset, float rotationOffset2) {\n    vec2 p = uv * scale;\n    p.x = abs(p.x);\n   ", "\n  vec2 grid = floor(uv * gridRes) / gridRes;\n  return vec3(grid, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes) {\n  return squarePixelizor(uv, gridRes, vec2(0.0));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv) {\n  return squarePixelizor(uv, 10.0, vec2(0.0));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset) {\n  return squarePixelizor(uv, gridRes, vec2(offset));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offsetX, float offsetY) {\n  return squarePixelizor(uv, gridRes, vec2(offsetX, offsetY));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n  vec2 grid = floor(uv * gridRes) / gridRes;\n  return vec3(grid, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n  vec2 grid = floor(uv * gridRes) / gridRes;\n  return vec3(grid, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n  vec2 grid = floor(uv * gridRes) / gridRes;\n  return vec3(grid, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n  vec2 grid = floor(uv * gridRes) / gridRes;", "\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridSize) {\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridSize, float gridOffset) {\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridSize, float gridOffset, float gridRotation) {\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridSize, float gridOffset, float gridRotation, float gridScale) {\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridSize, float gridOffset, float gridRotation, float gridScale, float gridOpacity) {\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p, 0.0);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridSize, float gridOffset, float gridRotation, float gridScale, float gridOpacity, float gridColor) {\n  vec2 p = floor(uv * gridRes) / gridRes;\n  return vec3(p", "\n    vec2 cell = floor(uv * gridRes) + offset;\n    float cellTime = time * 0.001;\n    float cellTime2 = time * 0.002;\n    float cellTime3 = time * 0.003;\n    float cellTime4 = time * 0.004;\n    float cellTime5 = time * 0.005;\n    float cellTime6 = time * 0.006;\n    float cellTime7 = time * 0.007;\n    float cellTime8 = time * 0.008;\n    float cellTime9 = time * 0.009;\n    float cellTime10 = time * 0.01;\n    float cellTime11 = time * 0.011;\n    float cellTime12 = time * 0.012;\n    float cellTime13 = time * 0.013;\n    float cellTime14 = time * 0.014;\n    float cellTime15 = time * 0.015;\n    float cellTime16 = time * 0.016;\n    float cellTime17 = time * 0.017;\n    float cellTime18 = time * 0.018;\n    float cellTime19 = time * 0.019;\n    float cellTime20 = time * 0.02;\n    float cellTime21 = time * 0.021;\n    float cellTime22 = time * 0.022;\n    float cellTime23 = time * 0.023;\n    float cellTime24 = time * 0.024;\n    float cellTime25 = time * 0.025;\n    float cellTime26 = time * 0.026;\n    float cellTime27 = time * 0.027;\n    float cellTime28 = time * 0.028;\n    float cellTime29 = time * 0.029;\n    float cellTime30 = time * 0.0", "\n    vec2 cell = floor(uv * gridRes);\n    vec2 cellCenter = (cell + vec2(0.5)) / gridRes;\n    vec2 cellDir = normalize(uv - cellCenter);\n    float cellTime = time * 0.5 + cell.x * 100.0 + cell.y * 100.0;\n    float cellAngle = cellTime * 0.1;\n    vec2 cellDirRot = vec2(cos(cellAngle), sin(cellAngle));\n    float cellDist = length(uv - cellCenter);\n    float cellDistFade = smoothstep(0.0, 1.0, cellDist);\n    float cellDirDot = dot(cellDir, cellDirRot);\n    float cellDirDotFade = smoothstep(0.0, 1.0, cellDirDot);\n    float cellDirDotFade2 = smoothstep(0.0, 1.0, cellDirDot * 2.0 - 1.0);\n    float cellDirDotFade3 = smoothstep(0.0, 1.0, cellDirDot * 4.0 - 2.0);\n    float cellDirDotFade4 = smoothstep(0.0, 1.0, cellDirDot * 8.0 - 4.0);\n    float cellDirDotFade5 = smoothstep(0.0, 1.0, cellDirDot * 16.0 - 8.0);\n    float cellDirDotFade6 = smoothstep(0.0, 1.0, cellDirDot * 32.0 - 16.0);\n    float cellDirDotFade7 = smoothstep(0.0, 1.0, cellDirDot * 64.0 - 32.0);\n    float cellDirDotFade8 = smoothstep(0.0, 1.0, cellDirDot * 128.0 - 64.0);\n    float cellDirDotFade9 = smoothstep(0.0, 1.0, cellDirDot * 2", "\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 aa = vec2(0.0);\n    aa += 0.5000*step(w.y,p.x+0.5000)*step(p.y+0.5000,w.x);\n    aa += 0.7500*step(w.y,p.x+0.7500)*step(p.y+0.2500,w.x);\n    aa += 0.7500*step(w.y,p.x+0.2500)*step(p.y+0.7500,w.x);\n    aa += 0.5000*step(w.y,p.x+0.5000)*step(p.y+0.5000,w.x);\n    return clamp(aa.x+aa.y,0.0,1.0);\n}\n\nfloat gridTexture( in vec2 p )\n{\n    return gridTextureGradBox(p, dFdx(p), dFdy(p));\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    return gridTextureGradBox(p, ddx, ddy);\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    return gridTextureGradBox(p*scale, ddx*scale, ddy*scale);\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float offset )\n{\n    return gridTextureGradBox((p+offset)*scale, ddx*scale, ddy*scale);\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float offset, in float size )\n{\n    return gridTextureGradBox((p+offset)*scale, ddx*scale, ddy*scale, size);\n", "\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r, float s) {\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r, float s, float t) {\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r, float s, float t, float u) {\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r, float s, float t, float u, float v) {\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r, float s, float t, float u, float v, float w) {\n    p = abs(p);\n    return max(p.x + p.y * 0.866025404, p.y * 1.732050808) - r;\n}\n\nfloat hexagon(vec2 p, float r, float s, float t, float u, float v, float w, float x) {\n    p = abs(p);\n    return max(p.x + p.y * 0.86602", "\n    p = fract(p * 0.5) * 2.0 - 1.0;\n    if (p.x > p.y) {\n        p = p.yx;\n    }\n    return p;\n}\n\nvec2 hextile(inout vec2 p, float scale) {\n    p = fract(p * scale) * 2.0 - 1.0;\n    if (p.x > p.y) {\n        p = p.yx;\n    }\n    return p;\n}\n\nvec2 hextile(inout vec2 p, float scale, float offset) {\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    if (p.x > p.y) {\n        p = p.yx;\n    }\n    return p;\n}\n\nvec2 hextile(inout vec2 p, float scale, float offset, float rotation) {\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    if (p.x > p.y) {\n        p = p.yx;\n    }\n    p = rotate(p, rotation);\n    return p;\n}\n\nvec2 hextile(inout vec2 p, float scale, float offset, float rotation, float skew) {\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    if (p.x > p.y) {\n        p = p.yx;\n    }\n    p = rotate(p, rotation);\n    p = skew(p, skew);\n    return p;\n}\n\nvec2 hextile(inout vec2 p, float scale, float offset, float rotation, float skew, float aspect) {\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    if (p.x > p.y) {\n        p = p.yx;\n    }\n    p = rotate(p, rotation);\n    p = skew(p, skew);\n    p = aspect(p, aspect", "\n    return fract(sin(x)*43758.5453);\n}\n\nfloat noise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( fun(i), fun(i+1.0), f );\n}\n\nfloat fbm( in float x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    float shift = sin(x*1.0)*0.1;\n    for (int i = 0; i < 5; ++i)\n    {\n        v += a * noise(x*1.0+shift);\n        x *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm2( in float x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    float shift = sin(x*1.0)*0.1;\n    for (int i = 0; i < 5; ++i)\n    {\n        v += a * noise(x*1.0+shift);\n        x *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm3( in float x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    float shift = sin(x*1.0)*0.1;\n    for (int i = 0; i < 5; ++i)\n    {\n        v += a * noise(x*1.0+shift);\n        x *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm4( in float x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    float shift = sin(x*1.0)*0.1;\n    for (int i = 0; i < 5; ++i)\n    {\n        v += a * noise(x*1.0+shift);\n        x *= 2.", "\n    return mix(1.055 * pow(t, vec3(0.4166667)) - 0.055, t * 12.92, lessThanEqual(t, vec3(0.0031308)));\n}\n\nvec3 linear(vec3 t) {\n    return mix(pow((t + 0.055) / 1.055, vec3(2.4)), t / 12.92, lessThanEqual(t, vec3(0.04045)));\n}\n\nvec3 sRGB(vec4 t) {\n    return sRGB(t.rgb);\n}\n\nvec3 linear(vec4 t) {\n    return linear(t.rgb);\n}\n\nvec3 sRGB(vec2 t) {\n    return sRGB(vec3(t, 0.0));\n}\n\nvec3 linear(vec2 t) {\n    return linear(vec3(t, 0.0));\n}\n\nvec3 sRGB(float t) {\n    return sRGB(vec3(t, 0.0, 0.0));\n}\n\nvec3 linear(float t) {\n    return linear(vec3(t, 0.0, 0.0));\n}\n\nvec4 sRGB(vec3 t) {\n    return vec4(sRGB(t), 1.0);\n}\n\nvec4 linear(vec3 t) {\n    return vec4(linear(t), 1.0);\n}\n\nvec4 sRGB(vec2 t) {\n    return vec4(sRGB(t), 0.0, 1.0);\n}\n\nvec4 linear(vec2 t) {\n    return vec4(linear(t), 0.0, 1.0);\n}\n\nvec4 sRGB(float t) {\n    return vec4(sRGB(t), 0.0, 0.0, 1.0);\n}\n\nvec4 linear(float t) {\n    return vec4(", "\n    return length(p) - 0.5;\n}\n\nfloat df1(vec2 p) {\n    return length(p - vec2(0.5, 0.5)) - 0.5;\n}\n\nfloat df2(vec2 p) {\n    return length(p - vec2(0.5, -0.5)) - 0.5;\n}\n\nfloat df3(vec2 p) {\n    return length(p - vec2(-0.5, 0.5)) - 0.5;\n}\n\nfloat df4(vec2 p) {\n    return length(p - vec2(-0.5, -0.5)) - 0.5;\n}\n\nfloat df5(vec2 p) {\n    return length(p - vec2(0.5, 0.0)) - 0.5;\n}\n\nfloat df6(vec2 p) {\n    return length(p - vec2(0.5, 0.0)) - 0.5;\n}\n\nfloat df7(vec2 p) {\n    return length(p - vec2(0.0, 0.5)) - 0.5;\n}\n\nfloat df8(vec2 p) {\n    return length(p - vec2(0.0, 0.5)) - 0.5;\n}\n\nfloat df9(vec2 p) {\n    return length(p - vec2(0.5, 0.5)) - 0.5;\n}\n\nfloat df10(vec2 p) {\n    return length(p - vec2(0.5, -0.5)) - 0.5;\n}\n\nfloat df11(vec2 p) {\n    return length(p - vec2(-0.5, 0.5)) - 0.5;\n}\n\nfloat df12(vec2 p) {\n    return length(p - vec2(-0.5, -0.5)) - 0.5;\n}\n\nfloat df13(vec2 p) {\n    return length(p - vec2(0.5", "\n    float d = length(p) - 1.0;\n    float a = atan(p.y, p.x);\n    float r = mod(a, 0.7853981633974483);\n    return d * (r < 0.39269908169872415? 1.0 : -1.0);\n}\n\nfloat df2(vec2 p) {\n    float d = length(p) - 1.0;\n    float a = atan(p.y, p.x);\n    float r = mod(a, 0.7853981633974483);\n    return d * (r < 0.39269908169872415? -1.0 : 1.0);\n}\n\nfloat df3(vec2 p) {\n    float d = length(p) - 1.0;\n    float a = atan(p.y, p.x);\n    float r = mod(a, 0.7853981633974483);\n    return d * (r < 0.39269908169872415? 1.0 : 1.0);\n}\n\nfloat df4(vec2 p) {\n    float d = length(p) - 1.0;\n    float a = atan(p.y, p.x);\n    float r = mod(a, 0.7853981633974483);\n    return d * (r < 0.39269908169872415? -1.0 : -1.0);\n}\n\nfloat df5(vec2 p) {\n    float d = length(p) - 1.0;\n    float a = atan(p.y, p.x);\n    float r = mod(a, 0.7853981633974483);\n    return d * (r < ", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = vec2(e1.x*v0.y - e1.y*v0.x, e2.x*v1.y - e2.y*v1.x) / s;\n\n    return sqrt( min( dot2(pq0), dot2(pq1) ) ) * sign( s ) * step( 0.0, s );\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, out vec2 bary )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = -b - h;\n    if( t<dbuffer ) {\n        t = -b + h;\n        if( t<dbuffer ) return -1.0;\n    }\n    return t;\n}\n\nfloat sphsdf(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = -b - h;\n    return t;\n}\n\nfloat sphsdf(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = -b - h;\n    if( t<dbuffer ) {\n        t = -b + h;\n        if( t<dbuffer ) return -1.0;\n    }\n    return t;\n}\n\nfloat sphsdf(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float tmin, float tmax) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph", "\n    return length(p - vec2(clamp(p.x, -w, w), 0.0)) - r;\n}\n\nfloat roundedY(vec2 p, float w, float r) {\n    return length(p - vec2(0.0, clamp(p.y, -w, w))) - r;\n}\n\nfloat rounded(vec2 p, float w, float r) {\n    return max(roundedX(p, w, r), roundedY(p, w, r));\n}\n\nfloat rounded(vec2 p, float w, float r, float r2) {\n    return max(roundedX(p, w, r), roundedY(p, w, r2));\n}\n\nfloat rounded(vec2 p, float w, float r, float r2, float r3) {\n    return max(roundedX(p, w, r), max(roundedY(p, w, r2), roundedX(p, w, r3)));\n}\n\nfloat rounded(vec2 p, float w, float r, float r2, float r3, float r4) {\n    return max(roundedX(p, w, r), max(roundedY(p, w, r2), max(roundedX(p, w, r3), roundedY(p, w, r4))));\n}\n\nfloat rounded(vec2 p, float w, float r, float r2, float r3, float r4, float r5) {\n    return max(roundedX(p, w, r), max(roundedY(p, w, r2), max(roundedX(p, w, r3), max(roundedY(p, w, r4), roundedX(p, w, r5)))));\n}\n\nfloat rounded(vec2 p, float w, float r, float r2, float r3, float r4, float r5, float r6) {\n    return max(roundedX(p, w, r), max(roundedY(p, w, r2), max(roundedX(p, w, r3), max(roundedY(p, w, r4), max(roundedX(", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    float m = p.x*p.x + p.y*p.y;\n    return (m<1.0)? sqrt(m) * (1.0 - k) + p.x * p.y * k : m;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    float m = p.x*p.x + p.y*p.y + p.z*p.z;\n    return (m<1.0)? sqrt(m) * (1.0 - k) + p.x * p.y * p.z * k : m;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, float k )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    p.w = abs(p.w);\n    float m = p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w;\n    return (m<1.0)? sqrt(m) * (1.0 - k) + p.x * p.y * p.z * p.w * k : m;\n}", "\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec3 p )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec4 p )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in float p )\n{\n    float d = p;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float t )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec3 p, in float t )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec4 p, in float t )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in float p, in float t )\n{\n    float d = p;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in vec2 t )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec3 p, in vec3 t )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec4 p, in vec4 t )\n{\n    float d = p.y/p.x;\n    return d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in float p, in vec", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b, float k, float m) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h) - m * h;\n}\n\nfloat smin(float a, float b, float k, float m) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h) + m * h;\n}\n\nfloat smin(float a, float b, float k, float m, float n) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return", "\n    a = abs(a);\n    return mix(a, -a, step(k, a));\n}\n\nfloat pabs(float a) {\n    return pabs(a, 0.0);\n}\n\nvec2 pabs(vec2 a, float k) {\n    a = abs(a);\n    return mix(a, -a, step(k, a));\n}\n\nvec2 pabs(vec2 a) {\n    return pabs(a, 0.0);\n}\n\nvec3 pabs(vec3 a, float k) {\n    a = abs(a);\n    return mix(a, -a, step(k, a));\n}\n\nvec3 pabs(vec3 a) {\n    return pabs(a, 0.0);\n}\n\nvec4 pabs(vec4 a, float k) {\n    a = abs(a);\n    return mix(a, -a, step(k, a));\n}\n\nvec4 pabs(vec4 a) {\n    return pabs(a, 0.0);\n}\n", "\n    p = (p - vec2(0.0, 1.0)) * vec2(1.0, 1.0);\n    float a = length(p);\n    float b = atan(p.y, p.x);\n    float c = length(p * vec2(cos(b), -sin(b)));\n    c *= c;\n    a = 13.0 * sqrt(a);\n    return (13.0 * a - 22.0 * c + (10.0 * a - 3.0 * c) * cos(3.0 * b) + (a - c) * cos(4.0 * b)) / 14.0;\n}\n\nfloat heart(float x, float y) {\n    return heart(vec2(x, y));\n}\n\nfloat heart(float x) {\n    return heart(x, 0.0);\n}\n\nfloat heart(vec2 p, float r) {\n    return heart(p) - r;\n}\n\nfloat heart(float x, float y, float r) {\n    return heart(x, y) - r;\n}\n\nfloat heart(float x, float r) {\n    return heart(x, 0.0, r);\n}\n\nfloat heart(vec2 p, float r, float s) {\n    return heart(p, r) * s;\n}\n\nfloat heart(float x, float y, float r, float s) {\n    return heart(x, y, r) * s;\n}\n\nfloat heart(float x, float r, float s) {\n    return heart(x, 0.0, r, s);\n}\n\nfloat heart(vec2 p, float r, float s, float t) {\n    return heart(p, r, s) + t;\n}\n\nfloat heart(float x, float y, float r, float s, float t) {\n    return heart(x, y, r, s) + t;\n}\n\nfloat heart(float x, float r, float s, float t) {\n    return heart(x, 0.0, r, s, t);\n}\n\nfloat", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec4 p4) {\n    p4  = fract(p4 *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    p4 += dot(p4, p4.zxy + 33.33);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec4 p4) {\n    p4  = fract(p4 *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    p4 += dot(p4, p4.zxy + 33.33);\n    p4 += dot(p4, p4.yxz + 33.33);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec4 p4) {\n    p4  = fract(p4 *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n", "\n    vec2 P = pos - A;\n    vec2 Q = B - A;\n    vec2 R = C - B;\n    vec2 S = A - C;\n\n    vec2 dP = P;\n    vec2 dQ = Q - P;\n    vec2 dR = R - Q;\n    vec2 dS = S - R;\n\n    float t = dot(dP,dP);\n    float a = dot(dP,dQ);\n    float b = dot(dQ,dQ);\n    float c = dot(dR,dQ);\n    float d = dot(dP,dR);\n    float e = dot(dR,dR);\n    float f = dot(dS,dR);\n    float g = dot(dS,dS);\n\n    float k = inversesqrt(b*e*g - c*c);\n    float j = k*(b*f - c*d);\n    float t2 = k*(a*e - b*d);\n    float t1 = k*(a*f - b*c);\n\n    float x = t1*t1*t1 - 3.0*t1*t2 + t2*t2 + 2.0*t1*t - t*t2 - t*t1 + t*t;\n    float y = 3.0*t1*t1 - 2.0*t1*t2;\n\n    float z = t2*t2*t2 - 3.0*t2*t1 + t*t2 - t*t1 + 1.0;\n\n    float w = sqrt(x*x + 4.0*y*z);\n    float s = clamp((w - x)/(2.0*y), 0.0, 1.0);\n\n    vec2 dPdS = 2.0*s*(s*R + (1.0-s)*S) - P;\n    vec2 dPdT = 2.0*(c*s*(s*R + (1.0-s)*S) + b*s*s*S + a*s", "\n    vec2 p = pos;\n    float w = wi;\n    float h = he;\n    float k = (w*w+h*h)/(w*w);\n    vec2 c = vec2(-w*h*h/w,0.0);\n    vec2 v = p-c;\n    vec2 d = v*mat2(k,-h,h,k);\n    float s = sign(d.x);\n    vec2 r = v*s - s*h*h/w;\n    float q = dot(r,r);\n    float dq = q*(w*w/h*h-1.0);\n    float z = sqrt(dq);\n    vec2 uv = sign(q)*r*inversesqrt(vec2(dq,z*w));\n    vec2 duv = d*s/z - uv*dq/z;\n    float x = dot(uv,uv);\n    vec3 res = vec3(x,uv.x,uv.y);\n    res.z = dot(duv,duv);\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipsoid( in vec3 pos, in vec3 r )\n{\n    vec3 p = pos;\n    vec3 r2 = r*r;\n    vec3 p2 = p*p;\n    vec3 q = p2/r2;\n    float d = dot(q,vec3(1.0));\n    float x = dot(p2,vec3(1.0)) - d;\n    vec3 duv = p*(2.0*q/r2 - vec3(d));\n    return vec3(x,duv.x,duv.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\ufffd", "\n    vec2 p = pos*pos;\n    vec2 p0 = p*k;\n    float h = k*(p.x+p.y);\n    float d = h*h - p0.x - p0.y;\n    vec2 g = p*k*2.0;\n    vec2 dg = vec2(g.x*h - p0.x, g.y*h - p0.y);\n    float l = length(dg);\n    vec3 res;\n    res.x = sqrt(d*d + l*l);\n    res.yz = dg/l;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec3 pos, in float k )\n{\n    vec2 p = pos.xy*pos.xy;\n    vec2 p0 = p*k;\n    float h = k*(p.x+p.y);\n    float d = h*h - p0.x - p0.y;\n    vec2 g = p*k*2.0;\n    vec2 dg = vec2(g.x*h - p0.x, g.y*h - p0.y);\n    float l = length(dg);\n    vec3 res;\n    res.x = sqrt(d*d + l*l);\n    res.yz = dg/l;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in vec2 k )\n{\n    vec2 p = pos*pos;\n    vec2 p0", "\n    vec2 q = p;\n    float a = atan(q.y, q.x);\n    float r = length(q);\n    float b = (1.0 - rb) * ra / rb;\n    float c = (ra - rb) / (ra + rb);\n    float k = (1.0 + c * c) / (1.0 - c);\n    float h = (r - ra) / (r + ra) * k;\n    float d1 = sqrt(h * h + d * d);\n    float a1 = atan(d, h);\n    float x = c * a1 + a;\n    float y = sqrt(h * h + d * d) * (c * sin(a1) - 1.0) / r;\n    float z = -sqrt(h * h + d * d) * sin(a1) * c / r;\n    float r1 = sqrt(x * x + y * y);\n    float a2 = atan(y, x);\n    float s = (r1 - ra) / (r1 + ra);\n    float da = abs(a2 - a);\n    float x1 = s * cos(da);\n    float y1 = s * sin(da);\n    float r2 = sqrt(x1 * x1 + y1 * y1);\n    float a3 = atan(y1, x1);\n    float f = (r2 - b) / (r2 + b);\n    float x2 = f * cos(a3);\n    float y2 = f * sin(a3);\n    float r3 = sqrt(x2 * x2 + y2 * y2);\n    float a4 = atan(y2, x2);\n    float g = (r3 - c) / (r3 + c);\n    float x3 = g * cos(a4);\n    float y3 = g * sin(a4);\n    float r4 = sqrt(x3 * x3 + y3 * y3);\n    float a5 = atan(y3, x3);\n    float h1 = (r4 - 1.0) / (", "\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v >> 16);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v >> 16);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nfloat Pcg2(float v)\n{\n    v = v * 1664525u + 1013904223u;\n    v = v ^ (v >> 16);\n    v = v * 1664525u + 1013904223u;\n    v = v ^ (v >> 16);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nvec2 Pcg2(vec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v >> 16);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v >> 16);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jc", "\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nfloat Pcg3(float v)\n{\n    v = v * 1664525u + 1013904223u;\n    v = v + (v >> 16u);\n    v = v * 15485863u;\n    v = v + (v >> 16u);\n    v = v * 15485863u;\n    v = v + (v >> 16u);\n    return v * (1.0 / 4294967296.0);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nvec3 Pcg3(vec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return v * (1.0 / 42", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    vec3 res = vec3(dot(d, d), ky * ky - 4.0 * kx * kz, 2.0 * ky * kz - kx * kx - kx * kx);\n    vec2 h = max(vec2(0.0, -1.0), min(vec2(1.0, 0.0), -res.yz / (2.0 * res.x)));\n    float s = clamp(h.x + h.y, 0.0, 1.0);\n    vec2 d2 = res.yz + s * (2.0 * res.z * vec2(h.x, h.y) - res.x);\n    float dd2 = dot(d2, d2);\n    float dd = sqrt(dd2);\n    return sign(d2.x) * (sqrt(dd) * sign(d2.y) * sqrt(1.0 - s) + dd * s) / abs(kx);\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - 3.0 * B + 3.0 * C - D;\n    vec2 e = a * 3.0", "\n    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n}\n\nfloat sd_line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sd_line_segment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sd_line_segment_2(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) * sign(winding_sign(p, a, b));\n}\n\nfloat sd_line_segment_3(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) * sign(winding_sign(p, a, b)) * sign(winding_sign(a, b, p));\n}\n\nfloat sd_line_segment_4(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b -", "\n    vec3 r = ro/rd;\n    vec3 q = abs(r)-s;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    vec3 n = vec3(0.0);\n    if( q.x>q.y && q.x>q.z ) n = vec3( sign(r.x), 0.0, 0.0 );\n    if( q.y>q.x && q.y>q.z ) n = vec3( 0.0, sign(r.y), 0.0 );\n    if( q.z>q.x && q.z>q.y ) n = vec3( 0.0, 0.0, sign(r.z) );\n    return vec4( d, n );\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n//  t     = wedge thickness\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec3 s, in float t )\n{\n    vec3 r = ro/rd;\n    vec3 q = abs(r)-s;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    vec3 n = vec3(0.0);\n    if( q.x>q.y && q.x>q.z ) n = vec3( sign(r.x), 0.0, 0.0 );\n    if( q.y>q.x && q.y>q.z ) n = vec3( 0.0, sign(r.y), 0.0 );\n    if( q.z>q.x && q.z>q.y ) n = vec3( 0.0, 0.0, sign(r", "\n    int a_i = a;\n    int b_i = int(b*float(1<<24));\n    int x_i = int(x*float(1<<24));\n    int ret_i = a_i*b_i+x_i;\n    ret_n = ret_i>>24;\n    return float(ret_i&0x007fffff)/float(1<<24);\n}\n\n// https://www.shadertoy.com/view/Xlf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f64 (out int ret_n, int a, double b, double x) {\n    int a_i = a;\n    int b_i = int(b*double(1<<24));\n    int x_i = int(x*double(1<<24));\n    int ret_i = a_i*b_i+x_i;\n    ret_n = ret_i>>24;\n    return double(ret_i&0x007fffff)/double(1<<24);\n}\n\n// https://www.shadertoy.com/view/Xlf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f16 (out int ret_n, int a, half b, half x) {\n    int a_i = a;\n    int b_i = int(b*half(1<<24));\n    int x_i = int(x*half(1<<24));\n    int ret_i = a_i*b_i+x_i;\n    ret_n = ret_i>>24;\n    return half(ret_i&0x00", "\n    vec3 m = vec3( min(a.x,b.x), min(a.y,b.y), min(a.z,b.z) );\n    float m2 = min(m.x,m.y);\n    m2 = min(m2, m.z);\n    vec3 r = vec3(m2, m2, m2);\n    return vec3(\n        m2 - k*r.x,\n        m.x - k*r.y,\n        m.y - k*r.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    vec3 m = vec3( max(a.x,b.x), max(a.y,b.y), max(a.z,b.z) );\n    float m2 = max(m.x,m.y);\n    m2 = max(m2, m.z);\n    vec3 r = vec3(m2, m2, m2);\n    return vec3(\n        m2 - k*r.x,\n        m.x - k*r.y,\n        m.y - k*r.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSClamp( in vec3 a, in vec3 b, in vec3 c, in float k )\n{\n    return sdgSMin( sdgSMax(a,b,k), c, k );\n}\n\n//.x = f(p)\n//.y = \ufffd", "\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float r = (x*x)/(a*a) + (y*y)/(b*b);\n    return r;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c){\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float r = (x*x)/(a*a) + (y*y)/(b*b);\n    float d = (x-c.x)*(x-c.x) + (y-c.y)*(y-c.y);\n    return r-d;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c, in vec2 d){\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float r = (x*x)/(a*a) + (y*y)/(b*b);\n    float d1 = (x-c.x)*(x-c.x) + (y-c.y)*(y-c.y);\n    float d2 = (x-d.x)*(x-d.x) + (y-d.y)*(y-d.y);\n    return r-d1-d2;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c, in vec2 d, in vec2 e){\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float r = (x", "\n    return a + b;\n}\n\nfloat sub_ploss(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss(in float a, in float b){\n    return a / b;\n}\n\nfloat add_ploss_2(in float a, in float b){\n    return a + b;\n}\n\nfloat sub_ploss_2(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss_2(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss_2(in float a, in float b){\n    return a / b;\n}\n\nfloat add_ploss_3(in float a, in float b){\n    return a + b;\n}\n\nfloat sub_ploss_3(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss_3(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss_3(in float a, in float b){\n    return a / b;\n}\n\nfloat add_ploss_4(in float a, in float b){\n    return a + b;\n}\n\nfloat sub_ploss_4(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss_4(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss_4(in float a, in float b){\n    return a / b;\n}\n\nfloat add_ploss_5(in float a, in float b){\n    return a + b;\n}\n\nfloat sub_ploss_5(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss_5(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss_5(in float a, in float b){", "\n    vec2 q = p - ab;\n    float a = dot(q,q);\n    float b = dot(q,ab);\n    float c = dot(ab,ab);\n    float d = s1*s1*c - b*b;\n    float e = s2*s2*c - b*b;\n    float f = s1*s1*e - d*c;\n    float g = d*e - f*b;\n    float h = s1*s1*a - d*b;\n    float i = s2*s2*a - e*b;\n    float j = d*e - f*a;\n    float k = d*c - b*b;\n    float l = e*c - b*b;\n    float m = f*c;\n    float n = h*l - j*j;\n    float o = h*m - n*b;\n    float p = j*m - n*a;\n    float q = k*l - m*m;\n    float r = k*n - o*b;\n    float s = l*n - p*b;\n    float t = k*o - r*a;\n    float u = l*p - s*b;\n    float v = m*n - t*b;\n    float w = m*o - u*a;\n    float x = m*p - v*b;\n    float y = n*o - w*b;\n    float z = n*p - x*b;\n    float w2 = w*w;\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n    float det = w2*z2 - x2*y2;\n    float u1 = (z2*u - x2*v)/det;\n    float u2 = (w2*v - y2*u)/det;\n    float u3 = (x2*y - z2*w)/det;\n    float v1 = (z2*t - x2*s)/det;\n    float v2 = (w2*s - y2*t)/det;\n", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x2 = baba - paba * paba / baba;\n    float y = clamp(paba / baba, -ra, rb);\n    float x = sqrt(max(x2 - y * y, 0.0));\n    vec3 c = pa * baba - ba * paba;\n    float zc = dot(c, c);\n    float d = x * (y + sqrt(max(zc - x2 * y * y, 0.0)));\n    vec3 pt = p - ba * (paba - y) / baba;\n    float h = sqrt(max(ra * ra - y * y, 0.0));\n    return vec4(sqrt(min(d * d / zc, h * h * x2 / zc)), pt);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h)\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x2 = baba - paba * paba / baba;\n    float y = clamp(paba / baba, -ra, rb);\n    float x = sqrt(max(x2 - y * y, 0.0));\n    vec3 c = pa * baba - ba * paba;\n    float zc = dot(c, c);\n    float d = x * (y + sqrt(max(zc - x2 * y * y, 0.0)));\n    vec3 pt = p - ba * (paba - y) / baba;\n    float h2 = h * h;\n    return vec4(sqrt(min(d * d / zc,", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, out float h )\n{\n    vec3 pa = p - a, ba = b - a;\n    h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, out float h, out float d )\n{\n    vec3 pa = p - a, ba = b - a;\n    h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    d = length( pa - ba*h ) - r;\n    return d;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, out float h, out float d, out float t )\n{\n    vec3 pa = p - a, ba = b - a;\n    h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    d = length( pa - ba*h ) - r;\n    t = dot(pa,ba)/dot(ba,ba);\n    return d;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, out float h, out float d, out float t, out float h2 )\n{\n    vec3 pa = p - a, ba = b - a;\n    h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    d = length( pa - ba*h ) - r;\n    t = dot(pa,ba)/dot(ba,ba);\n", "\n    return length(p-cen) - rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz-c.xz),p.y-c.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec3 c, float h, float r1, float r2 )\n{\n  // adaptivelicious.com/2016/01/25/ray-marching-signed-distance-functions/\n  float q = length(p.xz);\n  vec2 v = vec2(q,-p.y);\n  vec2 w = vec2(r1,h) - v;\n  vec2 u = max(vec2(r2-q,-p.y),vec2(0.0));\n  return min(min(dot(v,v),dot(w,w)),dot(u,u)) +\n         max(q-r2,max(h,p.y)) * sign(max(q*q + h*h,p.y-h));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdHexPrism( vec3 p", "\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, showSurface, samplePoint ).x );\n}\n\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, showSurface ).x );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint, vec3 samplePoint2 )\n{\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, showSurface, sample", "\n    float res = 1.0;\n    float t = 0.001;\n    float h = 1.0;\n    float k = 0.1;\n    for( int i=0; i<16; i++ )\n    {\n        if( h<0.001 || t>10.0 ) break;\n        h = map( ro + rd*t );\n        if( showSurface )\n        {\n            if( h<0.001 )\n            {\n                res = min( res, k*h/t );\n            }\n        }\n        else\n        {\n            res = min( res, k*h/t );\n        }\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float k )\n{\n    float res = 1.0;\n    float t = 0.001;\n    float h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        if( h<0.001 || t>10.0 ) break;\n        h = map( ro + rd*t );\n        if( showSurface )\n        {\n            if( h<0.001 )\n            {\n                res = min( res, k*h/t );\n            }\n        }\n        else\n        {\n            res = min( res, k*h/t );\n        }\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float k, float mip )\n{\n    float res = 1.0;\n    float t = 0.001;\n    float h = 1.0;", "\n    float h = ra - rb;\n    float t = clamp( (p.x-ra)/h, 0.0, 1.0 );\n    float r = mix( ra, rb, t );\n    float d = length( p ) - r;\n    float a = atan( p.y, p.x );\n    float b = atan( p.y, h );\n    float c = (b-a)/(2.0*3.1415926535897932384626433832795);\n    ocl = vec2( c, 1.0 );\n    return vec3( d, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl, out vec2 ocl2 )\n{\n    float h = ra - rb;\n    float t = clamp( (p.x-ra)/h, 0.0, 1.0 );\n    float r = mix( ra, rb, t );\n    float d = length( p ) - r;\n    float a = atan( p.y, p.x );\n    float b = atan( p.y, h );\n    float c = (b-a)/(2.0*3.1415926535897932384626433832795);\n    ocl = vec2( c, 1.0 );\n    ocl2 = vec2( c, 1.0 );\n    return vec3( d, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc )\n{\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd )\n{\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re )\n{\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re, float rf )\n{\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re, float rf, float rg )\n{\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re, float rf, float rg, float rh )\n{\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q);\n}\n\nvec4", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * sign( dot(ba,vec2(-ba.y,ba.x)) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) - r.x + length(max(q,0.0));\n}\n\nfloat sdBoxFrame( in vec2 p, in vec2 b, in float e )\n{\n    vec2 d = abs(p)-b+e;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - e;\n}", " return dot(v,v); }\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedBox(vec3 p, vec3 b, vec4 r)\n{\n    r.xyzw = (p.xyzw+r.xyzw)*b.xyzw;\n    vec4 q = max(r.xyzw,r.yzwx)*max(r.yzwx,0.0);\n    return sqrt(dot(q,q))*2.0/dot(b,b);\n}\n\n// Rounded box with rounded caps https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedBox(vec3 p, vec3 b, vec4 r, float rc)\n{\n    r.xyzw = (p.xyzw+r.xyzw)*b.xyzw;\n    vec4 q = max(r.xyzw,r.yzwx)*max(r.yzwx,0.0);\n    return sqrt(dot(q,q))*2.0/dot(b,b) - rc;\n}\n\n// Rounded box with rounded caps and rounded corners https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedBox(vec3 p, vec3 b, vec4 r, float rc, float rr)\n{\n    r.xyzw = (p.xyzw+r.xyzw)*b.xyzw;\n    vec4 q = max(r.xyzw,r.yzwx)*max(r.yzwx,0.0);\n    return sqrt(dot(q,q))*2.0/dot(b,b) -", "\n    vec2 d = max(p - minCorner, minCorner - p);\n    return d.x * d.x + d.y * d.y;\n}\n\n// Squared distance to a circle\nfloat sqCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p - c) * length(p - c) - r * r;\n}\n\n// Squared distance to a line segment\nfloat sqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length(pa - ba * h) * length(pa - ba * h);\n}\n\n// Squared distance to a line segment\nfloat sqLine( in vec2 p, in vec2 a, in vec2 b, out float t )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    t = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length(pa - ba * t) * length(pa - ba * t);\n}\n\n// Squared distance to a line segment\nfloat sqLine( in vec2 p, in vec2 a, in vec2 b, out float t, out float d )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    t = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    d = length(pa - ba * t);\n    return d * d;\n}\n\n// Squared distance to a line segment\nfloat sqLine( in vec2 p, in vec2 a, in vec2 b, out float t, out float d, out float h )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n", "\n\tvec2 uv2 = uv;\n\tuv2.x *= iResolution.x/iResolution.y;\n\tuv2.x *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n\tuv2.y *= 1.0;\n", "\n    vec3 ray = vec3(uv, 1.0);\n    ray = (2.0 * ray - 1.0) * vec3(u_viewport.zw, 0.0);\n    ray.z = -1.0;\n    return normalize(ray);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z)\n{\n    vec3 ray = vec3(uv, z);\n    ray = (2.0 * ray - 1.0) * vec3(u_viewport.zw, 0.0);\n    return normalize(ray);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov)\n{\n    vec3 ray = vec3(uv, z);\n    ray = (2.0 * ray - 1.0) * vec3(u_viewport.zw, 0.0);\n    ray.z = -1.0;\n    return normalize(ray);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov, float aspect)\n{\n    vec3 ray = vec3(uv, z);\n    ray = (2.0 * ray - 1.0) * vec3(u_viewport.zw, 0.0);\n    ray.z = -1.0;\n    return normalize(ray);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov, float aspect, vec3 pos)\n{\n    vec3 ray = vec3(uv, z);\n    ray = (2.0 * ray - 1.0) * vec3(u_viewport.zw, 0.0);\n    ray.z = -1.0;\n    return normalize(ray);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2", "\n    return v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(quatmul(q1, q2.xyz), q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\n// Quaternion conjugate\nvec4 quatconj(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n// Quaternion inverse\nvec4 quatinv(vec4 q)\n{\n    return quatconj(q) / dot(q, q);\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle)\n{\n    return vec4(normalize(axis) * sin(angle / 2.0), cos(angle / 2.0));\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle, vec3 v)\n{\n    return quatmul(quatrot(axis, angle), v);\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle, vec4 v)\n{\n    return quatmul(quatrot(axis, angle), v.xyz) + v.w * quatrot(axis, angle).xyzw;\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle, vec4 v, vec4 q)\n{\n    return quatmul(quatrot(axis, angle, v), quatinv(q));\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle, vec4 v, vec4 q, vec4 r)\n{\n    return quatmul(quatrot(axis, angle, v, q), r);\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle, vec4 v, vec4", "\n    return length(p-c)-r;\n}\n\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0;\n    vec2 e1 = p2-p1;\n    vec2 e2 = p0-p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot(pq0,pq0", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w*0.5;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w, float s )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w*0.5 + s;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w, float s, float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w*0.5 + s + t;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r, float w, float s, float t, float", "\n    return (m.x<d)? vec2(d,a) : m;\n}\n\nvec2 opSubtract( vec2 m, float d, float a )\n{\n    return (m.x>-d)? vec2(-d,a) : m;\n}\n\nvec2 opIntersect( vec2 m, float d, float a )\n{\n    return (m.x>d)? vec2(d,a) : m;\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n    float h = clamp( 0.5 + 0.5*(d-m.x)/m.y, 0.0, 1.0 );\n    return vec2( mix(d,m.x,h) - m.y*h*(1.0-h), a );\n}\n\nvec2 opSmoothSubtract( vec2 m, float d, float a )\n{\n    float h = clamp( 0.5 - 0.5*(d+m.x)/m.y, 0.0, 1.0 );\n    return vec2( mix(d,m.x,h) + m.y*h*(1.0-h), a );\n}\n\nvec2 opSmoothIntersect( vec2 m, float d, float a )\n{\n    float h = clamp( 0.5 - 0.5*(d-m.x)/m.y, 0.0, 1.0 );\n    return vec2( mix(d,m.x,h) + m.y*h*(1.0-h), a );\n}\n\nvec2 opSmoothUnion( vec2 m, vec2 d, float a )\n{\n    float h = clamp( 0.5 + 0.5*(d.x-m.x)/m.y, 0.0, 1.0 );\n    return vec2( mix(d.x,m.x,h) - m.y*h*(1.0-h), a );\n}\n\nvec2 opSmoothSubtract(", "\n    float a = dot(rd,rd);\n    float b = 2.0*dot(rd,ro);\n    float c = dot(ro,ro) - rad*rad;\n    float d = b*b - 4.0*a*c;\n    if( d<0.0 )\n    {\n        p1 = vec4(0.0,0.0,0.0,0.0);\n        p2 = vec4(0.0,0.0,0.0,0.0);\n    }\n    else\n    {\n        float t1 = (-b - sqrt(d)) / (2.0*a);\n        float t2 = (-b + sqrt(d)) / (2.0*a);\n        p1 = vec4(ro + t1*rd, t1, 0.0);\n        p2 = vec4(ro + t2*rd, t2, 0.0);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectSphere( in vec3 ro, in vec3 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n    float a = dot(rd,rd);\n    float b = 2.0*dot(rd,ro);\n    float c = dot(ro,ro) - rad*rad;\n    float d = b*b - 4.0*a*c;\n    if( d<0.0 )\n    {\n        p1 = vec4(0.0,0.0,0.0,0.0);\n        p2 = vec4(0.0,0.0,0.0,0.0);\n    }\n    else\n    {\n        float t1 = (-b - sqrt(d)) / (2.0*a);\n        float t2 = (-b + sqrt(d)) / (2.0*a);\n        p1 = vec4(ro + t1*rd, t1);\n        p2 = vec4(ro + t2*rd, t2);\n    }\n}\n\n// https://iquile", "\n    vec2 d = p - c;\n    float l = length(d);\n    float f = l - r;\n    return vec3( f, d/l );\n}\n\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    return sdgCircle( p, vec2(0.0), r );\n}\n\nvec3 sdgCircle( in vec2 p ) \n{\n    return sdgCircle( p, 1.0 );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    float f = length(max(d,0.0));\n    vec2 n = d.x < d.y? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    return vec3( f, n );\n}\n\nvec3 sdgBox( in vec2 p, in float b )\n{\n    return sdgBox( p, vec2(b) );\n}\n\nvec3 sdgBox( in vec2 p )\n{\n    return sdgBox( p, 1.0 );\n}\n\nvec3 sdgRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    float f = length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n    vec2 n = q.x < q.y? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    return vec3( f, n );\n}\n\nvec3 sdgRoundedBox( in vec2 p, in vec2 b )\n{\n    return sdgRoundedBox( p, b, 0.2 );\n}\n\nvec3 sdgRoundedBox( in vec2 p, in float b )\n{\n   ", "\n    vec2 d = abs(p)-b;\n    float m = max(d.x,d.y);\n    float n = (m<0.0)?0.0:((m>0.0)?1.0:0.5)-0.5;\n    return vec3( m, n*sign(d.y-d.x), n*sign(d.x-d.y) );\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    float m = max(d.x,max(d.y,d.z));\n    float n = (m<0.0)?0.0:((m>0.0)?1.0:0.5)-0.5;\n    return vec3( m, n*sign(d.z-d.x), n*sign(d.y-d.x) );\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c )\n{\n    vec3 q = abs(p-c)-b;\n    vec3 m = max(q.x,max(q.y,q.z));\n    float n = (m<0.0)?0.0:((m>0.0)?1.0:0.5)-0.5;\n    return vec3( m, n*sign(q.z-q.x), n*sign(q.y-q.x) );\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c, in vec3 u, in vec3 v )\n{\n    vec3 q = abs(p-c)-b;\n    vec3 m = max(q.x,max(q.y,q.z));\n    float n = (m<0.0)?0.0:((m>0.0)?1.0:0.5)-0.5;\n    return vec3( m, n*sign(q.z-q.x), n*sign(q.y-q.x)", "\n    vec3 q = vec3(p,0.0);\n    q.yz = p;\n    q.yz = p*p;\n    q.yz = p*p*p;\n    q.yz = p*p*p*p;\n    q.yz = p*p*p*p*p;\n    q.yz = p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p;\n    q.yz = p*p*p*p*p*p*p*p*p*p*", "\n    float t = (x - a1) / (b1 - a1);\n    return mix(b2, a2, t);\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/qjqjqjqjqj\nfloat h(float a1, float b1, float a2, float b2, float x) {\n    float t = (x - a1) / (b1 - a1);\n    return mix(a2, b2, t);\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/qjqjqjqjqj\nfloat i(float a1, float b1, float a2, float b2, float x) {\n    float t = (x - a1) / (b1 - a1);\n    return mix(b2, a2, t);\n}\n\n// Instant push -> wobble (yellow)\n// https://www.desmos.com/calculator/qjqjqjqjqj\nfloat j(float a1, float b1, float a2, float b2, float x) {\n    float t = (x - a1) / (b1 - a1);\n    return mix(a2, b2, t);\n}\n\n// Instant push -> wobble (cyan)\n// https://www.desmos.com/calculator/qjqjqjqjqj\nfloat k(float a1, float b1, float a2, float b2, float x) {\n    float t = (x - a1) / (b1 - a1);\n    return mix(b2, a2, t);\n}\n\n// Instant push -> wobble (magenta)\n// https://www.desmos.com/calculator/qjqjqjqjqj\nfloat l(float a1, float b1, float a2, float b2, float x) {\n    float t = (x - a1) / (b1 - a1);\n    return mix(a2, b2,", "\n    return pow(abs(x), n) / pow(a, n) + b;\n}\n\n// Fast push -> wobble (red)\n// https://www.desmos.com/calculator/qzqjqjqjqj\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat i(float a, float b, float n, float x) {\n    return pow(abs(x), n) / pow(a, n) - b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat j(float a, float b, float n, float x) {\n    return pow(abs(x), n) / pow(a, n) + b;\n}\n\n// Fast push -> wobble (red)\n// https://www.desmos.com/calculator/qzqjqjqjqj\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat k(float a, float b, float n, float x) {\n    return pow(abs(x), n) / pow(a, n) - b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat l(float a, float b, float n, float x) {\n    return pow(abs(x), n) / pow(a, n) + b;\n", "\n                vec2 p = floor(uv);\n                vec2 f = fract(uv);\n                float v = 0.0;\n                for(int y=-1; y<=1; y++){\n                    for(int x=-1; x<=1; x++){\n                        vec2 b = vec2(x,y);\n                        vec2 r = vec2(b) + hash22(p + b);\n                        float d = length(f-r);\n                        v += (1.0-d) * (1.0-d);\n                    }\n                }\n                return v;\n            }\n\n            float paperNoise(vec2 uv, float time){\n                vec2 p = floor(uv);\n                vec2 f = fract(uv);\n                float v = 0.0;\n                for(int y=-1; y<=1; y++){\n                    for(int x=-1; x<=1; x++){\n                        vec2 b = vec2(x,y);\n                        vec2 r = vec2(b) + hash22(p + b + time);\n                        float d = length(f-r);\n                        v += (1.0-d) * (1.0-d);\n                    }\n                }\n                return v;\n            }\n\n            float paperNoise(vec2 uv, float time, float scale){\n                vec2 p = floor(uv * scale);\n                vec2 f = fract(uv * scale);\n                float v = 0.0;\n                for(int y=-1; y<=1; y++){\n                    for(int x=-1; x<=1; x++){\n                        vec2 b = vec2(x,y);\n                        vec2 r = vec2(b) + hash22(p + b + time);\n                        float d = length(f-r);\n                        v += (1.0-d) * (1.0-d);\n                    }\n                }\n                return v;\n            }\n\n            float paperNoise(vec2 uv, float time, float scale, float speed){\n                ve", "\n    vec3 color = vec3( 0.0 );\n    for( int i = 0; i < 100; i++ )\n    {\n        float a = float( i ) / 100.0;\n        float b = float( i ) / 100.0;\n        float c = float( i ) / 100.0;\n        float d = float( i ) / 100.0;\n        float e = float( i ) / 100.0;\n        float f = float( i ) / 100.0;\n        color += vec3( a, b, c ) * vec3( d, e, f );\n    }\n    return color;\n}\n\nvoid main()\n{\n    vec3 color = compute( 0, 0 );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    return length(p-c)-r;\n}\n\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0;\n    vec2 e1 = p2-p1;\n    vec2 e2 = p0-p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot(pq0,pq0", "\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 c, in vec2 b, in float r )\n{\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 c, in vec2 b, in vec2 r )\n{\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - r.x;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 c, in vec2 b, in vec2 r, in float r2 )\n{\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - r.x - r2;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 c, in vec2 b, in vec2 r, in float r2, in float r3 )\n{\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - r.x - r2 - r3;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 c, in vec2 b, in vec2 r, in float r2, in float r3, in float r4 )\n{\n    p = abs(p-c)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - r.x - r2 - r3 - r4;\n}\n\nfloat s", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h), h );\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h) - r, h );\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float w )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h) - r, h );\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h )\n{\n    vec2 pa = p-a, ba = b-a;\n    float t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*t) - r, t );\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h, in float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float u = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*u) - r, u );\n}\n\nvec2 sdSqLine(", "\n    vec2 pa = p-a, ba = b-a;\n    float h2 = h*h;\n    float px = dot(pa,ba)/dot(ba,ba);\n    px = clamp(px, 0.0, 1.0);\n    vec2  q = pa - px*ba;\n    float d2 = dot(q,q);\n    float s = (px<0.0 || px>1.0)? length(q) : dot(q,ba/h);\n    float d = sqrt(d2)-s;\n    return vec2(d,d2<d2min? 1.0 : 0.0);\n}\n\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h )\n{\n    return sdSqArc(p,a,b,h,0.0);\n}\n\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b )\n{\n    return sdSqArc(p,a,b,0.0);\n}\n\nvec2 sdSqArc( in vec2 p, in vec2 a, in float h )\n{\n    return sdSqArc(p,a,a+vec2(1.0,0.0),h);\n}\n\nvec2 sdSqArc( in vec2 p, in vec2 a )\n{\n    return sdSqArc(p,a,a+vec2(1.0,0.0),0.0);\n}\n\nvec2 sdSqArc( in vec2 p, in float h )\n{\n    return sdSqArc(p,vec2(0.0),vec2(1.0,0.0),h);\n}\n\nvec2 sdSqArc( in vec2 p )\n{\n    return sdSqArc(p,vec2(0.0),vec2(1.0,0.0),0.0);\n}\n\n// https://iquilezles.org/articles/dist", "\n    float d = sdLine(p, kType[0], kPath[0], kPath[1], kPath[2], kPath[3]);\n    for (int i = 1; i < 7; i++)\n    {\n        if (kType[i] == 0)\n        {\n            d = opSmoothUnion(d, sdLine(p, kType[i], kPath[4*i], kPath[4*i+1], kPath[4*i+2], kPath[4*i+3]), 0.01);\n        }\n        else if (kType[i] == 1)\n        {\n            d = opSmoothUnion(d, sdArc(p, kType[i], kPath[4*i], kPath[4*i+1], kPath[4*i+2], kPath[4*i+3]), 0.01);\n        }\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius[7] )\n{\n    float d = sdLine(p, kType[0], kPath[0], kPath[1], kPath[2], kPath[3]);\n    for (int i = 1; i < 7; i++)\n    {\n        if (kType[i] == 0)\n        {\n            d = opSmoothUnion(d, sdLine(p, kType[i], kPath[4*i], kPath[4*i+1], kPath[4*i+2], kPath[4*i+3]), 0.01);\n        }\n        else if (kType[i] == 1)\n        {\n            d = opSmoothUnion(d, sdArc(p, kType[i], kPath[4*i], kPath[4*i+1], kPath[4*i+2], kPath[4*i+3]), 0.01);\n        }\n        else if (kType[i] == ", "\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdB( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdC( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdD( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdE( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdF( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdG( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdH( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdI( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdJ( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdK( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdL( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdM( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdN( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat sdO( in vec", "\n    float d = 1000.0;\n    d = min( d, sdBox( p, vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 1.0 ), vec3( 1.0 ) ) );\n    return d;\n}\n\nfloat sdC( in vec2 p )\n{\n    float d = 1000.0;\n    d = min( d, sdBox( p, vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 1.0 ), vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 2.0 ), vec3( 1.0 ) ) );\n    return d;\n}\n\nfloat sdD( in vec2 p )\n{\n    float d = 1000.0;\n    d = min( d, sdBox( p, vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 1.0 ), vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 2.0 ), vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 3.0 ), vec3( 1.0 ) ) );\n    return d;\n}\n\nfloat sdE( in vec2 p )\n{\n    float d = 1000.0;\n    d = min( d, sdBox( p, vec3( 1.0 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, 0.0, 1.0 ), ve", "\n    vec3 color = vec3(0.0);\n\n    // Scale the coordinates and use the resulting coordinates for\n    // the sine and cosine functions.\n    uv *= 3.0;\n    float s = sin(uv.x);\n    float c = cos(uv.y);\n\n    // Add up a color value using a sine and cosine of the scaled\n    // coordinates and add a little bit of random noise.\n    color += vec3(sin(s+c+uv.x+uv.y)*.5+.5);\n\n    // Add up a color value using a sine and cosine of the scaled\n    // coordinates and add a little bit of random noise.\n    color += vec3(sin(c*s+uv.x+uv.y)*.5+.5);\n\n    // Add up a color value using a sine and cosine of the scaled\n    // coordinates and add a little bit of random noise.\n    color += vec3(sin(s*c+uv.x+uv.y)*.5+.5);\n\n    return color;\n}\n\nvoid main()\n{\n    // Get the UV coordinates from the vertex shader.\n    vec2 uv = v_texCoord;\n\n    // Generate a pattern based on the UV coordinates.\n    vec3 color = pattern(uv);\n\n    // Output the resulting color.\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2  ba = b - a;\n    float h  = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2  ba = b - a;\n    float h  = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Distance to segment\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2  ba = b - a;\n    float h  = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( p - (a + ba*h) ) - th;\n}\n\n// Distance to line\nfloat distLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2  ba = b - a;\n    float h  = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( p - (a + ba*h) );\n}\n\n// Distance to line segment\nfloat distLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2  ba = b - a;\n    float h  = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( p - (a + ba*h) ) - th;\n}\n\n// Distance to line segment\nfloat distLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2  ba = b - a;\n    float h  = clamp( dot(p-a,ba)/dot(ba,ba), 0.0", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to line segment\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// distance to circle segment\nfloat sdCircleSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance to circle arc\nfloat sdCircleArc( in vec2 p, in vec2 c, in float r, in float a1, in float a2 )\n{\n    float da = a2-a1;\n    float s = sin(da), c = cos(da);\n    vec2 r0 = vec2(c,-s), r1 = vec2(s,c);\n    vec2 v", "\n    vec2 q = clamp(p, -b, b) - p;\n    return vec2( q.x, clamp(q.y, -r, r) );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float r2 )\n{\n    vec2 q = clamp(p, -b, b) - p;\n    return vec2( clamp(q.x, -r, r), clamp(q.y, -r2, r2) );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float r2, float r3 )\n{\n    vec2 q = clamp(p, -b, b) - p;\n    return vec2( clamp(q.x, -r, r), clamp(q.y, -r2, r2) );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float r2, float r3, float r4 )\n{\n    vec2 q = clamp(p, -b, b) - p;\n    return vec2( clamp(q.x, -r, r), clamp(q.y, -r2, r2) );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float r2, float r3, float r4, float r5 )\n{\n    vec2 q = clamp(p, -b, b) - p;\n    return vec2( clamp(q.x, -r, r), clamp(q.y, -r2, r2) );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float r2, float r3, float r4, float r5, float r6 )\n{\n    vec2 q = clamp(p, -b, b)", "\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float r2 )\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r2;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float r2, float r3 )\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r3;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float r2, float r3, float r4 )\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r4;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float r2, float r3, float r4, float r5 )\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to sphere\nfloat sdSphere( in vec3 p, in float s )\n{\n  return length(p)-s;\n}\n\n// distance to cylinder\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to torus\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// distance to plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// distance to infinite plane\nfloat sdHalfSpace( in vec4 n, in vec3 p )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// distance to infinite plane\nfloat sdPlane( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n  vec3  ba = b - a; vec3  pa = p - a;\n  vec3  cb = c - b; vec3  pb = p - b;\n  vec3  ac = a - c; vec3  pc = p - c;\n  vec3  nor = cross( ba, ac );\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),", "\n    p = 50.0*fract(p*0.3183099+.1);\n    return -1.0+2.0*fract(p.x*p.y*(p.x+p.y));\n}\n\n// 2D Noise\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat noise2(in vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*57.0;\n    float res = mix(mix( hash12(i + vec2(0.0,0.0) ), \n                         hash12(i + vec2(1.0,0.0) ),f.x),\n                    mix( hash12(i + vec2(0.0,1.0) ), \n                         hash12(i + vec2(1.0,1.0) ), f.x), f.y);\n    return res;\n}\n\n// 2D Fractal Brownian Motion\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p){\n    float f = 0.0;\n    f += 0.5000*noise2( p ); p = p*2.01;\n    f += 0.2500*noise2( p ); p = p*2.02;\n    f += 0.1250*noise2( p ); p = p*2.03;\n    f += 0.0625*noise2( p );\n    return f/0.9375;\n}\n\n// 2D Fractal Brownian Motion\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 151.7182, 123.456))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y)\n{\n    return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z)\n{\n    return fract(sin(dot(vec3(x, y, z), vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float w)\n{\n    return fract(sin(dot(vec4(x, y, z, w), vec4(12.9898, 78.233, 151.7182, 123.456))) * ", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Fractal Brownian Motion\n// HSV values from iq/2013\n// https://www.shadertoy.com/view/4dS3Wd\nvec3 fbm( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return vec3(f,f,f);", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// A 3D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y),", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D simplex noise\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    float k = 100.0;\n    float va = 0.0;\n    float wt = 0.0;\n    for (int j = -1; j <= 1; j++)\n    {\n        for (int i = -1; i <= 1; i++)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash22(p + g);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            float ww = pow(1.0 - smoothstep(0.0, 1.414, sqrt(d)), 4.0);\n            va += ww * noise(x * 0.01 + o * 10.0);\n            wt += ww;\n        }\n    }\n    return va / wt;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime * 0.1;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        float f = float(i);\n        vec2 p = uv * (1.0 + f * 0.5);\n        p += vec2(1.0, 3.0) * t;\n        float n = pattern(p);\n        col += vec3(n, n * 0.5, n * 0.25) * (0.5 / float(i + 1));\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return 1.0 / (4.0 * x * y);\n}\n\nfloat texelSolidAngle(float x, float y, float z)\n{\n    return areaElement(x, y) * z;\n}\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.glsl\n//\n\n//\n// The following functions are adapted from\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/pbr-frag.gl", "\n\tp3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash33(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash33(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash33(vec3 p3, float salt) {\n    p3 = fract(p3 * vec3(.1031,.1030,.0973) + salt);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash33(vec2 p, float salt) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973) + salt);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash33(float p, float salt) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030", "\n    //  Find current pixel's simplex cell.\n    vec3 i = floor(p + dot(p, vec3(F3)) );\n\n    //  Find the 3D coordinates of the 4 simplex corners\n    vec3 x0 = p - i + dot(i, vec3(G3));\n\n    //  For each of the 3 axes, check which simplex corner has the\n    //  smallest projection on that axis, and get the 3 coordinates\n    //  of that corner in the 3D simplex.\n    vec3 g;\n    g.x  = step(x0.y, x0.x);\n    g.y  = step(x0.z, g.x? x0.y : x0.x);\n    g.z  = 1.0 - g.x - g.y;\n    vec3 i1 = vec3(g.x, g.y, 1.0 - g.z);\n    vec3 i2 = vec3(1.0 - g.x, g.y, 1.0 - g.z);\n    vec3 i3 = vec3(1.0 - g.x, 1.0 - g.y, 1.0 - g.z);\n\n    //  Calculate the contribution from the 4 corners\n    vec4 x1 = x0.x + x0.y + x0.z;\n    vec4 x2 = x0.y + x0.z + i1.z;\n    vec4 x3 = x0.z + i1.z + i2.z;\n    vec4 x4 = i1.z + i2.z + i3.z;\n\n    //  We now determine the contribution from the corners\n    vec4 w;\n    w.x = x1.x + x1.y + x1.z;\n    w.y = x2.x + x2.y + x2.z;\n    w.z = x3.x + x3.y + x3.z;\n    w.w = x4.x + x4.y + x4.z;\n\n", "\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm2( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.125", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w - r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float r, in float r2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w - r - r2;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float r, in float r2, in float r3 )\n{\n    vec2 pa = p-a, ba = b-a;\n", "\n    vec2 d = abs(p)-b+r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.y;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p)-b+r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r.y;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    vec4 d = abs(p)-b+r;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0)) - r.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p)-b;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,", "\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/2)\n    // proj_info.y = sin(fov/2)\n    // proj_info.z = tan(fov/2)\n    // proj_info.w = tan(fov/2) / aspect\n\n    // proj_info.x = cos(fov/", "\n    p = 50.0*fract(p*0.3183099+.1);\n    return -1.0+2.0*fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = Hash12(i);\n    float b = Hash12(i + vec2(1.0, 0.0));\n    float c = Hash12(i + vec2(0.0, 1.0));\n    float d = Hash12(i + vec2(1.0, 1.0));\n\n    vec2 cubic = f*f*(3.0-2.0*f);\n\n    return mix(a, b, cubic.x) + (c - a)*cubic.y*(1.0 - cubic.x) + (d - b)*cubic.x*cubic.y;\n}\n\nfloat Fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*Noise(p); p = p*2.01;\n    f += 0.2500*Noise(p); p = p*2.02;\n    f += 0.1250*Noise(p); p = p*2.03;\n    f += 0.0625*Noise(p);\n    return f/0.9375;\n}\n\nfloat Fbm2(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*Noise(p); p = p*2.01;\n    f += 0.2500*Noise(p); p = p*2.02;\n    f += 0.1250*Noise(p); p = p*2.03;\n    f += 0.0625*Noise(p);\n    return f/0.9375;\n}\n\nfloat Fbm", "\n    float a = atan(p.y, p.x);\n    float d = length(p) - r;\n    float n = floor(a / acs.x) + 1.0;\n    float an2 = an * m;\n    float bn2 = bn * m;\n    float an2_2 = an2 * 0.5;\n    float bn2_2 = bn2 * 0.5;\n    float an2_2_2 = an2_2 * 0.5;\n    float bn2_2_2 = bn2_2 * 0.5;\n    float an2_2_2_2 = an2_2_2 * 0.5;\n    float bn2_2_2_2 = bn2_2_2 * 0.5;\n    float an2_2_2_2_2 = an2_2_2_2 * 0.5;\n    float bn2_2_2_2_2 = bn2_2_2_2 * 0.5;\n    float an2_2_2_2_2_2 = an2_2_2_2_2 * 0.5;\n    float bn2_2_2_2_2_2 = bn2_2_2_2_2 * 0.5;\n    float an2_2_2_2_2_2_2 = an2_2_2_2_2_2 * 0.5;\n    float bn2_2_2_2_2_2_2 = bn2_2_2_2_2_2 * 0.5;\n    float an2_2_2_2_2_2_2_2 = an2_2_2_2_2_2_2 * 0.5;\n    float bn2_2_2_2_2_2_2_2 = bn2_2_2_2_2_2_2 * 0.5;\n    float an2_2_2_2_2_2_2_2_2 = an2_2_2_2_2_2_2_", "\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n\t\t\t\t\t  k.yyx*map( p + k.yyx*h ) + \n\t\t\t\t\t  k.yxy*map( p + k.yxy*h ) + \n\t\t\t\t\t  k.xxx*map( p + k.xxx*h ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF triangle normals\nvec3 normal( vec3 p )\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n\t\t\t\t\t  k.yyx*map( p + k.yyx*h ) + \n\t\t\t\t\t  k.yxy*map( p + k.yxy*h ) + \n\t\t\t\t\t  k.xxx*map( p + k.xxx*h ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF triangle normals\nvec3 normal( vec3 p )\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n\t\t\t\t\t  k.yyx*map( p + k.yyx*h ) + \n\t\t\t\t\t  k.yxy*map( p + k.yxy*h ) + \n\t\t\t\t\t  k.xxx*map( p + k.xxx*h ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF triangle normals\nvec3 normal( vec3 p )\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n\t\t\t\t\t  k.yyx*map( p + k.yyx*h ) + \n\t\t\t\t\t  k.y", "\n    float res = 1.0;\n    float t = t0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (t > t1)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy) +\n                     e.yyx * map(pos + e.yyx) +\n                     e.yxy * map(pos + e.yxy) +\n                     e.xxx * map(pos + e.xxx));\n}\n\nvec3 calcColor(vec3 pos, vec3 nor)\n{\n    vec3 col = vec3(0.8, 0.9, 1.0) + 0.15 * sin(vec3(0.05, 0.08, 0.10) * pos.y + 1.5);\n    float occ = clamp(8.0 * map(pos + 0.02 * nor) / 0.02, 0.0, 1.0);\n    col *= occ;\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.8, 0.9, 1.0);\n    float t = 0.0;\n    for (int i = 0; i < 64; i++)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if (h < 0.001)\n        {\n            vec3 nor = calcNormal(pos);\n            vec3", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcSoftAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcSoftAO2( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n   ", "\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    vec3 ax = normalize(axis);\n    return mat3(\n        t * ax.x * ax.x + c, t * ax.x * ax.y - s * ax.z, t * ax.x * ax.z + s * ax.y,\n        t * ax.x * ax.y + s * ax.z, t * ax.y * ax.y + c, t * ax.y * ax.z - s * ax.x,\n        t * ax.x * ax.z - s * ax.y, t * ax.y * ax.z + s * ax.x, t * ax.z * ax.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat4 createRotationMatrixX(float angle) {\n    float c", "\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    return ray;\n}\n\n// Helper function that returns the distance to the nearest object\nfloat getDistance(vec3 p) {\n    float sphere = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    float plane = p.y;\n    return min(sphere, plane);\n}\n\n// Helper function that returns the normal of the nearest object\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = d - vec3(\n        getDistance(p - e.xyy),\n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx)\n    );\n    return normalize(n);\n}\n\n// Helper function that returns the color of the nearest object\nvec3 getColor(vec3 p) {\n    float d = getDistance(p);\n    if (d < 0.0) {\n        return vec3(1.0, 0.0, 0.0);\n    } else {\n        return vec3(0.0, 1.0, 0.0);\n    }\n}\n\n// Helper function that returns the color of the nearest object\nvec3 getColor(vec3 p, vec3 ray) {\n    float d = getDistance(p);\n    vec3 n = getNormal(p);\n    float diffuse = max(0.0, dot(n, ray));\n    return vec3(diffuse);\n}\n\n// Helper function that returns the color of the nearest object\nvec3 getColor(vec3 p, vec3 ray, vec3 light) {\n    float d = getDistance(p);\n    vec3 n = getNormal(p);\n    float diffuse = max(0.0, dot(n, light));\n   ", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2d(float x, float y){\n    return fract(sin(dot(vec2(x, y),vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2d(float x, float y, float z){\n    return fract(sin(dot(vec3(x, y, z),vec3(12.9898,78.233, 45.234))) * 43758.5453);\n}\n\nfloat rand2d(float x, float y, float z, float w){\n    return fract(sin(dot(vec4(x, y, z, w),vec4(12.9898,78.233, 45.234, 23.34))) * 43758.5453);\n}\n\nfloat rand2d(float x, float y, float z, float w, float u){\n    return fract(sin(dot(vec5(x, y, z, w, u),vec5(12.9898,78.233, 45.234, 23.34, 54.23))) * 43758.5453);\n}\n\nfloat rand2d(float x, float y, float z, float w, float u, float v){\n    return fract(sin(dot(vec6(x, y, z, w, u, v),vec6(12.9898,78.233, 45.234,", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 45.5432, 12.9898))) * 43758.5453);\n}\n\n// Hash for 5d vectors\nfloat rand5d(vec5 p){\n    return fract(sin(dot(p, vec5(12.9898, 78.233, 45.5432, 12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 6d vectors\nfloat rand6d(vec6 p){\n    return fract(sin(dot(p, vec6(12.9898, 78.233, 45.5432, 12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Hash for 7d vectors\nfloat rand7d(vec7 p){\n    return fract(sin(dot(p, vec7(12.9898, 78.233, 45.5432, 12.9898, 7", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash31(n+0.0), hash31(n+1.0),f.x),\n                   mix( hash31(n+57.0), hash31(n+58.0),f.x),f.y),\n               mix(mix( hash31(n+113.0), hash31(n+114.0),f.x),\n                   mix( hash31(n+170.0), hash31(n+171.0),f.x),f.y),f.z);\n}\n\n// 2D value noise\nfloat noise2d(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash21(n+0.0), hash21(n+1.0),f.x),\n               mix( hash21(n+57.0), hash21(n+58.0),f.x),f.y);\n}\n\n// 1D value noise\nfloat noise1d(float x){\n    float i = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = i + i*57.0;\n    return mix( hash11(n+0.0), hash11(n+1.0),f);\n}\n\n// 3D perlin noise\nfloat perlin3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n   ", "\n    float n = p.x + p.y*1e1 + p.z*1e2;\n    return fract(sin(n)*753.5453123);\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n    float n = p.x + p.y*1e1;\n    return fract(sin(n)*753.5453123);\n}\n\n// 1D simplex noise, cool trick\nfloat supernoise1d(float p){\n    return fract(sin(p)*753.5453123);\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n    float n = p.x + p.y*1e1 + p.z*1e2;\n    return fract(sin(n)*753.5453123);\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n    float n = p.x + p.y*1e1;\n    return fract(sin(n)*753.5453123);\n}\n\n// 1D simplex noise, cool trick\nfloat supernoise1d(float p){\n    return fract(sin(p)*753.5453123);\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n    float n = p.x + p.y*1e1 + p.z*1e2;\n    return fract(sin(n)*753.5453123);\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n    float n = p.x + p.y*1e1;\n    return fract(sin(n)*753.5453123);\n}\n\n// 1D simplex noise, cool trick\nfloat supernoise1d(float p){\n    return fract(sin(p)*753.", "\n    float f = 0.0;\n    f += 0.50000*noise(p); p = p*2.02;\n    f += 0.25000*noise(p); p = p*2.03;\n    f += 0.12500*noise(p); p = p*2.01;\n    f += 0.06250*noise(p); p = p*2.02;\n    f += 0.03125*noise(p);\n    return f/0.984375;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM2(vec3 p){\n    float f = 0.0;\n    f += 0.50000*noise(p); p = p*2.02;\n    f += 0.25000*noise(p); p = p*2.03;\n    f += 0.12500*noise(p); p = p*2.01;\n    f += 0.06250*noise(p); p = p*2.02;\n    f += 0.03125*noise(p);\n    return f/0.984375;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM3(vec3 p){\n    float f = 0.0;\n    f += 0.50000*noise(p); p = p*2.02;\n    f += 0.25000*noise(p); p = p*2.03;\n    f += 0.12500*noise(p); p = p*2.01;\n    f += 0.06250*noise(p); p = p*2.02;\n    f += 0.03125*noise(p);\n    return f/0.984375;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM4(vec3 p){\n    float f = 0.0;\n    f += 0.50000*noise(p); p", "\n    // get the distance to the clouds\n    float dist = distance(pos, cloudPos);\n    // get the density at this point\n    float density = exp(-dist*cloudDensity);\n    // get the color at this point\n    float color = exp(-dist*cloudColor);\n    // return the density and color\n    return vec2(density, color);\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity(vec2 pos){\n    // get the distance to the clouds\n    float dist = distance(pos, cloudPos.xy);\n    // get the density at this point\n    float density = exp(-dist*cloudDensity);\n    // get the color at this point\n    float color = exp(-dist*cloudColor);\n    // return the density and color\n    return vec2(density, color);\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity2D(vec2 pos){\n    // get the distance to the clouds\n    float dist = distance(pos, cloudPos.xy);\n    // get the density at this point\n    float density = exp(-dist*cloudDensity);\n    // get the color at this point\n    float color = exp(-dist*cloudColor);\n    // return the density and color\n    return vec2(density, color);\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity2D(vec2 pos, float time){\n    // get the distance to the clouds\n    float dist = distance(pos, cloudPos.xy);\n    // get the density at this point\n    float density = exp(-dist*cloudDensity);\n    // get the color at this point\n    float color = exp(-dist*cloudColor);\n    // return the density and color\n    return ve", "\n    float height = point.y;\n    float shadow = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float coverage = smoothstep(0.0, 0.01, height);\n    float sun = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow2 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow3 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow4 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow5 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow6 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow7 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow8 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow9 = clamp(dot(point, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float sunShadow10 = clamp(dot(point, ve", "\n    vec3 ray = normalize(pointEnd - pointStart);\n    float d = rayMarch(pointStart, ray, dist);\n    float fog = exp(-d * 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    color *= 0.6;\n    color = clamp(color, 0.0, 1.0);\n    color = (color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color = aces_tonemap(color);\n    fragColor = vec4(color, 1.0);\n}\n"]}