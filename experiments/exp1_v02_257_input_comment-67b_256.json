{"input_comment": ["\n    float x = cos(a*tau);\n    return (x+.5)/1.5)*2-1;\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) = 1, fsin(2/3) = -1\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 1.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 2.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 3.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 4.0), 1.0), 0.1);\n    d = opSmoothUnion(d, sdSphere(p + vec3(0.0, 0.0, 5.0), 1.0), 0.1);\n    d =", "\n    return length(max(abs(p) - vec3(0.5), 0.0));\n}\n\n// Distance to the scene\nfloat", "\n    vec3 q = p;\n    float d = map(q);\n    for (int i = 0; i < 10; i++) {\n        q = p + d * normalize(q);\n        d = map(q);\n    }\n    P = q;\n    return vec2(d, map(q));\n}\n\n// Distance to the scene and color of the closest point\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    return vec4(x, x, x, 1.0);\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 uv2 = uv;\n    uv2.x = uv.x * resolution.x / resolution.y;\n    uv2.y = uv.y;\n\n    vec4 color = texture2D(texture, uv2);\n    float brightness = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n    color = gradient(brightness);\n\n    gl_FragColor = color;\n}\n", "\n    float f = d / 10.0;\n    return vec4(f, f, f, 1.0);\n}\n\nvoid main()\n{\n    // get the distance to the nearest point\n    float d = distance(gl_FragCoord.xy, p);\n\n    // shade the point based on distance\n    gl_FragColor = shade(d);\n}\n", "\n    // Get the ray's direction in spherical coordinates.\n    float theta = acos(rayDir.y);\n    float phi = atan(rayDir.z, rayDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun = acos(sunDir.y);\n    float phiSun = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun2 = acos(sunDir.y);\n    float phiSun2 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun3 = acos(sunDir.y);\n    float phiSun3 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray's direction in spherical coordinates.\n    float thetaSun4 = acos(sunDir.y);\n    float phiSun4 = atan(sunDir.z, sunDir.x);\n\n    // Get the ray'", "\n    return F(coords.x) - coords.y;\n}\n\n// F'(x) = F(x+1) - F(x)\nfloat", "\n    return F(coords.x) - coords.y;\n}\n\n// F'(x) = F(x+1) - F(x)\nfloat", "\n    return F(coords.x) - coords.y;\n}\n\n// F'(x) = F(x+1) - F(x)\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n//Fun end here\n\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n    float f = 0.0;\n    float w = 0.5;\n    float ws = 0.0;\n    for (int i = 0; i < NUM_OCTAVES; i++) {\n        f += w * noise(p);\n        ws += w;\n        w *= 0.5;\n        p *= 2.0;\n    }\n    return f / ws;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float k = 1.0+63.0*pow(1.0-f.x,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 g = vec2(float(i),float(j));\n            vec3 o = hash3(n + g);\n            vec2 r = g - f + o.xy;\n            float d = dot(r,r);\n            float ww = pow(1.0-smoothstep(0.0,1.414,sqrt(d)), k);\n            va += o.z*ww;\n            wt += ww;\n        }\n    }\n    return va/wt;\n}\n\n//\n// Voronoi 3D\n//\n// This is a 3D version of the 2D", "\n    // Get the integer part of the coordinate and turn it\n    // into a direction in [ 0, 1 ] to lookup the right cell\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Initialize the lookup\n    float minDist = 1.0;\n\n    // Try all of the cells\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            // Get the cell's coordinate\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Get the cell's distance\n            vec2 point = rand2(i + neighbor);\n            vec2 diff = neighbor + point - f;\n            float dist = dot(diff, diff);\n\n            // Keep the minimum distance\n            minDist = min(minDist, dist);\n        }\n    }\n\n    // Return the distance\n    return minDist;\n}\n\n// The main function\nvoid main()\n{\n    // Get the", "\n\n    // We will use the rayHitInfo to get the position of the hit\n    // and then we will use that position to get the normal\n    // of the hit\n    vec3 hitPosition = eyePosition + rayDirection * rayHitInfo.x;\n    vec3 normal = getNormal( hitPosition );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color = getColor( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color2 = getColor2( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color3 = getColor3( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color4 = getColor4( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    vec3 color5 = getColor5( normal );\n\n    // We will use the normal to get the color\n    // of the hit\n    ve", "\n    // ~~~~~~~ sphere\n    // sphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    // ~~~~~~~ plane\n    // plane(p, vec3(0.0, 1.0, 0.0), 0.0);\n    // ~~~~~~~ box\n    // box(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    // ~~~~~~~ torus\n    // torus(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5);\n    // ~~~~~~~ cylinder\n    // cylinder(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5);\n    // ~~~~~~~ cone\n    // cone(p, vec3(0.0, 0.0, 0.0), 1.0, 0.5);\n    // ", "\n\tfloat tmin = 1000.0;\n\tfloat tmax = 2000.0;\n\t\n\tfloat t = tmin;\n\t\n\tvec2 res = vec2(-1.0);\n\t\n\tfor (int i = 0; i < NUM_OBJECTS; i++)\n\t{\n\t\tfloat d = sceneSDF(ro + rd * t);\n\t\tif (d < EPSILON)\n\t\t{\n\t\t\tres = vec2(t, float(i));\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tif (t > tmax)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n// ~~~~~~~ get normal of the surface at point p\n// input p --> point on surface\n// output normal\n//\nvec", "\n    // ~~~~~~~ raymarching\n    // raymarching is basically finding the closest point to the ray\n    // by moving the ray position by a small amount and checking if\n    // the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    // and we move the ray position by a small amount\n    // we do this until we find the closest point\n    // we do this by moving the ray position by a small amount\n    // and checking if the ray position is inside the object\n    // if it is, then the ray position is the closest point\n    // if it is not, then the ray position is not the closest point\n    //", "\n    float tmin = 1000.0;\n    float tmax = 2000.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x < EPSILON )\n        {\n            m = res.y;\n            break;\n        }\n        t += res.x;\n        if( t > tmax )\n            break;\n    }\n\n    if( m == -1.0 )\n        return vec4(t,m,0.0,0.0);\n\n    // calc normal\n    vec3 n = calcNormal( ro+rd*t );\n\n    // calc light\n    float occ = calcAO( ro+rd*t, n );\n    vec3 lig = normalize( vec3(0.0,0.0,1.0) );\n    float amb = clamp( 0.5+0.", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float w = 0.0;\n    float wSum = 0.0;\n    float dSum = 0.0;\n    float dMax = 0.0;\n    float dMin = 1000000.0;\n    float dMinIdx = 0.0;\n    float dMaxIdx = 0.0;\n    float dMinIdx2 = 0.0;\n    float dMaxIdx2 = 0.0;\n    float dMinIdx3 = 0.0;\n    float dMaxIdx3 = 0.0;\n    float dMinIdx4 = 0.0;\n    float dMaxIdx4 = 0.0;\n    float dMinIdx5 = 0.0;\n    float dMaxIdx5 = 0.0;\n    float dMinIdx6 = 0.0;\n    float dMaxIdx6 = 0.0;\n    float dMinIdx7 = 0.0;\n    float dMaxIdx7 = 0", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 21.0));\n    vec4 v = vec4(n, n+1.0, n+57.0, n+58.0) * 1.1547005383792515290182975610039;\n    vec4 r = fract(v*1031.1031);\n    r = r*r*(3.0-2.0*r);\n    float n0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n    r = fract(v*1031.1031);\n    r = r*r*(3.0-2.0*r);\n    float", "\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float tmax = 1000.0;\n    float tmin = 0.001;\n    float tstep = 0.01;\n    for (int i = 0; i < 100; i++) {\n        t += tstep;\n        if (t > tmax) break;\n        vec3 pos = rayDir * t;\n        float h = GetHeight(pos);\n        if (h > 0.0) {\n            float d = t - h;\n            if (d < tstep) {\n                vec3 n = GetNormal(pos);\n                float f = dot(n, rayDir);\n                if (f > 0.0) {\n                    float f2 = f * f;\n                    float f3 = f2 * f;\n                    float f4 = f2 * f2;\n                    float f5 = f4 * f;\n                    float f6 = f5 * f;\n                    float f7 = f6 * f;\n                    float f8 =", "\n    vec2 AB = B - A;\n    vec2 AC = coords - A;\n    float t = dot(AC, AB) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    vec2 P = A + t * AB;\n    float d = length(P - coords);\n    return d - height;\n}\n\n//============================================================\nfloat", "\n    float dot = dot(start, end);\n    float theta_0 = acos(dot);\n    float theta = theta_0 * percent;\n    vec2 v2 = end - start * dot;\n    v2 = normalize(v2);\n    return ((start * cos(theta)) + (v2 * sin(theta)));\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================\n//============================================================", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0.0)\n        return length(ap);\n    else if (t > 1.0)\n        return length(p - b);\n    else\n        return length(ap - t * ab);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat", "\n    vec3 color = vec3(0.0);\n\n    // Add a softbox light.\n    float dist = RayBox(rayDir, vec3(0.0), vec3(1000.0), 0.0);\n    if (dist > 0.0)\n    {\n        color += vec3(1.0);\n    }\n\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The distance to the nearest surface.\n    float d = -1.0;\n\n    // The material index.\n    int materialIndex = 0;\n\n    // The distance to the nearest surface.\n    float d1 = Sphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    float d2 = Sphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n    float d3 = Sphere(p, vec3(0.0, 0.0, 0.0), 0.25);\n\n    // The material index.\n    int materialIndex1 = 1;\n    int materialIndex2 = 2;\n    int materialIndex3 = 3;\n\n    // The distance to the nearest surface.\n    float d4 = Box(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float d5 = Box(p, vec3(", "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n        return false;\n    float t1 = (-b - sqrt(d)) / (2.0 * a);\n    float t2 = (-b + sqrt(d)) / (2.0 * a);\n    near = min(t1, t2);\n    far = max(t1, t2);\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float b = dot(org, dir);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - c;\n    if (d < 0.0)\n        return false;\n    float t1 =", "\n    vec3 q = abs(p) - s.xyz;\n    float k0 = length(max(q, 0.0));\n    float k1 = min(max(q.x, max(q.y, q.z)), 0.0);\n    float h = max(k0 - r.x, k1);\n    return length(max(vec2(h, h - s.w), 0.0)) - r.y;\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nfloat", "\n    // Permutation and hashing used in original shader\n    int[256] perm = int[](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n            88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165", "\n    float r = 0.0;\n    r += circle(p, vec2(0.0, 0.0), 0.25);\n    r += circle(p, vec2(0.5, 0.0), 0.25);\n    r += circle(p, vec2(0.0, 0.5), 0.25);\n    r += circle(p, vec2(0.5, 0.5), 0.25);\n    return r;\n}\n\nfloat", "\n    vec3 bump = vec3(0.0);\n    for(int i = 0; i < 3; i++){\n        bump[i] = bumpFactor * (sn[i] - sp[i]);\n    }\n    return bump;\n}\n\n//\n// Standard bump function.\n//\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec3 l = normalize(light_pos - p);\n    vec3 v = normalize(camera_pos - p);\n    vec3 h = normalize(l + v);\n\n    float n_dot_l = max(dot(n, l), 0.0);\n    float n_dot_h = max(dot(n, h), 0.0);\n\n    vec3 diffuse = n_dot_l * light_color;\n    vec3 specular = pow(n_dot_h, 100.0) * light_color;\n\n    return diffuse + specular;\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy / resolution, 0.0);\n    vec3 n = normal(p);\n\n    vec3 color = shade(p, n);\n\n    frag_color = vec4(color, 1.0);\n}\n", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec3 sky = vec3(0.0);\n    vec3 sun = vec3(0.0);\n    vec3 sunColor = vec3(1.0);\n    vec3 sunDir = normalize(vec3(0.0, 1.0, 0.0));\n    float sunIntensity = 1.0;\n\n    // sun\n    float sunDot = dot(rd, sunDir);\n    float sunAngle = acos(sunDot);\n    float sunAngleFalloff = clamp(sunAngle / (0.5 * PI), 0.0, 1.0);\n    float sunAngleFalloff2 = sunAngleFalloff * sunAngleFalloff;\n    float sunAngleFalloff3 = sunAngleFalloff2 * sunAngleFalloff;\n    float sunAngleFalloff4 = sunAngleFalloff3 * sunAngleFalloff;\n    float sunAngleFalloff5 = sunAngleFalloff4 * sunAngleFalloff;", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < EPSILON)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return length(p)-rad;\n}\n\n//box\nfloat", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p - vec3(0.0, 0.0, 2.0), vec3(0.5, 0.5, 0.5)), 0.1);\n    d = opSmoothUnion(d, sdBox(p - vec3(0.0, 0.0, 4.0), vec3(0.5, 0.5, 0.5)), 0.1);\n    d = opSmoothUnion(d, sdBox(p - vec3(0.0, 0.0, 6.0), vec3(0.5, 0.5, 0.5)), 0.1);\n    d = opSmoothUnion(d, sdBox(p - vec3(0.0, 0.0, 8.0), vec3(0.5, 0.5, 0.5)), 0.1);\n    d", "\n    float d = DE(p, param);\n    float l = length(p);\n    float ld = l * d;\n    float ld2 = ld * ld;\n    float ld3 = ld2 * ld;\n    float ld4 = ld2 * ld2;\n    float ld5 = ld4 * ld;\n    float ld6 = ld4 * ld2;\n    float ld7 = ld6 * ld;\n    float ld8 = ld6 * ld2;\n    float ld9 = ld8 * ld;\n    float ld10 = ld8 * ld2;\n    float ld11 = ld10 * ld;\n    float ld12 = ld10 * ld2;\n    float ld13 = ld12 * ld;\n    float ld14 = ld12 * ld2;\n    float ld15 = ld14 * ld;\n    float ld16 = ld14 * l", "\n    vec3 col = vec3(0.0);\n    float sun = max(dot(rd, sunDir), 0.0);\n    float sky = max(dot(rd, skyDir), 0.0);\n    float sky2 = max(dot(rd, skyDir2), 0.0);\n    float sky3 = max(dot(rd, skyDir3), 0.0);\n    float sky4 = max(dot(rd, skyDir4), 0.0);\n    float sky5 = max(dot(rd, skyDir5), 0.0);\n    float sky6 = max(dot(rd, skyDir6), 0.0);\n    float sky7 = max(dot(rd, skyDir7), 0.0);\n    float sky8 = max(dot(rd, skyDir8), 0.0);\n    float sky9 = max(dot(rd, skyDir9), 0.0);\n    float sky10 = max(dot(rd, skyDir10), 0.0);\n    float sky11 = max(dot(rd", "\n    vec3 col = vec3(0.0);\n    vec3 pos = ro + rd * ti;\n    vec3 nor = calcNormal(pos);\n    float dif = clamp(dot(nor, lightDir), 0.0, 1.0);\n    col = vec3(dif);\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));\n    float ti = intersect(ro, rd);\n    vec3 col = rayColor(ro, rd, ti);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    p = abs(p - diamond.xy);\n    p -= 2.0 * min(min(p.x, p.y), 0.0) + vec2(clamp(p.x, 0.0, 1.0), clamp(p.y, 0.0, 1.0));\n    return length(p) * sign(max(p.x, p.y));\n}\n\n// circle: (center.x, center.y, radius)\nfloat", "\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y,uv.x);\n    float r = TWO_PI/float(N);\n    float d1 = cos(floor(.5+a/r)*r-a)*length(uv);\n    float d2 = cos(floor(.5+a/r)*r-a+r)*length(uv);\n    col = vec3(1.0-smoothstep(FOLD_WIDTH,FOLD_WIDTH+.1,d1));\n    col *= vec3(1.0-smoothstep(FOLD_WIDTH,FOLD_WIDTH+.1,d2));\n    return col;\n}\n\nvoid main(){\n    vec2 uv = (gl_FragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    col = pattern(uv);\n    col = vec3(1.0-exp(-col*", "\n    return length( pos ) - 1.0;\n}\n\n// get distance in the world\nfloat", "\n    vec3 l = normalize( lightPos - v );\n    vec3 h = normalize( l + eye );\n    vec3 ambient = ka * Ia;\n    vec3 diffuse = kd * max( dot( n, l ), 0.0 ) * Id;\n    vec3 specular = ks * pow( max( dot( n, h ), 0.0 ), shininess ) * Is;\n    return ambient + diffuse + specular;\n}\n\nvoid main() {\n    vec3 v = vec3( gl_ModelViewMatrix * gl_Vertex );\n    vec3 n = normalize( gl_NormalMatrix * gl_Normal );\n    vec3 eye = normalize( -v );\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n    gl_FrontColor = vec4( shading( v, n, eye ), 1.0 );\n}\n", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float d = length(p) - offset;\n    return pow(abs(sin(d * 100.0)), 1.0);\n}\n\n// 2d rotation matrix\nmat", "\n    float r = x.x;\n    float g = x.y;\n    float b = x.z;\n    float y = (r + g + b) / 3.0;\n    float c = (r - y) * (g - y) * (b - y);\n    float m = max(r, max(g, b));\n    float n = min(r, min(g, b));\n    float z = ((y - n) - (m - y)) * ((y - n) - (m - y)) * ((y - n) - (m - y));\n    float e = (r - g) * (r - g) * (r - g) * (r - g);\n    float f = (g - b) * (g - b) * (g - b) * (g - b);\n    float h = (b - r) * (b - r) * (b - r) * (b - r);\n    float i = (r - g) * (g - b) * (b - r);\n    float j = (r - y) * (g", "\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h/2.0);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * Signed distance function for a cone with base radius r1 and top radius r2,\n * and height h.\n */\nfloat", "\n    float sphere = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n    float plane = p.y;\n    return min(sphere, plane);\n}\n\n/**\n * Calculate the normal of the surface at point p.\n */\nvec", "\n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, up));\n    vec3 newUp = cross(right, forward);\n\n    return mat3(right, newUp, -forward);\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float n = pnoise(p, 1.0);\n    n += pnoise(p*2.0, 2.0);\n    n += pnoise(p*4.0, 4.0);\n    n += pnoise(p*8.0, 8.0);\n    n /= 4.0;\n    return n;\n}\n\n// my noise\nfloat", "\n    vec2 pos = coord;\n    float dist = distance(pos, vec2(0.0, 0.0));\n    float angle = atan(pos.y, pos.x);\n    float color = sin(dist * morphConstant.x + angle * morphConstant.y);\n    return vec4(color, color, color, 1.0);\n}\n\n//Returns the color of a biomorph at position coord\nvec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    return 1.0 - smoothstep(0.0, 0.01, length(p));\n}\n\n// The bump mapping function.\nfloat", "\n    vec4 scr_pt_hom = vec4(scr_pt, 0.0, 1.0);\n    vec4 view_pt = viewp_inv * scr_pt_hom;\n    view_pt.xyz /= view_pt.w;\n    vec4 world_pt = view_inv * view_pt;\n    vec4 world_dir = proj_inv * view_pt;\n    return vec4(world_pt.xyz, world_dir.xyz);\n}\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec", "\n    vec2 pa = pA - uv;\n    vec2 ba = pB - pA;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h) - thick.x;\n    float m = smoothstep(thick.y, 0.0, d);\n    float r = length(pa) - thick.x;\n    float a = (1.0 - smoothstep(thick.y, 0.0, r)) * dashOn;\n    return mix(m, a, rounded);\n}\n\n// This is the same as above, but it will return the distance field and the normal at the same time.\n// The normal is the direction of the line at the point.\n// This is useful for lighting, but you can also use it for other things.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n// The normal is not normalized, so you will need to normalize it yourself if you want to use it.\n//", "\n    vec3 lightDir = normalize(vec3(1, 1, 1));\n    vec3 lightColor = vec3(1, 1, 1);\n    float diffuse = max(dot(n, lightDir), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n    return diffuseColor;\n}\n\n// Ray marching\n// p : point,\n// d : direction\nfloat", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t = max(max(k.x, k.y), k.z);\n    return vec2(t + min(max(k.x, max(k.y, k.z)), 0.0), t);\n}\n\n// ray-box intersection (simplified)\nvec", "\n    float y = sin(x * PI);\n    float z = (y + 1) / 2;\n    float w = pow(z, a);\n    return w * b;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// z * z\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*dot(oa,oa) - baoa*baoa - ra*ra;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        vec3  n = (oa + t*rd) / ra;\n        return vec4( t, n );\n    }\n    return vec4(-1.0);\n}\n\n// ray-cone intersection (returns t and normal)\nvec", "\n    float d = length(P) - r;\n    if (d < 0.0) {\n        O = vec4(C, 1.0);\n    }\n}\n\nvoid main() {\n    vec2 P = (gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;\n    vec4 O = vec4(0.0);\n\n    sphere(O, vec2(0.0, 0.0), P, 0.5, vec3(1.0, 0.0, 0.0));\n\n    gl_FragColor = O;\n}\n", "\n    float d = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    d = opSmoothUnion(d, sdSphere(p, vec3(0.0, 0.0, 0.0), 0.5), 0.1);\n    return d;\n}\n\n// ray marching\nfloat", "\n    float scale = pow(2.0, layerID);\n    p = p * scale;\n    p = p - 0.5 * scale;\n    return vec3(p, layerID);\n}\n\n// The main function. This is where the magic happens.\n// The function takes a point, and returns a color.\n// The point is in the range [-1, 1] x [-1, 1].\n// The color is in the range [0, 1] x [0, 1] x [0, 1].\nvec", "\n    vec3 c = vec3(0.0);\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float d = abs(a);\n    float s = sin(d*10.0);\n    float t = tan(d*10.0);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r4*r4;\n    float r10 = r8*r2;\n    float r12 = r8*r4;\n    float r14 = r12*r2;\n    float r16 = r12*r4;\n    float r18 = r16*r2;\n    float r20 = r16*r4;\n    float r22 = r20*r2;\n    float r24 = r20*r4;\n    float r26 = r24*r2;\n    float r28 = r2", "\n    float flameRadius = 0.5;\n    float flameHeight = 0.5;\n    float flameWidth = 0.5;\n    float flameLength = 0.5;\n    float flameDistance = length(currentRayPosition - vec3(0.0, flameHeight, 0.0));\n    float flameAngle = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle2 = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle3 = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle4 = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle5 = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle6 = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle7 = atan(currentRayPosition.x, currentRayPosition.z);\n    float flameAngle8 = atan(current", "\n    float distanceToSphere = length(currentRayPosition - spherePosition) - sphereRadius;\n    float distanceToPlane = dot(currentRayPosition, planeNormal) - planeDistance;\n    return min(distanceToSphere, distanceToPlane);\n}\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0446\u0432\u0435\u0442 \u043f\u0438\u043a\u0441\u0435\u043b\u044f\nvec", "\n    return (1.0 - cos(x * 3.1415926535897932384626433832795)) * 0.5 * sm;\n}\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat", "\n    vec3 q = vec3(dot(p, vec3(1.0, 57.0, 21.0)),\n                  dot(p, vec3(57.0, 21.0, 1.0)),\n                  dot(p, vec3(21.0, 1.0, 57.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\n// vec3 to vec3 hash algorithm.\nvec", "\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y + p.z) * F3; // F3 = (sqrt(3) - 1) / 3;\n    // Very nice interpolating function.\n    // s = s - floor(s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s * (3 - 2 * s);\n    // s = s * s", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.01;\n    f += 0.2500*noise(p); p = p*2.02;\n    f += 0.1250*noise(p); p = p*2.03;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat", "\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n    vec3 balloonSize = vec3(0.5, 0.5, 0.5);\n    vec3 balloonDirection = vec3(0.0, 1.0, 0.0);\n    float balloonRadius = 0.2;\n    float balloonHeight = 0.5;\n    float balloonAngle = 0.0;\n    float balloonSpeed = 0.01;\n    float balloonRotationSpeed = 0.01;\n    float balloonRotationAngle = 0.0;\n    float balloonRotationAngleSpeed = 0.01;\n    float balloonRotationAngleSpeed2 = 0.01;\n    float balloonRotationAngleSpeed3 = 0.01;\n    float balloonRotationAngleSpeed4 = 0.01;\n    float balloonRotationAngleSpeed5 = 0.01;\n    float balloonRotationAngleSpeed6 = 0.01", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec4( tN, tF, tN>tF?-1.0:1.0, tN>tF?0.0:1.0 );\n}\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y + p.z) * F3; // F3 = (sqrt(3.0)-1.0)/3.0\n    vec3 i = floor(p + s);\n    vec3 x0 = p - i + s;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    vec3 w, g;\n    vec3 g0 = vec3(x0.x, x0.y, x0.z);\n    vec3 g1 = vec3(x0.y, x0.z, x0.x);\n    vec3 g2 = vec3(x0.z, x0.x, x0.y);\n    float k0 = dot(g0, g0);\n    float k1 = dot(g1, g1);\n    float k2 = dot(g2, g2);\n   ", "\n    vec2 pa=p-a, ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    float d=length(pa-ba*h);\n    return c*d;\n}\n\n//coloring lineAO()\nvec", "\n    float i = 0.0;\n    for(; i < 100.0; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(dot(z,z) > 4.0) break;\n    }\n    return i;\n}\n\n//Main function\nvoid main(){\n    //Get the pixel coordinates\n    vec2 c = (gl_FragCoord.xy - 0.5*u_resolution.xy)/u_resolution.y;\n    //Calculate the mandelbrot set\n    vec2 z = vec2(0.0, 0.0);\n    float i = mandelbrot(c, z);\n    //Calculate the color\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if(i < 100.0){\n        color = vec3(0.0, 0.0, 0.0);\n    }", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    return mat4(\n        x.x, x.y, x.z, 0,\n        y.x, y.y, y.z, 0,\n        z.x, z.y, z.z, 0,\n        -dot(x, cam), -dot(y, cam), -dot(z, cam), 1\n    );\n}\n\n//projection matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//color space\nvec", "\n    float d = abs(p.x) - w;\n    d = max(d, abs(p.y) - w);\n    d = max(d, abs(p.x) - w * dir);\n    return d;\n}\n\nfloat", "\n    return (x - a) / (b - a);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float x = xy.x;\n    float y = func(x);\n    if (y == -1.0)\n    {\n        baseCol = curveCol;\n    }\n    else\n    {\n        baseCol = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicitFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float f = func(x);\n    if (f == y)\n    {\n        baseCol = curveCol;\n    }\n    else\n    {\n        baseCol = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicitFunc2(inout vec4 baseCol, vec2 xy, vec", "\n    float d=0.;\n    for(int i=0;i<5;i++){\n        float a=float(i)*3.1415926535/2.;\n        float s=sin(a);\n        float c=cos(a);\n        vec2  t=vec2(c,s);\n        vec2  r=vec2(c,-s);\n        d+=line(p,t*0.5,r*0.5,j);\n    }\n    return d;\n}\n\n//[j]=jitter\nfloat", "\n    return smoothstep(0.0, 1.0, f);\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat", "\n    c.r = c.r*1.05 - 0.05;\n    c.g = c.g*0.95 + 0.05;\n    c.b = c.b*1.05 - 0.05;\n    return c;\n}\n\n//reduce rgb values of some ranges, similar to EnChromaHsv(), but\n//not quite how human vision works, still helps \"visualizing\"\n//how this apparently enhanches yellow, and mostly filters out green.\nvec", "\n    vec3 d = abs(p) - s;\n    return vec4(min(max(d.x,max(d.y,d.z)),0.0),d);\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n    float d = sdSphere(p, 1.0);\n    float d2 = sdSphere(p, 0.5);\n    float d3 = sdSphere(p, 0.25);\n    float d4 = sdSphere(p, 0.125);\n    float d5 = sdSphere(p, 0.0625);\n    float d6 = sdSphere(p, 0.03125);\n    float d7 = sdSphere(p, 0.015625);\n    float d8 = sdSphere(p, 0.0078125);\n    float d9 = sdSphere(p, 0.00390625);\n    float d10 = sdSphere(p, 0.001953125);\n    float d11 = sdSphere(p, 0.0009765625);\n    float d12 = sdSphere(", "\n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    float t = 0.0;\n    float s = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// Tone mapping\nvec", "\n    float d=1e10;\n    for(int i=0;i<10;i++){\n        p=abs(p*2.)-1.;\n        p.x=max(p.x,p.y);\n        p.x=max(p.x,p.z);\n        d=min(d,p.x);\n    }\n    return d;\n}\n\nfloat", "\n    float d = sdSphere(p, 1.0);\n    if (d < 0.0) {\n        return mat(vec3(0.0), vec3(0.0), 0.0);\n    }\n    return mat(vec3(0.0), vec3(0.0), 0.0);\n}\n\n//scene normal at position p\nvec", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    vec2 p0 = floor(p);\n    vec2 p1 = p0 + vec2(1.0, 0.0);\n    vec2 p2 = p0 + vec2(0.0, 1.0);\n    vec2 p3 = p0 + vec2(1.0, 1.0);\n\n    vec2 d0 = p - p0;\n    vec2 d1 = p - p1;\n    vec2 d2 = p - p2;\n    vec2 d3 = p - p3;\n\n    vec2 d00 = d0;\n    vec2 d10 = d1;\n    vec2 d01 = d0;\n    vec2 d11 = d1;\n\n    d00.x = d00.x * d00.x;\n    d10.x = d10.x * d10.x;\n    d01.y = d01.y * d01.y;\n    d11.y = d", "\n    return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough [a] and [b], a and b must be normalized.\nfloat", "\n    return dot(u,m);\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n    vec2 v = u - m.xy;\n    vec2 w = m.zw - m.xy;\n    float l2 = dot(w,w);\n    float t = dot(v,w)/l2;\n    t = clamp(t, 0.0, 1.0);\n    vec2 p = m.xy + t*w;\n    return distance(u,p);\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return U.x;\n}\n\n/* end__.Main\n   start.Implicit\n*/\nv1 c(v2 U){\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return U.x;\n}\n\n/* end__.Main\n   start.Implicit\n*/\nv1 c(v2 U){\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return U.x;\n}\n\n/* end__.Main\n   start.Implicit\n*/\nv1 c(v2 U){\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return U.x;\n}\n\n/* end__.Main\n   start.Implicit\n*/\nv1 c(v2 U){\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\n", "\n   return U.x;\n}\n\nv2 d(v1 U){\n   return U.y;\n}\n\nv2 e(v1 U){\n   return U.z;\n}\n\nv2 f(v1 U){\n   return U.w;\n}\n\nv2 g(v1 U){\n   return U.x;\n}\n\nv2 h(v1 U){\n   return U.y;\n}\n\nv2 i(v1 U){\n   return U.z;\n}\n\nv2 j(v1 U){\n   return U.w;\n}\n\nv2 k(v1 U){\n   return U.x;\n}\n\nv2 l(v1 U){\n   return U.y;\n}\n\nv2 m(v1 U){\n   return U.z;\n}\n\nv2 n(v1 U){\n   return U.w;\n}\n\nv2 o(v1 U){\n   return U.x;\n}\n\nv2 p(v1 U){\n   return U.y;\n}", "\n    return a - dot(a, b) * b;\n}\n\n//Gram-Schmidt method\nvec", "\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    float r3 = 1.0 - r1;\n    float r4 = 1.0 - r2;\n    w = r1 * A + r2 * B + r3 * C;\n    wPdf = dot(cross(B - A, C - A), w) / dot(cross(B - A, C - A), A);\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangle(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf, out vec3 wN) {\n    float r1 = sqrt(Xi1);\n    float r2", "\n   return U.x;\n}\n\nv2 d(v1 U){\n   return U.y;\n}\n\nv2 e(v1 U){\n   return U.z;\n}\n\nv2 f(v1 U){\n   return U.w;\n}\n\nv2 g(v1 U){\n   return U.x;\n}\n\nv2 h(v1 U){\n   return U.y;\n}\n\nv2 i(v1 U){\n   return U.z;\n}\n\nv2 j(v1 U){\n   return U.w;\n}\n\nv2 k(v1 U){\n   return U.x;\n}\n\nv2 l(v1 U){\n   return U.y;\n}\n\nv2 m(v1 U){\n   return U.z;\n}\n\nv2 n(v1 U){\n   return U.w;\n}\n\nv2 o(v1 U){\n   return U.x;\n}\n\nv2 p(v1 U){\n   return U.y;\n}", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return max(p.x,p.y)-0.5;\n}\n\n// Torus: A torus is a tube with a hole in the middle.\nfloat", "\n    vec3 q = p;\n    q.xz = mod(q.xz, 2.0) - 1.0;\n    q.y = mod(q.y, 2.0) - 1.0;\n    float d = length(q) - 0.5;\n    float d2 = length(q.xz) - 0.5;\n    float d3 = length(q.yz) - 0.5;\n    float d4 = length(q.xy) - 0.5;\n    float d5 = length(q.xz) - 0.5;\n    float d6 = length(q.yz) - 0.5;\n    float d7 = length(q.xy) - 0.5;\n    float d8 = length(q.xz) - 0.5;\n    float d9 = length(q.yz) - 0.5;\n    float d10 = length(q.xy) - 0.5;\n    float d11 = length(q.xz) -", "\n    float d = sdSegment(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    float gID2 = floor(gID);\n    float gID3 = mod(gID2, 2.0);\n    float gID4 = step(0.5, gID3);\n    float gID5 = gID4 * 0.5;\n    float gID6 = gID5 * 0.5;\n    float gID7 = gID6 * 0.5;\n    float gID8 = gID7 * 0.5;\n    float gID9 = gID8 * 0.5;\n    float gID10 = gID9 * 0.5;\n    float gID11 = gID10 * 0.5;\n    float gID12 = gID11 * 0.5;\n    float gID13 = gID12 * 0.5;\n    float gID14 = gID1", "\n    float t = 0.0;\n    for(int i = 0; i < 128; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            return t;\n        }\n        t += d;\n    }\n    return 1000.0;\n}\n\n// Calculate the normal of the surface at a point.\nvec", "\n    float res = 1.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tstep = tmax/100.0;\n    for(float ti=tmin; ti<tmax; ti+=tstep){\n        float h = map(ro + ti*l);\n        if(h<0.001){\n            return 0.0;\n        }\n        float y = h*h/(2.0*k);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 10.0*d/ti);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// The main function.\nvec", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(0.0);\n    nor.x = sd(p + eps.xyy, t) - sd(p - eps.xyy, t);\n    nor.y = sd(p + eps.yxy, t) - sd(p - eps.yxy, t);\n    nor.z = sd(p + eps.yyx, t) - sd(p - eps.yyx, t);\n    edge = clamp(1.0 - (nor.x + nor.y + nor.z) / 3.0, 0.0, 1.0);\n    crv = clamp(1.0 - (nor.x * nor.x + nor.y * nor.y + nor.z * nor.z) / 3.0, 0.0, 1.0);\n    return normalize(nor);\n}\n\n// Distance to the scene.\nfloat", "\n    vec3 v = p3 - t;\n    return vec4(dot(v, m[0]), dot(v, m[1]), dot(v, m[2]), 0.0);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    // p is the position in the grid\n    // p.x is the column, p.y is the row\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we need to do some math to get the right cell\n    // the hexagonal grid is a bit weird, so we", "\n    float d = sdTruchet(p, dir);\n    return d;\n}\n\n// Distance field for the whole scene.\nfloat", "\n    float r = length(q);\n    float theta = atan(q.y, q.x);\n    if(dir == 1.){\n        return theta;\n    }else{\n        return r;\n    }\n}\n\n// Get the color of the arc pixel.\nvec", "\n    vec3 v = p3 - t;\n    return vec4(dot(v, n[0]), dot(v, n[1]), dot(v, n[2]), 1.0);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n  vec4 v = q - p;\n  vec4 w = r - p;\n  float c1 = dot(v, v);\n  float c2 = dot(v, w);\n  float b = c1 - c2*c2/dot(w, w);\n  float a = c2*c2/dot(w, w) - dot(v, v);\n  float k = -b / (2.0*a);\n  if (k < 0.0 || k > 1.0) return c1;\n  return b*b / (4.0*a);\n}\n\n// Find the (squared) distance to the triangle in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float d = sdBox(p, vec2(lW, lW));\n    float s = smoothstep(0.0, 0.01, d);\n    return s;\n}\n\n// Background pipe.\nfloat", "\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 grid = abs(fract(p*w - 0.5*w) - 0.5);\n    return 1.0 - smoothstep(0.0, 0.1, min(grid.x, grid.y));\n}\n\n// grid ratio\nfloat", "\n    vec2 p = f;\n    float d = dot(p,p);\n    mr = p;\n    mg = p;\n    float dmr = d;\n    float dmg = d;\n    for( int i=0; i<4; i++ )\n    {\n        p = n + p;\n        d = dot(p,p);\n        if( d<dmr )\n        {\n            dmr = d;\n            mr = p;\n        }\n        if( d<dmg )\n        {\n            dmg = d;\n            mg = p;\n        }\n    }\n    return sqrt(dmg);\n}\n\n// This is the main function.\n// It's a bit more complicated than it should be,\n// but it's more elegant than the previous version.\n// We pass n=|q|, f=q-n, as an optimization.\nfloat", "\n    return vec2(lerp(pos_inicial.x, pos_final.x, t), lerp(pos_inicial.y, pos_final.y, t));\n}\n\n////////////// POSICAO PONTOS\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// vec3 to vec3 hash.\nfloat", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p0;\n    vec2 c = p2 - p1;\n    float a2 = dot(a, a);\n    float b2 = dot(b, b);\n    float c2 = dot(c, c);\n    float denom = a2 * (b2 + c2 - a2) + b2 * c2;\n    vec2 ab = (a2 * b + a * b2 + a * c2) / denom;\n    vec2 bc = (b2 * c + b * c2 + b * a2) / denom;\n    vec2 ca = (c2 * a + c * a2 + c * b2) / denom;\n    return ab + bc + ca;\n}\n\n// Triangle's circumcenter: The center of the circumscribed circle, which in essence is the\n// smallest circle that can be drawn around a triangle.\nvec", "\n    float a = length(p0-p1);\n    float b = length(p1-p2);\n    float c = length(p2-p0);\n    float s = (a+b+c)/2.0;\n    return sqrt(s*(s-a)*(s-b)*(s-c))/s;\n}\n\n// The radius of the triangle's circumcircle:\nfloat", "\n    vec2 v1 = h2 - h1;\n    vec2 v2 = h3 - h1;\n    vec2 v3 = h3 - h2;\n\n    float a = dot(v1, v1);\n    float b = dot(v2, v2);\n    float c = dot(v3, v3);\n\n    float d = dot(v1, v2);\n    float e = dot(v1, v3);\n    float f = dot(v2, v3);\n\n    float g = a * c - d * d;\n    float h = b * c - f * f;\n    float i = a * b - d * e;\n\n    float j = a * a + b * b + c * c;\n    float k = d * d + e * e + f * f;\n\n    float l = (h * i - g * k) / (g * i - h * f);\n    float m = (h * l - f) / (g - h);\n    float n = (l * m - e) / (d -", "\n    // The triangle we're returning\n    triObj tri;\n    // The cell we're in\n    int cell = getCell(p);\n    // The cell we're in\n    int cell2 = cell;\n    // The cell we're in\n    int cell3 = cell;\n    // The cell we're in\n    int cell4 = cell;\n    // The cell we're in\n    int cell5 = cell;\n    // The cell we're in\n    int cell6 = cell;\n    // The cell we're in\n    int cell7 = cell;\n    // The cell we're in\n    int cell8 = cell;\n    // The cell we're in\n    int cell9 = cell;\n    // The cell we're in\n    int cell10 = cell;\n    // The cell we're in\n    int cell11 = cell;\n    // The cell we're in\n    int cell12 = cell;\n    // The cell we're in\n    int cell13 = cell;\n    // The cell we're in\n    int cell1", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    float t = 0.0;\n    float d = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(ro + rd * t);\n        t += d;\n        if (d < 0.001 || t > tmax) break;\n    }\n    if (t < tmax) {\n        col = vec3(1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////////////////////////////////////////////////\n    // Replace with your code here:\n    /////////////////////////////////////////////////////////////////////////////\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56de", "\n\tvec3 oc = ray.origin - sph.center;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = dot( oc, ray.direction );\n\tfloat c = dot( oc, oc ) - sph.radius * sph.radius;\n\tfloat discriminant = b * b - a * c;\n\tif ( discriminant > 0.0 )\n\t{\n\t\tfloat temp = ( -b - sqrt( discriminant ) ) / a;\n\t\tif ( temp < tmax && temp > tmin )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\ttemp = ( -b + sqrt( discriminant ) ) / a;\n\t\tif ( temp < tmax && temp > tmin )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_", "\n    /////////////////////////////////////////////////////////////////////////////\n    // TODO: 1. \u4f7f\u7528RaySphereIntersect\u51fd\u6570\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u573a\u666f\u4e2d\u6240\u6709\u7403\u4f53\u7684\u76f8\u4ea4\n    // TODO: 2. \u5982\u679c\u6709\u76f8\u4ea4\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u573a\u666f\u4e2d\u6240\u6709\u5149\u6e90\u7684\u5149\u7167\n    // TODO: 3. \u5982\u679c\u6ca1\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u4f7f\u7528RaySphereIntersect\u51fd\u6570\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u573a\u666f\u4e2d\u6240\u6709\u7403\u4f53\u7684\u76f8\u4ea4\n    // 2. \u5982\u679c\u6709\u76f8\u4ea4\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u573a\u666f\u4e2d\u6240\u6709\u5149\u6e90\u7684\u5149\u7167\n    // 3. \u5982\u679c\u6ca1\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u4f7f\u7528RaySphereIntersect\u51fd\u6570\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u573a\u666f\u4e2d\u6240\u6709\u7403\u4f53\u7684\u76f8\u4ea4\n    // 2. \u5982\u679c\u6709\u76f8\u4ea4\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u573a\u666f\u4e2d\u6240\u6709\u5149\u6e90\u7684\u5149\u7167\n    // 3. \u5982\u679c\u6ca1\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1.", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d0d1 = d0 * d1;\n    vec2 d1d2 = d1 * d2;\n    vec2 d2d0 = d2 * d0;\n\n    vec2 d0d1d2 = d0d1 * d2;\n    vec2 d1d2d0 = d1d2 * d0;\n    vec2 d2d0d1 = d2d0 * d1;\n\n    vec2 d0d1d2d0 = d0d1d2 * d0;\n    vec2 d1d2d0d1 = d1d2d0 * d1;\n    vec2 d2d0d1d2 = d2d0d1 * d2;\n\n    vec2 d0d1d2d0d1 = d0d1d2d0 * d1;\n   ", "\n    vec3 p01 = mix(p0,p1,0.5);\n    vec3 p12 = mix(p1,p2,0.5);\n    vec3 p23 = mix(p2,p3,0.5);\n    vec3 p012 = mix(p01,p12,0.5);\n    vec3 p123 = mix(p12,p23,0.5);\n    vec3 p0123 = mix(p012,p123,0.5);\n    vec3 pmin = min(min(min(p0,p1),p2),p3);\n    vec3 pmax = max(max(max(p0,p1),p2),p3);\n    pmin = min(min(min(pmin,p01),p12),p012);\n    pmax = max(max(max(pmax,p01),p12),p012);\n    pmin = min(min(min(p", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(ro + rd * t);\n        t += d;\n        if (d < 0.001) {\n            break;\n        }\n    }\n    if (d < 0.001) {\n        col = vec3(1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return -0.5 * (cos(PI*k) - 1.0);\n}\n\n/**\n * Sinusoidal In Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\nA: I'm not sure if this is what you're looking for, but you can use the following code to get the current time in seconds:\nfloat", "\n    return vec2(coord.x / res.x * 4.0 - 2.0, coord.y / res.y * 4.0 - 2.0);\n}\n\n// Compute the number of iterations of the mandelbrot set for a given point.\nint", "\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\n// Distance estimator.\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash\nfloat", "\n    float d = length(pos);\n    float a = atan(pos.y, pos.x);\n    float w = width * 0.5;\n    float r = radius * 0.5;\n    float dd = d - r;\n    float aa = a - w;\n    float bb = a + w;\n    float dd2 = d - r * 0.5;\n    float aa2 = a - w * 0.5;\n    float bb2 = a + w * 0.5;\n    float dd3 = d - r * 0.25;\n    float aa3 = a - w * 0.25;\n    float bb3 = a + w * 0.25;\n    float dd4 = d - r * 0.125;\n    float aa4 = a - w * 0.125;\n    float bb4 = a + w * 0.125;\n    float dd5 = d - r * 0.0625;\n    float aa", "\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Sphere\n    vec3 sphereCenter = vec3(0.5, 0.5, 0.5);\n    float sphereRadius = 0.2;\n    vec3 rayOrigin = vec3(0.5, 0.5, 1.0);\n    vec3 rayDirection = normalize(vec3(uv, 0.0) - rayOrigin);\n\n    // Ray-sphere intersection\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayOrigin - sphereCenter);\n    float c = dot(rayOrigin - sphereCenter, rayOrigin - sphereCenter) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 21.0));\n    vec3 u = vec3(n+13.0, n+51.0, n+19.0);\n    vec3 r = fract(u*0.1);\n    float rx = mix(mix(dot(r, vec3(1.0, 57.0, 21.0)), dot(r, vec3(4.0, 58.0, 22.0)), f.x), mix(dot(r, vec3(17.0, 59.0, 23.0)), dot(r, vec3(19.0, 61.0, 25.0)), f.x), f.y);\n    float ry = mix(mix(dot(r, vec3(", "\n    // log-spherical space\n    sp = log(p);\n\n    // tiling\n    tp = sp * tiling;\n\n    // rotation\n    rp = rotate(tp);\n\n    // scaling\n    mul = scale(rp);\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, out float mul_inv)\n{\n    // log-spherical space\n    sp = log(p);\n\n    // tiling\n    tp = sp * tiling;\n\n    // rotation\n    rp = rotate(tp);\n\n    // scaling\n    mul", "\n    vec2 d = vec2(1000000.0, 0.0);\n    d = opU(d, vec2(SDF_Plane(p, vec3(0.0, 1.0, 0.0), 0.0), 1.0));\n    d = opU(d, vec2(SDF_Sphere(p, vec3(0.0, 0.0, 0.0), 1.0), 2.0));\n    d = opU(d, vec2(SDF_Sphere(p, vec3(0.0, 0.0, 0.0), 0.5), 3.0));\n    d = opU(d, vec2(SDF_Sphere(p, vec3(0.0, 0.0, 0.0), 0.25), 4.0));\n    d = opU(d, vec2(SDF_Sphere(p, vec3(0.0, 0.0", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    float s = sqrt(3.0);\n    float a = atan(1.0, -1.0);\n    float b = atan(1.0, 1.0);\n    float c = atan(0.0, 1.0);\n    float d = atan(0.0, -1.0);\n    float e = atan(-1.0, 0.0);\n    float f = atan(1.0, 0.0);\n    float g = atan(0.0, -1.0);\n    float h = atan(-1.0, -1.0);\n    float i = atan(1.0, 1.0);\n    float j = atan(-1.0, 1.0);\n    float k = atan(1.0, -1.0);\n    float l = atan(-1.0, 0.0);\n    float m = atan(1.0, 0.0);\n    float n = atan(0.0, 1.0);\n    float o = at", "\n    vec3 p = pos;\n    float d = length(p) - 1.0;\n    int id = 0;\n    if (p.x > 0.0) {\n        p.x -= 2.0;\n        id = 1;\n    }\n    if (p.y > 0.0) {\n        p.y -= 2.0;\n        id = 2;\n    }\n    if (p.z > 0.0) {\n        p.z -= 2.0;\n        id = 3;\n    }\n    d = max(d, length(p) - 0.5);\n    return vec2(d, float(id));\n}\n\n// returns the distance to the scene\nfloat", "\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.0;\n    return vec2(length(pos - spherePos) - sphereRadius, 0.0);\n}\n\n// returns the distance to the ground plane and the associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // raymarching variables\n    float t = 0.0;\n    float d = 0.0;\n    float maxDist = 100.0;\n    float minDist = 0.001;\n    float marchDist = 0.0;\n    float marchStep = 0.0;\n    float marchStepInc = 0.0;\n    float marchStepDec = 0.0;\n    float marchStepMax = 0.0;\n    float marchStepMin = 0.0;\n    float marchStepDecay = 0.0;\n    float marchStepDecayMin = 0.0;\n    float marchStepDecayMax = 0.0;\n    float marchStepDecayInc = 0.0;\n    float marchStepDecayDec = 0.0;\n    float marchStepDecayDecMin = 0.0;\n    float marchStepDecayDecMax = 0.0;\n    float marchStepDecayDecInc = 0.0;\n    float marchStepDecayDecDec = 0.0;\n    float marchStepDecayDecDecMin = 0.0;\n    float march", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n//https://www.shadertoy.com/view/XsXXD1\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\n/// @brief Get signed-distance funciton weight value of sphere.\nfloat", "\n    vec3 p = vec3(ix);\n    vec3 f = fract(fx);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0);\n    float d = hash(n+ 58.0);\n    float e = hash(n+113.0);\n    float f = hash(n+114.0);\n    float g = hash(n+170.0);\n    float h = hash(n+171.0);\n    float i1 = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    float i2 = mix(mix(e, f, f.x), mix(g, h, f.x), f.y);\n    return mix(i", "\n    float f = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += amp * noise(fxyz * freq);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return f;\n}\n\n// Fractal Brownian Motion 2\nfloat", "\n    p.xz = abs(p.xz);\n    p.x -= clamp(p.x,0.0,r);\n    p.y -= clamp(p.y,0.0,h);\n    return length(p) - r;\n}\n\nfloat", "\n    float d1 = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    float d2 = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n    float d3 = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.25);\n    float d4 = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.125);\n    float d5 = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.0625);\n    float d6 = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.03125);\n    float d7 = sdSphere(p, vec3(0.0, 0.0, 0.0", "\n    vec3 n = vec3(0.0);\n    float d = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(", "\n    return max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    float k0 = dot(ro,ro) - ra*ra;\n    float k1 = dot(ro,rd);\n    float k2 = dot(rd,rd);\n    float h = k1*k1 - k2*(k0-4.0*ra*ra);\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t1 = -k1 - h;\n    float t2 = -k1 + h;\n    if( t1>0.0 )\n        return t1;\n    if( t2>0.0 )\n        return t2;\n    return -1.0;\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 p_rcp = 1.0/p;\n    vec2 dpdx_rcp = 1.0/(p+dpdx);\n    vec2 dpdy_rcp = 1.0/(p+dpdy);\n    float p_mod2 = mod( mod(p.x,2.0)*0.5+mod(p.y,2.0), 2.0 );\n    float dpdx_mod2 = mod( mod(p.x+dpdx.x,2.0)*0.5+mod(p.y+dpdx.y,2.0), 2.0 );\n    float dpdy_mod2 = mod( mod(p.x+dpdy.x,2.0)*0.5+mod(p.y+dpdy.y,2.0), 2.0 );\n    float p_cross = p_mod2*dpdx_mod2 + (1.0-p_mod2)*(1.0-dpdx_mod2);\n    float dpdx_cross = dpdx_mod2*dpdy", "\n    // Set the background color.\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\n    // Setup the viewport.\n    glViewport(0, 0, g_ViewportWidth, g_ViewportHeight);\n\n    // Setup the projection matrix.\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0f, (GLfloat)g_ViewportWidth / (GLfloat)g_ViewportHeight, 1.0f, 100.0f);\n\n    // Setup the modelview matrix.\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n\n    // Setup the light.\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n\n    // Setup the material.\n    glEnable(GL_COLOR_MATERIAL);\n    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);\n\n   ", "\n    // TODO: Implement this function\n    ///////////////////////////////////////////////////////////////////////////////\n    // Hint: Use the quadratic equation to solve for t.\n    ///////////////////////////////////////////////////////////////////////////////\n    vec3 oc = ray.origin - sph.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if (discriminant > 0.0) {\n        float temp = (-b - sqrt(b * b - a * c)) / a;\n        if (temp < tmax && temp > tmin) {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = (hitPos - sph.center) / sph.radius;\n            return true;\n        }\n        temp = (-b + sqrt(b * b - a * c)) / a;\n        if (temp < tmax && temp > tmin", "\n\tvec3 oc = ray.origin - sph.center;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = dot( oc, ray.direction );\n\tfloat c = dot( oc, oc ) - sph.radius * sph.radius;\n\tfloat discriminant = b * b - a * c;\n\tif ( discriminant > 0.0 )\n\t{\n\t\tfloat temp = ( -b - sqrt( discriminant ) ) / a;\n\t\tif ( temp < tmax && temp > tmin )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\ttemp = ( -b + sqrt( discriminant ) ) / a;\n\t\tif ( temp < tmax && temp > tmin )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_", "\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TODO: Implement this function.\n    /////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////\n    // Hint:\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. Loop through all the objects in the scene.\n    // 2. For each object, cast a ray into the object.\n    // 3. If the ray intersects the object, then compute the color at the\n    //    intersection point.\n    // 4. If the color at the intersection point is not the background color,\n    //    then the ray intersects the object.\n    // 5. If the color at the intersection point is the background color,\n    //    then the ray does not intersect the object.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Your code goes here:\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////////////////////////////////////////////////\n    // End", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid main()\n{\n    vec3 pos = position;\n    pos.x += sin(time * 0.5) * 0.5;\n    pos.y += sin(time * 0.5) * 0.5;\n    pos.z += sin(", "\n    // the color of the ray\n    vec3 color = vec3(0.0);\n\n    // the distance the ray has traveled\n    float dist = 0.0;\n\n    // the direction of the ray\n    vec3 ray_dir = normalize(dir);\n\n    // the position of the ray\n    vec3 ray_pos = start;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist = 0.0;\n\n    // the position of the light ray\n    vec3 light_pos = start;\n\n    // the direction of the light ray\n    vec3 light_dir_norm = normalize(light_dir);\n\n    // the color of the light ray\n    vec3 light_color = vec3(0.0);\n\n    // the color of the ray\n    vec3 ray_color = vec3(0.0);\n\n    // the color of the light ray\n    vec3 light_", "\n    vec3 sample_dir = normalize(sample_pos - surface_pos);\n    float sample_dist = length(sample_pos - surface_pos);\n    float sample_angle = dot(sample_dir, surface_normal);\n\n    float sample_attenuation = pow(max(0.0, 1.0 - sample_dist / atmosphere_radius), 2.0);\n    float sample_intensity = max(0.0, dot(sample_dir, light_dir));\n\n    return sample_attenuation * sample_intensity * background_col;\n}\n\n/*\nThis is the main function that renders the scene.\n\nIt takes in the ray direction and the current pixel position, and returns the color of the pixel.\n*/\nvec", "\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    float depth = 0.0;\n    float shadow = 0.0;\n    float shadow_dist = 0.0;\n    float shadow_depth = 0.0;\n    float shadow_shadow = 0.0;\n    float shadow_shadow_dist = 0.0;\n    float shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(vec3(uv.x - 0.5, uv.y - 0.5, 1.0));\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n\n    // get the ray direction\n    vec3 rayDir = camDir;\n\n    // get the ray origin\n    vec3 rayOrigin = camPos;\n\n    // get the ray length\n    float rayLength = rayMarch(rayOrigin, rayDir);\n\n    // get the color\n    vec3 color = getColor(rayOrigin + rayDir * rayLength);\n\n    // draw the atmosphere\n    color = drawAtmosphere(rayOrigin, rayDir, rayLength, color);\n\n    // draw the sun\n    color = drawSun(rayOrigin, rayDir, rayLength, color, lightDir);\n\n", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float b2_ac = (b * b) - c;\n    if (b2_ac > 0.0) {\n        float t = b - sqrt(b2_ac);\n        if (t > 0.0) {\n            return t;\n        }\n    }\n    return -1.0;\n}\n\n//-----------------------------------------------------------------------\nfloat", "\n    //---------------------------------------------------------------------\n    // Calculate the intersection point of the ray with the scene\n    //---------------------------------------------------------------------\n    vec3 intersectionPoint = vec3(0.0);\n    float t = intersect(cameraPos, cameraRayDir, intersectionPoint);\n\n    //---------------------------------------------------------------------\n    // If the ray intersects with the scene, calculate the color\n    //---------------------------------------------------------------------\n    if (t > 0.0)\n    {\n        //---------------------------------------------------------------------\n        // Calculate the normal at the intersection point\n        //---------------------------------------------------------------------\n        vec3 normal = calculateNormal(intersectionPoint);\n\n        //---------------------------------------------------------------------\n        // Calculate the color of the intersection point\n        //---------------------------------------------------------------------\n        vec3 color = calculateColor(intersectionPoint, normal);\n\n        //---------------------------------------------------------------------\n        // Calculate the lighting at the intersection point\n        //---------------------------------------------------------------------\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        vec3 lightColor = vec3(1.0", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n//-----------------------------------------------------------------------\n//-----------------------------------------------------------------------\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_color = vec3(0.0);\n    vec3 ray_position = ray_origin;\n    vec3 ray_normal = vec3(0.0);\n    float ray_distance = 0.0;\n    float ray_reflection_coefficient = 1.0;\n    float ray_refraction_coefficient = 1.0;\n    float ray_refraction_index = 1.0;\n    float ray_reflection_index = 1.0;\n    float ray_reflection_angle = 0.0;\n    float ray_refraction_angle = 0.0;\n    float ray_reflection_distance = 0.0;\n    float ray_refraction_distance = 0.0;\n    float ray_reflection_distance_squared = 0.0;\n    float ray_refraction_distance_squared = 0.0;\n    float ray_reflection_distance_squared_max = 0.0;\n    float ray_refraction_distance_squ", "\n    vec2 q = p*0.5;\n    vec2 r = floor(q);\n    vec2 s = fract(q);\n    vec2 t = vec2(s.x,1.0-s.y);\n    vec2 u = vec2(s.y,1.0-s.x);\n    vec2 v = vec2(1.0-s.x,1.0-s.y);\n    vec2 w = vec2(1.0-s.y,s.x);\n    vec2 x = vec2(s.x,s.y);\n    vec2 y = vec2(s.y,s.x);\n    vec2 z = vec2(1.0-s.x,s.y);\n    vec2 w = vec2(1.0-s.y,1.0-s.x);\n    vec2 h = -1.0 + 2.0*fract(0.5*p + vec2(0.0,1.0));", "\n    return length(p) - 1.0;\n}\n\n// Get normal of the sphere\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // Permutations\n    vec4 perm0 = vec4( 1.0, 13.0, 13.0, 13.0);\n    vec4 perm1 = vec4(191.0, 191.0, 191.0, 191.0);\n    vec4 perm2 = vec4(137.0, 137.0, 137.0, 137.0);\n    vec4 perm3 = vec4( 79.0,  79.0,  79.0,  79.0);\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    vec4 grad0 = vec4( 0.8, 1.6, 0.0, 1.2);\n    vec4 grad1 = vec4( 0.1, ", "\n    return frac(53.589891*sin(x) + 43758.5453);\n}\n\n// Interpolated noise\nfloat", "\n    float d = sdBox(p, vec3(1.0));\n    return vec2(d, 1.0);\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0));\n    return vec2(d, 1.0);\n}\n\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\n// segment with disc ends: seamless distance to segment\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    //------------------------------------------\n    // 1. \u30c6\u30af\u30b9\u30c1\u30e3\u306e\u8aad\u307f\u8fbc\u307f\n    //------------------------------------------\n    vec4 tex = texture(iChannel0, uv);\n    \n    //------------------------------------------\n    // 2. \u30c6\u30af\u30b9\u30c1\u30e3\u306e\u8272\u3092\u30ab\u30e9\u30fc\u30d0\u30fc\u306b\u5909\u63db\n    //------------------------------------------\n    col = tex.rgb;\n    \n    //------------------------------------------\n    // 3. \u30c6\u30af\u30b9\u30c1\u30e3\u306e\u8272\u3092\u30b0\u30ec\u30fc\u30b9\u30b1\u30fc\u30eb\u306b\u5909\u63db\n    //------------------------------------------\n    col = vec3(tex.r);\n    \n    //------------------------------------------\n    // 4. \u30c6\u30af\u30b9\u30c1\u30e3\u306e\u8272\u3092\u53cd\u8ee2\u3055\u305b\u308b\n    //--------------------------------", "\n    p = abs(p);\n    return max(p.x,p.y) + min(p.x,p.y)*0.4330127018922193;\n}\n\n// Distance function for the hexagonal grid.\nfloat", "\n    float x = ix;\n    float y = iy;\n    float z = 0.0;\n    float w = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float ww = 0.0;\n    float xx = 0.0;\n    float yy", "\n    float t = time;\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float d = asin(p.z/r);\n    float f = cos(a*10.0-t*10.0)*0.5+0.5;\n    float g = cos(d*10.0-t*10.0)*0.5+0.5;\n    float b = cos(a*10.0+d*10.0-t*10.0)*0.5+0.5;\n    return vec3(f,g,b);\n}\n\n// Return the normal of the sphere at point p\nvec", "\n    return sin(p * 10.0) * 0.5 + 0.5;\n}\n\nfloat", "\n    return vec2(atan(z.x, z.y), length(z));\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    //  Find current tetrahedron T and it's four vertices\n    //  Check if P is inside T\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x0 = p - s + dot(s, vec3(G3));\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    vec3 i1, i2;  // Offsets for second (middle) corner of simplex in (i,j,k) coords\n    vec3 i3;      // Offsets for third (final) corner of simplex in (i,j,k) coords\n\n    if (x0.x >= x0.y) {\n        if (x0.x >= x0.z) {\n            i1 = vec3(1, 0, 0);\n            i2 = vec3(1, 1, 0);\n            i3 = vec3(1, 1, 1);\n", "\n    float time = mod(iTime, 25.0);\n    float wave = cos(p.x*0.1+time*0.1);\n    float dist = length(p.xz);\n    float rings = exp(-dist*dist);\n    return (wave*rings*0.5+0.5)*0.05;\n}\n\n// the color of the droplet is based on the distance to the center\n// the color is a gradient from blue to red\n// the color is also attenuated by the distance to the center\n// the color is also attenuated by the wave displacement\nvec", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.", "\n    float d = sdStairs(rp, vec2(1.0, 0.5), 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,", "\n    return (end - d) / (end - start);\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_texCoord).rgb;\n    float fog = linearFog(gl_FragCoord.z, u_fogStart, u_fogEnd);\n    color = mix(color, u_fogColor, fog);\n    outColor = vec4(color, 1.0);\n}\n", "\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n", "\n    vec2 q = p;\n    q.x = mod(q.x, 2.0) - 1.0;\n    q.y = mod(q.y, 2.0) - 1.0;\n    float d = length(q) - 0.5;\n    float a = atan(q.y, q.x);\n    float f = cos(a * 10.0);\n    float r = length(q);\n    float w = f * (1.0 - r);\n    return vec2(d, w);\n}\n\n// The distance field for the \"Truchet\" pattern.\nvec", "\n\n\t// Get the pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the time\n\tfloat time = iTime;\n\n\t// Get the mouse position\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\t// Get the pixel size\n\tvec2 pixelSize = 1.0 / iResolution.xy;\n\n\t// Get the pixel color\n\tvec3 pixelColor = vec3(0.0);\n\n\t// Get the pixel position\n\tvec2 pixelPos = uv;\n\n\t// Get the pixel position in the center of the screen\n\tvec2 pixelPosCenter = uv - 0.5;\n\n\t// Get the pixel position in the center of the screen with the aspect ratio\n\tvec2 pixelPosCenterAspect = uv - 0.5;\n\tpixelPosCenterAspect.x *= aspect;\n\n\t// Get the pixel position in the center of the screen with the aspect ratio and the time\n\tvec2 pixelPosCenterAs", "\n    float theta = atan(pc.y, pc.x);\n    float r = a + b*theta;\n    float r2 = length(pc);\n    float diff = abs(r2 - r);\n    if(diff < 0.001){\n        return theta;\n    }\n    return -1.0;\n}\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//If on spiral, return number of degrees (theta).\n//If not on spiral, return -1.0\nfloat", "\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid main() {\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n\n  // Remap the space to -1. to 1.\n  st = st * 2.0 - 1.0;\n\n  // Give the square an asymmetrical shape.\n  st.x *= u_resolution.x/u_resolution.y;\n\n  // Normalize the coordinates to -1. to 1.\n  st = normalize(st);\n\n  // Use a step to turn on and off the grid\n  color = vec3(step(0.1,st.x) * step(0.1,st.y));\n\n  // Plot a line\n  color = vec3(plot(st,0.95));\n\n  // Plot a dot\n  color", "\n    // Calculating the initial circular domain according to number of polygon\n    // sides (N) and the number of adjacent polygons (Q): STB was clever enough\n    // to use repeat polar space to position the rest. Anyway, the idea is to\n    // use the polygon geometry to set up the required geometrical diagram\n    // (see the line below), then use a mixture of standard Euclidean and\n    // hyperbolic geometry (if needed) to calculate the required values, which\n    // are described below.\n    //\n    // The following diagram shows the initial circular domain, where the\n    // polygon is the central polygon, and the adjacent polygons are the\n    // adjacent polygons. The adjacent polygons are positioned in a circular\n    // fashion, with the central polygon being the first adjacent polygon.\n    //\n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //", "\n    vec2 q = p - circ.xy;\n    float r = length(q);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r8 = r4 * r4;\n    float r16 = r8 * r8;\n    float r32 = r16 * r16;\n    float r64 = r32 * r32;\n    float r128 = r64 * r64;\n    float r256 = r128 * r128;\n    float r512 = r256 * r256;\n    float r1024 = r512 * r512;\n    float r2048 = r1024 * r1024;\n    float r4096 = r2048 * r2048;\n    float r8192 = r4096 * r4096;\n    float r16384 = r8192 * r8192;\n", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\n// Mouse pointer inversion.\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 normal = getNormal(march);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    float diffuse = max(dot(normal, light), 0.0);\n    color += diffuse * vec3(1.0);\n    return color;\n}\n\n// Raymarch\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", " // Input (x, y) pixel coordinate\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to polar coordinates\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n\n    // Convert to HSB\n    float h = a / (2.0 * PI);\n    float s = 1.0;\n    float b = r;\n\n    // Convert to RGB\n    vec3 rgb = hsb2rgb(vec3(h, s, b));\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}\n", "\n    float h = hash * 6.0;\n    float s = floor(h);\n    float t = fract(h);\n    float u = t * t;\n    float v = 1.0 - u;\n    float x = (s + v) * X;\n    float y = (s + u) * Y;\n    float z = s * Z;\n    return normalize(vec3(x, y, z));\n}\n\n// 2D simplex noise\nfloat", "\n    X.z = mod(X.z, 1.0);\n    X.xz = bccNoise_PlaneFirst(X.xz);\n    return X.xz;\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec", "\n  float t = iTime;\n  float wave = sin(p.x * 10.0 + t * 1.0) * 0.5;\n  wave += sin(p.x * 10.0 + t * 1.5) * 0.5;\n  wave += sin(p.x * 10.0 + t * 2.0) * 0.5;\n  wave += sin(p.x * 10.0 + t * 2.5) * 0.5;\n  wave += sin(p.x * 10.0 + t * 3.0) * 0.5;\n  wave += sin(p.x * 10.0 + t * 3.5) * 0.5;\n  wave += sin(p.x * 10.0 + t * 4.0) * 0.5;\n  wave += sin(p.x * 10.0 + t * 4.5) * 0.5;\n  wave += sin(p.x * 10.0", "\n    vec3 rayToTarget = targetPos - ray.origin;\n    float rayToTargetLength = length( rayToTarget );\n    float rayToTargetDot = dot( ray.direction, rayToTarget );\n    float rayToTargetDot2 = rayToTargetDot * rayToTargetDot;\n    float rayToTargetDot3 = rayToTargetDot2 * rayToTargetDot;\n    float rayToTargetDot4 = rayToTargetDot3 * rayToTargetDot;\n    float rayToTargetDot5 = rayToTargetDot4 * rayToTargetDot;\n    float rayToTargetDot6 = rayToTargetDot5 * rayToTargetDot;\n    float rayToTargetDot7 = rayToTargetDot6 * rayToTargetDot;\n    float rayToTargetDot8 = rayToTargetDot7 * rayToTargetDot;\n    float rayToTargetDot9 = rayToTargetDot8 * rayToTargetDot;\n    float rayToTargetDot10 = rayToTargetDot9 * rayToTargetDot;", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a line\n    col = vec3(uv.x, uv.y, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec4 s = vec4(0.0);\n    s = opS(s, sdBox(p, vec3(1.0)));\n    s = opS(s, sdSphere(p, 1.0));\n    s = opS(s, sdCylinder(p, vec2(1.0, 0.5)));\n    s = opS(s, sdCone(p, vec2(1.0, 0.5)));\n    s = opS(s, sdTorus(p, vec2(0.5, 0.1)));\n    s = opS(s, sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)));\n    s = opS(s, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.5));\n    s = opS(s, sdC", "\n    float t = length( targetPos - ray.origin );\n    float d = length( targetPos - ray.origin + ray.direction * t );\n    float f = exp( -d * d / ( lightDiameter * lightDiameter ) );\n    return f * f / ( t * t );\n}\n\n// \u5149\u6e90\nvec", "\n    vec2 d = vec2(1000.0);\n    d = opU(d, vec2(sdfSphere(p - vec3(0.0, 0.0, 0.0), 1.0), 1.0));\n    d = opU(d, vec2(sdfSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 2.0));\n    d = opU(d, vec2(sdfSphere(p - vec3(0.0, 0.0, 0.0), 0.25), 3.0));\n    return d;\n}\n\n// \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191", "\n    float i = floor(x);\n    float f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), f);\n}\n\n// 2D noise\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/", "\n    float radius = start_radius;\n    int i = 0;\n    while(radius < uv.x){\n        radius += hex_size;\n        i++;\n    }\n    return i;\n}\n\n//Find the closest hexagon to a point\nvec", "\n    float r = circumradius;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r2*r2;\n    float r5 = r4*r;\n    float r6 = r4*r2;\n    float r7 = r6*r;\n    float r8 = r6*r2;\n    float r9 = r8*r;\n    float r10 = r8*r2;\n    float r11 = r10*r;\n    float r12 = r10*r2;\n    float r13 = r12*r;\n    float r14 = r12*r2;\n    float r15 = r14*r;\n    float r16 = r14*r2;\n    float r17 = r16*r;\n    float r18 = r16*r2;\n    float r19 = r18*r;\n    float r20 = r18*r2;\n    float r21 = r20", "\n    float r = circumradius;\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r6*r2;\n    float r10 = r8*r2;\n    float r12 = r10*r2;\n    float r14 = r12*r2;\n    float r16 = r14*r2;\n    float r18 = r16*r2;\n    float r20 = r18*r2;\n    float r22 = r20*r2;\n    float r24 = r22*r2;\n    float r26 = r24*r2;\n    float r28 = r26*r2;\n    float r30 = r28*r2;\n    float r32 = r30*r2;\n    float r34 = r32*r2;\n    float r36 = r34*r2;\n    float r38 =", "\n    float L = exp(-d);\n    float k = 0.0;\n    float p = L;\n    float U1 = U.x;\n    while (U1 > p) {\n        k += 1.0;\n        p = L * d / k;\n    }\n    return k;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash2(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash3(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    // 1.0 - uv.y\n    // 0.0 - uv.x\n    // 0.0 - uv.y\n    // 1.0 - uv.x\n    // 1.0 - uv.y\n    // 0.0 - uv.x\n    // 1.0 - uv.x\n    // 1.0 - uv.y\n    // 0.0 - uv.y\n    // 0.0 - uv.x\n    // 1.0 - uv.y\n    // 1.0 - uv.x\n    // 0.0 - uv.y\n    // 0.0 - uv.x\n    // 1.0 - uv.x\n    // 1.0 - uv.y\n    // 0.0 - uv.y\n    // 0.0 - uv.x\n    // ", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 res = map(ro + rd * t);\n        float d = res.x;\n        int m = int(res.y);\n        if (d < EPS || t > MAX_DIST) break;\n        t += d;\n        if (m == SPHERE) {\n            col = vec3(1.0, 0.0, 0.0);\n        } else if (m == PLANE) {\n            col = vec3(0.0, 1.0, 0.0);\n        }\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 res = map(ro + rd * t);\n        float d = res.x;\n        int m = int(res.y);\n        if (d < EPS || t > MAX_DIST) break;\n        t += d;\n        if (m == SPHERE) {\n            col = vec3(1.0, 0.0, 0.0);\n        } else if (m == PLANE) {\n            col = vec3(0.0, 1.0, 0.0);\n        }\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3", "\n    return normalize(vec3(\n        sdf(p + vec3(EPSILON, 0.0, 0.0)) - sdf(p - vec3(EPSILON, 0.0, 0.0)),\n        sdf(p + vec3(0.0, EPSILON, 0.0)) - sdf(p - vec3(0.0, EPSILON, 0.0)),\n        sdf(p + vec3(0.0, 0.0, EPSILON)) - sdf(p - vec3(0.0, 0.0, EPSILON))\n    ));\n}\n\n/**\n * Return the color of the background.\n */\nvec", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\n// I didnt update this hash until after I styled it -_- so it stays\nfloat", "\n    if ( i == 0 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 1 ) {\n        color = vec3( 0.15, 0.15, 0.15 );\n        return true;\n    }\n    if ( i == 2 ) {\n        color = vec3( 0.3, 0.3, 0.3 );\n        return true;\n    }\n    if ( i == 3 ) {\n        color = vec3( 0.4, 0.4, 0.4 );\n        return true;\n    }\n    if ( i == 4 ) {\n        color = vec3( 0.56, 0.56, 0.56 );\n        return true;\n    }\n    if ( i == 5 ) {\n        color = vec3( 0.63, 0.63, 0.52 );\n        return true;\n    }\n    if ( i == 6", "\n    p = p / ab;\n    float k0 = length(p);\n    float k1 = k0*k0/2.0;\n    vec2  k2 = k0*p/2.0;\n    float x  = p.x*k2.x - p.y*k2.y;\n    float y  = p.x*k2.y + p.y*k2.x;\n    float z  = k1 - 1.0;\n    return vec3( sqrt(x*x+y*y)*(k0<1.0?1.0:0.0) - z, x, y );\n}\n\n//--------------------------------------------------------------------------\n// 2D distance functions\n//--------------------------------------------------------------------------\n\n// 2D distance function for a circle\nfloat", "\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  4 out, 1 in...\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec2 p = (uv - 0.5) * 2.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float f = abs(cos(a * 10.0 - iTime * 2.0) * 0.5);\n    col = vec3(1.0 - smoothstep(f, f + 0.02, r));\n    fragColor = vec4(col, 1.0);\n}", "\n    float d = -1.0;\n    for(int i = 0; i < NUM_HYPERSPHERES; i++){\n        float dist = hypersphere(raypos, hypersphere_pos[i], hypersphere_radius[i]);\n        if(dist < d || d < 0.0){\n            d = dist;\n        }\n    }\n    return d;\n}\n\n// Multiple Hyperspheres Distance Estimator\nfloat", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n    return mat3(\n        cy*cz, cy*sz*sx - cx*sz, cy*sz*cx + sx*sz,\n        sx*sy, cx*cz + sx*sy*sz, cx*sz*sy - cy*sx,\n        -sy, cy*sx + sy*sz*cx, cy*cx*sz - sx*sy\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        t += d = map4D(rayori + raydir * t);\n        if(d < EPSILON || t > MAX_DISTANCE){\n            break;\n        }\n    }\n    return vec3(t, d, 0.0);\n}\n\n// 4D Ray-Marching with Shadow\nvec", "\n    vec3 col = vec3(0.0);\n    vec3 p = vec3(uv.x, uv.y, 0.0);\n    vec3 d = vec3(0.0, 0.0, 1.0);\n    float t = 0.0;\n    float dd = 0.0;\n    for(int i = 0; i < 100; i++){\n        dd = map(p);\n        if(dd < 0.001){\n            break;\n        }\n        t += dd;\n        p += d * t;\n    }\n    if(dd < 0.001){\n        col = vec3(1.0);\n    }\n    return col;\n}\n\n// 4D Screen Output Image\nvec", "\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(rayori + raydir * t);\n        if(d < EPSILON){\n            break;\n        }\n        t += d;\n    }\n    return vec3(t, d, 0.0);\n}\n\n// 3D Normal\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a line\n    col = vec3(uv.x, uv.y, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    float x = coord.x * frequency;\n    float y = coord.y * frequency;\n    float xRate = travelRate * x;\n    float yRate = travelRate * y;\n    float xRateSin = sin(xRate);\n    float yRateSin = sin(yRate);\n    float xRateCos = cos(xRate);\n    float yRateCos = cos(yRate);\n    float xRateSinSq = xRateSin * xRateSin;\n    float yRateSinSq = yRateSin * yRateSin;\n    float xRateCosSq = xRateCos * xRateCos;\n    float yRateCosSq = yRateCos * yRateCos;\n    float xRateSinCos = xRateSin * xRateCos;\n    float yRateSinCos = yRateSin * yRateCos;\n    float xRateSinSqCosSq = xRateSinSq * xRateCosSq;\n    float yRateSinSqCosSq = yRateSinSq * yRateCosSq;", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------", "\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec2(p1.x, p2.y);\n    e3 = p2 - vec2(p2.x, p1.y);\n    e4 = p2 - vec2(p1.x, p1.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    vec3 p1 = p - d;\n    vec3 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec3(p1.x, p2.y, p1.z);\n    e3 = p2 - vec3", "\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_texCoord).rgb;\n    color = filmic(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    outColor = vec4(color, 1.0);\n}\n", "\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h ) - w1;\n    float t = w2/length(ba);\n    return min( d, abs(h-1.0)*t );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y,uv.x);\n    float r = length(p);\n    float f = abs(cos(a*3.0-r*10.0));\n    col = vec3(1.0-smoothstep(0.0,f,d));\n    return col;\n}\n\n/////////////////////////////////////////////////////////////\n// 2D rotation formula\n// From: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat", "\n    return vec3( 1.0 ) - smoothstep( falloff, falloff + 0.02, rnd.y );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  4 out, 1 in...\nvec", "\n    float x2 = x * x;\n    return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    col = col * (0.69470171 + col * (0.2362743 + col * (0.04757511)));\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec", "\n    p = abs(p) - vec3(1.0);\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n/* \u4e00\u4e2a\u7403\u4f53\u7684SDF */\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a circle\n    float radius = iMouse.x / iResolution.x;\n    float dist = distance(uv, vec2(0.5, 0.5));\n    float brightness = (radius - dist) * 10.0;\n    col = vec3(brightness);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"]}