{"id": "X3dXDf", "name": "Laetro: L Logo Mark", "author": "farhankk360", "description": "fun little pulsing logo mark with tunnel effect.\nClick and drag to see the parallax", "tags": ["logo", "shape", "laetro"], "likes": 1, "viewed": 63, "published": 3, "date": "1719778089", "time_retrieved": "2024-07-07T01:17:28.048804", "image_code": "// Created using Shadertoy-SVG: https://zduny.github.io/shadertoy-svg/\n// For better performance, consider using buffers, see example: https://www.shadertoy.com/view/7lKGzR\n\nconst vec3 positions[51] = vec3[51](vec3(0.8829233431174539, 0.5454545454545455, 0), vec3(0.8441158483331854, 0.5454545454545455, 0), vec3(0.7241161368075284, 0.5454545454545455, 0), vec3(0.47609505282315356, 0.5454545454545455, 0), vec3(0.1656350945490055, 0.5454545454545455, 0), vec3(-0.16563782182173292, 0.5454545454545455, 0), vec3(-0.47609778009588066, 0.5454545454545455, 0), vec3(-0.7241188640802556, 0.5454545454545455, 0), vec3(-0.8441185756059126, 0.5454545454545455, 0), vec3(-0.8829260703901811, 0.5454545454545455, 0), vec3(-0.9107768465909091, 0.5428866700994318, 0), vec3(-0.9509176136363636, 0.5238813824573864, 0), vec3(-0.9810486079545454, 0.4898005237926137, 0), vec3(-0.997751875, 0.44474466796875, 0), vec3(-1, 0.41174425000000003, 0), vec3(-1, 0.37813575, 0), vec3(-0.9944559832208807, 0.21944258256392044, 0), vec3(-0.9648730510364879, 0.025343474720348015, 0), vec3(-0.9305281037486683, -0.0839614174582742, 0), vec3(-0.8841287188720703, -0.17843946215820308, 0), vec3(-0.8253697161865234, -0.2591610276322798, 0), vec3(-0.7539459154718573, -0.3271964821333451, 0), vec3(-0.6695521365079014, -0.38361619391424, 0), vec3(-0.5179751771129262, -0.44880767453835224, 0), vec3(-0.26762929199218743, -0.5050646528764206, 0), vec3(0.040089750088778464, -0.5341252888849434, 0), vec3(0.40762339089133515, -0.5445525285866477, 0), vec3(0.6910805113636365, -0.5454143465909093, 0), vec3(0.8313828977272728, -0.5443691761363636, 0), vec3(0.9150191051136365, -0.5406656924715909, 0), vec3(0.9533362926136362, -0.5242935262784091, 0), vec3(0.9820108664772729, -0.49501667258522747, 0), vec3(0.9978689630681821, -0.4564533700284092, 0), vec3(1, -0.4252269050071023, 0), vec3(1, -0.35598978462357966, 0), vec3(1, -0.1645449758522728, 0), vec3(1, 0.1491075213068182, 0), vec3(1, 0.340552330078125, 0), vec3(1, 0.4097894504616477, 0), vec3(0.9977521306818182, 0.44474466796875, 0), vec3(0.9810501420454545, 0.4898005237926137, 0), vec3(0.9509197443181818, 0.5238813824573864, 0), vec3(0.910776846590909, 0.5428866700994318, 0), vec3(-1, 0.3704974545454545, 0), vec3(-1, 0.41938254545454545, 0), vec3(-0.888020909090909, 0.5454545454545455, 0), vec3(0.6145836363636363, -0.5454545454545455, 0), vec3(0.8880181818181818, 0.5454545454545455, 0), vec3(0.8932363636363636, -0.5428818181818181, 0), vec3(1, 0.41938254545454545, 0), vec3(1, -0.4348200000000001, 0));\nconst ivec3 triangles[49] = ivec3[49](ivec3(0, 38, 1), ivec3(0, 39, 49), ivec3(0, 40, 39), ivec3(0, 47, 40), ivec3(0, 49, 38), ivec3(1, 37, 2), ivec3(1, 38, 37), ivec3(2, 36, 3), ivec3(2, 37, 36), ivec3(3, 26, 4), ivec3(3, 36, 26), ivec3(4, 25, 5), ivec3(4, 26, 25), ivec3(5, 23, 6), ivec3(5, 24, 23), ivec3(5, 25, 24), ivec3(6, 17, 7), ivec3(6, 18, 17), ivec3(6, 19, 18), ivec3(6, 20, 19), ivec3(6, 21, 20), ivec3(6, 22, 21), ivec3(6, 23, 22), ivec3(7, 16, 43), ivec3(7, 17, 16), ivec3(7, 43, 8), ivec3(8, 14, 9), ivec3(8, 15, 14), ivec3(8, 43, 15), ivec3(9, 12, 45), ivec3(9, 13, 12), ivec3(9, 14, 44), ivec3(9, 44, 13), ivec3(10, 45, 11), ivec3(11, 45, 12), ivec3(26, 35, 46), ivec3(26, 36, 35), ivec3(27, 34, 28), ivec3(27, 35, 34), ivec3(27, 46, 35), ivec3(28, 33, 48), ivec3(28, 34, 33), ivec3(29, 48, 30), ivec3(30, 48, 31), ivec3(31, 48, 32), ivec3(32, 48, 50), ivec3(33, 50, 48), ivec3(40, 47, 41), ivec3(41, 47, 42));\nconst int len = 49;\n\nbool sameSide( vec3 p1, vec3 p2, vec3 a, vec3 b ) {\n    vec3 cp1 = cross(b-a, p1-a);\n    vec3 cp2 = cross(b-a, p2-a);\n      \n    return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle( vec3 p, vec3 a, vec3 b, vec3 c ) {\n    return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nbool inPath( vec2 p ) {\n    for (int i=0; i<len; i++) {\n        ivec3 triangle = triangles[i];\n        vec3 a = positions[triangle[0]];\n        vec3 b = positions[triangle[1]];\n        vec3 c = positions[triangle[2]];\n  \n        if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n            return true;\n        }\n    }\n  \n    return false;\n}\n      \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 2.0;\n    uv -= vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.4;\n\n    // Define color sets\n    vec3 fillColors[3] = vec3[3](\n        vec3(0.886, 0.969, 0.925), // #E2F7EC\n        vec3(0.761, 0.902, 0.965), // #C2E6F6\n        vec3(0.635, 0.855, 0.416)  // #A2DA6A\n    );\n    vec3 shadowColors[3] = vec3[3](\n        vec3(0.635, 0.855, 0.416), // #A2DA6A\n        vec3(0.184, 0.463, 1.000), // #2f76ff (alpha ignored)\n        vec3(0.129, 0.769, 0.424)  // #21C46C\n    );\n\n    // Calculate color cycle\n    float cycleTime = mod(iTime, 9.0); // 9 seconds for a full cycle (3 colors * 5 seconds each)\n    int colorIndex = int(cycleTime / 3.0);\n    float colorTransition = fract(cycleTime / 3.0);\n\n    // Initial desired shape dimensions in pixels\n    float initialWidth = 860.0;\n    float initialHeight = 460.0;\n\n    // Maximum number of shapes\n    int maxShapes = 8; // Adjust this number to add more or fewer shapes\n\n    // Pulsing effect\n    float pulseSpeed = 2.0;\n    float pulse = 0.5 + 0.5 * sin(iTime * pulseSpeed);\n\n    for (int i = 0; i < maxShapes; i++) {         \n        // Calculate parallax factor (1.0 for innermost shape, 0.0 for outermost)\n        float parallaxFactor = 1.0 - float(i) / float(maxShapes - 1);\n        \n        // Calculate center with parallax effect\n        vec2 center = mouse * parallaxFactor;\n\n        // Calculate scaling factors for the current shape\n        float scaleX = initialWidth / iResolution.x;\n        float scaleY = initialHeight / iResolution.y;\n\n        // Apply pulsing effect to shape size\n        float pulseFactor = 1.0 + 0.1 * pulse * (1.0 - parallaxFactor);\n        scaleX *= pulseFactor;\n        scaleY *= pulseFactor;\n\n        // Scale UV coordinates\n        vec2 scaledUV = uv - center;\n        scaledUV.x /= scaleX;\n        scaledUV.y /= scaleY;\n\n        // Check if the point is within the current shape\n        if (inPath(scaledUV)) {\n            // Calculate distance from the edge for shadow effect\n            float distFromEdge = 1.2 - length(scaledUV);\n            float shadowStrength = smoothstep(0.0, 1.0, distFromEdge);\n            \n            // Calculate color transition for this shape\n            float shapeTransition = clamp(colorTransition * float(maxShapes) - float(i), 0.0, 1.0);\n            int nextColorIndex = (colorIndex + 1) % 3;\n            \n            vec3 currentFillColor = mix(fillColors[colorIndex], fillColors[nextColorIndex], shapeTransition);\n            vec3 currentShadowColor = mix(shadowColors[colorIndex], shadowColors[nextColorIndex], shapeTransition);\n            \n            // Apply pulsing effect to colors\n            currentFillColor = mix(currentFillColor, vec3(1.0), 0.2 * pulse);\n            currentShadowColor = mix(currentShadowColor, vec3(0.0), 0.2 * pulse);\n            \n            // Mix fill color with shadow color\n            vec3 finalColor = mix(currentShadowColor, currentFillColor, shadowStrength);\n            \n            // Apply overall pulsing effect\n            finalColor *= 0.8 + 0.2 * pulse;\n            \n            fragColor = vec4(finalColor, 1.0);\n            return;\n        }\n\n        // Scale up for the next shape\n        initialWidth *= 1.4;\n        initialHeight *= 1.4;\n    }\n    \n    // Background color\n    fragColor = vec4(vec3(0.0), 1.0);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3dXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 3492, 3543, 3543, 3651], [3653, 3653, 3709, 3709, 3792], [3794, 3794, 3817, 3817, 4132], [4140, 4140, 4195, 4195, 7729]], "test": "valid"}
{"id": "lXdXWX", "name": "Oren-Nayar Sphere", "author": "ArolaunTech", "description": "A sphere render. Use the mouse to change the roughness parameter.", "tags": ["sphere", "rendering", "diffuse"], "likes": 1, "viewed": 63, "published": 3, "date": "1719775178", "time_retrieved": "2024-07-07T01:17:28.934462", "image_code": "#define pi 3.14159\n\nfloat gamma(float brightness) {\n    float result = 1.055 * pow(brightness, 5.0/12.0) - 0.055;\n    if (brightness < 0.0031308) {\n        result = 12.92 * brightness;\n    }\n    if (brightness < 0.0) {\n        result = 0.0;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Sphere settings\n    float sphereRadius = 1.5;\n    vec3 sphereCenter = vec3(0.0, 0.0, 3.0);\n    float roughness = 2.0*iMouse.x/iResolution.x;\n    \n    //Lighting settings\n    //vec3 lightDirection = normalize(vec3(cos(iTime), 0.0, sin(iTime)));\n    vec3 lightDirection = vec3(1.0, 0.0, 0.0);\n\n    //Calculate direction vector\n    float m = iResolution.y;\n    vec2 uv = vec2(fragCoord.x-.5*(iResolution.x - m), fragCoord.y)/m;\n    vec2 xy = 2.0 * uv - 1.0;\n    \n    vec3 D = normalize(vec3(xy, 1.0));\n    \n    //Sphere intersection\n    float tca = dot(D, sphereCenter);\n    float d = sqrt(dot(sphereCenter, sphereCenter) - tca * tca);\n    float thc = sqrt(sphereRadius * sphereRadius - d * d);\n    float dist = tca - thc;\n    \n    //Normal vector\n    vec3 normal = normalize(D * dist - sphereCenter);\n    \n    //Calculate angles\n    float roughSquare = roughness*roughness;\n    \n    vec3 tangentLight = normalize(cross(normal, cross(lightDirection, normal)));\n    vec3 tangentView = normalize(cross(normal, cross(-D, normal)));\n    float cosDiff = dot(tangentLight, tangentView);\n    \n    float cosThetaLight = dot(normal, lightDirection);\n    float cosThetaView = dot(normal, -D);\n    \n    float thetaLight = acos(abs(cosThetaLight));\n    float thetaView = acos(abs(cosThetaView));\n    \n    float alpha = max(thetaLight, thetaView);\n    float beta = min(thetaLight, thetaView);\n    \n    float c1 = 1.0 - 0.5 * roughness*roughness/(roughness*roughness + 0.33);\n    float c2Mult = sin(alpha);\n    if (cosDiff < 0.0) {\n        c2Mult -= pow(2.0*beta/pi,3.0);\n    }\n    float c2 = 0.45 * roughSquare/(roughSquare + 0.09) * c2Mult;\n    float c3 = 0.125 * roughSquare * pow(4.0*thetaLight*thetaView/(pi*pi),2.0)/(roughSquare + 0.09);\n    \n    float l1 = 1.0 * cosThetaLight * (c1 + c2*cosDiff*tan(beta) + c3*(1.0-abs(cosDiff))*tan(0.5*(alpha+beta)));\n    float l2 = 0.17 * cosThetaLight * roughSquare * (1.0 - cosDiff*pow(2.0*beta/pi,2.0))/(roughSquare+0.13);\n   \n    //Lighting calculations\n    //float lighting = dot(normal, lightDirection); //Lambertian diffuse\n    float lighting = l1 + l2; //Oren-Nayar reflection model\n    //float lighting = cosThetaLight/(cosThetaLight + cosThetaView); //Lommel-Seeliger law? idk\n    \n    if (dot(normal, lightDirection) < 0.0) {\n        lighting = 0.0;\n    }\n    \n    //Aesthetics\n    lighting = mix(lighting, 1.0, 0.003);\n\n    // Output to screen\n    fragColor = vec4(vec3(gamma(lighting)), 1.0);\n    if (tca < 0.0) {\n        fragColor = vec4(0.0);\n    }\n    if (d > sphereRadius) {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lXdXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 267], [269, 269, 326, 348, 2890]], "test": "valid"}
{"id": "l3cXWs", "name": "eating cosmos", "author": "nayk", "description": "originals  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/mtyGWy https://glslsandbox.com/e#51003.0", "tags": ["fractal", "color", "stars", "neon", "cineshader"], "likes": 4, "viewed": 93, "published": 3, "date": "1719771371", "time_retrieved": "2024-07-07T01:17:29.811131", "image_code": "\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define time iTime\n\nfloat sphere(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat box(vec2 p, vec2 s) {\n\tp = abs(p) - s;\n\treturn length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\nvec2 translate(vec2 p, vec2 o) {\n\treturn p - o;\n}\n\nmat2 rotate(float r) {\n\tfloat c = cos(r);\n\tfloat s = sin(r);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 foldX(vec2 p) {\n\tp.x = abs(p.x);\n\treturn p;\n}\n\nvec2 foldY(vec2 p) {\n\tp.y = abs(p.y);\n\treturn p;\n}\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n  \n\tuv.y*=iResolution.y/iResolution.x;\n    vec3 dir=vec3(uv*zoom,1.);\n    vec3 from=vec3(1.,.5,0.5);\n    float s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*= rotate(0.1 * time);// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    \tvec4 fragColor2 = vec4(v*.03,1.);\t\n    vec3 finalColor = vec3(0.0);\n    vec2 p = uv;\n\t\n\tfloat d = 9999.0;\n\tfloat size = 0.1;\n\t\n\tfor (int i = 0; i < 17; i++) { \n\t\tp *= rotate(0.1 * time);\n\t\tp = foldX(p);\n\t\tp = foldY(p);\n\t\tp = translate(p, vec2(0.2, 0.2));\n\t\td = min(d, box(p * rotate(3.1 * time * float(i)), vec2(size)));\n\t\tsize *= 0.75;\n\t}\n\t\n\t\n\n\n\tvec3 c = vec3(1.0) * smoothstep(0.0, 0.01, abs(d));\n  \n    for (float i = 0.0; i < 4.0; i++) {\n      uv*= rotate(0.5 * time);\n      uv*= translate(p, uv*c.xy);\n        uv = fract(uv+p * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d*c*fragColor2.xyz;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/l3cXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 210], [299, 299, 330, 330, 355], [357, 357, 384, 384, 458], [460, 460, 492, 492, 509], [511, 511, 533, 533, 600], [602, 602, 622, 622, 652], [654, 654, 674, 674, 704], [965, 965, 1022, 1022, 2817]], "test": "error"}
{"id": "MXcSWs", "name": "happy star 3", "author": "nayk", "description": "originals https://glslsandbox.com/e#64038.0  https://www.shadertoy.com/view/4tyfWy", "tags": ["fractal", "star", "cineshader"], "likes": 3, "viewed": 65, "published": 3, "date": "1719770262", "time_retrieved": "2024-07-07T01:17:30.725201", "image_code": "\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define PI 3.141592 \n#define time iTime*0.\n#define time2 iTime\n#define resolution iResolution.xy\nmat2 rotate(float a) {\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nconst float pi = radians(180.0);\n\nfloat hash21(in vec2 st)\n{\n\treturn fract(sin(dot(st, vec2(235.214, 123.124)))*23526.235);\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nfloat atan2(vec2 u){return atan(u.x,u.y);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n\tfloat s=exp2((time));\n    vec2 p = (gl_FragCoord.xy - 0.5*resolution.xy) / resolution.y;\n\tvec2 grid_id = floor(p * 10.0);\n\t\n\t// Polar coordinates\n\tfloat angle = atan(p.y + \n\t\t\t   0.02, p.x);\n\tfloat radius = length(p) + sin(2.0 * cos(angle*5.0 + time2))*0.1;\n\t\n\tfloat dif = abs(cos(angle*floor(hash21(grid_id)) + time2))*0.04 / abs(radius*0.6 - 0.2);\n\tvec3 color = vec3(dif);\n\tuv*=s*color.xy;\n\tfloat c=7.; //Count\n\tfloat r=exp2(floor(log2(length(uv))-(1./c))-1.);\n\tfloat d=r/sin(PI/c); //Space distance\n\tfloat a=(atan2(rotate(PI/2.)*uv)+PI)/(PI*2.);\n\ta=floor(fract(a+(.5/c))*c)/c;\n\tvec2 uv2=uv*rotate(a*PI*2.);\n\tfloat b=length(uv2-vec2(d,0));\n\tfloat v = (b-r)*(200./s);\n\tfragColor = vec4(vec3(v)+color.xyz,1.);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,1.15)*0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MXcSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 166, 166, 215], [250, 250, 276, 276, 341], [342, 342, 381, 381, 527], [528, 528, 548, 548, 570], [571, 571, 628, 628, 1620]], "test": "error"}
{"id": "XXtSWN", "name": "Computer inside", "author": "devlop", "description": "d", "tags": ["d"], "likes": 0, "viewed": 60, "published": 3, "date": "1719757772", "time_retrieved": "2024-07-07T01:17:31.640258", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resolution = vec2(1920.0, 1080.0);\n    float time = iTime;\n    vec2 playerPos = vec2(0.0);\n    vec2 uv = fragCoord.xy / resolution.xy;\n    uv.y = 1.0 - uv.y;\n    float uv_x = (uv.x * 2.0 - 1.0);\n    float uv_y = (uv.y * 2.0 - 1.0);\n    float r = -0.5 + 0.5 * cos(-time - time + uv_x * 200.0 * 1e-03 * 5.0 + -uv_y * 2.0 * 10.0 + 4.0);\n    float g = 0.5 + -0.5 * cos(time - -time + uv_y * 200.0 * 1e-03 * 5.0 + -uv_x * 2.0 * 10.0 + 4.0) * 3.0;\n    float b = -0.5 + 0.5 * cos(-time - time + -uv_y * 200.0 * 1e-03 * 5.0 + uv_x * 2.0 * 10.0 + 4.0);\n    fragColor = vec4(-r, -b, -g, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXtSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 649]], "test": "valid"}
{"id": "4XcXDl", "name": "mandelbrotus line", "author": "nayk", "description": "originals source https://glslsandbox.com/e#68373.0 https://glslsandbox.com/e#68373.0", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 66, "published": 3, "date": "1719745766", "time_retrieved": "2024-07-07T01:17:32.495985", "image_code": "\n\n#define PI 3.141592653\n#define TWO_PI 2.0*PI\n#define t time*0.3\n#define MAX 30.\n#define time iTime\n#define resolution iResolution.xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// vec2 uv = surfacePosition;\n\tvec2 uv = (gl_FragCoord.xy - resolution * 0.5) / max(resolution.x, resolution.y) * 4.0;\n\tuv *= 1.0;\n\n\t\tfloat t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n \n\tvec2 z = uv;\n\tfloat e = 0.0;\n\tfor (float i=0.0;i<=100.0;i+=1.0) {\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.y * z.x)+ z*cos(t)+uv*sin(t);\t\t\n\t\tif (length(z) > 2.0) break;\n\t\te += 0.005/abs(i*z.y + sin(time + i*z.y));\n\t}\n\t\nfragColor = vec4(vec3(e), 3.0);\t\nvec2 position =uv;\n\tvec2 mid = vec2(resolution.x/2.0, resolution.y/2.0);\n\tfloat distance = sqrt(pow(gl_FragCoord.x-mid.x,2.0) + pow(gl_FragCoord.y - mid.y,2.0))*.03;\n\tfragColor*= vec4( vec3( 10.0/distance, 100.0/distance, 600.0/distance)*vec3(10.,0.5,0.5)*0.1, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4XcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 191, 222, 1013]], "test": "valid"}
{"id": "XXcXDl", "name": "Kaleidoscope psy ", "author": "nayk", "description": "original source https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/wtdfRX https://www.shadertoy.com/view/4XtXDf", "tags": ["fractal", "cineshader"], "likes": 5, "viewed": 87, "published": 3, "date": "1719745010", "time_retrieved": "2024-07-07T01:17:33.342738", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 uv = ( C - .5*iResolution.xy ) / iResolution.y;\n     vec3 screenRes = iResolution;\n\n    // Position vector\n    vec3 o;\n\n    // Current time\n    float time = iTime;\nvec4  finalImage = O;\nvec2 texCoords = C;\n    // Spiral pattern control variables\n    float spiralFactor = 0.1;\n    float scale = 3.0;\n    float brightness = 2.0;\n    float maxExponent = 25.0;\n    float angleOffset = 0.314;\n    float modulationFactor = 0.1;\n    float fractOffset = 0.5;\n    float vectorScale = 1000.0;\n    vec4 rotationConstants = vec4(0.0, 11.0, 33.0, 0.0);\n    vec3 color1 = vec3(0.84, 0.74, 0.87);\n    vec3 color2 = vec3(0.9, 0.9, 0.6);\n\n    // Loop through exponent values\n    for (float exponent = 0.0; exponent < maxExponent; exponent++) {\n\n        // Modulus operation for z to create layers\n        o.z = mod(o.z, modulationFactor) - modulationFactor;\n\n        // Update x based on time and scale\n        float x = spiralFactor - time * scale;\n\n        // Transform the o.xy vector using rotation matrix\n        vec2 transformedVector = o.xy *= mat2(\n            cos(rotationConstants + round((atan(o.y, o.x) - x) / angleOffset) * angleOffset + x)\n        );\n        o.x = fract(transformedVector.x) - fractOffset;\n\n        // Calculate length of the vector\n        float vectorLength = length(o);\n\n        // Increment spiral factor\n        float timeScaleIncrement = vectorLength / scale;\n        spiralFactor += timeScaleIncrement;\n\n        // Calculate cosine and sine for color manipulation\n        float cosValue = cos(spiralFactor + time * scale);\n        float sinValue = sin(spiralFactor + time * scale);\n\n        // Color mask calculation\n        float colourMask = clamp(cos(time * scale) + sin(time * scale), 0.0, 1.0);\n\n        // Add to final image using brightness and vector length\n        finalImage += (brightness + cosValue) * (brightness + sinValue) / (vectorLength * vectorScale);\n\n        // Normalize and scale the position vector\n        o = spiralFactor * normalize(\n            vec3((texCoords + texCoords - screenRes.xy) * mat2(cos(rotationConstants + time * scale)), screenRes.y)\n        );\n\n        // Clamp final image values\n        finalImage = clamp(finalImage, 0.0, 1.0);\n\n        // Define two colors for mixing\n        vec3 mixedColor1 = finalImage.xyz * color1;\n        vec3 mixedColor2 = finalImage.xyz * color2;\n          finalImage = vec4(mix(mixedColor1, mixedColor2, colourMask), 0.0);\n         }\n         vec4 O2 = finalImage ;\n    vec3 r=iResolution,p;  \n  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        (e<.002)?O.xyz+=mix(r/r,H(log(s)*.25),.5)*1./i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n      \n        p=R(p,normalize(vec3(0,1.2,1.2)),3.15);\n\n        p.xz=abs(p.xz)-1.+cos(iTime);\n        p.x>p.z?p=p.zyx:p;\n         p.z<p.x?p=p.yzx:p;\n        s=2.;\n        for(int j=0;j++<7;)\n          \n            s*=e=3.7/clamp(dot(p,p),0.,5.+0.1*cos(iTime)),\n            p=abs(p)*e-vec3(1,1.+0.1*cos(iTime),.003);\n        g+=e=length(p.xz)/s;\n    \n    \n    \n    }\n    O+=O2;\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.25)*5., 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 141, 141, 287], [290, 290, 326, 326, 3564]], "test": "error"}
{"id": "MXdXWX", "name": "Byt3-daily-004", "author": "byt3_m3chanic", "description": "Making it 3D now, using the timing lerp to flip and raise the boxes. \n4 tap map loop from @Shane", "tags": ["raymarching", "cube", "reflections", "lerp"], "likes": 21, "viewed": 175, "published": 3, "date": "1719713578", "time_retrieved": "2024-07-07T01:17:34.217987", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Making it 3D now, using the timing lerp to flip and raise the boxes.\n    \n    4 tap map loop from @Shane\n    \n    Byt3-daily-004\n    06/29/2024  @byt3_m3chanic\n    \n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.141592653\n#define PI2 6.283185307\n\n#define MIN_DIST 1e-3\n#define MAX_DIST 40.\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e - b), 0., 1.); }\nfloat eoc(float t) { return t = --t * t * t + 1.; }\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),.0);\n}\n\n//globals\nvec3 s_hit, g_hit;\nvec2 s_id, g_id;\nmat2 mx, my;\n\n//scales for all things\nconst float scale = 1./.5;\nconst float scale_h = scale*.5;\nconst vec2 s = vec2(scale)*2.;\n\n//positions and rotations\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\n\n// block map -v4 tap technique from @Shane\nvec2 map(vec3 q3){\n\n    vec2 res = vec2(1e5,0.);\n    vec2 p,ip,id = vec2(0),ct = vec2(0);\n\n    float t=1e5, y=1e5, m=1.;\n\n    for(int i =0; i<4; i++){\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\n        vec2 idi = (ip + ct)*s;\n \n        float rnd = mod(idi.x,10.); \n              rnd+=(mod(idi.y,10.)*10.)*.15;\n        float tmod = mod(T, 24.); \n\n        //movement\n        float t3 = lsp(rnd, rnd+1., tmod);\n        t3 = eoc(t3); t3 = t3*t3*t3;\n        float t4 = lsp(rnd+1., rnd+2., tmod);\n        t4 = eoc(t4); t4 = t4*t4*t4;\n        float t5 = lsp(rnd+2., rnd+3., tmod);\n        t5 = eoc(t5); t5 = t5*t5*t5;\n        float t6 = lsp(rnd+3., rnd+4., tmod);\n        t6 = eoc(t6); t6 = t6*t6*t6;\n            \n        float xx = scale*(t3-t5);  \n        float yy = scale*(t4-t6); \n\n        vec3 q = vec3(p.x,q3.y-yy-xx,p.y);\n        mat2 rmx=rot((t3-t5)*PI);\n        mat2 rmy=rot((t4-t6)*PI);\n        \n        q.xy*=rmx;\n        q.zy*=rmy;\n\n        float b = box(q,vec3(scale*.385))-.065;\n        if(b<t ) {\n            t = b;\n            m = mod(float(i),2.)<1.? 5.:4.;\n            s_id = idi;\n            s_hit = q+(idi.xyx*vec3(.25)+float(i));\n            mx=rmx;\n            my=rmy;\n        }\n    }\n    \n\tif(t<res.x) res = vec2(t,m);\n\n    float f = q3.y+1.5;\n    if (f<res.x) {\n        res = vec2(f,2.);\n        s_hit = q3;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 FC = vec4(.17,.14,.11,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    // marcher\n    for(int i=0;i<132;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.25: ray.x*.75;\n        m  = ray.y;\n    } \n    g_hit = s_hit;\n    g_id = s_id;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-5,8,0);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        \n        int face;\n        vec3 cuv = s_hit;\n           \n        if(m>2.) {\n            // quick find the correct face with normal\n            vec3 tn = n;\n            tn.xy*=mx;\n            tn.zy*=my;\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n\n            if(face==0||face==5) cuv = s_hit.yzx;\n            if(face==1||face==4) cuv = s_hit.xzy+vec3(.5);\n            if(face==2||face==3) cuv = s_hit.xyz-vec3(.5);\n        }\n        \n        vec3 h = vec3(.15);\n\n        if( m==5.) {\n            h = texture(iChannel0,cuv.xy).rgb*vec3(.9,.4,.1);\n            ref = h;\n        }\n        if( m==4.) {\n            h = texture(iChannel1,cuv.xy*.25).rgb;\n            ref = h;\n        }\n        \n        if( m==2.) {\n            vec2 uv = fract(g_hit.xz*3.)-.5;\n            if(uv.x*uv.y>0.) h = vec3(.4);\n            ref=h;\n        }\n\n        float shdw = 1.;\n        for( float t=.01; t < 10.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>18. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = .5 * pow(max(dot(normalize(p-ro), ret), 0.), 14.);\n\n        C = h*diff+min(spec,shdw);\n        if(last) C = mix(FC.rgb,C,  exp(-.0025*d*d*d));\n    \n        ro = p+n*1e-3;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //ray origin - direction\n    vec3 ro = vec3(0,0,12);\n    vec3 rd = normalize(vec3(uv, -1));\n\n    // mouse //\n    float x = M.xy==vec2(0)||M.z<0. ? .1+.08*sin(T*.35) : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0)||M.z<0. ? .1*cos(T*.15) : -(M.x/R.x*2.-1.)*PI;\n    \n    mat2 rx =rot(-.92+x);\n    mat2 ry =rot(.78+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n   \n    ro.z+=T;\n\n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d = 0.,a = 0.;\n\n    float numBounces = 2.;//3 ok on 4090 - slower on mac m3\n    \n    for(float i=0.; i<numBounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = d;\n    }\n\n    C = mix(FC.rgb,C,  exp(-.0002*a*a*a));\n    O = vec4(pow(C, vec3(.4545)),1);\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MXdXWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[0, 422, 441, 441, 486], [487, 487, 525, 525, 568], [569, 569, 589, 589, 620], [622, 622, 648, 648, 733], [1026, 1069, 1087, 1087, 2498], [2500, 2500, 2530, 2530, 2769], [2804, 2804, 2889, 2889, 5008], [5010, 5010, 5051, 5051, 5918]], "test": "error"}
{"id": "X3tXWX", "name": "Pong", "author": "BJ", "description": "This is my first shader here, i have used c++ in the past but i dont have any experience with shaders but i was inspired by a video i saw by kishimisu.\n\nA shader inspiered by the game pong.", "tags": ["animation", "pong", "neon", "relaxing"], "likes": 3, "viewed": 69, "published": 3, "date": "1719711876", "time_retrieved": "2024-07-07T01:17:35.161476", "image_code": "const float pi = 3.14159;\n\n// makes a triangle function which basicly just goes from -1 to 1 and then back to -1 forever in a loop.\nfloat TriangleWaveFunction(float x)\n    {\n        return (acos(cos(x*pi))/pi -0.5)*2.0;\n    }\n\n// a sine wave modified to have the same peaks as the triangle wave.\nfloat SineWave(float x)\n    {\n        return sin(x * pi + (pi/2.0)*3.0);\n    }\n\nfloat dist(vec2 Ball, vec2 PixelCord) \n    {\n        return sqrt(pow(Ball.x - PixelCord.x, 2.0) + pow(Ball.y - PixelCord.y, 2.0));\n    }\n\n// this sdf was made by iq, not me.\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv*= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 BallPos = vec2(TriangleWaveFunction(iTime)*1.4, TriangleWaveFunction(iTime)*0.6*-1.0);\n    float BallFace = step(dist(BallPos, uv),0.1);\n    \n    float RacketOffsetX = 1.6;\n    vec2 RacketPosY = vec2(SineWave(iTime), 0.5);\n    float RacketWidth = 0.005;\n    float RacketHeight = 0.25;\n    \n    float RacketFaceLeft = sdBox(vec2(uv.x+RacketOffsetX, uv.y +SineWave(iTime)*0.6), vec2(RacketWidth, RacketHeight));\n    float RacketFaceRight = sdBox(vec2(uv.x-RacketOffsetX, uv.y +SineWave(iTime*2.0)*0.6*-1.0), vec2(RacketWidth, RacketHeight));\n\n    float RacketFace = max(step(RacketFaceLeft, 0.1),step(RacketFaceRight, 0.1));\n    // Time varying pixel color\n    vec3 ColVaraity = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(step(0.0, uv.x)*(uv.x+0.2), 0.0, step(uv.x, 0.0)*(abs(uv.x)+0.2));\n    \n    col += ColVaraity*0.5;\n    float GlobalFaces = max(BallFace, RacketFace);\n    \n    col *= GlobalFaces;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3tXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 132, 173, 173, 225], [227, 296, 325, 325, 374], [376, 376, 420, 420, 512], [514, 550, 587, 587, 667], [673, 673, 730, 758, 1859]], "test": "valid"}
{"id": "l3dSWX", "name": "weird realtime shadows experimen", "author": "andylovescode", "description": "like google material design or something", "tags": ["shadow"], "likes": 0, "viewed": 99, "published": 3, "date": "1719707837", "time_retrieved": "2024-07-07T01:17:36.066076", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float light_height = texture(iChannel0,uv).x;\n    float texture_height = texture(iChannel1, uv).x;\n    \n    float light = 1.0 - (light_height - texture_height) * 0.5;\n    \n    //light = light_height;\n    //light = texture_height;\n    \n    vec3 surfaceColor = vec3(158. / 255., 169. / 255., 255. / 255.);\n    \n    surfaceColor += (1. - surfaceColor) * texture_height;\n        \n    surfaceColor = surfaceColor * light;\n    \n    fragColor = vec4(surfaceColor, 1.);\n    \n    //fragColor = vec4(light, light, light, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float light(vec2 fragCoord, float texture_height, vec2 dir, float slope) {\n    float rate = 1.;\n    float light_height = texture(iChannel0, (fragCoord - dir * rate) / iResolution.xy).x - slope * rate;\n\n    if (light_height > texture_height) {\n        texture_height = light_height;\n    }\n    \n    return texture_height;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float texture_height = texture(iChannel1, uv).x;\n    \n    texture_height = light(fragCoord, texture_height, vec2(1., -1.), 0.05);\n\n    // Mouse light\n    //texture_height = light(fragCoord, texture_height, normalize(fragCoord - iMouse.xy), 0.05);\n    \n    // Fake AO hack\n    float around_depth = 0.3;\n\n    texture_height = light(fragCoord, texture_height, vec2(-1., 0.), around_depth);\n    texture_height = light(fragCoord, texture_height, vec2(0., 1.), around_depth);\n    texture_height = light(fragCoord, texture_height, vec2(1., 0.), around_depth);\n    texture_height = light(fragCoord, texture_height, vec2(0., -1.), around_depth);\n        \n    fragColor = vec4(texture_height, 0., 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float height = 0.;\n    \n    float time = iTime;\n    \n    vec2 coord = ((fragCoord) / 50.0) + time;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    height = round(uv.y * 2.) / 4.;\n    \n    if (sin(coord.x) * sin(coord.y) > 0.4) {\n        height = 1.;\n    }\n    \n    vec2 from_center = fragCoord - (iResolution.xy / 2.);\n    float dist = distance(from_center, vec2(0.));\n    \n    if (dist > 100. && dist < 200.) {\n        //height = 0.;\n    } else {\n        //height = 1.;\n    }\n    \n    if (texture(iChannel0, fragCoord / iResolution.xy).z > iMouse.y / iResolution.y) {\n        height = 1.;\n    } else {\n        height = 0.;\n    }\n    \n    fragColor = vec4(height,height,height,1.);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/l3dSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 619]], "test": "error"}
{"id": "X3dSDf", "name": "iterative shadows", "author": "andylovescode", "description": "simple algorithm", "tags": ["shadow"], "likes": 10, "viewed": 120, "published": 3, "date": "1719707830", "time_retrieved": "2024-07-07T01:17:36.980630", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec4 c_empty = vec4(0.);\n    vec4 c_wall = vec4(1.);\n    vec4 c_origin = vec4(1., 0., 0., 0.);\n    vec4 c_light = vec4(0., 0., 1., 0.);\n\n    vec2 fixed_pos = (iResolution.xy * vec2(0.5));\n    vec2 fixed_ofst = fragCoord - fixed_pos;\n\n    vec2 origin = (iResolution.xy * vec2(0.5)) + sin(iTime * 1.0) * vec2(0.0, 250.0);\n    \n    origin = iMouse.xy;\n    \n    vec2 ofst = fragCoord - origin;\n    float dist = distance(ofst, vec2(0.));\n    vec2 dir = normalize(ofst);\n   \n    vec2 stepped = (fragCoord - (dir * 5.0)) / iResolution.xy;\n\n    if (dist < 25.0) {\n        fragColor = c_origin;\n    } else if (sin(fixed_ofst.x / 25.0) * sin(fixed_ofst.y / 25.0) > 0.9) {\n        fragColor = c_wall;\n    } else if (texture(iChannel0, stepped) == c_light || texture(iChannel0, stepped) == c_origin) {\n        fragColor = c_light;\n    } else {\n        fragColor = vec4(stepped / 518.0, 0., 1.);\n        fragColor = c_empty;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3dSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 144]], "test": "error"}
{"id": "X3dXWf", "name": "Voice Synthesis", "author": "Peace", "description": "I will try adding other vowels and phenomes, for now enjoy \"AAaAAAaAAAAAAaaAAAAaaaAAAAAAAaaAAAAaAAA\nAAaAAAaAAAAAAaaAAAAaaaAAAAAAAaaAAAAaAAAAAaAAAaAAAAAAaaAAAAaaaAAAAAAAaaAAAAaAAAAAaAAAaAAAAAAaaAAAAaaaAAAAAAAaaAAAAaAAAAAaAAAaAAAAAAaaAAAAaaaAAAAAAAaaAAAAaA\"", "tags": ["sound", "music", "synthesis", "synth", "speech", "voice", "phonetic", "sing"], "likes": 8, "viewed": 110, "published": 3, "date": "1719704741", "time_retrieved": "2024-07-07T01:17:37.843321", "image_code": "float spiral(vec2 uv) {\n    vec2 nv = normalize(uv);\n    float a = atan(uv.y, uv.x);\n    float l = sqrt(length(uv));\n    uv = nv * (sin(l * 3.0 + iTime * 2.0) + sin(a * 4.0));\n    float s = sin(a * 4.0);\n    float d = distance(nv * (s * 0.2 + 0.5), uv);\n    d = cos(d * l);\n    \n    return clamp(-exp(-d*1.0) + 0.3 / (d * d), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y) * 2.0;\n    float t = iTime * 0.2;\n\n    vec3 col = vec3(spiral(uv * cos(t - cos(t * 3.0 + cos(t * 4.0))) + vec2(-uv.y, uv.x) * sin(t - sin(t * 3.0))));\n    col.b *= 0.4;\n    uv -= col.gb;\n    col.r += col.r + spiral(uv * cos(0.5 + t - cos(t * 3.0 + cos(t * 4.0))) + vec2(-uv.y, uv.x) * sin(0.5 + sin(t * 3.0) + t));\n    uv += col.rr;\n    col.g += col.g + spiral(uv * cos(1.0 - t + sin(t  * 3.0 - sin(t * 5.0))) + vec2(-uv.y, uv.x) * sin(1.0 - sin(t * 3.0)));\n    uv -= col.rg;\n    col.b += col.b + spiral(uv * cos(1.5 - cos(t * 3.0)) + vec2(-uv.y, uv.x) * sin(1.5 - sin(t * 3.0)));\n    col = 1.0 - sqrt(col);\n    col = sin(col * 2.0) * 0.5 + 0.5;\n    col = (0.5 + col) * (1.5 - abs(cos(length(col) * 3.0)));\n    col = mix(vec3(dot(col, vec3(0.299, 0.587, 0.114))), col, 4.0);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "sound_code": "const float T = 6.28318531;\n\nfloat ts = 0.0;\n\nfloat hash11(float p) {\n    uint u = floatBitsToUint(p * 1231.1031) * 2597334677u;\n    return float(u * u * 2597334677u) / float(~0u);\n}\n\nfloat noise(float p) {\n\tfloat i = floor(p);\n\tfloat f = fract(p);\n    f *= f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i), hash11(i + 1.0), f);\n}\n\nfloat A(float t) {\n    float F = 90.0;\n    float F2 = F / 3.0;\n    float M = 1.0 / (1.0 + ts * ts);\n    \n    float vb = 0.0;\n    float tFT = t * F * T - (M - 1.0) * 15.0;\n    float tF2T = t * F2 * T - (M - 1.0) * 45.0;\n    float tF2 = t * F2 + (M - 1.0) * 45.0;\n    vb += cos(tFT * 1.0) * cos(tF2T * 1.0 + noise(tF2 - 321.85652) * 3.0 * M) * 0.1;\n    vb += cos(tFT * 3.0) * cos(tF2T * 3.0 + noise(tF2 - 311.54742) * 3.0 * M) * 0.5;\n    vb -= cos(tFT * 5.0) * cos(tF2T * 5.0 + noise(tF2 - 222.84654) * 3.0 * M) * 0.5;\n    vb += cos(tFT * 6.0) * cos(tF2T * 6.0 + noise(tF2 - 111.63453) * 3.0 * M);\n    vb -= cos(tFT * 8.0) * cos(tF2T * 8.0 + noise(tF2 - 845.86532) * 3.0 * M);\n    vb -= cos(tFT * 9.0) * cos(tF2T * 9.0 + noise(tF2 - 655.11123) * 3.0 * M) * 0.3;\n    vb += cos(tFT * 12.0) * cos(tF2T * 12.0 + noise(tF2 - 531.63329) * 3.0 * M) * 0.5;\n    \n    return vb;\n}\n\nvec2 mainSound(int samp, float t) {\n    ts = fract(abs(0.5 - fract(t * 2.0)) - abs(0.5 - fract(t * 0.5)) * 3.0);\n    if (t < 4.0) ts = 0.0;\n    float s = A(t - 0.0251262) - A(t + 0.0365754) + A(t - 0.07462323) - A(t + 0.0726861);\n    if (t < 4.0) ts = 0.99;\n    s *= ts * smoothstep(1.0, 0.99, ts);\n    return vec2(s) * 0.1;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3dXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 338], [340, 340, 392, 392, 1285]], "test": "valid"}
{"id": "X3dSDX", "name": "reflect on sphere", "author": "FabriceNeyret2", "description": "analytic reflection on a sphere.\nSwitch #if between plane and cubemap", "tags": ["raytracing", "envmap", "analytic"], "likes": 14, "viewed": 203, "published": 3, "date": "1719688566", "time_retrieved": "2024-07-07T01:17:38.727953", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;              // normalized coordinates\n    vec3 P = vec3( U, sqrt(1.-dot(U,U)) ),   // = point and normal on sphere\n      // T = reflect( vec3(0,0,-1), N );     // reflected ray from infinity\n         T =  vec3(0,0,-1) + 2.*P *P.z ;     // = I - 2. * dot(N, I) * N\n#if 1                                        // environment: plane Z = 1\n\n    P += ( 1. - P.z ) / T.z * T;             // ray from P to plane z = 1\n // P += (( sign(T) - P) / T ).z * T;        // variante: front + rear plane z = +-1\n    O = texture( iChannel0, P.xy*.5+.5 );\n // O /= length(fwidth(P)) *R.y/4.;          // (empirical) Jacobian fading\n // R = vec2( length(vec2(dFdx(P.x),dFdy(P.x))), length(vec2(dFdx(P.y),dFdy(P.y))) )*R.y/2. , O /= R.x*R.y*.7; // correct Jacobian\n   \n#else                                        // environment: cubemap\n\n    vec3 A = abs(T);\n    int i =   A.z > max(A.x,A.y) ? 2         // plane id = main reflect direction \n            : A.y > max(A.x,A.z) ? 1\n            :                      0;\n    P += ( sign(T[i]) - P[i] ) / T[i] * T;  // ray from P to plane xi = sign(Ti)\n//  P += (( sign(T) - P ) / T ) [i] * T;    // golfed\n    O = texture( iChannel0, vec2( P[(i+1)%3], P[(i+2)%3]) *.5+.5 );\n#endif   \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3dSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1314]], "test": "error"}
{"id": "X3tSDX", "name": "Más esferas e inversiones", "author": "metamatematico", "description": "Código generado con Claude AI y Copilot", "tags": ["spheres", "esferas"], "likes": 2, "viewed": 75, "published": 3, "date": "1719686071", "time_retrieved": "2024-07-07T01:17:39.658464", "image_code": "#define MAX_STEPS 30\n#define MAX_DIST 40.\n#define SURF_DIST .001\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nfloat getDistance(vec3 p) {\n    float d = MAX_DIST;\n    vec3 z = p;\n    float scale = 0.8;\n    \n    for(int i=0; i<10; i++) {\n        z = rotateY(z, iTime * 0.1 + iMouse.x * 0.001); // Añadir interacción con el ratón\n        z = abs(z) - vec3(5.0, 0.5, 1.0) * scale;\n        \n        if((z.x) < z.y) z.xy = z.yx;\n        if(z.x < z.z) z.xzy = z.xzy;\n        if(z.y < z.z) z.yxz = z.xzy;\n        \n        z = z * 2.80 - vec3(5.0, 3.0, -0.5) * scale;\n        scale *= 1.0200; // Aumentar el factor de escala para incrementar la deformación\n        \n        float sphereDist = sdSphere(z, 1.50 * scale);\n        d = min(d, sphereDist / scale);\n    }\n    \n    return d * 0.5;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 e = vec2(.00001, 0);\n    vec3 n = d - vec3(\n        getDistance(p-e.xyy),\n        getDistance(p-e.yxy),\n        getDistance(p-e.yyx));\n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.5;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDistance(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getColor(vec3 p) {\n    vec3 col = vec3(0.5) + 0.5 * sin(iTime * 0.1 + p.xyx * 0.2 + vec3(0,2,4));\n    return mix(vec3(30.8, 10.5, 4.22), vec3(0.2, 0.5, 0.08), col) * .3333333; // Hacer colores más translúcidos\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.09*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(1, 0, -4);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    ro = rotateY(ro, iTime * 0.1 + iMouse.x * 0.001); // Añadir interacción con el ratón\n    rd = rotateY(rd, iTime * 0.1 + iMouse.x * 0.001); // Añadir interacción con el ratón\n    \n    float d = rayMarch(ro, rd);\n    \n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = getColor(p);\n        \n        col *= dif;\n        col += pow(max(dot(r, normalize(vec3(1,2,3))), 0.70), 8.0); // specular\n        col *= refract(rd, n, 5.0 / 4.533); // Añadir refracción para simular la óptica de las burbujas de jabón\n    }\n    \n    col = pow(col, vec3(.4545));  // gamma correction\n    \n    fragColor = vec4(col,0.0000001); // Ajustar la opacidad a 0.1 para hacer los objetos casi transparentes\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3tSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 99, 99, 127], [129, 129, 160, 160, 256], [258, 258, 285, 285, 935], [937, 937, 961, 961, 1162], [1164, 1164, 1198, 1198, 1413], [1415, 1415, 1438, 1438, 1633], [1635, 1635, 1692, 1692, 2705]], "test": "valid"}
{"id": "XXtSWX", "name": "sphere of  fractal", "author": "nayk", "description": "sphere\noriginals https://www.shadertoy.com/view/Nsy3Dy\n", "tags": ["fractal", "cineshader"], "likes": 3, "viewed": 119, "published": 3, "date": "1719680593", "time_retrieved": "2024-07-07T01:17:40.555066", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\n\n\n\n#define PI acos(-1.)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.05,fwidth(val-thre)))\n\n#define TRYPOPHOBIA 0\n\n// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTet(vec3 p, float r) {\n    const vec3 c = normalize(vec3(1.,-1.,1.));\n    return max(max(max(dot(p, c.xxx) - r, dot(p, c.yyx) - r), dot(p, c.xyy) - r), dot(p, c.yxy) - r);\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// assumes normalized axis\nmat3 makeRotation(vec3 axis,float angle) {\n    \n    float c = cos(angle), s = sin(angle);\n    float mc = 1. - c;\n    float sz = s * axis.z;\n    float sy = s * axis.y;\n    float sx = s * axis.x;\n    float mx = mc * axis.x;\n    float my = mc * axis.y;\n    float mz = mc * axis.z;\n    \n    return mat3(c + mx * axis.x,\n                mx * axis.y - sz,\n                mx * axis.z + sy,\n                mx * axis.y + sz,\n                c + my * axis.y,\n                my * axis.z - sx,\n                mx * axis.z - sy,\n                my * axis.z + sx,\n                c + mz * axis.z);\n}\n\n// -----------------\n\nmat3 innerRotation;\n\nfloat d(vec3 position) {\n    position = rX(position, iTime * 0.0);\n    float fScale = 0.79 + sin(iTime * 0.0) * 0.013;\n    float accumulatedScale = 1.;\n    \n    for(int i = 0; i < 8; i++) {\n        position = abs(position);\n        position *= fScale;\n        accumulatedScale *= fScale;\n        position -= (0.0137 + 0.001 );\n        position = innerRotation * position;\n    }\n    float cutoutAmount = pow(sin(iTime * 0.0), 4.);\n    #if TRYPOPHOBIA\n    float innerCutout = sdTet(-position,0.003 + cutoutAmount * 0.009);\n    #else\n    float innerCutout = sdSphere(position, 0.014 + cutoutAmount * 0.002);// sdSphere(position, 0.009 + cutoutAmount * 0.007);\n    #endif\n    float outerCrop = sdSphere(position, 0.021 + sin(iTime * 0.00 + 2.) * 0.003);\n    return opInt(opSub(sdTet(position, 0.01), innerCutout), outerCrop) / accumulatedScale;\n}\n\n\n\n// soft shadows also using iq’s technique — https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 origin, vec3 direction, float sharpness) {\n    const float maxDistance = 2.;\n    float amount = 1.;\n    float totalDistance = 0.;\n    for(int i = 0; i < 70; i++) {\n        float localDistance = d(origin);\n        amount = min(amount, 0.5 + 0.5 * localDistance / (sharpness * totalDistance));\n        if (localDistance < 0.) break;\n        origin += direction * max(0.002, localDistance);\n    }\n    \n    amount = max(amount, 0.);\n    return amount * amount * (3. - 2. * amount);\n    \n}\n\n\n#define ANTIALIASING_SAMPLES 3\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n      vec2 uv =  C/iResolution.xy-0.5;\n \n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    \n    \n    vec2 uv2 = 2.0 * (C.xy / iResolution.xy - 0.5);\n   \n    \n    innerRotation = makeRotation(normalize(vec3(1.,2.,-3.)), iTime * 0.1 + sin(iTime * 0.0) * 0.1);\n    \n\n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.05*exp(-.45*i*i*e))\n    {\n    \n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n  \n        p=g*d-vec3(0.,.0,1.1);\n        p=R(p,normalize(vec3(1,-2,2)),iTime);\n        s=4.;\n   \n        vec4 q=vec4(p*innerRotation,0.20+0.051*cos(iTime));\n                q.xzy*=innerRotation;\n                 q.xy*=ma;\n\t\tfor(int j=0;j++<8;)\n\n            q=abs(q),\n               \n            q=q.x<q.y?q.zwxy:q.zwyx,\n            s*=e=1.15/min(dot(q,q),0.54),\n            \n            q=q*e-vec4(1,4,.8,3);\n           \n        g+=e=min(\n            length(q.w+q.x)/s,\n            length(cross(q.yzw,normalize(vec3(1,1,1))))/s-.0002\n        );\n    }\n    O=pow(O,vec4(5));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXtSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 245, 291, 291, 400], [402, 402, 433, 433, 522], [524, 524, 557, 557, 585], [587, 587, 617, 617, 768], [770, 770, 807, 807, 853], [855, 855, 888, 888, 915], [917, 917, 950, 950, 976], [978, 978, 1011, 1011, 1037], [1039, 1039, 1065, 1065, 1204], [1206, 1206, 1232, 1232, 1372], [1374, 1374, 1400, 1400, 1539], [1541, 1568, 1610, 1610, 2156], [2158, 2201, 2225, 2225, 3043], [3047, 3137, 3197, 3197, 3639], [3674, 3674, 3710, 3710, 4876]], "test": "valid"}
{"id": "X33SDX", "name": "Fork cellnoise tetrismegi 504", "author": "tetrismegistus", "description": "just messing around with the parent project", "tags": ["cellularnoise"], "likes": 4, "viewed": 90, "published": 3, "date": "1719633271", "time_retrieved": "2024-07-07T01:17:41.424738", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;    \n    vec3 blue = vec3(0.455,0.537,0.753);\n    vec3 orange = vec3(0.961,0.318,0.035);\n    vec3 offWhite = vec3(0.941,0.918,0.776);\n    \n    vec3 verGrad = mix(orange, blue, uv.y);\n    vec3 horGrad = mix(offWhite, blue, uv.x);\n    vec3 mixGrad = mix(mix(offWhite,blue, .1 + uv.x * sin(iTime) + uv.y * cos(iTime)), mix(verGrad, horGrad, -abs(sin(iTime + uv.x) * .5)), uv.x * uv.y);    \n        \n    vec3 color = vec3(0.0);\n    uv *= 10.;\n    vec2 pos = vec2(uv);\n\n    \n\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n    float m_dist = 1.; \n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = vec2(random2(i_uv + neighbor));\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_uv;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = smoothstep(m_dist, dist, .9);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Show isolines\n    //color -= step(.7,abs(sin(50.0*m_dist)))*.3;\n\n    // Output to screen    \n    \n    color -= vec3(smoothstep(.7,abs(sin(27.0*m_dist)), .1)*.5, 1.0, 1.0);\n    color += mixGrad;\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X33SDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 144], [146, 146, 170, 170, 263], [268, 268, 325, 376, 1960]], "test": "valid"}
{"id": "M3sXDS", "name": "Fidget Cube", "author": "TheBen27", "description": "Similar to a toy I have on my desk.\n\nThis is lit only with an environment map and ambient occlusion, which looks nice as long as you use big, soft lights. \n", "tags": ["raymarch"], "likes": 32, "viewed": 175, "published": 3, "date": "1719632279", "time_retrieved": "2024-07-07T01:17:42.515818", "image_code": "#define MAX_DEPTH 8.0\n#define CUBE_COUNT 8\n\nconst float minDepth = 0.01;\nconst float matchEps = 0.0001;\n\n// Global vars\nfloat time;\n// For some reason, making this a global variable is good for performance,\n// despite the fact that shaders don't have a stack. Maybe this array is\n// copied into inner functions?\nmat4[CUBE_COUNT] transforms;\nfloat shapeFactor;\n\nfloat snapping(float a, float b, float t) {\n    t = clamp(t, a, b);\n    t = (t - a) / (b - a);\n    t = clamp(t * 2.0, 0.0, 1.0);\n    \n    float s = step(0.5, t);\n    float ta = pow(t * 2.0, 2.0) * 0.5;\n    float tb = 0.5 + pow(max(0.0, t * 2.0 - 1.0), 0.5) * 0.5;\n    t = mix(ta, tb, s);\n    \n    return t;\n}\n\nfloat beat() {\n    return mod(time * 2.0, 8.0);\n}\n\nmat4[CUBE_COUNT] cubeTransforms() {\n    \n    // 120BPM\n    float time = beat();\n\n    mat4 preT = translate(vec3(0.25, -0.25, -0.25));\n    \n    mat4 mats[CUBE_COUNT];\n    mats[0] = rotY(0.0) * preT;\n    mats[1] = rotY(PI / 2.0) * preT;\n    mats[2] = rotY(PI) * preT;\n    mats[3] = rotY(PI * 3.0 / 2.0) * preT;\n    mat4 sy = translate(vec3(0.0, -1.0, 0.0)) * rotX(PI);\n    mats[4] = sy * mats[0];\n    mats[5] = sy * mats[1];\n    mats[6] = sy * mats[2];\n    mats[7] = sy * mats[3];\n    \n    // first folding out\n    float s1 = snapping(0.0, 1.0, time);\n    mat4 t1 = translate(vec3(0.0, -s1 * 0.5, 0.0));\n    mat4 r1 = t1 * rotX(s1 * PI / 2.0);\n    mat4 r1i = t1 * rotX(-s1 * PI / 2.0);\n    mats[0] = r1i * mats[0];\n    mats[1] = r1  * mats[1];\n    mats[2] = r1  * mats[2];\n    mats[3] = r1i * mats[3];\n    mats[4] = r1  * mats[4];\n    mats[5] = r1i * mats[5];\n    mats[6] = r1i * mats[6];\n    mats[7] = r1  * mats[7];\n    \n    // second folding\n    float s2 = snapping(1.0, 2.0, time);\n    mat4 t2 = translate(vec3(0.0, -s2 * 0.5, 0.0));\n    mat4 r2 = t2 * rotZ(s2 * PI / 2.0);\n    mat4 r2i = t2 * rotZ(-s2 * PI / 2.0);\n    mats[0] = r2i *  mats[0];\n    mats[1] = r2i * mats[1];\n    mats[2] = r2  * mats[2];\n    mats[3] = r2  * mats[3];\n    mats[4] = r2i * mats[4];\n    mats[5] = r2i * mats[5];\n    mats[6] = r2  * mats[6];\n    mats[7] = r2  * mats[7];\n    \n    // third folding\n    float s3 = snapping(2.0, 3.0, time);\n    mat4 t3 = translate(vec3(0.0, -s3 * 0.5, 0.0));\n    mat4 r3 = t3 * translate(vec3(0.0, 0.0, 0.5)) * rotX(s3 * PI) * translate(vec3(0.0, 0.0, -0.5));\n    mat4 r3i = t3 * translate(vec3(0.0, 0.0, -0.5)) * rotX(-s3 * PI) * translate(vec3(0.0, 0.0, 0.5));\n    mats[0] = t3  *  mats[0];\n    mats[1] = t3  * mats[1];\n    mats[2] = t3  * mats[2];\n    mats[3] = t3  * mats[3];\n    mats[4] = r3  * mats[4];\n    mats[5] = r3i * mats[5];\n    mats[6] = r3i * mats[6];\n    mats[7] = r3  * mats[7];\n    \n    // TODO can get rid of remaining foldings\n    \n    // fourth folding\n    float s4 = snapping(4.0, 5.0, time);\n    mat4 t4 = translate(vec3(0.0, -s4 * 0.5, 0.0));\n    mat4 r4 = t4 * rotZ(s4 * PI / 2.0);\n    mat4 r4i = t4 * rotZ(-s4 * PI / 2.0);\n    mats[0] = r4i * mats[0];\n    mats[1] = r4i * mats[1];\n    mats[2] = r4 * mats[2];\n    mats[3] = r4 * mats[3];\n    mats[4] = r4i * mats[4];\n    mats[5] = r4i * mats[5];\n    mats[6] = r4 * mats[6];\n    mats[7] = r4 * mats[7];\n    \n\n    // fifth folding\n    float s5 = snapping(5.0, 6.0, time);\n    mat4 t5 = translate(vec3(0.0, -s5 * 0.5, 0.0));\n    mat4 r5 = t5 * rotX(s5 * PI / 2.0);\n    mat4 r5i = t5 * rotX(-s5 * PI / 2.0);\n    mats[0] = r5i * mats[0];\n    mats[1] = r5 * mats[1];\n    mats[2] = r5 * mats[2];\n    mats[3] = r5i * mats[3];\n    mats[4] = r5 * mats[4];\n    mats[5] = r5i * mats[5];\n    mats[6] = r5i * mats[6];\n    mats[7] = r5 * mats[7];\n    \n    // sixth and final folding\n    float s6 = snapping(6.0, 7.0, time);\n    mat4 t6 = translate(vec3(0.0, -s6 * 0.5, 0.0));\n    mat4 r6 = t6 * translate(vec3(-0.5, 0.0, 0.0)) * rotZ(s6 * PI) * translate(vec3(0.5, 0.0, 0.0));\n    mat4 r6i = t6 * translate(vec3(0.5, 0.0, 0.0)) * rotZ(-s6 * PI) * translate(vec3(-0.5, 0.0, 0.0));\n    mats[0] = r6i * mats[0];\n    mats[1] = r6i * mats[1];\n    mats[2] = r6 * mats[2];\n    mats[3] = r6 * mats[3];\n    mats[4] = t6 * mats[4];\n    mats[5] = t6 * mats[5];\n    mats[6] = t6 * mats[6];\n    mats[7] = t6 * mats[7];\n    \n    // spin every fourth beat\n    mat4 spin = rotY(\n        PI * 0.5 * (snapping(7.0, 8.0, time) + snapping(3.0, 4.0, time))\n    );\n    mats[0] = spin * mats[0];\n    mats[1] = spin * mats[1];\n    mats[2] = spin * mats[2];\n    mats[3] = spin * mats[3];\n    mats[4] = spin * mats[4];\n    mats[5] = spin * mats[5];\n    mats[6] = spin * mats[6];\n    mats[7] = spin * mats[7];\n    \n    return mats;\n}\n\nvec2 sceneSDF(vec3 pos) {\n    vec2 sm = vec2(MAX_DEPTH, 0.0);\n    vec4 p = vec4(pos, 1.0);\n    \n    for (int i = 0; i < CUBE_COUNT; i++) {\n        float tri = sdTriBox((p * transforms[i]).xyz);\n        float cir = sdCircleBox((p * transforms[i]).xyz);\n        float mixed = mix(tri, cir, shapeFactor);\n        if (mixed < sm.x) {\n            sm.x = mixed;\n            sm.y = float(i);\n        }\n    }\n    return sm;\n}\n\nvec3 sceneNormal( in vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h).x + \n                      k.yyx*sceneSDF( p + k.yyx*h).x + \n                      k.yxy*sceneSDF( p + k.yxy*h).x + \n                      k.xxx*sceneSDF( p + k.xxx*h).x );\n}\n\nbool intersectPlane(vec3 normal, vec3 planeOrigin, vec3 eye, vec3 dir, out float dist)\n{\n    eye.y = -eye.y;\n    dir.y = -dir.y;\n    // Assuming vectors are all normalized\n    float denom = dot(normal, dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = planeOrigin - eye;\n        dist = dot(p0l0, normal) / denom; \n        return (dist >= 0.0);\n    }\n\n    return false;\n}\n\nbool intersectFloor(float height, vec3 eye, vec3 dir, out float t) {\n    return intersectPlane(vec3(0.0, 1.0, 0.0), vec3(0.0, height, 0.0), eye, dir, t);\n}\n\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nvec2 getDepthAndMaterial(vec3 eye, vec3 dir) {\n    // AABB check\n    vec2 boxCheck =\n        intersectAABB(\n            eye,\n            dir,\n            vec3(-0.75, -0.25, -1.25),\n            vec3(0.75, 1.25, 1.25)\n    );\n    if (boxCheck.x > boxCheck.y) {\n        return vec2(MAX_DEPTH, 0.0);\n    }\n\n    float depth = boxCheck.x;\n    float sdf = matchEps;\n    float mat = 0.0;\n    for (int steps = 0;\n         sdf >= matchEps && depth < MAX_DEPTH && steps < 40;\n         steps++) {\n        vec2 sdf = sceneSDF(eye + depth * dir);\n        depth += sdf.x;\n        mat = sdf.y;\n    }\n    depth = min(depth, MAX_DEPTH);\n    \n    return vec2(depth, mat);\n}\n\nfloat occ( in vec3 p, in vec3 n)\n{\n    const float maxDist = 0.5;\n    const float falloff = 1.0;\n    const int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = rand(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal for self occlusion problems!\n\n        ao += (l - max(sceneSDF( p + rd).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 getTexCoords(vec3 pos, float mat) {\n    vec4 p = vec4(pos, 1.0);\n    return (p * transforms[int(mat)]).xyz;\n}\n\n// surprisingly acceptable for something so simple\nvec2 boxMapping(vec3 tc, vec3 norm) {\n    vec2 uvTop = tc.xz;\n    vec2 uvRight = tc.zy;\n    vec2 uvFront = tc.xy;\n    float weightTop = abs(norm.y);\n    float weightRight = abs(norm.x);\n    float weightFront = abs(norm.z);\n    float totalWeights = weightTop + weightRight + weightFront;\n    \n    return (uvTop * weightTop + uvRight * weightRight + uvFront * weightFront) / totalWeights;\n}\n\nvec3 textureAt(vec3 tc, vec3 norm, float mat) {\n    norm = (vec4(norm, 0.0) * transforms[int(mat)]).xyz;\n    \n    // box mapping\n    vec2 uv = boxMapping(tc, norm);\n    \n    vec3 color;\n    \n    // outside faces:\n    // (0, 0, 1)\n    // (0, -1, 0)\n    // (-1, 0, 0)\n    float isOutside = step(0.9, dot(norm, vec3(-1.0, -1.0, 1.0)));\n    \n    // base colors\n    float checker = step(mod(mat, 2.0), 0.99);\n    vec3 outside = mix(\n        vec3(1.0, 0.5, 0.9), // pink\n        vec3(0.5, 0.7, 0.8), // blue\n        checker\n    );\n    vec3 inside = mix(\n        vec3(0.8, 0.2, 0.2), // red\n        vec3(0.2, 0.8, 0.2), // green\n        checker\n    );\n    color = mix(inside, outside, isOutside);\n    \n    // add an edge outline\n    \n    // \"snap\" the normal vector to the nearest cardinal direction\n    // not sure if there's a better way to do this...\n    // bias the snap based on what side of the cube's diagonal we're on\n    // this makes the diagonal side look right\n    float bias = sign(-tc.x - tc.z) * 0.001;\n    vec3 snorm;\n    \n    if (abs(norm.x) + bias > abs(norm.y) && abs(norm.x) + bias > abs(norm.z)) {\n        snorm = vec3(sign(norm.x), 0.0, 0.0);\n    } else if (abs(norm.y) + bias > abs(norm.z)) {\n        snorm = vec3(0.0, sign(norm.y), 0.0);\n    } else {\n        snorm = vec3(0.0, 0.0, sign(norm.z));\n    }\n    \n    // proj a onto b = dot(a, b) / dot(b, b) * b\n    // since |b| = 1...\n    vec3 p = dot(tc, snorm) * snorm;\n    vec3 r = tc - p;\n    float boxDist = max(abs(r.x), max(abs(r.y), abs(r.z)));\n    float edgeHighlight = smoothstep(0.24, 0.25, boxDist);\n    \n    // apply edge highlight\n    color = mix(color, vec3(1.0, 0.8, 0.9), edgeHighlight);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    if (iMouse.z > 0.0) {\n        time = 4.0 * iMouse.x / iResolution.x;\n    } else {\n        time = iTime - 0.5 * texture(iChannel3, uv).r * iTimeDelta; \n    }\n \n    float shape1 = snapping(3.0, 4.0, mod(beat(), 4.0));\n    shapeFactor = beat() > 4.0 ? (1.0 - shape1) : shape1;\n \n    vec3 eye, dir;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = -2.5;\n    mat2 rx = rot(PI / 6.5);\n    mat2 ry = rot(PI / 4.0);\n    eye = vec3(0.0, 0.25, dist);\n    eye.yz *= rx;\n    eye.xz *= ry;\n    dir = normalize(vec3(uv, 1.0));\n    dir.yz *= rx;\n    dir.xz *= ry;\n   \n    vec3 col = vec3(1.0, 1.0, 0.0);\n    \n    // it looks like we do something wrong here...\n    transforms = cubeTransforms();\n    \n    vec2 sdf = getDepthAndMaterial(eye, dir);\n    float depth = sdf.x;\n    float mat = sdf.y;\n    \n    if (depth >= MAX_DEPTH) {\n        float dist;\n        bool hitFloor = intersectFloor(0.0, eye, dir, dist);\n        if (hitFloor) {\n            depth = dist;\n            mat = -1.0;\n        }\n    }\n    \n    if (depth < MAX_DEPTH || mat == -1.0) {\n        vec3 pos = eye + dir * depth;\n        vec3 norm;\n        \n        if (mat < 0.0) {\n            norm = vec3(0.0, 1.0, 0.0);\n            col = vec3(1.0);\n        } else {\n            // texture\n            norm = sceneNormal(pos);\n            vec3 color = textureAt(getTexCoords(pos, mat), norm, mat);\n            col = color;\n        }\n        pos += norm * 0.001;\n        \n        // diffuse light\n        col *= texture(iChannel0, norm).rgb;\n\n        // specular highlights\n        float fresnel = 0.8 * fresnelFactor(1.2, dir, norm);\n        float spec = texture(iChannel0, reflect(dir, norm)).a;\n        col = mix(col, vec3(spec), max(0.0, fresnel));\n        \n        float occ = occ(pos, norm);\n        occ *= occ;\n        col *= occ;\n        \n    } else {\n        col = sky(dir);\n    }\n\n    // Output to screen\n    fragColor = vec4(sqrt(Tonemap_ACES(col * 0.8)),1.0);\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n#define MAT_METAL -1.0\n\nvec3 Tonemap_ACES(vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat fresnelFactor(float r0, vec3 dir, vec3 normal) {\n    float f = 1.0 - dot(normal, dir);\n    return r0 + (1.0 - r0) * (f * f * f * f * f);\n}\n\nvec3 skyLight(vec3 dir, vec3 col, vec3 center, float size, float smoothness) {\n    float falloff = max(0.0, dot(dir, normalize(center)));\n    float sizeMin = 1.0 - size;\n    falloff = smoothstep(sizeMin, mix(sizeMin, 1.0, smoothness), falloff);\n    // energy correction - smaller lamps should be brighter\n    return col * falloff / size;\n}\n\nvec3 sky(vec3 dir) {\n    vec3 top = vec3(0.4, 0.4, 0.6);\n    vec3 bottom = vec3(0.3, 0.3, 0.5);\n    vec3 ambient = mix(top, bottom, -dir.y);\n    \n    vec3 fill = skyLight(dir, vec3(1.0), vec3(-0.1, 1.0, 0.5), 0.5, 1.0);\n    vec3 key = skyLight(dir, vec3(0.6), vec3(-0.2, 0.3, -0.2), 0.2, 1.0);\n    return ambient + fill + key;\n}\n\nfloat rand(float p)\n{\n    p = fract(p * .1031);\n    p += 0.1;\n    p *= p + 33.33;\n    p *= p + p;\n    p -= 0.1;\n    return fract(p);\n}\n\nfloat rand2(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(rand(i+1.), rand(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nconst mat4 id = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\nmat4 scale(vec3 p) {\n    return mat4(\n        p.x, 0.0, 0.0, 0.0,\n        0.0, p.y, 0.0, 0.0,\n        0.0, 0.0, p.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 translate(vec3 p) {\n    return mat4(\n        1.0, 0.0, 0.0, p.x,\n        0.0, 1.0, 0.0, p.y,\n        0.0, 0.0, 1.0, p.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotZ(float t) {\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n         ct, -st, 0.0, 0.0,\n         st,  ct, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotY(float t) {\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n         ct, 0.0,  st, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -st, 0.0,  ct, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotX(float t) {\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,  ct, -st, 0.0,\n        0.0,  st,  ct, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCircleBox(vec3 p) {\n    float smoothness = 0.01;\n    float b = sdBox(p, vec3(0.25) - smoothness) - smoothness;\n    \n    float c = distance(p, vec3(-0.25, -0.25, 0.25)) - 0.5;\n    return max(b, c);\n}\n\nfloat sdTriBox(vec3 p) {\n    float smoothness = 0.01;\n    float b = sdBox(p, vec3(0.25) - smoothness) - smoothness;\n    \n    float magic = 0.577;\n    float cutter = dot(p, normalize(vec3(magic, magic, -magic))) - (0.15);\n    return max(b, cutter);\n}\n\nvec2 sdfMin(vec2 s1, vec2 s2) {\n    if (s1.x < s2.x) {\n        return s1;\n    }\n    return s2;\n}", "cube_a_code": "// Precompute environment map\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame > 1) {\n        fragColor = texture(iChannel0, rayDir);\n        return;\n    }\n    \n    // Diffuse\n    vec3 diff = vec3(0.0);\n    const int diff_samples = 512;\n    for (int i = 0; i < diff_samples; i++) {\n        vec3 dir = randomHemisphereDir(rayDir, float(i));\n        diff += sky(dir);\n    }\n    diff /= float(diff_samples);\n    \n    // Specular\n    vec3 specColor = sky(rayDir);\n    float spec = specColor.r + specColor.g + specColor.b;\n    spec /= 3.0;\n    \n    // Output to cubemap\n    fragColor = vec4(diff, spec);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/M3sXDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 361, 404, 404, 669], [671, 671, 685, 685, 720], [4501, 4501, 4526, 4526, 4918], [4920, 4920, 4950, 4950, 5234], [5236, 5236, 5324, 5324, 5606], [5608, 5608, 5676, 5676, 5763], [5765, 5765, 5840, 5840, 6119], [6121, 6121, 6167, 6185, 6774], [6776, 6776, 6810, 6810, 7382], [7384, 7384, 7424, 7424, 7498], [7500, 7551, 7588, 7588, 7939], [7941, 7941, 7988, 7988, 9633], [9635, 9635, 9692, 9692, 11687]], "test": "error"}
{"id": "X3cXWX", "name": "cellnoise", "author": "tetrismegistus", "description": "an implementation based on the one described in the book of shaders https://thebookofshaders.com/12/", "tags": ["cellularnoise"], "likes": 4, "viewed": 104, "published": 3, "date": "1719631219", "time_retrieved": "2024-07-07T01:17:43.384557", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec2 permute(const in vec2 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec3 permute(const in vec3 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec4 permute(const in vec4 v) { return mod289(((v * 34.0) + 1.0) * v); }\n\n#endif\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    return p;\n}\n#endif\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec2 snoise2( vec2 x ){\n    float s  = snoise(vec2( x ));\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n\n#endif\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;    \n    vec3 blue = vec3(0.455,0.537,0.753);\n    vec3 orange = vec3(0.961,0.318,0.035);\n    vec3 offWhite = vec3(0.941,0.918,0.776);\n    \n    vec3 verGrad = mix(orange, blue, uv.y);\n    vec3 horGrad = mix(offWhite, blue, uv.x);\n    vec3 mixGrad = mix(mix(offWhite,blue, .1 + uv.x * sin(iTime) + uv.y * cos(iTime)), mix(verGrad, horGrad, -abs(sin(iTime + uv.x) * .5)), uv.x * uv.y);    \n        \n    vec3 color = vec3(0.0);\n    uv *= 10.;\n    vec2 pos = vec2(uv);\n\n    // Use the noise function\n    float n = snoise(vec3(pos.x, pos.y, iTime * .5));\n    uv *= n;\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n    float m_dist = 1.; \n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = vec2(random2(i_uv + neighbor));\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_uv;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Show isolines\n    //color -= step(.7,abs(sin(50.0*m_dist)))*.3;\n\n    // Output to screen    \n    \n    color -= vec3(smoothstep(.7,abs(sin(27.0*m_dist)), .1)*.5, 1.0, 1.0);\n    color += mixGrad;\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3cXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8737, 8737, 8764, 8764, 8881], [8883, 8883, 8907, 8907, 9000], [9005, 9005, 9062, 9113, 10777]], "test": "error"}
{"id": "l3dXDj", "name": "glass doodle ", "author": "elenzil", "description": "keyboard:\n1. heat map\n2. x-eyed stereo\n3. cutting plane\n4. zoom\n5. AA\n6. transmission", "tags": ["refraction", "glass", "optics"], "likes": 25, "viewed": 163, "published": 3, "date": "1719619700", "time_retrieved": "2024-07-07T01:17:44.466599", "image_code": "/*\n    This attempts to handle transparent materials\n    with various indices of refraction\n    which directly abut each other.\n    \n    Orion Elenzil 2024\n*/\n\n\n\n/*\n\nKeyboard (iChannel3)\n--------------------\n1. heat map\n2. x-eyed stereo\n3. cutting plane\n4. zoom\n5. AA\n6. transmission\n\n*/\n\n#define SUBSURFACE 0   // not-quite-right subsurface scattering\n#define HQ         0   // slowww but pretty\n\n//---------------------------------------------------------------\n// Viewport and Time\nconst float gZoom       = 0.8;\n      float gFOVZoom    = 2.0;\n      float gCamDist    = 24.0;\nconst float gToggleZoom = 2.0;\nconst float gStereoSep  = 0.4;\n\n      float gT;         // set in main\n\n//--------------------------------------------------------------------------\n// ray handling parameters\n\n// maximum number of rays per pixel.\n// reflections, shadows, and transmission all spawn a ray,\n// and a single ray travels until it hits a boundary.\n#if HQ\nconst uint  gHQMult         = 3u;\n#else\nconst uint  gHQMult         = 1u;\n#endif\nconst uint  gMaxRays        = 120u * gHQMult;\nconst uint  gQueueSize      =  18u * gHQMult;\n\n// standard marching parameters\nconst float gSceneScale     = 2.0f;\nconst uint  gMaxMarchSteps  = 200u * gHQMult;\nconst float gMarchEps       = 0.03;\nconst float gNormEps        = gMarchEps * 0.4;\nconst float gMarchMaxT      = 5e1 * gSceneScale;\nconst float gMarchUnderstep = 1.0 / float(gHQMult);\nconst float gHitBackoff     = gMarchEps * 0.0;\n\n// smallest contribution before extinguishing a ray\nconst float gMinAmt         = 0.01 / float(gHQMult);\n\n// direction to the light\nvec3  gLightDir;\nfloat gAmbient              = 0.02;\n\n// heat map stuff\n      float gMapCount       = 0.0;\nconst float cHeatMapSteps   = 200.0;\nconst float cHeatMapRays    = 20.0;\n\n// debugging color\n      vec3  gDebugRGB       = v0;\n\n//--------------------------------------------------------------------------\n// Materials\n\nconst uint gMtlAir   = 1u;\nconst uint gMtlFloor = 2u;\nconst uint gMtlGlass = 3u;\nconst uint gMtlWater = 4u;\nconst uint gMtlIce   = 5u;\nconst uint gMtlBands = 6u;\nmtl_t mtls[] = mtl_t[] (\n    //    albedo             opac   ior    absorption\n    mtl_t(vX * 1e9         , 1.0  , 1.0  , v41                   ), // 0 invalid\n    mtl_t(v1               , 0.0  , 1.0  , v41 * 0.5             ), // 1 air\n    mtl_t(v1 * 0.3         , 1.0  , 1.3  , v41 * 1.0             ), // 2 floor\n    mtl_t(v1 * 1.0         , 0.0  , 1.52 , V4(0.3, 0.3, 0.3, 0.2)), // 3 glass\n    mtl_t(v1 * 1.0         , 0.0  , 1.33 , V4(0.2, 0.2, 0.6, 0.5)), // 4 water\n    mtl_t(vX + vY          , 0.0  , 1.31 , V4(0.2, 0.2, 0.2, 0.1)), // 5 ice\n    mtl_t(V3(0.9, 0.0, 0.4), 0.015, 1.2  , V4(0.5, 0.8, 0.0, 2.0)), // 6 bands\n    mtl_t(v1 * 0.6         , 1.0  , 1.5  , v41                   )  // 7\n);\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff part one\nbool kPipOn;        // 1. heat map\nbool kXEyedStereo;  // 2. x-eyed stereo\nbool kCuttingPlane; // 3. cutting plane\nbool kZoom;         // 4. zoom\nbool kAA;           // 5. AA\nbool kTransmission; // 6. transmission\n// pbpaste | sed -e 's/.*\\/\\/ //' | pbcopy\n\n//--------------------------------------------------------------------------\n// Scene Setup\nvec3  gSceneCenter;\nfloat gFloorGap;\nmat2  gObjRot1;\nmat2  gObjRot2;\nvec3  gCamPos;\n\n\nvoid setupScene() {\n    gSceneCenter  = gSceneScale * vY * 8.0;\n    gLightDir     = normalize(vec3(-0.8, 1.5, 1.9));\n    gFOVZoom     *= kZoom ? gToggleZoom : 1.0;\n    \n    gObjRot1 = rot2(gT * 0.123);\n    gObjRot2 = rot2(gT * 0.321);\n    \n    // change the material verrrry slowly according to the wall time.\n    vec4 w = mtls[gMtlBands].absorption;\n    float t = (iDate.z * 100.0 + iDate.w) * 1e-3;\n    w.r  = sin(t * 1.01) * 0.3 + 0.4;\n    w.g  = sin(t * 1.21) * 0.3 + 0.4;\n    w.b  = sin(t * 1.31) * 0.3 + 0.4;\n    w.a += sin(t * 1.41) * 0.3 + 0.5;\n    mtls[gMtlBands].absorption = w;\n    \n    float no = sin(t * 1.51) * 0.1;\n    mtls[gMtlBands].ior += no;\n}\n\n\n//---------------------------------------------------------------------\n// The SDF !\n\nMST sdScene(in vec3 p) {\n    gMapCount += 1.0;\n    \n    p.y -= gSceneCenter.y;\n    \n    p /= gSceneScale;\n    vec3 q = p;\n    \n    \n    vec3 tmp;\n    tmp  = opRing(q.xz, 9.0, 5.0);\n    q.xz = tmp.xy;\n    q.yz *= gObjRot1;\n    tmp  = opRing(q.yz, 4.0, 3.0);\n    q.yz = tmp.xy;\n\n    q.yz *= gObjRot1;\n    q.yx *= gObjRot2;\n\n    float d = 1e9;\n    \n    d = min(d,  sdCappedCylinder(q, 1., 2.7));\n    d = max(d, -sdCylinder(q.xz, 0.8));\n    d -= 0.1;\n    \n    \n    MST ms = MST(d, 4u);\n\n    \n    if (kCuttingPlane) {\n        ms.dist = max(ms.dist, p.z);\n    }\n    \n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    \n    return ms;\n}\n\n\n//------------------------------------------------------\n// ray-handling stuff.\n\n// FIFO queue of rays. see Common tab.\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES (gQueueSize)\nQ_IMPLEMENTATION\nhit_t rayVsScene(ray_t);\nvec3  sky(ray_t);\nvec3  albedo(hit_t);\nMST sdScene(vec3 p);\nMST sdSceneWithFloor(vec3 p);\n\n// run a single ray.\nvec3 runRay(ray_t ray) {\n    hit_t hit = rayVsScene(ray);\n    \n    if (!hit.hit) {\n        // ray hit nothing.\n        \n        if (ray.isLightingRay) {\n            // a \"lighting ray\" is to the light.\n            return ray.amt;\n        }\n        else {\n            // it's a direct ray and sees the sky.\n            return ray.amt * sky(ray);\n        }\n    }\n    \n    // the ray hit something\n\n    // get map samples on either side of the interface\n    MST ms1 = sdSceneWithFloor(hit.pnt + hit.hf_nrm * gMarchEps * 3.0);\n    MST ms2 = sdSceneWithFloor(hit.pnt - hit.hf_nrm * gMarchEps * 3.0);\n    mtl_t mtl1 = mtls[ms1.mtl];\n    mtl_t mtl2 = mtls[ms2.mtl];\n\n    // just traveled through media, attenuate !  (but not through air)\n    if (ms1.mtl != gMtlAir) {\n        vec4 absorption = mtl1.absorption;\n        absorption.w   = mix(absorption.w * 0.7, absorption.w  , smoothstep(0.0, 4.0, hit.pnt.y / gSceneScale));\n        absorption.rgb = mix(absorption.brg * 1.7, absorption.rgb, smoothstep(0.0, 6.0, hit.pnt.y / gSceneScale));\n        float density = absorption.w;\n        float absorptionDist = hit.t / gSceneScale;\n        ray.amt *= sat(exp(-density * absorptionDist * (1.0 - absorption.rgb)));\n    }\n    \n    if (ray.isLightingRay && !QIsFull()) {\n        // lighting ray just keeps traveling\n        if (kTransmission) {\n            float R = reflectAmount(mtls[ms1.mtl].ior, mtl2.ior, dot(ray.rd, -hit.hf_nrm));\n            ray.amt *= 1.0 - mtl2.opacity;\n            ray.amt *= 1.0 - R;\n            ray.ro = hit.pnt - hit.hf_nrm * gMarchEps * 4.0;\n            QEnqueue(ray);\n        }\n        return v0;\n    }\n    \n    float dif;\n    vec4  rfl;\n    vec4  trn;\n    vec3  tmpAmt;\n    \n    thisRayWalksIntoAnInterface(\n        ray.rd,\n        hit.hf_nrm,\n        mtl1.ior,\n        mtl2.ior,\n        mtl2.opacity,\n        dif,\n        rfl,\n        trn);\n         \n    // diffuse\n    float normal_dot_light = dot(hit.of_nrm, gLightDir);\n    vec3 alb = albedo(hit);\n    float shade = sat(normal_dot_light);\n    tmpAmt = ray.amt * dif * alb * shade;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    \n    // subsurface\n    // this has issues.\n    #if SUBSURFACE\n    tmpAmt = ray.amt * dif * alb * (sat(-normal_dot_light + 0.5));\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 5.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    #endif\n    \n    // reflect\n    tmpAmt = ray.amt * rfl.w;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // in the reflect direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = rfl.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n    // transmit\n    tmpAmt = ray.amt * trn.w;\n    if (kTransmission && vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // in the refraction direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = trn.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n\n    // return ambient lighting, no new ray.\n    return ray.amt * gAmbient * alb * dif;\n}\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff part two\n\nconst float cPipScale = 0.45;\nvec2  gMouse;\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn        =  KEY_TOGGLED(ZRO + 1, iChannel3);\n    kXEyedStereo  =  KEY_TOGGLED(ZRO + 2, iChannel3);\n    kCuttingPlane =  KEY_TOGGLED(ZRO + 3, iChannel3);\n    kZoom         =  KEY_TOGGLED(ZRO + 4, iChannel3);\n    kAA           =  KEY_TOGGLED(ZRO + 5, iChannel3);\n    kTransmission = !KEY_TOGGLED(ZRO + 6, iChannel3);\n    \n    #if HQ\n    kAA = true;\n    #endif\n}\n\nvoid readMouse() {\n    if (texelFetch(iChannel2, ivec2(3, 0), 0).r == 0.0) {\n        // This texel should be != 0,\n        // so we conclude buffers are broken on this platform.\n        // see https://www.shadertoy.com/view/McsXRM\n        \n        if (dot(iMouse.xy, iMouse.xy) < 75.0 * 75.0) {\n            gMouse = vec2(gT, 0.75 * RES.y);\n\n        }\n        else {\n            gMouse = iMouse.xy;\n        }\n    }\n    else {\n        gMouse = texelFetch(iChannel2, ivec2(0), 0).xy;\n        gMouse.x += 140.0;\n    }\n}\n\n\n\n// sdScene() does not include a floor,\n// because ray-marching infinite planes is a drag.\n// but sometimes we want such a thing.\nMST sdSceneWithFloor(in vec3 p) {\n    MST ms = sdScene(p);\n    opUnion(ms, MST(p.y, gMtlFloor));\n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    return ms;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalScene(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdSceneWithFloor(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n\n\n//-----------------------------------------------------------\n// material stuff\n\n\nvec3 albedo(hit_t hit) {\n    uint mtl = hit.ms.mtl;\n    vec3 rgb = mtls[mtl].albedo;\n    if (mtl == gMtlFloor) {\n        float f  = 0.0;\n        vec2  xz = mod(hit.pnt.xz * rot2(pi/6.0) + 10.0, 20.0) - 10.0;\n        f  = max(f, smoothstep(1.5, 1.0, abs(xz.x)));\n        f  = max(f, smoothstep(1.5, 1.0, abs(xz.y)));\n        f *= smoothstep(200.0, 100.0, length(hit.pnt.xz));\n        rgb = mix(rgb, rgb * 1.3, f);\n    }\n    return rgb;\n}\n\nfloat ior(MST ms) {\n    const float atmosphere = 1.0;\n\n    if (ms.dist > 0.0) {\n        return atmosphere;\n    }\n    \n    return mtls[ms.mtl].ior;\n}\n\nvec3 sky(ray_t ray) {\n\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(ray.rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(ray.rd, gLightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(ray.rd.z, ray.rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(ray.rd.y)));\n    return c;\n}\n\n//--------------------------------------------------------------------------\n// ray-vs scene stuff\n\nvoid rayVsFloor(ray_t ray, inout hit_t hit) {\n    float t = rayVsPlane(ray.ro, ray.rd, vY, 0.0);\n    if (t > 0.0 && (!hit.hit || t < hit.t)) {\n        hit.t   = t;\n        hit.hit = true;\n        hit.pnt = ray.ro + ray.rd * t;\n        hit.of_nrm = vY;\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = MST(0.0, gMtlFloor);\n    }\n}\n\nvoid rayMarch(ray_t ray, inout hit_t hit) {\n\n    float t = 0.0;\n    \n    MST ms;\n    uint n;\n    vec3 p;\n    for (n = 0u; n < gMaxMarchSteps; ++n) {\n    \n        // if our hit already has a hit\n        // and our t is not closer than it, return.\n        if (hit.hit && t >= hit.t) {\n            return;\n        }\n    \n        // sample the map (without floor)\n        p        = ray.ro + ray.rd * t;        \n        ms       = sdScene(p);\n        float d  = abs(ms.dist);\n\n        if (d < gMarchEps) {\n            // close to a surface!\n            // mark it the hit & return\n            hit.hit    = true;\n            hit.t      = t;\n            hit.pnt    = p;\n            hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n            hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n            \n            // the hit should be from the new material. need to re-sample.\n            hit.ms     = sdScene(p - hit.hf_nrm * gMarchEps * 2.0);\n            return;\n        }\n        \n        // advance\n        t += d * gMarchUnderstep;\n        \n        // if we're just too far away, return.\n        if (t > gMarchMaxT) {\n            return;\n        }\n    }\n    \n    if (t < 1e4 * gSceneScale) {\n        // ran out of steps.\n        hit.hit = true;\n        hit.t   = t;\n        hit.pnt = p;\n        hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = ms;        \n    }\n}\n\nhit_t rayVsScene(ray_t ray) {\n    hit_t hit;\n    hit.hit = false;\n    hit.t   = 1e9;\n    \n    rayVsFloor(ray, hit);\n    rayMarch  (ray, hit);\n    \n    return hit;\n}\n\nvec3 runRays() {\n\n    vec3 rgb = v0;\n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty() && rayCount < gMaxRays) {\n        rgb += runRay(QDequeue());\n        rayCount += 1u;\n    }\n    \n    if (rayCount >= gMaxRays) {\n    //    gDebugRGB.g = 1.0;\n    }\n    \n    return rgb;\n}\n\n//--------------------------------------------------------------------------\n// viewport, camera, initial ray stuff.\n\nray_t getCameraRay(vec2 xy, float stereoOffset) {\n    ray_t ret;\n    \n    vec3 lookFrom = vZ * gCamDist * gSceneScale;\n    float rX      = gT * 0.1;\n    float rY      = 0.0;\n    rX = (gMouse.x / RES.x * 2.0 - 1.0) * pi * -1.2;\n    rY =  smoothstep(1.0, 0.0, gMouse.y / RES.y) * pi * 0.49;\n    \n    lookFrom.yz  *= rot2(rY);\n    lookFrom.xz  *= rot2(rX);\n    lookFrom.y    = max(0.1, lookFrom.y);\n    gCamPos       = lookFrom;\n         \n    vec3 lookTo   = gSceneCenter;\n    \n    vec3 camFw    = normalize(lookTo - lookFrom);\n    vec3 camRt    = normalize(cross(camFw, vY));\n    vec3 camUp    = cross(camRt, camFw);\n    \n    ret.ro            = lookFrom;\n    ret.ro           += camRt * stereoOffset;\n    ret.rd            = normalize(camFw + (xy.x * camRt + xy.y * camUp) / gFOVZoom);\n    ret.amt           = v1;\n    ret.isLightingRay = false;\n        \n    return ret;\n}\n      \n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    // over-large time introduce precision problems\n    gT = mod(iTime, float( 60 * 60 * 4));\n    \n    readKeyboard();\n    readMouse();\n    \n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n    \n    vec2  xy           = VIEWFROMSCREEN(XY);\n    float stereoOffset = 0.0;\n    \n    if (kXEyedStereo) {\n        float f = sign(xy.x);\n        xy.x -= f * VIEWFROMSCREEN_DIST(RES.x / 2.0);\n        xy   *= 2.0;\n        stereoOffset = -f * gStereoSep * gSceneScale;\n    }\n    \n    setupScene();\n        \n    QClear();\n    \n    if (kAA) {\n        vec2 aa = vec2(1, -1) * 0.3 / MINRES;\n        QEnqueue(getCameraRay(xy + aa.xx, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.xy, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.yx, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.yy, stereoOffset));\n    }\n    else {\n        QEnqueue(getCameraRay(xy, stereoOffset));\n    }\n    \n    float rootRayCount = float(QCount());\n\n    vec3 c  = runRays();\n    \n    c      /= rootRayCount;\n    c      *= 1.0 - pow(lengthSqr(XY/RES - 0.5) * 1.8, 3.0);\n    c       = pow(c, vec3(1.0 / 2.2));\n    c      += gDebugRGB;\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        c = mix(cCool, cHot, pow(temp, 0.6));\n    }\n    \n    RGBA    = vec4(c, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst vec4  v40 = v01.xxxx;\nconst vec4  v41 = v01.yyyy;\nconst float pi  = 3.14159265359;\n\n//---------------------------------------------------\n// Screen-to-View stuff\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (min(iFrame,0))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n\n\n//---------------------------------------------------\n// math conveniences\n#define saturate(v) ( clamp((v), 0.0, 1.0) )\nfloat lengthSqr(vec3 a) { return dot(a, a); }\nfloat lengthSqr(vec2 a) { return dot(a, a); }\nfloat sqr(float a) { return a * a; }\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nint   vmax(ivec2 A) { return max(    A.x, A.y); }\nfloat vmax( vec2 A) { return max(    A.x, A.y); }\nfloat vmax( vec3 A) { return max(max(A.x, A.y), A.z); }\nint   vmin(ivec2 A) { return min(    A.x, A.y); }\nfloat vmin( vec2 A) { return min(    A.x, A.y); }\nfloat vmin( vec3 A) { return min(min(A.x, A.y), A.z); }\nfloat sat (float A) { return clamp(A,      0.0 ,      1.0 ); }\nvec2  sat ( vec2 A) { return clamp(A, vec2(0.0), vec2(1.0)); }\nvec3  sat ( vec3 A) { return clamp(A, vec3(0.0), vec3(1.0)); }\n#define V2(A, B   )    ( vec2(A, B      ) )\n#define V3(A, B, C)    ( vec3(A, B, C   ) )\n#define V4(A, B, C, D) ( vec4(A, B, C, D) )\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    \n    // if true, this is a ray looking for the light.\n    bool  isLightingRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\nstruct mtl_t {\n    vec3  albedo;\n    float opacity;         // opacity at the surface\n    float ior;\n    vec4  absorption;      // <vec3, permeability>\n};\n\n//--------------------------------------------------------------------------\n// optics\n\n// A modified Schlick's approximation\n// where reflectamount -> 0 as n2 -> n1.\nfloat reflectAmount(float n1, float n2, float incidentDotNormal) {\n    // from https://en.wikipedia.org/wiki/Schlick%27s_approximation \n    float R0 = sqr((n1 - n2) / (n1 + n2));\n    float R  = R0 + (1.0 - R0) * pow(1.0 - incidentDotNormal, 5.0);\n\n    // Schlick's approximation seems invalid when n1 ~= n2.\n    // Compensate with an additional fudge.\n    // https://physics.stackexchange.com/q/794963\n    float ndiffSqr      = sqr(n1 - n2);\n    float elenzilFudge  = ndiffSqr / (ndiffSqr + 0.01);\n    R                  *= elenzilFudge;\n\n    return R;\n}\n\n// n1 == n2          -> no reflection\nvoid thisRayWalksIntoAnInterface(\n    //  direction of the incoming ray.\n    in  vec3  incident,\n    \n    //  surface normal.\n    in  vec3  hit_facing_normal,\n    \n    //  indices of refraction.\n    in  float n1,\n    in  float n2,\n    \n    in  float opacity,\n    \n    //  amount allocated to diffuse lighting\n    out float out_sDiffuse,\n    \n    //  direction and amount for specular reflection\n    out vec4  out_vReflect,\n    \n    //  direction and amount for transmission\n    out vec4  out_vTransmit\n    ) {\n    \n    // 0 = transmit 1 = reflect 1\n    float transmitVsReflect = reflectAmount(n1, n2, dot(incident, -hit_facing_normal));\n    \n    // check for total internal reflection.\n    float eta     = n1 / n2;\n    out_vTransmit.xyz = refract(incident, hit_facing_normal, eta);\n    if (dot(out_vTransmit.xyz, out_vTransmit.xyz) == 0.0) {\n        // total internal\n        transmitVsReflect = 1.0;\n    }\n    \n    float amtDiffuse  = (1.0 - transmitVsReflect) * opacity;\n    float amtReflect  = transmitVsReflect;\n    float amtTransmit =  1.0 - amtDiffuse - amtReflect;\n    \n    out_sDiffuse      = amtDiffuse;\n    out_vTransmit.w   = amtTransmit;\n    out_vReflect.w    = amtReflect;\n    out_vReflect.xyz  = reflect(incident, hit_facing_normal);\n}\n\n//--------------------------------------------------------------------------\n\n// Queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n// CSG Operations.\n// These all mutate the first argument and return void.\n// MST types are used only where sensible.\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opReplace(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\nvoid opReplace(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/smin/\n// polynomial smooth min\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Ml3fWj\n// return.w must be added to the distance.\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n// Orion Elenzil\n// From https://www.shadertoy.com/view/43l3zr\n//\n// repeats the origin 'reps' times\n// around a ring of radius 'rad'.\n//\n// reps must be a positive integer.\n//\n// returns:\n//   v.xy = new coordinates\n//   v.z  = cell index, [0, reps - 1].   \nvec3 opRing(in vec2 p, float rad, float reps) {\n    float scale = pi * 2.0 / reps;\n    float theta;\n    float cell;\n    float isEven;\n    \n    // theta in [-𝜋, 𝜋]\n    theta  = atan(p.y, p.x);\n    \n    // scale theta to [-reps/2, reps/2]\n    theta /= scale;\n\n    // determine cell index\n    isEven = float((int(reps) + 1) % 2);\n    cell   = theta + (reps + isEven) / 2.0;\n    cell   = floor(mod(cell, reps));\n\n    // repeat space. theta in [-1/2, 1/2]\n    theta  = fract(theta + 0.5) - 0.5;\n    \n    // scale up again\n    theta *= scale;\n    \n    // polar to cartesian\n    p      = vec2(cos(theta), sin(theta)) * length(p);\n\n    // move the origin onto the ring\n    p.x   -= rad;\n\n    // align +x to be counter-clockwise along the ring.\n    // this might not be what you want,\n    // but it seems natural to me.\n    p      = vec2(p.y, -p.x);\n\n    return vec3(p, cell);\n}\n\n\n//--------------------------------------------------------------------------------\n// Signed Distance Field Primitives\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//--------------------------------------------------------------------------------\n// Analytic ray-vs-primitives\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n", "buffer_a_code": "// mouse handling.\n// outputs non-normalized mouse as (0,0).xy.\n// defaults to iResolution.xy / 2.\n// resets when mouse is in lower-left.\n// https://www.shadertoy.com/view/Mf2GDy\n// orion elenzil January 2024.\n\n// Wrapping mode for X and Y:\n// 0u = unconstrained\n// 1u = clamp\n// 2u = wrap\nconst uvec2 wrap = uvec2(0u, 1u);\n\n// initial position (normalized)\nconst vec2  p0   = vec2(0.5, 0.75);\n\n// when actual mouse is within this radius\n// in the lower-right, reset to p0.\nconst float resetCircle = 75.0;\n\n// 1 to visualize the mouse position and reset circle.\n#define VISUALIZE 0\n\n// special texels\nconst ivec2 pos = ivec2(0, 0);\nconst ivec2 btn = ivec2(1, 0);\nconst ivec2 hrt = ivec2(3, 0);\n\n\n// data[0] <- bool mouseIsDown\n// data[1] <- bool mouseJustBecameDown\n// data.zw <- current mouse pos\nvoid trackButton(inout vec4 data) {\n    bool mouseIsDown         = iMouse.z > 0.0;\n    bool mouseWasDown        = bool(data[0]);\n    bool mouseJustBecameDown = !mouseWasDown && mouseIsDown;\n    \n    data[0] = float(mouseIsDown);\n    data[1] = float(mouseJustBecameDown);\n    data.zw = iMouse.xy;\n}\n\n// data.xy <- cumulative mousePos\n// data.zw <- raw last mousePos\nvoid trackMouse(inout vec4 data, in vec4 button) {\n    bool mouseIsDown = bool(button[0]);\n    bool mouseJustBecameDown = bool(button[1]);\n    vec2 mouse = button.zw;\n\n    vec2 home = p0 * iResolution.xy + 8.2 * iTime * v01.yx;\n    \n    if (iFrame == 0) {\n        data.xy = home;\n        data.zw = mouse;\n        return;\n    }\n\n    if (dot(iMouse.xy, iMouse.xy) < resetCircle * resetCircle) {\n        data.xy = mix(data.xy, home, 0.1);\n        data.zw = mouse;\n        return;\n    }\n    \n    if (!mouseIsDown) {\n        return;\n    }\n    \n    if (mouseJustBecameDown) {\n        data.zw = mouse;\n    }\n    \n    vec2 prevMouse = data.zw;\n    vec2 deltMouse = mouse - prevMouse;\n    \n    data.xy += deltMouse;\n    \n    for (int n = 0; n < 2; ++n) {\n        switch (wrap[n]) {\n            case 0u:\n                break;\n            case 1u:\n                // clamp\n                data[n] = clamp(data[n], 0.0, iResolution[n] - 1.0);\n                break;\n            case 2u:\n                // wrap\n                data[n] = mod(data[n], iResolution[n]);\n                break;\n        }\n    }\n    \n    data.zw = mouse;\n}\n\n// buffers are currently 100% broken on all browsers on iOS.\n// this provides a work-around so shaders can detect that.\nvoid trackHeartbeat(inout vec4 RGBA) {\n    RGBA.r = 1.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA = texelFetch(iChannel2, IJ, 0);\n    \n    if (iFrame == 0) {\n        RGBA = vec4(0);\n    }\n    \n    if (IJ == btn) {\n        trackButton(RGBA);\n        return;\n    }\n    \n    vec4 button = texelFetch(iChannel2, btn, 0);\n    \n    if (IJ == pos) {\n        trackMouse(RGBA, button);\n        return;\n    }\n    \n    if (IJ == hrt) {\n        trackHeartbeat(RGBA);\n        return;\n    }\n    \n    \n#if VISUALIZE    \n    vec4 mouse = texelFetch(iChannel2, pos, 0);\n    \n    vec2  p = XY;\n    float d = 1e9;\n    d = min(d, abs(length(p) - resetCircle));\n    float a = atan(p.y, p.x) * 20.0 - iTime;\n    d += smoothstep(-0.2, 0.2, sin(a));\n    d = min(d, abs(length(p - mouse.xy) - 20.0) - 2.0);\n    d = min(d, abs(length(p - mouse.zw) - 10.0) - 2.0);\n    float c = smoothstep(2.0, 0.0, d);\n    \n    RGBA.rgb = vec3(c);\n#else\n    discard;\n#endif\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/l3dXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3156, 3334, 3353, 3353, 3996], [3999, 4085, 4109, 4109, 4724], [5036, 5057, 5081, 5081, 8856], [8858, 9011, 9032, 9032, 9425], [9427, 9427, 9445, 9445, 9942], [9946, 10075, 10108, 10108, 10245], [10247, 10293, 10319, 10319, 10536], [10539, 10621, 10645, 10645, 11057], [11059, 11059, 11078, 11078, 11207], [11209, 11209, 11230, 11230, 11737], [11739, 11839, 11884, 11884, 12203], [12205, 12205, 12248, 12248, 13669], [13671, 13671, 13700, 13700, 13835], [13837, 13837, 13853, 13853, 14116], [14118, 14236, 14285, 14285, 15106], [15115, 15115, 15158, 15210, 16667]], "test": "error"}
{"id": "43dSD2", "name": "Learning Agains 3", "author": "prishainabox", "description": "Sources (more in code)\nhttps://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\nSooo cool how this video distorted the camera (see raymarchOp function)\nhttps://www.youtube.com/watch?v=khblXafu7iA", "tags": ["raymarching"], "likes": 0, "viewed": 10, "published": 3, "date": "1719605976", "time_retrieved": "2024-07-07T01:17:45.362241", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;        \n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define AA       1\n#define MAX_DIST 100.0\n#define CAM_DIST 2.0\n#define PI       3.14159\n#define FOV      0.9\n#define CS(a)    vec2( cos(a), sin(a) )\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n/***************************************************************************/\n\n// https://www.shadertoy.com/view/4djSRW\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1, 113.5,271.9,124.6) ) *43758.5453123)\n\n/***************************************************************************/\n\n// https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n    k *= 4.0;\n    // 0 to 1, spikes when a and b are near\n    float h = max( k-abs(a-b), 0.0); \n    return min(a,b) - h*h/(4.0*k);\n}\n\n// \nfloat smax(float a, float b, float k) {\n    k *= 4.0;\n    float h = max( k-abs(a-b), 0.0);\n    return max(a,b) + h*h/(4.0*k);\n\n}\n\n/***************************************************************************/\n\nfloat sdSphere(in vec3 pt, in float r) {\n    return length(pt) - r;\n}\n\n// https://www.youtube.com/watch?v=8--5LwHRhjk\nfloat sdEllipsoid(in vec3 pt, in vec3 r) {\n    float a = length(pt / r);\n    return (a*a - a) / length(pt / r*r);\n}\n\n// https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat sdBox(in vec3 pt, in vec3 r) {\n    return length(max(abs(pt) - r, vec3(0.0)));\n}\n\n/***************************************************************************/\n\nfloat sdfOp(in vec3 pt) {\n\n    float d = MAX_DIST;\n    float time = iTime;\n    \n    // rotating cube and sphere\n    {\n        float sf = 1.2; //scaling factor\n        vec3 p = pt- vec3(0,0.7,0);\n        p.yz *= rot(PI/4.0 + iTime);    \n        p.xz *= rot(PI/2.0 + iTime);\n\n\n        d =  min( d, sdBox(p*sf, vec3(0.5)) / sf );\n        d = smin( d, sdSphere(pt - 1.6 * vec3(sin(time * 0.7), 0.5, 0.0), 0.5), 0.2);\n    }\n    \n    // repeating cubes\n    {\n        vec3 q = pt - vec3(2, -0.3, 2);\n        vec3 m = vec3(1);\n        q = mod(q, m) - m*0.5;\n        d = smin(d, sdBox(q, vec3(0.1)) - 0.01, 0.1);\n    }\n    \n    // floor\n    {\n        float fl = pt.y + 0.1;// - 0.1*cos(5.0 * atan(pt.z, pt.x));\n        d = smin(d, fl, 0.1);\n    }\n\n    return d;\n\n}\n\n/***************************************************************************/\n\nvec3 calcNormalOp(in vec3 pt) {\n    vec2 h = vec2(0.001, 0);\n    return normalize(vec3(\n        sdfOp(pt + h.xyy) - sdfOp(pt - h.xyy),\n        sdfOp(pt + h.yxy) - sdfOp(pt - h.yxy),\n        sdfOp(pt + h.yyx) - sdfOp(pt - h.yyx)   \n    ));\n}\n\n/***************************************************************************/\n\nfloat raymarchOp(vec3 ro, vec3 rd, float tmin, float tmax, inout int steps) {\n\n    float td = tmin;\n    \n    int i;\n    for (i = 0; i < 80; i++) {\n    \n        vec3 p = ro + rd*td;\n        \n        // weird transform 1 from https://www.youtube.com/watch?v=khblXafu7iA\n        p.xy *= rot(td * 0.15);\n    \n        float d = sdfOp(p);\n        \n        // weird transform 2\n        rd.y += (d) * 0.02;\n        \n        td += d;\n        \n        if (abs(d) < 0.001 || td > tmax) break;\n    \n    }\n    \n    steps = i;\n    return td;\n\n}\n\n/***************************************************************************/\n\nvec3 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n\n    vec3 clr = vec3(1);\n    \n    int steps = 0;\n    float d = raymarchOp(ro, rd, 0.01, MAX_DIST, steps);\n    \n    \n    // vec3 nor = calcNormalOp(ro + rd*d);\n    // clr = nor * 0.5 + 0.5;\n    // clr = vec3(1.0 - d * 0.05 * d);\n    // clr = vec3(smoothstep(25.0, 0.0, d*d));\n    // clr = vec3(d * 0.12);\n    \n    \n    clr = vec3(smoothstep(0.0, MAX_DIST * 0.2, d)) + 0.001*float(steps);\n\n    \n  //if(d > 0.0 && d < MAX_DIST) {\n        // vec3 nor = calcNormalOp(ro + rd*d);\n        //clr += 0.5 * (nor * 0.5 + 0.5);\n  //}\n    \n    \n    clr = pow(clr, vec3(0.4545));\n\n    return clr;\n\n}\n\n/***************************************************************************/\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + FOV * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // if (iFrame != 0) discard;\n\n    float time = iTime;\n    vec2 res = iResolution.xy;\n    vec2 mouse = (iMouse.xy * 2.0 - res.xy) / res.y;\n    \n    // target\n    vec3 target = vec3(0, 0, 0);\n    vec3 ro;\n    \n    // ray origin \n    // float movX = -20.0 * mouse.x/res.x + 10.0;\n    // float movY = -20.0 * mouse.y/res.y + 10.0;\n    // float r = 4.5;\n    // vec3 ro = target + vec3(sin(movX) * r,  movY, cos(movX) * r);\n    // vec3 ro = target + vec3(0, 0, 3);\n    \n    // ray origin - spherical coordinates\n    { \n        float rho   = CAM_DIST; // distance\n        float phi   = max(PI*0.1, (mouse.y * 0.5 + 0.5) * 0.5 * PI);\n        float theta = mouse.x * 2.0 * PI;\n        float rad   = rho * sin(phi);\n        ro = target + vec3( rad * cos(theta), rho * cos(phi), rad * sin(theta) );\n    }\n    \n    // accumulate color\n    vec3 clr = vec3(0.0);\n    \n    #if AA > 1\n    \n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n\n\n        // Normalized pixel coordinates\n        vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n        # else\n        vec2 f = fragCoord;\n        \n    #endif\n    \n        vec2 uv = (2.0 * f - res) / res.y;\n        vec3 rd = setCamera(uv, ro, target);\n\n        // calculate color\n        vec3 c = render(uv, ro, rd);\n\n        clr += c;\n\n    #if AA > 1    \n    \n    }}    \n    \n    clr /= float(AA*AA);\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(clr, 1);\n    \n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/43dSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 162]], "test": "error"}
{"id": "McKSDy", "name": "Techno Sequence Test 1", "author": "taylormatson", "description": "st", "tags": ["st"], "likes": 3, "viewed": 86, "published": 3, "date": "1719602813", "time_retrieved": "2024-07-07T01:17:46.252375", "image_code": "#define time2 iTime*BPM_TO_TIME // use for env\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float phase = 0.0;\n    float wN = whole(time2, phase);\n    float qN = quarter(time2, phase);\n    float sN = sixteenth(time2, phase);\n    \n    \n    // Output to screen\n    fragColor = vec4(1.0)-qN;\n}", "image_inputs": [], "sound_code": "#define time2 time*BPM_TO_TIME // use for env, not osc\n\nvec2 mainSound( int samp, float time )\n{\n    float pc = 120./BPM; // Pitch correction - not in use\n    \n    float dest = 0.; // desitnation bus\n    \n    float kick_env = 2.*exp(-6.*quarter(time2, 0.));\n    float kick_osc = sin(TAU*58.*time);\n    \n    dest += (kick_env*kick_osc);\n    \n    float bass_env = sin(100.*exp(-10.*whole(time2, .25)));\n    float bass_osc = sin(TAU*30.*time);\n    \n    dest += (.5*bass_env*bass_osc);\n    \n    float ch_env = .01+exp(-10.*sixteenth(time2, 0.));\n    float ch_osc = random(time);\n    \n    dest += .1*(ch_env*ch_osc);\n    \n    float oh_env = .01+exp(-10.*quarter(time2, .5));\n    float oh_osc = random(time);\n    \n    dest += .1*(oh_env*oh_osc);\n    \n    return vec2(dest);\n    \n}", "sound_inputs": [], "common_code": "#define PI 3.1415926535\n#define TAU 6.2831853071\n#define BPM 120.\n#define BPM_TO_TIME (1./120.)*BPM\n\n// Time Signatures\nfloat whole     (float time, float phase){ return fract(time   +phase); }\nfloat quarter   (float time, float phase){ return fract(time*2.+phase); }\nfloat sixteenth (float time, float phase){ return fract(time*8.+phase); }\n\n// Function to generate pseudo-random noise\nfloat random(float time) {\n    return fract(sin(dot(time, 78.233)) * 43758.5453123);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McKSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 105, 308]], "test": "error"}
{"id": "43dXDj", "name": "noisyRotations", "author": "tetrismegistus", "description": "learning noise and grids", "tags": ["noise", "grid"], "likes": 3, "viewed": 112, "published": 3, "date": "1719595749", "time_retrieved": "2024-07-07T01:17:47.119560", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec2 permute(const in vec2 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec3 permute(const in vec3 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec4 permute(const in vec4 v) { return mod289(((v * 34.0) + 1.0) * v); }\n\n#endif\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    return p;\n}\n#endif\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec2 snoise2( vec2 x ){\n    float s  = snoise(vec2( x ));\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n\n#endif\n\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n#define PI 3.14159265358979323846\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size, _size + aa, _st);\n    uv *= smoothstep(_size, _size + aa, vec2(1.0) - _st);\n    return uv.x * uv.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 getGridColor(vec2 uv, vec2 translate, float timeOffset, vec2 size, float smoothEdges) {\n    uv += translate * 0.9;\n    vec2 localUV = fract(uv); // Get local UV within the grid cell\n    localUV -= vec2(0.5);     // Move to center\n    localUV = rotate2d(sin(iTime + timeOffset) * PI) * localUV; // Rotate locally\n    localUV += vec2(0.5);     // Move back to original position\n    \n    vec3 blue = vec3(0.455,0.537,0.753);\n    vec3 orange = vec3(0.961,0.318,0.035);\n    vec3 offWhite = vec3(0.941,0.918,0.776);\n    \n    vec3 verGrad = mix(orange, blue, uv.y);\n    vec3 horGrad = mix(offWhite, blue, uv.x);\n    vec3 mixGrad = mix(mix(offWhite,blue, .1 + localUV.x * sin(iTime) + localUV.y * cos(iTime)), mix(verGrad, horGrad, -abs(sin(iTime + localUV.x) * .5)), localUV.x * localUV.y);    \n\n    \n    \n    return (mixGrad * box(localUV, size, smoothEdges));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;    \n    \n    \n    vec2 pos = vec2(uv * 2.0);\n\n    // Use the noise function\n    float n = snoise(vec3(pos.x, pos.y, iTime * .5));\n    \n    \n    vec3 col = vec3(0.0);\n    vec2 translate1 = vec2(cos(iTime), sin(iTime));\n    vec2 translate2 = vec2(sin(iTime), cos(iTime));\n    vec2 translate3 = vec2(cos(iTime), cos(iTime));\n        \n    vec2 uv1 = uv * 10.0 + 0.5;\n    col += getGridColor(uv1 * n, translate1, 0.0, vec2(0.25, 0.25), 0.01);\n\n    vec2 uv2 = uv * 10.0 + 0.8;  // Adjusted initial UV for the second grid\n    col += getGridColor(uv2 * n, translate2, 10.0, vec2(0.5, 0.5), 0.01);\n    \n    vec2 uv3 = uv * 10.0 - 0.3;  // Adjusted initial UV for the third grid\n    col += getGridColor(uv3 * n, translate3, 15.0, vec2(0.75, 0.75), 0.01);\n\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/43dXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8737, 8750, 8777, 8777, 8894], [8931, 8931, 8983, 8983, 9188], [9190, 9190, 9218, 9218, 9304], [9306, 9306, 9398, 9398, 10167], [10171, 10171, 10228, 10279, 11150]], "test": "error"}
{"id": "X3dSDj", "name": " triagle box sphere if tunnel", "author": "nayk", "description": "combination originals https://www.shadertoy.com/view/Nsy3Dy", "tags": ["fractal", "space", "cineshader"], "likes": 1, "viewed": 91, "published": 3, "date": "1719593127", "time_retrieved": "2024-07-07T01:17:48.013179", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(10,23,21))*1.5+.5)\nfloat intensity = 1.0;\nfloat radius = 0.05;\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n//Distance functions from\n//https://iquilezles.org/articles/distfunctions2d\nfloat triangleDist(vec2 p){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n    vec2 d = abs(p)-1.0;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 uv2 =C/iResolution.xy-0.5;\n    vec2 uv =C/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre;\n    vec2 pos;\n\n    float t = -iTime * 0.05;\n   \n    float dist;\n    float glow;\n    vec3 col = vec3(0);\n   \n    //The spacing between shapes\n    const float scale = 150.0;\n    //Number of shapes\n    const float layers = 10.0;\n   \n    float depth;\n    vec2 bend;\n   \n    const vec3 purple = vec3(0.611, 0.129, 0.909);\n    const vec3 green = vec3(0.133, 0.62, 0.698);\n   \n    float angle;\n    float rotationAngle;\n    mat2 rotation;\n   \n    //For movement of the anchor point in time\n    float d = 2.5*(sin(t) + sin(3.0*t));\n\n    //Create an out of frame anchor point where all shapes converge to    \n    //vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    vec2 anchor = vec2(0.5);\n\n    //Create light purple glow at the anchor loaction\n    pos = anchor - uv;\n    pos.y /= widthHeightRatio;\n    dist = length(pos);\n    glow = getGlow(dist, 0.35, 0.9);\n    col += glow * vec3(0.2,0.2,0.20);\n   \nfor(float i = 0.0; i < layers; i++){\n       \n       \n        depth = fract(i/layers + t);\n\n        //Move the focus of the camera in a circle\n        //centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        centre = vec2(0.5);\n        //Position shapes between the anchor and the camera focus based on depth\n        bend = mix(anchor, centre, depth);\n     \n        pos = bend - uv;\n    pos.y /= widthHeightRatio;\n\n        //Rotate shapes\n        rotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + i;\n        rotation = mat2(cos(rotationAngle), -sin(rotationAngle),\n                        sin(rotationAngle),  cos(rotationAngle));\n       \n        pos *= rotation;\n       \n        //Position shapes according to depth\n    pos *= mix(scale, 0.0, depth);\n   \n        float m = mod(i, 3.0);\n        if(m == 0.0){\n        dist = abs(boxDist(pos));\n        }else if(m == 1.0){\n        dist = abs(triangleDist(pos));\n        }else{\n        dist = abs(circleDist(pos));\n        }\n       \n        //Get glow from base radius and intensity modified by depth\n    glow = getGlow(dist, radius+(1.0-depth)*2.0, intensity + depth);\n       \n        //Find angle along shape and map from [-PI; PI] to [0; 1]\n        angle = (atan(pos.y, pos.x)+3.14)/6.28;\n        //Shift angle depending on layer and map to [1...0...1]\nangle = abs((2.0*fract(angle + i/layers)) - 1.0);\n       \n        //White core\n    col += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n       \n        //Glow according to angle value\n      col += glow * mix(green, purple, angle);\n}\n   \n    //Tone mapping\n    col = 1.0 - exp(-col);\n   \n    vec4 p;\n    vec3 q,r=iResolution,\n    d2=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p.xyz=g*d2*col;\n      p.z+=iTime*10.;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.z<p.w?p=p.zyxw:p;\n            p.z<p.y?p=p.xzyw:p;\n                    p.z<p.y?p=p.xzyw:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p.xyz=abs(p.xyz)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n   O*= vec4(happy_star(uv2, anim) * vec3(0.05,0.2,1.15)*5.1, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3dSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 191, 191, 337], [340, 416, 443, 443, 652], [654, 654, 676, 676, 762], [764, 764, 790, 790, 818], [820, 860, 917, 917, 959], [961, 961, 997, 997, 4574]], "test": "valid"}
{"id": "4XtSDj", "name": "message from", "author": "nayk", "description": "originals from glslsandbox.com \nhttps://www.shadertoy.com/view/4tyfWy", "tags": ["cosmos", "universe", "cineshader"], "likes": 4, "viewed": 100, "published": 3, "date": "1719593005", "time_retrieved": "2024-07-07T01:17:48.900311", "image_code": "float cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define resolution iResolution.xy\n#define time iTime\nfloat snow(vec2 uv,float scale)\n{\nfloat w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.0)return 0.;\nuv.x+=time*4./scale;\nuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=40.,d;\np=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\nk=smoothstep(0.,k,sin(f.x+f.y)*0.003);\n    return k*w;\n}\nvec2 uv3;\n\n\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 40 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n#define n0 ddigit(0x22FF);\n#define n1 ddigit(0x0281);\n#define n2 ddigit(0x1177);\n#define n3 ddigit(0x11E7);\n#define n4 ddigit(0x5508);\n#define n5 ddigit(0x11EE);\n#define n6 ddigit(0x11FE);\n#define n7 ddigit(0x2206);\n#define n8 ddigit(0x11FF);\n#define n9 ddigit(0x11EF);\n\n#define A ddigit(0x119F);\n#define B ddigit(0x927E);\n#define C ddigit(0x007E);\n#define D ddigit(0x44E7);\n#define E ddigit(0x107E);\n#define F ddigit(0x101E);\n#define G ddigit(0x807E);\n#define H ddigit(0x1199);\n#define I ddigit(0x4466);\n#define J ddigit(0x4436);\n#define K ddigit(0x9218);\n#define L ddigit(0x0078);\n#define M ddigit(0x0A99);\n#define N ddigit(0x8899);\n#define O ddigit(0x00FF);\n#define P ddigit(0x111F);\n#define Q ddigit(0x80FF);\n#define R ddigit(0x911F);\n#define S ddigit(0x8866);\n#define T ddigit(0x4406);\n#define U ddigit(0x00F9);\n#define V ddigit(0x2218);\n#define W ddigit(0xA099);\n#define X ddigit(0xAA00);\n#define Y ddigit(0x4A00);\n#define Z ddigit(0x2266);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0);\n#define s_minus   ddigit(0x1100);\n#define s_plus    ddigit(0x5500);\n#define s_greater ddigit(0x2800);\n#define s_less    ddigit(0x8200);\n#define s_sqrt    ddigit(0x0C02);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start; ch_pos.y -= 9.0;\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n  dot(p,vec2(269.5,183.3)),\n  dot(p,vec2(419.2,371.9)) );\nreturn fract(sin(q)*43758.5453);\n}\n\nfloat dseg(vec2 p0, vec2 p1)\n{\nvec2 dir = normalize(p1 - p0);\nvec2 cp = (uv3 - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\nreturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));  \n}\n\nbool bit(int n, int b)\n{\nreturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nfloat d = 1e6;\n\nvoid ddigit(int n)\n{\n\n\nfloat v = 1e6;\nvec2 cp = uv3 - ch_pos;\n    vec3 c = hash3(vec2(uv3*.001));\nif (n == 0)     v = min(v, dseg(vec2(-0.405*cos(iTime), -1.000), vec2(-0.500, -1.000)));\nif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063*sin(iTime)), vec2( 0.500*cos(iTime),  0.937)));\nif (bit(n,  1)) v = min(v, dseg(vec2( 0.438*sin(iTime),  1.000), vec2( 0.063*cos(iTime),  1.000)));\nif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438*cos(iTime),  1.000)));\nif (bit(n,  3)) v = min(v, dseg(vec2(-0.500*cos(iTime),  0.937), vec2(-0.500,  0.062*sin(iTime))));\nif (bit(n,  4)) v = min(v, dseg(vec2(-0.500*cos(iTime), -0.063*sin(iTime)), vec2(-0.500*cos(iTime), -0.938)));\nif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\nif (bit(n,  6)) v = min(v, dseg(vec2( 0.063*sin(iTime), -1.000), vec2( 0.438, -1.000)));\nif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500*cos(iTime), -0.063)));\nif (bit(n,  8)) v = min(v, dseg(vec2( 0.063*cos(iTime),  0.000*sin(iTime)), vec2( 0.438, -0.000)));\nif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\nif (bit(n, 10)) v = min(v, dseg(vec2( 0.000*cos(iTime),  0.063*cos(iTime)), vec2( 0.000,  0.937)));\nif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\nif (bit(n, 12)) v = min(v, dseg(vec2(-0.438+c.x*cos(iTime),  0.000), vec2(-0.063, -0.000)*c.yz));\nif (bit(n, 13)) v = min(v, dseg(vec2(-0.063*sin(iTime), -0.063)*c.yz, vec2(-0.438+c.x*sin(iTime), -0.938)*c.yz));\nif (bit(n, 14)) v = min(v, dseg(vec2( 0.000*cos(iTime), -0.938*cos(iTime))*c.yz, vec2( 0.000, -0.063)*c.yz));\nif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063+c.x*sin(iTime)), vec2( 0.438+c.x*sin(iTime), -0.938)));\nch_pos.x += ch_space.x+0.1*c.x*cos(iTime);\n\nd = min(d, v);\n}\nmat2 rotate(float a)\n{\nfloat c = cos(a);\nfloat s = sin(a);\nreturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\nrgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\nreturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n     vec2 uv2 =fragCoord/iResolution.xy-0.5;\n     float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + 1.07)) * 25.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\nvec2 aspect = resolution.xy / resolution.y;\nuv3 = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\nfloat _d =  1.0-length(uv);\nuv3 *= 22.0 ;\nuv3 -= vec2(-3., -2.);\n//uv *= rotate(time+uv.x*0.05);\n\nvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n\nvec3 bg_color = vec3(_d*0.4, _d*0.2, _d*0.1);\nuv2.x += 0.5+sin(time+uv3.y*0.7)*0.5;\nch_pos = ch_start;\n\n    _ _ _ _ _ S P A C E\n\n                 \n\nvec3 color = mix(ch_color, bg_color, 1.0- (0.08 / d*2.0));  // shading\n     uv2.y+=0.1;\nvec3 finalColor=vec3(0);\nfloat c=smoothstep(0.1,0.0,clamp(uv.x*.01+.99,0.,.99));\nc+=snow(uv*ma,3.)*.8;\nc+=snow(uv*ma,5.)*.7;\nc+=snow(uv,7.)*.6;\n\nc+=snow(uv*ma,9.)*.5;\n\nc+=snow(uv*ma,11.)*.4;\n\nc+=snow(uv,13.)*.3;\n\nc+=snow(uv*ma,15.)*.2;\n\nc+=snow(uv*ma,17.)*.1;\n\n \nfinalColor=(vec3(c*0.2,c*0.8,c*01.9));\nfragColor = vec4(finalColor,1)*81.0;\n\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n    fragColor+= vec4(cheap_star(uv3, anim) * vec3(0.35,0.2,0.75)*0.25, 1.0);\n    fragColor+= vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4XtSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 185], [306, 306, 339, 339, 621], [1181, 2945, 2967, 2967, 3105], [3107, 3107, 3137, 3137, 3306], [3308, 3308, 3332, 3332, 3399], [3417, 3417, 3437, 3437, 5206], [5207, 5207, 5229, 5229, 5293], [5294, 5294, 5328, 5328, 5503], [5504, 5504, 5560, 5560, 6871]], "test": "error"}
{"id": "XXtXWj", "name": "two step", "author": "tetrismegistus", "description": "continuing to learn about grids", "tags": ["grid", "learning"], "likes": 4, "viewed": 96, "published": 3, "date": "1719588479", "time_retrieved": "2024-07-07T01:17:49.754037", "image_code": "#define PI 3.14159265358979323846\n#define iTime (iTime + sin(iTime*PI*2. - PI)/(2.*PI))\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nvec4 tile(vec2 _st, float _zoom){\n    // returns space (xy) and column row info (zw)\n    _st *= _zoom;\n    float col = floor(_st.x);\n    float row = floor(_st.y);   \n    if (mod(row, 2.0) == 0.0 && mod(floor(iTime), 3.0) == 1.0) {\n        _st.x += mod(iTime, 2.0);\n    } else if (mod(col, 2.0) == 0.0 && mod(floor(iTime), 3.0) != 1.0) {\n        _st.y += mod(iTime, 2.0);\n    }\n    return vec4(fract(_st), int(floor(_st.x)), int(floor(_st.y)));\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    // Define gradient colors\n    vec3 blue = vec3(0.455,0.537,0.753);\n    vec3 orange = vec3(0.961,0.318,0.035);\n    vec3 offWhite = vec3(0.941,0.918,0.776);\n\n    // Get the grid and local coordinates within each cell\n    vec4 grid = tile(uv, 10.0);\n    vec2 localUV = grid.xy;\n\n    // Calculate the gradient for the local coordinates\n    vec3 verGrad = mix(orange, blue, localUV.y);\n    vec3 horGrad = mix(offWhite, blue, localUV.x);\n    vec3 mixGrad = mix(mix(offWhite, blue, .1 + localUV.x * sin(iTime) + localUV.y * cos(iTime)), \n                       mix(verGrad, horGrad, -abs(sin(iTime + localUV.x) * .5)), uv.x * uv.y);\n\n    // Apply the gradient to the circles\n    color = mixGrad * box(localUV, vec2(0.9, .9), .025);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXtXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 127, 127, 267], [269, 269, 313, 313, 481], [483, 483, 516, 567, 928], [930, 930, 982, 982, 1175], [1177, 1177, 1234, 1284, 2173]], "test": "error"}
