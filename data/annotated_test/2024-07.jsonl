{"id": "MflcRj", "name": "Brushed aluminium texture", "author": "jakel101", "description": "my attempt and doing a noise based brushed aluminium texture. The basic idea being you simply start with noise and then use directional blur.\nwould likely do better with added fractal noise to look sharper?\nlength and scale are fun to play with... (mouse)", "tags": ["procedural", "noise", "texture"], "likes": 0, "viewed": 8, "published": 3, "date": "1721334367", "time_retrieved": "2024-07-18T23:33:07.604139", "image_code": "#define PHI 1.6180339887\n\n// pseudo random? not great one....\nfloat hash21(in vec2 ab){\n    float a = ab.x - 0.006;\n    float b = ab.y + 0.1;\n    float h = mod(PHI, -45.4/a) * mod(PHI, -b*0.03);\n    h *= 9123.512;\n    return fract(dot(vec2(a,b),fract(vec2(h,a+b))*586.512));\n}\n\n\n// value noise ~ sorta\nfloat noise2(in vec2 ab){\n    \n    vec2 i = floor(ab);\n    vec2 f = fract(ab);\n    \n    vec2 f2 = smoothstep(0.0, 1.0, f); //\n    \n    // corners in 2D\n    // c3 - c2\n    //  |    |\n    // c0 - c1\n    float c0 = hash21(i);\n    float c1 = hash21(i+vec2(1.0,0.0));\n    float c2 = hash21(i+vec2(1.0,1.0));\n    float c3 = hash21(i+vec2(0.0,1.0));\n    \n    // reconstruct with interpolation\n    float r = mix( mix(c0, c1, f2.x),\n                   mix(c3, c2, f2.x), f2.y);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // really naive directional blur\n    vec2 m = iMouse.xy;\n    if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){m.x=400.0,m.y=420.0;};\n    float dist = m.y/10.0;\n    float scale = m.x;\n    \n    float steps = max(10.0,dist*3.0);\n    vec3 col = vec3(0);\n    for (float i = 0.0; i <= steps; i++){\n        vec2 offset = vec2((i/steps)*dist); \n        offset *= vec2(sin(iTime*0.1), cos(iTime*0.1)); // animate direction by time?\n        col += noise2((uv*scale)-offset+10.4)/steps;\n    }\n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MflcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 62, 87, 87, 276], [279, 302, 327, 327, 786], [788, 788, 845, 895, 1479]], "test": "ok"}
{"id": "lcfyRj", "name": "Checker shadow illusion, 1bit", "author": "FordPerfect", "description": "Familiar [url=https://en.wikipedia.org/wiki/Checker_shadow_illusion]checker shadow illusion[/url], now in 1bit color!\nMouse click for grayscale.", "tags": ["dither", "optical", "illusion"], "likes": 1, "viewed": 36, "published": 3, "date": "1721324939", "time_retrieved": "2024-07-18T23:33:08.359121", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Familiar checker shadow illusion, now in 1bit color.\n// Mouse click for grayscale.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float h=3.0;\n    float H=2.0;\n    float R=1.0;\n    float r=0.25;\n    vec2 C=vec2(3.0,-5.0);\n    vec2 n=normalize(vec2(-2,1));\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,h,0);\n    vec3 rd=normalize(vec3(xy+vec2(0,-0.25),-1.0));\n    vec3 col=vec3(0.625);\n    if(rd.y<0.0)\n    {\n        vec2 xz=(ro-rd*h/rd.y).xz;\n        vec2 uv=0.5*mat2(0.6,-0.8,0.8,0.6)*xz;\n        col=vec3(0.5)+0.5*mod(dot(floor(uv),vec2(1)),2.0);\n        col=mix(col,vec3(0.75),smoothstep(-0.25,0.0,rd.y));\n        vec2 d=xz-C;\n        if(dot(n,d)>0.0) col*=0.5+0.5*smoothstep(R+0.05*dot(n,d),R+0.5*dot(n,d),abs(n.x*d.y-n.y*d.x));\n        vec2 A=rd.xz,B=ro.xz-C;\n        float a=dot(A,A),b=dot(A,B),c=dot(B,B)-R*R;\n        float t=b*b-a*c;\n        if(t>0.0)\n        {\n            t=(-b-sqrt(t))/a;\n            vec3 D=ro+t*rd;\n            if(D.y>0.0)\n            {\n                if(D.y<H) col=vec3(0.5+0.375*normalize(D.xz-C).x);\n                else\n                {\n                    t=(H-h)/rd.y;\n                    D=ro+t*rd;\n                    if(length(D.xz-C)<R) col=vec3(0.625);\n                }\n            }\n        }\n    }\n    // Dithering.\n    const int M[16]=int[16](\n         0, 8, 2,10,\n        12, 4,14, 6,\n         3,11, 1, 9,\n        15, 7,13, 5);\n    if(iMouse.z<=0.0) col=floor(col+(float(M[(int(fragCoord.x)&3)+4*(int(fragCoord.y)&3)])+0.5)/16.0);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfyRj.jpg", "access": "api", "license": "public-domain", "functions": [], "test": "ok"}
{"id": "MffcR2", "name": " Adventure", "author": "wyatt", "description": "I asked chatGTP if it was a photo, but it could tell it was digital art.", "tags": ["noise", "scene"], "likes": 10, "viewed": 63, "published": 3, "date": "1721316463", "time_retrieved": "2024-07-18T23:33:09.112108", "image_code": "Main {\n    \n    float h = 1.-.8*exp(-.01*abs(U.y-.4*R.y));\n    \n       \n    \n    if (U.y < .4*R.y) {\n        U.y = abs(-U.y+.8*R.y);\n        U.x += 30.*sin(100.*U.y/R.y)+5.*sin(39.*U.x/R.y);\n        U.y += 30.*sin(100.*U.y/R.y)+5.*sin(39.*U.x/R.y);\n    }\n    \n    Q = B(U);\n    vec2 v = normalize(U-.7*R)*(1.-exp(-10.*length(U-.7*R)/R.y));\n    for (float i = 0.; i < 180.; i++){\n        Q -= (vec4(.7,.6,.5,1))*B(U-v*i*R.y/100.)*.03;\n        Q += (1.-vec4(.7,.6,.5,1))*B(U-v*i*R.y/100.)*.01;\n        Q += .2*vec4(.7,.6,.5,1)*exp(-4.*length(U-v*i*R.y/100.-.7*R)/R.y);\n    }\n    Q *= .1*(B(U));\n    float m = .05*R.y*(C(vec2(U.x,0)).x*.2+C(vec2(.1*U.x,0)).x)+.1*R.x-U.x*.1;\n    Q *= .5+.5*smoothstep(0.,2.,U.y-.4*R.y-m);\n    m = .05*R.y*(C(vec2(U.x,10)).x*.2+C(vec2(.1*U.x,10)).x)+.07*R.x-U.x*.1;\n    Q *= .75+.25*smoothstep(0.,2.,U.y-.4*R.y-m);\n    m = .05*R.y*(C(vec2(U.x,20)).x*.2+C(vec2(.1*U.x,20)).x)+.02*R.x-U.x*.1;\n    Q *= .9+.1*smoothstep(0.,2.,U.y-.4*R.y-m);\n    \n    Q *= h;\n    \n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n    float t = iTime;\n    Q = vec4(0);\n    Q += .05*A(U*2.+t);\n    Q += .1*A(U+t);\n    Q += .2*A(U*.5+t);\n    Q += .3*A(U*.25+t);\n    Q += .4*A(U*.125+t);\n    Q += .5*A(U*.125+t);\n    Q += .75*A(U*.125*.5);\n    Q += 1.*A(U*.125*.25);\n    Q += 2.*A(U*.125*.125);\n\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Main void mainImage(out vec4 Q, in vec2 U)\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)", "buffer_b_code": "Main {\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    Q.y = n.x-s.x;\n    Q.x = e.x-w.x;\n    Q.xy = .1*Q.xy+vec2(-Q.y,Q.x);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nMain {\n\n    for (float i = 0.; i < 100.; i++) {\n        U += 5.*B(U).xy;\n    }\n    Q = A(U).xxxx;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    Q.y = n.x-s.x;\n    Q.x = e.x-w.x;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MffcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "lcfyR2", "name": "Square Tiles Cube Room", "author": "WilstonOreo", "description": "Shader to be used in touchdesigner", "tags": ["sdf", "texture", "fisheye", "dome"], "likes": 0, "viewed": 30, "published": 3, "date": "1721313845", "time_retrieved": "2024-07-18T23:33:09.865095", "image_code": "/*\n{\n  \"DESCRIPTION\": \"Data Transfer\",\n  \"CREDIT\": \"cr8tr.org\",\n  \"IMPORTED\" : [\n  ],\n  \"CATEGORIES\" : [\n  ],\n  \"DESCRIPTION\" : \"CR8TR Data Transfer\",\n  \"INPUTS\" : [\n  {\n  \t\"NAME\": \"colorImage\",\n  \t\"TYPE\": \"image\"\n  },\n  {\n    \"NAME\": \"cam_yaw\",\n    \"LABEL\": \"Yaw\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -180.0,\n    \"MAX\": 180.0\n  },\n  {\n    \"NAME\": \"cam_pitch\",\n    \"LABEL\": \"Pitch\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -180.0,\n    \"MAX\": 180.0\n },\n {\n \"NAME\": \"cam_roll\",\n \"LABEL\" : \"Roll\",\n \"TYPE\": \"float\",\n \"DEFAULT\": 0.0,\n \"MIN\": -180.0,\n \"MAX\": 180.0\n },\n  {\n    \"NAME\": \"scale_x\",\n    \"LABEL\": \"Scale X\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.1,\n    \"MAX\": 10.0\n  },\n  {\n    \"NAME\": \"scale_y\",\n    \"LABEL\": \"Scale Y\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.1,\n    \"MAX\": 10.0\n  },\n  {\n    \"NAME\": \"cam_pos_x\",\n    \"LABEL\": \"Cam Position X\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -1.0,\n    \"MAX\": 1.0\n  },\n  {\n    \"NAME\": \"cam_pos_y\",\n    \"LABEL\": \"Cam Position Y\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -1.0,\n    \"MAX\": 1.0\n  },\n  {\n    \"NAME\": \"cam_pos_z\",\n    \"LABEL\": \"Cam Position Z\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -1.0,\n    \"MAX\": 1.0\n  },\n {\n \"NAME\": \"speed\",\n \"LABEL\" : \"Speed\",\n \"TYPE\": \"float\",\n \"DEFAULT\": 0.5,\n \"MIN\": -2.0,\n \"MAX\": 2.0\n },\n {\n \"NAME\": \"map_mode\",\n \"VALUES\": [\n 0,\n 1,\n 2\n ],\n \"LABELS\": [\n \"Equirectangular\",\n \"Fisheye\",\n \"Cubic\"\n ],\n \"DEFAULT\": 0,\n \"TYPE\": \"long\"\n },\n  ],\n\t\"PERSISTENT_BUFFERS\": [\n\t\t\"timeBuffer\"\n\t],\n\t\"PASSES\": [\n\t\t{\n\t\t\t\"TARGET\": \"timeBuffer\",\n\t\t\t\"WIDTH\": \"1\",\n\t\t\t\"HEIGHT\": \"1\",\n\t\t\t\"FLOAT\": true\n\t\t}, {\n\t\t}\n\t]\n}\n*/\n\nfloat currentTime;\n\n////////// shaders/camera.h //////////\n//#define MAP_DYNAMIC\n//#define MAP_ROTATE\n//#define MAP_SPHERICAL 0\n#define MAP_FISHEYE 1\n//#define MAP_CUBE 2\n\nuniform float cam_roll; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_pitch; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_yaw; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_pos_x; // default = 0.0, min = -1.0, max = 1.0\nuniform float cam_pos_y; // default = 0.0, min = -1.0, max = 1.0\nuniform float cam_pos_z; // default = 0.0, min = -1.0, max = 1.0\n\n#ifdef TOUCHDESIGNER\nuniform float scale_x; // default = 1.0, min = 0.1, max = 10.0\nuniform float scale_y; // default = 1.0, min = 0.1, max = 10.0\n#else\nconst float scale_x = 1.0; // default = 1.0, min = 0.1, max = 10.0\nconst float scale_y = 1.0; // default = 1.0, min = 0.1, max = 10.0\n#endif\n\n\n////////// shaders/direction.h //////////\n////////// shaders/util.h //////////\n\nconst float PI = 3.14159265358979323846264;\n\nstruct Ray\n{\n  vec3 org;\n  vec3 dir;\n};\n\n/// Convert degrees to radians\nfloat deg2rad(in float deg)\n{\n  return deg * PI / 180.0;\n}\n\n\n/// Convert degrees to radians\nfloat rad2deg(in float rad)\n{\n  return rad / PI * 180.0;\n}\n\nfloat sqr(in float a)\n{\n  return a*a;\n}\n\n/// Calculates the rotation matrix of a rotation around X axis with an angle in radians\nmat3 rotateAroundX( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0,0.0,0.0,\n              0.0,  c, -s,\n              0.0,  s,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Y axis with an angle in radians\nmat3 rotateAroundY( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c,0.0,  s,\n              0.0,1.0,0.0,\n               -s,0.0,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Z axis with an angle in radians\nmat3 rotateAroundZ( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c, -s,0.0,\n                s,  c,0.0,\n              0.0,0.0,1.0);\n}\n\n/// Calculate rotation by given yaw and pitch angles (in degrees!)\nmat3 rotationMatrix(in float yaw, in float pitch, in float roll)\n{\n  return rotateAroundZ(deg2rad(yaw)) *\n         rotateAroundY(deg2rad(-pitch)) *\n         rotateAroundX(deg2rad(roll));\n}\n\nfloat solveQuadraticEquation(\n    in float a,\n    in float b,\n    in float c)\n{\n  float disc = b*b - 4.0 * a * c;\n  if (disc < 0.0) return -1.0;\n\n  float distSqrt = sqrt(disc);\n  float q;\n  if (b < 0.0)\n  {\n    q = (-b - distSqrt)*0.5;\n  }\n  else\n  {\n    q = (-b + distSqrt)*0.5;\n  }\n  if (q == 0.0) return -1.0;\n\n  float t = c / q;\n  if (t < 0.0)\n    t = q / a;\n\n  return t;\n}\n\n\n#ifdef MAP_FISHEYE\n// Get fisheye camera ray from screen coordinates\nfloat fisheye_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n\tuv = uv - 0.5;\n  float phi = atan(uv.x,uv.y);\n  float l = length(uv);\n\n  if (l > 0.5)\n  {\n    return -1.0;\n  }\n  float theta  = l * PI;\n  rd = normalize(vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));\n  return 1.0;\n}\n#endif\n\n#ifdef MAP_SPHERICAL\nfloat spherical_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n  float theta = (uv.t) * PI,\n        phi = (uv.s - 0.5)* 2.0 * PI;\n  rd = vec3(sin(theta) * sin(phi), sin(theta) * cos(phi), cos(theta));\n  return 1.0;\n}\n#endif\n#ifdef MAP_CUBE\nfloat cubemap_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n  uv.x *= 6.0;\n\n  if (uv.x < 1.0) // EAST\n  {\n    uv -= 0.5;\n    rd = vec3(2.0*uv.x,1.0,-2.0*uv.y);\n  } else\n  if (uv.x < 2.0) // WEST\n  {\n    uv -= 0.5;\n    uv.x -= 1.0;\n    rd = vec3(-2.0*uv.x,-1.0,-2.0*uv.y);\n  } else\n  if (uv.x < 3.0) // NORTH\n  {\n    uv -= 0.5;\n    uv.x -= 2.0;\n    rd = vec3(1.0,-2.0*uv.xy);\n  } else\n  if (uv.x < 4.0) // SOUTH\n  {\n    uv -= 0.5;\n    uv.x -= 3.0;\n    rd = vec3(-1.0,2.0*uv.x,-uv.y*2.0);\n  } else\n  if (uv.x < 5.0) // Top\n  {\n    uv -= 0.5;\n    uv.x -= 4.0;\n    rd = vec3(2.0*uv,1.0);\n  } else\n  if (uv.x < 6.0) // Bottom\n  {\n    uv -= 0.5;\n    uv.x -= 5.0;\n    rd = vec3(-uv.x*2.0,uv.y*2.0,-1.0);\n  }\n\n  rd = normalize(rd);\n\n  return 1.0;\n}\n#endif\n#ifdef MAP_DYNAMIC\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n#ifdef MAP_SPHERICAL\n  if (map_mode == MAP_SPHERICAL)\n  {\n    return spherical_direction(screenCoord,res,rd);\n  }\n#endif\n#ifdef MAP_FISHEYE\n  if (map_mode == MAP_FISHEYE)\n  {\n    return fisheye_direction(screenCoord,res,rd);\n  }\n#endif\n#ifdef MAP_CUBE\n  if (map_mode == MAP_CUBE)\n  {\n    return cubemap_direction(screenCoord,res,rd);\n  }\n#endif\n  return -1.0;\n}\n\n#endif\n\n#ifndef MAP_DYNAMIC\n#ifdef MAP_SPHERICAL\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return spherical_direction(screenCoord,res,rd);\n}\n#endif\n#ifdef MAP_FISHEYE\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return fisheye_direction(screenCoord,res,rd);\n}\n#endif\n#ifdef MAP_CUBE\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return cubemap_direction(screenCoord,res,rd);\n}\n#endif\n#endif\n\n\n\n\n// Get fisheye camera ray from screen coordinates with rotation\nfloat direction(in vec2 screenCoord, in vec2 res, float rotX, float rotY, float rotZ, out vec3 rd)\n{\n  if (direction(screenCoord,res,rd) < 0.0)\n  {\n    return -1.0;\n  }\n  rd *= rotateAroundZ(rotZ)*rotateAroundY(rotY)*rotateAroundX(rotX);\n  return 1.0;\n}\n\n\nfloat setup_camera_ray(in vec2 uv, out vec3 ray)\n{\n  return direction(uv,vec2(1.0),deg2rad(90.0+cam_yaw),deg2rad(cam_roll),deg2rad(cam_pitch),ray);\n}\n\n////////// shaders/time.h //////////\n\n// Returns a pyramid-like periodic signal.\nfloat pyramid(float x)\n{\n\tx = fract(x);\n\treturn min(x * 2.0, (1.0 - x) * 2.0);\n}\n\n// Returns a semicircular periodic signal.\nfloat circ(float x)\n{\n\tx = fract(x) * 2.0 - 1.0;\n\treturn sqrt(1.0 - x * x);\n}\n\nfloat mp(float x)\n{\n\tfloat y=0.3;\n\treturn clamp((pyramid(x)-0.5)*2.0-0.4,-y,y);\n}\n\nmat3 transpose_(mat3 m)\n{\n\treturn mat3(vec3(m[0].x,m[1].x,m[2].x),\n\t\t\t\tvec3(m[0].y,m[1].y,m[2].y),\n\t\t\t\tvec3(m[0].z,m[1].z,m[2].z));\n}\n\nfloat sceneDist(vec3 p)\n{\n\tfloat d=1e3;\n\n\tp+=vec3(0.0,1.0,0.0);\n\tp.z+=cos(p.y*2.0+currentTime)*0.1;\n\tfloat tm=fract(currentTime*1.0-0.1);\n\tp.x-=(smoothstep(0.0,0.3,tm)-smoothstep(0.4,1.0,tm))*smoothstep(0.5,2.0,p.y)*0.2;\n\n\treturn d;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n\tp*=15.0;//scene_scale;\n\tfloat c=sceneDist(p);\n\tfloat e=1e-3;\n\treturn normalize(vec3(sceneDist(p+vec3(e,0,0))-c,\n\t\t\t\t\t\t  sceneDist(p+vec3(0,e,0))-c,\n\t\t\t\t\t\t  sceneDist(p+vec3(0,0,e))-c));\n}\n\nvec2 unitSquareInterval(vec2 ro, vec2 rd)\n{\n\tvec2 slabs0 = (vec2(+1.0) - ro) / rd;\n\tvec2 slabs1 = (vec2(-1.0) - ro) / rd;\n\n\tvec2 mins = min(slabs0, slabs1);\n\tvec2 maxs = max(slabs0, slabs1);\n\n\treturn vec2(max(mins.x, mins.y),\n\t\t\t\tmin(maxs.x, maxs.y));\n}\n\nvec3 squaresColours(in vec2 p)\n{\n\tp+=vec2(currentTime*0.005);\n\treturn texture(iChannel0,fract(p*vec2(scale_x,scale_y))).xyz;\n}\n\nvec3 squaresTex(vec2 p,float border)\n{\n\tfloat sm=0.02;\n\tvec2 res=vec2(8.0);\n\tvec2 ip=floor(p*res)/res;\n\tvec2 fp=fract(p*res);\n\tfloat m=1.0-max(smoothstep(border-sm,border,abs(fp.x-0.5)),smoothstep(border-sm,border,abs(fp.y-0.5)));\n\tm+=1.0-smoothstep(0.0,0.56,distance(fp,vec2(0.5)));\n\treturn m*squaresColours(ip);\n}\n\nvec3 room(vec3 ro,vec3 rd,out vec3 rp,out vec3 n)\n{\n\tvec2 box_size=vec2(1.0,5.0+3.0/8.0);\n\tvec2 cp=vec2(0.0),ct=vec2(1e3);\n\tvec3 ci=ro+rd*ct.y;\n\tvec2 cu=vec2(atan(ci.z-cp.y,ci.x-cp.x)/3.1415926*0.5,(ci.y+0.5/8.0)*4.0);\n\n\tfloat wt=max(0.0,unitSquareInterval(ro.xy * box_size, rd.xy * box_size).y);\n\tfloat t=min(ct.y,wt);\n\trp=ro+rd*t;\n\n\tn.z=0.0;\n\tif(abs(rp.x*box_size.x)>abs(rp.y*box_size.y))\n\t\tn.xy=vec2(rp.x/abs(rp.x),0.0);\n\telse\n\t\tn.xy=vec2(0.0,rp.y/abs(rp.y));\n\n\tif(ct.y<wt)\n\t{\n\t\tn.y=0.0;\n\t\tn.xz=normalize(rp.xz-ci.xz);\n\t}\n\n\tfloat l=1.0-smoothstep(0.0,3.0,abs(rp.z-ro.z));\n\n\tvec3 wc=mix(squaresTex(rp.zy+vec2(0.0,0.5/8.0),0.5),squaresTex(rp.xz,0.44),step(0.999/box_size.y,abs(rp.y)));\n\tvec3 cc=squaresTex(cu,0.45)+0.8*vec3(smoothstep(0.83/5.0,0.86/5.0,abs(rp.y)));\n\n\treturn l*mix(cc,wc,step(wt,t));\n}\n\nvec3 scene(vec2 uv)\n{\n\tfloat lt=0.0;\n\tvec3 ro = vec3(cam_pos_x,cam_pos_y,cam_pos_z);\n  vec3 rd;\n\n\tif (setup_camera_ray(uv, rd) < 0.0)\n  {\n    return vec3(0.0);\n  }\n\n\trd=normalize(rd);\n\n\tvec3 n,rp;\n\n\tvec3 c;\n\tvec3 c0=room(ro,rd,rp,n);\n\t\tvec3 r=reflect(rd,n);\n\t\tvec3 c1=room(rp,r,rp,n);\n\t\tc=c0+c1*c0*0.4;\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tfragColor = vec4(vec3(scene(uv)),1.0);\n }\n", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2714, 2745, 2774, 2774, 2803], [2806, 2837, 2866, 2866, 2895], [2897, 2897, 2920, 2920, 2936], [2938, 3026, 3064, 3064, 3196], [3198, 3286, 3324, 3324, 3456], [3458, 3546, 3584, 3584, 3716], [3718, 3785, 3851, 3851, 3973], [3975, 3975, 4054, 4054, 4352], [6777, 6841, 6941, 6941, 7094], [7097, 7097, 7147, 7147, 7246], [7286, 7329, 7353, 7353, 7409], [7411, 7454, 7475, 7475, 7531], [7533, 7533, 7552, 7552, 7614], [7616, 7616, 7641, 7641, 7749], [7751, 7751, 7776, 7776, 7985], [7987, 7987, 8011, 8011, 8200], [8202, 8202, 8245, 8245, 8455], [8457, 8457, 8489, 8489, 8583], [8585, 8585, 8623, 8623, 8900], [8902, 8902, 8953, 8953, 9704], [9706, 9706, 9727, 9727, 10022], [10024, 10024, 10079, 10079, 10163]], "test": "error"}
{"id": "lffcRj", "name": "SDF Motionblur stress test", "author": "jafam", "description": "Simulation starts with 50 particles. A new one is spawned every second. Potential to be optimized with gpu instancing.", "tags": ["2d", "blur", "motionblur", "motion", "analytic"], "likes": 1, "viewed": 34, "published": 3, "date": "1721308208", "time_retrieved": "2024-07-18T23:33:10.619080", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic motion blur, for 2D spheres (disks).\n//\n// (Linearly) Moving Disk - pixel/ray overlap test. The resulting\n// equation is a quadratic that can be solved to compute time coverage\n// of the swept disk behind the pixel over the aperture of the camera\n// (a full frame at 24 hz in this test).\n\n// draw a disk with motion blur\nfloat sdSegment(vec2 p, vec2 a, vec2 ba, float r) {\n    vec2 pa = p-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-ba*h)-r;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\nvec4 hash4( float n ) { return fract(sin(vec4(n,n+1.0,n+2.0,n+3.0))*43758.5453123); }\n\nconst float speed = 2.0;\nvec2 getPosition( float time, vec4 id ) { return vec2(       0.9*sin((speed*(0.75+0.5*id.z))*time+20.0*id.x),        0.75*cos(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\nvec2 getVelocity( float time, vec4 id ) { return vec2( speed*0.9*cos((speed*(0.75+0.5*id.z))*time+20.0*id.x), -speed*0.75*sin(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    const float fps = 60.0;\n    vec3 col = vec3(0.03) + 0.015*p.y;\n    int imax = 50 + int(iTime);\n    for(int i=0; i<imax; i++) {\n        vec4 off = hash4(13.13*float(i));\n        vec2 sphpos = getPosition(iTime, off);\n        vec2 sphvel = getVelocity(iTime, off);\n        float sphrad = 0.005+0.005*off.x;\n        vec3 sphcol = off.xyz;\n        vec2 sphtrail = 0.5*sphvel/fps;\n        float d = sdSegment(p,sphpos,sphtrail,sphrad);\n        const float blur = 0.005;\n        col = mix(col,sphcol,clamp(-d/blur,0.0,1.0));\n\t}\n    \n    col = pow(col,vec3(0.4545));\n    \n    col += (1.0/255.0)*hash3(p.x+13.13*p.y);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lffcRj.jpg", "access": "api", "license": "mit", "functions": [[1380, 1412, 1463, 1463, 1568], [1570, 1570, 1593, 1593, 1649], [1650, 1650, 1673, 1673, 1735], [1762, 1762, 1803, 1803, 1930], [1931, 1931, 1972, 1972, 2099], [2101, 2101, 2156, 2156, 2865]], "test": "ok"}
{"id": "XcXyz2", "name": "Internal ray-circle intersect 2D", "author": "Mytino", "description": "Find circle intersection of a ray starting inside the circle.", "tags": ["ray", "intersection", "circle", "internal", "check"], "likes": 1, "viewed": 30, "published": 3, "date": "1721296306", "time_retrieved": "2024-07-18T23:33:11.463822", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float scale = 1000.0 / iResolution.x;\n   \n    vec2 p = (fragCoord - iResolution.xy * 0.5) * scale;\n    vec2 p0 = (abs(iMouse.zw) - iResolution.xy * 0.5) * scale;\n    vec2 to = (abs(iMouse.xy) - iResolution.xy * 0.5) * scale;\n    vec2 dir = normalize(to - p0);\n    \n    float r = 200.0;\n    \n    float a = p0.x, b = p0.y;\n    float u = dir.x, v = dir.y;\n    float t = (sqrt(-a*a*v*v + 2.0*a*b*u*v - b*b*u*u + r*r*(u*u+v*v)) - a*u - b*v) / (u*u + v*v);\n    vec2 intersection = p0 + dir * t;\n    \n    if (p.x * p.x + p.y * p.y < r * r) {\n        col = vec3(0.3);\n    }\n    \n    float colArrow = sdf_arrow(p - p0, length(to - p0), normalize(to - p0), 3.0, 1.0);\n    colArrow = smoothstep(1.5, 0.0, colArrow);\n    col += vec3(colArrow);\n    \n    if (length(p - intersection) < 8.0) col = vec3(1, 0, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265358979\n#define TAU (2.0 * PI)\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\n#define m_stretch_neg(p, st) (.5 * m_stretch(2. * p + st, st))  /* Stretch-negative: positive values are fixed */\n#define m_stretch_pos(p, st) (.5 * m_stretch(2. * p, st))  /* Stretch-positive: negative values are fixed */\n\n// A fast \"manual\" lossy rotate function by ollj.\n// Control the angle of rotation by specifying the ROTATE_PARAM constants.\n// https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);  // Try changing these!\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n// NOTE: Very slightly modified - Mytino.\n// Optimized arrow SDF, by ollj\n// @head_len isn't actual uv units, but the unit size depends on ROTATE_PARAMs\nfloat sdf_arrow(vec2 uv, float norm, vec2 dir, float head_height, float stem_width){\n    uv = vec2(dir.x * uv.x + dir.y * uv.y, -dir.y * uv.x + dir.x * uv.y);\n\n    norm -= head_height;  // Make sure the norm INCLUDES the arrow head\n    uv.x -= norm;  // Place the arrow's origin at the stem's base!\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = m_stretch_neg(uv.x, norm);\n    uv.y = m_stretch_pos(uv.y, stem_width);\n    float stem = length(uv);\n\n    return min(head, stem);  // Join head and stem!\n}\n// ------------------------------------------------------------------------------------------------", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcXyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 921]], "test": "error"}
{"id": "lclczB", "name": "jul172024 2", "author": "brendanluu", "description": "bruh", "tags": ["wave", "spiral", "fibonacci", "logarithmic", "golden"], "likes": 0, "viewed": 29, "published": 3, "date": "1721287570", "time_retrieved": "2024-07-18T23:33:12.209827", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.012,0.000,0.659);\n    vec3 b = vec3(1.000,0.639,0.851);\n    vec3 c = vec3(0.282,0.059,0.212);\n    vec3 d = vec3(0.859,0.000,0.373);\n    \n    return a + b*cos(6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    vec2 uv0 = uv;\n    \n    uv = fract(uv * 2.5);\n   \n    float d = length(uv);\n    \n    vec3 col = palette(d + length(uv0));\n        \n    d = cos(d + (iTime)*10.0)/995.;\n    d = abs(d);\n    \n    d = 0.003 / d;\n    \n    col *= d;\n    \n    col = mix(vec3(0.1), col, 0.1);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lclczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 222], [224, 224, 281, 281, 689]], "test": "ok"}
{"id": "MfscRB", "name": "jul172024 ", "author": "brendanluu", "description": "bruh", "tags": ["wave", "spiral", "fibonacci", "logarithmic", "golden"], "likes": 0, "viewed": 25, "published": 3, "date": "1721287450", "time_retrieved": "2024-07-18T23:33:12.959822", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.686,0.071,0.071);\n    vec3 b = vec3(1.000,0.639,0.851);\n    vec3 c = vec3(0.745,0.557,0.686);\n    vec3 d = vec3(1.000,0.702,0.831);\n    \n    return a + b*cos(6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    vec2 uv0 = uv;\n    \n    uv = fract(uv * 2.0) -0.5;\n   \n    float d = length(uv);\n    \n    vec3 col = palette(d + length(uv0));\n        \n    d = cos(d/0.8 + (iTime)/1.25)/90.;\n    d = abs(d);\n    \n    d = 0.003 / d;\n    \n    col *= d;\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfscRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 222], [224, 224, 281, 281, 656]], "test": "ok"}
{"id": "lcsczB", "name": "grow up", "author": "nayk", "description": "sources  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/McscRS", "tags": ["fractal", "moving", "infinite"], "likes": 1, "viewed": 34, "published": 3, "date": "1721283796", "time_retrieved": "2024-07-18T23:33:13.710814", "image_code": "\n\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED = vec3(1,0,0);\n\nint murmur_32_scramble(int k) {\n    k *= 0xcc9e2d51;\n    k = (k << 15) | (k >> 17);\n    k *= 0x1b873593;\n    return k;\n}\n\n\nint murmur3_32(int x, int y, int seed)\n{\n    int h = seed ^ murmur_32_scramble(x);\n    h = (h << 13) | (h >> 19);\n    h = h * 5 + 0xe6546b64;\n    h ^= murmur_32_scramble(y);\n    h = (h << 13) | (h >> 19);\n    h = h * 5 + 0xe6546b64;\n    /* Finalize. */\n\th ^= 2;\n\th ^= h >> 16;\n\th *= 0x85ebca6b;\n\th ^= h >> 13;\n\th *= 0xc2b2ae35;\n\th ^= h >> 16;\n\treturn h;\n}\n\nvec4 distort(vec2 start, float power) {\n    float dTime = iTime + 1.5*sin(iTime*0.2);\n    vec2 centre = vec2(\n       sin(dTime*0.93) *1.5,\n       cos(dTime*0.62)\n    ) * 2.8;\n    vec2 rel = start - centre;\n    float dist = 3.0*(sin(iTime*3.91)+1.5)*length(rel) - 3.0;\n    float effect = (1.0+0.5*sin(iTime*0.1))/(1.0+pow(dist,2.0));\n    float mult = 1.0 + 0.125*(0.5+cos(dist))/(pow(dist,2.0)+1.0);\n    rel = rel * mult;\n    float len = length(rel);\n    float ang = atan(rel.y, rel.x) + effect * sin(iTime*1.2);\n    rel = vec2(cos(ang), sin(ang))*len;\n    return vec4(rel + centre, effect, 0.5);\n}\n\nvec4 distort2(vec2 start, float power) {\n  float dx = sin(start.x+iTime*1.1) + cos(start.y+iTime*1.3);\n  float dy = cos(start.x+iTime*1.7) - sin(start.y+iTime*1.9);\n  vec2 bonk = vec2(dx, dy);\n  return vec4(bonk * power + start, length(bonk*power), atan(dx,dy));\n}\n\nvec3 lerp(vec3 a, vec3 b, float x) {\n  return a + (b-a) * x;\n}\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.3-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n   \n    vec2 uv2 = 6.0 * (fragCoord.xy/iResolution.xy -0.5)\n      *vec2(iResolution.x/iResolution.y, 1.0);\n    float spin = 0.4 + 1.1 * sin(iTime*10.10);\n  \n\n    vec4 pos = distort(uv2, 2.0*sin(iTime*10.13));\n    vec2 gpos = abs(fract(pos.xy*12.0)-0.5);\n  \n\n    float d = max(uv.x,uv.y) *100.0-(iTime)*1.0;\n    vec3 color =vec3(d, d, d);\n\n      \n      \n\tvec3 dir=vec3(uv*zoom,iTime*0.05)-color;\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcsczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 128, 128, 217], [220, 220, 260, 260, 575], [577, 577, 616, 616, 1174], [1176, 1176, 1216, 1216, 1440], [1442, 1442, 1478, 1478, 1504], [1761, 1761, 1839, 1867, 2733], [2735, 2735, 2792, 2820, 3416]], "test": "ok"}
{"id": "McscRB", "name": "SWS3005_02 gluttonous snake", "author": "Android6", "description": "新国立暑期实时渲染课程作业五，小组二", "tags": ["3d"], "likes": 3, "viewed": 96, "published": 3, "date": "1721278662", "time_retrieved": "2024-07-18T23:33:14.645316", "image_code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER: 02\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/view/McscRB\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 19;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 9;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o; // Ray Origin.\n    vec3 d; // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n    int dirrection;\n};\n\nstruct Light_t {\n    vec3 position; // Point light 3D position.\n    vec3 I_a;      // For Ambient.\n    vec3 I_source; // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;  // Ambient coefficient.\n    vec3 k_d;  // Diffuse coefficient.\n    vec3 k_r;  // Reflected specular coefficient.\n    vec3 k_rg; // Global reflection coefficient.\n    float n;   // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// 自定义的全局变量\nint SphereLevel[10];\nconst float SNAKE_RADIUS = 0.4;\nint DirectionX[4];\nint DirectionY[4];\nint SnakeNum = 5;\nconst int TotalTime = 36;\nconst int StepNum = 18;\nconst float TimeScale = 2.0f;\nconst float ScaleSizeSpeed = 10.0f;\nconst int MaxAddNum = 4;\nint BlackMaterial = 10;\n\nivec2 moveForward[StepNum];\nint startPos[NUM_SPHERES];\nfloat addTime[MaxAddNum];\nfloat removeTime[MaxAddNum];\nvec2 scaleTime[MaxAddNum];\n\n\n\nint CheckInScaleTime(float nowTime) {\n    for (int i = 0; i < MaxAddNum; i++) {\n        if (scaleTime[i].x <= nowTime && nowTime <= scaleTime[i].y) return i;\n    } return -1;\n}\n\n//Adjust all the parameters of the balls, including animations\nvoid SetUpBalls() {\n    float nowTime = iTime * TimeScale;\n    nowTime = fract(nowTime / float(TotalTime)) * float(TotalTime);\n    int nowFrameTime = int(nowTime) % TotalTime;\n    int cnt = nowFrameTime % StepNum;\n    int flag = int(nowFrameTime / StepNum);\n\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        Sphere[i].radius = SNAKE_RADIUS;\n        float sphereY =\n            abs(sin(8.0 * iTime + float(SphereLevel[i]))) + SNAKE_RADIUS;\n        Sphere[i].center.y = sphereY;\n        Sphere[i].materialID = i;\n    }\n\n    Sphere[0].radius = 1.3 * SNAKE_RADIUS;\n\n    for (int i = 0; i < SnakeNum; i++) {\n        float sphereX = 0.0;\n        float sphereZ = float(i);\n        Sphere[i].center.xz = vec3(sphereX, 0, sphereZ).xz;\n    }\n    //snake body moving\n    if (flag == 0) {\n        SnakeNum = 5;\n        for (int i = 0; i < MaxAddNum; i++) \n            if (nowTime >= addTime[i]) SnakeNum++;\n            \n        int ScaleTimeFlag = CheckInScaleTime(nowTime);\n\n        //Swelling after eating the ball\n        if (ScaleTimeFlag != -1) {\n            float nowScaleTime = nowTime - scaleTime[ScaleTimeFlag].x;\n            Sphere[0].radius = Sphere[0].radius + 0.1 * sin(nowScaleTime * ScaleSizeSpeed * PI);\n        }\n\n        if (SnakeNum <= 5) {\n            Sphere[5].center.xz = vec2(1.0, 2.0);\n        } else {\n            Sphere[5].center.xz = vec2(1.0, 4.0);\n        }\n        if (SnakeNum <= 6) {\n            Sphere[6].center.xz = vec2(3.0, 1.0);\n        } else {\n            Sphere[6].center.xz = vec2(2.0, 4.0);\n        }\n        if (SnakeNum <= 7) {\n            Sphere[7].center.xz = vec2(4.0, 3.0);\n        } else {\n            Sphere[7].center.xz = vec2(3.0, 4.0);\n        }\n        if (SnakeNum <= 8) {\n            Sphere[8].center.xz = vec2(2.0, 4.0);\n        } else {\n            Sphere[8].center.xz = vec2(4.0, 4.0);\n        }\n    } else if (flag == 1) {\n        SnakeNum = 9;\n        for (int i = 0; i < MaxAddNum; i++)\n            if (float(cnt) >= removeTime[i]) SnakeNum--;\n\n        if (SnakeNum <= 5) {\n            Sphere[5].center.xz = vec2(2.0, 4.0);\n        } else {\n            Sphere[5].center.xz = vec2(1.0, 4.0);\n        }\n        if (SnakeNum <= 6) {\n            Sphere[6].center.xz = vec2(4.0, 3.0);\n        } else {\n            Sphere[6].center.xz = vec2(2.0, 4.0);\n        }\n        if (SnakeNum <= 7) {\n            Sphere[7].center.xz = vec2(3.0, 1.0);\n        } else {\n            Sphere[7].center.xz = vec2(3.0, 4.0);\n        }\n        if (SnakeNum <= 8) {\n            Sphere[8].center.xz = vec2(1.0, 2.0);\n        } else {\n            Sphere[8].center.xz = vec2(4.0, 4.0);\n        }\n    }\n\n    \n    for (int i = 0; i < SnakeNum; i++) {\n        int start = startPos[i];\n        for (int j = 0; j < cnt; j++, start = (start + 1) % StepNum) {\n            Sphere[i].center.xz += vec2(moveForward[start]);\n        }\n        Sphere[i].center.xz += vec2(moveForward[start]) * fract(nowTime);\n    }\n}\n\nvec3 convertColor(int r, int g, int b) {\n    return vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\n\n// define eight basic colors\nvec3 greatColors[8];\nvoid initializeColors() {\n    greatColors[0] = convertColor(138, 43, 226);  // 紫罗兰\n    greatColors[1] = convertColor(227, 23, 13);   // 朱红\n    greatColors[2] = convertColor(255, 128, 0);   // 橘黄\n    greatColors[3] = convertColor(218, 112, 205); // 杏色\n    greatColors[4] = convertColor(255, 153, 18);  // 铬黄\n    greatColors[5] = convertColor(61, 89, 171);   // 深蓝色\n    greatColors[6] = convertColor(0, 201, 187);   // 翠绿色\n    greatColors[7] = convertColor(128, 42, 42);   // 棕色\n\n}\n\n// mix now color and next color\nvec3 getTransitionColor(int seed) {\n\n    int currentIndex = (seed) % 8;\n    int nextIndex = (currentIndex + 1) % 8;\n\n    float transitionDuration = 10.0; // 过渡时间长度\n    float t = mod(iTime * 3.0, transitionDuration) / transitionDuration;\n\n    vec3 currentColor = greatColors[currentIndex];\n    vec3 nextColor = greatColors[nextIndex];\n\n    return mix(currentColor, nextColor, 1. - t);\n}\n\nvoid SetUpMaterial() {\n    // materials for balls\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        Material[i].k_d = greatColors[i % 8];\n        Material[i].k_r = vec3(0.2, 0.2, 0.2);\n        Material[i].k_rg = 4.0 * vec3(0.1, 0.1, 0.1);\n        Material[i].n = 64.0;\n    }\n\n    Material[9].k_d = vec3(0.5, 0.5, 0.5);\n    Material[9].k_a = 0.2 * Material[9].k_d;\n    Material[9].k_r = 2.0 * Material[9].k_d;\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 64.0;\n\n    //materials for walls\n\n    for(int i = 11; i <= 18; i++){\n        Material[i].k_d = getTransitionColor(i);\n        Material[i].k_a = 0.2 * Material[i].k_d;\n        Material[i].k_r = 2.0 * Material[i].k_d;\n        Material[i].k_rg = 0.5 * Material[i].k_r;\n        Material[i].n = 128.0;\n    }\n\n\n    // Black material.\n    Material[BlackMaterial].k_d = vec3(0.0, 0.0, 0.0);\n    Material[BlackMaterial].k_a = vec3(0.11, 0.06, 0.09);\n    Material[BlackMaterial].k_r = vec3(0.33, 0.33, 0.52);\n    Material[BlackMaterial].k_rg = 0.4 * Material[8].k_r;\n    Material[BlackMaterial].n = 128.0;\n}\n\nvoid SetUpLight() {\n    Light[0].position = vec3(2.0, 8.0, 2.0);\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = 0.5 * vec3(1.0, 1.0, 1.0);\n\n    Light[1].position = vec3(6.0, 8.0, 6.0);\n    Light[1].I_a = vec3(0.9, 0.9, 0.9);\n    Light[1].I_source = 0.5 * vec3(1.0, 1.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene() {\n    moveForward[0] = ivec2(1, 0);\n    moveForward[1] = ivec2(0, 1);\n    moveForward[2] = ivec2(0, 1);\n    moveForward[3] = ivec2(1, 0);\n    moveForward[4] = ivec2(0, -1);\n    moveForward[5] = ivec2(1, 0);\n    moveForward[6] = ivec2(1, 0);\n    moveForward[7] = ivec2(0, 1);\n    moveForward[8] = ivec2(0, 1);\n    moveForward[9] = ivec2(0, 1);\n    moveForward[10] = ivec2(-1, 0);\n    moveForward[11] = ivec2(-1, 0);\n    moveForward[12] = ivec2(-1, 0);\n    moveForward[13] = ivec2(-1, 0);\n    moveForward[14] = ivec2(0, -1);\n    moveForward[15] = ivec2(0, -1);\n    moveForward[16] = ivec2(0, -1);\n    moveForward[17] = ivec2(0, -1);\n\n    startPos[0] = 0;\n    startPos[1] = 17;\n    startPos[2] = 16;\n    startPos[3] = 15;\n    startPos[4] = 14;\n    startPos[5] = 13;\n    startPos[6] = 12;\n    startPos[7] = 11;\n    startPos[8] = 10;\n    \n    addTime[0] = 2.5;\n    addTime[1] = 5.5;\n    addTime[2] = 8.5;\n    addTime[3] = 11.5;\n    \n    scaleTime[0] = vec2(2.5, 3.5);\n    scaleTime[1] = vec2(5.5, 6.5);\n    scaleTime[2] = vec2(8.5, 9.5);\n    scaleTime[3] = vec2(11.5, 12.5);\n    \n    removeTime[0] = 11.0;\n    removeTime[1] = 13.0;\n    removeTime[2] = 15.0;\n    removeTime[3] = 17.0;\n    \n    // 动画应该也要在这里面做完。\n    //  Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 9;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 2.5;\n    Plane[1].materialID = 9;\n\n    // Vertical plane.\n    Plane[2].A = 0.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 1.0;\n    Plane[2].D = -6.5;\n    Plane[2].materialID = 9;\n\n    // Vertical plane.\n    Plane[3].A = 1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 2.5;\n    Plane[3].materialID = 9;\n\n    // Vertical plane.\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = -6.5;\n    Plane[4].materialID = 9;\n\n    SetUpBalls();\n    // 把球摆好\n\n    // 材质初始化\n    SetUpMaterial();\n\n    // 光源初始化\n    SetUpLight();\n}\n\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                    out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if (t0 < tmin || t0 > tmax)\n        return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(N);\n    return true;\n}\n\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin,\n                    in float tmax) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if (t0 < tmin || t0 > tmax)\n        return false;\n    return true;\n}\n\n// 渲染模块\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin,\n                     in float tmax, out float t, out vec3 hitPos,\n                     out vec3 hitNormal) {\n\n    vec3 oc = ray.o - sph.center; // 光线原点到球心\n    float a = dot(ray.d, ray.d);  // 1\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n        return false;\n    float t1 = (-b + sqrt(d)) / (2.0 * a);\n    float t2 = (-b - sqrt(d)) / (2.0 * a);\n    float t0;\n    if (t1 > 0.0 && t2 > 0.0)\n        t0 = min(t1, t2);\n    else if (t1 > 0.0 && t2 <= 0.0)\n        t0 = t1;\n    else if (t1 <= 0.0 && t2 > 0.0)\n        t0 = t2;\n    else\n        return false;\n    if (t0 < tmin || t0 > tmax)\n        return false;\n\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(hitPos - sph.center);\n    return true;\n}\n\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin,\n                     in float tmax) {\n    vec3 oc = ray.o - sph.center; // 光线原点到球心\n    float a = dot(ray.d, ray.d);  // 1\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n        return false;\n    float t1 = (-b + sqrt(d)) / (2.0 * a);\n    float t2 = (-b - sqrt(d)) / (2.0 * a);\n    float t0;\n    if (t1 > 0.0 && t2 > 0.0)\n        t0 = min(t1, t2);\n    else if (t1 > 0.0 && t2 <= 0.0)\n        t0 = t1;\n    else if (t1 <= 0.0 && t2 > 0.0)\n        t0 = t2;\n    else\n        return false;\n    if (t0 < tmin || t0 > tmax)\n        return false;\n\n    return true;\n}\n\n// 计算冯氏光照模型\nvec3 PhongLighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                   in Material_t mat, in Light_t light) {\n    if (inShadow) {\n        return light.I_a * mat.k_a;\n    } else {\n        vec3 R = reflect(-L, N);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n// 渲染模块\nvec3 CastRay(in Ray_t ray, out bool hasHit, out vec3 hitPos, out vec3 hitNormal,\n             out vec3 k_rg) {\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t =\n        DEFAULT_TMAX;       // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;    // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal; // Normal vector at the nearest hit point.\n    int nearest_hitMatID; // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // planes\n    for (int i = 0; i < NUM_PLANES; i++) {\n        if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)) {\n            temp_hasHit = true;\n            IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t,\n                           temp_hitPos, temp_hitNormal);\n            if (temp_t < nearest_t) {\n                hasHitSomething = temp_hasHit;\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                if (i == 0) {\n                    float tempX = mod(nearest_hitPos.x + 0.5, 2.0) - 1.0;\n                    float tempZ = mod(nearest_hitPos.z + 0.5, 2.0) - 1.0;\n                    if (tempX * tempZ < 0.0)\n                        nearest_hitMatID = Plane[i].materialID;\n                    else\n                        nearest_hitMatID = BlackMaterial;\n                }\n\n                else if (i == 1) {\n                    float tempX = mod(nearest_hitPos.x - 0.5, 2.0) - 1.0;\n                    float tempY = mod(nearest_hitPos.y, 2.0) - 1.0;\n                    if (tempX < 0.9 && tempY > -0.9 && tempX > 0.1 &&\n                        tempY < -0.1)\n                        nearest_hitMatID = 11;\n                    else if (tempX > -0.9 && tempY < 0.9 && tempX < -0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 12;\n                    else if (tempX > -0.9 && tempY > -0.9 && tempX < -0.1 &&\n                             tempY < -0.1)\n                        nearest_hitMatID = 13;\n                    else if (tempX < 0.9 && tempY < 0.9 && tempX > 0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 14;\n                    else\n                        nearest_hitMatID = BlackMaterial;\n                }\n\n                else if (i == 2) {\n                    float tempX = mod(nearest_hitPos.x - 0.5, 2.0) - 1.0;\n                    float tempY = mod(nearest_hitPos.y, 2.0) - 1.0;\n                    if (tempX < 0.9 && tempY > -0.9 && tempX > 0.1 &&\n                        tempY < -0.1)\n                        nearest_hitMatID = 11;\n                    else if (tempX > -0.9 && tempY < 0.9 && tempX < -0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 12;\n                    else if (tempX > -0.9 && tempY > -0.9 && tempX < -0.1 &&\n                             tempY < -0.1)\n                        nearest_hitMatID = 13;\n                    else if (tempX < 0.9 && tempY < 0.9 && tempX > 0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 14;\n                    else\n                        nearest_hitMatID = BlackMaterial;\n                }\n\n                else if (i == 3) {\n                    float tempX = mod(nearest_hitPos.z - 0.5, 2.0) - 1.0;\n                    float tempY = mod(nearest_hitPos.y, 2.0) - 1.0;\n                    if (tempX < 0.9 && tempY > -0.9 && tempX > 0.1 &&\n                        tempY < -0.1)\n                        nearest_hitMatID = 11;\n                    else if (tempX > -0.9 && tempY < 0.9 && tempX < -0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 12;\n                    else if (tempX > -0.9 && tempY > -0.9 && tempX < -0.1 &&\n                             tempY < -0.1)\n                        nearest_hitMatID = 13;\n                    else if (tempX < 0.9 && tempY < 0.9 && tempX > 0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 14;\n                    else\n                        nearest_hitMatID = BlackMaterial;\n                }\n\n                else if (i == 4) {\n                    float tempX = mod(nearest_hitPos.z - 0.5, 2.0) - 1.0;\n                    float tempY = mod(nearest_hitPos.y, 2.0) - 1.0;\n                    if (tempX < 0.9 && tempY > -0.9 && tempX > 0.1 &&\n                        tempY < -0.1)\n                        nearest_hitMatID = 15;\n                    else if (tempX > -0.9 && tempY < 0.9 && tempX < -0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 16;\n                    else if (tempX > -0.9 && tempY > -0.9 && tempX < -0.1 &&\n                             tempY < -0.1)\n                        nearest_hitMatID = 17;\n                    else if (tempX < 0.9 && tempY < 0.9 && tempX > 0.1 &&\n                             tempY > 0.1)\n                        nearest_hitMatID = 18;\n                    else\n                        nearest_hitMatID = BlackMaterial;\n                }\n            }\n        }\n    }\n    // spheres\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)) {\n            temp_hasHit = true;\n            IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t,\n                            temp_hitPos, temp_hitNormal);\n            if (temp_t < nearest_t) {\n                hasHitSomething = temp_hasHit;\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if (!hasHitSomething)\n        return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3(0.0); // Result color will be accumulated here.\n\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        bool inShadow = false;\n\n        // check if the shadow ray intersects any of the objects\n        for (int j = 0; j < NUM_PLANES; j++) {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN,\n                               length(Light[i].position - nearest_hitPos))) {\n                inShadow = true;\n                break;\n            }\n        }\n\n        for (int j = 0; j < NUM_SPHERES; j++) {\n            if (IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN,\n                                length(Light[i].position - nearest_hitPos))) {\n                inShadow = true;\n                break;\n            }\n        }\n\n        I_local += PhongLighting(normalize(Light[i].position - nearest_hitPos),\n                                 nearest_hitNormal, normalize(-ray.d), inShadow,\n                                 Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n// 将RGB颜色转换为HSL\nvec3 rgb2hsl(vec3 color) {\n    float maxColor = max(color.r, max(color.g, color.b));\n    float minColor = min(color.r, min(color.g, color.b));\n    float delta = maxColor - minColor;\n\n    float h = 0.0;\n    float s = 0.0;\n    float l = (maxColor + minColor) / 2.0;\n\n    if (delta != 0.0) {\n        s = (l < 0.5) ? (delta / (maxColor + minColor)) : (delta / (2.0 - maxColor - minColor));\n\n        if (maxColor == color.r) {\n            h = (color.g - color.b) / delta + (color.g < color.b ? 6.0 : 0.0);\n        } else if (maxColor == color.g) {\n            h = (color.b - color.r) / delta + 2.0;\n        } else {\n            h = (color.r - color.g) / delta + 4.0;\n        }\n\n        h /= 6.0;\n    }\n\n    return vec3(h, s, l);\n}\n\n// 将HSL颜色转换为RGB\nvec3 hsl2rgb(vec3 hsl) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n\n    vec3 rgb = vec3(l);\n\n    if (s != 0.0) {\n        float q = (l < 0.5) ? (l * (1.0 + s)) : (l + s - l * s);\n        float p = 2.0 * l - q;\n        float t[3];\n        t[0] = h + 1.0 / 3.0;\n        t[1] = h;\n        t[2] = h - 1.0 / 3.0;\n\n        for (int i = 0; i < 3; i++) {\n            if (t[i] < 0.0) t[i] += 1.0;\n            if (t[i] > 1.0) t[i] -= 1.0;\n\n            if (t[i] < 1.0 / 6.0) {\n                rgb[i] = p + (q - p) * 6.0 * t[i];\n            } else if (t[i] < 1.0 / 2.0) {\n                rgb[i] = q;\n            } else if (t[i] < 2.0 / 3.0) {\n                rgb[i] = p + (q - p) * (2.0 / 3.0 - t[i]) * 6.0;\n            } else {\n                rgb[i] = p;\n            }\n        }\n    }\n\n    return rgb;\n}\n\n// 提高给定颜色的饱和度\nvec3 increaseSaturation(vec3 color, float increaseFactor) {\n    vec3 hsl = rgb2hsl(color);\n    hsl.y = clamp(hsl.y + increaseFactor, 0.0, 1.0); // 增加饱和度并限制在0到1之间\n    return hsl2rgb(hsl);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    initializeColors();\n    int temp = 0;\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (temp == 0)\n            SphereLevel[i] = 1 + (i % 3);\n        else\n            SphereLevel[i] = 2 - (i % 3);\n        if (i % 3 == 2)\n            temp = 1 - temp;\n    }\n\n    // 以下所有部分都不需要修改\n    // 初始化场景\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // 调整照相机\n    //  vec3 cam_pos = vec3( 1.0, 10.0, 1.0);\n    vec3 cam_pos = vec3(2.0f + 4.0f * sin(iTime * PI * 0.2f),\n                        5.0f + 2.0f * sin(iTime * PI * 0.3f),\n                        2.0f + 4.0f * cos(iTime * PI * 0.2f));\n    vec3 cam_lookat = Sphere[0].center - vec3(0.0, Sphere[0].center.y, 0.0);\n    vec3 cam_up_vec = vec3(0.0, 1.0, 0.0);\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis +\n                       pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3(0.0);\n    vec3 compounded_k_rg = vec3(1.0);\n    Ray_t nextRay = pRay;\n\n    for (int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\n        I_result += compounded_k_rg * I_local;\n\n        if (!hasHit)\n            break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n    }\n\n    vec3 saturatedColor = increaseSaturation(I_result, 0.2); // 增加10%的饱和度\n    fragColor = vec4(saturatedColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McscRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3133, 3133, 3170, 3170, 3309], [3311, 3374, 3393, 3393, 6305], [6307, 6307, 6347, 6347, 6420], [6472, 6472, 6497, 6497, 6989], [6991, 7023, 7058, 7058, 7420], [7422, 7422, 7444, 7471, 8496], [8498, 8498, 8517, 8517, 8792], [8794, 8976, 8994, 8994, 11060], [11062, 11062, 11213, 11213, 11541], [11543, 11543, 11644, 11644, 11856], [11858, 11874, 12049, 12049, 12771], [12773, 12773, 12877, 12877, 13505], [13507, 13535, 13662, 13662, 14055], [14057, 14073, 14183, 14274, 21398], [21400, 21428, 21454, 21454, 22153], [22155, 22183, 22207, 22207, 22996], [22998, 23032, 23091, 23091, 23244], [23246, 23246, 23301, 23301, 25310]], "test": "ok"}
{"id": "lflcD7", "name": "Leaf. From BigWIngs tutorial", "author": "clicker", "description": "Got from tutorial https://www.shadertoy.com/view/ttlcR2", "tags": ["leaf"], "likes": 6, "viewed": 64, "published": 3, "date": "1721258707", "time_retrieved": "2024-07-18T23:33:15.479087", "image_code": "#define S smoothstep\n\nmat2 Rot(float a)\n{\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 Transform(vec3 p, float angle) {\n\tp.xz *= Rot(angle );\n    p.xy *= Rot(angle * 1.7);\n\n    return p;\n}\n\nfloat Leaf(vec2 p)\n{\n    float w = fwidth(p.y);\n\n\tfloat d = length(p - vec2(0.0, clamp(p.y, -0.3, 0.3)));\n\n    float r = mix(0.07, .001, S(0.0, 0.3, abs(p.y - 0.03)));\n\n    float m = S(w, -w, d-r);\n    \n    float side = sign(p.x);\n\n    float x = 0.9 * abs(p.x) / r;\n    \n    float wave = (1.-x)*sqrt(x) + x*(1.-sqrt(1.-x));\n\n    float y = (p.y - wave * 0.2) * 20.0 + side * 243.75;\n\n    float id = floor(y + 20.0);\n\n    float n = fract(sin(id*564.32)*763.);\n    \n    float shade = mix(.8, 0.9, n);\n    \n    d = length(p - vec2(0.0, clamp(p.y, -0.3, 0.2)));\n    \n    float strand = S(.0, .1, abs( fract(y) - 0.5 ) - 0.4);\n\n    strand *= S(w, -w, x - 0.9);\n    strand *= S(-w, w, x - 0.02);\n    strand *= S(w, -w, abs(p.y) - 0.3);\n\n    float stem = S(w, -w, d + (p.y-0.3) * 0.01);\n    \n    return max(m * shade, max(stem, strand));\n}\n\nfloat ScrewLeaf(vec2 p, float angle)\n{\n    p -= vec2(0,-.45);\n    float d = length(p);\n    p *= Rot(sin(angle) * 0.5 * d);\n\n    p += vec2(0,-.45);\n\n    return Leaf(p);\n}\n\nvec4 LeafBall(vec3 ro, vec3 rd, vec3 pos, vec3 color, float angle)\n{\t\n    vec4 col = vec4(0);\n    \n    float t = dot(pos-ro, rd);\n    vec3 p = ro + rd * t;\n    float y = length(pos-p);\n    \n    if (y < 1.0)\n    {\n        float x = sqrt(1.-y*y);\n        vec3 pF = ro + rd * (t-x) - pos;\n        float n = pF.y*.5+.5;\n        \n        pF = Transform(pF, angle);\n        vec2 uvF = vec2(atan(pF.x, pF.z), pF.y); // -pi<>pi, -1<>1\n        uvF *= vec2(.25,.5);\n        float f = Leaf(uvF);\n        \n        vec4 front = vec4(f * color, S(0., .6, f));\n        \n        vec3 pB = ro + rd * (t+x) - pos;\n        n = pB.y*.5+.5;\n        pB = Transform(pB, angle);\n        vec2 uvB = vec2(atan(pB.x, pB.z), pB.y); // -pi<>pi, -1<>1\n        uvB *= vec2(.25, .5);\n        float b = Leaf(uvB);\n        vec4 back = vec4(b * color, S(0., .6, b));\n        \n    \tcol = mix(back, front, front.a);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 M  = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float addend = (sin(20.0 * length(uv - M) - iTime * 2.0) * 0.5 + 0.5) * 0.05 - 0.2;\n\n    vec3 bg = vec3(0.7, 0.8, 0.87);\n    //bg      = mix(bg, vec3(0.8, 0.6, 0.3), S(1.0, 0.5, uv.y + 1.1));\n    bg      = mix(bg, vec3(0.8, 0.6, 0.3), S(1.0, 0.4, uv.y + addend + 1.1));\n    \n    vec4 col = vec4(bg, 0.0);\n\t\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    for (float i = 0.0; i < 1.0; i += 1.0 / 60.0)\n    {\n        vec3 color = vec3(sin(i * 2.0) * 0.5 + 0.5 , cos(i * 2.0) * 0.5 + 0.5, 0.1);\n\n        float n = fract(sin(i*564.3)*4570.3);\n        float x = mix(-12., 12., n) + M.x;\n        float y = mix(5.0, -5.0, fract(fract(n * 10.) + iTime * 0.1)) + M.y;\n        \n        float z = mix(5., 0., i);\n        float a = iTime * 0.5 + i * 563.34;\n        \n    \tvec4 leaf = LeafBall(ro, rd, vec3(x, y, z), color, a);\n        \n        leaf.rgb = mix(bg, leaf.rgb, mix(.3, 1., i));\n        leaf.rgb = sqrt(leaf.rgb);\n        \n        col = mix(col, leaf, leaf.a);\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lflcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 41, 41, 97], [99, 99, 136, 136, 205], [207, 207, 227, 227, 1038], [1040, 1040, 1078, 1078, 1209], [1211, 1211, 1279, 1279, 2118], [2120, 2120, 2175, 2175, 3336]], "test": "ok"}
{"id": "lcfyRS", "name": "Warning colors", "author": "shadertoyjiang", "description": "lit. ten  kilometers  snake \nN > 13\n\nThe number of iterations (N) can be controlled using the UP, DOWN, and HOME keys. \nLEFT or RIGHT  buttons to change the surface shape\n", "tags": ["mouse", "colors", "warning", "scary", "hirbert"], "likes": 22, "viewed": 119, "published": 3, "date": "1721233075", "time_retrieved": "2024-07-18T23:33:16.231077", "image_code": "\n// 2024年7月17日\n// hilbert curve\n// 349.7161.\n\n\n\n\n\n//int N = 2 ;\n\nfloat dln(in vec3 a, in vec3 b, in vec3 p){b-=a; p-=a;float h = clamp(dot(p,b)/dot(b,b), 0., 1.);return length(p - b * h);}\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nbool calcText=true;\nvec4 clr;\nfloat mrx;\n\n// 2024年7月18日\nfloat shape2(vec3 p)\n{\n        vec2 f=vec2(3,3);\n        vec2 u = p.xy;\n        u *= f; \n        u += iTime * vec2(5,1);\n        u = abs(u-round(u))/f;\n        vec2 v = vec2( min(u.x,u.y), p.z  * .8 ); // 不太正确的方法\n        return length(v)-.08;\n}\n\n\nfloat shape1(vec3 p)\n{ \n        p.xy+=iTime*.1;\n        vec3 sz=vec3(3,6,2);\n        p*=sz;\n        vec2 c = vec2(.433, .5);\n        p.xy = p.xy / c * .5;\n        p.xy = p.xy - round(p.xy);\n        p.xy = p.xy * c / .5;\n        p.yz = p.yz * sign(p.y);\n        p.x = abs(p.x);\n        p.y = p.y - .25;\n        p.yz = p.yz *  sign(p.y);\n\n        p.xy = p.xy - c/vec2(2,4);\n\n        p.xyz = p.xyz * sign(p.x);\n        p.xy = p.xy - c/vec2(2,4);\n        float fz =.2, r =.06;\n        float d1 = dln(vec3(0,0,-fz),vec3(0,-.5, fz),p);\n        float d2 = dln(vec3(0,0, fz),vec3(-.433,-.25, -fz),p);\n  clr /=clr;\n  clr=vec4(2,1.2,.5,1)*.3+.3;\n        return (min(d1,d2)-r)/6.;\n}\n\nvoid txtu(vec2 u)\n{\n        u *=3.; \n        u += iTime*vec2(5,1);\n        u -= round(u);\n        u = abs(u);\n        clr = clr*0.+1.-exp(-20.*min(u.x,u.y))-2.*(abs(u.y/3.-.5)-.4);\n}\n\nfloat texX(vec3 p, float f)\n{\n        float a = atan(p.y,p.x)/1.57;\n        return (a-.5)*f+.5; // + ind;\n}\n\nfloat texY(vec3 p, float f)\n{\n        float r = length(p.xy)-2.;\n        float a = atan(r,p.z)/6.28+.5;\n        return (a-.5)*f+.5;\n}\n\nfloat hilbert(vec3 p)\n{\n        int N = int(texture(iChannel0, vec2(.5)).x);\n        //int N = int(ky.x);\n        float dBox = length(  max(abs(p)-2., 0.) );\n        if(dBox>.051)return dBox;\n        const vec3 Z=vec3(-1,0,1); \n        vec3 f[] = vec3[](Z.zyy, Z.yyz,-Z.yzy,-Z.yyz, Z.zyy, Z.yyz, Z.yzy,-Z.yyz,Z.yzy);\n        vec3 c[] = vec3[](Z.yxy, Z.zyy, Z.zyy, Z.yxy, Z.yxy, Z.xyy, Z.xyy, Z.zyy); // c[i]=cross(f[i],f[i+1])\n        vec3 x,y,z,w;\n        float s=1.,h,k=1., a=0. ;\n        int e, t=0;//, N = 17; \n        for(int i=0;i<N;i++)\n        {\n                w = sign(p); w.y *= w.x; w.z *= -w.y;\n                e = int( dot(vec3(4,2,1), w*.5+.5) );\n                t = t * 8 + (k<0.?7-e:e);\n                x = f[e];\n                y = f[e+1];\n                z = c[e];// =cross(x,y);\n                h = 0.;\n                if(p.z<0. && e>0)z=-z, s=-s, h=.25; // e==3,4,7\n                if(e<2 || e==3 || e==5)w=-x, x=-y, y=w, k=-k;\n                mat3 m = mat3(x,y,z);\n                p += p - 2.*sign(p);\n                p *= m;\n                //\n                if(calcText==true){\n                   if(i==N-1)h=(e>0 && e<7 ? .25 : 0.)-h;\n                   if(i==N-2)h=(e>0 && e<7 ? .5  : 0.)+h;\n                   a += h * s;\n                }\n        }\n        //float n = 1.;\n        //if(t==0 || t==(1<<N*3)-1)//\n          //if(-p.x<p.y)p=-p.yxz;//, n =-n;// sun=-sun.yxz;\n        \n        p -= vec3(-2,2,0);\n        float tx,ty,tz;\n                tz = length(vec2(length(p.xy)-2., p.z));      \n        \n        if(calcText==true){\n                tx = texX(p, k) + float(t);\n                ty = texY(p, s) + a ; ty = fract(ty+5000.);\n           \n                txtu(vec2(tx,ty));\n        }\n        float d,d1=1e8,d2=1e8;\n        //if(mrx<.5)\n        //    d1 = (tz -1.3)/float(1<<N);\n        //else\n        //    d2 = shape1(vec3(tx,ty,tz-1.2))/float(1<<N);\n        //d=min(d1,d2);\n        \n        switch (int(texture(iChannel0, vec2(.5)).w))\n        {\n              case 0:{ d = shape1(vec3(tx,ty,tz-1.2))/float(1<<N);break;}\n              case 1:{ d = shape2(vec3(tx,ty,tz-1.2))/float(1<<N);break;}\n              case 2:{ d = (tz -1.3)/float(1<<N)    ;break;}\n        }\n        \n        return max(d, dBox);\n}\n\n\n\n\n\nfloat map(vec3 p)\n{\n        float t = iTime*.103;\n        vec2 ms = iMouse.xy/iResolution.xy*6.28+t;\n        p.xy = p.xy * rot(t +1.);\n        p.xz = p.xz * rot(ms.x);\n        p.yz = p.yz * rot(ms.y);\n        return hilbert(p);\n}\n\nbool keypress(int keycode){if(int(texture(iChannel0, vec2(keycode, .5)).x)==keycode)return true;return false;}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        //const int KEY_UP = 38;\n        //const int KEY_DOWN = 40;\n        //const int KEY_HOME = 36;\n        //if(keypress(KEY_UP)==true)N=N+1;\n        //if(keypress(KEY_DOWN)==true && N>0)N=N-1;\n        //if(keypress(KEY_HOME)==true)N=0;\n        O = vec4(.5);\n        mrx = 1.-iMouse.x/iResolution.x;\n        //if(texture(iChannel0, vec2(.5)).w<.5)mrx=1.-mrx;\n        if(mrx>.5)calcText=true;\n        vec2 R = iResolution.xy,\n             u = (U+U - R) / R.y;\n        if(length(u)>1.4)return;\n        vec3 eye = vec3(0, 0, -4),\n             dir = normalize(vec3(u, 1)),\n             sun = 5. * ( .2*cos(iTime+vec3(7,11,13)) + vec3(-1,2,-3)/3.74 ),\n             eps = vec3(0, .0001, 0),\n             nor, p;\n        float d , t=0.;\n        for(int i=0; i<328 ;i++)\n        {\n                if(t>7.)break;\n                p = eye + dir * t;\n                d = map(p);\n                if( d<.001 ) // if N>5 then set .001\n                {       // phong 光照模型\n                        \n                        float cx,cy,cz;\n                        cx=map(p+eps.yxx);\n                        cy=map(p+eps);\n                        calcText=true;\n                        cz=map(p+eps.xxy);\n                        nor = normalize(vec3(cx, cy, cz)-d); \n                        vec3  sp = normalize(sun-p), ep=normalize(eye-p);\n                        float ln = max(0., dot(nor,sp)),               // light norm\n                              er = max(0., dot(ep, reflect(-sp,nor))); // eye ray\n                        float ambt=.3, difu=.6, spec=80.;\n                        vec4  lightClr = vec4(1,.5,0,1);\n                        O = lightClr * (ambt + difu*ln + pow(er, spec));\n                        O *= clr;\n                        if(mrx>-.5)O *= 2.*exp(-.5*(t-1.5));\n                        break;\n                }\n                t += d * .5;\n        }\n        \n}\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// 2024年7月18日\n// keypress thx to FabriceNeyret2\n#define keypress(ascii)   ( texelFetch(iChannel1,ivec2(ascii,1),0).x > 0.)\n//bool keypress(int keycode){if( int(texture(iChannel1, vec2(keycode, .5)).x)==keycode )return true;return false;}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n        const int KEY_UP = 38;\n        const int KEY_DOWN = 40;\n        const int KEY_HOME = 36;\n        const int KEY_LEFT = 37;\n        const int KEY_RIGHT = 39;\n\n        O = texture(iChannel0, vec2(.01));\n        if     ( keypress(KEY_HOME)==true          )O=vec4(0);\n        else if( keypress(KEY_UP)==true            )O.x=O.x+1.;\n        else if( keypress(KEY_DOWN)==true && O.x>.5)O.x=O.x-1.;\n        \n        if( keypress(KEY_LEFT)==true && O.w>.5)O.w=O.w-1.;\n        if( keypress(KEY_LEFT)==true )O.w=1.+O.w;\n        O.w = float( int(O.w)%3 );\n        if(length(iMouse.xy)>5. || length(O.xyz- vec3(2,-1,0))>.5 )O.y=0.;\n        if(iFrame<10)O = vec4(2,-1,0,2);\n        if(O.y<0.)O.w = mod(floor(iTime*.3), 3.);\n        O = round(O);        \n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 114, 114, 194], [291, 311, 333, 333, 569], [572, 572, 594, 594, 1243], [1245, 1245, 1264, 1264, 1427], [1429, 1429, 1458, 1458, 1536], [1538, 1538, 1567, 1567, 1671], [3922, 3922, 3941, 3941, 4151], [4153, 4153, 4180, 4180, 4263], [4265, 4265, 4301, 4542, 6185]], "test": "error"}
{"id": "lcXyRS", "name": "manada mandala dala", "author": "nayk", "description": "sources  https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/fdy3WG https://glslsandbox.com/e#78073.0", "tags": ["fractal", "star", "cineshader"], "likes": 4, "viewed": 58, "published": 3, "date": "1721230501", "time_retrieved": "2024-07-18T23:33:16.986059", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nuniform float time;\n\n#define time iTime\n#define resolution iResolution.xy\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 uv = ( C - .5*iResolution.xy ) / iResolution.y;\n    vec2 p2 = (C.xy * 2.0 - resolution) /min(resolution.x, resolution.y);\n\tfloat l = 0.3 * abs(cos(time)) / length(p2);\n\tvec3 Color = vec3(l, 0.5, 0.7);\n\tfloat f = 0.0;\n\tfor(float i = 0.0; i < 20.0; i++)\n\t{\n\t\tfloat s = sin(time + i * 1.0) * 0.5;\n\t\tfloat c = cos(time + i * 1.0) * 0.5;\n        f += 0.0025 / abs(length(p2 + vec2(c, s)) - 0.5);\n\t\tf += 0.0015 / abs(length(p2 - vec2(c, s)) - 1.0);\n\t\tf += 0.00215 / abs(length(p2 + vec2(c, s)) - 0.5);\n\t}\n\t\n\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.08*exp(-i*i*e))\n    {\n        p=g*d;\n       \n        p.z-=.6;\n\n        s=3.;\n        for(int j=0;j++<8;)\n            p=abs(p+vec3(Color * f)),p=p.x<p.y?p.zxy:p.zyx,\n              p=abs(p),p=p.x<p.y?p.zxy:p.zyx,\n              \n            s*=e=1.8/min(dot(p,p),1.3),\n            p=p*e-vec3(12,3,3);\n        g+=e=length(p.xz)/s;\n  \n    }\n    O=pow(O,vec4(5));\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.15), 1.0);\n    O+= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.35)*0.1, 1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 219, 219, 365], [368, 368, 404, 404, 1712]], "test": "error"}
{"id": "XcfczB", "name": "other shine star", "author": "nayk", "description": "combination of  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/7lKSDz and fbm mix", "tags": ["star", "galaxy", "shine", "cineshader"], "likes": 4, "viewed": 80, "published": 3, "date": "1721230009", "time_retrieved": "2024-07-18T23:33:17.736054", "image_code": "\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define NUM_OCTAVES 5\n#define time iTime\n#define resolution iResolution.xy\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.05-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\n\nmat3 rotX(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    1, 0, 0,\n    0, c, -s,\n    0, s, c\n    );\n}\nmat3 rotY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c\n    );\n}\n\nfloat random(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    float a = random(i + vec2(0.0, 0.0));\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 pos) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i=0; i<NUM_OCTAVES; i++) {\n        v += a * noise(pos);\n        pos = rot * pos * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n#define time iTime\n\nconst float PI = 3.1415925358;\n\nfloat safety_sin( in float x ) { return sin( mod( x, PI ) ); }\n\nfloat rand( vec2 p ) { return fract( safety_sin( dot(p, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 + time * .35 ); }\n\nfloat noise2( vec2 x )\n{\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tvec4 h;\n\t// Smooth Interpolation\n\tf = f * f * ( f * -2.0 + 3.0 );\n\t// Four corners in 2D of a tile\n\th.x = rand( i + vec2( 0., 0. ) );\n\th.y = rand( i + vec2( 1., 0. ) );\n\th.z = rand( i + vec2( 0., 1. ) );\n\th.w = rand( i + vec2( 1., 1. ) );\n\t// Mix 4 coorners porcentages\n\treturn mix( mix( h.x, h.y, f.x ), mix( h.z, h.w, f.x ), f.y );\n}\n\nfloat star_burst( vec2 p )\n{\n\tfloat k0 = 2.0;\n\tfloat k1 = 1.0;\n\tfloat k2 = 0.5;\n\tfloat k3 = 12.0;\n\tfloat k4 = 12.0;\n    float k5 = 2.0;\n    float k6 = 5.2;\n    float k7 = 4.0;\n    float k8 = 6.2;\n\t\n\tfloat l  = length( p );\n    float l2 = pow( l * k1, k2 );\n\tfloat n0 = noise2( vec2( atan(  p.y,  p.x ) * k0, l2 ) * k3 );\n\tfloat n1 = noise2( vec2( atan( -p.y, -p.x ) * k0, l2 ) * k3 );\n\tfloat n  = pow( max( n0, n1 ), k4 ) * pow( clamp( 1.0 - l * k5, 0.0, 1.0 ), k6 );\n\tn += pow( clamp( 1.0 - ( l * k7 - 0.1 ), 0.0, 1.0 ), k8 );\n\treturn n;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n    \tuv*=fract(-iTime*1.1);\n\tvec3 dir=vec3(uv*zoom,iTime*0.009);\n\nvec2 p = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n    float t = 0.0, d;\n\n    float time2 = 2.6 * time / 5.0;\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(p + 0.00 * time2);\n    q.y = fbm(p + vec2(1.0));\n    vec2 r = vec2(0.0);\n    r.x = fbm(p + 1.0 * q + vec2(1.7, 9.2) + 0.15 * time2);\n    r.y = fbm(p + 1.0 * q + vec2(8.3, 2.8) + 0.126 * time2);\n    float f = fbm(p + r);\n    vec3 color = mix(\n    vec3(1.90, 0.2, 0.1),\n    vec3(1.50, 0.07, 0.07),\n    clamp((f * f) * 4.0, 1.0, 0.0)\n    );\n\n    color = mix(\n    color,\n    vec3(0.3, 0.5, 0.90),\n    clamp(length(q), 1.0, 2.0)\n    );\n vec2 p2 = fragCoord / min( iResolution.x, iResolution.y );\n    \n    p2 -= 0.5; p2.x -= 0.35;\n    p2 *= 0.5;\n    \n\tfloat r2 = star_burst( p2 * 1.1 );\n\tfloat g = star_burst( p2 );\n\tfloat b = star_burst( p2 * 0.2 );\n\n    // Output to screen\n    vec3 col = pow( vec3( r2, g, b ), vec3( 1.0 / 2.2 ) );\n\n    color = mix(\n    color,\n    vec3(.0, 1.0, 0.0),\n    clamp(length(r.y), 0.2, 0.0)\n    );\n\n    color = ( f + 1.09 * f * + 0.8 * f) * color;\n\n\tvec3 from=vec3(1.,.5,0.5)*col;\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor+=vec4(color+col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcfczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 409, 437, 1234], [1237, 1237, 1257, 1257, 1366], [1367, 1367, 1387, 1387, 1496], [1498, 1498, 1522, 1522, 1599], [1601, 1601, 1624, 1624, 1961], [1963, 1963, 1984, 1984, 2262], [2315, 2315, 2347, 2347, 2377], [2379, 2379, 2401, 2401, 2493], [2495, 2495, 2519, 2519, 2896], [2898, 2898, 2926, 2926, 3438], [3439, 3439, 3496, 3524, 4839]], "test": "ok"}
{"id": "4fXyRB", "name": "menger transformation", "author": "nayk", "description": "originals  https://glslsandbox.com/e#78381.0 https://www.shadertoy.com/view/fdy3WG", "tags": ["fractal", "menger", "transform"], "likes": 3, "viewed": 59, "published": 3, "date": "1721227089", "time_retrieved": "2024-07-18T23:33:18.490038", "image_code": "\n\n\n#define time iTime\n#define resolution iResolution.xy\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nfloat cube(vec3 p, vec3 s)\n{\ns+=R(s,normalize(vec3(1,1,1)),iTime);\n  p =abs(p) - s;\n  return max(max(p.x,p.y),p.z);\n}\n\nfloat crosscube(vec3 p, vec3 s)\n{\n s=R(s,normalize(vec3(10,3,10)),iTime);\n  vec3 a = vec3(s.x*1./3.,s.x*1./3.,s.x*4./3.);\n  float d = cube(p,a.xyz);\n  float d2 = cube(p,a.yzx);\n  float d3 = cube(p,a.zxy);\n\n  return min(min(d,d2),d3);\n}\n\nfloat menger(vec3 p, vec3 s)\n{\n  p=R(p,normalize(vec3(10,3,10)),iTime);\n  float d = cube(p,s);\n  float td = crosscube(p,s);\n  d = max(d,-td);\n\nfor(int i = 0; i < 4; i++)\n{\n  s *= 1./3.;\n  float m = s.x * 2.;\n    p+=R(p,normalize(vec3(10,53,2)),iTime);\n  p = mod(p-m*0.5,m)-m*0.5;\n  p=R(p,normalize(vec3(23,2,1)),iTime);\n  td = crosscube(p,s);\n  d = max(d,-td);\n}\n  return d;\n}\n\nfloat map(vec3 p)\n{\np=R(p,normalize(vec3(1,2,1)),iTime);\n  float d = menger(p,vec3(1.));\n\n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (gl_FragCoord.xy * 2. - resolution.xy) / min(resolution.x,resolution.y);\n\n  vec3 cp = vec3(0.,0.,5.);\n  vec3 cd = vec3(0.,0.,-1.);\n  vec3 cu = vec3(0.,1.,0.);\n  vec3 cs = cross(cd,cu);\n  float td = 1.;\n\n  vec3 ray = normalize(p.x*cs+p.y*cu+cd*td);\n  vec3 col = vec3(0.);\n  float me = 0.;\n\n  float d,t = 0.;\n  vec3 rp = cp;\n  for(int i = 0; i < 128; i++)\n  {\n\n      d = map(rp);\n      \n      me += exp(abs(d)*-0.2);\n    if(d < 0.001)\n    {\n      break;\n    }\n    t += d;\n    rp = cp + t * ray;\n  }\n  col = vec3(0.3,0.7,1.9)*me*0.05;\n fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fXyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 143, 143, 232], [234, 234, 267, 267, 469], [471, 471, 501, 501, 847], [849, 849, 868, 868, 952], [955, 955, 1012, 1012, 1584]], "test": "ok"}
{"id": "McXyD8", "name": "SDF Motionblur 2D", "author": "jafam", "description": "SDF version of Inigo's Analytic Motionblur", "tags": ["2d", "blur", "motionblur", "motion", "analytic"], "likes": 3, "viewed": 50, "published": 3, "date": "1721218971", "time_retrieved": "2024-07-18T23:33:19.247014", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic motion blur, for 2D spheres (disks).\n//\n// (Linearly) Moving Disk - pixel/ray overlap test. The resulting\n// equation is a quadratic that can be solved to compute time coverage\n// of the swept disk behind the pixel over the aperture of the camera\n// (a full frame at 24 hz in this test).\n\n// draw a disk with motion blur\nfloat sdSegment(vec2 p, vec2 a, vec2 ba, float r) {\n    vec2 pa = p-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-ba*h)-r;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\nvec4 hash4( float n ) { return fract(sin(vec4(n,n+1.0,n+2.0,n+3.0))*43758.5453123); }\n\nconst float speed = 8.0;\nvec2 getPosition( float time, vec4 id ) { return vec2(       0.9*sin((speed*(0.75+0.5*id.z))*time+20.0*id.x),        0.75*cos(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\nvec2 getVelocity( float time, vec4 id ) { return vec2( speed*0.9*cos((speed*(0.75+0.5*id.z))*time+20.0*id.x), -speed*0.75*sin(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\t\n\tvec3 col = vec3(0.03) + 0.015*p.y;\n\tfloat d = 0.0;\n\tfor( int i=0; i<16; i++ )\n\t{\t\t\n\t\tvec4 off = hash4( float(i)*13.13 );\n        vec3 sph = vec3( getPosition( iTime, off ), 0.02+0.1*off.x );\n        vec2 dv = getVelocity( iTime, off ) /24.0 ;\n\t\tvec3 sphcol = 0.55 + 0.45*sin( 3.0*off.z + vec3(4.0,0.0,2.0) );\n        d = sdSegment(p,sph.xy,dv,sph.z);\n        col = mix(col,sphcol,clamp(-50.0*d,0.0,1.0));\n\t}\t\t\n    \n    col = pow( col, vec3(0.4545) );\n    \n    col += (1.0/255.0)*hash3(p.x+13.0*p.y);\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McXyD8.jpg", "access": "api", "license": "mit", "functions": [[1380, 1412, 1463, 1463, 1568], [1570, 1570, 1593, 1593, 1649], [1650, 1650, 1673, 1673, 1735], [1762, 1762, 1803, 1803, 1930], [1931, 1931, 1972, 1972, 2099], [2101, 2101, 2158, 2158, 2750]], "test": "ok"}
{"id": "lcsyWM", "name": "grid loop circle square", "author": "jonasfrey", "description": "a simple loop animation", "tags": ["grid", "circle", "square", "loop"], "likes": 9, "viewed": 69, "published": 3, "date": "1721207406", "time_retrieved": "2024-07-18T23:33:20.000002", "image_code": "// Fork of \"triangle thing 2\" by jonasfrey. https://shadertoy.com/view/4cXcWN\n// 2024-07-17 08:10:00\n\nfloat f_n_sdf_rectangle( in vec2 o_p, in vec2 o_sidelength )\n{\n    vec2 o_d = abs(o_p)-o_sidelength;\n    return length(max(o_d,0.0)) + min(max(o_d.x,o_d.y),0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn = ( fragCoord.xy - iResolution.xy*.5 ) / iResolution.yy;\n    o_trn*=1.5;\n    float n = (length(o_trn)-.5)/.5;\n    float nt = iTime *0.5;\n    vec2 o_scl = vec2(6., 6.);\n    vec2 o_scl_one = 1./ o_scl; \n    \n    float n_its = o_scl.x*o_scl.y;\n    float n_it_one_nor = 1./n_its;\n    float n_tau = 6.2831;\n    vec4 o_col = vec4(0.);\n    float n_min = 1.;\n    for(float n_it_nor = 0.; n_it_nor<1.; n_it_nor+=n_it_one_nor){\n    \n        float n_it = floor(n_it_nor*n_its);\n        float n_radians = n_tau * n_it_nor;\n        vec2 o_p = o_trn-vec2(\n            fract(n_it_nor*o_scl.x), \n            floor(n_it_nor*o_scl.x)*(1./o_scl.x)\n        )+.5;\n        \n        float nl = 1.-clamp(fract(n_it_nor+sin(iTime*0.5))*12.,0.,1.);\n        nl = sin(nl*n_tau/2.);\n        float n_size = .5+nl;\n        float n = f_n_sdf_rectangle(o_p, (1./o_scl/2.).yx*n_size);\n        float nc = length(o_p)-max(o_scl_one.x, o_scl_one.y)*.5*n_size;\n        n = nl*n + (1.-nl)*nc;\n        n /= n_size;\n        n_min = min(n_min, n);\n        //n = (n-n_size)/n_size;// signed distance field\n        n = 1.-pow(abs(n), 1./12.);\n        n = clamp(n, 0., 1.);\n        vec4 o_c = vec4(n_it_nor, 1.-n_it_nor, fract(n_it_nor+.5), 1.);\n        o_col += o_c*n;\n        //o_col += vec4(n);\n    }\n    float n2 = 1.-pow(abs(n_min), 1./9.);\n    fragColor = o_col*n2*2.;\n    //fragColor = sqrt(fragColor);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcsyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 164, 164, 265], [268, 268, 325, 375, 1758]], "test": "ok"}
{"id": "XfsczN", "name": "Clock sharingan Tsukuyomi", "author": "Sank", "description": "Une montre avec le theme Tsukuyomi", "tags": ["v1"], "likes": 6, "viewed": 55, "published": 3, "date": "1721205115", "time_retrieved": "2024-07-18T23:33:20.749000", "image_code": "#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(-0.2, -0.0)\n\nconst vec3 skycolor = vec3(0.55, 0.0, 0.0);\nconst vec3 bgcolor = vec3(0.1, 0.0, 0.0);\n\nconst float PI = 3.1415926;\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\nmat2 scale(vec2 scale){\n    return mat2(scale.x, 0.0,\n                0.0, scale.y);\n}\nfloat circle( vec2 p, float r ){\n    return 1.0 - smoothstep(0.9* r, r,length(p) - r);\n}\n\nfloat circle_perfect(vec2 p, float r) {\n    return step(length(p), r);\n}\n\nfloat ring( vec2 p, float r ){\n    return circle(p, r) - circle(p, r - 0.03);\n}\n\nfloat semicircle(vec2 p, float r) {\n    float pct = 1.0 - smoothstep(0.9 * r, r,length(p) - r); \n    pct *= step(0.0, p.y);\n    return pct;\n}\n\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec3 line(in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col)\n{\n    float f = sdLine(p, a, b);\n    float g = fwidth(f) * w.y;\n    return mix(buf, col.xyz, col.w * (1.0 - smoothstep(w.x - g, w.x + g, f)));\n}\n\n\nvec2 random2(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat segment(vec2 uv, bool On)\n{\n    if (!On) return 0.0;\n    float seg = (1.0 - smoothstep(0.08, 0.09 + float(On) * 0.02, abs(uv.x))) *\n                (1.0 - smoothstep(0.46, 0.47 + float(On) * 0.02, abs(uv.y) + abs(uv.x)));\n    if (On)\n        seg *= (1.0 - length(uv * vec2(3.8, 0.9)));\n    else\n        seg *= -(0.05 + length(uv * vec2(0.2, 0.1)));\n    return seg;\n}\n\nfloat perlin_noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(\n            dot(random2(i + vec2(0.0)), f - vec2(0.0)),\n            dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)),\n            u.x\n        ),\n        mix(            \n            dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n            dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)),\n            u.x\n        ),\n        u.y\n    );\n}\n\nfloat cloud_wind(vec3 x) {\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    p.z += WIND.x * 10.0 * iTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    return perlin_noise(uv);\n}\n\nfloat density(vec3 pos) {\n    float den = 3.0 * cloud_wind(pos * 0.3) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    return den;\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\n\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol) {\n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; ++i) {\n        if (sum.a > 0.99 ||\n        pos.y < (MIN_HEIGHT - 1.0) ||\n        pos.y > (MAX_HEIGHT + 1.0)) break;\n\n        float den = density(pos);\n        if (den > 0.01) {\n            float dif = clamp((den - density(pos)) / 0.6, 0.0, 1.0);\n            vec3 lin = vec3(0.0);\n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);\n            \n            col.rgb *= lin;\n            sum = sum + col*(1.0 - sum.a);    \n        }\n        t += max(0.05, 0.02 * t);\n        \n       pos = ro + rd * t;\n\n       \n    }\n    sum = clamp(sum, 0.0, 1.0);\n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    return mix(backCol, sum.xyz, sum.a);\n}\n\nvec3 Tsukuyomi(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.1, 1.0));\n\n    float dist = planeIntersect(ro, rd, 3.0);\n\n    \n    vec3 color = mix(bgcolor, skycolor, uv.y * 0.5 + 0.5);\n\n    if (dist > 0.0) {\n        color = raymarching(ro, rd, dist, color);\n       \n        \n    }\n    return color;\n}\nfloat sevenSegment(vec2 uv, int num)\n{\n    float seg = 0.0;\n    \n    // Segment 1 (haut)\n    seg += segment(uv.yx + vec2(-1.0, 0.0), num != -1 && num != 1 && num != 4);\n\n    // Segment 2 (haut gauche)\n    seg += segment(uv.xy + vec2(0.5, -0.5), num != -1 && num != 1 && num != 2 && num != 3 && num != 7);\n\n    // Segment 3 (haut droit)\n    seg += segment(uv.xy + vec2(-0.5, -0.5), num != -1 && num != 5 && num != 6);\n\n    // Segment 4 (milieu)\n    seg += segment(uv.yx + vec2(0.0, 0.0), num != -1 && num != 0 && num != 1 && num != 7);\n\n    // Segment 5 (bas gauche)\n    seg += segment(uv.xy + vec2(0.5, 0.5), num == 0 || num == 2 || num == 6 || num == 8);\n\n    // Segment 6 (bas droit)\n    seg += segment(uv.xy + vec2(-0.5, 0.5), num != -1 && num != 2);\n\n    // Segment 7 (bas)\n    seg += segment(uv.yx + vec2(1.0, 0.0), num != -1 && num != 1 && num != 4 && num != 7);\n\n    return seg;\n}\n\nvec3 drawNumber(vec3 col, vec2 uv, float r, float angle, int num)\n{\n    vec2 offset = r * vec2(cos(angle), sin(angle));\n    float seg = 0.0;\n    vec2 pos = (uv - offset) * 13.0;\n    \n    if (num == 10 || num == 11 || num == 12)\n    {\n        seg += sevenSegment(vec2(pos.x+0.7, pos.y), 1);\n        \n        if (num == 10)\n            seg += sevenSegment(vec2(pos.x - 0.8, pos.y), 0);\n        else if (num == 11)\n            seg += sevenSegment(vec2(pos.x - 0.6, pos.y), 1);\n        else if (num == 12)\n            seg += sevenSegment(vec2(pos.x - 0.8, pos.y), 2);\n    }\n    else\n    {\n        seg = sevenSegment((uv - offset) * 13.0, num);\n    }\n\n    if (seg < 0.0)\n        seg = -seg;\n\n    col = mix(col, vec3(1.0, 1.0, 1.0), seg);\n    return col;\n}\n\n\n\n\nfloat gouYu(vec2 p, float progress) {\n    float pct = circle(p, 0.2 - 0.1 * progress);\n    pct += semicircle(p + vec2(-0.2 - 0.2 * progress, 0.0), 0.3);\n    pct -= semicircle(p + vec2(-0.6, 0.0), 0.15 + 0.05 * progress);   \n    return step(1.0, pct);\n}\n\nfloat eye(vec2 p, float gouyuState) {\n    float pct = circle_perfect(p, 0.9);   \n    \n    float scale = 3.0 - 1.78 * gouyuState;\n    float offsetScale = 1.5 - 1.4 * gouyuState;\n    \n    vec2 uv = scale * p;\n\n    vec2 offset = - offsetScale * vec2(cos(PI / 3.0), sin(PI / 3.0));\n    vec2 pTemp = rotate2d(PI) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);\n    pTemp = rotate2d(5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n    pTemp = rotate2d(-5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n\n    pct -= (1.0 - 4.0 * gouyuState) * circle_perfect(p, 0.06);\n    pct -= ring(p, 0.28) * (1.0 - gouyuState);\n    pct -= ring(p, 0.48);\n    \n    float opacity = 1.0 - length(p) * length(p) * length(p);\n    return pct * opacity;\n}\n\nvec4 sharingan(vec2 st, float openProcess, float mangekyoSharinganProgress, float t) {\n    \n    vec4 color = vec4(0.0);\n    float height = 0.55 * abs(mod(0.5 * iTime, 1.1) - 0.55);\n    height = 0.55 * openProcess;\n\n    float t1 = (clamp(t, 2.0, 8.0) - 2.0) / 6.0;\n    float x = sin(t1 * PI * 0.5);\n    x = x * x * x;\n    mat2 eyeRotate = rotate2d(-x * x * 16.0) * 1.0;\n    \n    vec2 eyeoffset = vec2(0.0, 0.0);\n    float pct = 1.0;\n    //color += vec4(pct) - circle(3.6 * st  + eyeoffset, 0.5) * pct;  \n\n    pct *= eye((1.0 * st + eyeoffset) * eyeRotate, mangekyoSharinganProgress);\n  \n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0);\n    \n    \n\n    // ----  ---- //\n    float opacity = 0.2;\n    float t2 = clamp(t, 0.5, 1.5) - 0.5;\n    //t2 = 1.0;\n    float scale = clamp(.2 / t2, 0.3, 1.0);\n    opacity = (scale - 0.3) * 0.5  * step(1.0, openProcess);\n    pct = eye((3.0 * st + eyeoffset) * scale * eyeRotate, mangekyoSharinganProgress);\n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0) * opacity;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float mils = fract(iDate.w);\n    float secs = mod(floor(iDate.w), 60.0);\n    float mins = mod(floor(iDate.w / 60.0), 60.0);\n    float hors = mod(floor(iDate.w / 3600.0), 24.0);\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    float r = length(uv);\n    float a = atan(uv.y, uv.x) + 3.1415926;\n\n    vec3 nightColor = vec3(0.0, 0.0, 0.0) + 0.1 * uv.y;\n    vec3 dayColor = vec3(0.0, 0.0, 0.0) + 0.2 * uv.y;\n    vec3 col = mix(nightColor, dayColor, smoothstep(5.0, 7.0, hors) -\n                              smoothstep(19.0, 21.0, hors));\n    \n                              \n    \n\n    float f = abs(2.0 * fract(0.5 + a * 60.0 / 6.2831) - 1.0);\n    float g = 1.0 - smoothstep(0.0, 0.1, abs(2.0 * fract(0.5 + a * 12.0 / 6.2831) - 1.0));\n    float w = fwidth(f);\n    f = 1.0 - smoothstep(0.1 * g + 0.05 - w, 0.1 * g + 0.05 + w, f);\n    f *= smoothstep(0.85, 0.86, r + 0.05 * g) - smoothstep(0.94, 0.95, r);\n    col = mix(col, vec3(1.0, 0.0, 0.0), f);\n\n    vec2 dir;\n    dir = vec2(sin(6.2831 * secs / 60.0), cos(6.2831 * secs / 60.0));\n    col = line(col, vec2(0.0), dir * 0.9, uv, vec2(0.005, 1.0), vec4(1.0, 1.0, 1.0, 1.0));\n\n    dir = vec2(sin(6.2831 * mins / 60.0), cos(6.2831 * mins / 60.0));\n    col = line(col, vec2(0.0), dir * 0.7, uv, vec2(0.015, 1.0), vec4(1.0, 1.0, 1.0, 1.0));\n\n    dir = vec2(sin(6.2831 * hors / 12.0), cos(6.2831 * hors / 12.0));\n    col = line(col, vec2(0.0), dir * 0.4, uv, vec2(0.015, 1.0), vec4(1.0, 1.0, 1.0, 1.0));\n    \n    //col = mix( col, vec3(0.1), 1.0-smoothstep(0.050,0.055,r) );\n    \n\n    float angle6 = (9.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle6, 6);\n\n\n    float angle7 = (8.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle7, 7);\n\n\n    float angle8 = (7.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle8, 8);\n\n\n    float angle9 = (6.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle9, 9);\n\n\n    float angle10 = (5.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle10, 10);\n\n\n    float angle11 = (4.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle11, 11);\n\n\n    float angle12 = (3.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle12, 12);\n    \n\n    float angle1 = (2.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle1, 1);\n\n\n    float angle2 = (1.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle2, 2);\n\n\n    float angle3 = (0.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle3, 3);\n\n\n    float angle4 = (-1.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle4, 4);\n\n    float angle5 = (-2.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle5, 5);\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    st = st * 2.0 - 1.0;\n    st *= 1.5;\n    st.x -= 1.2;\n    st.x = -st.x;\n\n    st = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.xy;\n    col += Tsukuyomi(st) * ((clamp(2.0 * iTime, 1.0, 3.0) - 1.0) / 2.0);\n    \n    float time = mod(iTime, 15.0);\n    float openProcess = clamp(time, 0.0, 0.5) * (12.0 - clamp(time, 11.5, 12.0)) * 4.0;\n    float sharinganProgress = (clamp(time, 4.0, 6.0) - 4.0) * 0.5;\n     //float sharinganProgress =0.2;\n    vec4 color = sharingan(uv, openProcess, sharinganProgress, time);\n    col += color.xyz;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfsczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 221, 221, 305], [306, 306, 329, 329, 392], [393, 393, 425, 425, 481], [483, 483, 522, 522, 555], [557, 557, 587, 587, 636], [638, 638, 673, 673, 779], [782, 782, 829, 829, 954], [956, 956, 1037, 1037, 1180], [1183, 1183, 1206, 1206, 1337], [1339, 1339, 1372, 1372, 1711], [1713, 1713, 1742, 1742, 2209], [2211, 2211, 2237, 2237, 2435], [2437, 2437, 2462, 2462, 2687], [2689, 2689, 2743, 2743, 2792], [2794, 2794, 2853, 2853, 3636], [3638, 3638, 3663, 3663, 3981], [3982, 3982, 4020, 4020, 4869], [4871, 4871, 4938, 4938, 5621], [5626, 5626, 5663, 5663, 5878], [5880, 5880, 5917, 5917, 6655], [6657, 6657, 6743, 6743, 7684], [7686, 7686, 7741, 7741, 11141]], "test": "ok"}
{"id": "MclcWN", "name": "Machination", "author": "darnok", "description": "infinite square tunnel", "tags": ["raymarching", "tunnel", "square", "infinite"], "likes": 8, "viewed": 64, "published": 3, "date": "1721202703", "time_retrieved": "2024-07-18T23:33:21.499992", "image_code": "#define PI     3.14159265\n#define MAX_DIST     150.\n#define YWave  5.\n\nfloat degToRad(float d) {\n    return PI * d / 180.;\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Funtion Distance\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Distance to the scene\nfloat map(vec3 p, float timeRad) {      \n    vec3 squareSize = vec3(60., 60., 0.1);\n    \n    float distFract = 2.;\n    \n    float idBlock = p.z - (mod(p.z, distFract));\n    float blockDistCoef = idBlock / 10.;\n    float blockYDistortion = 3. * idBlock / 10.;\n    float blockRot = 20. * idBlock / MAX_DIST;\n    \n    float distCenter = min(73., 63. - 1. * sin(timeRad) * 2.5 * (1. + blockDistCoef));\n    \n    vec3 pos = p;\n    pos.z = mod(p.z, distFract) - (distFract / 2.);\n    \n    pos.y += sin(blockYDistortion + timeRad * YWave);\n    pos.xy *= rot2D(blockRot * timeRad);\n    \n    float squareLeft = sdBox(pos - vec3(-distCenter, 0., 0.2), squareSize);\n    float squareTop = sdBox(pos - vec3(0., -distCenter, 0.4), squareSize);\n    float squareRight = sdBox(pos - vec3(distCenter, 0., 0.6), squareSize);\n    float squareBottom = sdBox(pos - vec3(0., distCenter, 0.8), squareSize);\n    \n    return min(\n        min(squareLeft, squareTop),\n        min(squareRight, squareBottom)\n    );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float timeRad )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, timeRad ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, timeRad ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, timeRad ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, timeRad ) );    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor, float timeRad )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor, timeRad );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.);//(iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, 0);                     // ray origin\n    vec3 rd = normalize(vec3(uv, 1));             // ray direction\n    vec3 col = vec3(0);                           // final pixel color\n    \n    float t = 0.;                                 // total distance travelled\n   \n    \n    float timeRad = degToRad(iTime) * 15.;\n    \n    ro.xy *= rot2D(timeRad);\n    rd.xy *= rot2D(timeRad);\n    \n    // Raymarching\n    int i;\n    vec3 p;\n    for (i = 0; i < 80; i++) {    \n        p = ro + rd * t;                     // position along the ray\n\n        float d = map(p, timeRad);                         // current distance to the scene\n\n        t += d;                                   // \"march\" the ray\n        \n        //col = vec3(i) / 80.;                    // iteration count\n       \n        if (d < .001 || t > MAX_DIST) break;          // early stop\n    }\n    \n    // Coloring\n    float distCoef = 0.05;\n    float iterationCoef = 0.005;\n    col = vec3(t * distCoef\n        + iterationCoef * float(i)); // color based on distance\n    \n    fragColor = vec4(col, 1);\n    \n    \n    float shadow = 1. - (max(0., min(t, MAX_DIST)) / MAX_DIST);\n    \n    float ao = calcAO(p, calcNormal(p, timeRad), timeRad);\n    ao = 0.5 + (0.5 * ao);\n    \n    col = shadow * ao * palette(log(t) * .05 + float(i) * 0.02 + (iTime * 0.1),\n        \n        vec3(0.558, 0.168, 0.338),\n        vec3(0.358, 0.808, 0.418),\n        vec3(-0.552, 0.338, 0.218),\n        vec3(1.975, 1.975, -0.925)); // http://dev.thi.ng/gradients/\n        \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MclcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 96, 96, 124], [126, 126, 151, 151, 235], [237, 276, 348, 348, 391], [393, 413, 442, 442, 537], [539, 564, 598, 598, 1550], [1552, 1598, 1645, 1645, 1885], [1887, 1944, 2001, 2001, 2314], [2316, 2316, 2373, 2373, 4076]], "test": "ok"}
{"id": "4cfyDN", "name": "Accent Color", "author": "ARtronClassic", "description": "Highlight red, can be adjusted to a different color.", "tags": ["accent"], "likes": 1, "viewed": 44, "published": 3, "date": "1721201125", "time_retrieved": "2024-07-18T23:33:22.252991", "image_code": "vec4 AccentColor = vec4(1,0,0,1);\nfloat Threshold = 0.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 mainTex = texture(iChannel0,uv);\n    \n    vec4 a = abs(mainTex - AccentColor);\n    vec3 b = vec3(dot(mainTex.xyz, vec3(0.299, 0.587, 0.114)));\n    float c = dot(a.xyz,b.xyz);\n    \n    if (c < Threshold)\n    fragColor = mainTex;\n    else\n    fragColor = vec4(c, c, c, mainTex.a);\n    \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cfyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 451]], "test": "error"}
{"id": "McfyW7", "name": "line study 1 - static strokes", "author": "tetrismegistus", "description": "practicing variations of drawing lines to gain mastery over primitives", "tags": ["lines", "learning", "rng"], "likes": 3, "viewed": 58, "published": 3, "date": "1721185361", "time_retrieved": "2024-07-18T23:33:23.011962", "image_code": "#define hash_f_s(s)  ( float( hashi(uint(s)) ) / float( 0xffffffffU ) )\n#define hash_f()  ( float( seed = hashi(seed) ) / float( 0xffffffffU ) )\n#define hash_v2()  vec2(hash_f(),hash_f())\n#define hash_v3()  vec3(hash_f(),hash_f(),hash_f())\n#define hash_v4()  vec3(hash_f(),hash_f(),hash_f(),hash_f())\n\nuint seed;\nuint hashi(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = fragCoord/ iResolution.y;\n    ivec2 i_coords = ivec2(fragCoord);        \n    int id = i_coords.x + i_coords.y * int(iResolution.x);\n    seed = 1235125u + uint(id);   \n    vec3 col = vec3(0.0); // Start with black background     \n    vec2 oguv  = uv;    \n    float numLines = 5.0;\n    uv *= numLines;\n    uv.y = fract(uv.y) - .5;\n    uv.x -= numLines;\n    float lineThickness = abs(oguv.y) * .1;    \n    float line = sdSegment(uv, vec2(-numLines + 2.0, 0.0), vec2(numLines - 3.0, 0.0)) - lineThickness;\n    col += smoothstep(-0.01, 0.01, -line) * vec3(hash_f()); \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McfyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 333, 333, 447], [451, 451, 492, 492, 617], [619, 619, 674, 674, 1289]], "test": "ok"}
{"id": "lcXyW7", "name": "fuzzy halo shader", "author": "cwervo", "description": "... for Folk ... hmmm", "tags": ["fuzzy", "folk"], "likes": 1, "viewed": 36, "published": 3, "date": "1721184204", "time_retrieved": "2024-07-18T23:33:23.759962", "image_code": "// Define the four points of the box\n#define P1 vec2(-0.5, -0.5)\n#define P2 vec2(0.5, -0.5)\n#define P3 vec2(0.5, 0.5)\n#define P4 vec2(-0.5, 0.5)\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n\nfloat sdBox(vec2 p, float radius, float fuzzy, vec3 haloColor, out vec3 outColor)\n{\n    // Calculate distances to each line segment\n    float d1 = sdSegment(p, P1, P2);\n    float d2 = sdSegment(p, P2, P3);\n    float d3 = sdSegment(p, P3, P4);\n    float d4 = sdSegment(p, P4, P1);\n    \n    // Get the minimum distance\n    float d = min(min(d1, d2), min(d3, d4));\n    \n    // Apply radius and fuzziness\n    float sdf = smoothstep(radius, radius * (1.0 + fuzzy), d);\n    \n    // Calculate halo color based on distance\n    outColor = mix(haloColor, vec3(0.0), sdf);\n    \n    return sdf;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float radius = 0.05;\n    float fuzzy = 0.25 + sin(iTime * 0.01);\n    vec3 haloColor = vec3(1.0, 0.5, 0.2);\n    \n    vec3 color;\n    float d = sdBox(uv, radius, fuzzy, haloColor, color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 187, 187, 321], [324, 324, 407, 455, 908], [910, 910, 965, 965, 1267]], "test": "ok"}
{"id": "lcXyWN", "name": "Parametric Trochoid", "author": "sanblu", "description": "Main elements of this shader:\n1) simple trichoid parametric curve (4 rotating circles stacked on top of each other)\n2) a separate function for controlling the \"thickness\" of the curve\n3) the curve SDF is based on piecewise line segments", "tags": ["2d", "sdf", "parametric", "trochoid"], "likes": 7, "viewed": 68, "published": 3, "date": "1721168757", "time_retrieved": "2024-07-18T23:33:24.509957", "image_code": "// The MIT License\n// Copyright © 2024 Sandro Blum\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Main elements:\n// 1) a trichoid parametric curve (4 rotating circles stacked on top of each other)\n// 2) a separate function for controlling the \"thickness\" of the curve\n// 3) the curve SDF is based on piecewise line segments (more segments for curved areas, idea by inigo quilez -> https://www.shadertoy.com/view/Xlf3zl)\n\n// note1: the concept of 2) 3) can be used for any parametric curve, doesn't need to be the trichoid curve\n\n// trochoid parametric curve\n// for context, see: https://scholarcommons.scu.edu/cgi/viewcontent.cgi?article=1004&context=math_compsci\nvec2 trochoid(float t, bvec4 clockwise, vec4 cf, vec4 weights) {\n    return 0.5 + 0.5 * (\n            weights[0] * (clockwise[0] ? vec2(cos(cf[0] * t),sin(cf[0] * t)) : vec2(sin(cf[0] * t),cos(cf[0] * t))) +\n            weights[1] * (clockwise[1] ? vec2(cos(cf[1] * t),sin(cf[1] * t)) : vec2(sin(cf[1] * t),cos(cf[1] * t))) +\n            weights[2] * (clockwise[2] ? vec2(cos(cf[2] * t),sin(cf[2] * t)) : vec2(sin(cf[2] * t),cos(cf[2] * t))) +\n            weights[3] * (clockwise[3] ? vec2(cos(cf[3] * t),sin(cf[3] * t)) : vec2(sin(cf[3] * t),cos(cf[3] * t)))\n        );\n}\n\nfloat curveThickness(float t) {\n    return 0.002 + 0.006 * sin(16.0 * t + iTime);\n}\n\nfloat minDistance(vec2 uv, vec2 pos0, vec2 pos1, float thickness0, float thickness1, float minDist) {\n        vec2 dir = normalize(pos1 - pos0);\n        vec2 nearestPoint = clamp(dot(uv - pos0, dir), 0.0, length(pos1 - pos0)) * dir + pos0;\n        float dist = length(uv - nearestPoint);\n        float thickness = mix(thickness0, thickness1, clamp(dot(uv - pos0, dir) / length(pos1 - pos0), 0.0, 1.0));\n        return min(minDist, dist - thickness); \n}\n\nfloat curveSd(vec2 uv, bvec4 clockwise, vec4 cf, vec4 weights) {\n    float minDist = FLT_MAX;\n    float t0 = 0.0;\n    float t1 = 0.02;\n    while (true) {\n        vec2 pos0 = trochoid(t0, clockwise, cf, weights);\n        vec2 pos1 = trochoid(t1, clockwise, cf, weights);\n        float thickness0 = curveThickness(t0);\n        float thickness1 = curveThickness(t1);         \n        minDist = minDistance(uv, pos0, pos1, thickness0, thickness1, minDist);\n        \n        if (t1 == PI2) {\n            break;\n        }        \n        \n        // increase segment density for curved areas\n        // idea by inigo quilez: https://www.shadertoy.com/view/Xlf3zl\n        float delta = clamp(0.0006 * length(pos0 - uv) / length(pos0 - pos1), 0.0002, 0.01 );        \n        t0 = t1;        \n        t1 = min(t1 + delta, PI2);\n    }   \n    return minDist;\n}\n\n\nvec4 randomWeights(in uint seed) {\n    uint rnd1 = pcg1d(seed);\n    uint rnd2 = pcg1d(rnd1);\n    uint rnd3 = pcg1d(rnd2);\n    uint rnd4 = pcg1d(rnd3);       \n    vec4 weights = vec4(rnd1, rnd2, rnd3, rnd4) / UINT_MAX;\n    weights /= weights.x + weights.y + weights.z + weights.w;\n    return weights;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspectRatio - (aspectRatio - 1.0) * 0.5;\n\n    // for this demo we choose just one specific trichoid configuration (there are tons of other configurations that look nice too)    \n    int n = 4;\n    bvec4 clockwise = bvec4(1, 1, 0, 1);\n    vec4 cf = vec4(1, 7, 17, 13);\n    \n    float mixRatio = smoothstep(0.3, 0.7, cos(iTime * 1.0) * 0.5 + 0.5);    \n    uint rootSeed = 1339u;\n    uint seedA = rootSeed + uint(0.5 * iTime / PI);\n    uint seedB = rootSeed * 7u + uint((0.5 * iTime + PI * 0.5) / PI);    \n    vec4 weightsA = randomWeights(seedA);\n    vec4 weightsB = randomWeights(seedB);\n    vec4 weights = mix(weightsA, weightsB, mixRatio);\n\n    float dist = curveSd(uv, clockwise, cf, weights);    \n    \n    float val = 1.0 - pow(clamp(dist,0.0,1.0),0.5);    \n    vec3 col = pal(val, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,0.5), vec3(0.8,0.9,0.3));\n    fragColor = vec4(col, 1.0);                \n}\n", "image_inputs": [], "common_code": "#define FLT_MAX 3.402823466e+38\n#define PI 3.14159\n#define PI2 6.28318530718\n#define UINT_MAX 4294967295.0\n\n// https://www.pcg-random.org/\n// http://www.jcgt.org/published/0009/03/02/\nuint pcg1d(in uint v)\n{\n    uint state = v * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXyWN.jpg", "access": "api", "license": "mit", "functions": [[1511, 1646, 1710, 1710, 2218], [2220, 2220, 2251, 2251, 2303], [2305, 2305, 2406, 2406, 2757], [2759, 2759, 2823, 2823, 3608], [3611, 3611, 3645, 3645, 3912], [3915, 3915, 3970, 3970, 4995]], "test": "error"}
{"id": "XflcWH", "name": "Prime waves 2", "author": "dray", "description": "To accompany https://www.shadertoy.com/view/MXdXDN\nwith sub-harmonics to match graphic wavelengths.", "tags": ["sound", "primes"], "likes": 3, "viewed": 63, "published": 3, "date": "1721167929", "time_retrieved": "2024-07-18T23:33:25.269925", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = U/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    O = vec4(col,1.0);\n    \n    O += float(int[](49,73,70,0,62,65,126,127,48,12,1)[int[](3,0,1,1,2,3,4,5,5,4,3,6,10,10,6,3,7,8,9,7,3,7,5,5,4,3,3)[int(U)/4-2]]>>int(U.y)/3&1);\n    \n}", "image_inputs": [], "sound_code": "#define PI 3.1415926535\n#define TAU (2.*PI)\n\nvec2 mainSound( int samp, float time )\n{\n    float oo=0., cnt=0.;\n    \n    float FUND = 8000.;\n\n#define T(PR) if ( time * 2. > PR ) { oo = oo * .9 + sin( mod( TAU / PR * FUND * time, TAU ) ); cnt = cnt * .9 + 1.; }\n\nT(2.)\nT(3.)\nT(5.)\nT(7.)\nT(11.)\nT(13.)\nT(17.)\nT(19.)\nT(23.)\nT(29.)\nT(31.)\nT(37.)\nT(41.)\nT(43.)\nT(47.)\nT(53.)\nT(59.)\nT(61.)\nT(67.)\nT(71.)\nT(73.)\nT(79.)\nT(83.)\nT(89.)\nT(97.)\nT(101.)\nT(103.)\nT(107.)\nT(109.)\nT(113.)\nT(127.)\nT(131.)\nT(137.)\nT(139.)\nT(149.)\nT(151.)\nT(157.)\nT(163.)\nT(167.)\nT(173.)\nT(179.)\nT(181.)\nT(191.)\nT(193.)\nT(197.)\nT(199.)\nT(211.)\nT(223.)\nT(227.)\nT(229.)\nT(233.)\nT(239.)\nT(241.)\nT(251.)\nT(257.)\nT(263.)\nT(269.)\nT(271.)\nT(277.)\nT(281.)\nT(283.)\nT(293.)\nT(307.)\nT(311.)\nT(313.)\nT(317.)\nT(331.)\nT(337.)\nT(347.)\nT(349.)\nT(353.)\nT(359.)\nT(367.)\nT(373.)\nT(379.)\nT(383.)\nT(389.)\nT(397.)\nT(401.)\nT(409.)\nT(419.)\nT(421.)\nT(431.)\nT(433.)\nT(439.)\nT(443.)\nT(449.)\nT(457.)\nT(461.)\nT(463.)\nT(467.)\nT(479.)\nT(487.)\nT(491.)\nT(499.)\nT(503.)\nT(509.)\nT(521.)\nT(523.)\nT(541.)\n\nreturn vec2(.2*oo/cnt);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XflcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "XcXyWM", "name": "jul162024", "author": "brendanluu", "description": "y'all need moire?", "tags": ["godtier"], "likes": 1, "viewed": 55, "published": 3, "date": "1721164364", "time_retrieved": "2024-07-18T23:33:26.024908", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.616, 0.157, 0.106);\n    vec3 b = vec3(1.000, 0.639, 0.851);\n    vec3 c = vec3(0.310, 0.012, 0.216);\n    vec3 d = vec3(1.000, 0.439, 0.682);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float d = length(uv);\n\n    // Base resolution\n    vec2 baseResolution = vec2(1280.0, 720.0);\n\n    // Calculate resolution factor\n    float resolutionFactor = length(iResolution.xy / baseResolution);\n\n    // Adjust time relative to the resolution\n    float adjustedTime = iTime + 200.0 * resolutionFactor;\n\n    vec3 col = palette(d * adjustedTime * 69.0);\n\n    d = cos(d * 1.3 + (adjustedTime * 0.55)) / 8.0;\n    d = abs(d);\n\n    d = 0.035 / d;\n\n    col *= d;\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcXyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 233], [235, 235, 290, 290, 886]], "test": "ok"}
{"id": "4ffyRM", "name": "GrayScott_UI", "author": "kosalos", "description": "diffusion", "tags": ["grayscott"], "likes": 1, "viewed": 67, "published": 3, "date": "1721147921", "time_retrieved": "2024-07-18T23:33:26.961908", "image_code": "// Use the Mouse to draw walls.\n//\n// Keyboard Commands:\n//\n// <Q>,<W> alter Feed Rate\n// <A>,<S> alter Kill Rate\n// <Z>,<W> alter Diffusion rate A\n// <E>,<R> alter Diffusion rate B\n// <D>,<F> alter Scale\n//\n// <Return> Reset everything \n// <Space>  Reset just the Population\n//--------------------------------------------------------------\n\nvoid displaySettings(inout vec4 fragColor, in vec2 fragCoord,int offset) {\n    if(fragCoord.x > iResolution.x * 0.6) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.5) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(30,30);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.8,0.9) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n    \n    if(offset == 1) {\n     t.color.xyz = vec3(0.);\n     t.fragCoord += vec2(-2.,3.);\n    }\n    \n    String str;\n    setString(str,14,(cQ,cW,cSp,cF,ce,ce,cd,cr,ca,ct,ce,cSp,cSp,cSp));\n    printString(str,t);\n    printFloat(qFeedRate,t);\n    newlineCursor(t);\n    \n    setString(str,14, (cA,cS,cSp,cK,ci,cl,cl,cr,ca,ct,ce,cSp,cSp,cSp));\n    printString(str,t);\n    printFloat(qKillRate,t);\n    newlineCursor(t);\n    t.fragCoord += vec2(0.,10.);\n\n    setString(str,14, (cZ,cX,cSp,cD,ci,cf,cf,cu,cs,ci,co,cn,cA,cSp));\n    printString(str,t);\n    printFloat(qDiffusionRateA,t);\n    newlineCursor(t);\n    \n    setString(str,14, (cE,cR,cSp,cD,ci,cf,cf,cu,cs,ci,co,cn,cB,cSp));\n    printString(str,t);\n    printFloat(qDiffusionRateB,t);\n    newlineCursor(t);\n    t.fragCoord += vec2(0.,10.);\n\n    setString(str,14, (cD,cF,cSp,cS,cc,ca,cl,ce,cSp,cSp,cSp,cSp,cSp,cSp));\n    printString(str,t);\n    printFloat(qScale,t);\n    newlineCursor(t);\n\n    drawText(t, iChannel2, fragColor);\n}\n\n\n// ----------------------------------------------------------\n// coloring:  https://www.shadertoy.com/view/ls2Bz1\n\nfloat saturate (float x) { return min(1.0, max(0.0,x)); }\nvec3 saturate (vec3 x) { return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x)); }\n\nvec3 bump3y (vec3 x, vec3 yoffset) {\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\nvec3 spectral_zucconi (float w) {\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// ----------------------------------------------------------\n\nvoid drawGrid(inout vec4 fragColor,in vec2 fragCoord) {\n    // screen coord -> grid\n    fragCoord /= iResolution.xy;  // 0 ... 1\n    ivec2 addr = ivec2(int(float(GRIDX) * fragCoord.x),int(float(GRIDY) * fragCoord.y));\n\n    vec4 data = fetchData(iChannel0, addr);\n    \n    fragColor.xyz = vec3(0.);\n    if(data.x != WALL) \n        fragColor.xyz = spectral_zucconi(fract(data.x) * 300. + 400.);\n}\n\n// ---------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    drawGrid(fragColor,fragCoord);\n    \n    getSettings(iChannel0);\n    if(iFrame - int(qFrame) < 20) {\n        displaySettings(fragColor,fragCoord,1);\n        displaySettings(fragColor,fragCoord,0);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void saveSettings(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor.xyz = q[i];\n            return;\n        }\n}\n\n// ----------------------------------------------------------\n\nconst float RNDCHANCE = 0.01;\nconst float YSTART = 0.83;\n\nvoid resetDiffusion(inout vec4 color,vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    if(adr.x < GRIDX && adr.y < GRIDY) {\n        if(color.x != WALL) {\n            color.x = 1.; \n            color.y = (rndStart(coord,iTime) < RNDCHANCE) ? YSTART : 0.;\n        }\n    }\n}\n\nvoid reset(inout vec4 color,vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    if(adr.x < GRIDX && adr.y < GRIDY) {\n        color.x = 1.;\n        color.y = (rndStart(coord,iTime) < RNDCHANCE) ? YSTART : 0.;\n    }\n}\n\n// ----------------------------------------------------------\n\n#define hk 0.004\n#define adjacentWeight 0.2\n#define diagonalWeight (adjacentWeight / 1.414)\n#define centerWeight -(adjacentWeight * 4.0 + diagonalWeight * 4.0 + hk * 2.0)\n\nfloat cellV1(int x, int y, int ix, int iy) {\n    float v = texelFetch(iChannel0,ivec2(ix,iy),0).x;\n\tif (v < WALL) return v;\n    \n    return texelFetch(iChannel0,ivec2(x,y),0).x;\n}\n\nfloat cellV2(int x, int y, int ix, int iy) {\n    float v = texelFetch(iChannel0,ivec2(ix,iy),0).y;\n\tif (v < WALL) return v;\n    \n    return texelFetch(iChannel0,ivec2(x,y),0).y;\n}\n\nvoid evolveCell(inout vec4 color, vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    vec4 cell = texelFetch(iChannel0,adr,0); \n    float a = cell.x;\n    float b = cell.y;\n\n    color.z = a;\n    color.w = b;\n\n    if (a != WALL) {\n        float k = qKillRate + qKillRate * a / 100.0;\n        float f = qFeedRate + qFeedRate * a / 100.0;\n\n        // ------------------------------------------------------------\n        // neighboring pixels, wrapping around edges\n        int xp = (GRIDX + adr.x - 1) % GRIDX;\n        int xn = (GRIDX + adr.x + 1) % GRIDX;\n        int yp = (GRIDY + adr.y - 1) % GRIDY;\n        int yn = (GRIDY + adr.y + 1) % GRIDY;\n\n        // A diffusion\n        float dda = a * centerWeight;\n        dda += cellV1(adr.x, adr.y, xn, yn) * diagonalWeight;\n        dda += cellV1(adr.x, adr.y, xp, yn) * diagonalWeight;\n        dda += cellV1(adr.x, adr.y, xn, yp) * diagonalWeight;\n        dda += cellV1(adr.x, adr.y, xp, yp) * diagonalWeight;\n        dda += cellV1(adr.x, adr.y, adr.x, yn) * adjacentWeight;\n        dda += cellV1(adr.x, adr.y, adr.x, yp) * adjacentWeight;\n        dda += cellV1(adr.x, adr.y, xn, adr.y) * adjacentWeight + hk;\n        dda += cellV1(adr.x, adr.y, xp, adr.y) * adjacentWeight + hk;\n\n        // B diffusion\n        float ddb = b * centerWeight;\n        ddb += cellV2(adr.x, adr.y, xn, yn) * diagonalWeight;\n        ddb += cellV2(adr.x, adr.y, xp, yn) * diagonalWeight;\n        ddb += cellV2(adr.x, adr.y, xn, yp) * diagonalWeight;\n        ddb += cellV2(adr.x, adr.y, xp, yp) * diagonalWeight;\n        ddb += cellV2(adr.x, adr.y, adr.x, yn) * adjacentWeight;\n        ddb += cellV2(adr.x, adr.y, adr.x, yp) * adjacentWeight;\n        ddb += cellV2(adr.x, adr.y, xn, adr.y) * adjacentWeight + hk;\n        ddb += cellV2(adr.x, adr.y, xp, adr.y) * adjacentWeight + hk;\n\n        // reaction diffusion formula\n        float da = qDiffusionRateA * dda - a * b * b + f * (1.0 - a);\n        float db = qDiffusionRateB * ddb + a * b * b - (f + k) * b;\n\n\t\tcolor.z = a + da * qScale;\n\t\tcolor.w = b + db * qScale;\n\t}\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\treturn (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    bool keyPressed = bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n    if(keyPressed) qFrame = float(iFrame);\n    return keyPressed;\n}\n\n// ----------------------------------------------------------\n\nvoid wallPixel(vec2 base, int x,int y,inout vec4 fragColor, vec2 fragCoord) {\n    ivec2 adr = ivec2(int(base.x)+x,int(base.y)+y);\n    if(storeDataAddr(fragCoord,adr)) fragColor.x = WALL;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if((iFrame < 2 || keyClick(13,iChannel3)) && (iFrame & 1) == 1) { // coldstart or <Return>\n        qFeedRate = 0.02;\n        qKillRate = 0.079;\n        qDiffusionRateA = 1.1010;\n        qDiffusionRateB = 0.4;\n        qScale = 0.79;\n        saveSettings(fragColor,fragCoord);\n        reset(fragColor,fragCoord);\n        return;\n    }\n    \n    getSettings(iChannel0); \n    fragColor = fetchData(iChannel0, ivec2(fragCoord));\n\n    if(keyClick(32,iChannel3)) { // <Space>\n        resetDiffusion(fragColor,fragCoord);\n        return;\n    }\n    \n    if(fragCoord.x < float(GRIDX) && fragCoord.y < float(GRIDY)) {\n        if((iFrame & 1) == 1) \n            fragColor.xy = fragColor.zw;\n        else\n            evolveCell(fragColor,fragCoord);     \n    }\n    \n    // adding walls ------------------------------------\n    if(iMouse.z > 0.) {     // mouse down or dragged\n        vec2 mPos = vec2(GRIDX,GRIDY) * iMouse.xy / iResolution.xy; // mouse as grid position\n        for(int x=-3;x<=3;++x)\n            for(int y=-3;y<=3;++y)\n                wallPixel(mPos,x,y,fragColor,fragCoord);\n    }\n    \n    // -----------------------------------------------------------------------------------\n    if(getKeyState(81,iChannel3)) qFeedRate = clamp(qFeedRate - 0.001,0.01,0.2); // Q\n    if(getKeyState(87,iChannel3)) qFeedRate = clamp(qFeedRate + 0.001,0.01,0.2); // W\n    if(getKeyState(65,iChannel3)) qKillRate = clamp(qKillRate - 0.001,0.01,0.2); // A\n    if(getKeyState(83,iChannel3)) qKillRate = clamp(qKillRate + 0.001,0.01,0.2); // S\n    if(getKeyState(90,iChannel3)) qDiffusionRateA = clamp(qDiffusionRateA - 0.001,0.1,1.3); // Z\n    if(getKeyState(88,iChannel3)) qDiffusionRateA = clamp(qDiffusionRateA + 0.001,0.1,1.3); // X\n    if(getKeyState(69,iChannel3)) qDiffusionRateB = clamp(qDiffusionRateB - 0.001,0.1,1.3); // E\n    if(getKeyState(82,iChannel3)) qDiffusionRateB = clamp(qDiffusionRateB + 0.001,0.1,1.3); // R\n    if(getKeyState(68,iChannel3)) qScale = clamp(qScale - 0.01,0.01,10.); // D\n    if(getKeyState(70,iChannel3)) qScale = clamp(qScale + 0.01,0.01,10.); // F\n\n    saveSettings(fragColor,fragCoord); \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GRIDX  250  // terrain size\n#define GRIDY  140\n#define WALL   10.\n\n#define qFeedRate       q[0].x\n#define qKillRate       q[0].y\n#define qDiffusionRateA q[0].z\n#define qDiffusionRateB q[1].x\n#define qScale          q[1].y\n#define qFrame          q[1].z  // frame# when edits were made\nconst int ADDR_COUNT =    2;\n\nvec3[ADDR_COUNT] q;\n\nconst ivec2 Q0 = ivec2( 0,GRIDY+1);\nconst ivec2 Q1 = ivec2( 1,GRIDY+1);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0,Q1);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i) \n        q[i] = texelFetch(channel, addrList[i],0).xyz;\n}\n\n// ========================================================================\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat previousRnd = 0.;\n\nfloat rnd(vec2 c) { return fract(sin(dot(vec2(1.317,19.753),c))*413.7972); } // 0...1\n\nfloat rndStart(vec2 coord, float t) {  // 0...1\n\tpreviousRnd += rnd(coord.xy + vec2(t * 217.0));\n    return previousRnd;\n}\n\n// ========================================================================\n// https://www.shadertoy.com/view/mdsSD7\n\nconst int maxStringLength = 24;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12),\n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12)\n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11),\n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11),\n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11),\n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10),\n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10)\n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9),\n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9),\n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9),\n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8),\n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8)\n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    int count;\n    ivec2[maxStringLength] chars;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    if(val < 100) printChar(cSp,t);\n    if(val < 10) printChar(cSp,t);\n    \n    for(;;)  {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    if(texture(fontTexture, t.outUV).r > 0.2)\n        fragColor = t.outColor;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ffyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 342, 416, 416, 1939], [2057, 2057, 2083, 2083, 2114], [2115, 2115, 2139, 2139, 2192], [2194, 2194, 2230, 2230, 2303], [2305, 2305, 2338, 2375, 2634], [2699, 2699, 2754, 2782, 3093], [3151, 3151, 3207, 3207, 3415]], "test": "error"}
{"id": "4fscWN", "name": "molecule RST", "author": "nayk", "description": "combination of https://www.shadertoy.com/view/4cXcWN and  https://www.shadertoy.com/view/DtGyWh", "tags": ["fractal", "cineshader"], "likes": 2, "viewed": 86, "published": 3, "date": "1721146398", "time_retrieved": "2024-07-18T23:33:27.710905", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    \n    vec2 o_trn = ( C.xy - iResolution.xy*.5 ) / iResolution.yy;\n    o_trn*=1.5;\n    float n = (length(o_trn)-.5)/.5;\n    \n    float n_its = 33.; \n    float n_it_one_nor = 1./n_its;\n    float n_tau = 6.2831;\n    vec4 o_col = vec4(0.);\n    for(float n_it_nor = 0.; n_it_nor<1.; n_it_nor+=n_it_one_nor){\n    \n        float n_radians = n_tau * n_it_nor*iTime;\n        float n_radius = sin(iTime*0.5+n_it_nor*n_tau*3.)*.5*iTime*0.01;\n        vec2 o_p = vec2(\n            sin(n_radians), \n            cos(n_radians)\n        )*n_radius;\n        float n = length(o_trn-o_p);\n        float n_circ_rad = (0.2*cos(iTime*.5+(n_it_nor*3.+.25)*n_tau)*iTime*0.01*.5+.5)*0.15;\n        n = (n-n_circ_rad)/n_circ_rad;// signed distance field\n        n = 1.-pow(abs(n), 1./5.);\n        n = clamp(n, 0., 1.);\n        vec4 o_c = vec4(n_it_nor, 1.-n_it_nor, fract(n_it_nor+.5), 1.);\n        o_col += o_c*n;\n        }\n    vec3 n1,q,r=iResolution,\n    \n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        n1=g*d;\n     n1.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime) );\n      n1.yz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime) );\n        a=35.;\n        n1=mod(n1-a,a*2.)-a;\n           \n        s=3.+(dot(d.z,d.y));\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n           \n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.+cos(iTime*.103+.5*cos(iTime*.053))*3.,\n                    120,\n                    8.+cos(iTime*0.105)*5.\n                 )*o_col.xyz;\n         }\n      g+=e=length(n1.yz+ceil(n1.y))/s;\n     \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fscWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 1947]], "test": "error"}
{"id": "4fsyWN", "name": "New Year's Eve at Sea", "author": "sferrando", "description": "Particle fireworks over the sea.", "tags": ["claude"], "likes": 0, "viewed": 50, "published": 3, "date": "1721144923", "time_retrieved": "2024-07-18T23:33:28.556645", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define NUM_FIREWORKS 8\n#define NUM_PARTICLES 80\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nstruct Firework {\n    vec3 pos;\n    float time;\n    vec3 color;\n    float type;\n};\n\nFirework fireworks[NUM_FIREWORKS];\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid initFireworks() {\n    for (int i = 0; i < NUM_FIREWORKS; i++) {\n        float x = mix(-15.0, 15.0, hash(float(i) * 12.345));\n        float z = mix(-15.0, 15.0, hash(float(i) * 45.678));\n        float y = mix(5.0, 20.0, hash(float(i) * 78.901));\n        vec3 color = palette(hash(float(i) * 23.456));\n        float type = floor(hash(float(i) * 34.567) * 3.0);\n        fireworks[i] = Firework(vec3(x, y, z), mod(iTime + hash(float(i)), 4.0), color, type);\n    }\n}\n\nvec3 particleEffect(vec3 ro, vec3 rd, Firework fw) {\n    vec3 color = vec3(0);\n    float t = fw.time;\n    \n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        float angle = hash(float(i)) * 6.283;\n        float speed = mix(2.0, 6.0, hash(float(i) * 123.456));\n        vec3 dir;\n        \n        if (fw.type < 1.0) {\n            dir = normalize(vec3(cos(angle), hash(float(i) * 789.012) * 2.0 - 1.0, sin(angle)));\n        } else if (fw.type < 2.0) {\n            dir = normalize(vec3(cos(angle), 0.1 * (hash(float(i) * 789.012) * 2.0 - 1.0), sin(angle)));\n        } else {\n            float spiral = 2.0 * 3.14159 * hash(float(i) * 345.678);\n            dir = normalize(vec3(cos(angle + spiral * t), 0.5 * (hash(float(i) * 789.012) * 2.0 - 1.0), sin(angle + spiral * t)));\n        }\n        \n        vec3 pos = fw.pos + dir * speed * t;\n        \n        float size = mix(0.05, 0.15, hash(float(i) * 345.678));\n        float fade = 1.0 - smoothstep(1.0, 2.5, t);\n        \n        vec3 closestPoint = ro + max(0.0, dot(pos - ro, rd)) * rd;\n        float dist = length(closestPoint - pos);\n        \n        if (dist < size) {\n            float intensity = smoothstep(size, 0.0, dist) * fade;\n            vec3 particleColor = mix(fw.color, palette(hash(float(i) * 56.789)), 0.5);\n            color += particleColor * intensity * (1.0 + 0.5 * sin(20.0 * t));\n        }\n    }\n    \n    return color;\n}\n\nfloat sdWater(vec3 p) {\n    float wave1 = sin(p.x * 0.5 + iTime) * 0.5;\n    float wave2 = sin(p.z * 0.3 - iTime * 0.5) * 0.3;\n    return p.y + 2.0 + wave1 + wave2;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat getDist(vec3 p) {\n    float water = sdWater(p);\n    \n    // Add moon\n    vec3 moonPos = vec3(20.0, 15.0, 10.0);\n    float moonDist = sdSphere(p - moonPos, 3.0);\n    \n    return min(water, moonDist);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvec3 getWaterColor(vec3 p, vec3 rd, vec3 n) {\n    vec3 baseColor = vec3(0.0, 0.1, 0.2);\n    vec3 reflectDir = reflect(rd, n);\n    float fresnel = pow(1.0 - max(0.0, dot(-rd, n)), 5.0);\n    vec3 skyReflection = mix(vec3(0.0), vec3(0.1, 0.2, 0.3), reflectDir.y * 0.5 + 0.5);\n    return mix(baseColor, skyReflection, fresnel);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 2, -15);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 col = vec3(0);\n    \n    float d = rayMarch(ro, rd);\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        \n        if (p.y < -1.0) {\n            // Water surface\n            col = getWaterColor(p, rd, n);\n            // Add some specular highlight\n            vec3 lightDir = normalize(vec3(0.5, 0.8, 0.2));\n            vec3 reflectDir = reflect(-lightDir, n);\n            float spec = pow(max(dot(reflectDir, -rd), 0.0), 32.0);\n            col += vec3(1.0) * spec * 0.5;\n        } else {\n            // Moon\n            col = vec3(0.9, 0.9, 0.8);  // Moon color\n            col *= max(0.2, dot(n, normalize(vec3(-0.5, 0.8, -0.2))));  // Moon lighting\n        }\n    } else {\n        // Black background\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    \n    initFireworks();\n    for (int i = 0; i < NUM_FIREWORKS; i++) {\n        col += particleEffect(ro, rd, fireworks[i]);\n    }\n    \n    // Bloom effect\n    col += max(vec3(0), col - 0.7) * 0.5;\n    \n    // Tone mapping and gamma correction\n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 139, 139, 169], [170, 170, 190, 190, 278], [400, 400, 423, 423, 614], [616, 616, 638, 638, 1082], [1084, 1084, 1136, 1136, 2478], [2480, 2480, 2503, 2503, 2645], [2647, 2647, 2680, 2680, 2708], [2710, 2710, 2733, 2733, 2916], [2918, 2918, 2952, 2952, 3184], [3186, 3186, 3210, 3210, 3404], [3406, 3406, 3451, 3451, 3731], [3733, 3733, 3788, 3788, 5079]], "test": "ok"}
{"id": "XclyWN", "name": "2d light design test", "author": "yasuo", "description": "2d light design test. inspired by Chris Kuroda Light design", "tags": ["light", "cineshader"], "likes": 5, "viewed": 88, "published": 3, "date": "1721143107", "time_retrieved": "2024-07-18T23:33:29.378447", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),-antialiasing(1.5),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define COLORMODE 0\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nvec2 polarToCartesian(float radius, float angle) {\n    return vec2(radius * cos(angle), radius * sin(angle));\n}\n\nvec4 light2D(vec2 p, vec2 lightPos, vec3 lightCol, float intensity, float range, float deg, float angle, float noiseAngle){\n    float lightRadius = radians(range); // spot light range \n    float aspect = iResolution.x / iResolution.y;\n    lightRadius /= aspect;\n\n    vec2 spotLightDir = polarToCartesian(1.,radians(deg)); // rotate light\n    float spotAngle =  radians(angle);\n    vec2 lightDir = p - lightPos;\n    float lightDistance = length(lightDir);\n    \n    float d = step(dot(normalize(lightDir), normalize(spotLightDir)),cos(spotAngle/2.));\n    d = max((length(lightDir)-(lightRadius)),d);\n    float d2 = length(lightDir)-0.005;\n    d = min(d,d2);\n    p*=Rot(radians(noiseAngle));\n    p.y+=iTime*0.1;\n    float n = fbm(p*3.)*0.6;\n    return vec4(intensity * (1. - length(lightDir / lightRadius)) * lightCol+n,d);\n}\n\nvec3 torus(vec2 p, vec3 col, float dir, float deg, float size){\n    vec2 prevP = p;\n    p.x*=dir;\n    p*=Rot(radians(iTime*deg+30.));\n    float d = abs(length(p)-size)-0.05;\n    \n    #if COLORMODE\n    vec3 cColor = vec3(0.1,0.6,0.8);\n    #else\n    vec3 cColor = vec3(1.);\n    #endif\n    \n    col = mix(col,cColor*0.2,S(d,0.0));\n    \n    d = abs(length(p)-size)-0.05;\n    d = max(-p.x,d);\n    float a = clamp(atan(p.x,p.y)*0.5,0.3,1.);\n    col = mix(col,vec3(a)*cColor*0.3,S(d,0.0));\n    \n    return col;\n}\n\nvec3 dots(vec2 p, vec3 col){\n    p = mod(p,0.05)-0.025;\n    float d = length(p)-0.001;\n    return mix(col,vec3(1.),S(d,0.0));\n}\n\nfloat bgEffectItem(vec2 p){\n    float size = 0.5;\n    \n    p.x*=2.;\n    p.y-=size*0.5;\n    p.y-=0.3;\n    p.y-=iTime*0.5;\n    \n    p.y = mod(p.y,0.6)-0.3;\n    float d = abs(Tri(p,vec2(size)))-0.02;\n    p.x*=0.5;\n    float d2 = length(p-vec2(0.0,-0.2))-0.03;\n    return min(d,d2);\n}\n\nvec3 bgEffect(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p+=0.025;\n    p*=20.;\n    \n    vec2 id = floor(p);\n    vec2 gd = fract(p)-0.5;\n    float n = random(id);\n    \n    if(n<0.1){\n        gd*=Rot(radians(90.));\n    } else if(n>=0.1 && n<0.2){ \n        gd*=Rot(radians(180.));\n    } else if(n>=0.3 && n<0.4){ \n        gd*=Rot(radians(270.));\n    }\n    float d = bgEffectItem(gd);\n    if(n>=0.5){\n        d = 10.0;\n    }\n\n    col = mix(col,vec3(0.5),S(d,0.0));\n    return col;\n}\n\nvec3 bg(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    col = dots(p,col);\n    \n    p*=5.;\n    vec2 id = floor(p);\n    vec2 gd = fract(p)-0.5;\n    float n = random(id);\n    \n    col = torus(gd,col,(n<0.5)?1.:-1.,30.+n*30.0,0.2+n*0.1);\n    return col;\n}\n\nvec3 baseLights(vec2 p, vec3 col){\n    p.y = abs(p.y);\n    float intensity = 0.6;\n    #if COLORMODE\n    vec3 lightColor = vec3(0.3,0.9,0.8);\n    #else\n    vec3 lightColor = vec3(1.);\n    #endif\n    vec4 d = light2D(p,vec2(-0.1,0.1),lightColor,intensity,15.,220.+sin(-iTime*1.5)*5.,10.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.1,0.1),lightColor,intensity,15.,320.+sin(iTime*1.5)*5.,10.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    \n    d = light2D(p,vec2(0.09,0.1),lightColor,intensity,10.,180.+sin(-iTime*2.)*5.,10.,-90.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(-0.09,0.1),lightColor,intensity,10.,0.+sin(-iTime*2.)*5.,10.,90.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    \n    d = light2D(p,vec2(-0.1,0.1),lightColor,intensity,15.,320.+sin(-iTime*2.)*5.,10.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.1,0.1),lightColor,intensity,15.,220.+sin(-iTime*2.)*5.,10.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    \n    return col;\n}\n\nvec3 lightsSystemBack(vec2 p, vec3 col){\n    p.x = abs(p.x);\n    vec2 prevP = p;\n    vec3 d = vec3(0.);\n    for(float i = 0.; i<5.; i++){\n        p*=Rot(radians(i*65.0+sin(i)*5.*-iTime));\n        p = abs(p)-0.18;\n        p.y+=0.05;\n        d = baseLights(p,col);\n    }\n    \n    return d;\n}\n\nvec3 lightsSystemMain(vec2 p, vec3 col){\n    p.y = abs(p.y);\n    p.y*=-1.;\n    float intensity = 0.5;\n    vec4 d = light2D(p,vec2(-0.09,-0.2),vec3(1.0),intensity,50.,-80.+sin(-iTime)*5.,20.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.09,-0.2),vec3(1.0),intensity,50.,-100.+sin(iTime)*5.,20.,-10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    \n    d = light2D(p,vec2(-0.18,-0.23),vec3(1.0),intensity,50.,-80.+sin(-iTime*1.1)*5.,10.,-10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.18,-0.23),vec3(1.0),intensity,50.,-100.+sin(iTime*1.1)*5.,10.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    \n    d = light2D(p,vec2(-0.25,-0.27),vec3(1.0),intensity,50.,-110.+sin(-iTime*1.2)*5.,20.,-10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.25,-0.27),vec3(1.0),intensity,50.,-70.+sin(iTime*1.2)*5.,20.,10.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    \n    d = light2D(p,vec2(-0.15,-0.1),vec3(1.0),intensity,120.,-30.+sin(-iTime*1.3)*5.,20.,-60.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.15,-0.1),vec3(1.0),intensity,120.,-150.+sin(iTime*1.3)*5.,20.,60.);\n    col = mix(col,d.rgb,S(d.w,0.));    \n    \n    d = light2D(p,vec2(-0.3,-0.1),vec3(1.0),intensity,90.,-130.+sin(-iTime*1.4)*5.,20.,50.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.3,-0.1),vec3(1.0),intensity,90.,-50.+sin(iTime*1.4)*5.,20.,-50.);\n    col = mix(col,d.rgb,S(d.w,0.));      \n    \n    d = light2D(p,vec2(-0.4,-0.15),vec3(1.0),intensity,90.,-180.+sin(-iTime*1.5)*5.,20.,90.);\n    col = mix(col,d.rgb,S(d.w,0.));\n    d = light2D(p,vec2(0.4,-0.15),vec3(1.0),intensity,90.,0.+sin(iTime*1.5)*5.,20.,-90.);\n    col = mix(col,d.rgb,S(d.w,0.));      \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = bgEffect(uv,col);\n    \n    col = bg(uv,col);\n    col = lightsSystemBack(uv,col);\n    col = lightsSystemMain(uv,col);\n    \n    float brightness = 1.5;\n    fragColor = vec4(col*brightness,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XclyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 387, 387, 460], [462, 611, 631, 631, 765], [767, 767, 794, 794, 1297], [1299, 1299, 1318, 1318, 1580], [1582, 1582, 1632, 1632, 1693], [1695, 1695, 1818, 1818, 2517], [2519, 2519, 2582, 2582, 3024], [3026, 3026, 3054, 3054, 3153], [3155, 3155, 3182, 3182, 3435], [3437, 3437, 3469, 3469, 3915], [3917, 3917, 3943, 3943, 4169], [4171, 4171, 4205, 4205, 5163], [5165, 5165, 5205, 5205, 5454], [5456, 5456, 5496, 5496, 7168], [7170, 7170, 7227, 7227, 7526]], "test": "ok"}
{"id": "4csyW4", "name": "Maxwell Equivalence", "author": "wyatt", "description": "Shown are 3 versions of the Maxwell equations. The part that changes is the treatment of magnetic materials. I have no clue which is \"correct\". They all converge to the same thing", "tags": ["physics", "maxwell", "em"], "likes": 12, "viewed": 143, "published": 3, "date": "1721139447", "time_retrieved": "2024-07-18T23:33:30.134427", "image_code": "Main {\n\n    float mu = 1.;\n    if ((U.x > .25*R.x && U.y > .2*R.y && U.x < .75*R.x && U.y < .8*R.y) && (U.x > .65*R.x || U.y > .65*R.y || U.x < .35*R.x || U.y < .35*R.y)) {\n        mu = 1000.;\n    }\n    \n    Q = A(U);\n    if (U.x < .5*R.x) Q = B(U);\n    if (U.y > .5*R.y) Q = C(U)/mu;\n    if (mu>1.) Q *= 10.;\n    Q = sin(-2.+length(Q.xy)+vec4(1,2,3,4));\n    \n    \n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)", "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    float j = 0.;\n    if (length(U-vec2(.2,.5)*R) < 10.) {\n        j = 1.;\n    }\n    if (length(U-vec2(.4,.5)*R) < 10.) {\n        j = -1.;\n    }\n    float mu = 1.;\n    if ((U.x > .25*R.x && U.y > .2*R.y && U.x < .75*R.x && U.y < .8*R.y) && (U.x > .65*R.x || U.y > .65*R.y || U.x < .35*R.x || U.y < .35*R.y)) {\n        mu = 1000.;\n    }\n    \n    if (iFrame%2==0) {\n        Q.xy -= 0.5*vec2(n.z-s.z,w.z-e.z)/mu;\n    } else {\n        Q.z  -= 0.5*(n.x-s.x+w.y-e.y) - j;\n    }\n    Q.z *= .9999;\n    if (U.x < 10.||R.x-U.x < 10.||R.y - U.y < 10.||U.y < 10.) Q *= .9;\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    float j = 0.;\n    if (length(U-vec2(.2,.5)*R) < 10.) {\n        j = 1.;\n    }\n    if (length(U-vec2(.4,.5)*R) < 10.) {\n        j = -1.;\n    }\n    float mu = 1.;\n    if ((U.x > .25*R.x && U.y > .2*R.y && U.x < .75*R.x && U.y < .8*R.y) && (U.x > .65*R.x || U.y > .65*R.y || U.x < .35*R.x || U.y < .35*R.y)) {\n        mu = 1000.;\n    }\n    \n    if (iFrame%2==0) {\n        Q.xy -= 0.5*vec2(n.z-s.z,w.z-e.z) + (mu-1.)/1000.*B(U).xy;\n    } else {\n        Q.z  -= 0.5*(n.x-s.x+w.y-e.y) - j;\n    }\n    \n    if (U.x < 10.||R.x-U.x < 10.||R.y - U.y < 10.||U.y < 10.) Q *= .9;\n\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    vec4 N = B(U+vec2(0,1));\n    vec4 E = B(U+vec2(1,0));\n    vec4 S = B(U-vec2(0,1));\n    vec4 W = B(U-vec2(1,0));\n    float j = 0.;\n    if (length(U-vec2(.2,.5)*R) < 10.) {\n        j = 1.;\n    }\n    if (length(U-vec2(.4,.5)*R) < 10.) {\n        j = -1.;\n    }\n    float mu = 1.;\n    if ((U.x > .25*R.x && U.y > .2*R.y && U.x < .75*R.x && U.y < .8*R.y) && (U.x > .65*R.x || U.y > .65*R.y || U.x < .35*R.x || U.y < .35*R.y)) {\n        mu = 1000.;\n    }\n    \n    if (iFrame%2==0) {\n        Q.xy -= .5*vec2(n.z-s.z,w.z-e.z);\n    } else {\n        Q.z  -= .5*(n.x-s.x+w.y-e.y-N.z+S.z-W.w+E.w) - j;\n    }\n    \n    if (U.x < 10.||R.x-U.x < 10.||R.y - U.y < 10.||U.y < 10.) Q *= .9;\n\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\n    Q = C(U);\n    float mu = 1.;\n    if ((U.x > .25*R.x && U.y > .2*R.y && U.x < .75*R.x && U.y < .8*R.y) && (U.x > .65*R.x || U.y > .65*R.y || U.x < .35*R.x || U.y < .35*R.y)) {\n        mu = 1000.;\n    }\n    if (iFrame%2==1) {\n        Q.xy = (1.-1./mu)*A(U).xy;\n        Q.zw = (1.-1./mu)*B(U).xy;\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4csyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "lcfcDN", "name": "Look At Me", "author": "Peace", "description": "it's searching for sins and cosines in your soul...\nfound one", "tags": ["flame", "eye", "iris", "pupil", "sclera"], "likes": 13, "viewed": 103, "published": 3, "date": "1721138153", "time_retrieved": "2024-07-18T23:33:30.886416", "image_code": "vec2 hash21(float n) {\n    return fract(sin(vec2(n, n + 1.0)) * vec2(43758.5453123, 22578.1459123)) * 2.0 - 1.0;\n}\n\nfloat hash11(float n) {\n    return fract(sin(n) * 43758.5453123) * 2.0 - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y) * 0.7;\n    float f = length(fwidth(uv)) * 4.5;\n\n    float anim = smoothstep(0.85, 0.92, abs(sin(iTime * 0.5)));\n    \n    float a = 0.04 - hash11(iTime) * anim * 0.01;\n    uv = cos(a) * uv + sin(a) * vec2(-uv.y, uv.x);\n    uv -= vec2(0.06, 0.3);\n    \n    uv += normalize(hash21(iTime)) * 0.01 * anim;\n    \n    float BLINK = smoothstep(0.0, 0.1, abs(sin(iTime * 0.5))) * 0.7 + 0.4 - anim * 0.1; // + anim * 0.8 for creepy result\n    float sclera = distance(uv * vec2(0.5, -0.85 / BLINK), vec2(0)) - 0.5;\n    sclera = max(sclera, distance(uv * vec2(0.18, -1.0 / BLINK), vec2(-0.15, 0.4 / BLINK)) - 0.3);\n    float sclera_mask = smoothstep(f, 0.0, sclera);\n    \n    vec2 IRIS_POS = vec2(-0.05, -0.4) - normalize(hash21(-iTime * 0.7)) * 0.01 * anim;\n    float iris = distance(uv, IRIS_POS) - 0.3 + anim * 0.1;\n    float iris_mask = smoothstep(f, 0.0, iris) * sclera_mask;\n    float iris_angle = abs(atan(uv.y - IRIS_POS.y, uv.x - IRIS_POS.x));\n    \n    \n    vec3 sclera_col = vec3(1) * smoothstep(f, 0.0, sclera);\n    sclera_col -= max(vec3(0), sin(iris * iris * 2.0 - vec3(0.015, 0.421, 0.585))) * (1.0 - iris_mask); // Sclera Color\n    vec3 col = sclera_col; \n    col -= max(vec3(0), 1.0 - vec3(0.193,0.562,0.890) - iris) * iris_mask; // Iris Color\n    col += (0.5 + col) * smoothstep(-0.1, 0.05, iris) * iris_mask; // Iris Glow\n    col -= smoothstep(-0.12, -0.2, iris); // Pupil\n    col -= 0.4 * smoothstep(-0.05, 0.05, sclera); // Sclera Darken\n    col += cos(iris_angle * 11.0 + cos(iris_angle * 18.0 - iris * 38.0 + iTime * 2.1)) * cos(iris_angle * 12.0) * iris_mask * 0.2; // Iris Texture\n    col = max(vec3(0), col);\n    col += vec3(0.063,0.396,0.655) * (1.0 - sclera_mask); // Background\n    col += vec3(1.000,0.366,0.318) * 0.013 / max(0.001, sclera * sclera) * sclera * (1.0 - sclera_mask); // Glow\n    col *= smoothstep(0.7, 0.5, 0.013 / max(0.0001, sclera)) + sclera_mask; // Eye Darks?\n    col -= smoothstep(0.1, 0.2, 0.013 / max(0.0001, sclera)) * (1.0 - sclera_mask) * max(0.0, -sin(uv.y * 13.0 + uv.x * (2.0 + uv.x))) * (0.5 - 0.5 * uv.x); // Eye Lashes\n    col += 0.0035 / max(0.001, sclera) * (1.0 - sclera_mask + smoothstep(0.7, 0.5, 0.013 / max(0.0001, sclera))) * (0.5 + 0.5 * uv.x);\n    col = clamp(col, vec3(0), vec3(1));\n    \n    // Try messing with these lines, it produces cool results\n    col = 1.0 - col;\n    if (sin(iTime * 0.5) >= 0.0)\n        col = dot(col, col) * (1.0 - col);\n    col = dot(col, col) * (1.0 - col);\n    col = dot(col, col) * (uv.x * 0.5 + 0.95 - col);\n    col *= 1.0 + anim * 0.25; // anim * 0.6 for more intensity\n    col = dot(col, col) * (1.0 - col);\n    col = pow(col, vec3(1.0 + anim * 2.0));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "sound_code": "float noise(vec2 p) {\n    return smoothstep(-0.5, 0.9, sin((p.x - p.y) * 555.0) * sin(p.y * 1444.0)) - 0.4;\n}\n\nfloat fabric(vec2 p) {\n    const mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.0;\n    f += 0.4 * noise(p); p = m * p;\n    f += 0.3 * noise(p); p = m * p;\n    f += 0.2 * noise(p); p = m * p;\n    f += 0.1 * noise(p);\n    return f;\n}\n\n\nvec2 mainSound(int samp, float t) {\n    float anim = smoothstep(0.85, 0.99, abs(sin(t * 0.5)));\n    float s = fabric(vec2(0, t) * (0.09 + sqrt(anim) / t * 0.1));\n    return vec2(s) * 0.4;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 114], [116, 116, 139, 139, 195], [197, 197, 249, 249, 3017]], "test": "ok"}
{"id": "4cXcWN", "name": "triangle thing 2", "author": "jonasfrey", "description": "triangle circle thing", "tags": ["triangle"], "likes": 7, "viewed": 76, "published": 3, "date": "1721118597", "time_retrieved": "2024-07-18T23:33:31.637409", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn = ( fragCoord.xy - iResolution.xy*.5 ) / iResolution.yy;\n    o_trn*=1.5;\n    float n = (length(o_trn)-.5)/.5;\n    \n    float n_its = 33.; \n    float n_it_one_nor = 1./n_its;\n    float n_tau = 6.2831;\n    vec4 o_col = vec4(0.);\n    for(float n_it_nor = 0.; n_it_nor<1.; n_it_nor+=n_it_one_nor){\n    \n        float n_radians = n_tau * n_it_nor;\n        float n_radius = sin(iTime*0.5+n_it_nor*n_tau*3.)*.5;\n        vec2 o_p = vec2(\n            sin(n_radians), \n            cos(n_radians)\n        )*n_radius;\n        float n = length(o_trn-o_p);\n        float n_circ_rad = (sin(iTime*.5+(n_it_nor*3.+.25)*n_tau)*.5+.5)*0.15;\n        n = (n-n_circ_rad)/n_circ_rad;// signed distance field\n        n = 1.-pow(abs(n), 1./5.);\n        n = clamp(n, 0., 1.);\n        vec4 o_c = vec4(n_it_nor, 1.-n_it_nor, fract(n_it_nor+.5), 1.);\n        o_col += o_c*n;\n        //o_col += vec4(n);\n    }\n    fragColor = o_col;\n    //fragColor = sqrt(fragColor);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cXcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1063]], "test": "ok"}
{"id": "XfXyW4", "name": "other galaxy", "author": "nayk", "description": "combination of https://www.shadertoy.com/view/lXsSRN https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/wdtczM", "tags": ["galaxy", "stars", "universe"], "likes": 2, "viewed": 89, "published": 3, "date": "1721112352", "time_retrieved": "2024-07-18T23:33:32.396380", "image_code": "\n\n#define iterations 14\n#define formuparam 0.50\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.04,1.);\t\n}\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec2 r(vec2 p, float a) { return p*mat2(cos(a), sin(a), -sin(a), cos(a)); }\n#define R iResolution.xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec4 O = fragColor; vec2 I = fragCoord;\n      vec2 uv3 = I/R;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.005);\n\tfloat time=iTime*speed+.25;\n     vec2 uv2 = fragCoord / iResolution.xy;\n vec2 adjustedUV = (uv2 - 0.5) * 3.5;\n    float timeFactor = iTime * 0.025;\n    vec4 outputColor = vec4(0.0);\n    float x;\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    vec4 o = fragColor;\n vec2 R2 = iResolution.xy; \n    o-=o;\n    for(float d,t = -iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( I - R2 *.5 ) / R2.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1);                     \n    }\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t \n    vec2 p = (2.*I - R) / R.y * 1.5;\n    \n    float fp = pow(.5/length(pow(abs(r(p,.43))\n        *vec2(2,1),vec2(.5))),4.5);\n       \n    p *= mat2(.7,-.5,-.4,1.2);    \n    vec3 pos = normalize(vec3(r(p,-.4/length(p)),.25));\n    pos.z -= iTime*1.1;\n    \n    vec3 q = 6.*pos;\n    float f  = 0.5000*noise( q ); q = q*2.;\n          f += 0.2500*noise( q ); q = q*2.;\n          f += 0.1250*noise( q ); q = q*2.;\n          f += 0.0625*noise( q );\n    \n    vec2 n = uv3*(1.-uv)*3.; float v = pow(n.x*n.y,.8);\n    \n    float fr = .6/length(p);\n    f = smoothstep(-.4,2.,f*f) * fr*fr + fp;\n    \n    O = vec4(aces_tonemap(\n        pow(f*f * vec3(1., .05, 1.0)*v,vec3(.45))*3.5),0);\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n    vec3 color;\n    for (float waveIndex = 0.0; waveIndex < 25.0; waveIndex += 1.0) {\n        vec2 waveVector = vec2(cos(x = waveIndex * 15. - timeFactor), sin(x));\n        float wave = sin(waveIndex * mix(0.05, 0.5, sin(timeFactor) * 0.5) - timeFactor);\n        float distance = length(adjustedUV - wave * waveVector); \n        \n        for(int i=0;i<3;i++) {\n            float z = waveIndex * 0.000002;\n            float l = distance;\n            vec2 uv = adjustedUV;\n            uv += waveVector/l*(sin(z)+5.)*abs(sin(l*1.1-z-z));\n            color[i] = 0.0013/length(mod(uv + vec2(0.003 * float(i-1)),1.1)-0.5); \n        }\n        color *= vec3(0.49, 0.49, 1.0)+o.xyz; \n        outputColor += vec4(color / distance, 2.0);\n    }\n\t\n    \n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=outputColor*5.;\n    fragColor*=O*2.;\n    fragColor*=vec4(min(pow(abs(col), vec3(1.0)), 1.0), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 337, 365, 1173], [1174, 1174, 1245, 1321, 1523], [1525, 1525, 1551, 1551, 2041], [2043, 2084, 2114, 2114, 2561], [2563, 2563, 2588, 2588, 2638], [2664, 2664, 2721, 2749, 6192]], "test": "ok"}
{"id": "McfcDH", "name": "jul152024", "author": "brendanluu", "description": "bruh", "tags": ["wave", "spiral", "fibonacci", "logarithmic", "golden"], "likes": 0, "viewed": 43, "published": 3, "date": "1721111714", "time_retrieved": "2024-07-18T23:33:33.145377", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.686,0.071,0.071);\n    vec3 b = vec3(1.000,0.639,0.851);\n    vec3 c = vec3(0.310,0.012,0.216);\n    vec3 d = vec3(1.000,0.439,0.682);\n    \n    return a + b*cos(6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n\n    float d = length(uv);\n    \n    vec3 col = palette(d);\n        \n    d = cos(d*1.3 + (iTime))/8.;\n    d = abs(d);\n    \n    d = 0.035 / d;\n    \n    col *= d;\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McfcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 222], [224, 224, 281, 281, 578]], "test": "ok"}
{"id": "McscDH", "name": "black and white3", "author": "nayk", "description": "originals  https://www.shadertoy.com/view/XcfyWH", "tags": ["fractal", "blackandwhite", "cineshader"], "likes": 1, "viewed": 44, "published": 3, "date": "1721111265", "time_retrieved": "2024-07-18T23:33:33.895373", "image_code": "\nfloat intensity = 1.0;\nfloat radius2 = 0.05;\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n//Distance functions from\n//https://iquilezles.org/articles/distfunctions2d\nfloat triangleDist(vec2 p){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n    vec2 d = abs(p)-1.0;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n   \n   \n   \n    vec2 uv2  =fragCoord/iResolution.xy-0.5;\nuv*=2.5;\n\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre;\n    vec2 pos;\n\n    float t = -iTime * 0.05;\n   \n    float dist;\n    float glow;\n    vec3 col = vec3(0);\n   \n    //The spacing between shapes\n    const float scale = 150.0;\n    //Number of shapes\n    const float layers = 10.0;\n   \n    float depth;\n    vec2 bend;\n   \n    const vec3 purple = vec3(0.611, 0.129, 0.909);\n    const vec3 green = vec3(0.133, 0.62, 0.698);\n   \n    float angle;\n    float rotationAngle;\n    mat2 rotation;\n   \n    //For movement of the anchor point in time\n    float d = 2.5*(sin(t) + sin(3.0*t));\n\n    //Create an out of frame anchor point where all shapes converge to    \n    //vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    vec2 anchor = vec2(0.5);\n\n    //Create light purple glow at the anchor loaction\n    pos = anchor - uv;\n  \n    dist = length(pos);\n    glow = getGlow(dist, 0.35, 0.9);\n\n   \nfor(float i = 0.0; i < layers; i++){\n       \n       \n        depth = fract(i/layers + t);\n\n        //Move the focus of the camera in a circle\n        //centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        centre = vec2(0.0);\n        //Position shapes between the anchor and the camera focus based on depth\n        bend = mix(anchor, centre, depth);\n     \n        pos =  uv;\n\n\n        //Rotate shapes\n        rotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + i;\n        rotation = mat2(cos(rotationAngle), -sin(rotationAngle),\n                        sin(rotationAngle),  cos(rotationAngle));\n       \n        pos *= rotation;\n       \n        //Position shapes according to depth\n    pos *= mix(scale, 0.0, depth);\n   \n        float m = mod(i, 3.0);\n        if(m == 0.0){\n        dist = abs(boxDist(pos));\n        }else if(m == 1.0){\n        dist = abs(triangleDist(pos));\n        }else{\n        dist = abs(circleDist(pos));\n        }\n       \n        //Get glow from base radius and intensity modified by depth\n    glow = getGlow(dist, radius2+(1.0-depth)*2.0, intensity + depth);\n       \n        //Find angle along shape and map from [-PI; PI] to [0; 1]\n        angle = (atan(pos.y, pos.x)+3.14)/6.28;\n        //Shift angle depending on layer and map to [1...0...1]\nangle = abs((2.0*fract(angle + i/layers)) - 1.0);\n       \n        //White core\n    col += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n       \n        //Glow according to angle value\n      col += glow * mix(green, purple, angle);\n}\n   \n  \n   \n    float radius = 0.8;\n    float smoothEdge = 0.01;\n\n    float dist2 = length(uv);\n float time = iTime;\n\n    float angle3 = atan(uv.y, uv.x);\n    float radius3 = length(uv);\n    angle3 = mod(angle3, 3.14159265 / 3.0) * 6.0;\n    uv = vec2(cos(angle3), sin(angle3)) * radius3;\n\n    vec3 color = vec3(0.0);\n\n    float r1 = 0.5;\n    float r2 = 0.2;\n\n    float scale3 = 1.;\n\n    for (int i = 0; i < 95; i++) {\n    \n        uv2 += vec2(sin(time), cos(time)) * 0.05; \n        \n        uv2 = fract(uv * scale3) - 0.5;\n        float len = length(uv2);\n        float angle3 = atan(uv2.y, uv2.x);\n\n        float d = abs(r1 - len) - r2;\n\n        vec3 kColor = vec3(.7, .7, .1) * (0.5 + 0.5 * cos(6.0 * angle3 + time));\n        color += kColor / (d * scale + 0.0);\n        \n        scale3 *= 1.3;\n    }\n\n    color = pow(color, vec3(0.4545));\n    float angle2 = iTime * 0.523598776;\nfloat t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 1.2;\n\tfloat si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n    \n    vec2 rotatedUV = uv;\n    rotatedUV.x+=cos(iTime);\n         rotatedUV.y+=sin(iTime);\n    if (dist2 < radius)\n    {\n        float s = sin(angle2);\n        float c = cos(angle2);\n        rotatedUV = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y)*ma;\n         \n    }\n\n    vec2 checker = floor(uv * 10.0);\n  \n    vec2 rotatedChecker = floor(rotatedUV *col.xy* 10.0);\n    float checkerPattern = mod(rotatedChecker.x + rotatedChecker.y, 2.0);\n \n    float circleEdge = smoothstep(radius - smoothEdge, radius + smoothEdge, dist);\n\n    float pattern = mix(checkerPattern, checkerPattern, circleEdge);\n\n    vec3 color2 = vec3(pattern);\n\n    fragColor = vec4(color*color2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McscDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 85, 85, 231], [234, 310, 337, 337, 546], [548, 548, 570, 570, 656], [658, 658, 684, 684, 712], [714, 754, 811, 811, 853], [854, 854, 909, 909, 5205]], "test": "ok"}
{"id": "lflcWH", "name": "sws3005_2024_assign5_task2", "author": "__init__", "description": "by group03", "tags": ["whittedraytracing"], "likes": 10, "viewed": 114, "published": 3, "date": "1721106726", "time_retrieved": "2024-07-18T23:33:35.376414", "image_code": "//============================================================================\n// PROJECT ID: 02\n//\n// GROUP NUMBER: 03\n//\n// STUDENT NAME: CHEN ZHIAN\n// NUS User ID.: t0933479\n//\n// STUDENT NAME: LI YIXIN\n// NUS User ID.: t0933820\n//\n// STUDENT NAME: OUYANG ANNAN\n// NUS User ID.: t0933394\n//\n// COMMENTS TO GRADER: This is the pass 4 shader which will output to the screen.\n//                     Therer are 3 input need to be configured in shadertoy:\n//                     iChannel0: BufferA\n//                     iChannel1: BufferB\n//                     iChannel2: CubeA\n//\n//                     We use multiple passes and this is only a part of tasks2.\n//                     There are 1 common file and 4 pass files in total.\n//                     The complete project is in the following link:\n//                     https://www.shadertoy.com/view/lflcWH\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst bool TURN_OFF_AABB_OPTIMIZATION = false;\n\nconst float PI = 3.1415926536;\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Camera_t {\n    vec3 pos;\n    vec3 x;\n    vec3 y;\n    vec3 z;\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Triangle_t {\n    vec3 A, B, C;\n    int materialID;\n};\n\nstruct Barycentric_t {\n    float alpha, beta, gamma;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\nvec4 texelFetch( sampler2D tex, int index )\n{\n    int x = index % int(iResolution.x);\n    int y = index / int(iResolution.x);\n    return texelFetch( tex, ivec2(x,y), 0 );\n}\n\nvoid loadCamera( out Camera_t cam )\n{\n    cam.pos = texelFetch( iChannel1, 0 ).xyz;\n    cam.x   = texelFetch( iChannel1, 1 ).xyz;\n    cam.y   = texelFetch( iChannel1, 2 ).xyz;\n    cam.z   = texelFetch( iChannel1, 3 ).xyz;\n}\n\nvoid loadLight( in int lightIndex, out Light_t light )\n{\n    int index = lightIndex * LIGHTS_UNIT + LIGHTS_OFFSET;\n    light.position = texelFetch( iChannel0,   index ).xyz;\n    light.I_a      = texelFetch( iChannel0, index+1 ).xyz;\n    light.I_source = texelFetch( iChannel0, index+2 ).xyz;\n}\n\nvoid loadMaterial( in int materialIndex, out Material_t mat )\n{\n    int index = materialIndex * MATERIALS_UNIT + MATERIALS_OFFSET;\n    mat.k_a  = texelFetch( iChannel0,   index ).xyz;\n    mat.k_d  = texelFetch( iChannel0, index+1 ).xyz;\n    mat.k_r  = texelFetch( iChannel0, index+2 ).xyz;\n    mat.k_rg = texelFetch( iChannel0, index+3 ).xyz;\n    mat.n    = texelFetch( iChannel0, index+3 ).w;\n}\n\nvoid loadPlane( in int planeIndex, out Plane_t pln )\n{\n    int index = planeIndex * PLANES_UNIT + PLANES_OFFSET;\n    vec4 planeData = texelFetch( iChannel0, index );\n    pln.A = planeData.x;\n    pln.B = planeData.y;\n    pln.C = planeData.z;\n    pln.D = planeData.w;\n    pln.materialID = 3;\n}\n\nvoid loadSphere( in int sphereIndex, out Sphere_t sph )\n{\n    int index = sphereIndex * SPHERES_UNIT + SPHERES_OFFSET;\n    vec4 sphereData = texelFetch( iChannel0, index );\n    sph.center = sphereData.xyz;\n    vec2 radius_material = unpackHalf2x16(floatBitsToUint(sphereData.w));\n    sph.radius = radius_material.x;\n    sph.materialID = int(radius_material.y + 0.5);\n}\n\nvoid loadTriangle( in int vertexIndex, out Triangle_t tri )\n{\n    int index = vertexIndex + TRIANGLES_OFFSET;\n    tri.A = texelFetch( iChannel0,   index ).xyz;\n    tri.B = texelFetch( iChannel0, index+1 ).xyz;\n    tri.C = texelFetch( iChannel0, index+2 ).xyz;\n    tri.materialID = 10;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 movedRayOrigin = ray.o - sph.center;\n    float a = 1.0; // actually ray.d * ray.d\n    float b = 2.0 * dot( ray.d, movedRayOrigin );\n    float c = dot( movedRayOrigin, movedRayOrigin ) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c; // Discriminant.\n    if ( d < 0.0 ) return false; // No intersection.\n\n    float t0 = (-b - sqrt(d)) / (2.0 * a); // Try the smaller root.\n    if ( t0 < tmin || t0 > tmax ) {\n        t0 = (-b + sqrt(d)) / (2.0 * a); // Try the larger root.\n        if ( t0 < tmin || t0 > tmax ) {\n            return false;\n        }\n    }\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( movedRayOrigin + t0 * ray.d );\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 movedRayOrigin = ray.o - sph.center;\n    float a = 1.0;\n    float b = 2.0 * dot( ray.d, movedRayOrigin );\n    float c = dot( movedRayOrigin, movedRayOrigin ) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c; // Discriminant.\n    if ( d < 0.0 ) return false; // No intersection.\n\n    float t0 = (-b - sqrt(d)) / (2.0 * a); // Try the smaller root.\n    if ( t0 < tmin || t0 > tmax ) {\n        t0 = (-b + sqrt(d)) / (2.0 * a); // Try the larger root.\n        if ( t0 < tmin || t0 > tmax ) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax,\n                        out float t, out vec3 hitPos, out vec3 hitNormal, out Barycentric_t bary )\n{\n    vec3 A_sub_Ro = tri.A - ray.o;\n    vec3 A_sub_B = tri.A - tri.B;\n    vec3 A_sub_C = tri.A - tri.C;\n\n    mat3 beta_mat = mat3( A_sub_Ro, A_sub_C, ray.d );\n    mat3 gamma_mat = mat3( A_sub_B, A_sub_Ro, ray.d );\n    mat3 A_mat = mat3(A_sub_B, A_sub_C, ray.d);\n\n    float detA = determinant(A_mat);\n    if (abs(detA) < 1e-6) return false;\n\n    float beta = determinant( beta_mat ) / detA;\n    float gamma = determinant( gamma_mat ) / detA;\n\n    if ( beta < 0.0 || gamma < 0.0 || beta + gamma > 1.0 ) return false;\n\n    mat3 t_mat = mat3( A_sub_B, A_sub_C, A_sub_Ro );\n    float t0 = determinant( t_mat ) / detA;\n\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( cross( A_sub_B, A_sub_C ) );\n    bary.alpha = 1.0 - beta - gamma;\n    bary.beta = beta;\n    bary.gamma = gamma;\n    return true;\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 A_sub_Ro = tri.A - ray.o;\n    vec3 A_sub_B = tri.A - tri.B;\n    vec3 A_sub_C = tri.A - tri.C;\n\n    mat3 beta_mat = mat3( A_sub_Ro, A_sub_C, ray.d );\n    mat3 gamma_mat = mat3( A_sub_B, A_sub_Ro, ray.d );\n    mat3 A_mat = mat3(A_sub_B, A_sub_C, ray.d);\n\n    float detA = determinant(A_mat);\n    if (abs(detA) < 1e-6) return false;\n\n    float beta = determinant( beta_mat ) / detA;\n    float gamma = determinant( gamma_mat ) / detA;\n\n    if ( beta < 0.0 || gamma < 0.0 || beta + gamma > 1.0 ) return false;\n\n    mat3 t_mat = mat3( A_sub_B, A_sub_C, A_sub_Ro );\n    float t0 = determinant( t_mat ) / detA;\n\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\nbool IntersectAABB( in Ray_t ray, in int AABB_idx )\n{\n    vec3 invD = vec3(\n        ray.d.x == 0.0 ? 1e9 : 1.0 / ray.d.x,\n        ray.d.y == 0.0 ? 1e9 : 1.0 / ray.d.y,\n        ray.d.z == 0.0 ? 1e9 : 1.0 / ray.d.z\n    );\n    vec3 t_near = (AABB_MIN[AABB_idx] - ray.o) * invD;\n    vec3 t_far = (AABB_MAX[AABB_idx] - ray.o) * invD;\n\n    vec3 t_min = min(t_near, t_far);\n    vec3 t_max = max(t_near, t_far);\n\n    float t_min_max = max(max(t_min.x, t_min.y), t_min.z);\n    float t_max_min = min(min(t_max.x, t_max.y), t_max.z);\n\n    return t_min_max <= t_max_min && t_max_min >= 0.0;\n}\n\nbool IntersectNearestTriangle( in Ray_t ray, in float tmin, in float tmax,\n                               out float t, out vec3 hitPos, out vec3 hitNormal,\n                               out int hitMatID, out Barycentric_t bary )\n{\n    t = tmax;\n    bool hasHitSomething = false;\n    int vert_offset = 0;\n    int vert_cnt;\n    for ( int i = 0; i < NUM_VERTEX.length(); i++ ) {\n        vert_cnt = NUM_VERTEX[i];\n        if ( TURN_OFF_AABB_OPTIMIZATION || IntersectAABB( ray, i ) ) {\n            Triangle_t tri;\n            for ( int j = 0; j < vert_cnt; j += 3 ) {\n                loadTriangle( vert_offset + j, tri );\n                if ( IntersectTriangle( tri, ray, tmin, t,\n                                        t, hitPos, hitNormal, bary ) ) {\n                    hasHitSomething = true;\n                    hitMatID = tri.materialID;\n                }\n            }\n        }\n        vert_offset += vert_cnt;\n    }\n    return hasHitSomething;\n}\n\nbool IntersectAnyTriangle( in Ray_t ray, in float tmin, in float tmax )\n{\n    int vert_offset = 0;\n    int vert_cnt;\n    for ( int i = 0; i < NUM_VERTEX.length(); i++ ) {\n        vert_cnt = NUM_VERTEX[i];\n        if ( TURN_OFF_AABB_OPTIMIZATION || IntersectAABB( ray, i ) ) {\n            Triangle_t tri;\n            for ( int j = 0; j < vert_cnt; j += 3 ) {\n                loadTriangle( vert_offset + j, tri );\n                if ( IntersectTriangle( tri, ray, tmin, tmax ) ) {\n                    return true;\n                }\n            }\n        }\n        vert_offset += vert_cnt;\n    }\n    return false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    Barycentric_t bary;\n    hasHitSomething = IntersectNearestTriangle( ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                                nearest_t, nearest_hitPos, nearest_hitNormal,\n                                                nearest_hitMatID, bary );\n    for ( int i = 0; i < NUM_PLANES; i++ ) {\n        Plane_t pln;\n        loadPlane( i, pln );\n        if ( IntersectPlane( pln, ray, DEFAULT_TMIN, nearest_t,\n                             temp_t, temp_hitPos, temp_hitNormal ) ) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = pln.materialID;\n        }\n    }\n    for ( int i = 0; i < NUM_SPHERES; i++ ) {\n        Sphere_t sph;\n        loadSphere( i, sph );\n        if ( IntersectSphere( sph, ray, DEFAULT_TMIN, nearest_t,\n                              temp_t, temp_hitPos, temp_hitNormal ) ) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = sph.materialID;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return texture( iChannel2, ray.d ).rgb;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    Material_t Material;\n    loadMaterial( nearest_hitMatID, Material );\n    // Accumulate lighting from each light source.\n    for ( int i = 0; i < NUM_LIGHTS; i++ ) {\n        Light_t Light;\n        loadLight( i, Light );\n        vec3 L = normalize( Light.position - nearest_hitPos );\n        vec3 V = normalize( ray.o - nearest_hitPos );\n\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = L;\n\n        // Check if shadow ray intersects any object.\n        // Only consider t between object and light source.\n        bool inShadow = false;\n        float tmax = length( Light.position - nearest_hitPos );\n        inShadow = IntersectAnyTriangle( shadowRay, DEFAULT_TMIN, tmax );\n        for ( int j = 0; !inShadow && j < NUM_PLANES; j++ ) {\n            Plane_t Plane;\n            loadPlane( j, Plane );\n            inShadow = IntersectPlane( Plane, shadowRay, DEFAULT_TMIN, tmax );\n        }\n        for ( int j = 0; !inShadow && j < NUM_SPHERES; j++ ) {\n            Sphere_t Sphere;\n            loadSphere( j, Sphere );\n            inShadow = IntersectSphere( Sphere, shadowRay, DEFAULT_TMIN, tmax );\n        }\n\n        I_local += PhongLighting( L, nearest_hitNormal, V, inShadow,\n                                  Material, Light );\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material.k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    Camera_t cam;\n    loadCamera( cam );\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam.pos;\n    pRay.d = normalize( pixel_pos.x * cam.x  +  pixel_pos.y * cam.y  +  pixel_pos_z * cam.z );\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//============================================================================\n// PROJECT ID: 02\n//\n// GROUP NUMBER: 03\n//\n// STUDENT NAME: CHEN ZHIAN\n// NUS User ID.: t0933479\n//\n// STUDENT NAME: LI YIXIN\n// NUS User ID.: t0933820\n//\n// STUDENT NAME: OUYANG ANNAN\n// NUS User ID.: t0933394\n//\n// COMMENTS TO GRADER: This is the pass 1 shader which will output to the BufferA\n//                     in shadertoy. BufferA layout can be found in the common\n//                     fragment shader.\n//\n//                     We use multiple passes and this is only a part of tasks2.\n//                     There are 1 common file and 4 pass files in total.\n//                     The complete project is in the following link:\n//                     https://www.shadertoy.com/view/lflcWH\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\nconst float PI = 3.1415926536;\n\nconst float angle60 = 1.0471975512;\nconst float angle120 = 2.0943951024;\nconst float angle180 = 3.1415926536;\nconst float angle240 = 4.1887902048;\nconst float angle300 = 5.2359877560;\n\nconst mat4 rotationMatrix60 = mat4(\n    0.5, 0.0, -0.8660254038, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.8660254038, 0.0, 0.5, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\nconst mat4 rotationMatrix120 = mat4(\n    -0.5, 0.0, -0.8660254038, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.8660254038, 0.0, -0.5, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\nconst mat4 rotationMatrix180 = mat4(\n    -1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, -1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\nconst mat4 rotationMatrix240 = mat4(\n    -0.5, 0.0, 0.8660254038, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -0.8660254038, 0.0, -0.5, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\nconst mat4 rotationMatrix300 = mat4(\n    0.5, 0.0, 0.8660254038, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -0.8660254038, 0.0, 0.5, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\n\n\nvec4 light( in int idx )\n{\n    switch(idx) {\n        // Light 0.\n        case 0: return vec4( -12.0, 8.0, -16.0, 0.0 ); // position\n        case 1: return vec4( 0.15, 0.15, 0.15, 0.0 );  // I_a\n        case 2: return vec4( 1.0, 1.0, 1.0, 0.0 );  // I_source\n\n        // Light 1.\n        case 3: return vec4( 8.0, 5.0, 0.0, 0.0 ); // position\n        case 4: return vec4( 0.15, 0.15, 0.15, 0.0 );  // I_a\n        case 5: return vec4( 1.0, 1.0, 1.0, 0.0 );  // I_source\n\n        // Light 2.\n        case 6: return vec4( -3.0, 6.0, 4.0, 0.0 ); // position\n        case 7: return vec4( 0.08, 0.08, 0.08, 0.0 );  // I_a\n        case 8: return vec4( 1.0, 1.0, 1.0, 0.0 );  // I_source\n    }\n}\n\nvec4 material( in int idx )\n{\n    switch(idx) {\n        // Silver material.(0)\n        case  0: return 1.0 * vec4( 0.5, 0.5, 0.5, 0.0 ); // k_d\n        case  1: return 0.2 * vec4( 0.5, 0.5, 0.5, 0.0 ); // k_a\n        case  2: return 2.0 * vec4( 0.5, 0.5, 0.5, 0.0 ); // k_r\n        case  3: return vec4( 0.5, 0.5, 0.5, 64.0 );      // k_rg, n\n\n        // Gold material.(1)\n        case  4: return 1.0 * vec4( 0.8, 0.7, 0.1, 0.0 ); // k_d\n        case  5: return 0.6 * vec4( 0.8, 0.7, 0.1, 0.0 ); // k_a\n        case  6: return 2.0 * vec4( 0.8, 0.7, 0.1, 0.0 ); // k_r\n        case  7: return vec4( 0.8, 0.7, 0.1, 64.0 );      // k_rg, n\n\n        // Green plastic material.(2)\n        case  8: return 1.0 * vec4( 0.0, 0.8, 0.0, 0.0 ); // k_d\n        case  9: return 0.5 * vec4( 0.0, 0.8, 0.0, 0.0 ); // k_a\n        case 10: return vec4( 1.0, 1.0, 1.0, 0.0 );       // k_r\n        case 11: return vec4( 0.5, 0.5, 0.5, 128.0 );     // k_rg, n\n\n        // Mirror.(3)\n        case 12: return vec4( 0.0, 0.1, 0.2, 0.0 ); // k_d\n        case 13: return vec4( 0.0, 0.1, 0.2, 0.0 ); // k_a\n        case 14: return vec4( 0.0, 0.1, 0.2, 0.0 ); // k_r\n        case 15: return vec4( 0.3, 0.4, 0.5, 64.0 ); // k_rg, n\n\n        // Copper material.(4)\n        case 16: return vec4( 0.780392, 0.568627, 0.113725, 0.0 ); // k_d\n        case 17: return vec4( 0.329412, 0.223529, 0.027451, 0.0 ); // k_a\n        case 18: return vec4( 0.992157, 0.941176, 0.807843, 0.0 ); // k_r\n        case 19: return vec4( 0.396863, 0.376470, 0.323137, 27.0 ); // k_rg, n\n\n        // Pearl material.(5)\n        case 20: return vec4( 1.0, 0.829, 0.829, 0.0 ); // k_d\n        case 21: return vec4( 0.25, 0.20725, 0.20725, 0.0 ); // k_a\n        case 22: return vec4( 0.296648, 0.296648, 0.296648, 0.0 ); // k_r\n        case 23: return vec4( 0.118659, 0.118659, 0.118659, 128.0 ); // k_rg, n\n\n        // Bronze material.(6)\n        case 24: return vec4( 0.714, 0.4284, 0.18144, 0.0 ); // k_d\n        case 25: return vec4( 0.2125, 0.1275, 0.054, 0.0 ); // k_a\n        case 26: return vec4( 0.393548, 0.271906, 0.166721, 0.0 ); // k_r\n        case 27: return vec4( 0.157419, 0.108762, 0.066688, 128.0 ); // k_rg, n\n\n        // Violet material.(7)\n        case 28: return vec4( 0.43, 0.47, 0.54, 0.0 ); // k_d\n        case 29: return 2.0 * vec4( 0.11, 0.06, 0.09, 0.0 ); // k_a\n        case 30: return vec4( 0.33, 0.33, 0.52, 0.0 ); // k_r\n        case 31: return vec4( 0.132, 0.132, 0.208, 128.0 ); // k_rg, n\n\n        // Black material.(8)\n        case 32: return vec4( 0.0, 0.0, 0.0, 0.0 ); // k_d\n        case 33: return vec4( 0.11, 0.06, 0.09, 0.0 ); // k_a\n        case 34: return vec4( 0.33, 0.33, 0.52, 0.0 ); // k_r\n        case 35: return vec4( 0.132, 0.132, 0.208, 128.0 ); // k_rg, n\n\n        // Blue material.(9)\n        case 36: return 1.0 * vec4( 0.1, 0.4, 1.0, 0.0 ); // k_d\n        case 37: return 0.4 * vec4( 0.1, 0.4, 1.0, 0.0 ); // k_a\n        case 38: return 2.0 * vec4( 0.1, 0.4, 1.0, 0.0 ); // k_r\n        case 39: return vec4( 0.1, 0.4, 1.0, 64.0 );      // k_rg, n\n\n        // Purple material.(10)\n        case 40: return 1.0 * vec4( 0.6, 0.0, 0.8, 0.0 ); // k_d\n        case 41: return 0.2 * vec4( 0.6, 0.0, 0.8, 0.0 ); // k_a\n        case 42: return 2.0 * vec4( 0.5, 0.0, 0.7, 0.0 ); // k_r\n        case 43: return vec4( 0.5, 0.0, 0.7, 64.0 );      // k_rg, n\n\n        // Red material.(11)\n        case 44: return 1.0 * vec4( 1.0, 0.1, 0.1, 0.0 ); // k_d\n        case 45: return 0.6 * vec4( 1.0, 0.1, 0.1, 0.0 ); // k_a\n        case 46: return 2.0 * vec4( 1.0, 0.1, 0.1, 0.0 ); // k_r\n        case 47: return vec4( 1.0, 0.1, 0.1, 64.0 );      // k_rg, n\n\n        // Orange material.(12)\n        case 48: return 1.0 * vec4( 1.0, 0.5, 0.1, 0.0 ); // k_d\n        case 49: return 0.5 * vec4( 1.0, 0.5, 0.1, 0.0 ); // k_a\n        case 50: return 2.0 * vec4( 1.0, 0.5, 0.1, 0.0 ); // k_r\n        case 51: return vec4( 1.0, 0.5, 0.1, 64.0 );      // k_rg, n\n    }\n}\n\nvec4 plane( in int idx )\n{\n    switch(idx) {\n        // Horizontal plane.\n        case 0: return vec4( 0.0, 1.0, 0.0, 0.0 ); // A, B, C, D\n        // Vertical plane.\n        case 1: return vec4( 0.0, 0.0, 1.0, 14.0 );\n        case 2: return vec4( 1.0, 0.0, 0.0, 14.0 );\n        case 3: return vec4( 0.0, 0.0, -1.0, 14.0 );\n        case 4: return vec4( -1.0, 0.0, 0.0, 14.0 );\n        case 5: return vec4( 1.0, 0.0, 1.0, 14.0 );\n        case 6: return vec4( 1.0, 0.0, -1.0, 14.0 );\n        case 7: return vec4( -1.0, 0.0, 1.0, 14.0 );\n        case 8: return vec4( -1.0, 0.0, -1.0, 14.0 );\n    }\n}\n\nvec4 getSphere()\n{\n    float Time = mod(iTime, 20.0);\n    int num = 1;\n    vec4 result;\n    float newX;\n    float newY;\n    float newZ;\n    float endPos1X = 0.0;\n    float endPos1Y = 4.0;\n    float endPos1Z = 0.0;\n    float r0 = (endPos1Y - 2.32)/2.0;\n    float r1 = endPos1Y - 2.32;\n    float r2 = mix(r1,r1+2.0,(Time-10.0)/(2.0 * PI));\n\n    if (Time < 5.0) {\n        return vec4( 0.1, 2.32, 0.5, uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n    } else if(Time < 7.0){\n        result = vec4( 0.1, 2.32+r0-r0*cos((Time-5.0)*PI/2.0), 0.5 + r0*sin((Time-5.0)*PI/2.0), uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n    }else if (Time < 8.0) {\n        newX = mix(0.1, endPos1X, (Time - 7.0) / 1.0);\n        newY = endPos1Y;\n        newZ = mix(0.5, endPos1Z, (Time - 7.0) / 1.0);\n        return vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n    } else if (Time < 10.0) {\n        result = vec4( endPos1X + r1 * sin((Time - 8.0)/2.0 * PI/2.0), 4.0 - r1 + r1 * cos((Time - 8.0)/2.0 * PI/2.0), endPos1Z, uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n    }else if (Time < 10.0 + 2.0 * PI){\n        float speed = 1.0;\n        result = vec4( endPos1X + r2*cos((Time-10.0)*speed), 2.32, endPos1Z + r2*sin((Time-10.0)*speed), uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n    }else if (Time < 20.0){\n        result = vec4( endPos1X + r2, 2.32, endPos1Z, uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n        // newX = mix( endPos1X + r2,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n        // newY = 2.32;\n        // newZ = mix( endPos1Z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n        // result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n    }\n    return result;\n}\n\nvec4 sphere( in int idx )\n{\n    vec4 result = getSphere();\n    float Time = mod(iTime, 20.0);\n    float newX;\n    float newY;\n    float newZ;\n    switch(idx) {\n        case 0:\n            return vec4( 0.1, 2.32, 0.5, uintBitsToFloat(packHalf2x16(vec2(0.1, 0.1))) ); // center, radius, materialID\n        case 1:\n            // result = getSphere();\n            result.w = uintBitsToFloat(packHalf2x16(vec2(0.09, 11)));\n            if (Time < 8.0) return result;\n            if (Time > 10.0 + 2.0 * PI){\n                newX = mix( result.x,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                newY = 2.32;\n                newZ = mix( result.z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 11))) );\n                return result;\n            }\n            return result;\n        case 2:\n            result.w = uintBitsToFloat(packHalf2x16(vec2(0.09, 12)));\n            if (Time < 8.0) return result;\n            result = rotationMatrix60 * result;\n            if (Time > 10.0 + 2.0 * PI){\n                newX = mix( result.x,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                newY = 2.32;\n                newZ = mix( result.z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 12))) );\n                return result;\n            }\n            return result;\n        case 3:\n            result.w = uintBitsToFloat(packHalf2x16(vec2(0.09, 1)));\n            if (Time < 8.0) return result;\n            result = rotationMatrix120 * result;\n            if (Time > 10.0 + 2.0 * PI){\n                newX = mix( result.x,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                newY = 2.32;\n                newZ = mix( result.z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 1))) );\n                return result;\n            }\n            return result;\n        case 4:\n            result.w = uintBitsToFloat(packHalf2x16(vec2(0.09, 2)));\n            if (Time < 8.0) return result;\n            result = rotationMatrix180 * result;\n            if (Time > 10.0 + 2.0 * PI){\n                newX = mix( result.x,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                newY = 2.32;\n                newZ = mix( result.z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 2))) );\n                return result;\n            }\n            return result;\n        case 5:\n            result.w = uintBitsToFloat(packHalf2x16(vec2(0.09, 9)));\n            if (Time < 8.0) return result;\n            result = rotationMatrix240 * result;\n            if (Time > 10.0 + 2.0 * PI){\n                newX = mix( result.x,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                newY = 2.32;\n                newZ = mix( result.z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 9))) );\n                return result;\n            }\n            return result;\n        case 6:\n            result.w = uintBitsToFloat(packHalf2x16(vec2(0.09, 7)));\n            if (Time < 8.0) return result;\n            result = rotationMatrix300 * result;\n            if (Time > 10.0 + 2.0 * PI){\n                newX = mix( result.x,0.1, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                newY = 2.32;\n                newZ = mix( result.z,0.5, (Time - 10.0 - 2.0 * PI) / (10.0- 2.0 * PI));\n                result = vec4( newX, newY, newZ, uintBitsToFloat(packHalf2x16(vec2(0.09, 7))) );\n                return result;\n            }\n            return result;\n    }\n}\n\nvec4 triangle( in int idx )\n{\n    switch(idx) {\n        case 0: return vec4(-0.198743, 2.826322, 0.059470, 0.0);\n        case 1: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 2: return vec4(-0.186905, 2.532769, 0.265930, 0.0);\n        case 3: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 4: return vec4(-0.459840, 1.710626, 0.127664, 0.0);\n        case 5: return vec4(-0.367337, 1.627571, 0.370550, 0.0);\n        case 6: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 7: return vec4(-0.367337, 1.627571, 0.370550, 0.0);\n        case 8: return vec4(-0.090769, 2.249265, 0.577870, 0.0);\n        case 9: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 10: return vec4(-0.090769, 2.249265, 0.577870, 0.0);\n        case 11: return vec4(-0.027793, 2.284574, 0.480639, 0.0);\n        case 12: return vec4(-0.027793, 2.284574, 0.480639, 0.0);\n        case 13: return vec4(-0.186905, 2.532769, 0.265930, 0.0);\n        case 14: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 15: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 16: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 17: return vec4(-0.112174, 2.183552, 0.235866, 0.0);\n        case 18: return vec4(-0.027793, 2.284574, 0.480639, 0.0);\n        case 19: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 20: return vec4(-0.112174, 2.183552, 0.235866, 0.0);\n        case 21: return vec4(-0.027793, 2.284574, 0.480639, 0.0);\n        case 22: return vec4(-0.112174, 2.183552, 0.235866, 0.0);\n        case 23: return vec4(-0.135603, 2.326412, 0.330678, 0.0);\n        case 24: return vec4(-0.135603, 2.326412, 0.330678, 0.0);\n        case 25: return vec4(-0.186905, 2.532769, 0.265930, 0.0);\n        case 26: return vec4(-0.027793, 2.284574, 0.480639, 0.0);\n        case 27: return vec4(-0.186905, 2.532769, 0.265930, 0.0);\n        case 28: return vec4(-0.131967, 2.684812, 0.075591, 0.0);\n        case 29: return vec4(-0.198743, 2.826322, 0.059470, 0.0);\n        case 30: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 31: return vec4(-0.090769, 2.249265, 0.577870, 0.0);\n        case 32: return vec4(-0.367337, 1.627571, 0.370550, 0.0);\n        case 33: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 34: return vec4(-0.027793, 2.284574, 0.480639, 0.0);\n        case 35: return vec4(-0.090769, 2.249265, 0.577870, 0.0);\n        case 36: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 37: return vec4(-0.099666, 2.077898, 0.032954, 0.0);\n        case 38: return vec4(-0.112174, 2.183552, 0.235866, 0.0);\n        case 39: return vec4(0.311920, 2.532768, 0.265931, 0.0);\n        case 40: return vec4(0.507974, 2.468830, 0.144654, 0.0);\n        case 41: return vec4(0.328747, 2.819981, 0.075807, 0.0);\n        case 42: return vec4(0.492353, 1.627571, 0.370550, 0.0);\n        case 43: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 44: return vec4(0.507974, 2.468830, 0.144654, 0.0);\n        case 45: return vec4(0.492353, 1.627571, 0.370550, 0.0);\n        case 46: return vec4(0.507974, 2.468830, 0.144654, 0.0);\n        case 47: return vec4(0.215785, 2.249265, 0.577870, 0.0);\n        case 48: return vec4(0.215785, 2.249265, 0.577870, 0.0);\n        case 49: return vec4(0.507974, 2.468830, 0.144654, 0.0);\n        case 50: return vec4(0.152808, 2.284574, 0.480639, 0.0);\n        case 51: return vec4(0.311920, 2.532768, 0.265931, 0.0);\n        case 52: return vec4(0.152808, 2.284574, 0.480639, 0.0);\n        case 53: return vec4(0.507974, 2.468830, 0.144654, 0.0);\n        case 54: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 55: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 56: return vec4(0.237190, 2.183552, 0.235866, 0.0);\n        case 57: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 58: return vec4(0.152808, 2.284574, 0.480639, 0.0);\n        case 59: return vec4(0.237190, 2.183552, 0.235866, 0.0);\n        case 60: return vec4(0.260618, 2.326412, 0.330678, 0.0);\n        case 61: return vec4(0.237190, 2.183552, 0.235866, 0.0);\n        case 62: return vec4(0.152808, 2.284574, 0.480639, 0.0);\n        case 63: return vec4(0.311920, 2.532768, 0.265931, 0.0);\n        case 64: return vec4(0.260618, 2.326412, 0.330678, 0.0);\n        case 65: return vec4(0.152808, 2.284574, 0.480639, 0.0);\n        case 66: return vec4(0.271844, 2.689906, 0.069960, 0.0);\n        case 67: return vec4(0.311920, 2.532768, 0.265931, 0.0);\n        case 68: return vec4(0.328747, 2.819981, 0.075807, 0.0);\n        case 69: return vec4(0.215785, 2.249265, 0.577870, 0.0);\n        case 70: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 71: return vec4(0.492353, 1.627571, 0.370550, 0.0);\n        case 72: return vec4(0.152808, 2.284574, 0.480639, 0.0);\n        case 73: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 74: return vec4(0.215785, 2.249265, 0.577870, 0.0);\n        case 75: return vec4(0.100416, 2.027747, -0.030392, 0.0);\n        case 76: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 77: return vec4(0.237190, 2.183552, 0.235866, 0.0);\n        case 78: return vec4(0.326276, 2.952219, 0.040895, 0.0);\n        case 79: return vec4(0.251995, 2.721616, 0.337327, 0.0);\n        case 80: return vec4(0.578775, 2.400067, -0.022376, 0.0);\n        case 81: return vec4(0.251995, 2.721616, 0.337327, 0.0);\n        case 82: return vec4(0.326276, 2.952219, 0.040895, 0.0);\n        case 83: return vec4(0.294537, 2.973720, 0.343911, 0.0);\n        case 84: return vec4(0.578775, 2.400067, -0.022376, 0.0);\n        case 85: return vec4(0.251995, 2.721616, 0.337327, 0.0);\n        case 86: return vec4(0.270568, 3.038477, 0.062047, 0.0);\n        case 87: return vec4(0.251995, 2.721616, 0.337327, 0.0);\n        case 88: return vec4(0.294537, 2.973720, 0.343911, 0.0);\n        case 89: return vec4(0.270568, 3.038477, 0.062047, 0.0);\n        case 90: return vec4(0.133495, 2.853467, 0.085714, 0.0);\n        case 91: return vec4(0.000307, 2.781767, 0.203593, 0.0);\n        case 92: return vec4(0.066861, 2.731107, 0.258922, 0.0);\n        case 93: return vec4(0.000307, 2.781767, 0.203593, 0.0);\n        case 94: return vec4(0.207017, 3.081169, 0.161182, 0.0);\n        case 95: return vec4(0.051197, 2.873284, 0.340142, 0.0);\n        case 96: return vec4(0.000307, 2.781767, 0.203593, 0.0);\n        case 97: return vec4(0.051197, 2.873284, 0.340142, 0.0);\n        case 98: return vec4(-0.051497, 3.011251, 0.121885, 0.0);\n        case 99: return vec4(-0.016326, 2.161511, 0.619721, 0.0);\n        case 100: return vec4(-0.140341, 2.256935, 0.489296, 0.0);\n        case 101: return vec4(-0.108589, 2.228144, 0.455992, 0.0);\n        case 102: return vec4(-0.016326, 2.161511, 0.619721, 0.0);\n        case 103: return vec4(0.064858, 2.135775, 0.608844, 0.0);\n        case 104: return vec4(-0.140341, 2.256935, 0.489296, 0.0);\n        case 105: return vec4(0.064858, 2.135775, 0.608844, 0.0);\n        case 106: return vec4(0.077986, 2.234776, 0.533233, 0.0);\n        case 107: return vec4(-0.140341, 2.256935, 0.489296, 0.0);\n        case 108: return vec4(-0.140341, 2.256935, 0.489296, 0.0);\n        case 109: return vec4(0.077986, 2.234776, 0.533233, 0.0);\n        case 110: return vec4(-0.096493, 2.266745, 0.454581, 0.0);\n        case 111: return vec4(0.077986, 2.234776, 0.533233, 0.0);\n        case 112: return vec4(0.064858, 2.135775, 0.608844, 0.0);\n        case 113: return vec4(0.107414, 2.160195, 0.602529, 0.0);\n        case 114: return vec4(0.064858, 2.135775, 0.608844, 0.0);\n        case 115: return vec4(-0.016326, 2.161511, 0.619721, 0.0);\n        case 116: return vec4(0.107414, 2.160195, 0.602529, 0.0);\n        case 117: return vec4(-0.108589, 2.228144, 0.455992, 0.0);\n        case 118: return vec4(0.107414, 2.160195, 0.602529, 0.0);\n        case 119: return vec4(-0.016326, 2.161511, 0.619721, 0.0);\n        case 120: return vec4(0.107414, 2.160195, 0.602529, 0.0);\n        case 121: return vec4(-0.108589, 2.228144, 0.455992, 0.0);\n        case 122: return vec4(0.077986, 2.234776, 0.533233, 0.0);\n        case 123: return vec4(-0.096493, 2.266745, 0.454581, 0.0);\n        case 124: return vec4(0.077986, 2.234776, 0.533233, 0.0);\n        case 125: return vec4(-0.108589, 2.228144, 0.455992, 0.0);\n        case 126: return vec4(0.239720, 2.256746, 0.511709, 0.0);\n        case 127: return vec4(0.070815, 2.127584, 0.591753, 0.0);\n        case 128: return vec4(0.216797, 2.234768, 0.467689, 0.0);\n        case 129: return vec4(0.044685, 2.239236, 0.531086, 0.0);\n        case 130: return vec4(0.070815, 2.127584, 0.591753, 0.0);\n        case 131: return vec4(0.239720, 2.256746, 0.511709, 0.0);\n        case 132: return vec4(0.044685, 2.239236, 0.531086, 0.0);\n        case 133: return vec4(0.239720, 2.256746, 0.511709, 0.0);\n        case 134: return vec4(0.201567, 2.271960, 0.472507, 0.0);\n        case 135: return vec4(-0.043078, 2.093184, 0.544698, 0.0);\n        case 136: return vec4(0.070815, 2.127584, 0.591753, 0.0);\n        case 137: return vec4(0.044685, 2.239236, 0.531086, 0.0);\n        case 138: return vec4(0.025928, 2.197134, 0.509407, 0.0);\n        case 139: return vec4(-0.043078, 2.093184, 0.544698, 0.0);\n        case 140: return vec4(0.044685, 2.239236, 0.531086, 0.0);\n        case 141: return vec4(0.025928, 2.197134, 0.509407, 0.0);\n        case 142: return vec4(0.044685, 2.239236, 0.531086, 0.0);\n        case 143: return vec4(0.201567, 2.271960, 0.472507, 0.0);\n        case 144: return vec4(0.070815, 2.127584, 0.591753, 0.0);\n        case 145: return vec4(0.022112, 2.092685, 0.545129, 0.0);\n        case 146: return vec4(0.216797, 2.234768, 0.467689, 0.0);\n        case 147: return vec4(0.070815, 2.127584, 0.591753, 0.0);\n        case 148: return vec4(0.025928, 2.197134, 0.509407, 0.0);\n        case 149: return vec4(0.022112, 2.092685, 0.545129, 0.0);\n        case 150: return vec4(-0.043078, 2.093184, 0.544698, 0.0);\n        case 151: return vec4(0.025928, 2.197134, 0.509407, 0.0);\n        case 152: return vec4(0.070815, 2.127584, 0.591753, 0.0);\n        case 153: return vec4(0.022112, 2.092685, 0.545129, 0.0);\n        case 154: return vec4(0.025928, 2.197134, 0.509407, 0.0);\n        case 155: return vec4(0.216797, 2.234768, 0.467689, 0.0);\n        case 156: return vec4(0.201567, 2.271960, 0.472507, 0.0);\n        case 157: return vec4(0.216797, 2.234768, 0.467689, 0.0);\n        case 158: return vec4(0.025928, 2.197134, 0.509407, 0.0);\n        case 159: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 160: return vec4(0.169772, 3.122064, 0.422545, 0.0);\n        case 161: return vec4(0.118890, 2.659370, 0.397733, 0.0);\n        case 162: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 163: return vec4(0.118890, 2.659370, 0.397733, 0.0);\n        case 164: return vec4(0.131360, 2.779497, 0.277265, 0.0);\n        case 165: return vec4(0.118890, 2.659370, 0.397733, 0.0);\n        case 166: return vec4(0.190021, 3.123185, 0.329049, 0.0);\n        case 167: return vec4(0.131360, 2.779497, 0.277265, 0.0);\n        case 168: return vec4(0.190021, 3.123185, 0.329049, 0.0);\n        case 169: return vec4(0.118890, 2.659370, 0.397733, 0.0);\n        case 170: return vec4(0.169772, 3.122064, 0.422545, 0.0);\n        case 171: return vec4(0.190021, 3.123185, 0.329049, 0.0);\n        case 172: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 173: return vec4(0.131360, 2.779497, 0.277265, 0.0);\n        case 174: return vec4(0.264126, 2.557561, 0.338780, 0.0);\n        case 175: return vec4(0.344899, 2.771093, 0.076230, 0.0);\n        case 176: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 177: return vec4(0.344899, 2.771093, 0.076230, 0.0);\n        case 178: return vec4(0.073753, 2.845194, 0.118105, 0.0);\n        case 179: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 180: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 181: return vec4(0.073753, 2.845194, 0.118105, 0.0);\n        case 182: return vec4(-0.053706, 2.601016, 0.428838, 0.0);\n        case 183: return vec4(-0.053706, 2.601016, 0.428838, 0.0);\n        case 184: return vec4(-0.013808, 2.867647, 0.088736, 0.0);\n        case 185: return vec4(-0.216450, 2.783000, 0.065889, 0.0);\n        case 186: return vec4(-0.128414, 2.561538, 0.329633, 0.0);\n        case 187: return vec4(-0.053706, 2.601016, 0.428838, 0.0);\n        case 188: return vec4(-0.216450, 2.783000, 0.065889, 0.0);\n        case 189: return vec4(-0.128414, 2.561538, 0.329633, 0.0);\n        case 190: return vec4(-0.083856, 2.429277, 0.342375, 0.0);\n        case 191: return vec4(-0.053706, 2.601016, 0.428838, 0.0);\n        case 192: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 193: return vec4(0.217129, 2.271016, 0.402411, 0.0);\n        case 194: return vec4(0.264126, 2.557561, 0.338780, 0.0);\n        case 195: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 196: return vec4(0.277373, 2.010287, 0.434907, 0.0);\n        case 197: return vec4(0.217129, 2.271016, 0.402411, 0.0);\n        case 198: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 199: return vec4(-0.120593, 2.108763, 0.379246, 0.0);\n        case 200: return vec4(0.277373, 2.010287, 0.434907, 0.0);\n        case 201: return vec4(-0.120593, 2.108763, 0.379246, 0.0);\n        case 202: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 203: return vec4(-0.083856, 2.429277, 0.342375, 0.0);\n        case 204: return vec4(-0.053706, 2.601016, 0.428838, 0.0);\n        case 205: return vec4(0.073753, 2.845194, 0.118105, 0.0);\n        case 206: return vec4(-0.013808, 2.867647, 0.088736, 0.0);\n        case 207: return vec4(0.204880, 2.576619, 0.424575, 0.0);\n        case 208: return vec4(-0.053706, 2.601016, 0.428838, 0.0);\n        case 209: return vec4(-0.083856, 2.429277, 0.342375, 0.0);\n        case 210: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 211: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 212: return vec4(-0.198743, 2.826322, 0.059470, 0.0);\n        case 213: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 214: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 215: return vec4(-0.000884, 1.503325, -0.102178, 0.0);\n        case 216: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 217: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 218: return vec4(-0.000884, 1.503325, -0.102178, 0.0);\n        case 219: return vec4(-0.339350, 1.526524, -0.037972, 0.0);\n        case 220: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 221: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 222: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 223: return vec4(-0.339350, 1.526524, -0.037972, 0.0);\n        case 224: return vec4(-0.459840, 1.710626, 0.127664, 0.0);\n        case 225: return vec4(-0.382958, 2.468830, 0.144654, 0.0);\n        case 226: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 227: return vec4(-0.459840, 1.710626, 0.127664, 0.0);\n        case 228: return vec4(-0.294985, 2.426184, 0.015096, 0.0);\n        case 229: return vec4(-0.198743, 2.826322, 0.059470, 0.0);\n        case 230: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 231: return vec4(-0.198743, 2.826322, 0.059470, 0.0);\n        case 232: return vec4(-0.131967, 2.684812, 0.075591, 0.0);\n        case 233: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 234: return vec4(-0.099666, 2.077898, 0.032954, 0.0);\n        case 235: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 236: return vec4(-0.000884, 1.503325, -0.102178, 0.0);\n        case 237: return vec4(-0.000884, 1.503325, -0.102178, 0.0);\n        case 238: return vec4(0.100416, 2.027747, -0.030392, 0.0);\n        case 239: return vec4(-0.099666, 2.077898, 0.032954, 0.0);\n        case 240: return vec4(0.507974, 2.468830, 0.144654, 0.0);\n        case 241: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 242: return vec4(0.328747, 2.819981, 0.075807, 0.0);\n        case 243: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 244: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 245: return vec4(0.328747, 2.819981, 0.075807, 0.0);\n        case 246: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 247: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 248: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 249: return vec4(-0.000884, 1.503325, -0.102178, 0.0);\n        case 250: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 251: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 252: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 253: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 254: return vec4(0.464365, 1.526525, -0.037972, 0.0);\n        case 255: return vec4(0.271844, 2.689906, 0.069960, 0.0);\n        case 256: return vec4(0.328747, 2.819981, 0.075807, 0.0);\n        case 257: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 258: return vec4(0.079396, 2.736917, -0.043969, 0.0);\n        case 259: return vec4(-0.131967, 2.684812, 0.075591, 0.0);\n        case 260: return vec4(0.271844, 2.689906, 0.069960, 0.0);\n        case 261: return vec4(-0.000884, 1.503325, -0.102178, 0.0);\n        case 262: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 263: return vec4(0.100416, 2.027747, -0.030392, 0.0);\n        case 264: return vec4(-0.115155, 2.149971, -0.217257, 0.0);\n        case 265: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 266: return vec4(0.227281, 1.857075, -0.226910, 0.0);\n        case 267: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 268: return vec4(0.227281, 1.857075, -0.226910, 0.0);\n        case 269: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 270: return vec4(-0.115155, 2.149971, -0.217257, 0.0);\n        case 271: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 272: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 273: return vec4(-0.096804, 3.275048, 0.100496, 0.0);\n        case 274: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 275: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 276: return vec4(-0.125814, 2.917574, 0.195298, 0.0);\n        case 277: return vec4(-0.096804, 3.275048, 0.100496, 0.0);\n        case 278: return vec4(-0.340041, 2.707499, 0.178924, 0.0);\n        case 279: return vec4(-0.096804, 3.275048, 0.100496, 0.0);\n        case 280: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 281: return vec4(-0.340041, 2.707499, 0.178924, 0.0);\n        case 282: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 283: return vec4(0.326276, 2.952219, 0.040895, 0.0);\n        case 284: return vec4(0.578775, 2.400067, -0.022376, 0.0);\n        case 285: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 286: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 287: return vec4(0.578775, 2.400067, -0.022376, 0.0);\n        case 288: return vec4(0.227281, 1.857075, -0.226910, 0.0);\n        case 289: return vec4(-0.199971, 1.899570, -0.142343, 0.0);\n        case 290: return vec4(-0.115155, 2.149971, -0.217257, 0.0);\n        case 291: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 292: return vec4(-0.199971, 1.899570, -0.142343, 0.0);\n        case 293: return vec4(0.227281, 1.857075, -0.226910, 0.0);\n        case 294: return vec4(-0.199971, 1.899570, -0.142343, 0.0);\n        case 295: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 296: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 297: return vec4(0.270568, 3.038477, 0.062047, 0.0);\n        case 298: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 299: return vec4(0.578775, 2.400067, -0.022376, 0.0);\n        case 300: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 301: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 302: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 303: return vec4(0.266617, 2.024742, -0.240520, 0.0);\n        case 304: return vec4(0.270568, 3.038477, 0.062047, 0.0);\n        case 305: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 306: return vec4(-0.121024, 3.001428, 0.103137, 0.0);\n        case 307: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 308: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 309: return vec4(-0.340041, 2.707499, 0.178924, 0.0);\n        case 310: return vec4(-0.121024, 3.001428, 0.103137, 0.0);\n        case 311: return vec4(-0.125814, 2.917574, 0.195298, 0.0);\n        case 312: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 313: return vec4(-0.121024, 3.001428, 0.103137, 0.0);\n        case 314: return vec4(-0.340041, 2.707499, 0.178924, 0.0);\n        case 315: return vec4(-0.250912, 2.406855, -0.081150, 0.0);\n        case 316: return vec4(-0.115155, 2.149971, -0.217257, 0.0);\n        case 317: return vec4(-0.199971, 1.899570, -0.142343, 0.0);\n        case 318: return vec4(-0.051497, 3.011251, 0.121885, 0.0);\n        case 319: return vec4(-0.013366, 2.852985, 0.093602, 0.0);\n        case 320: return vec4(0.000307, 2.781767, 0.203593, 0.0);\n        case 321: return vec4(0.000307, 2.781767, 0.203593, 0.0);\n        case 322: return vec4(0.133495, 2.853467, 0.085714, 0.0);\n        case 323: return vec4(0.207017, 3.081169, 0.161182, 0.0);\n        case 324: return vec4(0.145541, 2.859779, -0.054899, 0.0);\n        case 325: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 326: return vec4(0.159129, 2.782875, -0.041184, 0.0);\n        case 327: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 328: return vec4(-0.065532, 2.863279, -0.047374, 0.0);\n        case 329: return vec4(0.064347, 2.494487, -0.089880, 0.0);\n        case 330: return vec4(0.064347, 2.494487, -0.089880, 0.0);\n        case 331: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 332: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 333: return vec4(0.159129, 2.782875, -0.041184, 0.0);\n        case 334: return vec4(0.170522, 3.094323, 0.208654, 0.0);\n        case 335: return vec4(0.146853, 2.433877, -0.124663, 0.0);\n        case 336: return vec4(0.159129, 2.782875, -0.041184, 0.0);\n        case 337: return vec4(0.146853, 2.433877, -0.124663, 0.0);\n        case 338: return vec4(0.064347, 2.494487, -0.089880, 0.0);\n        case 339: return vec4(0.064347, 2.494487, -0.089880, 0.0);\n        case 340: return vec4(0.146853, 2.433877, -0.124663, 0.0);\n        case 341: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 342: return vec4(0.170522, 3.094323, 0.208654, 0.0);\n        case 343: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 344: return vec4(0.146853, 2.433877, -0.124663, 0.0);\n        case 345: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 346: return vec4(0.079877, 2.008625, -0.106236, 0.0);\n        case 347: return vec4(0.146853, 2.433877, -0.124663, 0.0);\n        case 348: return vec4(0.146853, 2.433877, -0.124663, 0.0);\n        case 349: return vec4(0.079877, 2.008625, -0.106236, 0.0);\n        case 350: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 351: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 352: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 353: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 354: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 355: return vec4(0.079877, 2.008625, -0.106236, 0.0);\n        case 356: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 357: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 358: return vec4(0.079877, 2.008625, -0.106236, 0.0);\n        case 359: return vec4(0.052179, 1.479341, -0.184607, 0.0);\n        case 360: return vec4(0.079877, 2.008625, -0.106236, 0.0);\n        case 361: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 362: return vec4(0.052179, 1.479341, -0.184607, 0.0);\n        case 363: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 364: return vec4(0.170522, 3.094323, 0.208654, 0.0);\n        case 365: return vec4(0.159129, 2.782875, -0.041184, 0.0);\n        case 366: return vec4(-0.026015, 2.374027, -0.042204, 0.0);\n        case 367: return vec4(0.170522, 3.094323, 0.208654, 0.0);\n        case 368: return vec4(-0.065532, 2.863279, -0.047374, 0.0);\n        case 369: return vec4(0.344899, 2.771093, 0.076230, 0.0);\n        case 370: return vec4(0.151576, 2.816889, 0.068936, 0.0);\n        case 371: return vec4(0.073753, 2.845194, 0.118105, 0.0);\n        case 372: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 373: return vec4(-0.096804, 3.275048, 0.100496, 0.0);\n        case 374: return vec4(0.098125, 3.448996, 0.160518, 0.0);\n        case 375: return vec4(0.098125, 3.448996, 0.160518, 0.0);\n        case 376: return vec4(0.326276, 2.952219, 0.040895, 0.0);\n        case 377: return vec4(0.083199, 3.262238, -0.020138, 0.0);\n        case 378: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 379: return vec4(0.180265, 3.315095, 0.383238, 0.0);\n        case 380: return vec4(0.098125, 3.448996, 0.160518, 0.0);\n        case 381: return vec4(0.180265, 3.315095, 0.383238, 0.0);\n        case 382: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 383: return vec4(-0.068199, 3.147179, 0.558173, 0.0);\n        case 384: return vec4(-0.096804, 3.275048, 0.100496, 0.0);\n        case 385: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 386: return vec4(0.098125, 3.448996, 0.160518, 0.0);\n        case 387: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 388: return vec4(-0.096804, 3.275048, 0.100496, 0.0);\n        case 389: return vec4(-0.125814, 2.917574, 0.195298, 0.0);\n        case 390: return vec4(0.326276, 2.952219, 0.040895, 0.0);\n        case 391: return vec4(0.098125, 3.448996, 0.160518, 0.0);\n        case 392: return vec4(0.180265, 3.315095, 0.383238, 0.0);\n        case 393: return vec4(0.294537, 2.973720, 0.343911, 0.0);\n        case 394: return vec4(0.326276, 2.952219, 0.040895, 0.0);\n        case 395: return vec4(0.180265, 3.315095, 0.383238, 0.0);\n        case 396: return vec4(0.294537, 2.973720, 0.343911, 0.0);\n        case 397: return vec4(0.180265, 3.315095, 0.383238, 0.0);\n        case 398: return vec4(-0.068199, 3.147179, 0.558173, 0.0);\n        case 399: return vec4(-0.068199, 3.147179, 0.558173, 0.0);\n        case 400: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 401: return vec4(0.294537, 2.973720, 0.343911, 0.0);\n        case 402: return vec4(-0.068199, 3.147179, 0.558173, 0.0);\n        case 403: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 404: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 405: return vec4(-0.121024, 3.001428, 0.103137, 0.0);\n        case 406: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 407: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 408: return vec4(-0.232698, 3.170322, 0.477468, 0.0);\n        case 409: return vec4(-0.125814, 2.917574, 0.195298, 0.0);\n        case 410: return vec4(-0.121024, 3.001428, 0.103137, 0.0);\n        case 411: return vec4(0.270568, 3.038477, 0.062047, 0.0);\n        case 412: return vec4(0.294537, 2.973720, 0.343911, 0.0);\n        case 413: return vec4(0.113654, 3.388509, 0.143172, 0.0);\n        case 414: return vec4(0.034978, 3.191365, 0.445665, 0.0);\n        case 415: return vec4(-0.051497, 3.011251, 0.121885, 0.0);\n        case 416: return vec4(0.051197, 2.873284, 0.340142, 0.0);\n        case 417: return vec4(-0.051497, 3.011251, 0.121885, 0.0);\n        case 418: return vec4(0.034978, 3.191365, 0.445665, 0.0);\n        case 419: return vec4(-0.042253, 3.346303, 0.294809, 0.0);\n        case 420: return vec4(0.207017, 3.081169, 0.161182, 0.0);\n        case 421: return vec4(0.188544, 3.252530, 0.419767, 0.0);\n        case 422: return vec4(0.051197, 2.873284, 0.340142, 0.0);\n        case 423: return vec4(0.207017, 3.081169, 0.161182, 0.0);\n        case 424: return vec4(0.185406, 3.368005, 0.229430, 0.0);\n        case 425: return vec4(0.188544, 3.252530, 0.419767, 0.0);\n        case 426: return vec4(0.188544, 3.252530, 0.419767, 0.0);\n        case 427: return vec4(0.034978, 3.191365, 0.445665, 0.0);\n        case 428: return vec4(0.051197, 2.873284, 0.340142, 0.0);\n        case 429: return vec4(0.031126, 3.079918, 0.445999, 0.0);\n        case 430: return vec4(0.069153, 3.423640, 0.257066, 0.0);\n        case 431: return vec4(-0.044648, 3.159281, 0.400501, 0.0);\n        case 432: return vec4(0.069153, 3.423640, 0.257066, 0.0);\n        case 433: return vec4(0.031126, 3.079918, 0.445999, 0.0);\n        case 434: return vec4(0.169772, 3.122064, 0.422545, 0.0);\n        case 435: return vec4(0.169772, 3.122064, 0.422545, 0.0);\n        case 436: return vec4(0.031126, 3.079918, 0.445999, 0.0);\n        case 437: return vec4(0.094951, 3.072239, 0.430940, 0.0);\n        case 438: return vec4(0.069153, 3.423640, 0.257066, 0.0);\n        case 439: return vec4(0.169772, 3.122064, 0.422545, 0.0);\n        case 440: return vec4(0.238104, 3.250411, 0.305309, 0.0);\n        case 441: return vec4(0.224548, 3.221203, 0.209666, 0.0);\n        case 442: return vec4(0.238104, 3.250411, 0.305309, 0.0);\n        case 443: return vec4(0.309047, 3.015750, 0.091476, 0.0);\n        case 444: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 445: return vec4(0.309047, 3.015750, 0.091476, 0.0);\n        case 446: return vec4(0.238104, 3.250411, 0.305309, 0.0);\n        case 447: return vec4(0.069153, 3.423640, 0.257066, 0.0);\n        case 448: return vec4(-0.134734, 3.237893, 0.207058, 0.0);\n        case 449: return vec4(-0.044648, 3.159281, 0.400501, 0.0);\n        case 450: return vec4(-0.091589, 3.165616, 0.314905, 0.0);\n        case 451: return vec4(-0.044648, 3.159281, 0.400501, 0.0);\n        case 452: return vec4(-0.134734, 3.237893, 0.207058, 0.0);\n        case 453: return vec4(-0.134734, 3.237893, 0.207058, 0.0);\n        case 454: return vec4(-0.117696, 3.090438, 0.185262, 0.0);\n        case 455: return vec4(-0.091589, 3.165616, 0.314905, 0.0);\n        case 456: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 457: return vec4(0.145541, 2.859779, -0.054899, 0.0);\n        case 458: return vec4(0.309047, 3.015750, 0.091476, 0.0);\n        case 459: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 460: return vec4(0.238104, 3.250411, 0.305309, 0.0);\n        case 461: return vec4(0.169772, 3.122064, 0.422545, 0.0);\n        case 462: return vec4(-0.084965, 3.048194, 0.326772, 0.0);\n        case 463: return vec4(-0.044648, 3.159281, 0.400501, 0.0);\n        case 464: return vec4(-0.102494, 3.094185, 0.346055, 0.0);\n        case 465: return vec4(-0.044648, 3.159281, 0.400501, 0.0);\n        case 466: return vec4(-0.091589, 3.165616, 0.314905, 0.0);\n        case 467: return vec4(-0.102494, 3.094185, 0.346055, 0.0);\n        case 468: return vec4(-0.064427, 2.908914, 0.178961, 0.0);\n        case 469: return vec4(-0.102494, 3.094185, 0.346055, 0.0);\n        case 470: return vec4(-0.091589, 3.165616, 0.314905, 0.0);\n        case 471: return vec4(-0.097553, 3.081554, 0.317434, 0.0);\n        case 472: return vec4(-0.064427, 2.908914, 0.178961, 0.0);\n        case 473: return vec4(-0.091589, 3.165616, 0.314905, 0.0);\n        case 474: return vec4(-0.102494, 3.094185, 0.346055, 0.0);\n        case 475: return vec4(-0.064427, 2.908914, 0.178961, 0.0);\n        case 476: return vec4(-0.097553, 3.081554, 0.317434, 0.0);\n        case 477: return vec4(-0.065532, 2.863279, -0.047374, 0.0);\n        case 478: return vec4(-0.117696, 3.090438, 0.185262, 0.0);\n        case 479: return vec4(-0.134734, 3.237893, 0.207058, 0.0);\n        case 480: return vec4(-0.117696, 3.090438, 0.185262, 0.0);\n        case 481: return vec4(-0.065532, 2.863279, -0.047374, 0.0);\n        case 482: return vec4(0.170522, 3.094323, 0.208654, 0.0);\n        case 483: return vec4(0.190021, 3.123185, 0.329049, 0.0);\n        case 484: return vec4(0.170522, 3.094323, 0.208654, 0.0);\n        case 485: return vec4(0.257045, 2.948637, 0.211633, 0.0);\n        case 486: return vec4(-0.348637, 1.163173, 0.188485, 0.0);\n        case 487: return vec4(-0.339350, 1.526524, -0.037972, 0.0);\n        case 488: return vec4(-0.294241, 1.085086, 0.220785, 0.0);\n        case 489: return vec4(-0.339350, 1.526524, -0.037972, 0.0);\n        case 490: return vec4(-0.348637, 1.163173, 0.188485, 0.0);\n        case 491: return vec4(-0.459840, 1.710626, 0.127664, 0.0);\n        case 492: return vec4(-0.459840, 1.710626, 0.127664, 0.0);\n        case 493: return vec4(-0.348637, 1.163173, 0.188485, 0.0);\n        case 494: return vec4(-0.367337, 1.627571, 0.370550, 0.0);\n        case 495: return vec4(-0.294241, 1.085086, 0.220785, 0.0);\n        case 496: return vec4(-0.339350, 1.526524, -0.037972, 0.0);\n        case 497: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 498: return vec4(-0.294241, 1.085086, 0.220785, 0.0);\n        case 499: return vec4(-0.232687, 1.719725, 0.070112, 0.0);\n        case 500: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 501: return vec4(-0.294241, 1.085086, 0.220785, 0.0);\n        case 502: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 503: return vec4(-0.348637, 1.163173, 0.188485, 0.0);\n        case 504: return vec4(-0.115506, 2.169380, 0.505615, 0.0);\n        case 505: return vec4(-0.367337, 1.627571, 0.370550, 0.0);\n        case 506: return vec4(-0.348637, 1.163173, 0.188485, 0.0);\n        case 507: return vec4(0.464365, 1.526525, -0.037972, 0.0);\n        case 508: return vec4(0.473653, 1.163173, 0.188485, 0.0);\n        case 509: return vec4(0.419257, 1.085086, 0.220785, 0.0);\n        case 510: return vec4(0.473653, 1.163173, 0.188485, 0.0);\n        case 511: return vec4(0.464365, 1.526525, -0.037972, 0.0);\n        case 512: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 513: return vec4(0.492353, 1.627571, 0.370550, 0.0);\n        case 514: return vec4(0.473653, 1.163173, 0.188485, 0.0);\n        case 515: return vec4(0.585506, 1.871744, 0.050467, 0.0);\n        case 516: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 517: return vec4(0.464365, 1.526525, -0.037972, 0.0);\n        case 518: return vec4(0.419257, 1.085086, 0.220785, 0.0);\n        case 519: return vec4(0.360413, 1.715362, 0.067056, 0.0);\n        case 520: return vec4(0.419257, 1.085086, 0.220785, 0.0);\n        case 521: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 522: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 523: return vec4(0.419257, 1.085086, 0.220785, 0.0);\n        case 524: return vec4(0.473653, 1.163173, 0.188485, 0.0);\n        case 525: return vec4(0.473653, 1.163173, 0.188485, 0.0);\n        case 526: return vec4(0.492353, 1.627571, 0.370550, 0.0);\n        case 527: return vec4(0.240521, 2.169379, 0.505615, 0.0);\n        case 528: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 529: return vec4(0.016260, 1.423471, -0.214446, 0.0);\n        case 530: return vec4(-0.026366, 1.051416, -0.219392, 0.0);\n        case 531: return vec4(0.052179, 1.479341, -0.184607, 0.0);\n        case 532: return vec4(-0.026366, 1.051416, -0.219392, 0.0);\n        case 533: return vec4(0.016260, 1.423471, -0.214446, 0.0);\n        case 534: return vec4(-0.026366, 1.051416, -0.219392, 0.0);\n        case 535: return vec4(0.052179, 1.479341, -0.184607, 0.0);\n        case 536: return vec4(0.028677, 0.959269, -0.163075, 0.0);\n        case 537: return vec4(0.052179, 1.479341, -0.184607, 0.0);\n        case 538: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 539: return vec4(0.028677, 0.959269, -0.163075, 0.0);\n        case 540: return vec4(-0.026366, 1.051416, -0.219392, 0.0);\n        case 541: return vec4(0.028677, 0.959269, -0.163075, 0.0);\n        case 542: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 543: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 544: return vec4(0.016260, 1.423471, -0.214446, 0.0);\n        case 545: return vec4(0.001948, 1.478990, -0.180586, 0.0);\n        case 546: return vec4(0.052179, 1.479341, -0.184607, 0.0);\n        case 547: return vec4(0.016260, 1.423471, -0.214446, 0.0);\n        case 548: return vec4(0.017755, 2.103514, -0.164004, 0.0);\n        case 549: return vec4(0.373384, 1.987493, 0.288453, 0.0);\n        case 550: return vec4(0.277373, 2.010287, 0.434907, 0.0);\n        case 551: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 552: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 553: return vec4(0.213478, 1.043798, 0.253628, 0.0);\n        case 554: return vec4(0.373384, 1.987493, 0.288453, 0.0);\n        case 555: return vec4(0.213478, 1.043798, 0.253628, 0.0);\n        case 556: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 557: return vec4(0.373384, 1.987493, 0.288453, 0.0);\n        case 558: return vec4(0.277373, 2.010287, 0.434907, 0.0);\n        case 559: return vec4(-0.120593, 2.108763, 0.379246, 0.0);\n        case 560: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 561: return vec4(-0.198167, 1.731613, 0.171009, 0.0);\n        case 562: return vec4(-0.113238, 0.982554, 0.110453, 0.0);\n        case 563: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 564: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 565: return vec4(-0.198167, 1.731613, 0.171009, 0.0);\n        case 566: return vec4(-0.079960, 1.701094, 0.016835, 0.0);\n        case 567: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 568: return vec4(-0.113238, 0.982554, 0.110453, 0.0);\n        case 569: return vec4(-0.198167, 1.731613, 0.171009, 0.0);\n        case 570: return vec4(-0.198167, 1.731613, 0.171009, 0.0);\n        case 571: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 572: return vec4(-0.120593, 2.108763, 0.379246, 0.0);\n        case 573: return vec4(0.155248, 1.984359, 0.043959, 0.0);\n        case 574: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 575: return vec4(-0.079960, 1.701094, 0.016835, 0.0);\n        case 576: return vec4(0.155248, 1.984359, 0.043959, 0.0);\n        case 577: return vec4(0.373384, 1.987493, 0.288453, 0.0);\n        case 578: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 579: return vec4(-0.651850, 3.053614, -0.218081, 0.0);\n        case 580: return vec4(-0.635507, 2.747586, -0.242411, 0.0);\n        case 581: return vec4(-0.426697, 2.505814, -0.240123, 0.0);\n        case 582: return vec4(-0.651850, 3.053614, -0.218081, 0.0);\n        case 583: return vec4(-0.653869, 3.235286, -0.234040, 0.0);\n        case 584: return vec4(-0.635507, 2.747586, -0.242411, 0.0);\n        case 585: return vec4(-0.651850, 3.053614, -0.218081, 0.0);\n        case 586: return vec4(-0.165179, 3.748286, -0.238332, 0.0);\n        case 587: return vec4(-0.653869, 3.235286, -0.234040, 0.0);\n        case 588: return vec4(-0.165179, 3.748286, -0.238332, 0.0);\n        case 589: return vec4(-0.651850, 3.053614, -0.218081, 0.0);\n        case 590: return vec4(-0.127114, 3.642886, -0.218079, 0.0);\n        case 591: return vec4(-0.651850, 3.053614, -0.218081, 0.0);\n        case 592: return vec4(-0.426697, 2.505814, -0.240123, 0.0);\n        case 593: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 594: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 595: return vec4(-0.127114, 3.642886, -0.218079, 0.0);\n        case 596: return vec4(-0.651850, 3.053614, -0.218081, 0.0);\n        case 597: return vec4(-0.127114, 3.642886, -0.218079, 0.0);\n        case 598: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 599: return vec4(-0.108327, 3.630056, -0.262072, 0.0);\n        case 600: return vec4(-0.635507, 2.747586, -0.242411, 0.0);\n        case 601: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 602: return vec4(-0.426697, 2.505814, -0.240123, 0.0);\n        case 603: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 604: return vec4(-0.635507, 2.747586, -0.242411, 0.0);\n        case 605: return vec4(-0.653869, 3.235286, -0.234040, 0.0);\n        case 606: return vec4(-0.165179, 3.748286, -0.238332, 0.0);\n        case 607: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 608: return vec4(-0.653869, 3.235286, -0.234040, 0.0);\n        case 609: return vec4(-0.546987, 3.325791, -0.259794, 0.0);\n        case 610: return vec4(-0.165179, 3.748286, -0.238332, 0.0);\n        case 611: return vec4(-0.108327, 3.630056, -0.262072, 0.0);\n        case 612: return vec4(-0.557885, 3.362643, -0.185991, 0.0);\n        case 613: return vec4(-0.406169, 3.377578, -0.262914, 0.0);\n        case 614: return vec4(-0.709601, 3.347708, -0.262914, 0.0);\n        case 615: return vec4(-0.557885, 3.362643, -0.185991, 0.0);\n        case 616: return vec4(-0.709601, 3.347708, -0.262914, 0.0);\n        case 617: return vec4(-0.406169, 3.377578, -0.262914, 0.0);\n        case 618: return vec4(-0.556639, 2.679675, -0.185521, 0.0);\n        case 619: return vec4(-0.404921, 2.694610, -0.262443, 0.0);\n        case 620: return vec4(-0.708353, 2.664739, -0.262443, 0.0);\n        case 621: return vec4(-0.556639, 2.679675, -0.185521, 0.0);\n        case 622: return vec4(-0.708353, 2.664739, -0.262443, 0.0);\n        case 623: return vec4(-0.404921, 2.694610, -0.262443, 0.0);\n        case 624: return vec4(-0.041760, 3.575318, -0.244422, 0.0);\n        case 625: return vec4(0.284416, 3.733560, -0.265018, 0.0);\n        case 626: return vec4(-0.128016, 3.801782, -0.218369, 0.0);\n        case 627: return vec4(0.284416, 3.733560, -0.265018, 0.0);\n        case 628: return vec4(-0.041760, 3.575318, -0.244422, 0.0);\n        case 629: return vec4(-0.128016, 3.801782, -0.218369, 0.0);\n        case 630: return vec4(0.760523, 2.747586, -0.242411, 0.0);\n        case 631: return vec4(0.776866, 3.053615, -0.218081, 0.0);\n        case 632: return vec4(0.551713, 2.505815, -0.240122, 0.0);\n        case 633: return vec4(0.778885, 3.235286, -0.234040, 0.0);\n        case 634: return vec4(0.776866, 3.053615, -0.218081, 0.0);\n        case 635: return vec4(0.760523, 2.747586, -0.242411, 0.0);\n        case 636: return vec4(0.290195, 3.748286, -0.238332, 0.0);\n        case 637: return vec4(0.776866, 3.053615, -0.218081, 0.0);\n        case 638: return vec4(0.778885, 3.235286, -0.234040, 0.0);\n        case 639: return vec4(0.776866, 3.053615, -0.218081, 0.0);\n        case 640: return vec4(0.290195, 3.748286, -0.238332, 0.0);\n        case 641: return vec4(0.252130, 3.642886, -0.218079, 0.0);\n        case 642: return vec4(0.551713, 2.505815, -0.240122, 0.0);\n        case 643: return vec4(0.776866, 3.053615, -0.218081, 0.0);\n        case 644: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 645: return vec4(0.252130, 3.642886, -0.218079, 0.0);\n        case 646: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 647: return vec4(0.776866, 3.053615, -0.218081, 0.0);\n        case 648: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 649: return vec4(0.252130, 3.642886, -0.218079, 0.0);\n        case 650: return vec4(0.233343, 3.630056, -0.262072, 0.0);\n        case 651: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 652: return vec4(0.760523, 2.747586, -0.242411, 0.0);\n        case 653: return vec4(0.551713, 2.505815, -0.240122, 0.0);\n        case 654: return vec4(0.760523, 2.747586, -0.242411, 0.0);\n        case 655: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 656: return vec4(0.778885, 3.235286, -0.234040, 0.0);\n        case 657: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 658: return vec4(0.290195, 3.748286, -0.238332, 0.0);\n        case 659: return vec4(0.778885, 3.235286, -0.234040, 0.0);\n        case 660: return vec4(0.290195, 3.748286, -0.238332, 0.0);\n        case 661: return vec4(0.672003, 3.325791, -0.259794, 0.0);\n        case 662: return vec4(0.233343, 3.630056, -0.262072, 0.0);\n        case 663: return vec4(0.682900, 3.362643, -0.185991, 0.0);\n        case 664: return vec4(0.834617, 3.377578, -0.262913, 0.0);\n        case 665: return vec4(0.531185, 3.347708, -0.262913, 0.0);\n        case 666: return vec4(0.682900, 3.362643, -0.185991, 0.0);\n        case 667: return vec4(0.531185, 3.347708, -0.262913, 0.0);\n        case 668: return vec4(0.834617, 3.377578, -0.262913, 0.0);\n        case 669: return vec4(0.681651, 2.679675, -0.185520, 0.0);\n        case 670: return vec4(0.833369, 2.694610, -0.262442, 0.0);\n        case 671: return vec4(0.529937, 2.664739, -0.262442, 0.0);\n        case 672: return vec4(0.681651, 2.679675, -0.185520, 0.0);\n        case 673: return vec4(0.529937, 2.664739, -0.262442, 0.0);\n        case 674: return vec4(0.833369, 2.694610, -0.262442, 0.0);\n        case 675: return vec4(0.015005, 1.031375, 0.275563, 0.0);\n        case 676: return vec4(-0.026443, 0.125679, 0.131967, 0.0);\n        case 677: return vec4(-0.085341, 0.052588, 0.292936, 0.0);\n        case 678: return vec4(-0.026443, 0.125679, 0.131967, 0.0);\n        case 679: return vec4(0.015005, 1.031375, 0.275563, 0.0);\n        case 680: return vec4(0.103999, 1.024596, 0.163502, 0.0);\n        case 681: return vec4(-0.010711, 0.165993, 0.290598, 0.0);\n        case 682: return vec4(-0.085341, 0.052588, 0.292936, 0.0);\n        case 683: return vec4(-0.027314, -0.006262, 0.447663, 0.0);\n        case 684: return vec4(-0.027314, -0.006262, 0.447663, 0.0);\n        case 685: return vec4(-0.026443, 0.125679, 0.131967, 0.0);\n        case 686: return vec4(-0.010711, 0.165993, 0.290598, 0.0);\n        case 687: return vec4(-0.010711, 0.165993, 0.290598, 0.0);\n        case 688: return vec4(-0.026443, 0.125679, 0.131967, 0.0);\n        case 689: return vec4(0.160436, 1.019989, 0.265305, 0.0);\n        case 690: return vec4(-0.026443, 0.125679, 0.131967, 0.0);\n        case 691: return vec4(0.103999, 1.024596, 0.163502, 0.0);\n        case 692: return vec4(0.160436, 1.019989, 0.265305, 0.0);\n        case 693: return vec4(0.160436, 1.019989, 0.265305, 0.0);\n        case 694: return vec4(0.015005, 1.031375, 0.275563, 0.0);\n        case 695: return vec4(-0.010711, 0.165993, 0.290598, 0.0);\n        case 696: return vec4(0.015005, 1.031375, 0.275563, 0.0);\n        case 697: return vec4(-0.085341, 0.052588, 0.292936, 0.0);\n        case 698: return vec4(-0.010711, 0.165993, 0.290598, 0.0);\n        case 699: return vec4(-0.027314, -0.006262, 0.447663, 0.0);\n        case 700: return vec4(-0.085341, 0.052588, 0.292936, 0.0);\n        case 701: return vec4(-0.026443, 0.125679, 0.131967, 0.0);\n        case 702: return vec4(0.125003, 0.121321, -0.051899, 0.0);\n        case 703: return vec4(0.078837, 1.024426, 0.105890, 0.0);\n        case 704: return vec4(0.184232, 0.046016, 0.107924, 0.0);\n        case 705: return vec4(0.078837, 1.024426, 0.105890, 0.0);\n        case 706: return vec4(0.125003, 0.121321, -0.051899, 0.0);\n        case 707: return vec4(-0.010089, 1.018949, -0.006296, 0.0);\n        case 708: return vec4(0.184232, 0.046016, 0.107924, 0.0);\n        case 709: return vec4(0.109018, 0.159058, 0.107339, 0.0);\n        case 710: return vec4(0.126466, -0.015555, 0.261685, 0.0);\n        case 711: return vec4(0.126466, -0.015555, 0.261685, 0.0);\n        case 712: return vec4(0.109018, 0.159058, 0.107339, 0.0);\n        case 713: return vec4(0.125003, 0.121321, -0.051899, 0.0);\n        case 714: return vec4(0.109018, 0.159058, 0.107339, 0.0);\n        case 715: return vec4(-0.066530, 1.012450, 0.095402, 0.0);\n        case 716: return vec4(0.125003, 0.121321, -0.051899, 0.0);\n        case 717: return vec4(-0.010089, 1.018949, -0.006296, 0.0);\n        case 718: return vec4(0.125003, 0.121321, -0.051899, 0.0);\n        case 719: return vec4(-0.066530, 1.012450, 0.095402, 0.0);\n        case 720: return vec4(-0.066530, 1.012450, 0.095402, 0.0);\n        case 721: return vec4(0.109018, 0.159058, 0.107339, 0.0);\n        case 722: return vec4(0.078837, 1.024426, 0.105890, 0.0);\n        case 723: return vec4(0.184232, 0.046016, 0.107924, 0.0);\n        case 724: return vec4(0.078837, 1.024426, 0.105890, 0.0);\n        case 725: return vec4(0.109018, 0.159058, 0.107339, 0.0);\n        case 726: return vec4(0.184232, 0.046016, 0.107924, 0.0);\n        case 727: return vec4(0.126466, -0.015555, 0.261685, 0.0);\n        case 728: return vec4(0.125003, 0.121321, -0.051899, 0.0);\n        case 729: return vec4(0.135665, 1.060305, 0.201608, 0.0);\n        case 730: return vec4(0.256849, 0.425630, 0.173512, 0.0);\n        case 731: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 732: return vec4(0.249784, 0.265013, -0.264766, 0.0);\n        case 733: return vec4(0.256849, 0.425630, 0.173512, 0.0);\n        case 734: return vec4(0.135665, 1.060305, 0.201608, 0.0);\n        case 735: return vec4(0.249784, 0.265013, -0.264766, 0.0);\n        case 736: return vec4(0.135665, 1.060305, 0.201608, 0.0);\n        case 737: return vec4(-0.020036, 1.070062, 0.015155, 0.0);\n        case 738: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 739: return vec4(0.256849, 0.425630, 0.173512, 0.0);\n        case 740: return vec4(0.249784, 0.265013, -0.264766, 0.0);\n        case 741: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 742: return vec4(0.249784, 0.265013, -0.264766, 0.0);\n        case 743: return vec4(-0.020036, 1.070062, 0.015155, 0.0);\n        case 744: return vec4(0.257321, 0.145362, 0.355660, 0.0);\n        case 745: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 746: return vec4(0.708718, -0.005564, 0.347980, 0.0);\n        case 747: return vec4(0.257321, 0.145362, 0.355660, 0.0);\n        case 748: return vec4(0.256849, 0.425630, 0.173512, 0.0);\n        case 749: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 750: return vec4(0.708718, -0.005564, 0.347980, 0.0);\n        case 751: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 752: return vec4(0.581312, 0.034502, -0.569417, 0.0);\n        case 753: return vec4(0.256849, 0.425630, 0.173512, 0.0);\n        case 754: return vec4(0.257321, 0.145362, 0.355660, 0.0);\n        case 755: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 756: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 757: return vec4(0.249784, 0.265013, -0.264766, 0.0);\n        case 758: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 759: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 760: return vec4(-0.174860, 0.351519, 0.079523, 0.0);\n        case 761: return vec4(-0.020036, 1.070062, 0.015155, 0.0);\n        case 762: return vec4(-0.524719, 0.032144, -0.128544, 0.0);\n        case 763: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 764: return vec4(-0.174860, 0.351519, 0.079523, 0.0);\n        case 765: return vec4(-0.174860, 0.351519, 0.079523, 0.0);\n        case 766: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 767: return vec4(-0.020036, 1.070062, 0.015155, 0.0);\n        case 768: return vec4(-0.524719, 0.032144, -0.128544, 0.0);\n        case 769: return vec4(-0.588271, 0.006201, -0.433714, 0.0);\n        case 770: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 771: return vec4(-0.588271, 0.006201, -0.433714, 0.0);\n        case 772: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 773: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 774: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 775: return vec4(-0.139941, 0.171092, -0.358654, 0.0);\n        case 776: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 777: return vec4(0.581312, 0.034502, -0.569417, 0.0);\n        case 778: return vec4(0.489723, 0.093914, -0.266242, 0.0);\n        case 779: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 780: return vec4(0.257321, 0.145362, 0.355660, 0.0);\n        case 781: return vec4(0.334070, 0.313111, 0.123899, 0.0);\n        case 782: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 783: return vec4(0.334070, 0.313111, 0.123899, 0.0);\n        case 784: return vec4(0.356214, 0.119525, -0.399525, 0.0);\n        case 785: return vec4(0.213478, 1.043798, 0.253628, 0.0);\n        case 786: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 787: return vec4(0.213478, 1.043798, 0.253628, 0.0);\n        case 788: return vec4(0.356214, 0.119525, -0.399525, 0.0);\n        case 789: return vec4(0.581312, 0.034502, -0.569417, 0.0);\n        case 790: return vec4(0.356214, 0.119525, -0.399525, 0.0);\n        case 791: return vec4(0.334070, 0.313111, 0.123899, 0.0);\n        case 792: return vec4(0.257321, 0.145362, 0.355660, 0.0);\n        case 793: return vec4(0.581312, 0.034502, -0.569417, 0.0);\n        case 794: return vec4(0.334070, 0.313111, 0.123899, 0.0);\n        case 795: return vec4(0.257321, 0.145362, 0.355660, 0.0);\n        case 796: return vec4(0.708718, -0.005564, 0.347980, 0.0);\n        case 797: return vec4(0.581312, 0.034502, -0.569417, 0.0);\n        case 798: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 799: return vec4(0.001713, 0.214821, -0.387921, 0.0);\n        case 800: return vec4(0.356214, 0.119525, -0.399525, 0.0);\n        case 801: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 802: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 803: return vec4(0.001713, 0.214821, -0.387921, 0.0);\n        case 804: return vec4(-0.588271, 0.006201, -0.433714, 0.0);\n        case 805: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 806: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 807: return vec4(-0.524719, 0.032144, -0.128544, 0.0);\n        case 808: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 809: return vec4(-0.588271, 0.006201, -0.433714, 0.0);\n        case 810: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 811: return vec4(-0.524719, 0.032144, -0.128544, 0.0);\n        case 812: return vec4(-0.174860, 0.351519, 0.079523, 0.0);\n        case 813: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 814: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 815: return vec4(-0.113238, 0.982554, 0.110453, 0.0);\n        case 816: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 817: return vec4(-0.113238, 0.982554, 0.110453, 0.0);\n        case 818: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 819: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 820: return vec4(0.001713, 0.214821, -0.387921, 0.0);\n        case 821: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 822: return vec4(0.001713, 0.214821, -0.387921, 0.0);\n        case 823: return vec4(0.021915, 1.119303, -0.024115, 0.0);\n        case 824: return vec4(0.356214, 0.119525, -0.399525, 0.0);\n        case 825: return vec4(-0.040552, 0.023171, -0.760682, 0.0);\n        case 826: return vec4(0.356214, 0.119525, -0.399525, 0.0);\n        case 827: return vec4(0.581312, 0.034502, -0.569417, 0.0);\n        case 828: return vec4(0.213478, 1.043798, 0.253628, 0.0);\n        case 829: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n        case 830: return vec4(0.334070, 0.313111, 0.123899, 0.0);\n        case 831: return vec4(-0.344855, 0.199192, -0.187084, 0.0);\n        case 832: return vec4(-0.174860, 0.351519, 0.079523, 0.0);\n        case 833: return vec4(0.013893, 0.890794, 0.358372, 0.0);\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int idx = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    if ( idx >= SPHERES_OFFSET && idx < TRIANGLES_OFFSET ) {\n        fragColor = sphere(idx - SPHERES_OFFSET);\n        return;\n    }\n    if ( iFrame > 3 ) { // use the previous frame\n        discard;\n    }\n    if ( idx < MATERIALS_OFFSET ) {\n        fragColor = light(idx - LIGHTS_OFFSET);\n    } else if ( idx < PLANES_OFFSET ) {\n        fragColor = material(idx - MATERIALS_OFFSET);\n    } else if ( idx < SPHERES_OFFSET ) {\n        fragColor = plane(idx - PLANES_OFFSET);\n    } else {\n        fragColor = triangle(idx - TRIANGLES_OFFSET);\n    }\n}\n", "buffer_a_inputs": [], "common_code": "//============================================================================\n// PROJECT ID: 02\n//\n// GROUP NUMBER: 03\n//\n// STUDENT NAME: CHEN ZHIAN\n// NUS User ID.: t0933479\n//\n// STUDENT NAME: LI YIXIN\n// NUS User ID.: t0933820\n//\n// STUDENT NAME: OUYANG ANNAN\n// NUS User ID.: t0933394\n//\n// COMMENTS TO GRADER: This is the common fragment shader which will be included\n//                     in all the other fragment shaders by shadertoy.\n//\n//                     We use multiple passes and this is only a part of tasks2.\n//                     There are 1 common file and 4 pass files in total.\n//                     The complete project is in the following link:\n//                     https://www.shadertoy.com/view/lflcWH\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\n// Constants for the scene objects.\n// BufferA layout:\n//   lights\n//   materials\n//   planes\n//   spheres\n//   triangles (front, back, top, bottom, ring, foot)\n//\n// BufferB layout:\n//   camera\nconst int NUM_LIGHTS    = 3;\nconst int NUM_MATERIALS = 13;\nconst int NUM_PLANES    = 1;\nconst int NUM_SPHERES   = 7;\n\nconst int NUM_VERTEX[] = int[](\n    210, // front\n    162, // back\n    114, // top\n    93,  // bottom\n    96,  // ring\n    159  // foot\n);\n\nconst int LIGHTS_UNIT    = 3;\nconst int MATERIALS_UNIT = 4;\nconst int PLANES_UNIT    = 1;\nconst int SPHERES_UNIT   = 1;\n\nconst vec3 AABB_MIN[] = vec3[](\n    vec3(-0.46,  1.62, -0.04), // front\n    vec3(-0.46,  1.47, -0.25), // back\n    vec3(-0.24,  2.85, -0.06), // top\n    vec3(-0.46,  0.89, -0.22), // bottom\n    vec3(-0.71,  2.50, -0.27), // ring\n    vec3(-0.59, -0.02, -0.77)  // foot\n);\n\nconst vec3 AABB_MAX[] = vec3[](\n    vec3(0.59, 3.13,  0.62), // front\n    vec3(0.59, 3.39,  0.22), // back\n    vec3(0.33, 3.45,  0.56), // top\n    vec3(0.59, 2.17,  0.51), // bottom\n    vec3(0.84, 3.81, -0.18), // ring\n    vec3(0.71, 1.12,  0.45)  // foot\n);\n\nconst int LIGHTS_OFFSET    = 0;\nconst int MATERIALS_OFFSET = LIGHTS_OFFSET    + LIGHTS_UNIT    * NUM_LIGHTS;\nconst int PLANES_OFFSET    = MATERIALS_OFFSET + MATERIALS_UNIT * NUM_MATERIALS;\nconst int SPHERES_OFFSET   = PLANES_OFFSET    + PLANES_UNIT    * NUM_PLANES;\nconst int TRIANGLES_OFFSET = SPHERES_OFFSET   + SPHERES_UNIT   * NUM_SPHERES;\n", "buffer_b_code": "//============================================================================\n// PROJECT ID: 02\n//\n// GROUP NUMBER: 03\n//\n// STUDENT NAME: CHEN ZHIAN\n// NUS User ID.: t0933479\n//\n// STUDENT NAME: LI YIXIN\n// NUS User ID.: t0933820\n//\n// STUDENT NAME: OUYANG ANNAN\n// NUS User ID.: t0933394\n//\n// COMMENTS TO GRADER: This is the pass 2 shader which will output to the BufferB\n//                     in shadertoy. BufferB layout can be found in the common\n//                     fragment shader.\n//\n//                     We use multiple passes and this is only a part of tasks2.\n//                     There are 1 common file and 4 pass files in total.\n//                     The complete project is in the following link:\n//                     https://www.shadertoy.com/view/lflcWH\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\nconst float NUM_FRAME = 1179.0;\nconst float FPS = 30.0;\n\nconst float TOTAL_TIME = NUM_FRAME / FPS;\n\nvec4 camera( in int idx )\n{\n    float speed = 0.2;\n    vec3 cam_pos, cam_lookat, cam_up_vec;\n    int frame = int( mod( iTime, TOTAL_TIME ) * FPS );\n    switch(frame) {\n        case 0:\n            cam_pos = vec3(-3.57501, 10.68408, 10.03236);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 1:\n            cam_pos = vec3(-3.56908, 10.68408, 10.03568);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 2:\n            cam_pos = vec3(-3.56315, 10.68408, 10.03900);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 3:\n            cam_pos = vec3(-3.55722, 10.68408, 10.04232);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 4:\n            cam_pos = vec3(-3.55128, 10.68408, 10.04564);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 5:\n            cam_pos = vec3(-3.54535, 10.68408, 10.04895);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 6:\n            cam_pos = vec3(-3.53942, 10.68408, 10.05227);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 7:\n            cam_pos = vec3(-3.53349, 10.68408, 10.05559);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 8:\n            cam_pos = vec3(-3.52756, 10.68408, 10.05891);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 9:\n            cam_pos = vec3(-3.52162, 10.68408, 10.06223);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 10:\n            cam_pos = vec3(-3.51569, 10.68408, 10.06554);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 11:\n            cam_pos = vec3(-3.50976, 10.68408, 10.06886);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 12:\n            cam_pos = vec3(-3.50383, 10.68408, 10.07218);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 13:\n            cam_pos = vec3(-3.49790, 10.68408, 10.07550);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 14:\n            cam_pos = vec3(-3.49196, 10.68408, 10.07882);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 15:\n            cam_pos = vec3(-3.48603, 10.68408, 10.08214);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 16:\n            cam_pos = vec3(-3.48010, 10.68408, 10.08545);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 17:\n            cam_pos = vec3(-3.47417, 10.68408, 10.08877);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 18:\n            cam_pos = vec3(-3.46824, 10.68408, 10.09209);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 19:\n            cam_pos = vec3(-3.46231, 10.68408, 10.09541);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 20:\n            cam_pos = vec3(-3.45637, 10.68408, 10.09872);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 21:\n            cam_pos = vec3(-3.45044, 10.68408, 10.10204);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 22:\n            cam_pos = vec3(-3.44451, 10.68408, 10.10536);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 23:\n            cam_pos = vec3(-3.43858, 10.68408, 10.10868);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 24:\n            cam_pos = vec3(-3.43265, 10.68408, 10.11200);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 25:\n            cam_pos = vec3(-3.42671, 10.68408, 10.11532);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 26:\n            cam_pos = vec3(-3.42078, 10.68408, 10.11863);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 27:\n            cam_pos = vec3(-3.41485, 10.68408, 10.12195);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 28:\n            cam_pos = vec3(-3.40892, 10.68408, 10.12527);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 29:\n            cam_pos = vec3(-3.40299, 10.68408, 10.12859);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 30:\n            cam_pos = vec3(-3.39705, 10.68408, 10.13190);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 31:\n            cam_pos = vec3(-3.39112, 10.68408, 10.13522);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 32:\n            cam_pos = vec3(-3.38519, 10.68408, 10.13854);\n            cam_up_vec = vec3(-0.31821, 0.75836, 0.56888);\n            break;\n        case 33:\n            cam_pos = vec3(-0.18654, 1.61794, 4.02523);\n            cam_up_vec = vec3(0.00229, 0.99273, -0.11946);\n            break;\n        case 34:\n            cam_pos = vec3(-0.18560, 1.61417, 4.02916);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 35:\n            cam_pos = vec3(-0.18594, 1.61192, 4.04619);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 36:\n            cam_pos = vec3(-0.18648, 1.60835, 4.07322);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 37:\n            cam_pos = vec3(-0.18720, 1.60360, 4.10930);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 38:\n            cam_pos = vec3(-0.18809, 1.59775, 4.15362);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 39:\n            cam_pos = vec3(-0.18912, 1.59091, 4.20544);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 40:\n            cam_pos = vec3(-0.19030, 1.58317, 4.26413);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 41:\n            cam_pos = vec3(-0.19160, 1.57460, 4.32911);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 42:\n            cam_pos = vec3(-0.19301, 1.56527, 4.39987);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 43:\n            cam_pos = vec3(-0.19453, 1.55524, 4.47593);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 44:\n            cam_pos = vec3(-0.19615, 1.54456, 4.55687);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 45:\n            cam_pos = vec3(-0.19786, 1.53329, 4.64231);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 46:\n            cam_pos = vec3(-0.19965, 1.52148, 4.73189);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 47:\n            cam_pos = vec3(-0.20152, 1.50916, 4.82528);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 48:\n            cam_pos = vec3(-0.20346, 1.49638, 4.92217);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 49:\n            cam_pos = vec3(-0.20546, 1.48318, 5.02229);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 50:\n            cam_pos = vec3(-0.20753, 1.46958, 5.12536);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 51:\n            cam_pos = vec3(-0.20964, 1.45563, 5.23113);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 52:\n            cam_pos = vec3(-0.21181, 1.44136, 5.33937);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 53:\n            cam_pos = vec3(-0.21402, 1.42679, 5.44985);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 54:\n            cam_pos = vec3(-0.21627, 1.41195, 5.56236);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 55:\n            cam_pos = vec3(-0.21855, 1.39687, 5.67669);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 56:\n            cam_pos = vec3(-0.22087, 1.38157, 5.79265);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 57:\n            cam_pos = vec3(-0.22322, 1.36609, 5.91005);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 58:\n            cam_pos = vec3(-0.22559, 1.35044, 6.02869);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 59:\n            cam_pos = vec3(-0.22799, 1.33465, 6.14841);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 60:\n            cam_pos = vec3(-0.23040, 1.31874, 6.26902);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 61:\n            cam_pos = vec3(-0.23283, 1.30274, 6.39036);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 62:\n            cam_pos = vec3(-0.23527, 1.28666, 6.51224);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 63:\n            cam_pos = vec3(-0.23771, 1.27054, 6.63451);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 64:\n            cam_pos = vec3(-0.24016, 1.25438, 6.75699);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 65:\n            cam_pos = vec3(-0.24261, 1.23822, 6.87951);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 66:\n            cam_pos = vec3(-0.24506, 1.22208, 7.00190);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 67:\n            cam_pos = vec3(-0.24750, 1.20598, 7.12398);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 68:\n            cam_pos = vec3(-0.24994, 1.18994, 7.24559);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 69:\n            cam_pos = vec3(-0.25236, 1.17399, 7.36654);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 70:\n            cam_pos = vec3(-0.25476, 1.15814, 7.48665);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 71:\n            cam_pos = vec3(-0.25714, 1.14244, 7.60573);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 72:\n            cam_pos = vec3(-0.25950, 1.12690, 7.72358);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 73:\n            cam_pos = vec3(-0.26183, 1.11154, 7.83999);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 74:\n            cam_pos = vec3(-0.26412, 1.09640, 7.95476);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 75:\n            cam_pos = vec3(-0.26638, 1.08151, 8.06765);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 76:\n            cam_pos = vec3(-0.26859, 1.06690, 8.17842);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 77:\n            cam_pos = vec3(-0.27076, 1.05261, 8.28683);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 78:\n            cam_pos = vec3(-0.27288, 1.03865, 8.39261);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 79:\n            cam_pos = vec3(-0.27494, 1.02509, 8.49546);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 80:\n            cam_pos = vec3(-0.27693, 1.01195, 8.59507);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 81:\n            cam_pos = vec3(-0.27885, 0.99929, 8.69110);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 82:\n            cam_pos = vec3(-0.28069, 0.98714, 8.78318);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 83:\n            cam_pos = vec3(-0.28245, 0.97557, 8.87091);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 84:\n            cam_pos = vec3(-0.28411, 0.96463, 8.95384);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 85:\n            cam_pos = vec3(-0.28566, 0.95439, 9.03148);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 86:\n            cam_pos = vec3(-0.28709, 0.94492, 9.10326);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 87:\n            cam_pos = vec3(-0.28840, 0.93631, 9.16857);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 88:\n            cam_pos = vec3(-0.28956, 0.92864, 9.22670);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 89:\n            cam_pos = vec3(-0.29057, 0.92203, 9.27683);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 90:\n            cam_pos = vec3(-0.29139, 0.91660, 9.31803);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 91:\n            cam_pos = vec3(-0.29201, 0.91248, 9.34922);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 92:\n            cam_pos = vec3(-0.29241, 0.90986, 9.36909);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 93:\n            cam_pos = vec3(-0.29255, 0.90894, 9.37612);\n            cam_up_vec = vec3(0.00239, 0.99281, -0.11969);\n            break;\n        case 94:\n            cam_pos = vec3(1.64025, 2.46871, 4.22964);\n            cam_up_vec = vec3(0.26847, 0.95989, -0.08048);\n            break;\n        case 95:\n            cam_pos = vec3(1.63569, 2.47286, 4.20413);\n            cam_up_vec = vec3(0.26691, 0.96044, -0.07952);\n            break;\n        case 96:\n            cam_pos = vec3(1.62930, 2.47555, 4.18346);\n            cam_up_vec = vec3(0.26509, 0.96101, -0.07860);\n            break;\n        case 97:\n            cam_pos = vec3(1.62291, 2.47823, 4.16278);\n            cam_up_vec = vec3(0.26328, 0.96159, -0.07768);\n            break;\n        case 98:\n            cam_pos = vec3(1.61652, 2.48091, 4.14211);\n            cam_up_vec = vec3(0.26146, 0.96216, -0.07676);\n            break;\n        case 99:\n            cam_pos = vec3(1.61012, 2.48358, 4.12144);\n            cam_up_vec = vec3(0.25964, 0.96272, -0.07583);\n            break;\n        case 100:\n            cam_pos = vec3(1.60371, 2.48626, 4.10077);\n            cam_up_vec = vec3(0.25783, 0.96328, -0.07491);\n            break;\n        case 101:\n            cam_pos = vec3(1.59731, 2.48893, 4.08010);\n            cam_up_vec = vec3(0.25601, 0.96384, -0.07398);\n            break;\n        case 102:\n            cam_pos = vec3(1.59090, 2.49160, 4.05944);\n            cam_up_vec = vec3(0.25419, 0.96439, -0.07306);\n            break;\n        case 103:\n            cam_pos = vec3(1.58448, 2.49427, 4.03877);\n            cam_up_vec = vec3(0.25236, 0.96494, -0.07214);\n            break;\n        case 104:\n            cam_pos = vec3(1.57806, 2.49693, 4.01811);\n            cam_up_vec = vec3(0.25054, 0.96548, -0.07121);\n            break;\n        case 105:\n            cam_pos = vec3(1.57164, 2.49960, 3.99745);\n            cam_up_vec = vec3(0.24872, 0.96602, -0.07028);\n            break;\n        case 106:\n            cam_pos = vec3(1.56522, 2.50226, 3.97679);\n            cam_up_vec = vec3(0.24689, 0.96656, -0.06936);\n            break;\n        case 107:\n            cam_pos = vec3(1.55879, 2.50492, 3.95614);\n            cam_up_vec = vec3(0.24507, 0.96709, -0.06843);\n            break;\n        case 108:\n            cam_pos = vec3(1.55236, 2.50757, 3.93548);\n            cam_up_vec = vec3(0.24324, 0.96761, -0.06750);\n            break;\n        case 109:\n            cam_pos = vec3(1.54592, 2.51023, 3.91483);\n            cam_up_vec = vec3(0.24142, 0.96814, -0.06657);\n            break;\n        case 110:\n            cam_pos = vec3(1.53948, 2.51288, 3.89418);\n            cam_up_vec = vec3(0.23959, 0.96865, -0.06564);\n            break;\n        case 111:\n            cam_pos = vec3(1.53304, 2.51553, 3.87353);\n            cam_up_vec = vec3(0.23776, 0.96917, -0.06472);\n            break;\n        case 112:\n            cam_pos = vec3(1.52659, 2.51818, 3.85288);\n            cam_up_vec = vec3(0.23593, 0.96967, -0.06379);\n            break;\n        case 113:\n            cam_pos = vec3(1.52014, 2.52083, 3.83224);\n            cam_up_vec = vec3(0.23410, 0.97018, -0.06286);\n            break;\n        case 114:\n            cam_pos = vec3(1.51369, 2.52347, 3.81160);\n            cam_up_vec = vec3(0.23226, 0.97068, -0.06192);\n            break;\n        case 115:\n            cam_pos = vec3(1.50723, 2.52611, 3.79095);\n            cam_up_vec = vec3(0.23043, 0.97118, -0.06099);\n            break;\n        case 116:\n            cam_pos = vec3(1.50077, 2.52875, 3.77031);\n            cam_up_vec = vec3(0.22860, 0.97167, -0.06006);\n            break;\n        case 117:\n            cam_pos = vec3(1.49430, 2.53139, 3.74968);\n            cam_up_vec = vec3(0.22676, 0.97215, -0.05913);\n            break;\n        case 118:\n            cam_pos = vec3(1.48783, 2.53403, 3.72904);\n            cam_up_vec = vec3(0.22493, 0.97264, -0.05820);\n            break;\n        case 119:\n            cam_pos = vec3(1.48136, 2.53666, 3.70841);\n            cam_up_vec = vec3(0.22309, 0.97311, -0.05726);\n            break;\n        case 120:\n            cam_pos = vec3(1.47488, 2.53930, 3.68777);\n            cam_up_vec = vec3(0.22125, 0.97359, -0.05633);\n            break;\n        case 121:\n            cam_pos = vec3(1.46841, 2.54193, 3.66714);\n            cam_up_vec = vec3(0.21941, 0.97406, -0.05540);\n            break;\n        case 122:\n            cam_pos = vec3(1.46192, 2.54455, 3.64652);\n            cam_up_vec = vec3(0.21757, 0.97452, -0.05446);\n            break;\n        case 123:\n            cam_pos = vec3(1.45543, 2.54718, 3.62589);\n            cam_up_vec = vec3(0.21573, 0.97498, -0.05353);\n            break;\n        case 124:\n            cam_pos = vec3(1.44894, 2.54981, 3.60527);\n            cam_up_vec = vec3(0.21389, 0.97544, -0.05259);\n            break;\n        case 125:\n            cam_pos = vec3(1.44245, 2.55243, 3.58464);\n            cam_up_vec = vec3(0.21205, 0.97589, -0.05166);\n            break;\n        case 126:\n            cam_pos = vec3(1.43595, 2.55505, 3.56402);\n            cam_up_vec = vec3(0.21021, 0.97634, -0.05072);\n            break;\n        case 127:\n            cam_pos = vec3(1.42945, 2.55767, 3.54340);\n            cam_up_vec = vec3(0.20836, 0.97678, -0.04978);\n            break;\n        case 128:\n            cam_pos = vec3(1.42294, 2.56029, 3.52279);\n            cam_up_vec = vec3(0.20652, 0.97722, -0.04885);\n            break;\n        case 129:\n            cam_pos = vec3(1.41643, 2.56290, 3.50217);\n            cam_up_vec = vec3(0.20467, 0.97766, -0.04791);\n            break;\n        case 130:\n            cam_pos = vec3(1.40992, 2.56552, 3.48156);\n            cam_up_vec = vec3(0.20283, 0.97809, -0.04697);\n            break;\n        case 131:\n            cam_pos = vec3(1.40340, 2.56813, 3.46095);\n            cam_up_vec = vec3(0.20098, 0.97851, -0.04603);\n            break;\n        case 132:\n            cam_pos = vec3(1.39688, 2.57074, 3.44034);\n            cam_up_vec = vec3(0.19913, 0.97893, -0.04509);\n            break;\n        case 133:\n            cam_pos = vec3(1.39036, 2.57334, 3.41973);\n            cam_up_vec = vec3(0.19728, 0.97935, -0.04416);\n            break;\n        case 134:\n            cam_pos = vec3(1.38383, 2.57595, 3.39912);\n            cam_up_vec = vec3(0.19543, 0.97976, -0.04322);\n            break;\n        case 135:\n            cam_pos = vec3(1.37730, 2.57855, 3.37852);\n            cam_up_vec = vec3(0.19358, 0.98017, -0.04228);\n            break;\n        case 136:\n            cam_pos = vec3(1.37076, 2.58116, 3.35792);\n            cam_up_vec = vec3(0.19173, 0.98058, -0.04134);\n            break;\n        case 137:\n            cam_pos = vec3(1.36422, 2.58376, 3.33732);\n            cam_up_vec = vec3(0.18988, 0.98098, -0.04040);\n            break;\n        case 138:\n            cam_pos = vec3(1.35768, 2.58636, 3.31672);\n            cam_up_vec = vec3(0.18803, 0.98137, -0.03945);\n            break;\n        case 139:\n            cam_pos = vec3(1.35113, 2.58895, 3.29612);\n            cam_up_vec = vec3(0.18618, 0.98176, -0.03851);\n            break;\n        case 140:\n            cam_pos = vec3(1.34458, 2.59155, 3.27553);\n            cam_up_vec = vec3(0.18432, 0.98215, -0.03757);\n            break;\n        case 141:\n            cam_pos = vec3(1.33802, 2.59414, 3.25494);\n            cam_up_vec = vec3(0.18247, 0.98253, -0.03663);\n            break;\n        case 142:\n            cam_pos = vec3(1.33146, 2.59674, 3.23435);\n            cam_up_vec = vec3(0.18061, 0.98291, -0.03569);\n            break;\n        case 143:\n            cam_pos = vec3(1.32490, 2.59933, 3.21376);\n            cam_up_vec = vec3(0.17876, 0.98328, -0.03474);\n            break;\n        case 144:\n            cam_pos = vec3(1.31834, 2.60192, 3.19317);\n            cam_up_vec = vec3(0.17690, 0.98365, -0.03380);\n            break;\n        case 145:\n            cam_pos = vec3(1.31177, 2.60450, 3.17259);\n            cam_up_vec = vec3(0.17504, 0.98401, -0.03286);\n            break;\n        case 146:\n            cam_pos = vec3(1.30519, 2.60709, 3.15201);\n            cam_up_vec = vec3(0.17318, 0.98437, -0.03191);\n            break;\n        case 147:\n            cam_pos = vec3(1.29861, 2.60967, 3.13143);\n            cam_up_vec = vec3(0.17132, 0.98473, -0.03097);\n            break;\n        case 148:\n            cam_pos = vec3(1.29203, 2.61226, 3.11085);\n            cam_up_vec = vec3(0.16947, 0.98508, -0.03003);\n            break;\n        case 149:\n            cam_pos = vec3(1.28545, 2.61484, 3.09027);\n            cam_up_vec = vec3(0.16760, 0.98543, -0.02908);\n            break;\n        case 150:\n            cam_pos = vec3(1.27886, 2.61742, 3.06970);\n            cam_up_vec = vec3(0.16574, 0.98577, -0.02813);\n            break;\n        case 151:\n            cam_pos = vec3(1.27227, 2.62000, 3.04912);\n            cam_up_vec = vec3(0.16388, 0.98611, -0.02719);\n            break;\n        case 152:\n            cam_pos = vec3(1.26567, 2.62257, 3.02855);\n            cam_up_vec = vec3(0.16202, 0.98644, -0.02624);\n            break;\n        case 153:\n            cam_pos = vec3(1.25907, 2.62515, 3.00798);\n            cam_up_vec = vec3(0.16016, 0.98677, -0.02530);\n            break;\n        case 154:\n            cam_pos = vec3(1.25246, 2.62772, 2.98742);\n            cam_up_vec = vec3(0.15829, 0.98709, -0.02435);\n            break;\n        case 155:\n            cam_pos = vec3(1.24586, 2.63029, 2.96685);\n            cam_up_vec = vec3(0.15643, 0.98741, -0.02340);\n            break;\n        case 156:\n            cam_pos = vec3(1.23924, 2.63286, 2.94629);\n            cam_up_vec = vec3(0.15457, 0.98773, -0.02246);\n            break;\n        case 157:\n            cam_pos = vec3(1.23263, 2.63543, 2.92573);\n            cam_up_vec = vec3(0.15270, 0.98804, -0.02151);\n            break;\n        case 158:\n            cam_pos = vec3(1.22601, 2.63800, 2.90517);\n            cam_up_vec = vec3(0.15084, 0.98835, -0.02056);\n            break;\n        case 159:\n            cam_pos = vec3(1.21938, 2.64057, 2.88461);\n            cam_up_vec = vec3(0.14897, 0.98865, -0.01961);\n            break;\n        case 160:\n            cam_pos = vec3(1.21276, 2.64313, 2.86406);\n            cam_up_vec = vec3(0.14710, 0.98895, -0.01867);\n            break;\n        case 161:\n            cam_pos = vec3(1.20613, 2.64569, 2.84350);\n            cam_up_vec = vec3(0.14523, 0.98924, -0.01772);\n            break;\n        case 162:\n            cam_pos = vec3(1.19949, 2.64826, 2.82295);\n            cam_up_vec = vec3(0.14337, 0.98953, -0.01677);\n            break;\n        case 163:\n            cam_pos = vec3(1.19285, 2.65082, 2.80240);\n            cam_up_vec = vec3(0.14150, 0.98981, -0.01582);\n            break;\n        case 164:\n            cam_pos = vec3(1.18621, 2.65337, 2.78185);\n            cam_up_vec = vec3(0.13963, 0.99009, -0.01487);\n            break;\n        case 165:\n            cam_pos = vec3(1.17956, 2.65593, 2.76131);\n            cam_up_vec = vec3(0.13776, 0.99037, -0.01392);\n            break;\n        case 166:\n            cam_pos = vec3(1.17291, 2.65849, 2.74076);\n            cam_up_vec = vec3(0.13589, 0.99064, -0.01297);\n            break;\n        case 167:\n            cam_pos = vec3(1.16626, 2.66104, 2.72022);\n            cam_up_vec = vec3(0.13402, 0.99091, -0.01202);\n            break;\n        case 168:\n            cam_pos = vec3(1.15960, 2.66360, 2.69968);\n            cam_up_vec = vec3(0.13215, 0.99117, -0.01107);\n            break;\n        case 169:\n            cam_pos = vec3(1.15294, 2.66615, 2.67915);\n            cam_up_vec = vec3(0.13028, 0.99143, -0.01012);\n            break;\n        case 170:\n            cam_pos = vec3(1.14627, 2.66870, 2.65861);\n            cam_up_vec = vec3(0.12840, 0.99168, -0.00917);\n            break;\n        case 171:\n            cam_pos = vec3(1.13960, 2.67125, 2.63808);\n            cam_up_vec = vec3(0.12653, 0.99193, -0.00822);\n            break;\n        case 172:\n            cam_pos = vec3(1.13293, 2.67380, 2.61755);\n            cam_up_vec = vec3(0.12466, 0.99217, -0.00726);\n            break;\n        case 173:\n            cam_pos = vec3(1.12625, 2.67635, 2.59702);\n            cam_up_vec = vec3(0.12279, 0.99241, -0.00631);\n            break;\n        case 174:\n            cam_pos = vec3(1.11957, 2.67889, 2.57649);\n            cam_up_vec = vec3(0.12091, 0.99265, -0.00536);\n            break;\n        case 175:\n            cam_pos = vec3(1.11288, 2.68144, 2.55596);\n            cam_up_vec = vec3(0.11904, 0.99288, -0.00441);\n            break;\n        case 176:\n            cam_pos = vec3(1.10619, 2.68398, 2.53544);\n            cam_up_vec = vec3(0.11716, 0.99311, -0.00346);\n            break;\n        case 177:\n            cam_pos = vec3(1.09950, 2.68652, 2.51492);\n            cam_up_vec = vec3(0.11529, 0.99333, -0.00250);\n            break;\n        case 178:\n            cam_pos = vec3(1.09280, 2.68906, 2.49440);\n            cam_up_vec = vec3(0.11341, 0.99355, -0.00155);\n            break;\n        case 179:\n            cam_pos = vec3(1.08610, 2.69160, 2.47388);\n            cam_up_vec = vec3(0.11154, 0.99376, -0.00060);\n            break;\n        case 180:\n            cam_pos = vec3(4.91077, 2.36275, 6.45292);\n            cam_up_vec = vec3(0.13925, 0.99004, 0.02072);\n            break;\n        case 181:\n            cam_pos = vec3(4.94315, 2.36024, 6.44168);\n            cam_up_vec = vec3(0.13924, 0.99006, 0.02006);\n            break;\n        case 182:\n            cam_pos = vec3(4.97142, 2.35810, 6.42109);\n            cam_up_vec = vec3(0.13917, 0.99008, 0.01929);\n            break;\n        case 183:\n            cam_pos = vec3(5.00223, 2.35576, 6.39843);\n            cam_up_vec = vec3(0.13909, 0.99011, 0.01845);\n            break;\n        case 184:\n            cam_pos = vec3(5.03539, 2.35323, 6.37381);\n            cam_up_vec = vec3(0.13900, 0.99014, 0.01754);\n            break;\n        case 185:\n            cam_pos = vec3(5.07074, 2.35053, 6.34729);\n            cam_up_vec = vec3(0.13889, 0.99017, 0.01657);\n            break;\n        case 186:\n            cam_pos = vec3(5.10810, 2.34766, 6.31894);\n            cam_up_vec = vec3(0.13878, 0.99020, 0.01554);\n            break;\n        case 187:\n            cam_pos = vec3(5.14733, 2.34464, 6.28882);\n            cam_up_vec = vec3(0.13864, 0.99024, 0.01446);\n            break;\n        case 188:\n            cam_pos = vec3(5.18829, 2.34146, 6.25699);\n            cam_up_vec = vec3(0.13850, 0.99027, 0.01333);\n            break;\n        case 189:\n            cam_pos = vec3(5.23084, 2.33815, 6.22349);\n            cam_up_vec = vec3(0.13833, 0.99031, 0.01215);\n            break;\n        case 190:\n            cam_pos = vec3(5.27485, 2.33471, 6.18836);\n            cam_up_vec = vec3(0.13816, 0.99035, 0.01092);\n            break;\n        case 191:\n            cam_pos = vec3(5.32023, 2.33114, 6.15165);\n            cam_up_vec = vec3(0.13796, 0.99039, 0.00966);\n            break;\n        case 192:\n            cam_pos = vec3(5.36684, 2.32745, 6.11339);\n            cam_up_vec = vec3(0.13775, 0.99043, 0.00835);\n            break;\n        case 193:\n            cam_pos = vec3(5.41460, 2.32365, 6.07361);\n            cam_up_vec = vec3(0.13751, 0.99047, 0.00701);\n            break;\n        case 194:\n            cam_pos = vec3(5.46340, 2.31974, 6.03235);\n            cam_up_vec = vec3(0.13726, 0.99052, 0.00564);\n            break;\n        case 195:\n            cam_pos = vec3(5.51315, 2.31573, 5.98963);\n            cam_up_vec = vec3(0.13699, 0.99056, 0.00423);\n            break;\n        case 196:\n            cam_pos = vec3(5.56375, 2.31162, 5.94548);\n            cam_up_vec = vec3(0.13670, 0.99061, 0.00280);\n            break;\n        case 197:\n            cam_pos = vec3(5.61513, 2.30742, 5.89993);\n            cam_up_vec = vec3(0.13639, 0.99065, 0.00134);\n            break;\n        case 198:\n            cam_pos = vec3(5.66720, 2.30313, 5.85299);\n            cam_up_vec = vec3(0.13605, 0.99070, -0.00015);\n            break;\n        case 199:\n            cam_pos = vec3(5.71988, 2.29876, 5.80470);\n            cam_up_vec = vec3(0.13570, 0.99075, -0.00166);\n            break;\n        case 200:\n            cam_pos = vec3(5.77311, 2.29431, 5.75507);\n            cam_up_vec = vec3(0.13532, 0.99080, -0.00319);\n            break;\n        case 201:\n            cam_pos = vec3(5.82681, 2.28978, 5.70413);\n            cam_up_vec = vec3(0.13491, 0.99085, -0.00475);\n            break;\n        case 202:\n            cam_pos = vec3(5.88091, 2.28518, 5.65190);\n            cam_up_vec = vec3(0.13449, 0.99090, -0.00631);\n            break;\n        case 203:\n            cam_pos = vec3(5.93534, 2.28052, 5.59839);\n            cam_up_vec = vec3(0.13404, 0.99094, -0.00790);\n            break;\n        case 204:\n            cam_pos = vec3(5.99006, 2.27578, 5.54362);\n            cam_up_vec = vec3(0.13356, 0.99100, -0.00950);\n            break;\n        case 205:\n            cam_pos = vec3(6.04498, 2.27098, 5.48763);\n            cam_up_vec = vec3(0.13306, 0.99105, -0.01111);\n            break;\n        case 206:\n            cam_pos = vec3(6.10006, 2.26613, 5.43042);\n            cam_up_vec = vec3(0.13254, 0.99110, -0.01274);\n            break;\n        case 207:\n            cam_pos = vec3(6.15524, 2.26121, 5.37202);\n            cam_up_vec = vec3(0.13199, 0.99115, -0.01437);\n            break;\n        case 208:\n            cam_pos = vec3(6.21046, 2.25624, 5.31244);\n            cam_up_vec = vec3(0.13142, 0.99120, -0.01601);\n            break;\n        case 209:\n            cam_pos = vec3(6.26568, 2.25122, 5.25171);\n            cam_up_vec = vec3(0.13082, 0.99125, -0.01767);\n            break;\n        case 210:\n            cam_pos = vec3(6.32085, 2.24615, 5.18985);\n            cam_up_vec = vec3(0.13019, 0.99130, -0.01932);\n            break;\n        case 211:\n            cam_pos = vec3(6.37590, 2.24104, 5.12687);\n            cam_up_vec = vec3(0.12954, 0.99135, -0.02098);\n            break;\n        case 212:\n            cam_pos = vec3(6.43081, 2.23588, 5.06279);\n            cam_up_vec = vec3(0.12886, 0.99140, -0.02265);\n            break;\n        case 213:\n            cam_pos = vec3(6.48551, 2.23067, 4.99764);\n            cam_up_vec = vec3(0.12816, 0.99146, -0.02431);\n            break;\n        case 214:\n            cam_pos = vec3(6.53998, 2.22543, 4.93143);\n            cam_up_vec = vec3(0.12743, 0.99151, -0.02598);\n            break;\n        case 215:\n            cam_pos = vec3(6.59416, 2.22015, 4.86420);\n            cam_up_vec = vec3(0.12667, 0.99156, -0.02765);\n            break;\n        case 216:\n            cam_pos = vec3(6.64802, 2.21483, 4.79595);\n            cam_up_vec = vec3(0.12589, 0.99161, -0.02931);\n            break;\n        case 217:\n            cam_pos = vec3(6.70151, 2.20948, 4.72671);\n            cam_up_vec = vec3(0.12508, 0.99166, -0.03097);\n            break;\n        case 218:\n            cam_pos = vec3(6.75460, 2.20409, 4.65650);\n            cam_up_vec = vec3(0.12425, 0.99171, -0.03263);\n            break;\n        case 219:\n            cam_pos = vec3(6.80725, 2.19868, 4.58535);\n            cam_up_vec = vec3(0.12339, 0.99177, -0.03429);\n            break;\n        case 220:\n            cam_pos = vec3(6.85943, 2.19324, 4.51327);\n            cam_up_vec = vec3(0.12251, 0.99182, -0.03594);\n            break;\n        case 221:\n            cam_pos = vec3(6.91110, 2.18777, 4.44030);\n            cam_up_vec = vec3(0.12160, 0.99187, -0.03758);\n            break;\n        case 222:\n            cam_pos = vec3(6.96223, 2.18228, 4.36645);\n            cam_up_vec = vec3(0.12066, 0.99192, -0.03921);\n            break;\n        case 223:\n            cam_pos = vec3(7.01278, 2.17676, 4.29174);\n            cam_up_vec = vec3(0.11970, 0.99197, -0.04084);\n            break;\n        case 224:\n            cam_pos = vec3(7.06273, 2.17122, 4.21622);\n            cam_up_vec = vec3(0.11872, 0.99202, -0.04245);\n            break;\n        case 225:\n            cam_pos = vec3(7.11205, 2.16566, 4.13988);\n            cam_up_vec = vec3(0.11771, 0.99207, -0.04406);\n            break;\n        case 226:\n            cam_pos = vec3(7.16071, 2.16008, 4.06278);\n            cam_up_vec = vec3(0.11668, 0.99212, -0.04565);\n            break;\n        case 227:\n            cam_pos = vec3(7.20868, 2.15449, 3.98492);\n            cam_up_vec = vec3(0.11562, 0.99217, -0.04723);\n            break;\n        case 228:\n            cam_pos = vec3(7.25593, 2.14888, 3.90634);\n            cam_up_vec = vec3(0.11454, 0.99222, -0.04880);\n            break;\n        case 229:\n            cam_pos = vec3(7.30244, 2.14326, 3.82706);\n            cam_up_vec = vec3(0.11344, 0.99227, -0.05035);\n            break;\n        case 230:\n            cam_pos = vec3(7.34819, 2.13763, 3.74711);\n            cam_up_vec = vec3(0.11231, 0.99232, -0.05189);\n            break;\n        case 231:\n            cam_pos = vec3(7.39315, 2.13198, 3.66652);\n            cam_up_vec = vec3(0.11117, 0.99237, -0.05341);\n            break;\n        case 232:\n            cam_pos = vec3(7.43730, 2.12633, 3.58532);\n            cam_up_vec = vec3(0.11000, 0.99241, -0.05492);\n            break;\n        case 233:\n            cam_pos = vec3(7.48062, 2.12067, 3.50354);\n            cam_up_vec = vec3(0.10881, 0.99246, -0.05640);\n            break;\n        case 234:\n            cam_pos = vec3(7.52309, 2.11500, 3.42120);\n            cam_up_vec = vec3(0.10760, 0.99251, -0.05788);\n            break;\n        case 235:\n            cam_pos = vec3(7.56470, 2.10933, 3.33834);\n            cam_up_vec = vec3(0.10637, 0.99256, -0.05933);\n            break;\n        case 236:\n            cam_pos = vec3(7.60542, 2.10366, 3.25498);\n            cam_up_vec = vec3(0.10512, 0.99260, -0.06076);\n            break;\n        case 237:\n            cam_pos = vec3(7.64523, 2.09798, 3.17117);\n            cam_up_vec = vec3(0.10385, 0.99265, -0.06217);\n            break;\n        case 238:\n            cam_pos = vec3(7.68413, 2.09230, 3.08692);\n            cam_up_vec = vec3(0.10256, 0.99269, -0.06357);\n            break;\n        case 239:\n            cam_pos = vec3(7.72210, 2.08663, 3.00228);\n            cam_up_vec = vec3(0.10126, 0.99274, -0.06494);\n            break;\n        case 240:\n            cam_pos = vec3(7.75913, 2.08096, 2.91726);\n            cam_up_vec = vec3(0.09994, 0.99278, -0.06629);\n            break;\n        case 241:\n            cam_pos = vec3(7.79519, 2.07529, 2.83192);\n            cam_up_vec = vec3(0.09860, 0.99283, -0.06762);\n            break;\n        case 242:\n            cam_pos = vec3(7.83029, 2.06963, 2.74628);\n            cam_up_vec = vec3(0.09725, 0.99287, -0.06892);\n            break;\n        case 243:\n            cam_pos = vec3(7.86441, 2.06398, 2.66037);\n            cam_up_vec = vec3(0.09588, 0.99291, -0.07021);\n            break;\n        case 244:\n            cam_pos = vec3(7.89754, 2.05833, 2.57424);\n            cam_up_vec = vec3(0.09450, 0.99296, -0.07147);\n            break;\n        case 245:\n            cam_pos = vec3(7.92968, 2.05270, 2.48791);\n            cam_up_vec = vec3(0.09310, 0.99300, -0.07270);\n            break;\n        case 246:\n            cam_pos = vec3(7.96081, 2.04708, 2.40142);\n            cam_up_vec = vec3(0.09170, 0.99304, -0.07391);\n            break;\n        case 247:\n            cam_pos = vec3(7.99093, 2.04147, 2.31482);\n            cam_up_vec = vec3(0.09028, 0.99308, -0.07510);\n            break;\n        case 248:\n            cam_pos = vec3(8.02004, 2.03587, 2.22813);\n            cam_up_vec = vec3(0.08885, 0.99312, -0.07626);\n            break;\n        case 249:\n            cam_pos = vec3(8.04813, 2.03030, 2.14139);\n            cam_up_vec = vec3(0.08741, 0.99316, -0.07739);\n            break;\n        case 250:\n            cam_pos = vec3(8.07520, 2.02474, 2.05465);\n            cam_up_vec = vec3(0.08596, 0.99320, -0.07850);\n            break;\n        case 251:\n            cam_pos = vec3(8.10125, 2.01920, 1.96793);\n            cam_up_vec = vec3(0.08450, 0.99324, -0.07959);\n            break;\n        case 252:\n            cam_pos = vec3(8.12628, 2.01368, 1.88129);\n            cam_up_vec = vec3(0.08303, 0.99328, -0.08064);\n            break;\n        case 253:\n            cam_pos = vec3(8.15029, 2.00819, 1.79477);\n            cam_up_vec = vec3(0.08156, 0.99332, -0.08167);\n            break;\n        case 254:\n            cam_pos = vec3(8.17327, 2.00272, 1.70839);\n            cam_up_vec = vec3(0.08009, 0.99335, -0.08268);\n            break;\n        case 255:\n            cam_pos = vec3(8.19524, 1.99728, 1.62222);\n            cam_up_vec = vec3(0.07860, 0.99339, -0.08366);\n            break;\n        case 256:\n            cam_pos = vec3(8.21620, 1.99187, 1.53628);\n            cam_up_vec = vec3(0.07712, 0.99343, -0.08461);\n            break;\n        case 257:\n            cam_pos = vec3(8.23615, 1.98649, 1.45062);\n            cam_up_vec = vec3(0.07563, 0.99346, -0.08553);\n            break;\n        case 258:\n            cam_pos = vec3(8.25509, 1.98115, 1.36529);\n            cam_up_vec = vec3(0.07414, 0.99350, -0.08643);\n            break;\n        case 259:\n            cam_pos = vec3(8.27305, 1.97584, 1.28033);\n            cam_up_vec = vec3(0.07265, 0.99353, -0.08729);\n            break;\n        case 260:\n            cam_pos = vec3(8.29002, 1.97056, 1.19579);\n            cam_up_vec = vec3(0.07117, 0.99356, -0.08814);\n            break;\n        case 261:\n            cam_pos = vec3(8.30601, 1.96533, 1.11172);\n            cam_up_vec = vec3(0.06968, 0.99360, -0.08895);\n            break;\n        case 262:\n            cam_pos = vec3(8.32104, 1.96013, 1.02816);\n            cam_up_vec = vec3(0.06819, 0.99363, -0.08974);\n            break;\n        case 263:\n            cam_pos = vec3(8.33512, 1.95499, 0.94517);\n            cam_up_vec = vec3(0.06671, 0.99366, -0.09050);\n            break;\n        case 264:\n            cam_pos = vec3(8.34826, 1.94988, 0.86279);\n            cam_up_vec = vec3(0.06524, 0.99369, -0.09123);\n            break;\n        case 265:\n            cam_pos = vec3(8.36048, 1.94483, 0.78108);\n            cam_up_vec = vec3(0.06377, 0.99372, -0.09194);\n            break;\n        case 266:\n            cam_pos = vec3(8.37179, 1.93983, 0.70008);\n            cam_up_vec = vec3(0.06231, 0.99375, -0.09262);\n            break;\n        case 267:\n            cam_pos = vec3(8.38221, 1.93488, 0.61987);\n            cam_up_vec = vec3(0.06086, 0.99378, -0.09327);\n            break;\n        case 268:\n            cam_pos = vec3(8.39176, 1.92999, 0.54048);\n            cam_up_vec = vec3(0.05942, 0.99381, -0.09390);\n            break;\n        case 269:\n            cam_pos = vec3(8.40046, 1.92516, 0.46200);\n            cam_up_vec = vec3(0.05799, 0.99383, -0.09450);\n            break;\n        case 270:\n            cam_pos = vec3(8.40833, 1.92039, 0.38446);\n            cam_up_vec = vec3(0.05657, 0.99386, -0.09507);\n            break;\n        case 271:\n            cam_pos = vec3(8.41540, 1.91569, 0.30793);\n            cam_up_vec = vec3(0.05517, 0.99389, -0.09562);\n            break;\n        case 272:\n            cam_pos = vec3(8.42169, 1.91106, 0.23249);\n            cam_up_vec = vec3(0.05378, 0.99391, -0.09614);\n            break;\n        case 273:\n            cam_pos = vec3(8.42721, 1.90650, 0.15819);\n            cam_up_vec = vec3(0.05241, 0.99394, -0.09664);\n            break;\n        case 274:\n            cam_pos = vec3(8.43202, 1.90202, 0.08511);\n            cam_up_vec = vec3(0.05106, 0.99396, -0.09712);\n            break;\n        case 275:\n            cam_pos = vec3(8.43612, 1.89763, 0.01333);\n            cam_up_vec = vec3(0.04973, 0.99399, -0.09757);\n            break;\n        case 276:\n            cam_pos = vec3(8.43955, 1.89331, -0.05709);\n            cam_up_vec = vec3(0.04842, 0.99401, -0.09799);\n            break;\n        case 277:\n            cam_pos = vec3(8.44235, 1.88909, -0.12607);\n            cam_up_vec = vec3(0.04713, 0.99403, -0.09839);\n            break;\n        case 278:\n            cam_pos = vec3(8.44454, 1.88496, -0.19351);\n            cam_up_vec = vec3(0.04587, 0.99405, -0.09877);\n            break;\n        case 279:\n            cam_pos = vec3(8.44617, 1.88093, -0.25934);\n            cam_up_vec = vec3(0.04464, 0.99407, -0.09913);\n            break;\n        case 280:\n            cam_pos = vec3(8.44726, 1.87701, -0.32345);\n            cam_up_vec = vec3(0.04344, 0.99409, -0.09947);\n            break;\n        case 281:\n            cam_pos = vec3(8.44785, 1.87320, -0.38574);\n            cam_up_vec = vec3(0.04227, 0.99411, -0.09978);\n            break;\n        case 282:\n            cam_pos = vec3(8.44800, 1.86951, -0.44612);\n            cam_up_vec = vec3(0.04114, 0.99413, -0.10007);\n            break;\n        case 283:\n            cam_pos = vec3(8.44773, 1.86594, -0.50447);\n            cam_up_vec = vec3(0.04004, 0.99415, -0.10035);\n            break;\n        case 284:\n            cam_pos = vec3(8.44710, 1.86250, -0.56067);\n            cam_up_vec = vec3(0.03897, 0.99416, -0.10060);\n            break;\n        case 285:\n            cam_pos = vec3(8.44614, 1.85920, -0.61459);\n            cam_up_vec = vec3(0.03795, 0.99418, -0.10083);\n            break;\n        case 286:\n            cam_pos = vec3(8.44490, 1.85605, -0.66610);\n            cam_up_vec = vec3(0.03698, 0.99419, -0.10105);\n            break;\n        case 287:\n            cam_pos = vec3(8.44344, 1.85306, -0.71503);\n            cam_up_vec = vec3(0.03605, 0.99421, -0.10124);\n            break;\n        case 288:\n            cam_pos = vec3(-2.49388, 1.52098, 1.18673);\n            cam_up_vec = vec3(0.21409, 0.96899, -0.12304);\n            break;\n        case 289:\n            cam_pos = vec3(-2.51706, 1.51905, 1.20003);\n            cam_up_vec = vec3(0.21467, 0.96870, -0.12463);\n            break;\n        case 290:\n            cam_pos = vec3(-2.50752, 1.51774, 1.20947);\n            cam_up_vec = vec3(0.21474, 0.96846, -0.12635);\n            break;\n        case 291:\n            cam_pos = vec3(-2.49676, 1.51608, 1.22065);\n            cam_up_vec = vec3(0.21480, 0.96820, -0.12829);\n            break;\n        case 292:\n            cam_pos = vec3(-2.48462, 1.51402, 1.23372);\n            cam_up_vec = vec3(0.21485, 0.96790, -0.13046);\n            break;\n        case 293:\n            cam_pos = vec3(-2.47096, 1.51155, 1.24880);\n            cam_up_vec = vec3(0.21487, 0.96756, -0.13289);\n            break;\n        case 294:\n            cam_pos = vec3(-2.45559, 1.50861, 1.26604);\n            cam_up_vec = vec3(0.21487, 0.96718, -0.13559);\n            break;\n        case 295:\n            cam_pos = vec3(-2.43832, 1.50518, 1.28559);\n            cam_up_vec = vec3(0.21484, 0.96677, -0.13860);\n            break;\n        case 296:\n            cam_pos = vec3(-2.41894, 1.50122, 1.30757);\n            cam_up_vec = vec3(0.21475, 0.96630, -0.14194);\n            break;\n        case 297:\n            cam_pos = vec3(-2.39725, 1.49668, 1.33209);\n            cam_up_vec = vec3(0.21460, 0.96578, -0.14563);\n            break;\n        case 298:\n            cam_pos = vec3(-2.37302, 1.49155, 1.35922);\n            cam_up_vec = vec3(0.21436, 0.96521, -0.14971);\n            break;\n        case 299:\n            cam_pos = vec3(-2.34606, 1.48579, 1.38896);\n            cam_up_vec = vec3(0.21402, 0.96458, -0.15418);\n            break;\n        case 300:\n            cam_pos = vec3(-2.31621, 1.47940, 1.42125);\n            cam_up_vec = vec3(0.21356, 0.96390, -0.15905);\n            break;\n        case 301:\n            cam_pos = vec3(-2.28336, 1.47239, 1.45591);\n            cam_up_vec = vec3(0.21294, 0.96315, -0.16433);\n            break;\n        case 302:\n            cam_pos = vec3(-2.24751, 1.46479, 1.49267);\n            cam_up_vec = vec3(0.21215, 0.96234, -0.17000);\n            break;\n        case 303:\n            cam_pos = vec3(-2.20875, 1.45666, 1.53112);\n            cam_up_vec = vec3(0.21116, 0.96147, -0.17603);\n            break;\n        case 304:\n            cam_pos = vec3(-2.16732, 1.44808, 1.57074);\n            cam_up_vec = vec3(0.20996, 0.96056, -0.18235);\n            break;\n        case 305:\n            cam_pos = vec3(-2.12355, 1.43915, 1.61095);\n            cam_up_vec = vec3(0.20853, 0.95960, -0.18891);\n            break;\n        case 306:\n            cam_pos = vec3(-2.07788, 1.42999, 1.65114);\n            cam_up_vec = vec3(0.20688, 0.95861, -0.19563);\n            break;\n        case 307:\n            cam_pos = vec3(-2.03082, 1.42072, 1.69075);\n            cam_up_vec = vec3(0.20502, 0.95760, -0.20243);\n            break;\n        case 308:\n            cam_pos = vec3(-1.98286, 1.41145, 1.72927);\n            cam_up_vec = vec3(0.20296, 0.95657, -0.20923);\n            break;\n        case 309:\n            cam_pos = vec3(-1.93450, 1.40228, 1.76630);\n            cam_up_vec = vec3(0.20072, 0.95555, -0.21597);\n            break;\n        case 310:\n            cam_pos = vec3(-1.88614, 1.39328, 1.80156);\n            cam_up_vec = vec3(0.19832, 0.95453, -0.22258);\n            break;\n        case 311:\n            cam_pos = vec3(-1.83816, 1.38451, 1.83487);\n            cam_up_vec = vec3(0.19580, 0.95352, -0.22903);\n            break;\n        case 312:\n            cam_pos = vec3(-1.79081, 1.37601, 1.86614);\n            cam_up_vec = vec3(0.19316, 0.95254, -0.23529);\n            break;\n        case 313:\n            cam_pos = vec3(-1.74432, 1.36780, 1.89536);\n            cam_up_vec = vec3(0.19045, 0.95157, -0.24134);\n            break;\n        case 314:\n            cam_pos = vec3(-1.69882, 1.35991, 1.92257);\n            cam_up_vec = vec3(0.18767, 0.95063, -0.24717);\n            break;\n        case 315:\n            cam_pos = vec3(-1.65443, 1.35232, 1.94783);\n            cam_up_vec = vec3(0.18484, 0.94971, -0.25276);\n            break;\n        case 316:\n            cam_pos = vec3(-1.61118, 1.34504, 1.97125);\n            cam_up_vec = vec3(0.18198, 0.94881, -0.25814);\n            break;\n        case 317:\n            cam_pos = vec3(-1.56912, 1.33805, 1.99293);\n            cam_up_vec = vec3(0.17910, 0.94795, -0.26329);\n            break;\n        case 318:\n            cam_pos = vec3(-1.52825, 1.33135, 2.01297);\n            cam_up_vec = vec3(0.17621, 0.94711, -0.26822);\n            break;\n        case 319:\n            cam_pos = vec3(-1.48856, 1.32493, 2.03151);\n            cam_up_vec = vec3(0.17332, 0.94629, -0.27295);\n            break;\n        case 320:\n            cam_pos = vec3(-1.45003, 1.31876, 2.04863);\n            cam_up_vec = vec3(0.17043, 0.94549, -0.27748);\n            break;\n        case 321:\n            cam_pos = vec3(-1.41263, 1.31284, 2.06445);\n            cam_up_vec = vec3(0.16756, 0.94472, -0.28182);\n            break;\n        case 322:\n            cam_pos = vec3(-1.37633, 1.30714, 2.07907);\n            cam_up_vec = vec3(0.16470, 0.94398, -0.28598);\n            break;\n        case 323:\n            cam_pos = vec3(-1.34110, 1.30167, 2.09258);\n            cam_up_vec = vec3(0.16186, 0.94325, -0.28996);\n            break;\n        case 324:\n            cam_pos = vec3(-1.30688, 1.29639, 2.10505);\n            cam_up_vec = vec3(0.15904, 0.94255, -0.29379);\n            break;\n        case 325:\n            cam_pos = vec3(-1.27365, 1.29131, 2.11658);\n            cam_up_vec = vec3(0.15625, 0.94186, -0.29747);\n            break;\n        case 326:\n            cam_pos = vec3(-1.24137, 1.28640, 2.12724);\n            cam_up_vec = vec3(0.15349, 0.94119, -0.30099);\n            break;\n        case 327:\n            cam_pos = vec3(-1.21000, 1.28166, 2.13708);\n            cam_up_vec = vec3(0.15075, 0.94054, -0.30439);\n            break;\n        case 328:\n            cam_pos = vec3(-1.17950, 1.27707, 2.14618);\n            cam_up_vec = vec3(0.14805, 0.93991, -0.30765);\n            break;\n        case 329:\n            cam_pos = vec3(-1.14984, 1.27263, 2.15459);\n            cam_up_vec = vec3(0.14538, 0.93930, -0.31078);\n            break;\n        case 330:\n            cam_pos = vec3(-1.12098, 1.26832, 2.16236);\n            cam_up_vec = vec3(0.14274, 0.93870, -0.31381);\n            break;\n        case 331:\n            cam_pos = vec3(-1.09290, 1.26414, 2.16955);\n            cam_up_vec = vec3(0.14013, 0.93811, -0.31671);\n            break;\n        case 332:\n            cam_pos = vec3(-1.06556, 1.26008, 2.17619);\n            cam_up_vec = vec3(0.13755, 0.93754, -0.31952);\n            break;\n        case 333:\n            cam_pos = vec3(-1.03892, 1.25614, 2.18232);\n            cam_up_vec = vec3(0.13501, 0.93699, -0.32222);\n            break;\n        case 334:\n            cam_pos = vec3(-1.01298, 1.25229, 2.18799);\n            cam_up_vec = vec3(0.13250, 0.93644, -0.32483);\n            break;\n        case 335:\n            cam_pos = vec3(-0.98768, 1.24854, 2.19323);\n            cam_up_vec = vec3(0.13002, 0.93591, -0.32735);\n            break;\n        case 336:\n            cam_pos = vec3(-0.96303, 1.24488, 2.19808);\n            cam_up_vec = vec3(0.12758, 0.93540, -0.32978);\n            break;\n        case 337:\n            cam_pos = vec3(-0.93898, 1.24130, 2.20256);\n            cam_up_vec = vec3(0.12517, 0.93489, -0.33213);\n            break;\n        case 338:\n            cam_pos = vec3(-0.91551, 1.23780, 2.20669);\n            cam_up_vec = vec3(0.12279, 0.93440, -0.33441);\n            break;\n        case 339:\n            cam_pos = vec3(-0.89261, 1.23437, 2.21052);\n            cam_up_vec = vec3(0.12044, 0.93391, -0.33660);\n            break;\n        case 340:\n            cam_pos = vec3(-0.87025, 1.23101, 2.21406);\n            cam_up_vec = vec3(0.11813, 0.93344, -0.33873);\n            break;\n        case 341:\n            cam_pos = vec3(-0.84841, 1.22770, 2.21733);\n            cam_up_vec = vec3(0.11584, 0.93298, -0.34078);\n            break;\n        case 342:\n            cam_pos = vec3(-0.82708, 1.22446, 2.22037);\n            cam_up_vec = vec3(0.11359, 0.93252, -0.34278);\n            break;\n        case 343:\n            cam_pos = vec3(-0.80624, 1.22126, 2.22318);\n            cam_up_vec = vec3(0.11137, 0.93208, -0.34471);\n            break;\n        case 344:\n            cam_pos = vec3(-0.78587, 1.21812, 2.22578);\n            cam_up_vec = vec3(0.10918, 0.93165, -0.34658);\n            break;\n        case 345:\n            cam_pos = vec3(-0.76596, 1.21501, 2.22820);\n            cam_up_vec = vec3(0.10702, 0.93122, -0.34839);\n            break;\n        case 346:\n            cam_pos = vec3(-0.74648, 1.21195, 2.23046);\n            cam_up_vec = vec3(0.10489, 0.93080, -0.35015);\n            break;\n        case 347:\n            cam_pos = vec3(-0.72743, 1.20892, 2.23256);\n            cam_up_vec = vec3(0.10279, 0.93040, -0.35185);\n            break;\n        case 348:\n            cam_pos = vec3(-0.70879, 1.20592, 2.23452);\n            cam_up_vec = vec3(0.10072, 0.92999, -0.35350);\n            break;\n        case 349:\n            cam_pos = vec3(-0.69055, 1.20294, 2.23636);\n            cam_up_vec = vec3(0.09868, 0.92960, -0.35511);\n            break;\n        case 350:\n            cam_pos = vec3(-0.67270, 1.19999, 2.23810);\n            cam_up_vec = vec3(0.09667, 0.92922, -0.35667);\n            break;\n        case 351:\n            cam_pos = vec3(-0.65522, 1.19706, 2.23974);\n            cam_up_vec = vec3(0.09468, 0.92884, -0.35818);\n            break;\n        case 352:\n            cam_pos = vec3(-0.63810, 1.19415, 2.24130);\n            cam_up_vec = vec3(0.09273, 0.92847, -0.35965);\n            break;\n        case 353:\n            cam_pos = vec3(-0.62133, 1.19125, 2.24279);\n            cam_up_vec = vec3(0.09080, 0.92810, -0.36108);\n            break;\n        case 354:\n            cam_pos = vec3(-0.60491, 1.18836, 2.24422);\n            cam_up_vec = vec3(0.08889, 0.92775, -0.36247);\n            break;\n        case 355:\n            cam_pos = vec3(-0.58881, 1.18547, 2.24561);\n            cam_up_vec = vec3(0.08702, 0.92740, -0.36382);\n            break;\n        case 356:\n            cam_pos = vec3(-0.57304, 1.18259, 2.24696);\n            cam_up_vec = vec3(0.08516, 0.92705, -0.36513);\n            break;\n        case 357:\n            cam_pos = vec3(-0.55758, 1.17970, 2.24829);\n            cam_up_vec = vec3(0.08334, 0.92672, -0.36641);\n            break;\n        case 358:\n            cam_pos = vec3(-0.54243, 1.17682, 2.24960);\n            cam_up_vec = vec3(0.08154, 0.92638, -0.36765);\n            break;\n        case 359:\n            cam_pos = vec3(-0.52757, 1.17392, 2.25091);\n            cam_up_vec = vec3(0.07977, 0.92606, -0.36886);\n            break;\n        case 360:\n            cam_pos = vec3(-0.51299, 1.17102, 2.25223);\n            cam_up_vec = vec3(0.07802, 0.92574, -0.37003);\n            break;\n        case 361:\n            cam_pos = vec3(-0.49870, 1.16810, 2.25356);\n            cam_up_vec = vec3(0.07629, 0.92542, -0.37118);\n            break;\n        case 362:\n            cam_pos = vec3(-0.48467, 1.16516, 2.25492);\n            cam_up_vec = vec3(0.07459, 0.92511, -0.37229);\n            break;\n        case 363:\n            cam_pos = vec3(-0.47091, 1.16221, 2.25632);\n            cam_up_vec = vec3(0.07291, 0.92481, -0.37338);\n            break;\n        case 364:\n            cam_pos = vec3(-0.45741, 1.15923, 2.25776);\n            cam_up_vec = vec3(0.07126, 0.92451, -0.37443);\n            break;\n        case 365:\n            cam_pos = vec3(-0.44416, 1.15622, 2.25926);\n            cam_up_vec = vec3(0.06963, 0.92422, -0.37546);\n            break;\n        case 366:\n            cam_pos = vec3(-0.43115, 1.15319, 2.26083);\n            cam_up_vec = vec3(0.06802, 0.92393, -0.37647);\n            break;\n        case 367:\n            cam_pos = vec3(-0.41838, 1.15012, 2.26246);\n            cam_up_vec = vec3(0.06644, 0.92365, -0.37744);\n            break;\n        case 368:\n            cam_pos = vec3(-0.40584, 1.14701, 2.26418);\n            cam_up_vec = vec3(0.06487, 0.92337, -0.37840);\n            break;\n        case 369:\n            cam_pos = vec3(-0.39353, 1.14386, 2.26600);\n            cam_up_vec = vec3(0.06333, 0.92309, -0.37933);\n            break;\n        case 370:\n            cam_pos = vec3(-0.38143, 1.14067, 2.26791);\n            cam_up_vec = vec3(0.06181, 0.92282, -0.38023);\n            break;\n        case 371:\n            cam_pos = vec3(-0.36956, 1.13743, 2.26994);\n            cam_up_vec = vec3(0.06031, 0.92256, -0.38111);\n            break;\n        case 372:\n            cam_pos = vec3(-0.35789, 1.13414, 2.27209);\n            cam_up_vec = vec3(0.05883, 0.92230, -0.38198);\n            break;\n        case 373:\n            cam_pos = vec3(-0.34642, 1.13079, 2.27437);\n            cam_up_vec = vec3(0.05737, 0.92204, -0.38282);\n            break;\n        case 374:\n            cam_pos = vec3(-0.33516, 1.12738, 2.27680);\n            cam_up_vec = vec3(0.05594, 0.92179, -0.38363);\n            break;\n        case 375:\n            cam_pos = vec3(-0.32408, 1.12391, 2.27938);\n            cam_up_vec = vec3(0.05452, 0.92154, -0.38443);\n            break;\n        case 376:\n            cam_pos = vec3(-0.31320, 1.12037, 2.28212);\n            cam_up_vec = vec3(0.05312, 0.92130, -0.38521);\n            break;\n        case 377:\n            cam_pos = vec3(-0.30251, 1.11676, 2.28503);\n            cam_up_vec = vec3(0.05174, 0.92106, -0.38598);\n            break;\n        case 378:\n            cam_pos = vec3(-0.29199, 1.11307, 2.28813);\n            cam_up_vec = vec3(0.05039, 0.92082, -0.38672);\n            break;\n        case 379:\n            cam_pos = vec3(-0.28165, 1.10929, 2.29142);\n            cam_up_vec = vec3(0.04905, 0.92059, -0.38744);\n            break;\n        case 380:\n            cam_pos = vec3(-0.27148, 1.10543, 2.29493);\n            cam_up_vec = vec3(0.04773, 0.92036, -0.38815);\n            break;\n        case 381:\n            cam_pos = vec3(-0.26148, 1.10148, 2.29865);\n            cam_up_vec = vec3(0.04642, 0.92013, -0.38884);\n            break;\n        case 382:\n            cam_pos = vec3(-0.25165, 1.09743, 2.30261);\n            cam_up_vec = vec3(0.04514, 0.91991, -0.38952);\n            break;\n        case 383:\n            cam_pos = vec3(-0.24197, 1.09327, 2.30681);\n            cam_up_vec = vec3(0.04387, 0.91969, -0.39018);\n            break;\n        case 384:\n            cam_pos = vec3(-0.23245, 1.08901, 2.31126);\n            cam_up_vec = vec3(0.04263, 0.91948, -0.39082);\n            break;\n        case 385:\n            cam_pos = vec3(-0.22309, 1.08463, 2.31600);\n            cam_up_vec = vec3(0.04140, 0.91927, -0.39145);\n            break;\n        case 386:\n            cam_pos = vec3(-0.21387, 1.08014, 2.32101);\n            cam_up_vec = vec3(0.04018, 0.91906, -0.39206);\n            break;\n        case 387:\n            cam_pos = vec3(-0.20480, 1.07551, 2.32633);\n            cam_up_vec = vec3(0.03899, 0.91886, -0.39266);\n            break;\n        case 388:\n            cam_pos = vec3(-0.19587, 1.07075, 2.33196);\n            cam_up_vec = vec3(0.03781, 0.91866, -0.39325);\n            break;\n        case 389:\n            cam_pos = vec3(-0.18708, 1.06585, 2.33793);\n            cam_up_vec = vec3(0.03665, 0.91846, -0.39382);\n            break;\n        case 390:\n            cam_pos = vec3(-0.17842, 1.06080, 2.34424);\n            cam_up_vec = vec3(0.03550, 0.91826, -0.39438);\n            break;\n        case 391:\n            cam_pos = vec3(-0.16989, 1.05559, 2.35091);\n            cam_up_vec = vec3(0.03437, 0.91807, -0.39492);\n            break;\n        case 392:\n            cam_pos = vec3(-0.16149, 1.05023, 2.35796);\n            cam_up_vec = vec3(0.03326, 0.91788, -0.39546);\n            break;\n        case 393:\n            cam_pos = vec3(-0.15322, 1.04469, 2.36541);\n            cam_up_vec = vec3(0.03217, 0.91770, -0.39598);\n            break;\n        case 394:\n            cam_pos = vec3(-0.14507, 1.03898, 2.37327);\n            cam_up_vec = vec3(0.03108, 0.91751, -0.39649);\n            break;\n        case 395:\n            cam_pos = vec3(-0.13703, 1.03308, 2.38156);\n            cam_up_vec = vec3(0.03002, 0.91733, -0.39699);\n            break;\n        case 396:\n            cam_pos = vec3(-0.12911, 1.02698, 2.39029);\n            cam_up_vec = vec3(0.02897, 0.91716, -0.39748);\n            break;\n        case 397:\n            cam_pos = vec3(-0.12130, 1.02069, 2.39949);\n            cam_up_vec = vec3(0.02793, 0.91698, -0.39795);\n            break;\n        case 398:\n            cam_pos = vec3(-0.11359, 1.01419, 2.40917);\n            cam_up_vec = vec3(0.02692, 0.91681, -0.39842);\n            break;\n        case 399:\n            cam_pos = vec3(-0.10599, 1.00748, 2.41934);\n            cam_up_vec = vec3(0.02591, 0.91664, -0.39887);\n            break;\n        case 400:\n            cam_pos = vec3(-0.09849, 1.00055, 2.43001);\n            cam_up_vec = vec3(0.02492, 0.91647, -0.39932);\n            break;\n        case 401:\n            cam_pos = vec3(-0.09109, 0.99339, 2.44120);\n            cam_up_vec = vec3(0.02395, 0.91631, -0.39975);\n            break;\n        case 402:\n            cam_pos = vec3(-0.08377, 0.98600, 2.45291);\n            cam_up_vec = vec3(0.02298, 0.91615, -0.40018);\n            break;\n        case 403:\n            cam_pos = vec3(-0.07655, 0.97838, 2.46515);\n            cam_up_vec = vec3(0.02204, 0.91599, -0.40059);\n            break;\n        case 404:\n            cam_pos = vec3(-0.06941, 0.97053, 2.47792);\n            cam_up_vec = vec3(0.02110, 0.91583, -0.40100);\n            break;\n        case 405:\n            cam_pos = vec3(-0.06234, 0.96245, 2.49121);\n            cam_up_vec = vec3(0.02019, 0.91568, -0.40140);\n            break;\n        case 406:\n            cam_pos = vec3(-0.05536, 0.95415, 2.50503);\n            cam_up_vec = vec3(0.01928, 0.91553, -0.40179);\n            break;\n        case 407:\n            cam_pos = vec3(-0.04844, 0.94562, 2.51934);\n            cam_up_vec = vec3(0.01839, 0.91538, -0.40217);\n            break;\n        case 408:\n            cam_pos = vec3(-0.04159, 0.93688, 2.53413);\n            cam_up_vec = vec3(0.01751, 0.91524, -0.40254);\n            break;\n        case 409:\n            cam_pos = vec3(-0.03481, 0.92794, 2.54936);\n            cam_up_vec = vec3(0.01665, 0.91509, -0.40290);\n            break;\n        case 410:\n            cam_pos = vec3(-0.02808, 0.91883, 2.56500);\n            cam_up_vec = vec3(0.01579, 0.91495, -0.40326);\n            break;\n        case 411:\n            cam_pos = vec3(-0.02140, 0.90955, 2.58101);\n            cam_up_vec = vec3(0.01495, 0.91481, -0.40361);\n            break;\n        case 412:\n            cam_pos = vec3(-0.01478, 0.90014, 2.59731);\n            cam_up_vec = vec3(0.01413, 0.91467, -0.40395);\n            break;\n        case 413:\n            cam_pos = vec3(-0.00820, 0.89063, 2.61385);\n            cam_up_vec = vec3(0.01332, 0.91454, -0.40428);\n            break;\n        case 414:\n            cam_pos = vec3(-0.00167, 0.88103, 2.63057);\n            cam_up_vec = vec3(0.01252, 0.91441, -0.40461);\n            break;\n        case 415:\n            cam_pos = vec3(0.00483, 0.87140, 2.64739);\n            cam_up_vec = vec3(0.01173, 0.91428, -0.40492);\n            break;\n        case 416:\n            cam_pos = vec3(0.01128, 0.86175, 2.66422);\n            cam_up_vec = vec3(0.01095, 0.91415, -0.40523);\n            break;\n        case 417:\n            cam_pos = vec3(0.01770, 0.85213, 2.68100);\n            cam_up_vec = vec3(0.01019, 0.91402, -0.40554);\n            break;\n        case 418:\n            cam_pos = vec3(0.02409, 0.84257, 2.69765);\n            cam_up_vec = vec3(0.00944, 0.91390, -0.40584);\n            break;\n        case 419:\n            cam_pos = vec3(0.03044, 0.83310, 2.71410);\n            cam_up_vec = vec3(0.00870, 0.91377, -0.40613);\n            break;\n        case 420:\n            cam_pos = vec3(0.03675, 0.82376, 2.73027);\n            cam_up_vec = vec3(0.00797, 0.91365, -0.40641);\n            break;\n        case 421:\n            cam_pos = vec3(0.04303, 0.81456, 2.74611);\n            cam_up_vec = vec3(0.00725, 0.91354, -0.40669);\n            break;\n        case 422:\n            cam_pos = vec3(0.04928, 0.80554, 2.76157);\n            cam_up_vec = vec3(0.00655, 0.91342, -0.40696);\n            break;\n        case 423:\n            cam_pos = vec3(0.05548, 0.79671, 2.77660);\n            cam_up_vec = vec3(0.00585, 0.91331, -0.40723);\n            break;\n        case 424:\n            cam_pos = vec3(0.06164, 0.78809, 2.79116);\n            cam_up_vec = vec3(0.00517, 0.91319, -0.40749);\n            break;\n        case 425:\n            cam_pos = vec3(0.06776, 0.77970, 2.80523);\n            cam_up_vec = vec3(0.00450, 0.91308, -0.40775);\n            break;\n        case 426:\n            cam_pos = vec3(0.07384, 0.77155, 2.81878);\n            cam_up_vec = vec3(0.00384, 0.91298, -0.40800);\n            break;\n        case 427:\n            cam_pos = vec3(0.07987, 0.76363, 2.83180);\n            cam_up_vec = vec3(0.00319, 0.91287, -0.40824);\n            break;\n        case 428:\n            cam_pos = vec3(0.08584, 0.75597, 2.84428);\n            cam_up_vec = vec3(0.00255, 0.91276, -0.40848);\n            break;\n        case 429:\n            cam_pos = vec3(0.09177, 0.74855, 2.85622);\n            cam_up_vec = vec3(0.00193, 0.91266, -0.40871);\n            break;\n        case 430:\n            cam_pos = vec3(0.09764, 0.74138, 2.86762);\n            cam_up_vec = vec3(0.00131, 0.91256, -0.40894);\n            break;\n        case 431:\n            cam_pos = vec3(0.10345, 0.73446, 2.87848);\n            cam_up_vec = vec3(0.00070, 0.91246, -0.40916);\n            break;\n        case 432:\n            cam_pos = vec3(0.10920, 0.72778, 2.88882);\n            cam_up_vec = vec3(0.00011, 0.91236, -0.40938);\n            break;\n        case 433:\n            cam_pos = vec3(0.11489, 0.72134, 2.89864);\n            cam_up_vec = vec3(-0.00048, 0.91227, -0.40959);\n            break;\n        case 434:\n            cam_pos = vec3(0.12051, 0.71514, 2.90796);\n            cam_up_vec = vec3(-0.00105, 0.91217, -0.40980);\n            break;\n        case 435:\n            cam_pos = vec3(0.12607, 0.70916, 2.91678);\n            cam_up_vec = vec3(-0.00162, 0.91208, -0.41001);\n            break;\n        case 436:\n            cam_pos = vec3(0.13156, 0.70341, 2.92513);\n            cam_up_vec = vec3(-0.00217, 0.91199, -0.41020);\n            break;\n        case 437:\n            cam_pos = vec3(0.13698, 0.69788, 2.93303);\n            cam_up_vec = vec3(-0.00272, 0.91190, -0.41040);\n            break;\n        case 438:\n            cam_pos = vec3(0.14233, 0.69256, 2.94047);\n            cam_up_vec = vec3(-0.00325, 0.91181, -0.41059);\n            break;\n        case 439:\n            cam_pos = vec3(0.14761, 0.68744, 2.94748);\n            cam_up_vec = vec3(-0.00378, 0.91173, -0.41077);\n            break;\n        case 440:\n            cam_pos = vec3(0.15281, 0.68252, 2.95408);\n            cam_up_vec = vec3(-0.00429, 0.91164, -0.41096);\n            break;\n        case 441:\n            cam_pos = vec3(0.15794, 0.67779, 2.96028);\n            cam_up_vec = vec3(-0.00480, 0.91156, -0.41113);\n            break;\n        case 442:\n            cam_pos = vec3(0.16299, 0.67324, 2.96610);\n            cam_up_vec = vec3(-0.00529, 0.91148, -0.41131);\n            break;\n        case 443:\n            cam_pos = vec3(0.16797, 0.66888, 2.97155);\n            cam_up_vec = vec3(-0.00578, 0.91140, -0.41148);\n            break;\n        case 444:\n            cam_pos = vec3(0.17287, 0.66468, 2.97664);\n            cam_up_vec = vec3(-0.00626, 0.91132, -0.41164);\n            break;\n        case 445:\n            cam_pos = vec3(0.17769, 0.66066, 2.98139);\n            cam_up_vec = vec3(-0.00673, 0.91125, -0.41180);\n            break;\n        case 446:\n            cam_pos = vec3(0.18243, 0.65679, 2.98581);\n            cam_up_vec = vec3(-0.00719, 0.91117, -0.41196);\n            break;\n        case 447:\n            cam_pos = vec3(0.18710, 0.65308, 2.98992);\n            cam_up_vec = vec3(-0.00764, 0.91110, -0.41211);\n            break;\n        case 448:\n            cam_pos = vec3(0.19168, 0.64952, 2.99372);\n            cam_up_vec = vec3(-0.00808, 0.91103, -0.41226);\n            break;\n        case 449:\n            cam_pos = vec3(0.19619, 0.64610, 2.99723);\n            cam_up_vec = vec3(-0.00851, 0.91096, -0.41241);\n            break;\n        case 450:\n            cam_pos = vec3(0.20062, 0.64283, 3.00046);\n            cam_up_vec = vec3(-0.00894, 0.91089, -0.41255);\n            break;\n        case 451:\n            cam_pos = vec3(0.20496, 0.63969, 3.00342);\n            cam_up_vec = vec3(-0.00935, 0.91082, -0.41269);\n            break;\n        case 452:\n            cam_pos = vec3(0.20923, 0.63668, 3.00612);\n            cam_up_vec = vec3(-0.00976, 0.91076, -0.41283);\n            break;\n        case 453:\n            cam_pos = vec3(0.21341, 0.63380, 3.00857);\n            cam_up_vec = vec3(-0.01016, 0.91069, -0.41296);\n            break;\n        case 454:\n            cam_pos = vec3(0.21752, 0.63104, 3.01077);\n            cam_up_vec = vec3(-0.01055, 0.91063, -0.41309);\n            break;\n        case 455:\n            cam_pos = vec3(0.22154, 0.62840, 3.01275);\n            cam_up_vec = vec3(-0.01093, 0.91057, -0.41322);\n            break;\n        case 456:\n            cam_pos = vec3(0.22549, 0.62587, 3.01450);\n            cam_up_vec = vec3(-0.01130, 0.91051, -0.41334);\n            break;\n        case 457:\n            cam_pos = vec3(0.22936, 0.62346, 3.01604);\n            cam_up_vec = vec3(-0.01166, 0.91045, -0.41346);\n            break;\n        case 458:\n            cam_pos = vec3(0.23314, 0.62116, 3.01737);\n            cam_up_vec = vec3(-0.01202, 0.91039, -0.41358);\n            break;\n        case 459:\n            cam_pos = vec3(0.23685, 0.61896, 3.01850);\n            cam_up_vec = vec3(-0.01237, 0.91033, -0.41369);\n            break;\n        case 460:\n            cam_pos = vec3(0.24047, 0.61686, 3.01944);\n            cam_up_vec = vec3(-0.01271, 0.91028, -0.41380);\n            break;\n        case 461:\n            cam_pos = vec3(0.24402, 0.61486, 3.02019);\n            cam_up_vec = vec3(-0.01304, 0.91022, -0.41391);\n            break;\n        case 462:\n            cam_pos = vec3(0.24749, 0.61296, 3.02076);\n            cam_up_vec = vec3(-0.01336, 0.91017, -0.41402);\n            break;\n        case 463:\n            cam_pos = vec3(0.25088, 0.61115, 3.02116);\n            cam_up_vec = vec3(-0.01368, 0.91012, -0.41412);\n            break;\n        case 464:\n            cam_pos = vec3(0.25419, 0.60943, 3.02139);\n            cam_up_vec = vec3(-0.01399, 0.91007, -0.41422);\n            break;\n        case 465:\n            cam_pos = vec3(0.25742, 0.60780, 3.02146);\n            cam_up_vec = vec3(-0.01429, 0.91002, -0.41431);\n            break;\n        case 466:\n            cam_pos = vec3(0.26058, 0.60626, 3.02137);\n            cam_up_vec = vec3(-0.01458, 0.90997, -0.41441);\n            break;\n        case 467:\n            cam_pos = vec3(0.26366, 0.60480, 3.02113);\n            cam_up_vec = vec3(-0.01487, 0.90993, -0.41450);\n            break;\n        case 468:\n            cam_pos = vec3(0.26666, 0.60342, 3.02074);\n            cam_up_vec = vec3(-0.01515, 0.90988, -0.41459);\n            break;\n        case 469:\n            cam_pos = vec3(0.26958, 0.60212, 3.02021);\n            cam_up_vec = vec3(-0.01542, 0.90984, -0.41467);\n            break;\n        case 470:\n            cam_pos = vec3(0.27243, 0.60089, 3.01954);\n            cam_up_vec = vec3(-0.01568, 0.90980, -0.41476);\n            break;\n        case 471:\n            cam_pos = vec3(0.27520, 0.59975, 3.01874);\n            cam_up_vec = vec3(-0.01594, 0.90976, -0.41484);\n            break;\n        case 472:\n            cam_pos = vec3(0.27789, 0.59867, 3.01781);\n            cam_up_vec = vec3(-0.01619, 0.90971, -0.41492);\n            break;\n        case 473:\n            cam_pos = vec3(0.28051, 0.59767, 3.01675);\n            cam_up_vec = vec3(-0.01643, 0.90968, -0.41499);\n            break;\n        case 474:\n            cam_pos = vec3(0.28306, 0.59674, 3.01558);\n            cam_up_vec = vec3(-0.01666, 0.90964, -0.41507);\n            break;\n        case 475:\n            cam_pos = vec3(0.28553, 0.59588, 3.01428);\n            cam_up_vec = vec3(-0.01689, 0.90960, -0.41514);\n            break;\n        case 476:\n            cam_pos = vec3(0.28792, 0.59508, 3.01287);\n            cam_up_vec = vec3(-0.01711, 0.90957, -0.41521);\n            break;\n        case 477:\n            cam_pos = vec3(0.29025, 0.59435, 3.01135);\n            cam_up_vec = vec3(-0.01733, 0.90953, -0.41527);\n            break;\n        case 478:\n            cam_pos = vec3(0.29250, 0.59368, 3.00972);\n            cam_up_vec = vec3(-0.01753, 0.90950, -0.41534);\n            break;\n        case 479:\n            cam_pos = vec3(0.29467, 0.59308, 3.00798);\n            cam_up_vec = vec3(-0.01773, 0.90947, -0.41540);\n            break;\n        case 480:\n            cam_pos = vec3(0.29678, 0.59253, 3.00615);\n            cam_up_vec = vec3(-0.01793, 0.90943, -0.41546);\n            break;\n        case 481:\n            cam_pos = vec3(0.29881, 0.59205, 3.00421);\n            cam_up_vec = vec3(-0.01811, 0.90940, -0.41552);\n            break;\n        case 482:\n            cam_pos = vec3(0.30077, 0.59162, 3.00218);\n            cam_up_vec = vec3(-0.01829, 0.90938, -0.41557);\n            break;\n        case 483:\n            cam_pos = vec3(0.30266, 0.59125, 3.00006);\n            cam_up_vec = vec3(-0.01847, 0.90935, -0.41563);\n            break;\n        case 484:\n            cam_pos = vec3(0.30448, 0.59094, 2.99784);\n            cam_up_vec = vec3(-0.01863, 0.90932, -0.41568);\n            break;\n        case 485:\n            cam_pos = vec3(0.30623, 0.59068, 2.99554);\n            cam_up_vec = vec3(-0.01879, 0.90929, -0.41573);\n            break;\n        case 486:\n            cam_pos = vec3(0.30791, 0.59047, 2.99314);\n            cam_up_vec = vec3(-0.01895, 0.90927, -0.41578);\n            break;\n        case 487:\n            cam_pos = vec3(0.30952, 0.59032, 2.99067);\n            cam_up_vec = vec3(-0.01909, 0.90925, -0.41582);\n            break;\n        case 488:\n            cam_pos = vec3(0.31107, 0.59022, 2.98811);\n            cam_up_vec = vec3(-0.01923, 0.90922, -0.41586);\n            break;\n        case 489:\n            cam_pos = vec3(0.31254, 0.59017, 2.98547);\n            cam_up_vec = vec3(-0.01937, 0.90920, -0.41590);\n            break;\n        case 490:\n            cam_pos = vec3(0.31395, 0.59016, 2.98276);\n            cam_up_vec = vec3(-0.01950, 0.90918, -0.41594);\n            break;\n        case 491:\n            cam_pos = vec3(0.31529, 0.59021, 2.97997);\n            cam_up_vec = vec3(-0.01962, 0.90916, -0.41598);\n            break;\n        case 492:\n            cam_pos = vec3(0.31656, 0.59031, 2.97710);\n            cam_up_vec = vec3(-0.01973, 0.90914, -0.41602);\n            break;\n        case 493:\n            cam_pos = vec3(0.31776, 0.59045, 2.97416);\n            cam_up_vec = vec3(-0.01984, 0.90913, -0.41605);\n            break;\n        case 494:\n            cam_pos = vec3(0.31890, 0.59064, 2.97116);\n            cam_up_vec = vec3(-0.01995, 0.90911, -0.41608);\n            break;\n        case 495:\n            cam_pos = vec3(0.31998, 0.59087, 2.96808);\n            cam_up_vec = vec3(-0.02005, 0.90909, -0.41611);\n            break;\n        case 496:\n            cam_pos = vec3(0.32099, 0.59115, 2.96494);\n            cam_up_vec = vec3(-0.02014, 0.90908, -0.41614);\n            break;\n        case 497:\n            cam_pos = vec3(0.32193, 0.59147, 2.96173);\n            cam_up_vec = vec3(-0.02022, 0.90906, -0.41617);\n            break;\n        case 498:\n            cam_pos = vec3(0.32281, 0.59183, 2.95845);\n            cam_up_vec = vec3(-0.02030, 0.90905, -0.41619);\n            break;\n        case 499:\n            cam_pos = vec3(0.32363, 0.59223, 2.95512);\n            cam_up_vec = vec3(-0.02038, 0.90904, -0.41621);\n            break;\n        case 500:\n            cam_pos = vec3(0.32438, 0.59268, 2.95172);\n            cam_up_vec = vec3(-0.02045, 0.90903, -0.41623);\n            break;\n        case 501:\n            cam_pos = vec3(0.32507, 0.59317, 2.94827);\n            cam_up_vec = vec3(-0.02051, 0.90902, -0.41625);\n            break;\n        case 502:\n            cam_pos = vec3(0.32570, 0.59369, 2.94475);\n            cam_up_vec = vec3(-0.02057, 0.90901, -0.41627);\n            break;\n        case 503:\n            cam_pos = vec3(0.32626, 0.59426, 2.94118);\n            cam_up_vec = vec3(-0.02062, 0.90900, -0.41628);\n            break;\n        case 504:\n            cam_pos = vec3(0.32677, 0.59487, 2.93755);\n            cam_up_vec = vec3(-0.02066, 0.90899, -0.41630);\n            break;\n        case 505:\n            cam_pos = vec3(0.32721, 0.59551, 2.93387);\n            cam_up_vec = vec3(-0.02070, 0.90899, -0.41631);\n            break;\n        case 506:\n            cam_pos = vec3(0.32759, 0.59619, 2.93013);\n            cam_up_vec = vec3(-0.02074, 0.90898, -0.41632);\n            break;\n        case 507:\n            cam_pos = vec3(0.32791, 0.59691, 2.92634);\n            cam_up_vec = vec3(-0.02077, 0.90898, -0.41633);\n            break;\n        case 508:\n            cam_pos = vec3(0.32817, 0.59766, 2.92250);\n            cam_up_vec = vec3(-0.02079, 0.90897, -0.41634);\n            break;\n        case 509:\n            cam_pos = vec3(0.32838, 0.59845, 2.91861);\n            cam_up_vec = vec3(-0.02081, 0.90897, -0.41634);\n            break;\n        case 510:\n            cam_pos = vec3(0.32852, 0.59927, 2.91467);\n            cam_up_vec = vec3(-0.02082, 0.90897, -0.41635);\n            break;\n        case 511:\n            cam_pos = vec3(0.32861, 0.60013, 2.91069);\n            cam_up_vec = vec3(-0.02083, 0.90897, -0.41635);\n            break;\n        case 512:\n            cam_pos = vec3(0.32863, 0.60102, 2.90665);\n            cam_up_vec = vec3(-0.02083, 0.90897, -0.41635);\n            break;\n        case 513:\n            cam_pos = vec3(1.47811, 2.15372, 2.16790);\n            cam_up_vec = vec3(-0.02224, 0.99874, -0.03519);\n            break;\n        case 514:\n            cam_pos = vec3(1.48885, 2.15978, 2.16076);\n            cam_up_vec = vec3(-0.02275, 0.99917, -0.03381);\n            break;\n        case 515:\n            cam_pos = vec3(1.49368, 2.15782, 2.15741);\n            cam_up_vec = vec3(-0.02326, 0.99914, -0.03440);\n            break;\n        case 516:\n            cam_pos = vec3(1.49850, 2.15586, 2.15404);\n            cam_up_vec = vec3(-0.02377, 0.99911, -0.03498);\n            break;\n        case 517:\n            cam_pos = vec3(1.50331, 2.15390, 2.15066);\n            cam_up_vec = vec3(-0.02429, 0.99907, -0.03556);\n            break;\n        case 518:\n            cam_pos = vec3(1.50812, 2.15194, 2.14727);\n            cam_up_vec = vec3(-0.02480, 0.99904, -0.03614);\n            break;\n        case 519:\n            cam_pos = vec3(1.51291, 2.14998, 2.14387);\n            cam_up_vec = vec3(-0.02532, 0.99901, -0.03671);\n            break;\n        case 520:\n            cam_pos = vec3(1.51769, 2.14802, 2.14045);\n            cam_up_vec = vec3(-0.02584, 0.99897, -0.03728);\n            break;\n        case 521:\n            cam_pos = vec3(1.52247, 2.14606, 2.13702);\n            cam_up_vec = vec3(-0.02637, 0.99894, -0.03785);\n            break;\n        case 522:\n            cam_pos = vec3(1.52724, 2.14410, 2.13358);\n            cam_up_vec = vec3(-0.02690, 0.99890, -0.03842);\n            break;\n        case 523:\n            cam_pos = vec3(1.53200, 2.14214, 2.13013);\n            cam_up_vec = vec3(-0.02743, 0.99886, -0.03899);\n            break;\n        case 524:\n            cam_pos = vec3(1.53674, 2.14018, 2.12667);\n            cam_up_vec = vec3(-0.02796, 0.99883, -0.03955);\n            break;\n        case 525:\n            cam_pos = vec3(1.54148, 2.13822, 2.12319);\n            cam_up_vec = vec3(-0.02850, 0.99879, -0.04011);\n            break;\n        case 526:\n            cam_pos = vec3(1.54622, 2.13626, 2.11970);\n            cam_up_vec = vec3(-0.02904, 0.99875, -0.04067);\n            break;\n        case 527:\n            cam_pos = vec3(-1.69579, 2.17056, 1.89713);\n            cam_up_vec = vec3(0.00800, 0.99994, -0.00592);\n            break;\n        case 528:\n            cam_pos = vec3(-1.74570, 2.16692, 1.90200);\n            cam_up_vec = vec3(0.00878, 0.99994, -0.00611);\n            break;\n        case 529:\n            cam_pos = vec3(-1.77869, 2.16304, 1.90790);\n            cam_up_vec = vec3(0.00938, 0.99993, -0.00648);\n            break;\n        case 530:\n            cam_pos = vec3(-1.81178, 2.15912, 1.91360);\n            cam_up_vec = vec3(0.00998, 0.99993, -0.00684);\n            break;\n        case 531:\n            cam_pos = vec3(-1.84497, 2.15515, 1.91911);\n            cam_up_vec = vec3(0.01058, 0.99992, -0.00720);\n            break;\n        case 532:\n            cam_pos = vec3(-1.87824, 2.15114, 1.92443);\n            cam_up_vec = vec3(0.01119, 0.99991, -0.00756);\n            break;\n        case 533:\n            cam_pos = vec3(-1.91161, 2.14708, 1.92956);\n            cam_up_vec = vec3(0.01180, 0.99990, -0.00791);\n            break;\n        case 534:\n            cam_pos = vec3(-1.94506, 2.14298, 1.93450);\n            cam_up_vec = vec3(0.01241, 0.99989, -0.00826);\n            break;\n        case 535:\n            cam_pos = vec3(-1.97861, 2.13884, 1.93924);\n            cam_up_vec = vec3(0.01302, 0.99988, -0.00861);\n            break;\n        case 536:\n            cam_pos = vec3(-2.01224, 2.13465, 1.94379);\n            cam_up_vec = vec3(0.01364, 0.99987, -0.00895);\n            break;\n        case 537:\n            cam_pos = vec3(-2.04597, 2.13041, 1.94814);\n            cam_up_vec = vec3(0.01425, 0.99986, -0.00929);\n            break;\n        case 538:\n            cam_pos = vec3(-2.07977, 2.12613, 1.95230);\n            cam_up_vec = vec3(0.01487, 0.99984, -0.00962);\n            break;\n        case 539:\n            cam_pos = vec3(-2.11367, 2.12181, 1.95627);\n            cam_up_vec = vec3(0.01550, 0.99983, -0.00995);\n            break;\n        case 540:\n            cam_pos = vec3(-2.14764, 2.11744, 1.96003);\n            cam_up_vec = vec3(0.01612, 0.99982, -0.01028);\n            break;\n        case 541:\n            cam_pos = vec3(-2.18170, 2.11303, 1.96361);\n            cam_up_vec = vec3(0.01675, 0.99980, -0.01060);\n            break;\n        case 542:\n            cam_pos = vec3(-2.21585, 2.10858, 1.96698);\n            cam_up_vec = vec3(0.01738, 0.99979, -0.01091);\n            break;\n        case 543:\n            cam_pos = vec3(-2.25007, 2.10408, 1.97016);\n            cam_up_vec = vec3(0.01801, 0.99977, -0.01123);\n            break;\n        case 544:\n            cam_pos = vec3(-2.28438, 2.09953, 1.97314);\n            cam_up_vec = vec3(0.01864, 0.99976, -0.01154);\n            break;\n        case 545:\n            cam_pos = vec3(-2.31876, 2.09494, 1.97593);\n            cam_up_vec = vec3(0.01928, 0.99974, -0.01184);\n            break;\n        case 546:\n            cam_pos = vec3(-2.35322, 2.09031, 1.97851);\n            cam_up_vec = vec3(0.01992, 0.99973, -0.01214);\n            break;\n        case 547:\n            cam_pos = vec3(-2.38776, 2.08564, 1.98090);\n            cam_up_vec = vec3(0.02056, 0.99971, -0.01244);\n            break;\n        case 548:\n            cam_pos = vec3(-2.42238, 2.08091, 1.98308);\n            cam_up_vec = vec3(0.02120, 0.99969, -0.01273);\n            break;\n        case 549:\n            cam_pos = vec3(-2.45707, 2.07615, 1.98507);\n            cam_up_vec = vec3(0.02185, 0.99968, -0.01302);\n            break;\n        case 550:\n            cam_pos = vec3(-2.49184, 2.07134, 1.98686);\n            cam_up_vec = vec3(0.02249, 0.99966, -0.01330);\n            break;\n        case 551:\n            cam_pos = vec3(-2.52667, 2.06648, 1.98844);\n            cam_up_vec = vec3(0.02314, 0.99964, -0.01358);\n            break;\n        case 552:\n            cam_pos = vec3(-2.56158, 2.06159, 1.98983);\n            cam_up_vec = vec3(0.02379, 0.99962, -0.01386);\n            break;\n        case 553:\n            cam_pos = vec3(-2.59657, 2.05664, 1.99101);\n            cam_up_vec = vec3(0.02445, 0.99960, -0.01413);\n            break;\n        case 554:\n            cam_pos = vec3(-2.63162, 2.05166, 1.99199);\n            cam_up_vec = vec3(0.02510, 0.99958, -0.01440);\n            break;\n        case 555:\n            cam_pos = vec3(-2.66674, 2.04663, 1.99277);\n            cam_up_vec = vec3(0.02576, 0.99956, -0.01466);\n            break;\n        case 556:\n            cam_pos = vec3(-2.70193, 2.04155, 1.99334);\n            cam_up_vec = vec3(0.02642, 0.99954, -0.01492);\n            break;\n        case 557:\n            cam_pos = vec3(-2.73719, 2.03643, 1.99372);\n            cam_up_vec = vec3(0.02708, 0.99952, -0.01518);\n            break;\n        case 558:\n            cam_pos = vec3(-2.77251, 2.03127, 1.99388);\n            cam_up_vec = vec3(0.02774, 0.99950, -0.01543);\n            break;\n        case 559:\n            cam_pos = vec3(-2.80790, 2.02606, 1.99385);\n            cam_up_vec = vec3(0.02841, 0.99947, -0.01567);\n            break;\n        case 560:\n            cam_pos = vec3(-2.84335, 2.02081, 1.99361);\n            cam_up_vec = vec3(0.02908, 0.99945, -0.01592);\n            break;\n        case 561:\n            cam_pos = vec3(-2.87886, 2.01551, 1.99316);\n            cam_up_vec = vec3(0.02975, 0.99943, -0.01615);\n            break;\n        case 562:\n            cam_pos = vec3(-2.91444, 2.01017, 1.99252);\n            cam_up_vec = vec3(0.03042, 0.99940, -0.01639);\n            break;\n        case 563:\n            cam_pos = vec3(-2.95008, 2.00479, 1.99166);\n            cam_up_vec = vec3(0.03109, 0.99938, -0.01662);\n            break;\n        case 564:\n            cam_pos = vec3(-2.98577, 1.99936, 1.99060);\n            cam_up_vec = vec3(0.03177, 0.99935, -0.01684);\n            break;\n        case 565:\n            cam_pos = vec3(-3.02153, 1.99388, 1.98933);\n            cam_up_vec = vec3(0.03244, 0.99933, -0.01706);\n            break;\n        case 566:\n            cam_pos = vec3(-3.05734, 1.98837, 1.98786);\n            cam_up_vec = vec3(0.03312, 0.99930, -0.01728);\n            break;\n        case 567:\n            cam_pos = vec3(-3.09321, 1.98280, 1.98618);\n            cam_up_vec = vec3(0.03380, 0.99928, -0.01749);\n            break;\n        case 568:\n            cam_pos = vec3(-3.12914, 1.97720, 1.98429);\n            cam_up_vec = vec3(0.03448, 0.99925, -0.01770);\n            break;\n        case 569:\n            cam_pos = vec3(-3.16512, 1.97155, 1.98219);\n            cam_up_vec = vec3(0.03517, 0.99922, -0.01790);\n            break;\n        case 570:\n            cam_pos = vec3(-3.20115, 1.96585, 1.97989);\n            cam_up_vec = vec3(0.03585, 0.99919, -0.01810);\n            break;\n        case 571:\n            cam_pos = vec3(-3.23724, 1.96011, 1.97738);\n            cam_up_vec = vec3(0.03654, 0.99916, -0.01829);\n            break;\n        case 572:\n            cam_pos = vec3(-3.27338, 1.95433, 1.97465);\n            cam_up_vec = vec3(0.03723, 0.99914, -0.01848);\n            break;\n        case 573:\n            cam_pos = vec3(-3.30956, 1.94850, 1.97172);\n            cam_up_vec = vec3(0.03792, 0.99911, -0.01867);\n            break;\n        case 574:\n            cam_pos = vec3(-3.34580, 1.94263, 1.96859);\n            cam_up_vec = vec3(0.03861, 0.99908, -0.01885);\n            break;\n        case 575:\n            cam_pos = vec3(-3.38209, 1.93672, 1.96524);\n            cam_up_vec = vec3(0.03930, 0.99905, -0.01903);\n            break;\n        case 576:\n            cam_pos = vec3(-3.41842, 1.93076, 1.96168);\n            cam_up_vec = vec3(0.04000, 0.99902, -0.01920);\n            break;\n        case 577:\n            cam_pos = vec3(-3.45480, 1.92475, 1.95791);\n            cam_up_vec = vec3(0.04070, 0.99898, -0.01937);\n            break;\n        case 578:\n            cam_pos = vec3(-3.49122, 1.91871, 1.95393);\n            cam_up_vec = vec3(0.04139, 0.99895, -0.01953);\n            break;\n        case 579:\n            cam_pos = vec3(-3.52769, 1.91261, 1.94974);\n            cam_up_vec = vec3(0.04209, 0.99892, -0.01969);\n            break;\n        case 580:\n            cam_pos = vec3(-3.56420, 1.90648, 1.94534);\n            cam_up_vec = vec3(0.04280, 0.99889, -0.01984);\n            break;\n        case 581:\n            cam_pos = vec3(-3.60075, 1.90030, 1.94072);\n            cam_up_vec = vec3(0.04350, 0.99885, -0.01999);\n            break;\n        case 582:\n            cam_pos = vec3(-3.63734, 1.89407, 1.93590);\n            cam_up_vec = vec3(0.04420, 0.99882, -0.02014);\n            break;\n        case 583:\n            cam_pos = vec3(-3.67397, 1.88780, 1.93086);\n            cam_up_vec = vec3(0.04491, 0.99879, -0.02028);\n            break;\n        case 584:\n            cam_pos = vec3(-3.71064, 1.88149, 1.92561);\n            cam_up_vec = vec3(0.04562, 0.99875, -0.02042);\n            break;\n        case 585:\n            cam_pos = vec3(-5.46054, 4.39953, 3.18061);\n            cam_up_vec = vec3(-0.27218, 0.93272, 0.23443);\n            break;\n        case 586:\n            cam_pos = vec3(-5.44522, 4.40699, 3.16556);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 587:\n            cam_pos = vec3(-5.41945, 4.39958, 3.14300);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 588:\n            cam_pos = vec3(-5.39368, 4.39217, 3.12043);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 589:\n            cam_pos = vec3(-5.36790, 4.38477, 3.09786);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 590:\n            cam_pos = vec3(-5.34213, 4.37736, 3.07529);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 591:\n            cam_pos = vec3(-5.31636, 4.36995, 3.05273);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 592:\n            cam_pos = vec3(-5.29059, 4.36254, 3.03016);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 593:\n            cam_pos = vec3(-5.26482, 4.35514, 3.00759);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 594:\n            cam_pos = vec3(-5.23905, 4.34773, 2.98502);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 595:\n            cam_pos = vec3(-5.21328, 4.34032, 2.96246);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 596:\n            cam_pos = vec3(-5.18750, 4.33291, 2.93989);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 597:\n            cam_pos = vec3(-5.16173, 4.32551, 2.91732);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 598:\n            cam_pos = vec3(-5.13596, 4.31810, 2.89475);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 599:\n            cam_pos = vec3(-5.11019, 4.31069, 2.87219);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 600:\n            cam_pos = vec3(-5.08442, 4.30328, 2.84962);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 601:\n            cam_pos = vec3(-5.05865, 4.29588, 2.82705);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 602:\n            cam_pos = vec3(-5.03288, 4.28847, 2.80448);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 603:\n            cam_pos = vec3(-5.00711, 4.28106, 2.78192);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 604:\n            cam_pos = vec3(-4.98133, 4.27365, 2.75935);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 605:\n            cam_pos = vec3(-4.95556, 4.26625, 2.73678);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 606:\n            cam_pos = vec3(-4.92979, 4.25884, 2.71421);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 607:\n            cam_pos = vec3(-4.90402, 4.25143, 2.69165);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 608:\n            cam_pos = vec3(-4.87825, 4.24402, 2.66908);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 609:\n            cam_pos = vec3(-4.85248, 4.23662, 2.64651);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 610:\n            cam_pos = vec3(-4.82671, 4.22921, 2.62394);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 611:\n            cam_pos = vec3(-4.80094, 4.22180, 2.60138);\n            cam_up_vec = vec3(-0.27405, 0.93233, 0.23593);\n            break;\n        case 612:\n            cam_pos = vec3(-0.15489, 1.15505, 1.32142);\n            cam_up_vec = vec3(-0.00217, 0.99834, -0.04823);\n            break;\n        case 613:\n            cam_pos = vec3(-0.12552, 1.13784, 1.31361);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 614:\n            cam_pos = vec3(-0.12475, 1.13952, 1.31369);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 615:\n            cam_pos = vec3(-0.12399, 1.14120, 1.31377);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 616:\n            cam_pos = vec3(-0.12322, 1.14289, 1.31384);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 617:\n            cam_pos = vec3(-0.12245, 1.14457, 1.31392);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 618:\n            cam_pos = vec3(-0.12169, 1.14625, 1.31400);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 619:\n            cam_pos = vec3(-0.12092, 1.14793, 1.31407);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 620:\n            cam_pos = vec3(-0.12016, 1.14961, 1.31415);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 621:\n            cam_pos = vec3(-0.11939, 1.15129, 1.31423);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 622:\n            cam_pos = vec3(-0.11862, 1.15298, 1.31430);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 623:\n            cam_pos = vec3(-0.11786, 1.15466, 1.31438);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 624:\n            cam_pos = vec3(-0.11709, 1.15634, 1.31445);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 625:\n            cam_pos = vec3(-0.11633, 1.15802, 1.31453);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 626:\n            cam_pos = vec3(-0.11556, 1.15970, 1.31461);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 627:\n            cam_pos = vec3(-0.11479, 1.16138, 1.31468);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 628:\n            cam_pos = vec3(-0.11403, 1.16306, 1.31476);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 629:\n            cam_pos = vec3(-0.11326, 1.16475, 1.31484);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 630:\n            cam_pos = vec3(-0.11250, 1.16643, 1.31491);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 631:\n            cam_pos = vec3(-0.11173, 1.16811, 1.31499);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 632:\n            cam_pos = vec3(-0.11096, 1.16979, 1.31507);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 633:\n            cam_pos = vec3(-0.11020, 1.17147, 1.31514);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 634:\n            cam_pos = vec3(-0.10943, 1.17315, 1.31522);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 635:\n            cam_pos = vec3(-0.10867, 1.17484, 1.31530);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 636:\n            cam_pos = vec3(-0.10790, 1.17652, 1.31537);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 637:\n            cam_pos = vec3(-0.10713, 1.17820, 1.31545);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 638:\n            cam_pos = vec3(-0.10637, 1.17988, 1.31553);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 639:\n            cam_pos = vec3(-0.10560, 1.18156, 1.31560);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 640:\n            cam_pos = vec3(-0.10483, 1.18324, 1.31568);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 641:\n            cam_pos = vec3(-0.10407, 1.18492, 1.31575);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 642:\n            cam_pos = vec3(-0.10330, 1.18661, 1.31583);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 643:\n            cam_pos = vec3(-0.10254, 1.18829, 1.31591);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 644:\n            cam_pos = vec3(-0.10177, 1.18997, 1.31598);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 645:\n            cam_pos = vec3(-0.10100, 1.19165, 1.31606);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 646:\n            cam_pos = vec3(-0.10024, 1.19333, 1.31614);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 647:\n            cam_pos = vec3(-0.09947, 1.19501, 1.31621);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 648:\n            cam_pos = vec3(-0.09871, 1.19670, 1.31629);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 649:\n            cam_pos = vec3(-0.09794, 1.19838, 1.31637);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 650:\n            cam_pos = vec3(-0.09717, 1.20006, 1.31644);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 651:\n            cam_pos = vec3(-0.09641, 1.20174, 1.31652);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 652:\n            cam_pos = vec3(-0.09564, 1.20342, 1.31660);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 653:\n            cam_pos = vec3(-0.09488, 1.20510, 1.31667);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 654:\n            cam_pos = vec3(-0.09411, 1.20678, 1.31675);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 655:\n            cam_pos = vec3(-0.09334, 1.20847, 1.31683);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 656:\n            cam_pos = vec3(-0.09258, 1.21015, 1.31690);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 657:\n            cam_pos = vec3(-0.09181, 1.21183, 1.31698);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 658:\n            cam_pos = vec3(-0.09104, 1.21351, 1.31706);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 659:\n            cam_pos = vec3(-0.09028, 1.21519, 1.31713);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 660:\n            cam_pos = vec3(-0.08951, 1.21687, 1.31721);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 661:\n            cam_pos = vec3(-0.08875, 1.21856, 1.31728);\n            cam_up_vec = vec3(-0.00050, 0.99875, -0.04998);\n            break;\n        case 662:\n            cam_pos = vec3(1.97615, 2.24797, 1.06978);\n            cam_up_vec = vec3(-0.02225, 0.99954, -0.02015);\n            break;\n        case 663:\n            cam_pos = vec3(1.97745, 2.25483, 1.08202);\n            cam_up_vec = vec3(-0.02225, 0.99955, -0.02011);\n            break;\n        case 664:\n            cam_pos = vec3(1.96481, 2.25483, 1.09590);\n            cam_up_vec = vec3(-0.02210, 0.99955, -0.02028);\n            break;\n        case 665:\n            cam_pos = vec3(1.95206, 2.25483, 1.10970);\n            cam_up_vec = vec3(-0.02195, 0.99955, -0.02044);\n            break;\n        case 666:\n            cam_pos = vec3(1.93921, 2.25483, 1.12340);\n            cam_up_vec = vec3(-0.02180, 0.99955, -0.02060);\n            break;\n        case 667:\n            cam_pos = vec3(1.92627, 2.25483, 1.13700);\n            cam_up_vec = vec3(-0.02165, 0.99955, -0.02076);\n            break;\n        case 668:\n            cam_pos = vec3(1.91322, 2.25483, 1.15051);\n            cam_up_vec = vec3(-0.02150, 0.99955, -0.02092);\n            break;\n        case 669:\n            cam_pos = vec3(1.90007, 2.25483, 1.16392);\n            cam_up_vec = vec3(-0.02134, 0.99955, -0.02108);\n            break;\n        case 670:\n            cam_pos = vec3(1.88682, 2.25483, 1.17723);\n            cam_up_vec = vec3(-0.02119, 0.99955, -0.02123);\n            break;\n        case 671:\n            cam_pos = vec3(1.87348, 2.25483, 1.19045);\n            cam_up_vec = vec3(-0.02103, 0.99955, -0.02139);\n            break;\n        case 672:\n            cam_pos = vec3(1.86004, 2.25483, 1.20357);\n            cam_up_vec = vec3(-0.02087, 0.99955, -0.02154);\n            break;\n        case 673:\n            cam_pos = vec3(1.84650, 2.25483, 1.21659);\n            cam_up_vec = vec3(-0.02071, 0.99955, -0.02170);\n            break;\n        case 674:\n            cam_pos = vec3(1.83287, 2.25483, 1.22950);\n            cam_up_vec = vec3(-0.02055, 0.99955, -0.02185);\n            break;\n        case 675:\n            cam_pos = vec3(1.81914, 2.25483, 1.24232);\n            cam_up_vec = vec3(-0.02039, 0.99955, -0.02200);\n            break;\n        case 676:\n            cam_pos = vec3(1.80532, 2.25483, 1.25504);\n            cam_up_vec = vec3(-0.02023, 0.99955, -0.02215);\n            break;\n        case 677:\n            cam_pos = vec3(1.79141, 2.25483, 1.26765);\n            cam_up_vec = vec3(-0.02006, 0.99955, -0.02230);\n            break;\n        case 678:\n            cam_pos = vec3(1.77740, 2.25483, 1.28016);\n            cam_up_vec = vec3(-0.01990, 0.99955, -0.02244);\n            break;\n        case 679:\n            cam_pos = vec3(1.76330, 2.25483, 1.29257);\n            cam_up_vec = vec3(-0.01973, 0.99955, -0.02259);\n            break;\n        case 680:\n            cam_pos = vec3(1.74911, 2.25483, 1.30487);\n            cam_up_vec = vec3(-0.01957, 0.99955, -0.02274);\n            break;\n        case 681:\n            cam_pos = vec3(1.73483, 2.25483, 1.31707);\n            cam_up_vec = vec3(-0.01940, 0.99955, -0.02288);\n            break;\n        case 682:\n            cam_pos = vec3(7.66379, 1.85569, 5.75011);\n            cam_up_vec = vec3(0.00779, 0.99995, 0.00584);\n            break;\n        case 683:\n            cam_pos = vec3(7.70659, 1.85587, 5.79521);\n            cam_up_vec = vec3(0.00858, 0.99994, 0.00646);\n            break;\n        case 684:\n            cam_pos = vec3(7.70868, 1.85883, 5.80990);\n            cam_up_vec = vec3(0.00920, 0.99993, 0.00690);\n            break;\n        case 685:\n            cam_pos = vec3(7.71076, 1.86180, 5.82452);\n            cam_up_vec = vec3(0.00981, 0.99993, 0.00732);\n            break;\n        case 686:\n            cam_pos = vec3(7.71283, 1.86479, 5.83908);\n            cam_up_vec = vec3(0.01043, 0.99992, 0.00775);\n            break;\n        case 687:\n            cam_pos = vec3(7.71489, 1.86780, 5.85356);\n            cam_up_vec = vec3(0.01105, 0.99991, 0.00817);\n            break;\n        case 688:\n            cam_pos = vec3(7.71693, 1.87082, 5.86798);\n            cam_up_vec = vec3(0.01167, 0.99990, 0.00860);\n            break;\n        case 689:\n            cam_pos = vec3(7.71896, 1.87387, 5.88234);\n            cam_up_vec = vec3(0.01229, 0.99988, 0.00901);\n            break;\n        case 690:\n            cam_pos = vec3(7.72098, 1.87692, 5.89662);\n            cam_up_vec = vec3(0.01292, 0.99987, 0.00943);\n            break;\n        case 691:\n            cam_pos = vec3(7.72299, 1.88000, 5.91084);\n            cam_up_vec = vec3(0.01354, 0.99986, 0.00984);\n            break;\n        case 692:\n            cam_pos = vec3(7.72498, 1.88309, 5.92499);\n            cam_up_vec = vec3(0.01417, 0.99985, 0.01025);\n            break;\n        case 693:\n            cam_pos = vec3(7.72696, 1.88620, 5.93907);\n            cam_up_vec = vec3(0.01480, 0.99983, 0.01066);\n            break;\n        case 694:\n            cam_pos = vec3(7.72893, 1.88932, 5.95308);\n            cam_up_vec = vec3(0.01543, 0.99982, 0.01107);\n            break;\n        case 695:\n            cam_pos = vec3(7.73089, 1.89246, 5.96702);\n            cam_up_vec = vec3(0.01607, 0.99981, 0.01147);\n            break;\n        case 696:\n            cam_pos = vec3(7.73282, 1.89562, 5.98090);\n            cam_up_vec = vec3(0.01670, 0.99979, 0.01187);\n            break;\n        case 697:\n            cam_pos = vec3(7.73475, 1.89880, 5.99471);\n            cam_up_vec = vec3(0.01734, 0.99977, 0.01227);\n            break;\n        case 698:\n            cam_pos = vec3(7.73666, 1.90199, 6.00846);\n            cam_up_vec = vec3(0.01798, 0.99976, 0.01266);\n            break;\n        case 699:\n            cam_pos = vec3(7.73856, 1.90520, 6.02213);\n            cam_up_vec = vec3(0.01862, 0.99974, 0.01306);\n            break;\n        case 700:\n            cam_pos = vec3(7.74045, 1.90842, 6.03574);\n            cam_up_vec = vec3(0.01926, 0.99972, 0.01345);\n            break;\n        case 701:\n            cam_pos = vec3(7.74231, 1.91166, 6.04928);\n            cam_up_vec = vec3(0.01991, 0.99971, 0.01383);\n            break;\n        case 702:\n            cam_pos = vec3(7.74417, 1.91492, 6.06275);\n            cam_up_vec = vec3(0.02055, 0.99969, 0.01422);\n            break;\n        case 703:\n            cam_pos = vec3(7.74600, 1.91820, 6.07615);\n            cam_up_vec = vec3(0.02120, 0.99967, 0.01460);\n            break;\n        case 704:\n            cam_pos = vec3(7.74783, 1.92149, 6.08948);\n            cam_up_vec = vec3(0.02185, 0.99965, 0.01498);\n            break;\n        case 705:\n            cam_pos = vec3(7.74963, 1.92480, 6.10275);\n            cam_up_vec = vec3(0.02250, 0.99963, 0.01535);\n            break;\n        case 706:\n            cam_pos = vec3(7.75142, 1.92812, 6.11596);\n            cam_up_vec = vec3(0.02315, 0.99961, 0.01573);\n            break;\n        case 707:\n            cam_pos = vec3(7.75320, 1.93147, 6.12909);\n            cam_up_vec = vec3(0.02381, 0.99959, 0.01610);\n            break;\n        case 708:\n            cam_pos = vec3(7.75496, 1.93482, 6.14215);\n            cam_up_vec = vec3(0.02447, 0.99957, 0.01647);\n            break;\n        case 709:\n            cam_pos = vec3(7.75670, 1.93820, 6.15515);\n            cam_up_vec = vec3(0.02512, 0.99954, 0.01683);\n            break;\n        case 710:\n            cam_pos = vec3(7.75843, 1.94159, 6.16808);\n            cam_up_vec = vec3(0.02578, 0.99952, 0.01719);\n            break;\n        case 711:\n            cam_pos = vec3(7.76013, 1.94500, 6.18094);\n            cam_up_vec = vec3(0.02644, 0.99950, 0.01755);\n            break;\n        case 712:\n            cam_pos = vec3(7.76182, 1.94843, 6.19374);\n            cam_up_vec = vec3(0.02711, 0.99947, 0.01791);\n            break;\n        case 713:\n            cam_pos = vec3(7.76350, 1.95187, 6.20646);\n            cam_up_vec = vec3(0.02777, 0.99945, 0.01826);\n            break;\n        case 714:\n            cam_pos = vec3(7.76515, 1.95533, 6.21912);\n            cam_up_vec = vec3(0.02844, 0.99942, 0.01862);\n            break;\n        case 715:\n            cam_pos = vec3(7.76679, 1.95880, 6.23172);\n            cam_up_vec = vec3(0.02910, 0.99940, 0.01896);\n            break;\n        case 716:\n            cam_pos = vec3(7.76841, 1.96230, 6.24424);\n            cam_up_vec = vec3(0.02977, 0.99937, 0.01931);\n            break;\n        case 717:\n            cam_pos = vec3(7.77001, 1.96581, 6.25670);\n            cam_up_vec = vec3(0.03044, 0.99934, 0.01965);\n            break;\n        case 718:\n            cam_pos = vec3(7.77160, 1.96933, 6.26909);\n            cam_up_vec = vec3(0.03112, 0.99932, 0.01999);\n            break;\n        case 719:\n            cam_pos = vec3(7.77316, 1.97287, 6.28141);\n            cam_up_vec = vec3(0.03179, 0.99929, 0.02033);\n            break;\n        case 720:\n            cam_pos = vec3(7.77471, 1.97643, 6.29366);\n            cam_up_vec = vec3(0.03246, 0.99926, 0.02067);\n            break;\n        case 721:\n            cam_pos = vec3(7.77624, 1.98001, 6.30585);\n            cam_up_vec = vec3(0.03314, 0.99923, 0.02100);\n            break;\n        case 722:\n            cam_pos = vec3(7.77774, 1.98360, 6.31797);\n            cam_up_vec = vec3(0.03382, 0.99920, 0.02133);\n            break;\n        case 723:\n            cam_pos = vec3(7.77923, 1.98721, 6.33003);\n            cam_up_vec = vec3(0.03450, 0.99917, 0.02165);\n            break;\n        case 724:\n            cam_pos = vec3(7.78070, 1.99084, 6.34202);\n            cam_up_vec = vec3(0.03518, 0.99914, 0.02198);\n            break;\n        case 725:\n            cam_pos = vec3(7.78215, 1.99448, 6.35393);\n            cam_up_vec = vec3(0.03586, 0.99911, 0.02230);\n            break;\n        case 726:\n            cam_pos = vec3(7.78357, 1.99814, 6.36579);\n            cam_up_vec = vec3(0.03655, 0.99908, 0.02262);\n            break;\n        case 727:\n            cam_pos = vec3(7.78498, 2.00181, 6.37757);\n            cam_up_vec = vec3(0.03724, 0.99904, 0.02293);\n            break;\n        case 728:\n            cam_pos = vec3(7.78637, 2.00551, 6.38929);\n            cam_up_vec = vec3(0.03792, 0.99901, 0.02324);\n            break;\n        case 729:\n            cam_pos = vec3(7.78774, 2.00921, 6.40094);\n            cam_up_vec = vec3(0.03861, 0.99898, 0.02355);\n            break;\n        case 730:\n            cam_pos = vec3(7.78908, 2.01294, 6.41252);\n            cam_up_vec = vec3(0.03930, 0.99894, 0.02386);\n            break;\n        case 731:\n            cam_pos = vec3(7.79040, 2.01668, 6.42404);\n            cam_up_vec = vec3(0.03999, 0.99891, 0.02416);\n            break;\n        case 732:\n            cam_pos = vec3(7.79171, 2.02044, 6.43549);\n            cam_up_vec = vec3(0.04069, 0.99887, 0.02447);\n            break;\n        case 733:\n            cam_pos = vec3(7.79298, 2.02421, 6.44687);\n            cam_up_vec = vec3(0.04138, 0.99884, 0.02476);\n            break;\n        case 734:\n            cam_pos = vec3(7.79424, 2.02801, 6.45818);\n            cam_up_vec = vec3(0.04208, 0.99880, 0.02506);\n            break;\n        case 735:\n            cam_pos = vec3(7.79548, 2.03181, 6.46943);\n            cam_up_vec = vec3(0.04278, 0.99876, 0.02535);\n            break;\n        case 736:\n            cam_pos = vec3(7.79669, 2.03564, 6.48061);\n            cam_up_vec = vec3(0.04347, 0.99873, 0.02564);\n            break;\n        case 737:\n            cam_pos = vec3(7.79789, 2.03948, 6.49173);\n            cam_up_vec = vec3(0.04417, 0.99869, 0.02593);\n            break;\n        case 738:\n            cam_pos = vec3(7.79905, 2.04334, 6.50278);\n            cam_up_vec = vec3(0.04488, 0.99865, 0.02621);\n            break;\n        case 739:\n            cam_pos = vec3(7.80020, 2.04721, 6.51376);\n            cam_up_vec = vec3(0.04558, 0.99861, 0.02649);\n            break;\n        case 740:\n            cam_pos = vec3(7.80132, 2.05110, 6.52467);\n            cam_up_vec = vec3(0.04628, 0.99857, 0.02677);\n            break;\n        case 741:\n            cam_pos = vec3(7.80242, 2.05501, 6.53552);\n            cam_up_vec = vec3(0.04699, 0.99853, 0.02705);\n            break;\n        case 742:\n            cam_pos = vec3(7.80350, 2.05893, 6.54630);\n            cam_up_vec = vec3(0.04770, 0.99849, 0.02732);\n            break;\n        case 743:\n            cam_pos = vec3(7.80455, 2.06288, 6.55702);\n            cam_up_vec = vec3(0.04841, 0.99845, 0.02759);\n            break;\n        case 744:\n            cam_pos = vec3(7.80558, 2.06683, 6.56767);\n            cam_up_vec = vec3(0.04912, 0.99840, 0.02785);\n            break;\n        case 745:\n            cam_pos = vec3(7.80658, 2.07081, 6.57825);\n            cam_up_vec = vec3(0.04983, 0.99836, 0.02812);\n            break;\n        case 746:\n            cam_pos = vec3(7.80756, 2.07480, 6.58876);\n            cam_up_vec = vec3(0.05054, 0.99832, 0.02838);\n            break;\n        case 747:\n            cam_pos = vec3(7.80851, 2.07880, 6.59921);\n            cam_up_vec = vec3(0.05125, 0.99828, 0.02864);\n            break;\n        case 748:\n            cam_pos = vec3(7.80944, 2.08283, 6.60959);\n            cam_up_vec = vec3(0.05197, 0.99823, 0.02889);\n            break;\n        case 749:\n            cam_pos = vec3(7.81034, 2.08687, 6.61991);\n            cam_up_vec = vec3(0.05268, 0.99819, 0.02914);\n            break;\n        case 750:\n            cam_pos = vec3(7.81122, 2.09092, 6.63016);\n            cam_up_vec = vec3(0.05340, 0.99814, 0.02939);\n            break;\n        case 751:\n            cam_pos = vec3(7.81208, 2.09499, 6.64035);\n            cam_up_vec = vec3(0.05412, 0.99809, 0.02964);\n            break;\n        case 752:\n            cam_pos = vec3(7.81290, 2.09908, 6.65046);\n            cam_up_vec = vec3(0.05484, 0.99805, 0.02988);\n            break;\n        case 753:\n            cam_pos = vec3(7.81370, 2.10319, 6.66051);\n            cam_up_vec = vec3(0.05556, 0.99800, 0.03012);\n            break;\n        case 754:\n            cam_pos = vec3(7.81448, 2.10731, 6.67050);\n            cam_up_vec = vec3(0.05629, 0.99795, 0.03036);\n            break;\n        case 755:\n            cam_pos = vec3(7.81523, 2.11145, 6.68042);\n            cam_up_vec = vec3(0.05701, 0.99790, 0.03059);\n            break;\n        case 756:\n            cam_pos = vec3(7.81595, 2.11560, 6.69027);\n            cam_up_vec = vec3(0.05773, 0.99786, 0.03082);\n            break;\n        case 757:\n            cam_pos = vec3(7.81665, 2.11978, 6.70006);\n            cam_up_vec = vec3(0.05846, 0.99781, 0.03105);\n            break;\n        case 758:\n            cam_pos = vec3(7.81731, 2.12396, 6.70978);\n            cam_up_vec = vec3(0.05919, 0.99776, 0.03128);\n            break;\n        case 759:\n            cam_pos = vec3(7.81795, 2.12817, 6.71944);\n            cam_up_vec = vec3(0.05992, 0.99771, 0.03150);\n            break;\n        case 760:\n            cam_pos = vec3(7.81857, 2.13239, 6.72903);\n            cam_up_vec = vec3(0.06065, 0.99766, 0.03172);\n            break;\n        case 761:\n            cam_pos = vec3(7.81915, 2.13663, 6.73855);\n            cam_up_vec = vec3(0.06138, 0.99760, 0.03194);\n            break;\n        case 762:\n            cam_pos = vec3(7.81971, 2.14088, 6.74801);\n            cam_up_vec = vec3(0.06211, 0.99755, 0.03215);\n            break;\n        case 763:\n            cam_pos = vec3(-0.16909, 1.10378, 5.59157);\n            cam_up_vec = vec3(0.01061, 0.97606, -0.21608);\n            break;\n        case 764:\n            cam_pos = vec3(-0.23261, 1.08795, 5.63068);\n            cam_up_vec = vec3(0.01010, 0.97609, -0.21715);\n            break;\n        case 765:\n            cam_pos = vec3(-0.23555, 1.07691, 5.69906);\n            cam_up_vec = vec3(0.00994, 0.97635, -0.21595);\n            break;\n        case 766:\n            cam_pos = vec3(-0.23895, 1.06401, 5.78033);\n            cam_up_vec = vec3(0.00976, 0.97667, -0.21453);\n            break;\n        case 767:\n            cam_pos = vec3(-0.24263, 1.04996, 5.87066);\n            cam_up_vec = vec3(0.00955, 0.97702, -0.21294);\n            break;\n        case 768:\n            cam_pos = vec3(-0.24646, 1.03518, 5.96777);\n            cam_up_vec = vec3(0.00933, 0.97739, -0.21124);\n            break;\n        case 769:\n            cam_pos = vec3(-0.25035, 1.01997, 6.07018);\n            cam_up_vec = vec3(0.00910, 0.97778, -0.20945);\n            break;\n        case 770:\n            cam_pos = vec3(-0.25425, 1.00453, 6.17684);\n            cam_up_vec = vec3(0.00887, 0.97818, -0.20758);\n            break;\n        case 771:\n            cam_pos = vec3(-0.25811, 0.98902, 6.28701);\n            cam_up_vec = vec3(0.00863, 0.97859, -0.20565);\n            break;\n        case 772:\n            cam_pos = vec3(-0.26191, 0.97356, 6.40011);\n            cam_up_vec = vec3(0.00839, 0.97900, -0.20367);\n            break;\n        case 773:\n            cam_pos = vec3(-0.26561, 0.95823, 6.51570);\n            cam_up_vec = vec3(0.00814, 0.97943, -0.20164);\n            break;\n        case 774:\n            cam_pos = vec3(-0.26918, 0.94312, 6.63340);\n            cam_up_vec = vec3(0.00790, 0.97985, -0.19958);\n            break;\n        case 775:\n            cam_pos = vec3(-0.27261, 0.92829, 6.75293);\n            cam_up_vec = vec3(0.00765, 0.98028, -0.19748);\n            break;\n        case 776:\n            cam_pos = vec3(-0.27589, 0.91378, 6.87405);\n            cam_up_vec = vec3(0.00741, 0.98070, -0.19536);\n            break;\n        case 777:\n            cam_pos = vec3(-0.27900, 0.89964, 6.99654);\n            cam_up_vec = vec3(0.00716, 0.98113, -0.19322);\n            break;\n        case 778:\n            cam_pos = vec3(-0.28194, 0.88592, 7.12024);\n            cam_up_vec = vec3(0.00692, 0.98156, -0.19105);\n            break;\n        case 779:\n            cam_pos = vec3(-0.28468, 0.87263, 7.24499);\n            cam_up_vec = vec3(0.00668, 0.98198, -0.18886);\n            break;\n        case 780:\n            cam_pos = vec3(-0.28723, 0.85980, 7.37065);\n            cam_up_vec = vec3(0.00644, 0.98240, -0.18666);\n            break;\n        case 781:\n            cam_pos = vec3(-0.28958, 0.84747, 7.49710);\n            cam_up_vec = vec3(0.00620, 0.98282, -0.18445);\n            break;\n        case 782:\n            cam_pos = vec3(-0.29171, 0.83564, 7.62423);\n            cam_up_vec = vec3(0.00596, 0.98324, -0.18222);\n            break;\n        case 783:\n            cam_pos = vec3(-0.29364, 0.82434, 7.75196);\n            cam_up_vec = vec3(0.00573, 0.98365, -0.17998);\n            break;\n        case 784:\n            cam_pos = vec3(-0.29535, 0.81358, 7.88018);\n            cam_up_vec = vec3(0.00551, 0.98406, -0.17774);\n            break;\n        case 785:\n            cam_pos = vec3(-0.29684, 0.80337, 8.00881);\n            cam_up_vec = vec3(0.00528, 0.98447, -0.17548);\n            break;\n        case 786:\n            cam_pos = vec3(-0.29810, 0.79372, 8.13778);\n            cam_up_vec = vec3(0.00506, 0.98487, -0.17322);\n            break;\n        case 787:\n            cam_pos = vec3(-0.29914, 0.78464, 8.26702);\n            cam_up_vec = vec3(0.00484, 0.98527, -0.17096);\n            break;\n        case 788:\n            cam_pos = vec3(-0.29996, 0.77614, 8.39646);\n            cam_up_vec = vec3(0.00463, 0.98566, -0.16869);\n            break;\n        case 789:\n            cam_pos = vec3(-0.30054, 0.76823, 8.52603);\n            cam_up_vec = vec3(0.00442, 0.98605, -0.16642);\n            break;\n        case 790:\n            cam_pos = vec3(-0.30090, 0.76090, 8.65567);\n            cam_up_vec = vec3(0.00421, 0.98643, -0.16415);\n            break;\n        case 791:\n            cam_pos = vec3(-0.30103, 0.75417, 8.78532);\n            cam_up_vec = vec3(0.00401, 0.98680, -0.16187);\n            break;\n        case 792:\n            cam_pos = vec3(-0.30093, 0.74803, 8.91493);\n            cam_up_vec = vec3(0.00381, 0.98717, -0.15960);\n            break;\n        case 793:\n            cam_pos = vec3(-0.30060, 0.74249, 9.04443);\n            cam_up_vec = vec3(0.00362, 0.98754, -0.15733);\n            break;\n        case 794:\n            cam_pos = vec3(-0.30004, 0.73754, 9.17376);\n            cam_up_vec = vec3(0.00343, 0.98790, -0.15506);\n            break;\n        case 795:\n            cam_pos = vec3(-0.29926, 0.73319, 9.30288);\n            cam_up_vec = vec3(0.00324, 0.98825, -0.15280);\n            break;\n        case 796:\n            cam_pos = vec3(-0.29825, 0.72943, 9.43172);\n            cam_up_vec = vec3(0.00306, 0.98860, -0.15054);\n            break;\n        case 797:\n            cam_pos = vec3(-0.29702, 0.72626, 9.56023);\n            cam_up_vec = vec3(0.00289, 0.98894, -0.14828);\n            break;\n        case 798:\n            cam_pos = vec3(-0.29557, 0.72368, 9.68835);\n            cam_up_vec = vec3(0.00271, 0.98928, -0.14603);\n            break;\n        case 799:\n            cam_pos = vec3(-0.29391, 0.72168, 9.81603);\n            cam_up_vec = vec3(0.00255, 0.98960, -0.14379);\n            break;\n        case 800:\n            cam_pos = vec3(-0.29202, 0.72026, 9.94320);\n            cam_up_vec = vec3(0.00238, 0.98993, -0.14156);\n            break;\n        case 801:\n            cam_pos = vec3(-0.28992, 0.71940, 10.06979);\n            cam_up_vec = vec3(0.00223, 0.99024, -0.13934);\n            break;\n        case 802:\n            cam_pos = vec3(-0.28763, 0.71911, 10.19576);\n            cam_up_vec = vec3(0.00207, 0.99055, -0.13712);\n            break;\n        case 803:\n            cam_pos = vec3(-0.28513, 0.71937, 10.32102);\n            cam_up_vec = vec3(0.00192, 0.99085, -0.13492);\n            break;\n        case 804:\n            cam_pos = vec3(-0.28243, 0.72018, 10.44552);\n            cam_up_vec = vec3(0.00178, 0.99115, -0.13273);\n            break;\n        case 805:\n            cam_pos = vec3(-0.27955, 0.72151, 10.56917);\n            cam_up_vec = vec3(0.00164, 0.99144, -0.13056);\n            break;\n        case 806:\n            cam_pos = vec3(-0.27648, 0.72337, 10.69191);\n            cam_up_vec = vec3(0.00151, 0.99172, -0.12840);\n            break;\n        case 807:\n            cam_pos = vec3(-0.27322, 0.72573, 10.81364);\n            cam_up_vec = vec3(0.00138, 0.99200, -0.12626);\n            break;\n        case 808:\n            cam_pos = vec3(-0.26981, 0.72858, 10.93428);\n            cam_up_vec = vec3(0.00125, 0.99226, -0.12414);\n            break;\n        case 809:\n            cam_pos = vec3(-0.26623, 0.73191, 11.05373);\n            cam_up_vec = vec3(0.00113, 0.99252, -0.12204);\n            break;\n        case 810:\n            cam_pos = vec3(-0.26250, 0.73570, 11.17189);\n            cam_up_vec = vec3(0.00101, 0.99278, -0.11996);\n            break;\n        case 811:\n            cam_pos = vec3(-0.25862, 0.73991, 11.28865);\n            cam_up_vec = vec3(0.00090, 0.99303, -0.11790);\n            break;\n        case 812:\n            cam_pos = vec3(-0.25461, 0.74455, 11.40388);\n            cam_up_vec = vec3(0.00080, 0.99326, -0.11587);\n            break;\n        case 813:\n            cam_pos = vec3(-0.25047, 0.74957, 11.51745);\n            cam_up_vec = vec3(0.00069, 0.99350, -0.11387);\n            break;\n        case 814:\n            cam_pos = vec3(-0.24625, 0.75495, 11.62920);\n            cam_up_vec = vec3(0.00060, 0.99372, -0.11190);\n            break;\n        case 815:\n            cam_pos = vec3(-0.24192, 0.76067, 11.73898);\n            cam_up_vec = vec3(0.00050, 0.99394, -0.10996);\n            break;\n        case 816:\n            cam_pos = vec3(-0.23752, 0.76668, 11.84659);\n            cam_up_vec = vec3(0.00042, 0.99414, -0.10807);\n            break;\n        case 817:\n            cam_pos = vec3(-0.23306, 0.77295, 11.95181);\n            cam_up_vec = vec3(0.00033, 0.99434, -0.10621);\n            break;\n        case 818:\n            cam_pos = vec3(-0.22857, 0.77944, 12.05441);\n            cam_up_vec = vec3(0.00025, 0.99454, -0.10440);\n            break;\n        case 819:\n            cam_pos = vec3(-0.22407, 0.78610, 12.15409);\n            cam_up_vec = vec3(0.00018, 0.99472, -0.10264);\n            break;\n        case 820:\n            cam_pos = vec3(-0.21959, 0.79288, 12.25052);\n            cam_up_vec = vec3(0.00011, 0.99489, -0.10094);\n            break;\n        case 821:\n            cam_pos = vec3(-0.21515, 0.79971, 12.34332);\n            cam_up_vec = vec3(0.00005, 0.99506, -0.09930);\n            break;\n        case 822:\n            cam_pos = vec3(-0.21080, 0.80652, 12.43202);\n            cam_up_vec = vec3(-0.00001, 0.99521, -0.09773);\n            break;\n        case 823:\n            cam_pos = vec3(-0.20658, 0.81323, 12.51604);\n            cam_up_vec = vec3(-0.00007, 0.99536, -0.09625);\n            break;\n        case 824:\n            cam_pos = vec3(-0.20254, 0.81973, 12.59470);\n            cam_up_vec = vec3(-0.00012, 0.99549, -0.09486);\n            break;\n        case 825:\n            cam_pos = vec3(-0.19875, 0.82591, 12.66710);\n            cam_up_vec = vec3(-0.00016, 0.99561, -0.09358);\n            break;\n        case 826:\n            cam_pos = vec3(-0.19529, 0.83162, 12.73210);\n            cam_up_vec = vec3(-0.00020, 0.99572, -0.09243);\n            break;\n        case 827:\n            cam_pos = vec3(-0.19225, 0.83666, 12.78818);\n            cam_up_vec = vec3(-0.00024, 0.99581, -0.09144);\n            break;\n        case 828:\n            cam_pos = vec3(-0.18978, 0.84079, 12.83322);\n            cam_up_vec = vec3(-0.00026, 0.99588, -0.09064);\n            break;\n        case 829:\n            cam_pos = vec3(-0.18806, 0.84367, 12.86414);\n            cam_up_vec = vec3(-0.00028, 0.99593, -0.09009);\n            break;\n        case 830:\n            cam_pos = vec3(-0.18740, 0.84479, 12.87612);\n            cam_up_vec = vec3(-0.00029, 0.99595, -0.08988);\n            break;\n        case 831:\n            cam_pos = vec3(0.19028, 2.59307, 1.30396);\n            cam_up_vec = vec3(0.01019, 0.99501, 0.09773);\n            break;\n        case 832:\n            cam_pos = vec3(0.19448, 2.60586, 1.21560);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 833:\n            cam_pos = vec3(0.19553, 2.60399, 1.22427);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 834:\n            cam_pos = vec3(0.19657, 2.60211, 1.23295);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 835:\n            cam_pos = vec3(0.19762, 2.60023, 1.24163);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 836:\n            cam_pos = vec3(0.19866, 2.59835, 1.25031);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 837:\n            cam_pos = vec3(0.19970, 2.59648, 1.25899);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 838:\n            cam_pos = vec3(0.20075, 2.59460, 1.26767);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 839:\n            cam_pos = vec3(0.20179, 2.59272, 1.27635);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 840:\n            cam_pos = vec3(0.20283, 2.59085, 1.28503);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 841:\n            cam_pos = vec3(0.20388, 2.58897, 1.29371);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 842:\n            cam_pos = vec3(0.20492, 2.58709, 1.30239);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 843:\n            cam_pos = vec3(0.20597, 2.58521, 1.31107);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 844:\n            cam_pos = vec3(0.20701, 2.58334, 1.31975);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 845:\n            cam_pos = vec3(0.20805, 2.58146, 1.32843);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 846:\n            cam_pos = vec3(0.20910, 2.57958, 1.33711);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 847:\n            cam_pos = vec3(0.21014, 2.57771, 1.34578);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 848:\n            cam_pos = vec3(0.21118, 2.57583, 1.35446);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 849:\n            cam_pos = vec3(0.21223, 2.57395, 1.36314);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 850:\n            cam_pos = vec3(0.21327, 2.57207, 1.37182);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 851:\n            cam_pos = vec3(0.21431, 2.57020, 1.38050);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 852:\n            cam_pos = vec3(0.21536, 2.56832, 1.38918);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 853:\n            cam_pos = vec3(0.21640, 2.56644, 1.39786);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 854:\n            cam_pos = vec3(0.21745, 2.56457, 1.40654);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 855:\n            cam_pos = vec3(0.21849, 2.56269, 1.41522);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 856:\n            cam_pos = vec3(0.21953, 2.56081, 1.42390);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 857:\n            cam_pos = vec3(0.22058, 2.55893, 1.43258);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 858:\n            cam_pos = vec3(0.22162, 2.55706, 1.44126);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 859:\n            cam_pos = vec3(0.22266, 2.55518, 1.44994);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 860:\n            cam_pos = vec3(0.22371, 2.55330, 1.45861);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 861:\n            cam_pos = vec3(0.22475, 2.55143, 1.46729);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 862:\n            cam_pos = vec3(0.22580, 2.54955, 1.47597);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 863:\n            cam_pos = vec3(0.22684, 2.54767, 1.48465);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 864:\n            cam_pos = vec3(0.22788, 2.54579, 1.49333);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 865:\n            cam_pos = vec3(0.22893, 2.54392, 1.50201);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 866:\n            cam_pos = vec3(0.22997, 2.54204, 1.51069);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 867:\n            cam_pos = vec3(0.23101, 2.54016, 1.51937);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 868:\n            cam_pos = vec3(0.23206, 2.53829, 1.52805);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 869:\n            cam_pos = vec3(0.23310, 2.53641, 1.53673);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 870:\n            cam_pos = vec3(0.23415, 2.53453, 1.54541);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 871:\n            cam_pos = vec3(0.23519, 2.53265, 1.55409);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 872:\n            cam_pos = vec3(0.23623, 2.53078, 1.56277);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 873:\n            cam_pos = vec3(0.23728, 2.52890, 1.57145);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 874:\n            cam_pos = vec3(0.23832, 2.52702, 1.58012);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 875:\n            cam_pos = vec3(0.23936, 2.52515, 1.58880);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 876:\n            cam_pos = vec3(0.24041, 2.52327, 1.59748);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 877:\n            cam_pos = vec3(0.24145, 2.52139, 1.60616);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 878:\n            cam_pos = vec3(0.24250, 2.51951, 1.61484);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 879:\n            cam_pos = vec3(0.24354, 2.51764, 1.62352);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 880:\n            cam_pos = vec3(0.24458, 2.51576, 1.63220);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 881:\n            cam_pos = vec3(0.24563, 2.51388, 1.64088);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 882:\n            cam_pos = vec3(0.24667, 2.51201, 1.64956);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 883:\n            cam_pos = vec3(0.24771, 2.51013, 1.65824);\n            cam_up_vec = vec3(0.01028, 0.99500, 0.09930);\n            break;\n        case 884:\n            cam_pos = vec3(-0.39592, 2.16920, 5.27969);\n            cam_up_vec = vec3(-0.00420, 0.99872, 0.05023);\n            break;\n        case 885:\n            cam_pos = vec3(-0.39018, 2.14003, 5.29535);\n            cam_up_vec = vec3(-0.00379, 0.99900, 0.04444);\n            break;\n        case 886:\n            cam_pos = vec3(-0.37977, 2.11638, 5.28006);\n            cam_up_vec = vec3(-0.00330, 0.99921, 0.03958);\n            break;\n        case 887:\n            cam_pos = vec3(-0.37005, 2.09435, 5.26562);\n            cam_up_vec = vec3(-0.00287, 0.99938, 0.03502);\n            break;\n        case 888:\n            cam_pos = vec3(-0.36078, 2.07340, 5.25172);\n            cam_up_vec = vec3(-0.00247, 0.99953, 0.03067);\n            break;\n        case 889:\n            cam_pos = vec3(-0.35185, 2.05322, 5.23816);\n            cam_up_vec = vec3(-0.00209, 0.99965, 0.02646);\n            break;\n        case 890:\n            cam_pos = vec3(-0.34315, 2.03364, 5.22485);\n            cam_up_vec = vec3(-0.00173, 0.99975, 0.02236);\n            break;\n        case 891:\n            cam_pos = vec3(-0.33465, 2.01452, 5.21169);\n            cam_up_vec = vec3(-0.00140, 0.99983, 0.01833);\n            break;\n        case 892:\n            cam_pos = vec3(-0.32629, 1.99576, 5.19864);\n            cam_up_vec = vec3(-0.00107, 0.99990, 0.01437);\n            break;\n        case 893:\n            cam_pos = vec3(-0.31804, 1.97729, 5.18566);\n            cam_up_vec = vec3(-0.00077, 0.99995, 0.01045);\n            break;\n        case 894:\n            cam_pos = vec3(-0.30989, 1.95907, 5.17270);\n            cam_up_vec = vec3(-0.00047, 0.99998, 0.00656);\n            break;\n        case 895:\n            cam_pos = vec3(-0.30182, 1.94105, 5.15975);\n            cam_up_vec = vec3(-0.00019, 1.00000, 0.00271);\n            break;\n        case 896:\n            cam_pos = vec3(-0.29381, 1.92319, 5.14678);\n            cam_up_vec = vec3(0.00008, 1.00000, -0.00113);\n            break;\n        case 897:\n            cam_pos = vec3(-0.28584, 1.90547, 5.13377);\n            cam_up_vec = vec3(0.00034, 0.99999, -0.00495);\n            break;\n        case 898:\n            cam_pos = vec3(-0.27791, 1.88786, 5.12070);\n            cam_up_vec = vec3(0.00059, 0.99996, -0.00877);\n            break;\n        case 899:\n            cam_pos = vec3(-0.27001, 1.87034, 5.10757);\n            cam_up_vec = vec3(0.00082, 0.99992, -0.01258);\n            break;\n        case 900:\n            cam_pos = vec3(-0.26213, 1.85289, 5.09436);\n            cam_up_vec = vec3(0.00105, 0.99987, -0.01639);\n            break;\n        case 901:\n            cam_pos = vec3(-0.25426, 1.83550, 5.08105);\n            cam_up_vec = vec3(0.00127, 0.99979, -0.02021);\n            break;\n        case 902:\n            cam_pos = vec3(-0.24640, 1.81815, 5.06764);\n            cam_up_vec = vec3(0.00148, 0.99971, -0.02403);\n            break;\n        case 903:\n            cam_pos = vec3(-0.23854, 1.80084, 5.05411);\n            cam_up_vec = vec3(0.00168, 0.99961, -0.02786);\n            break;\n        case 904:\n            cam_pos = vec3(-0.23068, 1.78354, 5.04046);\n            cam_up_vec = vec3(0.00187, 0.99950, -0.03170);\n            break;\n        case 905:\n            cam_pos = vec3(-0.22281, 1.76625, 5.02668);\n            cam_up_vec = vec3(0.00205, 0.99937, -0.03556);\n            break;\n        case 906:\n            cam_pos = vec3(-0.21492, 1.74896, 5.01275);\n            cam_up_vec = vec3(0.00222, 0.99922, -0.03943);\n            break;\n        case 907:\n            cam_pos = vec3(-0.20702, 1.73165, 4.99866);\n            cam_up_vec = vec3(0.00238, 0.99906, -0.04333);\n            break;\n        case 908:\n            cam_pos = vec3(-0.19910, 1.71433, 4.98442);\n            cam_up_vec = vec3(0.00253, 0.99888, -0.04724);\n            break;\n        case 909:\n            cam_pos = vec3(-0.19115, 1.69698, 4.97000);\n            cam_up_vec = vec3(0.00267, 0.99869, -0.05118);\n            break;\n        case 910:\n            cam_pos = vec3(-0.18317, 1.67959, 4.95540);\n            cam_up_vec = vec3(0.00280, 0.99847, -0.05514);\n            break;\n        case 911:\n            cam_pos = vec3(-0.17516, 1.66215, 4.94061);\n            cam_up_vec = vec3(0.00293, 0.99825, -0.05914);\n            break;\n        case 912:\n            cam_pos = vec3(-0.16711, 1.64466, 4.92561);\n            cam_up_vec = vec3(0.00304, 0.99800, -0.06316);\n            break;\n        case 913:\n            cam_pos = vec3(-0.15902, 1.62711, 4.91041);\n            cam_up_vec = vec3(0.00314, 0.99773, -0.06721);\n            break;\n        case 914:\n            cam_pos = vec3(-0.15089, 1.60948, 4.89498);\n            cam_up_vec = vec3(0.00323, 0.99745, -0.07131);\n            break;\n        case 915:\n            cam_pos = vec3(-0.14271, 1.59178, 4.87932);\n            cam_up_vec = vec3(0.00331, 0.99715, -0.07543);\n            break;\n        case 916:\n            cam_pos = vec3(-0.13447, 1.57399, 4.86341);\n            cam_up_vec = vec3(0.00338, 0.99682, -0.07960);\n            break;\n        case 917:\n            cam_pos = vec3(-0.12618, 1.55610, 4.84724);\n            cam_up_vec = vec3(0.00344, 0.99648, -0.08381);\n            break;\n        case 918:\n            cam_pos = vec3(-0.11782, 1.53811, 4.83079);\n            cam_up_vec = vec3(0.00348, 0.99611, -0.08807);\n            break;\n        case 919:\n            cam_pos = vec3(-0.10940, 1.52001, 4.81406);\n            cam_up_vec = vec3(0.00352, 0.99572, -0.09238);\n            break;\n        case 920:\n            cam_pos = vec3(-0.10091, 1.50178, 4.79703);\n            cam_up_vec = vec3(0.00354, 0.99530, -0.09673);\n            break;\n        case 921:\n            cam_pos = vec3(-0.09234, 1.48341, 4.77968);\n            cam_up_vec = vec3(0.00354, 0.99487, -0.10115);\n            break;\n        case 922:\n            cam_pos = vec3(-0.08370, 1.46490, 4.76199);\n            cam_up_vec = vec3(0.00354, 0.99440, -0.10562);\n            break;\n        case 923:\n            cam_pos = vec3(-0.07496, 1.44623, 4.74394);\n            cam_up_vec = vec3(0.00352, 0.99391, -0.11015);\n            break;\n        case 924:\n            cam_pos = vec3(-0.06613, 1.42738, 4.72551);\n            cam_up_vec = vec3(0.00348, 0.99339, -0.11475);\n            break;\n        case 925:\n            cam_pos = vec3(-0.05720, 1.40836, 4.70669);\n            cam_up_vec = vec3(0.00343, 0.99284, -0.11942);\n            break;\n        case 926:\n            cam_pos = vec3(-0.04816, 1.38913, 4.68743);\n            cam_up_vec = vec3(0.00337, 0.99226, -0.12416);\n            break;\n        case 927:\n            cam_pos = vec3(-0.03901, 1.36968, 4.66772);\n            cam_up_vec = vec3(0.00328, 0.99164, -0.12899);\n            break;\n        case 928:\n            cam_pos = vec3(-0.02973, 1.35000, 4.64752);\n            cam_up_vec = vec3(0.00318, 0.99099, -0.13391);\n            break;\n        case 929:\n            cam_pos = vec3(-0.02032, 1.33006, 4.62680);\n            cam_up_vec = vec3(0.00306, 0.99030, -0.13892);\n            break;\n        case 930:\n            cam_pos = vec3(-0.01075, 1.30984, 4.60552);\n            cam_up_vec = vec3(0.00292, 0.98957, -0.14403);\n            break;\n        case 931:\n            cam_pos = vec3(-0.00103, 1.28932, 4.58364);\n            cam_up_vec = vec3(0.00275, 0.98880, -0.14925);\n            break;\n        case 932:\n            cam_pos = vec3(0.00887, 1.26846, 4.56110);\n            cam_up_vec = vec3(0.00257, 0.98797, -0.15459);\n            break;\n        case 933:\n            cam_pos = vec3(0.01896, 1.24723, 4.53784);\n            cam_up_vec = vec3(0.00235, 0.98710, -0.16007);\n            break;\n        case 934:\n            cam_pos = vec3(0.02925, 1.22560, 4.51381);\n            cam_up_vec = vec3(0.00211, 0.98618, -0.16569);\n            break;\n        case 935:\n            cam_pos = vec3(0.03978, 1.20351, 4.48891);\n            cam_up_vec = vec3(0.00184, 0.98519, -0.17147);\n            break;\n        case 936:\n            cam_pos = vec3(0.05058, 1.18092, 4.46307);\n            cam_up_vec = vec3(0.00154, 0.98413, -0.17742);\n            break;\n        case 937:\n            cam_pos = vec3(0.06166, 1.15775, 4.43616);\n            cam_up_vec = vec3(0.00120, 0.98300, -0.18358);\n            break;\n        case 938:\n            cam_pos = vec3(0.07307, 1.13394, 4.40805);\n            cam_up_vec = vec3(0.00082, 0.98179, -0.18996);\n            break;\n        case 939:\n            cam_pos = vec3(0.08486, 1.10939, 4.37859);\n            cam_up_vec = vec3(0.00040, 0.98049, -0.19659);\n            break;\n        case 940:\n            cam_pos = vec3(0.09709, 1.08397, 4.34756);\n            cam_up_vec = vec3(-0.00008, 0.97907, -0.20352);\n            break;\n        case 941:\n            cam_pos = vec3(0.10983, 1.05754, 4.31470);\n            cam_up_vec = vec3(-0.00062, 0.97753, -0.21080);\n            break;\n        case 942:\n            cam_pos = vec3(0.12318, 1.02988, 4.27966);\n            cam_up_vec = vec3(-0.00123, 0.97584, -0.21849);\n            break;\n        case 943:\n            cam_pos = vec3(0.13730, 1.00072, 4.24195);\n            cam_up_vec = vec3(-0.00193, 0.97396, -0.22670);\n            break;\n        case 944:\n            cam_pos = vec3(0.15236, 0.96966, 4.20089);\n            cam_up_vec = vec3(-0.00274, 0.97186, -0.23554);\n            break;\n        case 945:\n            cam_pos = vec3(0.16869, 0.93608, 4.15540);\n            cam_up_vec = vec3(-0.00369, 0.96946, -0.24523);\n            break;\n        case 946:\n            cam_pos = vec3(0.18680, 0.89892, 4.10371);\n            cam_up_vec = vec3(-0.00484, 0.96663, -0.25611);\n            break;\n        case 947:\n            cam_pos = vec3(0.20769, 0.85616, 4.04235);\n            cam_up_vec = vec3(-0.00630, 0.96316, -0.26886);\n            break;\n        case 948:\n            cam_pos = vec3(0.23399, 0.80254, 3.96235);\n            cam_up_vec = vec3(-0.00835, 0.95843, -0.28521);\n            break;\n        case 949:\n            cam_pos = vec3(0.29307, 0.68282, 3.76987);\n            cam_up_vec = vec3(-0.01393, 0.94616, -0.32338);\n            break;\n        case 950:\n            cam_pos = vec3(3.73702, 1.31688, 1.97586);\n            cam_up_vec = vec3(-0.14170, 0.98684, -0.07279);\n            break;\n        case 951:\n            cam_pos = vec3(3.74971, 1.33127, 1.94776);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 952:\n            cam_pos = vec3(3.72918, 1.33965, 1.93674);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 953:\n            cam_pos = vec3(3.70864, 1.34802, 1.92572);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 954:\n            cam_pos = vec3(3.68811, 1.35640, 1.91471);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 955:\n            cam_pos = vec3(3.66758, 1.36478, 1.90369);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 956:\n            cam_pos = vec3(3.64705, 1.37316, 1.89268);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 957:\n            cam_pos = vec3(3.62651, 1.38154, 1.88166);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 958:\n            cam_pos = vec3(3.60598, 1.38991, 1.87065);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 959:\n            cam_pos = vec3(3.58545, 1.39829, 1.85963);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 960:\n            cam_pos = vec3(3.56492, 1.40667, 1.84861);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 961:\n            cam_pos = vec3(3.54438, 1.41505, 1.83760);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 962:\n            cam_pos = vec3(3.52385, 1.42342, 1.82658);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 963:\n            cam_pos = vec3(3.50332, 1.43180, 1.81557);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 964:\n            cam_pos = vec3(3.48279, 1.44018, 1.80455);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 965:\n            cam_pos = vec3(3.46225, 1.44856, 1.79354);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 966:\n            cam_pos = vec3(3.44172, 1.45694, 1.78252);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 967:\n            cam_pos = vec3(3.42119, 1.46531, 1.77151);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 968:\n            cam_pos = vec3(3.40065, 1.47369, 1.76049);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 969:\n            cam_pos = vec3(3.38012, 1.48207, 1.74947);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 970:\n            cam_pos = vec3(3.35959, 1.49045, 1.73846);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 971:\n            cam_pos = vec3(3.33906, 1.49882, 1.72744);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 972:\n            cam_pos = vec3(3.31852, 1.50720, 1.71643);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 973:\n            cam_pos = vec3(3.29799, 1.51558, 1.70541);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 974:\n            cam_pos = vec3(3.27746, 1.52396, 1.69440);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 975:\n            cam_pos = vec3(3.25693, 1.53234, 1.68338);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 976:\n            cam_pos = vec3(3.23639, 1.54071, 1.67236);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 977:\n            cam_pos = vec3(3.21586, 1.54909, 1.66135);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 978:\n            cam_pos = vec3(3.19533, 1.55747, 1.65033);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 979:\n            cam_pos = vec3(3.17480, 1.56585, 1.63932);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 980:\n            cam_pos = vec3(3.15426, 1.57422, 1.62830);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 981:\n            cam_pos = vec3(3.13373, 1.58260, 1.61729);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 982:\n            cam_pos = vec3(3.11320, 1.59098, 1.60627);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 983:\n            cam_pos = vec3(3.09267, 1.59936, 1.59525);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 984:\n            cam_pos = vec3(3.07213, 1.60774, 1.58424);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 985:\n            cam_pos = vec3(3.05160, 1.61611, 1.57322);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 986:\n            cam_pos = vec3(3.03107, 1.62449, 1.56221);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 987:\n            cam_pos = vec3(3.01054, 1.63287, 1.55119);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 988:\n            cam_pos = vec3(2.99000, 1.64125, 1.54018);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 989:\n            cam_pos = vec3(2.96947, 1.64962, 1.52916);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 990:\n            cam_pos = vec3(2.94894, 1.65800, 1.51815);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 991:\n            cam_pos = vec3(2.92841, 1.66638, 1.50713);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 992:\n            cam_pos = vec3(2.90787, 1.67476, 1.49611);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 993:\n            cam_pos = vec3(2.88734, 1.68314, 1.48510);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 994:\n            cam_pos = vec3(2.86681, 1.69151, 1.47408);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 995:\n            cam_pos = vec3(2.84627, 1.69989, 1.46307);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 996:\n            cam_pos = vec3(2.82574, 1.70827, 1.45205);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 997:\n            cam_pos = vec3(2.80521, 1.71665, 1.44104);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 998:\n            cam_pos = vec3(2.78468, 1.72502, 1.43002);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 999:\n            cam_pos = vec3(2.76414, 1.73340, 1.41900);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1000:\n            cam_pos = vec3(2.74361, 1.74178, 1.40799);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1001:\n            cam_pos = vec3(2.72308, 1.75016, 1.39697);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1002:\n            cam_pos = vec3(2.70255, 1.75854, 1.38596);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1003:\n            cam_pos = vec3(2.68201, 1.76691, 1.37494);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1004:\n            cam_pos = vec3(2.66148, 1.77529, 1.36393);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1005:\n            cam_pos = vec3(2.64095, 1.78367, 1.35291);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1006:\n            cam_pos = vec3(2.62042, 1.79205, 1.34190);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1007:\n            cam_pos = vec3(2.59988, 1.80042, 1.33088);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1008:\n            cam_pos = vec3(2.57935, 1.80880, 1.31986);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1009:\n            cam_pos = vec3(2.55882, 1.81718, 1.30885);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1010:\n            cam_pos = vec3(2.53829, 1.82556, 1.29783);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1011:\n            cam_pos = vec3(2.51775, 1.83394, 1.28682);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1012:\n            cam_pos = vec3(2.49722, 1.84231, 1.27580);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1013:\n            cam_pos = vec3(2.47669, 1.85069, 1.26479);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1014:\n            cam_pos = vec3(2.45616, 1.85907, 1.25377);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1015:\n            cam_pos = vec3(2.43562, 1.86745, 1.24275);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1016:\n            cam_pos = vec3(2.41509, 1.87582, 1.23174);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1017:\n            cam_pos = vec3(2.39456, 1.88420, 1.22072);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1018:\n            cam_pos = vec3(2.37403, 1.89258, 1.20971);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1019:\n            cam_pos = vec3(2.35349, 1.90096, 1.19869);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1020:\n            cam_pos = vec3(2.33296, 1.90934, 1.18768);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1021:\n            cam_pos = vec3(2.31243, 1.91771, 1.17666);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1022:\n            cam_pos = vec3(2.29189, 1.92609, 1.16564);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1023:\n            cam_pos = vec3(2.27136, 1.93447, 1.15463);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1024:\n            cam_pos = vec3(2.25083, 1.94285, 1.14361);\n            cam_up_vec = vec3(-0.14293, 0.98723, -0.07039);\n            break;\n        case 1025:\n            cam_pos = vec3(0.75697, 2.41493, 5.13841);\n            cam_up_vec = vec3(0.00024, 0.99908, 0.03882);\n            break;\n        case 1026:\n            cam_pos = vec3(0.73052, 2.45845, 5.04032);\n            cam_up_vec = vec3(0.00212, 0.99876, 0.04970);\n            break;\n        case 1027:\n            cam_pos = vec3(0.71686, 2.50329, 4.86397);\n            cam_up_vec = vec3(0.00261, 0.99807, 0.06199);\n            break;\n        case 1028:\n            cam_pos = vec3(0.70221, 2.54723, 4.67112);\n            cam_up_vec = vec3(0.00312, 0.99715, 0.07538);\n            break;\n        case 1029:\n            cam_pos = vec3(0.68746, 2.58690, 4.47293);\n            cam_up_vec = vec3(0.00362, 0.99602, 0.08909);\n            break;\n        case 1030:\n            cam_pos = vec3(0.67310, 2.62086, 4.27608);\n            cam_up_vec = vec3(0.00410, 0.99471, 0.10266);\n            break;\n        case 1031:\n            cam_pos = vec3(0.65943, 2.64871, 4.08470);\n            cam_up_vec = vec3(0.00454, 0.99326, 0.11582);\n            break;\n        case 1032:\n            cam_pos = vec3(0.64659, 2.67065, 3.90138);\n            cam_up_vec = vec3(0.00495, 0.99171, 0.12840);\n            break;\n        case 1033:\n            cam_pos = vec3(0.63466, 2.68717, 3.72775);\n            cam_up_vec = vec3(0.00532, 0.99009, 0.14029);\n            break;\n        case 1034:\n            cam_pos = vec3(0.62366, 2.69891, 3.56479);\n            cam_up_vec = vec3(0.00565, 0.98845, 0.15144);\n            break;\n        case 1035:\n            cam_pos = vec3(0.61360, 2.70658, 3.41309);\n            cam_up_vec = vec3(0.00595, 0.98681, 0.16180);\n            break;\n        case 1036:\n            cam_pos = vec3(0.60444, 2.71086, 3.27293);\n            cam_up_vec = vec3(0.00621, 0.98519, 0.17136);\n            break;\n        case 1037:\n            cam_pos = vec3(0.59618, 2.71243, 3.14439);\n            cam_up_vec = vec3(0.00644, 0.98362, 0.18013);\n            break;\n        case 1038:\n            cam_pos = vec3(0.58876, 2.71188, 3.02745);\n            cam_up_vec = vec3(0.00665, 0.98213, 0.18810);\n            break;\n        case 1039:\n            cam_pos = vec3(0.58215, 2.70977, 2.92196);\n            cam_up_vec = vec3(0.00683, 0.98072, 0.19529);\n            break;\n        case 1040:\n            cam_pos = vec3(0.57631, 2.70660, 2.82774);\n            cam_up_vec = vec3(0.00698, 0.97942, 0.20171);\n            break;\n        case 1041:\n            cam_pos = vec3(0.57120, 2.70277, 2.74454);\n            cam_up_vec = vec3(0.00711, 0.97823, 0.20738);\n            break;\n        case 1042:\n            cam_pos = vec3(0.56680, 2.69866, 2.67212);\n            cam_up_vec = vec3(0.00723, 0.97717, 0.21232);\n            break;\n        case 1043:\n            cam_pos = vec3(0.56307, 2.69457, 2.61020);\n            cam_up_vec = vec3(0.00732, 0.97625, 0.21654);\n            break;\n        case 1044:\n            cam_pos = vec3(0.55997, 2.69074, 2.55852);\n            cam_up_vec = vec3(0.00740, 0.97546, 0.22006);\n            break;\n        case 1045:\n            cam_pos = vec3(0.55748, 2.68738, 2.51679);\n            cam_up_vec = vec3(0.00746, 0.97481, 0.22290);\n            break;\n        case 1046:\n            cam_pos = vec3(0.55558, 2.68464, 2.48475);\n            cam_up_vec = vec3(0.00751, 0.97431, 0.22509);\n            break;\n        case 1047:\n            cam_pos = vec3(0.55424, 2.68261, 2.46215);\n            cam_up_vec = vec3(0.00754, 0.97395, 0.22663);\n            break;\n        case 1048:\n            cam_pos = vec3(0.55345, 2.68138, 2.44872);\n            cam_up_vec = vec3(0.00756, 0.97374, 0.22754);\n            break;\n        case 1049:\n            cam_pos = vec3(0.55319, 2.68096, 2.44423);\n            cam_up_vec = vec3(0.00756, 0.97367, 0.22785);\n            break;\n        case 1050:\n            cam_pos = vec3(3.69813, 0.96564, 3.97664);\n            cam_up_vec = vec3(-0.11132, 0.98861, -0.09484);\n            break;\n        case 1051:\n            cam_pos = vec3(3.73937, 0.94744, 3.98386);\n            cam_up_vec = vec3(-0.11281, 0.98877, -0.09801);\n            break;\n        case 1052:\n            cam_pos = vec3(3.74730, 0.94744, 3.97471);\n            cam_up_vec = vec3(-0.11304, 0.98877, -0.09775);\n            break;\n        case 1053:\n            cam_pos = vec3(3.75521, 0.94744, 3.96554);\n            cam_up_vec = vec3(-0.11327, 0.98877, -0.09748);\n            break;\n        case 1054:\n            cam_pos = vec3(3.76310, 0.94744, 3.95635);\n            cam_up_vec = vec3(-0.11349, 0.98877, -0.09722);\n            break;\n        case 1055:\n            cam_pos = vec3(3.77097, 0.94744, 3.94714);\n            cam_up_vec = vec3(-0.11372, 0.98877, -0.09695);\n            break;\n        case 1056:\n            cam_pos = vec3(3.77882, 0.94744, 3.93791);\n            cam_up_vec = vec3(-0.11395, 0.98877, -0.09669);\n            break;\n        case 1057:\n            cam_pos = vec3(3.78665, 0.94744, 3.92867);\n            cam_up_vec = vec3(-0.11417, 0.98877, -0.09642);\n            break;\n        case 1058:\n            cam_pos = vec3(3.79445, 0.94744, 3.91940);\n            cam_up_vec = vec3(-0.11440, 0.98877, -0.09615);\n            break;\n        case 1059:\n            cam_pos = vec3(3.80223, 0.94744, 3.91012);\n            cam_up_vec = vec3(-0.11462, 0.98877, -0.09589);\n            break;\n        case 1060:\n            cam_pos = vec3(3.81000, 0.94744, 3.90082);\n            cam_up_vec = vec3(-0.11484, 0.98877, -0.09562);\n            break;\n        case 1061:\n            cam_pos = vec3(3.81773, 0.94744, 3.89151);\n            cam_up_vec = vec3(-0.11507, 0.98877, -0.09535);\n            break;\n        case 1062:\n            cam_pos = vec3(3.82545, 0.94744, 3.88217);\n            cam_up_vec = vec3(-0.11529, 0.98877, -0.09508);\n            break;\n        case 1063:\n            cam_pos = vec3(3.83315, 0.94744, 3.87282);\n            cam_up_vec = vec3(-0.11551, 0.98877, -0.09481);\n            break;\n        case 1064:\n            cam_pos = vec3(3.84082, 0.94744, 3.86344);\n            cam_up_vec = vec3(-0.11573, 0.98877, -0.09454);\n            break;\n        case 1065:\n            cam_pos = vec3(3.84847, 0.94744, 3.85406);\n            cam_up_vec = vec3(-0.11595, 0.98877, -0.09427);\n            break;\n        case 1066:\n            cam_pos = vec3(3.85610, 0.94744, 3.84465);\n            cam_up_vec = vec3(-0.11617, 0.98877, -0.09400);\n            break;\n        case 1067:\n            cam_pos = vec3(3.86371, 0.94744, 3.83522);\n            cam_up_vec = vec3(-0.11639, 0.98877, -0.09373);\n            break;\n        case 1068:\n            cam_pos = vec3(3.87130, 0.94744, 3.82578);\n            cam_up_vec = vec3(-0.11661, 0.98877, -0.09346);\n            break;\n        case 1069:\n            cam_pos = vec3(3.87886, 0.94744, 3.81632);\n            cam_up_vec = vec3(-0.11683, 0.98877, -0.09319);\n            break;\n        case 1070:\n            cam_pos = vec3(3.88640, 0.94744, 3.80684);\n            cam_up_vec = vec3(-0.11704, 0.98877, -0.09291);\n            break;\n        case 1071:\n            cam_pos = vec3(3.89393, 0.94744, 3.79735);\n            cam_up_vec = vec3(-0.11726, 0.98877, -0.09264);\n            break;\n        case 1072:\n            cam_pos = vec3(3.90142, 0.94744, 3.78783);\n            cam_up_vec = vec3(-0.11747, 0.98877, -0.09237);\n            break;\n        case 1073:\n            cam_pos = vec3(3.90890, 0.94744, 3.77830);\n            cam_up_vec = vec3(-0.11769, 0.98877, -0.09209);\n            break;\n        case 1074:\n            cam_pos = vec3(3.91635, 0.94744, 3.76876);\n            cam_up_vec = vec3(-0.11790, 0.98877, -0.09182);\n            break;\n        case 1075:\n            cam_pos = vec3(3.92378, 0.94744, 3.75919);\n            cam_up_vec = vec3(-0.11812, 0.98877, -0.09154);\n            break;\n        case 1076:\n            cam_pos = vec3(3.93119, 0.94744, 3.74961);\n            cam_up_vec = vec3(-0.11833, 0.98877, -0.09127);\n            break;\n        case 1077:\n            cam_pos = vec3(3.93858, 0.94744, 3.74001);\n            cam_up_vec = vec3(-0.11854, 0.98877, -0.09099);\n            break;\n        case 1078:\n            cam_pos = vec3(3.94594, 0.94744, 3.73039);\n            cam_up_vec = vec3(-0.11876, 0.98877, -0.09071);\n            break;\n        case 1079:\n            cam_pos = vec3(3.95328, 0.94744, 3.72076);\n            cam_up_vec = vec3(-0.11897, 0.98877, -0.09043);\n            break;\n        case 1080:\n            cam_pos = vec3(3.96060, 0.94744, 3.71110);\n            cam_up_vec = vec3(-0.11918, 0.98877, -0.09016);\n            break;\n        case 1081:\n            cam_pos = vec3(1.57752, 0.69410, 4.14448);\n            cam_up_vec = vec3(0.01144, 0.99943, 0.02583);\n            break;\n        case 1082:\n            cam_pos = vec3(1.55063, 0.69476, 4.14861);\n            cam_up_vec = vec3(0.01233, 0.99955, 0.02723);\n            break;\n        case 1083:\n            cam_pos = vec3(1.54975, 0.69834, 4.14798);\n            cam_up_vec = vec3(0.01177, 0.99956, 0.02737);\n            break;\n        case 1084:\n            cam_pos = vec3(1.54884, 0.70203, 4.14733);\n            cam_up_vec = vec3(0.01119, 0.99956, 0.02751);\n            break;\n        case 1085:\n            cam_pos = vec3(1.54790, 0.70585, 4.14666);\n            cam_up_vec = vec3(0.01060, 0.99956, 0.02765);\n            break;\n        case 1086:\n            cam_pos = vec3(1.54693, 0.70979, 4.14596);\n            cam_up_vec = vec3(0.00998, 0.99956, 0.02780);\n            break;\n        case 1087:\n            cam_pos = vec3(1.54592, 0.71385, 4.14525);\n            cam_up_vec = vec3(0.00935, 0.99957, 0.02795);\n            break;\n        case 1088:\n            cam_pos = vec3(1.54488, 0.71805, 4.14451);\n            cam_up_vec = vec3(0.00869, 0.99957, 0.02811);\n            break;\n        case 1089:\n            cam_pos = vec3(1.54381, 0.72238, 4.14374);\n            cam_up_vec = vec3(0.00801, 0.99957, 0.02828);\n            break;\n        case 1090:\n            cam_pos = vec3(1.54270, 0.72684, 4.14296);\n            cam_up_vec = vec3(0.00732, 0.99957, 0.02844);\n            break;\n        case 1091:\n            cam_pos = vec3(1.54156, 0.73144, 4.14214);\n            cam_up_vec = vec3(0.00660, 0.99957, 0.02861);\n            break;\n        case 1092:\n            cam_pos = vec3(1.54038, 0.73619, 4.14131);\n            cam_up_vec = vec3(0.00586, 0.99957, 0.02879);\n            break;\n        case 1093:\n            cam_pos = vec3(1.53917, 0.74108, 4.14044);\n            cam_up_vec = vec3(0.00509, 0.99957, 0.02897);\n            break;\n        case 1094:\n            cam_pos = vec3(1.53791, 0.74612, 4.13955);\n            cam_up_vec = vec3(0.00430, 0.99957, 0.02916);\n            break;\n        case 1095:\n            cam_pos = vec3(1.53662, 0.75132, 4.13863);\n            cam_up_vec = vec3(0.00349, 0.99956, 0.02935);\n            break;\n        case 1096:\n            cam_pos = vec3(1.53528, 0.75668, 4.13769);\n            cam_up_vec = vec3(0.00265, 0.99956, 0.02955);\n            break;\n        case 1097:\n            cam_pos = vec3(1.53390, 0.76219, 4.13671);\n            cam_up_vec = vec3(0.00179, 0.99956, 0.02975);\n            break;\n        case 1098:\n            cam_pos = vec3(1.53248, 0.76788, 4.13570);\n            cam_up_vec = vec3(0.00090, 0.99955, 0.02996);\n            break;\n        case 1099:\n            cam_pos = vec3(1.53102, 0.77374, 4.13467);\n            cam_up_vec = vec3(-0.00002, 0.99954, 0.03017);\n            break;\n        case 1100:\n            cam_pos = vec3(1.52950, 0.77978, 4.13360);\n            cam_up_vec = vec3(-0.00097, 0.99954, 0.03039);\n            break;\n        case 1101:\n            cam_pos = vec3(1.52794, 0.78600, 4.13250);\n            cam_up_vec = vec3(-0.00194, 0.99953, 0.03061);\n            break;\n        case 1102:\n            cam_pos = vec3(1.52633, 0.79240, 4.13136);\n            cam_up_vec = vec3(-0.00294, 0.99952, 0.03084);\n            break;\n        case 1103:\n            cam_pos = vec3(1.52467, 0.79900, 4.13019);\n            cam_up_vec = vec3(-0.00398, 0.99951, 0.03108);\n            break;\n        case 1104:\n            cam_pos = vec3(1.52295, 0.80580, 4.12899);\n            cam_up_vec = vec3(-0.00505, 0.99950, 0.03132);\n            break;\n        case 1105:\n            cam_pos = vec3(1.52119, 0.81281, 4.12775);\n            cam_up_vec = vec3(-0.00614, 0.99948, 0.03157);\n            break;\n        case 1106:\n            cam_pos = vec3(1.51936, 0.82003, 4.12647);\n            cam_up_vec = vec3(-0.00728, 0.99947, 0.03182);\n            break;\n        case 1107:\n            cam_pos = vec3(1.51748, 0.82746, 4.12514);\n            cam_up_vec = vec3(-0.00844, 0.99945, 0.03208);\n            break;\n        case 1108:\n            cam_pos = vec3(1.51554, 0.83512, 4.12379);\n            cam_up_vec = vec3(-0.00965, 0.99943, 0.03234);\n            break;\n        case 1109:\n            cam_pos = vec3(1.51353, 0.84301, 4.12238);\n            cam_up_vec = vec3(-0.01088, 0.99941, 0.03262);\n            break;\n        case 1110:\n            cam_pos = vec3(1.51146, 0.85115, 4.12094);\n            cam_up_vec = vec3(-0.01216, 0.99938, 0.03289);\n            break;\n        case 1111:\n            cam_pos = vec3(1.50932, 0.85953, 4.11945);\n            cam_up_vec = vec3(-0.01348, 0.99936, 0.03318);\n            break;\n        case 1112:\n            cam_pos = vec3(1.50712, 0.86816, 4.11791);\n            cam_up_vec = vec3(-0.01484, 0.99933, 0.03347);\n            break;\n        case 1113:\n            cam_pos = vec3(1.50484, 0.87707, 4.11632);\n            cam_up_vec = vec3(-0.01623, 0.99930, 0.03377);\n            break;\n        case 1114:\n            cam_pos = vec3(1.50249, 0.88624, 4.11469);\n            cam_up_vec = vec3(-0.01768, 0.99926, 0.03408);\n            break;\n        case 1115:\n            cam_pos = vec3(1.50006, 0.89570, 4.11300);\n            cam_up_vec = vec3(-0.01917, 0.99922, 0.03439);\n            break;\n        case 1116:\n            cam_pos = vec3(1.49755, 0.90545, 4.11126);\n            cam_up_vec = vec3(-0.02070, 0.99918, 0.03471);\n            break;\n        case 1117:\n            cam_pos = vec3(1.49495, 0.91551, 4.10946);\n            cam_up_vec = vec3(-0.02228, 0.99914, 0.03504);\n            break;\n        case 1118:\n            cam_pos = vec3(1.49228, 0.92588, 4.10761);\n            cam_up_vec = vec3(-0.02392, 0.99909, 0.03538);\n            break;\n        case 1119:\n            cam_pos = vec3(1.48950, 0.93657, 4.10570);\n            cam_up_vec = vec3(-0.02560, 0.99903, 0.03572);\n            break;\n        case 1120:\n            cam_pos = vec3(1.48664, 0.94760, 4.10372);\n            cam_up_vec = vec3(-0.02734, 0.99898, 0.03607);\n            break;\n        case 1121:\n            cam_pos = vec3(1.48368, 0.95899, 4.10169);\n            cam_up_vec = vec3(-0.02913, 0.99891, 0.03643);\n            break;\n        case 1122:\n            cam_pos = vec3(1.48061, 0.97073, 4.09958);\n            cam_up_vec = vec3(-0.03098, 0.99884, 0.03679);\n            break;\n        case 1123:\n            cam_pos = vec3(1.47744, 0.98285, 4.09741);\n            cam_up_vec = vec3(-0.03290, 0.99877, 0.03717);\n            break;\n        case 1124:\n            cam_pos = vec3(1.47417, 0.99536, 4.09516);\n            cam_up_vec = vec3(-0.03487, 0.99869, 0.03755);\n            break;\n        case 1125:\n            cam_pos = vec3(1.47077, 1.00827, 4.09284);\n            cam_up_vec = vec3(-0.03691, 0.99860, 0.03794);\n            break;\n        case 1126:\n            cam_pos = vec3(1.46726, 1.02159, 4.09044);\n            cam_up_vec = vec3(-0.03901, 0.99850, 0.03834);\n            break;\n        case 1127:\n            cam_pos = vec3(1.46362, 1.03535, 4.08796);\n            cam_up_vec = vec3(-0.04118, 0.99840, 0.03874);\n            break;\n        case 1128:\n            cam_pos = vec3(1.45985, 1.04956, 4.08540);\n            cam_up_vec = vec3(-0.04343, 0.99829, 0.03916);\n            break;\n        case 1129:\n            cam_pos = vec3(1.45595, 1.06424, 4.08275);\n            cam_up_vec = vec3(-0.04575, 0.99817, 0.03958);\n            break;\n        case 1130:\n            cam_pos = vec3(1.45191, 1.07939, 4.08001);\n            cam_up_vec = vec3(-0.04815, 0.99804, 0.04001);\n            break;\n        case 1131:\n            cam_pos = vec3(1.44773, 1.09504, 4.07718);\n            cam_up_vec = vec3(-0.05062, 0.99790, 0.04045);\n            break;\n        case 1132:\n            cam_pos = vec3(1.44339, 1.11120, 4.07425);\n            cam_up_vec = vec3(-0.05318, 0.99775, 0.04089);\n            break;\n        case 1133:\n            cam_pos = vec3(1.43889, 1.12789, 4.07123);\n            cam_up_vec = vec3(-0.05582, 0.99758, 0.04134);\n            break;\n        case 1134:\n            cam_pos = vec3(1.43424, 1.14512, 4.06810);\n            cam_up_vec = vec3(-0.05855, 0.99741, 0.04180);\n            break;\n        case 1135:\n            cam_pos = vec3(1.42942, 1.16291, 4.06486);\n            cam_up_vec = vec3(-0.06137, 0.99722, 0.04226);\n            break;\n        case 1136:\n            cam_pos = vec3(1.42442, 1.18126, 4.06152);\n            cam_up_vec = vec3(-0.06428, 0.99702, 0.04273);\n            break;\n        case 1137:\n            cam_pos = vec3(1.41925, 1.20020, 4.05806);\n            cam_up_vec = vec3(-0.06728, 0.99680, 0.04321);\n            break;\n        case 1138:\n            cam_pos = vec3(1.41390, 1.21973, 4.05449);\n            cam_up_vec = vec3(-0.07037, 0.99656, 0.04369);\n            break;\n        case 1139:\n            cam_pos = vec3(1.40836, 1.23985, 4.05081);\n            cam_up_vec = vec3(-0.07357, 0.99631, 0.04417);\n            break;\n        case 1140:\n            cam_pos = vec3(1.40263, 1.26058, 4.04701);\n            cam_up_vec = vec3(-0.07686, 0.99604, 0.04466);\n            break;\n        case 1141:\n            cam_pos = vec3(1.39672, 1.28190, 4.04309);\n            cam_up_vec = vec3(-0.08024, 0.99575, 0.04515);\n            break;\n        case 1142:\n            cam_pos = vec3(1.39061, 1.30381, 4.03906);\n            cam_up_vec = vec3(-0.08372, 0.99544, 0.04564);\n            break;\n        case 1143:\n            cam_pos = vec3(1.38432, 1.32631, 4.03491);\n            cam_up_vec = vec3(-0.08729, 0.99511, 0.04613);\n            break;\n        case 1144:\n            cam_pos = vec3(1.37785, 1.34935, 4.03065);\n            cam_up_vec = vec3(-0.09095, 0.99476, 0.04662);\n            break;\n        case 1145:\n            cam_pos = vec3(1.37120, 1.37293, 4.02629);\n            cam_up_vec = vec3(-0.09470, 0.99439, 0.04710);\n            break;\n        case 1146:\n            cam_pos = vec3(1.36437, 1.39701, 4.02182);\n            cam_up_vec = vec3(-0.09852, 0.99400, 0.04758);\n            break;\n        case 1147:\n            cam_pos = vec3(1.35739, 1.42153, 4.01726);\n            cam_up_vec = vec3(-0.10242, 0.99358, 0.04805);\n            break;\n        case 1148:\n            cam_pos = vec3(1.35026, 1.44644, 4.01262);\n            cam_up_vec = vec3(-0.10638, 0.99314, 0.04851);\n            break;\n        case 1149:\n            cam_pos = vec3(1.34300, 1.47169, 4.00790);\n            cam_up_vec = vec3(-0.11039, 0.99268, 0.04896);\n            break;\n        case 1150:\n            cam_pos = vec3(1.33564, 1.49718, 4.00312);\n            cam_up_vec = vec3(-0.11444, 0.99220, 0.04939);\n            break;\n        case 1151:\n            cam_pos = vec3(1.32820, 1.52285, 3.99830);\n            cam_up_vec = vec3(-0.11852, 0.99170, 0.04981);\n            break;\n        case 1152:\n            cam_pos = vec3(1.32069, 1.54861, 3.99345);\n            cam_up_vec = vec3(-0.12261, 0.99118, 0.05022);\n            break;\n        case 1153:\n            cam_pos = vec3(1.31315, 1.57436, 3.98859);\n            cam_up_vec = vec3(-0.12671, 0.99065, 0.05060);\n            break;\n        case 1154:\n            cam_pos = vec3(1.30561, 1.60000, 3.98374);\n            cam_up_vec = vec3(-0.13078, 0.99010, 0.05097);\n            break;\n        case 1155:\n            cam_pos = vec3(1.29809, 1.62546, 3.97891);\n            cam_up_vec = vec3(-0.13482, 0.98954, 0.05131);\n            break;\n        case 1156:\n            cam_pos = vec3(1.29062, 1.65063, 3.97412);\n            cam_up_vec = vec3(-0.13882, 0.98897, 0.05164);\n            break;\n        case 1157:\n            cam_pos = vec3(1.28323, 1.67543, 3.96939);\n            cam_up_vec = vec3(-0.14276, 0.98839, 0.05194);\n            break;\n        case 1158:\n            cam_pos = vec3(1.27594, 1.69979, 3.96474);\n            cam_up_vec = vec3(-0.14663, 0.98781, 0.05222);\n            break;\n        case 1159:\n            cam_pos = vec3(1.26877, 1.72363, 3.96017);\n            cam_up_vec = vec3(-0.15041, 0.98723, 0.05248);\n            break;\n        case 1160:\n            cam_pos = vec3(1.26175, 1.74689, 3.95570);\n            cam_up_vec = vec3(-0.15410, 0.98665, 0.05271);\n            break;\n        case 1161:\n            cam_pos = vec3(1.25489, 1.76954, 3.95133);\n            cam_up_vec = vec3(-0.15770, 0.98607, 0.05293);\n            break;\n        case 1162:\n            cam_pos = vec3(1.24820, 1.79152, 3.94709);\n            cam_up_vec = vec3(-0.16118, 0.98549, 0.05312);\n            break;\n        case 1163:\n            cam_pos = vec3(1.24170, 1.81282, 3.94296);\n            cam_up_vec = vec3(-0.16456, 0.98493, 0.05330);\n            break;\n        case 1164:\n            cam_pos = vec3(1.23540, 1.83341, 3.93897);\n            cam_up_vec = vec3(-0.16782, 0.98437, 0.05346);\n            break;\n        case 1165:\n            cam_pos = vec3(1.22929, 1.85329, 3.93511);\n            cam_up_vec = vec3(-0.17097, 0.98382, 0.05360);\n            break;\n        case 1166:\n            cam_pos = vec3(1.22338, 1.87244, 3.93137);\n            cam_up_vec = vec3(-0.17400, 0.98328, 0.05373);\n            break;\n        case 1167:\n            cam_pos = vec3(1.21769, 1.89087, 3.92778);\n            cam_up_vec = vec3(-0.17692, 0.98275, 0.05384);\n            break;\n        case 1168:\n            cam_pos = vec3(1.21219, 1.90859, 3.92431);\n            cam_up_vec = vec3(-0.17972, 0.98224, 0.05394);\n            break;\n        case 1169:\n            cam_pos = vec3(1.20690, 1.92560, 3.92097);\n            cam_up_vec = vec3(-0.18241, 0.98174, 0.05403);\n            break;\n        case 1170:\n            cam_pos = vec3(1.20180, 1.94194, 3.91776);\n            cam_up_vec = vec3(-0.18499, 0.98125, 0.05411);\n            break;\n        case 1171:\n            cam_pos = vec3(1.19691, 1.95760, 3.91468);\n            cam_up_vec = vec3(-0.18747, 0.98078, 0.05417);\n            break;\n        case 1172:\n            cam_pos = vec3(1.19220, 1.97261, 3.91172);\n            cam_up_vec = vec3(-0.18984, 0.98032, 0.05423);\n            break;\n        case 1173:\n            cam_pos = vec3(1.18768, 1.98700, 3.90888);\n            cam_up_vec = vec3(-0.19211, 0.97987, 0.05428);\n            break;\n        case 1174:\n            cam_pos = vec3(1.18335, 2.00077, 3.90616);\n            cam_up_vec = vec3(-0.19428, 0.97944, 0.05432);\n            break;\n        case 1175:\n            cam_pos = vec3(1.17918, 2.01396, 3.90355);\n            cam_up_vec = vec3(-0.19636, 0.97902, 0.05435);\n            break;\n        case 1176:\n            cam_pos = vec3(1.17520, 2.02658, 3.90104);\n            cam_up_vec = vec3(-0.19835, 0.97862, 0.05438);\n            break;\n        case 1177:\n            cam_pos = vec3(1.17137, 2.03865, 3.89864);\n            cam_up_vec = vec3(-0.20025, 0.97823, 0.05441);\n            break;\n        default:\n            cam_pos = vec3(1.16770, 2.05020, 3.89634);\n            cam_up_vec = vec3(-0.20207, 0.97786, 0.05442);\n            break;\n    }\n    cam_lookat = vec3( 0.0, 2.0, 0.0 );\n\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis) );\n    switch(idx) {\n        case 0: return vec4( cam_pos, 1.0 ); // Camera position.\n        case 1: return vec4( cam_x_axis, 0.0 ); // Camera x-axis.\n        case 2: return vec4( cam_y_axis, 0.0 ); // Camera y-axis.\n        case 3: return vec4( cam_z_axis, 0.0 ); // Camera z-axis.\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int idx = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    if ( idx < 4 ) {\n        fragColor = camera(idx);\n    } else {\n        discard;\n    }\n}\n", "buffer_b_inputs": [], "cube_a_code": "//============================================================================\n// PROJECT ID: 02\n//\n// GROUP NUMBER: 03\n//\n// STUDENT NAME: CHEN ZHIAN\n// NUS User ID.: t0933479\n//\n// STUDENT NAME: LI YIXIN\n// NUS User ID.: t0933820\n//\n// STUDENT NAME: OUYANG ANNAN\n// NUS User ID.: t0933394\n//\n// COMMENTS TO GRADER: This is the pass 3 shader which will output to the CubeA\n//                     in shadertoy. CubeA is the cube texture that will be used\n//                     as the environment map.\n//\n//                     We use multiple passes and this is only a part of tasks2.\n//                     There are 1 common file and 4 pass files in total.\n//                     The complete project is in the following link:\n//                     https://www.shadertoy.com/view/lflcWH\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\nfloat random ( vec3 p ) {\n    return fract( sin( dot( p, vec3( 12.9898, 78.233, 45.543 ) ) ) * 43758.5453123 );\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    float mask = step(0.998, random(rayDir));\n    fragColor = vec4(mask, mask, mask, 1.0);\n}\n", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lflcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3491, 3491, 3536, 3536, 3663], [3665, 3665, 3702, 3702, 3888], [3890, 3890, 3946, 3946, 4183], [4185, 4185, 4248, 4248, 4580], [4582, 4582, 4636, 4636, 4873], [4875, 4875, 4932, 4932, 5243], [5245, 5245, 5306, 5306, 5531], [5535, 6031, 6185, 6185, 6515], [6517, 6849, 6932, 6932, 7144], [7146, 7664, 7821, 7935, 8676], [8678, 9011, 9096, 9210, 9781], [9783, 9783, 9970, 9970, 10875], [10877, 10877, 10966, 10966, 11646], [11648, 11648, 11701, 11701, 12228], [12230, 12230, 12461, 12461, 13181], [13183, 13183, 13256, 13256, 13795], [13799, 14153, 14283, 14283, 14695], [14699, 15488, 15601, 15692, 20232], [20236, 20597, 20654, 20731, 21677]], "test": "error"}
{"id": "4flyWH", "name": "Subatomics", "author": "leon", "description": "structures and creatures", "tags": ["abstract"], "likes": 43, "viewed": 187, "published": 3, "date": "1721085910", "time_retrieved": "2024-07-18T23:33:36.141368", "image_code": "\n// Subatomics\n// 2024-07-16 Leon Denise\n\n// Revisiting \"Taste of Noise 12\"\n// https://shadertoy.com/view/7sGSW3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nfloat gyroid (vec3 p) { return dot(cos(p),sin(p.yzx)); }\n\nfloat jump(float time, float curve)\n{\n    return pow(fract(time), curve) + floor(time);\n}\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "\n// Subatomics\n// 2024-07-16 Leon Denise\n\n// Revisiting \"Taste of Noise 12\"\n// https://shadertoy.com/view/7sGSW3\n\n// global variable\nfloat delay = 6.;\nfloat bounces;\nvec3 rng;\n\nfloat fbm(vec3 p) {\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        p += result*.5;\n        result += ((gyroid(p/a))*a);\n        a /= 2.;\n    }\n    return result;\n}\n\nfloat fbm2(vec3 p) {\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        p += result*.5;\n        result += ((gyroid(p/a))*a);\n        a /= 2.;\n    }\n    return result;\n}\n\n// geometry\nfloat map (vec3 p)\n{\n    float scene = 1000.;\n    float shape = 1000.;\n    vec3 q = p;\n    \n    // times\n    float t = floor(iTime/delay)*78.;\n    float j = t+rng.x*.002;\n    \n    vec3 rngt = hash31(t);\n    \n    // parameters\n    vec3 angle = vec3(1,2,3)+j;\n    float range = .5;\n    float size = .2;\n    \n    // random falloffs\n    float var = mix(1.2, 1.5, rngt.x);\n    float vaa = 1.7;\n    float vas = mix(1.3, 1.5, rngt.z);\n    \n    // kaleidoscopic iterated function\n    const float count = 8.;\n    float ar = 1., aa = 1., as = 1.0;\n    for (float index = 0.; index < count; ++index)\n    {\n        \n        // rotate\n        p.xz *= rot(angle.y/aa);\n        p.yz *= rot(angle.x/aa);\n        p.xy *= rot(angle.z/aa);\n        // fold\n        p.x = abs(p.x)-range*ar;\n        \n        // combine\n        scene = min(scene, length(p)-size*as);\n        \n        // falloff\n        ar /= var;\n        aa /= vaa;\n        as /= vas;\n    }\n    \n    vec3 qq = abs(fract(q*10.)-.5)*2.;\n    float s = length(qq)+fbm(q*8.);\n    scene += abs(fract(abs(s)*2.)-.5)*.01;\n    \n    // lines\n    p += fbm(q*4.)*.05;\n    shape = min(length(p.xy), length(p.xz));\n    shape = min(shape, length(p.zy));\n    shape -= .002;\n    scene = min(shape, scene);\n    return scene;\n}\n\nvec3 color (vec3 pos, vec3 ray, vec3 normal)\n{    \n    // lighting\n    vec3 rf = reflect(ray, normal);\n    vec3 backlight = vec3(0.1) * sqrt(dot(rf, vec3(0,0,1))*0.5+0.5);\n    vec3 specular = vec3(1) * pow(dot(rf, normalize(vec3(0,1,0)))*0.5+0.5,10.);\n    vec3 color = backlight + specular*.5;\n\n    // brighten up reflections\n    color *= 2.+bounces*1.;\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // reset color\n    fragColor = vec4(0,0,0,1);\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    \n    // blue noise scroll https://www.shadertoy.com/view/tlySzR\n    ivec2 pp = ivec2(fragCoord);\n    pp = (pp+(int(iFrame)+196)*ivec2(113,127)) & 1023;\n    rng = texelFetch(iChannel1,pp,0).xyz;\n    \n    // blur edges\n    vec3 rng3 = rng;//hash33(seed+78.);\n    vec2 dof = vec2(cos(rng3.x*6.28),sin(rng3.x*6.28))*rng3.y;\n    uv += dof*pow(length(uv), 8.0)*rng3.z*.2;\n    \n    // camera coordinates\n    vec3 eye = vec3(.5,1,-3.);\n    vec3 at = vec3(0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(z * 1.5 + uv.x * x + uv.y * y);\n    vec3 pos = eye + ray * (rng3.z*2.);\n    \n    // normalized random direction by Blackle (https://suricrasia.online/demoscene/functions/)\n    rng3 = normalize(tan(rng3*2.-1.));\n    \n    // raymarching\n    const float count = 30.;\n    float total = 0.;\n    bounces = 0.;\n    for (float index = 0.; index < count; ++index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.001)\n        {\n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(0.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n            // coloring\n            float shade = 1.-index/count;\n            fragColor.rgb += color(pos, ray, normal) * shade / (1.+bounces);\n            \n            // reflection\n            if (++bounces > 1.) break;\n            ray = reflect(ray, normal);\n            ray = normalize(ray + rng3);\n            dist = 0.01;\n            total = 0.;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * rng.z;\n        \n        // depth of field\n        total += dist;\n        ray += 0.03*smoothstep(2.,6.,total) * rng3;\n        \n        // ray march\n        pos += ray * dist;\n    }\n    \n    // temporal fade\n    vec4 frame = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = max(fragColor.rgb, frame.rgb);\n    \n    // animation fade\n    fragColor.rgb *= smoothstep(1., .95, fract(iTime/delay));\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Minimal Temporal Anti Aliasing\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 frame = texture(iChannel0, uv);\n    vec3 color = frame.rgb;\n    \n    // blue noise scroll https://www.shadertoy.com/view/tlySzR\n    ivec2 pp = ivec2(fragCoord);\n    pp = (pp+(int(iFrame))*ivec2(113,127)) & 1023;\n    vec3 dither = texelFetch(iChannel2,pp,0).xyz;\n    uv += 1.*(dither.xy-.5)/iResolution.xy;\n    \n    vec3 temporal = texture(iChannel1, uv).rgb;\n    \n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 171, 171, 240]], "test": "error"}
{"id": "4flcWH", "name": "Infinite Cosmic Soup in Purple", "author": "GLYDER", "description": "This is a fork of Infinite Cosmic Soup shader just with changed particle color.", "tags": ["glsl", "shader", "stars", "cosmic"], "likes": 1, "viewed": 96, "published": 3, "date": "1721084141", "time_retrieved": "2024-07-18T23:33:36.898345", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 adjustedUV = (uv - 0.5) * 3.5;\n    float timeFactor = iTime * 0.025;\n    vec4 outputColor = vec4(0.0);\n    float x;\n    for (float waveIndex = 0.0; waveIndex < 25.0; waveIndex += 1.0) {\n        vec2 waveVector = vec2(cos(x = waveIndex * 15. - timeFactor), sin(x));\n        float wave = sin(waveIndex * mix(0.05, 0.5, sin(timeFactor) * 0.5) - timeFactor);\n        float distance = length(adjustedUV - wave * waveVector); \n        vec3 color;\n        for(int i=0;i<3;i++) {\n            float z = waveIndex * 0.000009;\n            float l = distance;\n            vec2 uv = adjustedUV;\n            uv += waveVector/l*(sin(z)+5.)*abs(sin(l*1.1-z-z));\n            color[i] = 0.0013/length(mod(uv + vec2(0.003 * float(i-1)),1.1)-0.5); \n        }\n        color *= vec3(0.49, 0.49, 1.0); \n        outputColor += vec4(color / distance, 2.0);\n    }\n    fragColor = outputColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 975]], "test": "ok"}
{"id": "lcXcDH", "name": "Prime waves", "author": "dray", "description": "To accompany https://www.shadertoy.com/view/MXdXDN\nTo match graphic wavelengths, use sub-harmonics: https://www.shadertoy.com/view/XflcWH", "tags": ["sound", "primes"], "likes": 4, "viewed": 85, "published": 3, "date": "1721075298", "time_retrieved": "2024-07-18T23:33:37.647342", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = U/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    O = vec4(col,1.0);\n    \n    O += float(int[](49,73,70,0,62,65,126,127,48,12,1)[int[](3,0,1,1,2,3,4,5,5,4,3,6,10,10,6,3,7,8,9,7,3,7,5,5,4,3,3)[int(U)/4-2]]>>int(U.y)/3&1);\n    \n}", "image_inputs": [], "sound_code": "#define PI 3.1415926535\n#define TAU (2.*PI)\n\nvec2 mainSound( int samp, float time )\n{\n    float oo=0., cnt=0.;\n    \n    float FUND = 20.;\n\n#define T(PR) if ( time * 2. > PR ) { oo = oo * .98 + sin( mod( TAU * PR * FUND * time, TAU ) ); cnt = cnt * .98 + 1.; }\n\nT(2.)\nT(3.)\nT(5.)\nT(7.)\nT(11.)\nT(13.)\nT(17.)\nT(19.)\nT(23.)\nT(29.)\nT(31.)\nT(37.)\nT(41.)\nT(43.)\nT(47.)\nT(53.)\nT(59.)\nT(61.)\nT(67.)\nT(71.)\nT(73.)\nT(79.)\nT(83.)\nT(89.)\nT(97.)\nT(101.)\nT(103.)\nT(107.)\nT(109.)\nT(113.)\nT(127.)\nT(131.)\nT(137.)\nT(139.)\nT(149.)\nT(151.)\nT(157.)\nT(163.)\nT(167.)\nT(173.)\nT(179.)\nT(181.)\nT(191.)\nT(193.)\nT(197.)\nT(199.)\nT(211.)\nT(223.)\nT(227.)\nT(229.)\nT(233.)\nT(239.)\nT(241.)\nT(251.)\nT(257.)\nT(263.)\nT(269.)\nT(271.)\nT(277.)\nT(281.)\nT(283.)\nT(293.)\nT(307.)\nT(311.)\nT(313.)\nT(317.)\nT(331.)\nT(337.)\nT(347.)\nT(349.)\nT(353.)\nT(359.)\nT(367.)\nT(373.)\nT(379.)\nT(383.)\nT(389.)\nT(397.)\nT(401.)\nT(409.)\nT(419.)\nT(421.)\nT(431.)\nT(433.)\nT(439.)\nT(443.)\nT(449.)\nT(457.)\nT(461.)\nT(463.)\nT(467.)\nT(479.)\nT(487.)\nT(491.)\nT(499.)\nT(503.)\nT(509.)\nT(521.)\nT(523.)\nT(541.)\n\nreturn vec2(oo/cnt);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "4fsyW8", "name": "Simple caustics", "author": "afl_ext", "description": "Enjoy! ", "tags": ["caustics"], "likes": 4, "viewed": 95, "published": 3, "date": "1721074488", "time_retrieved": "2024-07-18T23:33:38.438228", "image_code": "// afl_ext 2024\n// MIT License\n\nvec3 getwaves_directions[] = vec3[](\n  vec3(0.7900, 0.5533, -0.2640),\n  vec3(-0.9075, 0.1099, 0.4055),\n  vec3(0.7029, -0.5427, 0.4598),\n  vec3(-0.1990, -0.7706, -0.6054),\n  vec3(-0.8966, 0.2679, -0.3526),\n  vec3(-0.1806, 0.4303, -0.8844),\n  vec3(-0.0061, 0.8324, -0.5542),\n  vec3(0.5143, -0.6805, 0.5219),\n  vec3(-0.5450, 0.7928, 0.2727),\n  vec3(0.5874, -0.7927, -0.1632),\n  vec3(0.4356, -0.1174, 0.8925),\n  vec3(-0.2174, 0.1649, -0.9621),\n  vec3(-0.5134, -0.0137, -0.8581),\n  vec3(-0.3361, -0.1214, 0.9340),\n  vec3(0.6320, -0.4675, -0.6181),\n  vec3(0.2561, 0.1685, -0.9519),\n  vec3(0.7354, 0.6738, 0.0716),\n  vec3(-0.0798, 0.9033, -0.4215),\n  vec3(-0.1344, -0.6286, -0.7660),\n  vec3(0.4724, 0.6836, 0.5564),\n  vec3(-0.5242, -0.6188, 0.5851),\n  vec3(0.0763, 0.0929, -0.9927),\n  vec3(-0.9852, -0.1562, -0.0712),\n  vec3(-0.2936, -0.7704, 0.5660),\n  vec3(-0.4166, -0.7558, 0.5051),\n  vec3(0.5641, -0.1422, 0.8134),\n  vec3(-0.1560, 0.3815, -0.9111)\n);\n\nfloat getwaves(vec3 position) {\n    int iters = getwaves_directions.length();\n    float result = 0.0;\n    for(int i=0;i<iters;i++) {\n        float x = dot(getwaves_directions[i], position);\n      \n        float wave = exp(sin(x) - 1.0);\n        float dx = wave * cos(x);\n      \n        result += wave;\n        position += getwaves_directions[i] * dx * -0.7;\n    }\n    return result / float(iters);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n\n    float intensity = pow(getwaves(vec3(uv * 100.0, iTime * 10.0)), 3.0);\n    vec3 colored = clamp(vec3(0.0, 0.3, 0.5) + intensity, 0.0, 1.0);\n\n    fragColor = vec4(colored,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsyW8.jpg", "access": "api", "license": "mit", "functions": [[981, 981, 1012, 1012, 1380], [1382, 1382, 1437, 1437, 1658]], "test": "error"}
{"id": "lXVXWt", "name": "Voronoi Edges Artwork #1 Y28", "author": "Yusef28", "description": "From my tutorial on the voronoi and voronoi edges algorithms:\nPart 1: https://youtu.be/g2bILAVIIvM?si=mfm4dA_U59PA6B_8\nPart 2: https://youtu.be/oIbj64Cq8HA?si=2W3m0xPmPKnByCws", "tags": ["voronoi"], "likes": 14, "viewed": 149, "published": 3, "date": "1721069518", "time_retrieved": "2024-07-18T23:33:39.244074", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. tomkh's drawing helped it click: \n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader inspired the lighting/art style:\n    https://www.shadertoy.com/view/ll3GRM\n*/\n\n\n#define pi 3.141592\n#define eps 20./iResolution.y\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//smoothMin funciton\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n//voronoi edges function\nvec4 voronoiEdges(vec2 uv){\n    \n    vec2 currentCell = floor(uv);\n    float minDist = 8.0;\n    vec2 A;\n\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n            vec2 neighbor = vec2(i,j);\n            vec2 offset = hash22(currentCell + neighbor);\n            offset = 0.3+0.3*sin(3.141592*2.*offset+iTime);\n            vec2 position = (currentCell + neighbor + offset);\n            float dist = length(uv - position);\n\n            if(dist < minDist){\n                minDist = dist;\n                A = position;\n            }\n        }\n    }\n\n    \n    float secondMinDist = 8.;\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n            vec2 neighbor = vec2(i,j);\n            vec2 offset = hash22(currentCell + neighbor);\n            offset = 0.3+0.3*sin(3.141592*2.*offset+iTime);\n            vec2 position = (currentCell + neighbor + offset);\n            vec2 B = position;\n\n            if( dot(A-B,A-B)<0.001 )continue;\n            vec2 halfWay = uv-0.5*(A+B);\n            vec2 dir = normalize(A-B);\n            float distToEdge = dot(halfWay, dir);\n            secondMinDist = smin2(secondMinDist,  distToEdge, 0.2); \n        }\n    }\n    \n    float border = sin(3.14159*1.9+abs(secondMinDist-0.04));\n    return vec4(border,secondMinDist, uv-A);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv,-1.));\n\n    uv*=2.;\n    \n    vec4 data = voronoiEdges(uv);\n    \n    //light 1 position \n    vec3 light = vec3(1.,1.,4.);\n    //light 1 direction vector using uv and voronoi height for surface point\n    vec3 ldir = normalize(light-vec3(uv.x,data.x,uv.y));\n    \n    //light2\n    vec3 light2 = vec3(1.,2.,4.);\n    vec3 ldir2 = normalize(light2-vec3(uv.x,data.x,uv.y));\n\n    vec3 col = 0.5+0.5*sin(vec3(0., 2.,2.99)/1.5+ data.x*pi*5.-0.2);\n    \n    //grabbing the texture based on the uv-cell point vectors \n    col = mix(col,texture(iChannel1,data.zw).rgb,data.y);\n    col *= 0.8;\n\n    \n    vec2 e = vec2(20./iResolution.y,0.);\n    vec3 n = vec3(\n                  voronoiEdges(uv+e).x-voronoiEdges(uv-e).x,\n                  voronoiEdges(uv+e.yx).x-voronoiEdges(uv-e.yx).x,\n                  e\n                  );\n    n = normalize(n);\n\n    //phong lighting diffuse and specular for light 1\n    float diff = max(dot(ldir,n),0.);\n    float spec = pow(max(dot(reflect(-ldir,n),rd),0.),10.);\n    col += diff*0.3+vec3(0.8,0.5,0.3)*spec*0.8;\n    \n    //and for light 2\n    float diff2 = max(dot(ldir,n),0.);\n    float spec2 = pow(max(dot( reflect(-ldir2,n),rd),0.),10.);\n    col += diff2*0.3+vec3(0.1,0.5,0.9)*spec2*0.8;\n    \n\n    col = mix(col,pow(col.r*1.4,3.2)*vec3(0.14,0.09,0.05),smoothstep(0.085,0.05,data.y));\n    //col = mix(col,pow((diff+diff2+spec+spec2)*2.,1.5)*vec3(0.14,0.09,0.05),smoothstep(0.085,0.05,data.y));\n    \n    \n    float borderMask = smoothstep(0.07,0.06,data.y);\n    vec3 env = texture(iChannel0, reflect(n,rd)).rgb;\n    col += mix(env*0.3,env,borderMask)*0.3;\n    \n    col /= 1.5;\n    col= pow(col, vec3(1.6));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lXVXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 372, 372, 506], [508, 529, 569, 569, 645], [647, 672, 699, 699, 1991], [1993, 1993, 2050, 2100, 3866]], "test": "error"}
{"id": "MXdXDN", "name": "Primes as waves", "author": "nimitz", "description": "Intersections with y=0 show the unique prime factors of non-primes.\nEvery integer is either an intersection of a \"prime wave\" with y=0, or a new wave corresponding to that prime. ", "tags": ["math", "primes", "numbertheory"], "likes": 36, "viewed": 295, "published": 3, "date": "1721057392", "time_retrieved": "2024-07-18T23:33:40.001050", "image_code": "// \"Primes as waves\" by nimitz 2024\n// https://www.shadertoy.com/view/MXdXDN\n\n/*\n    An alternate definition of this graph:\n        Given a range, how many waves of integer period (half-period) sine waves except period 1 \n        are required to be able to interest y=0 at every integer.\n*/\n\n#define SHOW_DIGITS\n//#define POSITIVE_ONLY\n\nint primes[100] = int[](2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\n                        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541);\n\n\n#define pi 3.14159265358979\nfloat sign2(float x){return x>=0.0?1.0:-1.0;}\n\nfloat dr(float v, float num)\n{\n    #ifdef POSITIVE_ONLY\n    return abs(sign2(num)*-sin(v*pi / num)*pow(abs(num),1.)*0.1*sign2(num));\n    #else\n    return sign2(num)*-sin(v*pi / num)*pow(abs(num),.9)*0.1*sign2(num);\n    #endif\n}\n\nfloat draw(const in vec2 p, const in float num)\n{\n    float v = dr(p.x, num)-p.y;\n    float g = 0.5 + dr(p.x + 0.1, num) - dr(p.x- 0.1, num);\n    float d = abs(v)/sqrt(g);\n    return .001/(d*d + 0.0001);\n}\n\nvec3 wheel( vec3 c )\n{\n    vec3 rgb = vec3(0);\n    c.x *= 3.14159265358979;\n    rgb.r = pow(abs(cos(c.x - 0.1)),4.)*1.5;\n    rgb.g = pow(abs(cos(c.x + 2.0944 + 0.1)),3.);\n    rgb.b = pow(abs(cos(c.x + 1.0472 + 0.35)),4.);\n    \n\treturn clamp(c.z * mix( vec3(1.0), rgb, c.y),0.,1.);\n}\n\n//for codes see: https://www.shadertoy.com/view/ldSBzd\nfloat getChar(vec2 p, int char)\n{\n\tvec2 pos = vec2(char%16, 15 - char / 16);\n\tpos += clamp(p, 0.001, 0.999);\n\treturn textureLod(iChannel0, pos/16., 0.).r;\n}\n#define chr(A) col += getChar(pp, A)*0.4,pp.x-=0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.5/iResolution.y;\n    vec2 p = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 bp = p;\n    float asp = iResolution.x/iResolution.y;\n    \n    p.x += iTime*0.1 - 1.5;\n    p = p*vec2(36.,12.) + vec2(30., 0);\n\n    vec3 col = vec3(0.05);\n    int num = int(iTime*2.);\n    \n    for(int i = 0; i<100; i++)\n    {\n        float fi = float(i);\n        vec3 col2 = draw(p, float(primes[i]))*step(float(primes[i]), p.x)*wheel( vec3(fi*0.0748, cos(fi*0.65)*0.07+0.9, 0.6));\n        col += col2 * smoothstep(.5,0., pow(float(i),1.01) - iTime*2.5 + .75*p.x/pow(float(i+1),.08));\n    }\n    \n    //Axes\n    col += smoothstep(0.07,.0,abs(fract(p.x + 0.5)-0.5))*0.05;\n    col += smoothstep(0.07,.0,abs(fract(p.y + 0.5)-0.5))*0.05;\n    col *= smoothstep(0.0,0.1, abs(p.x));\n    col += smoothstep(0.03,0.0, abs(p.y))*0.9;\n    \n#ifdef SHOW_DIGITS\n    vec2 pp = bp;\n    pp = (p - vec2(-0.4,-1.6))*1.;\n    chr(48); // 0\n    pp = (p - vec2(-0.5 + 5.2, -1.6))*1.;\n    chr(53);  // 5\n    pp = (p - vec2(-0.5 + 11., -1.6))*1.;\n    chr(49);chr(49);  // 11\n    pp = (p - vec2(-0.5 + 50., -1.6))*1.;\n    chr(53);chr(48);  // 11\n    pp = (p - vec2(-0.7 + 100.01, -4.))*1.;\n    chr(49);chr(48);chr(48); // 100\n    pp = (p - vec2(-0.7 + 200., -5.))*1.;\n    chr(50);chr(48);chr(48); // 200\n#endif\n\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MXdXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[887, 887, 908, 908, 932], [934, 934, 964, 964, 1161], [1370, 1370, 1392, 1392, 1652], [1654, 1709, 1742, 1742, 1865], [1918, 1918, 1975, 1975, 3310]], "test": "error"}
{"id": "XffyDH", "name": "Chromatin", "author": "wyatt", "description": "..", "tags": ["sdf", "mobius", "kifs"], "likes": 23, "viewed": 169, "published": 3, "date": "1721055283", "time_retrieved": "2024-07-18T23:33:40.754038", "image_code": "float map (vec3 p) {\n    \n    vec2 u = vec2(length(p.xy)-1.,p.z);\n    float a = 0.;\n    if (length(p.xy)>0.) a = atan(p.y,p.x);\n    u *= ei(a);\n    for (float i = 0.; i < 7.; i++) {\n        u = abs(u*ei(i*i*i*a+.1*i*i*i*i*iTime))-.3*exp(-.9*i);\n    }\n\n    return length(u)-.0003;\n\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-3,0);\n    return normalize(\n        vec3(\n            map(p+e.xyy)-map(p-e.xyy),\n            map(p+e.yxy)-map(p-e.yxy),\n            map(p+e.yyx)-map(p-e.yyx)\n        )\n    );\n\n}\nMain {\n    Q = vec4(0);\n    #define AA 1\n    for (int x = 0; x < AA; x++)\n    for (int y = 0; y < AA; y++){\n        vec3 p = vec3(0,0,-1);\n        vec3 d = normalize(vec3(2.*(U+vec2(x,y)/float(AA)-.5*R)/R.y,1));\n        p.xz *= ei(.1*iTime);\n        d.xz *= ei(.1*iTime);\n        p.yz *= ei(.1*iTime);\n        d.yz *= ei(.1*iTime);\n\n        for (float i = 0.; i < 70.; i++) {\n\n            p += .8*d*map(p);\n\n        }\n        vec3 li = vec3(0);\n        vec3 n = normal(p);\n        d = normalize(li-p);\n        p += 3e-3*d;\n        if (map(p) > .01) ;else{\n        for (float i = 0.; i < 30.; i++) {\n\n            p += .8*d*min(map(p),length(p-li)-.01);\n\n        }\n        Q.xyz += 1./float(AA*AA)*(0.5+0.5*n)*vec3(2,.5,1.5)*exp(-2.*length(p-li));\n        }\n    }\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U) \n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XffyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 282], [283, 283, 305, 305, 504]], "test": "error"}
{"id": "XcXcWH", "name": "Fork Fluted Gla eigilnikol 320", "author": "eigilnikolajsen", "description": "fork from baretto", "tags": ["glass", "flutedglass"], "likes": 0, "viewed": 49, "published": 3, "date": "1721052366", "time_retrieved": "2024-07-18T23:33:41.619723", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the custom uniforms as constants or use ShaderToy's UI for uniforms\n    const float u_numSegments = 10.0; // Number of segments\n    const float u_inputOutputRatio = 1.2; // Ratio between input and output segments\n    const float u_overlap = 0.6; // Overlap between segments\n    const float u_light_strength = 0.2;\n\n    // Calculate UV coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float segmentWidth = 1.0 / u_numSegments;\n    float inputSegmentWidth = segmentWidth * u_inputOutputRatio;\n    float overlapWidth = segmentWidth * u_overlap;\n\n    // Determine which segment we are in\n    float segmentIndex = floor(uv.x / segmentWidth);\n    float segmentStart = segmentIndex * segmentWidth;\n    float segmentEnd = segmentStart + segmentWidth;\n\n    // Calculate the local uv within the segment\n    float localUVx = (uv.x - segmentStart) / segmentWidth;\n\n    // Apply log compression to the x coordinate within the segment\n    float compressedX = log(1.0 + localUVx * 9.0) / log(10.0);\n\n    // Calculate the corresponding input UV\n    float inputSegmentStart = segmentIndex * (inputSegmentWidth - overlapWidth);\n    vec2 inputUV = vec2(inputSegmentStart + compressedX * inputSegmentWidth, uv.y);\n\n    // Get the color from the input image\n    vec4 color = texture(iChannel0, inputUV);\n\n    // Apply the vertical gradient\n    float gradientMidpoint = 0.8;\n    float gradientStrength = smoothstep(gradientMidpoint, 1.0, uv.y);\n    color = mix(color, vec4(0.0, 0.0, 0.0, 0.5), gradientStrength*0.5);\n    \n    // Apply the black gradient on the right side of each segment\n    float rightGradientStrength = smoothstep(0.8, 1.0, localUVx);\n    color = mix(color, vec4(0.0, 0.0, 0.0, rightGradientStrength), rightGradientStrength*u_light_strength);\n\n    // Apply the white gradient on the left side of each segment\n    float leftGradientStrength = smoothstep(0.1, 0.0, localUVx);\n    color = mix(color, vec4(1.0, 1.0, 1.0, leftGradientStrength), leftGradientStrength*u_light_strength);\n\n    \n    fragColor = color;\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcXcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 137, 2087]], "test": "error"}
{"id": "4cXcW8", "name": "Inverse ripples", "author": "Xe_non", "description": "My very first shader.", "tags": ["2d"], "likes": 1, "viewed": 58, "published": 3, "date": "1721044905", "time_retrieved": "2024-07-18T23:33:42.425569", "image_code": "vec3 palette(float t) {\n    return vec3(t, 0.1, 0.3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // Normalization\n    \n    uv = uv * 2.0 - 1.0; // Centering coords\n    uv.x *= iResolution.x / iResolution.y; // Correcting aspect ratio\n\n    float gridSize = 10.0; // Set grid size\n   \n    vec2 gridPos = floor(uv * gridSize) / gridSize; // Calculate points position\n\n    float angle = iTime * 2.5 + length(gridPos) * 7.0; // Calculate movement offset\n    vec2 offset = vec2(cos(angle), sin(angle)) * 0.1;\n\n    vec2 pointPos = gridPos + offset / gridSize; // Place points with offset\n\n    float dist = length(uv - pointPos); // Distance from (0, 0)\n\n    float intensity = smoothstep(0.02, 0.01, dist); // Smoothen the points\n\n    vec3 color = palette(intensity); // Color palette\n\n    fragColor = vec4(color, 1.0); // Ser fragment color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 55], [57, 57, 112, 112, 893]], "test": "ok"}
{"id": "lfsyDr", "name": "Attempt at something", "author": "bluecat", "description": "Can anyone explain how I could remove the blockiness in the center without altering the outer parts of the work?", "tags": ["cool", "attempt", "helpneeded"], "likes": 0, "viewed": 51, "published": 3, "date": "1721039846", "time_retrieved": "2024-07-18T23:33:43.170577", "image_code": "vec3 palette(float t) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    \n    return a + b*cos( 6.28318*(c*t*d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 1.87 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 5.0; i++) \n    {\n        uv = fract(uv) + 6.283;\n        \n        vec3 col = palette(length(uv0) + i*.8 + iTime*.4);\n        \n        float d = length(uv) * exp(length(uv0) + exp(-length(uv0)));\n        \n        d = sin(d*8. + iTime)/10.;\n        d = abs(d);\n        \n        d = pow(0.006 / d, 0.4);\n        \n        col *= d;\n        \n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfsyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 212], [214, 214, 271, 271, 839]], "test": "ok"}
{"id": "MclcWr", "name": "particles color", "author": "nayk", "description": "im not God=)  originals https://www.shadertoy.com/view/lclyWr https://www.shadertoy.com/view/tsVBWK", "tags": ["particlesrotate"], "likes": 2, "viewed": 66, "published": 3, "date": "1721036224", "time_retrieved": "2024-07-18T23:33:43.929548", "image_code": "#define particles 500.\nvec3 c1 = vec3(0.,0.3,1.);\nvec3 c2 = vec3(1.,0.5,.3);\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nvec3 noise(float n) {\n\tvec3 t = texture(iChannel0,vec2(floor(n)/particles)).xyz;\n    vec3 u = texture(iChannel0,vec2(ceil(n)/particles)).xyz;\n    return mix(t,u,fract(n));\n}\nvec3 palette(float t) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    \n    return a + b*cos( 6.28318*(c*t*d) );\n}\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec4 fire(vec2 p)\n\t{\n    p-=vec2(.5);     \n\tp.x /= 1.75;\n\t\n\tfloat color = 3.0 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 2; i++)\n\t\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-time*.05, time*.01), power*16.);\n\t\t}\n\treturn vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n\t}\n\n\nconst vec2 ch_size  = vec2(0.9, 2.0);              \t// character size\nconst vec2 ch_space = ch_size + vec2(0.7, 1.0);    \t// character distance  \nconst vec2 ch_start = vec2 (-8.8, 3.0); \t\t\t// start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             \t// character position\nfloat d = 1e6;\n\n/* 16 segment display...\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n\n#define A_ ch_pos.x-=0.5;ddigit(0x4381,uv);ch_pos.x+=0.1;\n#define B_ ch_pos.x-=0.5;ddigit(0xC442,uv);\n#define V_ ch_pos.x-=0.5;ddigit(0xC642,uv);\n#define G_ ch_pos.x-=0.5;ddigit(0x4402,uv);\n#define D_ ch_pos.x-=0.5;ddigit(0x42C1,uv);ch_pos.x+=0.1;\n//#define E_ ch_pos.x-=0.5;ddigit(0x4542,uv);\n#define E_ ch_pos.x-=0.5;ddigit(0x8300,uv);\n#define EY_ ch_pos.x-=0.5;ddigit(0x8300,uv);ch_pos+=vec2(.5-ch_space.x,2.5);ddigit(0x0,uv); ch_pos.x+=.5-ch_space.x; ddigit(0x0,uv); ch_pos-=vec2(1.,2.5);\n//ch_pos+=vec2(1.-ch_space.x,0.);ddigit(0,uv);ch_pos-=vec2(1.,1.);\n\n#define J_ ddigit(0xEE00,uv);\n#define Z_ ch_pos.x-=0.5;ddigit(0x8242,uv);\n#define I_ ddigit(0x6418,uv);ch_pos.x-=0.4;ch_pos.x+=0.1;\n#define IY_ ddigit(0x6418,uv);ch_pos+=vec2(-ch_space.x,.5);ddigit(0x4,uv);ch_pos-=vec2(.5,.5);ch_pos.x+=0.1;\n#define K_ ch_pos.x-=0.5;ddigit(0xc600,uv);\n#define L_ ch_pos.x-=0.5;ddigit(0x4281,uv);ch_pos.x+=0.1;\n#define M_ ddigit(0x0A99,uv);ch_pos.x+=0.1;\n#define N_ ch_pos.x-=0.5;ddigit(0x4581,uv);ch_pos.x+=0.1;\n#define O_ ch_pos.x-=0.5;ddigit(0x44c3,uv);ch_pos.x+=0.1;\n#define P_ ch_pos.x-=0.5;ddigit(0x4483,uv);ch_pos.x+=0.1;\n#define R_ ch_pos.x-=0.5;ddigit(0x4602,uv);\n//#define S_ ch_pos.x-=0.5;ddigit(0x4442,uv);\n#define S_ ch_pos.x-=0.5;ddigit(0x8200,uv);\n\n#define T_ ddigit(0x4406, uv /* * vec2(1.2, 1.)-vec2(.5,0.)*/ );//ch_pos.x-=0.3;\n\n#define U_ ddigit(0x3408,uv);ch_pos.x-=0.4;\n#define F_ ddigit(0x550F,uv);\n#define H_ ddigit(0xAA00,uv);\n//#define C_ ddigit(0x4478,uv);\n#define C_ ddigit(0x4478,uv);ch_pos+=vec2(.5-ch_space.x,-1.);ddigit(0x2000,uv);ch_pos-=vec2(.5,-1.);\n#define CH_ ddigit(0x5408,uv);ch_pos.x-=0.4;\n#define SH_ ddigit(0x44F9,uv);ch_pos.x+=0.1;\n//#define SHCH_ ddigit(0x1589,uv);\n#define SHCH_ ddigit(0x44F9,uv);ch_pos+=vec2(1.-ch_space.x,-1.);ddigit(0x3000,uv);ch_pos-=vec2(.5,-1.);\n\n#define mz_ ch_pos.x-=0.5;ddigit(0xC440,uv);\n#define YI_ ddigit(0x50B9,uv);ch_pos.x+=0.1;\n#define tz_ ddigit(0xC44C,uv);\n//#define YE_ ddigit(0x5424,uv);\n#define YE_ ddigit(0x3800,uv);ch_pos.x-=0.4;\n\n#define YU_ ddigit(0x54DB,uv);ch_pos.x+=0.1;\n#define YA_ ddigit(0x740C,uv);ch_pos.x-=0.4;\n\n\n#define n0 ddigit(0x22FF,uv);\n#define n1 ddigit(0x0281,uv);\n#define n2 ddigit(0x1177,uv);\n#define n3 ddigit(0x11E7,uv);\n#define n4 ddigit(0x5508,uv);\n#define n5 ddigit(0x11EE,uv);\n#define n6 ddigit(0x11FE,uv);\n#define n7 ddigit(0x2206,uv);\n#define n8 ddigit(0x11FF,uv);\n#define n9 ddigit(0x11EF,uv);\n\n#define A ddigit(0x119F,uv);\n#define B ddigit(0x927E,uv);\n#define C ddigit(0x007E,uv);\n#define D ddigit(0x44E7,uv);\n#define E ddigit(0x107E,uv);\n#define F ddigit(0x101E,uv);\n#define G ddigit(0x807E,uv);\n#define H ddigit(0x1199,uv);\n#define I ddigit(0x4466,uv);\n#define J ddigit(0x4436,uv);\n#define K ddigit(0x9218,uv);\n#define L ddigit(0x0078,uv);\n#define M ddigit(0x0A99,uv);\n#define N ddigit(0x8899,uv);\n#define O ddigit(0x00FF,uv);\n#define P ddigit(0x111F,uv);\n#define Q ddigit(0x80FF,uv);\n#define R ddigit(0x911F,uv);\n#define S ddigit(0x8866,uv);\n#define T ddigit(0x4406,uv);\n#define U ddigit(0x00F9,uv);\n#define V ddigit(0x2218,uv);\n#define W ddigit(0xA099,uv);\n#define X ddigit(0xAA00,uv);\n#define Y ddigit(0x4A00,uv);\n#define Z ddigit(0x2266,uv);\n#define _ ch_pos.x += ch_space.x / 1.5;\n\n#define s_dot     ddigit(0,uv);ch_pos.x -= ch_space.x/2.;\n\n#define s_minus   ddigit(0x1100,uv);\n#define s_plus    ddigit(0x5500,uv);\n#define s_greater ddigit(0x2800,uv);\n#define s_less    ddigit(0x8200,uv);\n#define s_sqrt    ddigit(0x0C02,uv);\n#define s_exc ch_pos.y+=0.5; ddigit(0x18,uv);ch_pos+=vec2(-ch_space.x,-0.5);ddigit(0,uv);ch_pos.x-=1.;\n#define s_que ch_pos.y+=0.5; ddigit(0x1414,uv);ch_pos+=vec2(-ch_space.x,-0.5);ddigit(0,uv);ch_pos.x-=.4;\n\n#define s_sobaka ddigit(0x50F7,uv);\n\nfloat dseg(vec2 p0, vec2 p1, vec2 uv)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\n\n#define saturate(x) clamp(x,0.,1.)\n#define rgb(r,g,b) (vec3(r,g,b)/255.)\n\nfloat rand(float x) { return fract(sin(x) * 71.); }\n\nfloat rand(vec2 x) { return rand(dot(x, vec2(13., 15.))); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    f *= f*(3.-2.*f);\n    return mix(mix(rand(i), rand(i+vec2(1,0)), f.x),\n               mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0, s = 1.0, w = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n{\n    return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*(iTime+47.)))-(1.0-density)), 1.0-sharpness);\n}\n\nvec3 render(vec2 uv)\n{\n\n    vec3 color = mix(rgb(255,212,166), rgb(204,235,255), uv.y);\n\n    // clouds\n    vec3 cl1 = mix(rgb(151,138,153), rgb(166,191,224),uv.y);\n    float d1 = mix(0.9,0.1,pow(uv.y, 0.7));\n    color = mix(color, cl1, cloud(uv,2.,8.,d1,0.4,0.04));\n    color = mix(color, vec3(0.9), 8.*cloud(uv,1.,1.,0.9,2.0,0.02) * cloud(uv,2.,5.,0.6,0.15,0.01)*uv.y);\n    color = mix(color, vec3(0.8), 5.*cloud(uv,12.,15.,0.9,0.0,0.03) * cloud(uv,2.,8.,0.5,0.0,0.02)*uv.y);\n    return color;\n}\nvoid ddigit(int n, vec2 uv)\n{\n\tfloat v = 1e6;\t\n\tvec2 cp = uv - ch_pos;\n\tif (n == 0)     v = min(v, dseg(vec2(-0.505, -1.000), vec2(-0.500, -1.000+sin(iTime)), uv));\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500+sin(iTime),  0.063), vec2( 0.500+sin(iTime),  0.937), uv));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000), uv));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063+cos(iTime),  1.000), vec2(-0.438+sin(iTime),  1.000), uv));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500+cos(iTime),  0.937), vec2(-0.500+cos(iTime),  0.062), uv));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500+sin(iTime), -0.063), vec2(-0.500+sin(iTime), -0.938), uv));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063+sin(iTime), -1.000), uv));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063+sin(iTime), -1.000+cos(iTime)), vec2( 0.438, -1.000), uv));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063), uv));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063+sin(iTime),  0.000), vec2( 0.438, -0.000), uv));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438+sin(iTime),  0.938+cos(iTime)), uv));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063+cos(iTime)), vec2( 0.000,  0.937), uv));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063+sin(iTime)), vec2(-0.438+sin(iTime),  0.938), uv));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438+sin(iTime),  0.000), vec2(-0.063, -0.000), uv));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063+sin(iTime), -0.063+cos(iTime)), vec2(-0.438, -0.938+sin(iTime)), uv));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938+cos(iTime)), vec2( 0.000, -0.063+cos(iTime)), uv));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938), uv));\n\tch_pos.x += ch_space.x+0.1*cos(iTime);\n\td = min(d, v);\n}\n\nvec3 render_points(vec2 uv) {\n    uv*=0.0308;\n    vec3 c=vec3(0.);\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n   uv.xy*=ma;\n   \n\tfor (float i=0.; i<particles; i++) {\n\t\tvec3 point=noise(i+floor(iTime/10.)*.1)-.5;\n          vec3 col2 = palette(length(uv) + i*.5 + iTime*.4);\n        float a=5.*smoothstep(0.,7.,1.);\n         \n        point.xz*=rot(iTime);\n        point.yz*=rot(iTime);\n\t\tpoint=pow(abs(point),vec3(1.3))*sign(point);\n        \n        float e=pow((dot(point,point)*.05+iTime*100.,.1)/.1,00.5);\n        point.xy/=max(1.,1.5+point.z);\n        point.x*=2.5;\n\t\tfloat l=max(0.,.1-distance(uv,point.xy))/.1;\n        vec3 col=mix(c1,c2,e)*col2*e;\n        c+=pow(l,20.)*col*2.;\n\t\tc+=pow(l,40.)*col*5.;\n       \n\t}\n\treturn c;\n}\n#define time iTime\n#define resolution iResolution.xy\n\nvoid mainImage( out vec4 o, vec2 fragCoord )\n{\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec3 feedback = texture(iChannel1,uv).rgb;\n    uv-=.5;\n    uv*=20.;\n\tvec2 position = (gl_FragCoord.xy/resolution.xy) -0.5;\n\t\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2.x -= 0.5;\n    uv2.x *= iResolution.x / iResolution.y;\n\tfloat y = 0.2 * position.y * sin(200.0*position.y - 20.0*time*0.35);\n\to = vec4(y *5., y, y* 5., 1.0);\n\ty = 1.0 / (600. * abs(position.y - y));\n\ty += 1./(665.*length(position - vec2(0., position.y)));\n\tfloat saule = 1./(65.*length(position - vec2(0, 0)));\n\t\n\tch_pos = ch_start;\n\tch_pos.x += 2.0; \n\tch_pos.y += 5.0;\n\t_ _  YA_ _ B_ O_ G_ _ _ \n\n    float v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n    \tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\tuv.x*=iResolution.x/iResolution.y;\n    \n\tvec3 color = mix(vec3(1.), vec3(0.), smoothstep(0.0, 0.0, d) - (0.10 / d));\n    vec3 c=render_points(uv);\n    \n    o=vec4(c+col+color,1.);\n  \n   \to*= vec4(render(uv2),1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MclcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 97, 97, 155], [158, 158, 179, 179, 331], [332, 332, 356, 356, 544], [612, 612, 646, 646, 1170], [1172, 1172, 1192, 1192, 1580], [5982, 5982, 6021, 6021, 6193], [6195, 6195, 6219, 6219, 6287], [6364, 6364, 6385, 6385, 6415], [6417, 6417, 6437, 6437, 6476], [6478, 6478, 6499, 6499, 6688], [6690, 6690, 6709, 6709, 6869], [6871, 6871, 6966, 6966, 7080], [7082, 7082, 7104, 7104, 7578], [7579, 7579, 7608, 7608, 9382], [9384, 9384, 9413, 9413, 10233]], "test": "error"}
{"id": "lclyWr", "name": "First Shader with help", "author": "bluecat", "description": "first shader ever with tutorial help: https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["shader"], "likes": 0, "viewed": 40, "published": 3, "date": "1721034118", "time_retrieved": "2024-07-18T23:33:44.690514", "image_code": "vec3 palette(float t) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    \n    return a + b*cos( 6.28318*(c*t*d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++) \n    {\n        uv = fract(uv * 1.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n        \n        vec3 col = palette(length(uv0) + i*.5 + iTime*.4);\n        \n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n        \n        d = pow(0.01 / d, 1.2);\n        \n        col *= d;\n        \n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lclyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 212], [214, 214, 271, 271, 816]], "test": "ok"}
{"id": "4flcR4", "name": "Phase Texture Variation (2-tap)", "author": "gehtsiegarnixan", "description": "This is a variation of the 2-tap texture tiling breakup shader from Suslik. Playing around with some modifications and rewriting it, so I understand how it works.", "tags": ["noise", "blending", "tiling", "texturing", "bombing", "stochastic", "variation", "texturebombing"], "likes": 6, "viewed": 205, "published": 3, "date": "1721027355", "time_retrieved": "2024-07-18T23:33:45.717768", "image_code": "// The MIT License\n// Copyright © 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI rewrote Suslik’s shader (https://www.shadertoy.com/view/WdVGWG). \nThe purpose was to understand its inner workings and play around with modifications.\n\nThe shader employs a gradient to derive phases to layer two alternating textures on \ntop of each other. Their texture coordinates vary with each phase. Since the edges \nget hidden by the alternating phases, we don't need partial derivatives (DDX, DDY) \nto fix their broken edges. The gradient can be extremly simple and fast, so even \nrepeating sinus hills seem to be enough. \n\nPhase texture variation requires 2 texture samples, an noise sample is optional but\nnot needed. In contrast, stochastic cell texturing, typically used with hexagon \ngrids, necessitates 3 texture samples and 3 hash calls and often an additional \nnoise texture to disrubt visible grid. While the cell approach offers greater \nflexibility, allowing directional flow or different textures. However, when \npurely disrupting tiling, the phase method is more cost-effective, especially in \nproduction scenarios with multiple texture layers and additional textures per \nlayer like normals.\n\nSee the global constants to mess about with different settings and debug views.\nIt also has mouse countrols to zoom in and out. \n\nFor comparison, check out cell stochastic texturing examples:\nhttps://inria.hal.science/hal-01824773\nhttps://www.shadertoy.com/view/7dGfzR\n*/\n\n// How many phases of different texture orientation get layered (1-inf)\n#define PHASE_COUNT 9\n\n// Comment this to disable per phase rotation,so you don't need normal rotation\n#define ROTATION\n\n/* Change this to change texture variation, instead of \n0 = precentage of index / PHASE_COUNT (lol this works too?)\n1 = maximum consecutive differences\n2 = random value from a hash function */\n#define VARIATION 0\n\n// Enable this to enable histogram correction (+1 sample and overdoes it sometimes)\n// But height blend using lightness already kinda does this for almost free\n//#define HISTOGRAM_CORRECTION\n\n/* Change the type of noise controling the phases\n0 = No Noise, a straight line \n1 = Sine hills, very cheap wavy function\n2 = value Noise (from iChannel1)\n3 = perlin Noise (from Buffer A) */ \n#define NOISE_TYPE 1\n\n/* Switch SHOW_VALUES to enable different views\n0 = phase stochastic textures \n1 = 1, with different colored Phases\n2 = just different colored Phases\n3 = Weight values for the interpolation\n4 = Mip levels as colormap with a grid to see the texture size*/\n#define SHOW_VALUES 0\n\n// Generates 2 indexs and a weight from a gradient\n// See https://www.desmos.com/calculator/uypn8kggi6\nvec3 getIndexWeight(float gradient, float count) {\n    \n    // generate partial values for the caculation\n    vec2 phases = vec2(gradient * (count-1.0) * 0.5) + vec2(0.5,0.0);\n    vec2 id = floor(phases);\n    float gridB = phases.y - id.y;\n    \n    // Fold repeating weights for the number of steps\n    float weight = min(gridB, 1.0 - gridB) * 2.0;\n    \n    // add some contrast to the grid for nicer transitions\n    weight = smoothValue(weight);\n    \n    // generate unique indexs for each weight phase\n    vec2 indexes = id * 2.0 + vec2(0.0,1.0);\n    \n    // Return the two indexes then the weight\n    return vec3(indexes, weight);\n}\n\n// Caculates the maximum consecutive difference (I could come up with)\n// https://www.desmos.com/calculator/pf5mkgxi7t\n#define ONE_THIRD 1.0/3.0\nfloat maxDiff(float index, float count) {\n    float third = index * ONE_THIRD; // 1/2 looks fine too\n    return ceil(mod(third * count, count)) + floor(third);\n}\n\n// Rotate and Offset the UV using the index\n#define TWO_PI 6.28318530718\nvec2 phaseUV(vec2 uv, float id, float count) {\n    \n    #if VARIATION == 0\n        // just the precentage of the id\n        vec2 precentage = vec2(id / count); \n    #elif VARIATION == 1\n        // The original code uses a hash to drive variation, which can lead to \n        // similar phases. Since we have a fixed number of phases and know the \n        // neighboring phases, let's maximize their differences. \n        float maxDiffIndex = maxDiff(id, count);\n        vec2 precentage = vec2(id, maxDiffIndex) / count;        \n    #else\n        // unique random vector per id\n        float seed = 6841.0; // must be larger than 0\n        vec2 precentage = hash21(id + seed);\n    #endif\n    \n    // add slight scale variation to the textures (in %)\n    float scaleVaritation = 0.3; // should probably be an input\n    uv *= (precentage.y - 0.5) * scaleVaritation + 1.0;\n    \n    // offset the coordinates\n    uv += precentage;\n    \n    #ifdef ROTATION\n        // use the evenly spread out ID precentage as angle\n        float angle = TWO_PI * precentage.y;\n        vec2 direction = vec2(sin(angle), cos(angle)); // use this to rotate normals\n\n        // Rotated coordinates (if you use normals they need to be rotated too)\n        uv = rotateUV(uv, direction); // rotation for coords, normals get rotated differently\n    #endif\n    \n    return uv;\n}\n\n// generates a stochastic texturing using phases of a gradient noise\nvec3 phaseTexture(vec2 uv, float count) {   \n    // Sample noise gradient\n    #if NOISE_TYPE == 0\n        // generate a straight alternating gradient\n        float gradient = abs(fract(uv.x / count)-0.5)*2.0;\n        \n    #elif NOISE_TYPE == 1\n        // simple and fast wavy pattern\n        float gradient = sinHills(uv / count * 2.0);\n    \n    #elif NOISE_TYPE == 2    \n        // Scale noise by resolution and layer count \n        float noiseScale = 1./(256. * count) * 5.0;\n        \n        // sample a value noise texture with slightly smoother filtering\n        float gradient = bilinearFilter(iChannel1, uv * noiseScale);\n        \n    #elif NOISE_TYPE >= 3\n        // Scale noise by resolution and layer count \n        float noiseScale = 1./(128. * count) * 5.0;\n        \n        // Sample perlin noise texture\n        float gradient = texture(iChannel2, fract(uv * noiseScale + 0.5)).x;\n    #endif\n\n    // generate the phase index and weights\n    vec3 indexWeight = getIndexWeight(gradient, count);    \n    float weight = indexWeight.z;\n    vec2 indices = indexWeight.xy;\n\n    // generate unique offsets and rotations for each phase\n    vec2 uvA = phaseUV( uv, indices.x, count);\n    vec2 uvB = phaseUV( uv, indices.y, count);\n            \n    // Sample color textures\n    vec3 colorA = texture(iChannel0, uvA).xyz;\n    vec3 colorB = texture(iChannel0, uvB).xyz;\n\n    // Height blend with the same texture makes a kinda histogram preservation  \n    // and it always looks nice no matter the texture and is really cheap\n    // See: https://www.shadertoy.com/view/DtXfD7\n    vec2 lightness = vec2(RGBtoHSV(colorA).z, RGBtoHSV(colorB).z);\n    weight = straightHeightWeight(weight, lightness, 1.);\n    \n    // Debug views\n    #if SHOW_VALUES == 1 \n        // sample the average color from highest mip level\n        vec3 average = textureLod(iChannel0, vec2(0), 99.).xyz;\n\n        // merge rainbow and textures using color modulation\n        colorA = viridis(maxDiff(indices.x, count) / max(1.,count-1.)) + (colorA - average);\n        colorB = viridis(maxDiff(indices.y, count) / max(1.,count-1.)) + (colorB - average);\n        \n    #elif SHOW_VALUES == 2\n        // ignore textures and make colors a rainbow\n        colorA = viridis(maxDiff(indices.x, count) / max(1.,count-1.));\n        colorB = viridis(maxDiff(indices.y, count) / max(1.,count-1.));\n\n    #elif SHOW_VALUES == 4\n        // find the partial derivative for coords for AA blur\n        vec2 ddF = fwidth(uv);\n        float aa = max(ddF.x, ddF.y);\n        \n        // generate a line on outline of uv squares\n        vec2 lines = smoothstep(0.01-aa, 0.01+aa, abs(fract(uv)-0.5));\n        float grid = min(lines.x, lines.y);\n    \n        // Debug feature to show the mip level instead of textures\n        colorA = visualizeMips(iChannel0, uvA) * grid;\n        colorB = visualizeMips(iChannel0, uvB) * grid;\n    #endif\n    \n    // Interpolate color\n    vec3 color = mix(colorA, colorB, weight);\n    \n    #if SHOW_VALUES == 0\n    #ifdef HISTOGRAM_CORRECTION        \n        // sample the average color from highest mip level\n        vec3 average = textureLod(iChannel0, vec2(0), 99.).xyz;\n        \n        // Histogram Blend Correction published in https://hal.inria.fr/inria-00536064v2\n        color = clamp(average + (color - average) / \n                sqrt(weight*weight + (1.-weight)*(1.-weight)),0.,1.);\n    #endif\n    #endif\n        \n    #if SHOW_VALUES == 3\n        // Debug view of the weights using the best colormap\n        color = viridis(weight);\n    #endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    float zoom = 1.1;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with smoothsteps\n        float zoomSteps = 10.0;\n        float mouseZoom = (floor(mouse.y * zoomSteps) + \n                           smoothstep(0.75, 1.0, fract(mouse.y * zoomSteps))) \n                           / zoomSteps;\n        zoom = mix(50.0, 1.0, mouseZoom);\n        \n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(50.0, 2.0, cos(zoomTime) * 0.5 + 0.5);\n    }\n    \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;\n    \n    // sample phase stochastic textureing\n    vec3 color = phaseTexture(uv, float(PHASE_COUNT));\n        \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// GENERAL FUNCTIONS _____________________________________________________\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec2 smoothValue(vec2 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// slighly nicer texture filtering, useful when zooming in a lot\nfloat bilinearFilter(sampler2D tex, vec2 uv) {\n\n    // find the texture resolution\n    vec2 texSize = vec2(textureSize(tex, 0));\n\n    // generate texure coordinates\n    vec2 coords = uv * texSize - 0.5;\n    vec2 id = floor(coords); // cell id\n    vec2 weights = coords - id; // technically also the grid\n    \n    weights = smoothValue(weights); // nicer transitions\n\n    // sample the 4 corners of the texture\n    float a = texelFetch(tex, ivec2(mod(id, texSize)), 0).x;\n    float b = texelFetch(tex, ivec2(mod(id +vec2(1,0), texSize)), 0).x;\n    float c = texelFetch(tex, ivec2(mod(id +vec2(0,1), texSize)), 0).x;\n    float d = texelFetch(tex, ivec2(mod(id +vec2(1,1), texSize)), 0).x;\n\n    // bilinear interpolation between the 4 corners\n    return mix(mix(a, b, weights.x), mix(c, d, weights.x), weights.y);\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Offset weight with height bias by contrast\n// See https://www.desmos.com/calculator/gxhnhzu1cs\nfloat straightHeightWeight (float weight, vec2 heights, float contrast) {\n\n    // apply contrast with offset\n    float heightWeight = weight + contrast * (weight * heights.y - (1.-weight) * heights.x);\n\n    // Ensure the final weight value is clamped to the range [0, 1]\n    return clamp(heightWeight, 0.0, 1.0);\n}\n\n// Converts an RGB color to an HSV color\nvec3 RGBtoHSV(vec3 rgbColor) {\n    // Constants for the conversion process\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    \n    // Determine the minimum and maximum values between the colors\n    vec4 p = mix(vec4(rgbColor.bg, K.wz), vec4(rgbColor.gb, K.xy), step(rgbColor.b, rgbColor.g));\n    vec4 q = mix(vec4(p.xyw, rgbColor.r), vec4(rgbColor.r, p.yzx), step(p.x, rgbColor.r));\n    float d = q.x - min(q.w, q.y);\n    \n    // Small constant to avoid division by zero\n    float e = 1.0e-10;\n    \n    // Calculate the HSV values\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// NOISE FUNCTIONS _________________________________________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define FPRIME 2800852409U\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}\n\nfloat hash12(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tuint n = (q.x & q.y) * FPRIME;\n\treturn float(n) * SMALLESTFLOAT;\n}\n\nvec2 hash21(float p) {\n\tuvec2 n = uint(int(p)) * VPRIME1;\n\tn = (n.x ^ n.y) * VPRIME2;\n\treturn vec2(n) * SMALLESTFLOAT;\n}\n\n// Sinus hill tiling mask, which is faster than a texture lookup\nfloat sinHills(vec2 uv) {\n    vec2 d = sin(uv * 6.283185); // Remove pi-sized grid\n    return (d.x + d.y) * 0.25 + 0.5; // Add and rescale to 0-1\n}\n\n// DEBUG FUNCTIONS __________________________________________________________\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    const vec3 c0 = vec3(0.503560,-0.002932,1.000009);\n    const vec3 c1 = vec3(-1.294985,3.144463,0.001872);\n    const vec3 c2 = vec3(-16.971202,0.031355,-1.232219);\n    const vec3 c3 = vec3(97.134102,-5.180126,-0.029721);\n    const vec3 c4 = vec3(-172.585487,-0.338714,0.316782);\n    const vec3 c5 = vec3(131.971426,3.514534,-0.061568);\n    const vec3 c6 = vec3(-37.784412,-1.171512,0.003376);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Function to calculate the highest mip level based on texture size\nfloat getHighestMipLevel (vec2 texSize) {\n    // Find the maximum dimension of the texture\n    float maxDimension = max(texSize.x, texSize.y);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension) + 1.;\n\n    // Return the highest mip level\n    return highestMipLevel;\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\n// Based on Unreal Engines ComputeMipLevel Material Function \nvec2 getMipLevel(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = duvdx * texSize;\n    vec2 scaledDDY = duvdy * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Calculate the highest possible mip level for the texture\n    float maxMipLevel = getHighestMipLevel(texSize);\n\n    // Clamp the mip level between 0 and the maximum mip level\n    mipLevel = clamp(mipLevel, 0.0, maxMipLevel);\n\n    // Return both the mip level and the maximum mip level\n    return vec2(mipLevel, maxMipLevel);\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\nvec2 getMipLevel(sampler2D sam, vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    // Caculate Mip level\n    return getMipLevel(sam, uv, duvdx, duvdy);\n}\n\n// Visualizes Mip level based on UV coordinates and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv);\n\n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}", "buffer_a_code": "// NOISE BUFFER ___________________________________________________\n\n// Helper Function for Perlin noise\nfloat rndGradient(vec2 grid, vec2 id, vec2 offset, uint gridsize, uvec2 seed) {\n\n    // Current cell coordinates\n    vec2 cell = id + offset;\n\n    // This makes the noise repeat between positions 0 and 1\n    cell = mod(cell, float(gridsize));    \n\n    // Generate a random offset for the current cell\n    vec2 randomOffset = hash22(cell + vec2(seed)) *2.-1.;\n    \n    // generate random gradient    \n    return dot(grid - offset, randomOffset);\n}\n\n// Function to generate Perlin 2D noise\nfloat perlin(vec2 position, uint gridsize, uvec2 seed) {\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 id = floor(position.xy); // Integer coordinates\n    vec2 grid = position.xy - id; // Fractional coordinates    \n    \n    // Sample noise at the corners\n    float a = rndGradient(grid, id, vec2(0,0), gridsize, seed);\n    float b = rndGradient(grid, id, vec2(1,0), gridsize, seed);\n    float c = rndGradient(grid, id, vec2(0,1), gridsize, seed);\n    float d = rndGradient(grid, id, vec2(1,1), gridsize, seed);\n    \n    // generate weight values\n    vec2 weights = smoothValue(grid); // for some contrast\n    \n    // Bilinear interpolation between the corner values\n    float result = mix(mix(a, b, weights.x),  mix(c, d, weights.x), weights.y);\n    \n    // rescale result to 0-1\n    return result *0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // sample the buffer itself\n    vec4 previousFrame = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // translate the current resolution to a hash\n    float hash = hash12(iResolution.xy);\n        \n    // check if the resolution changed, to not caculate more than needed\n    if (abs(previousFrame.y - hash) < 0.0001) {\n    \n        // Use the previously computed result to save performance\n        fragColor = previousFrame;   \n        \n    } else {        \n        // 0-1 normalized coordinates to sample the buffer\n        vec2 uv = fragCoord / iResolution.xy;\n    \n        // Interpolate both sides of the tennis ball mapping\n        uint gridsize = uint(128);\n        float noise = perlin(uv, gridsize, uvec2(421));\n\n        // Artistic increase of the variance, so the noise is not so gray\n        vec2 bounds = vec2(0.3, 0.7);\n        noise = clamp((noise - bounds.x) / (bounds.y - bounds.x), 0.0,1.0);\n                \n        fragColor = vec4(noise, hash, 0, 1);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flcR4.jpg", "access": "api", "license": "mit", "functions": [[3564, 3667, 3717, 3772, 4302], [4449, 4449, 4490, 4490, 4610], [4685, 4685, 4731, 4731, 6032], [6034, 6103, 6144, 6176, 9662], [9664, 9664, 9721, 9768, 10726]], "test": "error"}
{"id": "X3t3Ws", "name": "Formant Medley", "author": "dray", "description": "You start with something in mind ... and get this instead", "tags": ["sound", "formants", "rhythm"], "likes": 6, "viewed": 65, "published": 3, "date": "1721015795", "time_retrieved": "2024-07-18T23:33:46.470755", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = U/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    O = vec4(col,1.0);\n    \n    O += float(int[](49,73,70,0,62,65,126,127,48,12,1)[int[](3,0,1,1,2,3,4,5,5,4,3,6,10,10,6,3,7,8,9,7,3,7,5,5,4,3,3)[int(U)/4-2]]>>int(U.y)/3&1);\n\n}\n\n", "image_inputs": [], "sound_code": "#define PI (3.14159265)\n#define TAU (PI*2.)\n\n#define SINC(X) (sin(X)/(X))\n\nint inoisei(int a) {\n  a = (a * 54321) ^ (a * 14873);\n  a ^= a >> 16; // graycode\n  a ^= a >> 8;\n  a ^= a >> 4;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return a & 65535;\n}  \n\nfloat noisei(int a) {\n  return float( inoisei(a) & 65535 ) / 65536. ;\n}\n\nfloat noise(float a) { return noisei(int(a*1234.)); }\n\n#define RND0(L,H,IN) (noisei(IN)*(H-L)+L)\n#define RND(L,H,IN) (noise(IN)*(H-L)+L)\n\n#define FS iSampleRate\n\nfloat tonnos(float t,float f) {\n    float a = t*f;\n    int b = int(a);\n    return mix(noisei(b),noisei(b+1),smoothstep(0.,1.,fract(a))); // crude filter\n}\n\n\n\n#define FMT(FC,VOL,Q) max( 0., VOL - max(FC/har,har/FC) * Q )\n\nfloat voice(float time,float fc,float f1,float v1,float q1,float f2,float v2,float q2/*,float f3,float v3,float q3*/) {\n  float oo = 0.;\n  int cnt = 0;\n  for ( float har = fc; har < 12e3 && cnt++ < 30; har += fc ) {\n    oo += sin(TAU*time*har) * fc/har * ( \n      FMT(f1,v1,q1)  + FMT(f2,v2,q2)  // + FMT(f2,v2,q2)\n    );\n  }\n // oo += 1.*tonnos(FS*time*PI,f1);\n  return oo;\n}\n\nfloat voiceN3(float time,float fc1,float fc2,float fc3,float f1,float v1,float q1,float f2,float v2,float q2) {\n  return voice(time,fc1,f1,v1,q1,f2,v2,q2)+voice(time,fc2,f1,v1,q1,f2,v2,q2)+voice(time,fc3,f1,v1,q1,f2,v2,q2);\n}\n\n#define OSC(L,H,F) ((sin(TAU*gtime*(F))+1.)*.5*((H)-(L))+(L))\n\n/*\n#define F_i  SF( 290., 2200. )\n#define F_I  SF( 375., 2000. )\n#define F_u  SF( 340., 1250. )\n#define F_uu SF( 400., 1100. )\n#define F_o  SF( 425., 1000. )\n#define F_ee SF( 400., 2050. )\n#define F_cc SF( 560., 560. )\n#define F_A  SF( 690., 1400. )\n#define F_a  SF( 850., 1250. )\n#define F_ae SF( 875., 1500. )\n\n#define zSF(A,B)  A, 2.,.5, B, 2., .5 \n*/\n\n\n#define TT .5\n\n#define WHEN(T,CODE) if ( time < (T) ) { CODE; time = 10000.; } time -= (T);\n\nfloat vc1(float time,float FF) {\n\n    float f1, f2, notet, tt, fc, vc;\n\n#define SF(F,A,B) \\\n    if (fc==0.) fc=F, f1=A, f2=B; \\\n    if ( time < TT ) { \\\n        notet = TT - time; \\\n        tt = min( 1., (time)*4. ); \\\n        vc = voice( notet, \\\n            F - (fc-F)*time/2. , \\\n            mix(f1,A,tt), 5., 3.5 , \\\n            mix(f2,B,tt), 4., 3. ); \\\n        time += 1000.; \\\n    } \\\n    time -= TT; \\\n    f1 = A; \\\n    f2 = B; \\\n    fc = F; \\\n\n/*\n///WHEN(.5,vc+=.2*noisei(int(time*102312.)); )\n//WHEN(.3,vc+=voice(time,FF,4000.,2.,.2,12000.,2.,.2);)\n///WHEN(.5,vc+=voice(time,FF,690.,4.,3.,2400.,3.,2.);)\nWHEN(.5,vc+=mix(.4*noisei(int(time*102312.)),voice(time,FF,690.,4.,3.,2400.,3.,2.),time/.5);)\nWHEN(.5,vc+=voice(time,FF,690.,4.,3.,1400.,4.,3.);)\nWHEN(.5,vc+=mix(.2*noisei(int(time*102312.)),voice(time,FF,425.,4.,3.,1000.,3.,2.),time/.5);)\n*/\n\nSF( FF, 375., 2000. )\nSF( FF, 850., 1250. )\nSF( FF, 340., 1250. )\nSF( FF, 290., 2200. )\nSF( FF, 400., 1100. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 340., 1250. )\nSF( FF, 400., 1100. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\n\n    return vc;\n    \n}\n\nfloat note(float time,float rep,float phs,float att,float dur,float dec) {\n  float t=mod(time-phs-att,rep);\n  return t<att ? t/att : t<att+dur ? 1. : exp(-(t-att-dur)/dec);\n}\n\nfloat rhyt(float time,float rep,float phs,float dec) {\n  return note(time,rep,phs,.0002,.0,dec);\n}\n\nfloat pat(float time,float rep,int pbt) {\n  return float((pbt>>int(mod(time,rep*16.)/rep))&1);\n}\n\nfloat ramp(float time,float rep,float lo,float hi) {\n  return fract(time/rep)*(hi-lo)+lo;\n}\n\nfloat stair(float val,float rise) {\n  return floor(val/rise)*rise;\n}\n\n#define ROUNDTO(X,Y) (round((X)/(Y))*(Y))\n\nfloat tonrmp(float time,float f1,float t1,float f2,float t2) {\n  t1=ROUNDTO(t1,f1);\n  t2=ROUNDTO(t2,f2);\n  return time<t1 ? f1 : \n    time<t2 ? f1+(f2-f1)*(time-t1)/(t2-t1)/2. :\n      f2;\n}\n\n#define w 1.\n#define h .5\n#define q .25\n#define e .125\n#define s (e/2.)\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A sh sh\n\n// Just intonation pitches for C, sort of\n#define JC *8./8.\n#define JD *9./8.\n#define JE *10./8.\n#define JF *11./8.\n#define JG *12./8.\n#define JA *13./8.\n#define JBb *14./8.\n#define JB *15./8.\n\n// accidentals\n#define sh * 1.05946\n#define f * 0.9438\n\nvec2 mainSound( int samp, float time )\n{\n\n//return .2*vec2(vc1(time,220.));\n\n    float vc = 0.;\n    \n   // vc += sin(TAU*time*200.)*exp(-.5*PI*time);\n    //return vec2(vc);\n   \n    //time += 52.;\n    //time += 44.;\n\n    if ( time < 22. ) {\n    \n        int secs = int(10.*TT);\n        float xtime = float(samp%(int(iSampleRate)*secs))/iSampleRate;\n\n        //xtime *= 1. + SINC(xtime*20.)*.02; // + SINC(xtime*2.)*.3;\n        \n        /*\n        int t1 = int(time)/secs%6;\n        float[] fcs=float[](220.,330.,110.,110.,55.,55.);\n        float f1=fcs[t1];\n        //float f2=fcs[t1+1];\n        float fc=f1; // tonrmp(time,f1,float(t1)+.7,f2,float(t1+1));\n        */\n\n        vc += vc1(\n          xtime,\n          //fc\n          float[](220.,330.,110.,110.,55.,55.)[int(time)/secs%6]\n        );\n\n    }\n    \n    if ( time > 18. && time < 54. )\n    {\n        float yy=0.;\n        for ( float ii = 6.; ii < 11.; ++ii ) {\n            float ttime = (time+ii/6.)*2.;\n            float ntime = fract(ttime);        \n            int ndx = int(floor(ttime));\n            yy += .3*voice( ntime,\n                time<23.?80.:20.*ii,\n                RND0(250.,1000.,ndx+2+int(ii)), 4., 3.,\n                RND0(350.,2000.,ndx+4+int(ii)), 4., 3.);\n        }\n        vc = mix(vc,yy,clamp(0.,1.,(time-18.)/4.));\n       \n    }\n    \n    if ( time > 48. ) {\n   // vc=0.;\n        //vc *= smoothstep( 3., 0., time-20. );\n      //  vc += tonnos(time,TAU*2000.) ; // * rhyt(time,1.,0.,.5);\n        float yy=0.;     \n        yy += tonnos(time, noisei(int(time/e)) > .5 ? 16000. : 2000.) * rhyt(time,e,0.,s/2.);\n        if ( time > 56. ) {\n        yy += 1.5*tonnos(time, noisei(int(time+1./q)) > .5 ? 400. : 8000.) * rhyt(time,q,0.,s);\n        if ( time > 60. ) {\n        yy += tonnos(time, stair(ramp(time+2.,w*2.,20000.,120.),2000.)) * rhyt(time,h,0.,q);\n        yy += sin(mod(time*TAU*12000.,TAU)) * rhyt(time,w,q+q+q,e);\n        if ( time > 64. ) {\n\n        \n        float xtime = time - 48.;\n        xtime=mod(xtime,1.);\n        //float[] fcs=float[](1.,2.,1./2.,3./2.,2./3.,4./5.,5./4.);\n        //xtime=xtime * (1. + SINC(time*10.)*.1);\n        float fc = 880.;\n        float fc1=fc * (1. + SINC(xtime*40.)*.03*note(time,w*4.,0.,h,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc2=fc * (1. + SINC(xtime*30.)*.03*note(time,w*4.,0.,w,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc3=fc * (1. + SINC(xtime*35.)*.03*note(time,w*4.,0.,h+q,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        //yy=0.;\n        //yy += vc1( xtime, fc ) * note(time,3.*w,0.,e,e,e);\n        yy += .25*voiceN3( xtime,\n                  //fc*fcs[inoisei(int(time/4.)+1)%7],\n                  //fc*fcs[inoisei(int(time/4.)+2)%7],\n                  //fc*fcs[inoisei(int(time/4.)+3)%7],\n                  fc1, fc2*5./4., fc3*1.5,\n                  RND0(200.,1200.,int(time/4.)), //tonnos(time,1./w/8.)*1000.+250.,\n                  4., 3.,\n                  RND0(1200.,4800.,int(time/4.)), //tonnos(time+.1,1./w/8.)*3000.+350.,\n                  4., 3.)\n               * note(time,w*4.,q,q,h,q);\n               \n        } } }\n        vc = mix(vc,yy,clamp(0.,1.,(time-48.)/6.));\n    }\n    \n    return .15*vec2(vc);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/X3t3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "4clcWn", "name": "Radiance Cascades Diagram", "author": "Mytino", "description": "Illustrates the bilinear fix for radiance cascades. The forking fix can also be enabled. The original radiance cascades approach can be seen if both are disabled.", "tags": ["global", "illumination", "bilinear", "radiance", "cascade", "fix", "cascades"], "likes": 7, "viewed": 140, "published": 3, "date": "1721012497", "time_retrieved": "2024-07-18T23:33:47.414233", "image_code": "// Disable these to see classic V1 radiance cascades.\n#define BILINEAR_FIX_ENABLED (true)\n#define FORKING_FIX_ENABLED (false)\n\n// Tests:\n#define CIRCLE_PROJECTION_FIX_ENABLED (false)\n\n#define CELL_SIZE_C0 (iResolution.y * 0.1) // Change this to resize the diagram.\n#define CELL_COUNT_C0_X (8)\n#define CELL_COUNT_C0_Y (8)\n\n#define CASCADE_COUNT (2)\n#define CASCADE_START (0) // Set this to 1 to hide cascade 0 for example.\n\n#define LENGTH_C0 (CELL_SIZE_C0 * 0.5)\n#define DIR_COUNT_C0 (4.0)\n\n#define DIR_COUNT_MULTIPLIER (4.0)\n#define RAY_INTERVAL_LENGTH_MULTIPLIER (4.0)\n#define PROBE_SPACING_MULTIPLIER (2.0)\n\n// Ringing testbed - Places a light in the middle (pausing, 16x16 CELL_COUNT_C0_X/Y and 2 cascades recommended).\n// NOTE: Only works with PROBE_SPACING_MULTIPLIER = 2.0.\n#define RINGING_TESTBED_ENABLED (0) // Set to 1 to enable.\n#define INTENSITY_FACTOR (6.5)\n#define LIGHT_POS_MIN ((vec2(CELL_COUNT_C0_X, CELL_COUNT_C0_Y) * 0.5 - vec2(0.3)) * CELL_SIZE_C0)\n#define LIGHT_POS_MAX ((vec2(CELL_COUNT_C0_X, CELL_COUNT_C0_Y) * 0.5 + vec2(0.3)) * CELL_SIZE_C0)\n\n#define DRAW_ALL_ARROWS (RINGING_TESTBED_ENABLED == 0)\n#define MOUSEOVER_SHOW_CLOSEST_PROBES_NxN (1.0)\n#define ONLY_SHOW_TOP_RIGHT_QUADRANT (false)\n#define ONLY_SHOW_ARROWS_FOR_CLOSEST_INTERPOLATED_PROBE (false) // Keep this at false if using the ringing testbed.\n#define MAKE_ALL_ARROWS_FULLY_OPAQUE (false)\n\n// Extra conditionals to see only one cascade with the difference:\n#define BILINEAR_FIX_ENABLED_C0 (true)\n#define FORKING_FIX_ENABLED_C0 (true)\n#define BILINEAR_FIX_ENABLED_C1 (true)\n#define FORKING_FIX_ENABLED_C1 (true)\n#define BILINEAR_FIX_ENABLED_C2 (true)\n#define FORKING_FIX_ENABLED_C2 (true)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 gridSize = CELL_SIZE_C0 * vec2(CELL_COUNT_C0_X, CELL_COUNT_C0_Y);\n    float cellSizeC1 = CELL_SIZE_C0 * PROBE_SPACING_MULTIPLIER;\n    \n    vec2 worldOffset = -round(vec2(iResolution) * 0.5 - gridSize * 0.5);\n    vec2 pos = fragCoord + worldOffset;\n    vec2 mouse = iMouse.xy + worldOffset;\n\n    vec3 col = vec3(0.8, 0.8, 0.8);\n    \n    // Calculate arrow color (and fluence if testbed is enabled).\n    vec4 allArrowsCol = vec4(0.0);\n    float[CELL_COUNT_C0_X * CELL_COUNT_C0_Y * CASCADE_COUNT] radianceArray;\n    for (int l = 0; l < CELL_COUNT_C0_X * CELL_COUNT_C0_Y * CASCADE_COUNT; l++) radianceArray[l] = 100.0;\n    \n    for (int cInt = CASCADE_COUNT - 1; cInt >= CASCADE_START; cInt--) { // Cascade\n        float c = float(cInt);\n        float dirCount = DIR_COUNT_C0 * pow(DIR_COUNT_MULTIPLIER, c);\n        float dirCountLower = round(dirCount / DIR_COUNT_MULTIPLIER);\n        float cellSize = CELL_SIZE_C0 * pow(PROBE_SPACING_MULTIPLIER, c);\n        float cellSizeUpper = cellSize * PROBE_SPACING_MULTIPLIER;\n        vec3 arrowCol = cInt == 0 ? vec3(1.0, 0.3, 0.3) : cInt == 1 ? vec3(0.3, 0.6, 1.0) : vec3(0.3, 0.6, 0.3);\n        bool bilinearFixEnabled = BILINEAR_FIX_ENABLED && (cInt != 0 || BILINEAR_FIX_ENABLED_C0) && (cInt != 1 || BILINEAR_FIX_ENABLED_C1) && (cInt != 2 || BILINEAR_FIX_ENABLED_C2);\n        bool forkingFixEnabled = FORKING_FIX_ENABLED && (cInt != 0 || FORKING_FIX_ENABLED_C0) && (cInt != 1 || FORKING_FIX_ENABLED_C1) && (cInt != 2 || FORKING_FIX_ENABLED_C2);\n        vec2 probeCount = round(gridSize / cellSize);\n        \n        float tStart = cInt == 0 ? 0.0 : LENGTH_C0 * pow(RAY_INTERVAL_LENGTH_MULTIPLIER, c - 1.0);\n        float tEnd = LENGTH_C0 * pow(RAY_INTERVAL_LENGTH_MULTIPLIER, c);\n        \n        for (float x = 0.0; x < probeCount.x; x++) {\n        for (float y = 0.0; y < probeCount.y; y++) {\n            \n            vec2 probePos = (vec2(x, y) + vec2(0.5)) * cellSize;\n            \n            // Draw-related\n            vec2 mouseDelta = (mouse - probePos) / cellSize;\n            float gap = MOUSEOVER_SHOW_CLOSEST_PROBES_NxN / 2.0;\n            bool drawArrow = true;\n            if ((iMouse.z > 0.0 || !DRAW_ALL_ARROWS) && (mouseDelta.x >= gap || mouseDelta.y >= gap || mouseDelta.x < -gap || mouseDelta.y < -gap)) {\n                if (RINGING_TESTBED_ENABLED == 1) drawArrow = false; else continue;\n            }\n            \n            float dirCountToAverage = cInt == 0 ? DIR_COUNT_C0 : DIR_COUNT_MULTIPLIER;\n            float radianceSum = 0.0;\n            for (float d = 0.0; d < dirCount; d++) { // Directions\n                \n                int dInt = int(d);\n                float angle = (d + 0.5) / dirCount * TAU;\n                vec2 dir = vec2(cos(angle), sin(angle));\n                float angleLower = (floor(d / dirCountToAverage) + 0.5) / dirCountLower * TAU;\n                vec2 dirLower = vec2(cos(angleLower), sin(angleLower));\n                vec2 posStart = probePos + (forkingFixEnabled ? dirLower : dir) * tStart;\n                \n                if (ONLY_SHOW_TOP_RIGHT_QUADRANT && (dir.x < 0.0 || dir.y < 0.0)) { if (RINGING_TESTBED_ENABLED == 1) drawArrow = false; else continue; }\n                vec2 cellPosUpperClosest = floor(probePos / cellSizeUpper);\n                #if (RINGING_TESTBED_ENABLED == 1)\n                    int tileSizeUpper = int(round(cellSizeUpper / CELL_SIZE_C0));\n                    int dirIndexUpper = dInt;\n                    vec2 probePosUpperTopLeft = (floor((probePos - cellSize) / cellSizeUpper) + 0.5) * cellSizeUpper;\n                    vec2 weight = (probePos - probePosUpperTopLeft) / (cellSize * PROBE_SPACING_MULTIPLIER);\n                #endif\n                \n                for (int b = 0; b < (ONLY_SHOW_ARROWS_FOR_CLOSEST_INTERPOLATED_PROBE ? 1 : 4); b++) { // Bilinear interpolation\n                    \n                    vec2 offset01 = vec2(b % 2, b / 2);\n                    vec2 cellPosUpper = ONLY_SHOW_ARROWS_FOR_CLOSEST_INTERPOLATED_PROBE ? cellPosUpperClosest : (floor((probePos - cellSize) / cellSizeUpper) + offset01);\n                    vec2 probePosUpper = (cellPosUpper + 0.5) * cellSizeUpper;\n                    vec2 posEnd = (bilinearFixEnabled ? probePosUpper : probePos) + dir * tEnd;\n                    \n                    if (CIRCLE_PROJECTION_FIX_ENABLED) {\n                        float a = posStart.x - probePosUpper.x, e = posStart.y - probePosUpper.y;\n                        float u = dir.x, v = dir.y, r = tEnd;\n                        float t = (sqrt(-a*a*v*v + 2.0*a*e*u*v - e*e*u*u + r*r*(u*u+v*v)) - a*u - e*v) / (u*u + v*v);\n                        posEnd = posStart + dir * max(t, tStart);\n                    }\n                    \n                    vec3 finalArrowCol = arrowCol;\n                    #if (RINGING_TESTBED_ENABLED == 1)\n                        float weightRel = (offset01.x == 1.0 ? weight.x : (1.0 - weight.x)) * (offset01.y == 1.0 ? weight.y : (1.0 - weight.y));\n                        ivec2 storedPosUpper = ivec2(cellPosUpper) * tileSizeUpper + ivec2(dirIndexUpper / tileSizeUpper, dirIndexUpper % tileSizeUpper);\n                        int arrayIndexUpper = (cInt + 1) * CELL_COUNT_C0_X * CELL_COUNT_C0_Y + storedPosUpper.y * CELL_COUNT_C0_X + storedPosUpper.x;\n                        bool ignoreRadiance = cInt >= CASCADE_COUNT - 1 || any(lessThan(storedPosUpper, ivec2(0))) || storedPosUpper.x >= CELL_COUNT_C0_X || storedPosUpper.y >= CELL_COUNT_C0_Y;\n                        float radianceUpper = ignoreRadiance ? 0.0 : radianceArray[arrayIndexUpper];\n                        float radianceLower = intersectLight(posStart, posEnd, LIGHT_POS_MIN, LIGHT_POS_MAX);\n                        radianceSum += (radianceLower + radianceUpper) * weightRel;\n                        if (radianceLower > 0.0) finalArrowCol *= 2.5;\n                    #endif\n                    if (RINGING_TESTBED_ENABLED == 0 || (RINGING_TESTBED_ENABLED == 1 && drawArrow)) {\n                        float arrow = sdf_arrow(pos - posStart, length(posEnd - posStart), normalize(posEnd - posStart), 3.0, 1.0);\n                        allArrowsCol = mix(allArrowsCol, vec4(finalArrowCol, 1.0), smoothstep(1.5, 0.0, arrow) * (all(equal(cellPosUpper, cellPosUpperClosest)) ? 1.0 : (MAKE_ALL_ARROWS_FULLY_OPAQUE ? 1.0 : 0.25)));\n                    }\n                }\n                \n                #if (RINGING_TESTBED_ENABLED == 1)\n                    if ((dInt % int(dirCountToAverage)) == int(dirCountToAverage) - 1) {\n                        int tileSize = int(round(cellSize / CELL_SIZE_C0));\n                        int dirIndex = dInt / int(dirCountToAverage);\n                        ivec2 storedPos = ivec2(x, y) * tileSize + ivec2(dirIndex / tileSize, dirIndex % tileSize);\n                        int arrayIndexLower = cInt * CELL_COUNT_C0_X * CELL_COUNT_C0_Y + storedPos.y * CELL_COUNT_C0_X + storedPos.x;\n                        radianceArray[arrayIndexLower] = radianceSum / dirCountToAverage;\n                        radianceSum = 0.0;\n                    }\n                #endif\n            }\n        }}\n    }\n    \n    // Draw:\n    \n    if (all(lessThan(pos, gridSize)) && all(greaterThan(pos, vec2(0.0)))) {\n        #if (RINGING_TESTBED_ENABLED == 1)\n            ivec2 cellPos = ivec2(floor(pos / CELL_SIZE_C0));\n            float fluence = radianceArray[0 + cellPos.y * CELL_COUNT_C0_X + cellPos.x] * INTENSITY_FACTOR;\n            col = vec3(fluence);\n            col += any(lessThan(abs(pos - round(pos / CELL_SIZE_C0) * CELL_SIZE_C0), vec2(1.0))) ? 0.02 : 0.0; // Small grid\n            col += any(lessThan(abs(pos - round(pos / cellSizeC1) * cellSizeC1), vec2(1.0))) ? 0.02 : 0.0; // Large grid\n            col = mix(col, vec3(1.0, 1.0, 0.0), float(all(greaterThanEqual(pos, LIGHT_POS_MIN)) && all(lessThan(pos, LIGHT_POS_MAX)))); // Light source\n        #else\n            col *= any(lessThan(abs(pos - round(pos / CELL_SIZE_C0) * CELL_SIZE_C0), vec2(1.0))) ? 0.96 : 1.0; // Small grid\n            col *= any(lessThan(abs(pos - round(pos / cellSizeC1) * cellSizeC1), vec2(1.0))) ? 0.8 : 1.0; // Large grid\n        #endif\n    }\n    \n    // Add arrow graphics.\n    col = col * (1.0 - allArrowsCol.a) + allArrowsCol.rgb;\n    \n    if (all(lessThan(pos, gridSize)) && all(greaterThan(pos, vec2(0.0)))) {\n        #if (RINGING_TESTBED_ENABLED == 0)\n            col *= smoothstep(1.5, 2.0, length(pos - (floor(pos / CELL_SIZE_C0) + 0.5) * CELL_SIZE_C0)); // Small probe\n            col *= smoothstep(7.0, 8.0, length(pos - (floor(pos / cellSizeC1) + 0.5) * cellSizeC1)); // Large probe\n        #endif\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265358979\n#define TAU (2.0 * PI)\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\n#define m_stretch_neg(p, st) (.5 * m_stretch(2. * p + st, st))  /* Stretch-negative: positive values are fixed */\n#define m_stretch_pos(p, st) (.5 * m_stretch(2. * p, st))  /* Stretch-positive: negative values are fixed */\n\n// A fast \"manual\" lossy rotate function by ollj.\n// Control the angle of rotation by specifying the ROTATE_PARAM constants.\n// https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);  // Try changing these!\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n// NOTE: Very slightly modified - Mytino.\n// Optimized arrow SDF, by ollj\n// @head_len isn't actual uv units, but the unit size depends on ROTATE_PARAMs\nfloat sdf_arrow(vec2 uv, float norm, vec2 dir, float head_height, float stem_width){\n    uv = vec2(dir.x * uv.x + dir.y * uv.y, -dir.y * uv.x + dir.x * uv.y);\n\n    norm -= head_height;  // Make sure the norm INCLUDES the arrow head\n    uv.x -= norm;  // Place the arrow's origin at the stem's base!\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = m_stretch_neg(uv.x, norm);\n    uv.y = m_stretch_pos(uv.y, stem_width);\n    float stem = length(uv);\n\n    return min(head, stem);  // Join head and stem!\n}\n// ------------------------------------------------------------------------------------------------\n\nfloat LengthSq(vec2 v) { return dot(v, v); }\nfloat Pow2(float v) { return v * v; }\n\nfloat intersectLight(vec2 rayStart, vec2 rayEnd, vec2 boxPosMin, vec2 boxPosMax) {\n    vec2 dir = normalize(rayEnd - rayStart);\n    vec2 t = (vec2(boxPosMin.x, boxPosMax.x) - rayStart.x) / dir.x; float tMin = min(t.x, t.y), tMax = max(t.x, t.y);\n    t = (vec2(boxPosMin.y, boxPosMax.y) - rayStart.y) / dir.y; tMin = max(tMin, min(t.x, t.y)); tMax = min(tMax, max(t.x, t.y));\n    if (tMax < tMin || (tMin < 0.0 && tMax < 0.0) || tMin > length(rayEnd - rayStart)) return 0.0;\n\treturn 1.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4clcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "lffyDr", "name": "ADSR - Image/Sound", "author": "taylormatson", "description": "Change the envelope parameters in the common tab.", "tags": ["sound", "image", "decay", "attack", "sustain", "release"], "likes": 3, "viewed": 54, "published": 3, "date": "1721003326", "time_retrieved": "2024-07-18T23:33:48.253988", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Total envelope time\n    float totalTime = 1./BPM*60.;\n    \n    // Loop the envelope for demonstration purposes\n    float loopTime = mod(iTime, totalTime)/totalTime;\n    \n    // Calculate the envelope value\n    float envelope = adsr(loopTime, attack, decay, sustain, release);\n    \n    // Use the envelope to modulate the color\n    vec3 color = vec3(envelope);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    \n    float sps = iSampleRate*15.*BPM;\n    \n    float s2t = sps/iSampleRate; \n\n    // Total envelope time\n    // float totalTime = attack + decay + sustain + release;\n    \n    // float totalTime = float(samp)/iSampleRate/16./s2t;\n    \n    float totalTime = 1./BPM*60.;\n    \n    // Loop the envelope for demonstration purposes\n    float loopTime = mod(time, totalTime)/totalTime;\n    \n    // Calculate the envelope value\n    float envelope = adsr(loopTime, attack, decay, sustain, release);\n    \n    float F = 80.;\n    \n    return 0.7071*vec2(envelope*sin(TAU*F*time));\n    \n}", "sound_inputs": [], "common_code": "const float PI = 3.1415926535;\nconst float TAU = 2.*PI;\nconst float BPM = 120.00;\n\n// Envelope parameters\nconst float attack = .5;\nconst float decay = 1.;\nconst float sustain = .0;\nconst float release = .1;\n\n// ADSR Envelope function\nfloat adsr(float time, float attack, float decay, float sustain, float release) {\n    \n    float level;\n    \n    if (time < attack) {\n        // Attack phase: Linear rise from 0 to 1\n        level = time / attack;\n        \n    } else if (time < attack + decay) {\n        // Decay phase: Linear fall from 1 to sustain level\n        level = 1.0 + (sustain - 1.0) * (time - attack) / decay;\n        \n    } else if (time < attack + decay + sustain) {\n        // Sustain phase: Maintain sustain level\n        level = sustain;\n        \n    } else if (time < attack + decay + sustain + release) {\n        // Release phase: Linear fall from sustain level to 0\n        level = sustain * (1.0 - (time - attack - decay - sustain) / release);\n        \n    } else {\n        // After release: Return to 0\n        level = 0.0;\n    }\n    \n    return level;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lffyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 584]], "test": "error"}
{"id": "MffyWn", "name": "Spaceship Generator", "author": "leon", "description": "Inspired by Chris Foss colors and patterns.", "tags": ["space", "scifi", "spaceship"], "likes": 42, "viewed": 234, "published": 3, "date": "1721002344", "time_retrieved": "2024-07-18T23:33:49.114687", "image_code": "\n// Spaceship Generator\n// 2024-07-15 Leon Denise\n\n// edited 2024-07-15: added reprojection TAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\n\nmat3 look(vec3 z)\n{\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x,y,z);\n}\n\nfloat gyroid (vec3 p) { return dot(cos(p),sin(p.yzx)); }\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// Inigo Quilez https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n", "buffer_a_code": "\n// Spaceship Generator\n// 2024-07-15 Leon Denise\n\n// space ship seed\nconst float seed = 196.;\n#define animate\n\n// globals\nvec3 coord, dither;\nfloat disp, glitch;\nfloat mat;\n\n// noise\nfloat fbm(vec3 p) {\n    float result = 0., a = .5;\n    for (float i = 0.; i < 5.; ++i) {\n        p += result*.1;\n        result += abs(atan(gyroid(p/a))*a);\n        a /= 2.;\n    }\n    return result;\n}\n\n// sky\nvec3 get_sky(vec3 p) {\n\n    // cosmic dust\n    vec2 e = vec2(0.5,0)+.1*dither.y;\n    #define T(u) fbm(p+u)\n    vec3 normal = normalize(T(0.)-vec3(T(e.xyy),T(e.xyx),T(e.xxy)));\n    vec3 color = .5 + .5 * cos(vec3(1,2,3)*5.5+normal.x*.7+4.);\n    color *= smoothstep(-2.0,2.0,-abs(normal.z)+.5+dither.x);\n    normal.yz *= rot(.5);\n    color += (normal.y)*.2;\n    \n    // stars\n    for (float i = 1.; i < 8.; ++i) {\n        vec3 q = p*10.*i;\n        vec3 rng = hash33(floor(q)+196.);\n        float dist = length(fract(q)-.5)*2.;\n        float threshold = step(.95,rng.x);\n        float light = (1.-sqrt(dist))*.1/dist;\n        color += vec3(threshold*clamp(light,0.,1.)/2.);\n    }\n    \n    return color;\n}\n\n// spaceship sdf\nfloat map (vec3 p)\n{\n    float dist = 100.;\n    vec3 pos = p;\n    \n    // animate seed\n    float t = seed;\n    #ifdef animate\n    t += floor(iTime/5.+glitch*.1)*32.;\n    #endif\n    \n    // pattern details\n    vec3 q = p;\n    q.xy *= rot(.9);\n    q.xz *= rot(.5);\n    q = (abs(fract(q*2.)-.5))*2.;\n    float s = max(q.x,max(q.y,q.z));\n    \n    // kaleidoscopic space folding\n    float a = 1.;\n    vec3 e = vec3(.5,.1,.1);\n    for (float i = 0.; i < 4.; ++i)\n    {\n        p = p-clamp(p,-e*a,e*a);\n        p.xz = abs(p.xz)-.5*a;\n        p.xz *= rot(t*a);\n        p.yz *= rot(t*a);\n        a /= 1.8;\n    }\n    \n    // spaceship\n    dist = sdBox(p,vec3(.065));\n    \n    // details displace\n    dist += abs(fract(abs(s)*10.)-.5)*.01;\n    \n    // joints\n    dist = min(dist, length(p.xz)-.005);\n    dist = min(dist, length(p.yz)-.005);\n    dist = min(dist, length(p.yx)-.005);\n    \n    coord = p;\n    disp = s;\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.25);\n    \n    // coordinages\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 cam = vec3(0,1,-3.);\n    vec3 ray = normalize(vec3(p,1.));\n    \n    // blue noise scroll https://www.shadertoy.com/view/tlySzR\n    ivec2 pp = ivec2(fragCoord);\n    pp = (pp+(int(iFrame))*ivec2(113,127)) & 1023;\n    dither = texelFetch(iChannel1,pp,0).xyz;\n    \n    // glitch\n    vec4 rng = hash41(floor(iTime*10.));\n    glitch = hash33(vec3(floor(uv*40.*rng.xy*vec2(1.,3.)), 0.)).x;\n    \n    if (iMouse.z > 0.)\n    {\n        // mouse control\n        vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n        cam.yz *= rot(-mouse.y);\n        cam.xz *= rot(mouse.x);\n    }\n    else\n    {\n        // turn table animation\n        cam.xz *= rot(iTime/16.);\n        cam.y += sin(iTime/10.)*.5;\n    }\n    \n    \n    // camera rotation\n    ray = look(normalize(-cam)) * ray;\n    vec3 pos = cam + ray * dither.z * .1;\n    \n    // raymarch\n    float ratio = 1.;\n    float total = 0.;\n    for (ratio = 1.; ratio > 0.; ratio -= 1./200.)\n    {\n        float dist = map(pos);\n        if (dist < 0.001 * total || total > 10.) break;\n        dist *= 0.9 + 0.1 * dither.z;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    if (total < 10.)\n    {\n        vec3 c = coord;\n        float d = disp;\n        float m = mat;\n        \n        // lighting \n        vec2 e = vec2(.001,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos+e.xyy),map(pos+e.yxy),map(pos+e.yyx)));\n        vec3 rf = reflect(ray, normal);\n        float light = clamp(dot(rf, normalize(vec3(0,.1,-1)))*.5+.5,0.,1.);\n        \n        // patterns\n        vec3 q = (abs(fract(c*20.)-.5))*2.;\n        float s = max(q.x,max(q.y,q.z));\n        vec3 tint = .5+.5*cos(vec3(1,2,3)*5.+floor(s*8.)/3.+5.);\n        float pattern = smoothstep(.01,.0,abs(fract(abs(d)*2.)-.5)-.2);\n\n        // coloring\n        color = tint*pattern;\n        color += pow(light, 4.);\n        color += get_sky(rf)*(1.-pattern);\n        color *= ratio;\n    }\n    else\n    {\n        // background\n        color = get_sky(ray);\n    }\n    \n    if (fragCoord.y < 1.)\n    {\n        if (fragCoord.x < 1.) color = cam;\n    }\n    else if (fragCoord.y < 2.)\n    {\n        if (fragCoord.x < 1.) color = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    }\n    \n    fragColor = vec4(color, total);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Minimal Temporal Anti Aliasing\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// from P_Malin https://www.shadertoy.com/view/4dlyWX\nvec2 world_to_uv(vec3 world, vec3 cam_pos, vec3 cam_target, vec2 aspect)\n{\n    vec3 z = world - cam_pos;\n    vec3 cam = z * look(normalize(cam_target-cam_pos));\n    vec2 screen = cam.xy / cam.z;\n    return (screen/aspect)*.5+.5;\n}\n\nvec2 reproject_uv(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1);\n    vec4 frame = texture(iChannel0, uv);\n    \n    // camera positions between frames\n    vec3 cam_pos_now = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec3 cam_pos_prev = texelFetch(iChannel0, ivec2(0,1), 0).xyz;\n    \n    // camera constants\n    vec3 cam_target = vec3(0);\n    vec3 cam_ray_now = normalize(vec3(p,1.));\n    cam_ray_now = look(normalize(-cam_pos_now)) * cam_ray_now;\n    \n    // reproject depth to get world pos\n    vec3 world_now = cam_pos_now + cam_ray_now * frame.a;\n    \n    // world pos to previous camera screen space\n    return world_to_uv(world_now, cam_pos_prev, cam_target, aspect);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // blue noise scroll https://www.shadertoy.com/view/tlySzR\n    ivec2 pp = ivec2(fragCoord);\n    pp = (pp+(int(iFrame))*ivec2(113,127)) & 1023;\n    vec3 dither = texelFetch(iChannel2,pp,0).xyz;\n    uv += 1.*(dither.xy-.5)/iResolution.xy;\n    \n    // reprocted previous frame\n    vec2 uv_prev = reproject_uv(fragCoord.xy);\n    vec3 temporal = texture(iChannel1, uv_prev).rgb;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n    \n    //fragColor = vec4(screen, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MffyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 236]], "test": "error"}
{"id": "4ffcDn", "name": "perlin noise culegamer", "author": "CuleGamer", "description": "it sort of works, but the code is awful", "tags": ["noise"], "likes": 2, "viewed": 47, "published": 3, "date": "1720978949", "time_retrieved": "2024-07-18T23:33:49.945466", "image_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat cerp(float a, float b, float t)\n{\n    return a*(2.*t*t*t-3.*t*t+1.)+b*(-2.*t*t*t+3.*t*t);\n}\n\nvec2 randVec(vec2 pos)\n{\n    float theta = 3.14159 * hash12(pos) + iTime;\n    return vec2(cos(theta), sin(theta));\n}\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 uv = 4. * (2. * I - iResolution.xy)/iResolution.y;\n    vec3 col;\n    float val;\n    vec2 gridPos = fract(uv);\n    vec2 gridCorner;\n    vec2 cornerVec;\n    vec2 offset;\n    float cornerVal[4];\n    for(uint i; i < 4u; i++)\n    {\n        offset = vec2(i & 1u, i >> 1u);\n        //order of offset\n        //[3][4]\n        //[1][2]\n        gridCorner = floor(uv) + offset;\n        cornerVec = gridPos - offset;\n        cornerVal[i] = dot(cornerVec, randVec(gridCorner));\n    }\n    val = cerp(cerp(cornerVal[0], cornerVal[1], gridPos.x), cerp(cornerVal[2], cornerVal[3], gridPos.x), gridPos.y);\n    val = 0.5 * val + 0.5;\n    col = vec3(val);\n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ffcDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 139], [141, 141, 180, 180, 238], [240, 240, 264, 264, 356], [357, 357, 396, 396, 1067]], "test": "ok"}
{"id": "4ffcWn", "name": "Test water11111111111", "author": "Dizl", "description": "test", "tags": ["test"], "likes": 1, "viewed": 70, "published": 3, "date": "1720974477", "time_retrieved": "2024-07-18T23:33:50.800181", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 data = texture(iChannel0, uv);\n    \n    // Brightness = water height\n    //fragColor.xyz = vec3(data.x + 1.0) / 2.0;\n    \n    // Color = texture\n    fragColor = texture(iChannel1, uv + 0.2 * data.zw);\n    \n    // Sunlight glint\n    vec3 normal = normalize(vec3(-data.z, 0.2, -data.w));\n    fragColor += vec4(1) * pow(max(0.0, dot(normal, normalize(vec3(-3, 10, 3)))), 60.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Make this a smaller number for a smaller timestep.\n// Don't make it bigger than 1.4 or the universe will explode.\nconst float delta = 1.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {fragColor = vec4(0); return;}\n    \n    float pressure = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    float pVel = texelFetch(iChannel0, ivec2(fragCoord), 0).y;\n\n    float p_right = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float p_left = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0).x;\n    float p_up = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float p_down = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0, -1), 0).x;\n    \n    // Change values so the screen boundaries aren't fixed.\n    if (fragCoord.x == 0.5) p_left = p_right;\n    if (fragCoord.x == iResolution.x - 0.5) p_right = p_left;\n\tif (fragCoord.y == 0.5) p_down = p_up;\n    if (fragCoord.y == iResolution.y - 0.5) p_up = p_down;\n\n    // Apply horizontal wave function\n    pVel += delta * (-2.0 * pressure + p_right + p_left) / 4.0;\n    // Apply vertical wave function (these could just as easily have been one line)\n    pVel += delta * (-2.0 * pressure + p_up + p_down) / 4.0;\n    \n    // Change pressure by pressure velocity\n    pressure += delta * pVel;\n    \n    // \"Spring\" motion. This makes the waves look more like water waves and less like sound waves.\n    pVel -= 0.005 * delta * pressure;\n    \n    // Velocity damping so things eventually calm down\n    pVel *= 1.0 - 0.002 * delta;\n    \n    // Pressure damping to prevent it from building up forever.\n    pressure *= 0.999;\n    \n    //x = pressure. y = pressure velocity. Z and W = X and Y gradient\n    fragColor.xyzw = vec4(pressure, pVel, (p_right - p_left) / 2.0, (p_up - p_down) / 2.0);\n    \n    \n    if (iMouse.z > 1.0) {\n        float dist = distance(fragCoord, iMouse.xy);\n        if (dist <= 20.0) {\n            fragColor.x += 1.0 - dist / 20.0;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ffcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 534]], "test": "error"}
{"id": "4flyzN", "name": "DDA - Visualizer", "author": "anujv", "description": "Digital Differential Analysis Visualizer\n\n- to move second point: left click + drag", "tags": ["2d", "voxel", "dda"], "likes": 2, "viewed": 35, "published": 3, "date": "1720974276", "time_retrieved": "2024-07-18T23:33:51.654896", "image_code": "\n// in pixles\n#define GRID_SIZE     40\n#define POINT_SIZE_SQ 20.0f\n#define LINE_WIDTH_SQ 2.0f\n\n#define BIAS 0.0001f\n\n#define GRID_COLOR   vec4(0.3f, 0.3f, 0.0f, 1.0f)\n#define POINT_COLOR  vec4(1.0f, 0.0f, 0.0f, 1.0f)\n#define STEP_COLOR   vec4(0.1f, 0.9f, 0.1f, 1.0f)\n#define CELL_COLOR   vec4(0.1f)\n#define LINE_COLOR   vec4(0.1f, 0.6f, 0.4f, 1.0f)\n#define LINE_COLOR2  vec4(0.7f, 0.3f, 0.2f, 1.0f)\n#define BLOCK_COLOR  vec4(0.0f, 1.0f, 0.5f, 1.0f)\n\nfloat draw_point(in vec2 pos, in vec2 frag_coord);\n\n// --------------------------- utils --------------------------- //\n\nstruct Box {\n    vec2 min_pos;\n    vec2 max_pos;\n};\n\nfloat rand(float co) {\n    return fract(sin(co*(91.3458)) * 47453.5453); }\n\nbool aabb_with_line(in vec2 a, in vec2 b, in Box box) {\n    vec2 d = b - a;\n\n    if (d.x < 0.0f) {\n        float temp = box.min_pos.x;\n        box.min_pos.x = box.max_pos.x;\n        box.max_pos.x = temp;\n    }\n    \n    if (d.y < 0.0f) {\n        float temp = box.min_pos.y;\n        box.min_pos.y = box.max_pos.y;\n        box.max_pos.y = temp;\n    }\n    \n    vec2 min_t = (box.min_pos - a) / d;\n    vec2 max_t = (box.max_pos - a) / d;\n    \n    float t_min = max(min_t.x, min_t.y);\n    float t_max = min(max_t.x, max_t.y);\n    \n    if (t_min < t_max && max(t_min, t_max) > 0.0f && min(t_min, t_max) <= 1.0f) {\n        return true;\n    }\n\n    return false;\n}\n\nbool point_with_line(in vec2 a, in vec2 b, in vec2 c, float line_width_sq, out float dist_sq) {\n    vec2 d = b - a;\n    float t = (dot(d, vec2(c)) - dot(d, a)) / dot(d, d);\n    if (t < 0.0f || t > 1.0f) return false;\n    \n    vec2 p = (a + d * t) - c;\n    dist_sq = dot(p, p);\n    return dist_sq < line_width_sq;\n}\n\n// randomly select cells to be filled\nbool is_filled(in vec2 block_coord) {\n    float seed = block_coord.x * block_coord.y;\n    return fract(sin(seed * 91.3458f) * 47453.5453f) > 0.8f;\n}\n\n// return true if line intersect any filled block\n// color is just used to draw step points\nbool dda(in vec2 a, in vec2 b, out float t_out, in vec2 frag_coord, inout vec4 color) {\n    int max_steps = int(ceil(max(iResolution.x / float(GRID_SIZE), iResolution.y / float(GRID_SIZE))));\n    \n    vec2 d = b - a;\n    vec2 d_sign = sign(d);\n    vec2 cell_coord = floor(a / vec2(GRID_SIZE));\n    vec2 next_edge = cell_coord + vec2(1.0f) * vec2(equal(d_sign, vec2(1.0f)));\n    \n    for (int i = 0; i < max_steps; i++) {\n        vec2 t = (next_edge * vec2(GRID_SIZE) - a) / d;\n        float t_min = min(t.x, t.y);\n        vec2 pos = a + d * (t_min + BIAS);\n        cell_coord = floor(pos / vec2(GRID_SIZE));\n        if (is_filled(cell_coord)) {\n            t_out = t_min;\n            return true;\n        }\n        if (t_min >= 1.0f) {\n            break;\n        }\n        color += STEP_COLOR * draw_point(pos, frag_coord);\n        next_edge += d_sign * vec2(lessThanEqual(t, vec2(t_min)));\n    }\n    \n    return false;\n}\n\n// --------------------------------------------------------------//\n\nfloat draw_grid(in vec2 frag_coord) {\n    if (int(abs(frag_coord.x)) % GRID_SIZE == 0 || int(abs(frag_coord.y)) % GRID_SIZE == 0) {\n        return 1.0f;\n    }\n    \n    return 0.0f;\n}\n\nfloat draw_point(in vec2 pos, in vec2 frag_coord) {\n    vec2 diff = frag_coord - pos;\n    float dist = dot(diff, diff);\n    if (dist <= POINT_SIZE_SQ) {\n        return smoothstep(POINT_SIZE_SQ, 0.0f, dist);\n    }\n    \n    return 0.0f;\n}\n\nfloat draw_line(in vec2 pos_a, in vec2 pos_b, in vec2 frag_coord) {\n    float dist = 0.0f;\n    if (point_with_line(pos_a, pos_b, frag_coord, LINE_WIDTH_SQ, dist)) {\n        return smoothstep(LINE_WIDTH_SQ, 0.0f, dist);\n    }\n    \n    return 0.0f;\n}\n\nfloat draw_cell(in vec2 pos_a, in vec2 pos_b, in vec2 frag_coord) {\n    vec2 cell_coord = floor(frag_coord / vec2(GRID_SIZE)) * vec2(GRID_SIZE);\n    Box box;\n    box.min_pos = cell_coord;\n    box.max_pos = cell_coord + vec2(GRID_SIZE);\n    \n    if (aabb_with_line(pos_a, pos_b, box)) {\n        return 1.0f;\n    }\n    \n    return 0.0f;\n}\n\nfloat draw_blocks(in vec2 frag_coord) {\n    vec2 block_coord = floor(frag_coord / vec2(GRID_SIZE));\n    return is_filled(block_coord) ? 1.0f : 0.0f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 color = vec4(0.0f);\n    vec2 frag_coord = fragCoord - (iResolution.xy / 2.0f);\n    \n    vec2 a = vec2(0.0f);\n    vec2 b = vec2(sin(iTime * 0.3f), cos(iTime * 0.3f)) * max(iResolution.x, iResolution.y);\n    if (iMouse.z > 0.0f) {\n        b = iMouse.xy - (iResolution.xy / 2.0f);\n    }\n    vec2 hit_b = b;\n    vec2 d = b - a;\n    \n    float hit_t = 0.0f;\n    bool hit = dda(a, b, hit_t, frag_coord, color);\n    if (hit) {\n        hit_b = a + d * (hit_t - BIAS);\n        color += STEP_COLOR * draw_point(hit_b, frag_coord);\n    }\n    \n    // draw grid\n    color += GRID_COLOR * draw_grid(frag_coord);\n    \n    // draw points a and b\n    color += POINT_COLOR * draw_point(a, frag_coord);\n    color += POINT_COLOR * draw_point(b, frag_coord);\n    \n    // draw lines\n    color += LINE_COLOR * draw_line(a, hit_b, frag_coord);\n    if (hit) {\n        color += LINE_COLOR2 * draw_line(hit_b, b, frag_coord);\n    }\n    \n    // draw tested blocks\n    color += CELL_COLOR * draw_cell(a, hit_b, frag_coord);\n    \n    // draw solid blocks\n    color += BLOCK_COLOR * draw_blocks(frag_coord);\n    \n    fragColor = vec4(color.xyz, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[624, 624, 646, 646, 698], [700, 700, 755, 755, 1354], [1356, 1356, 1451, 1451, 1670], [1672, 1710, 1747, 1747, 1858], [1860, 1952, 2039, 2039, 2873], [2944, 2944, 2981, 2981, 3126], [3128, 3128, 3179, 3179, 3364], [3366, 3366, 3433, 3433, 3614], [3616, 3616, 3683, 3683, 3952], [3954, 3954, 3993, 3993, 4104], [4106, 4106, 4161, 4161, 5293]], "test": "ok"}
{"id": "Mfsyz7", "name": "Spectral Ray Tracing", "author": "javirk", "description": "Very simple spectral ray tracer. The index of refraction of dielectric materials depends on the wavelength via the Cauchy equation.", "tags": ["raytracer", "ray", "tracing", "spectral"], "likes": 19, "viewed": 207, "published": 3, "date": "1720969035", "time_retrieved": "2024-07-18T23:33:52.672177", "image_code": "// Spectral Ray Tracing. Created by Javier Gamazo - 2024\n// The MIT License\n//\n// https://www.shadertoy.com/view/tl23Rm\n// Taking some parts from https://www.shadertoy.com/view/tl23Rm and https://www.shadertoy.com/view/tsKyWG\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Ray Tracing - Primitives. Created by Javier Gamazo 2024\n//\n// I have combined different intersection routines in one shader (similar \n// to \"Raymarching - Primitives\": https://www.shadertoy.com/view/Xds3zN) and\n// added a simple ray tracer to visualize a scene with all primitives.\n// Functions for CIE from https://www.shadertoy.com/view/tsKyWG\n\n#define PI 3.14159265358979323\n#define PATH_LENGTH 12\n\n#define LOWER_BOUND 450\n#define UPPER_BOUND 750\n#define NUM_WAVELENGTHS 20\n// #define MOVE_CAMERA\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nconst mat3 XYZ_2_RGB = (mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n));\n\nconst mat3 RGB_2_XYZ = (mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041\n));\n\nfloat gaussian(float x, float mu, float sigma)\n{\n    return 1.0 / (sigma * sqrt(2.0 * PI)) * exp(-(x-mu)*(x-mu)/(2.*sigma*sigma));\n}\n\n\n// The CIE color matching functions were taken from  https://www.fourmilab.ch/documents/specrend\n// The tabulated functions then were approximated with gaussians (for G and B) and with a mixture of two gaussiuns (R).\nvec3 wavelength2XYZ(float l)\n{\n\treturn vec3(\n    \t8233.31 * gaussian(l, 593.951, 34.00) + 1891.26 * gaussian(l, 448.89, 18.785),\n        10522.64 * gaussian(l, 555.38, 40.80),\n        11254.78 * gaussian(l, 452.98, 21.57)\n    );\n}\n\nfloat XYZ2WavelengthApprox(float l, vec3 color) {\n    return dot(wavelength2XYZ(l), color) / 100.0;\n}\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float wavelength;\n};\n\nstruct Material\n{\n    int   materialType;\n    vec3  albedo;\n    float fuzz;\n    float refractionIndex;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 p;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    Material mat;\n};\n\nSphere sceneList[] = Sphere[3](\n    Sphere(\n        vec3(0., 0., 0.),\n        1.,\n        Material(DIELECTRIC, vec3(.5, .4, .4), 1., 1.5)\n    ),\n    Sphere(\n        vec3(1.5, 0.2, 0.2),\n        0.2,\n        Material(DIELECTRIC, vec3(.5, .4, .4), 1., 1.5)\n    ),\n    Sphere(\n        vec3(0., -1001., 0.),\n        1000.,\n        Material(LAMBERTIAN, vec3(.5, .5, .2), .4, 0.)\n    )\n);\n\n\nbool Sphere_hit(Sphere sphere, Ray ray, float t_min, float t_max, out Hit rec)\n{\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n\n    float discriminant = b * b - a * c;\n\n    if (discriminant > 0.0f)\n    {\n        float temp = (-b - sqrt(discriminant)) / a;\n\n        if (temp < t_max && temp > t_min){\n            rec.t = temp;\n            rec.p = ray.origin + rec.t * ray.direction;\n            rec.normal = (rec.p - sphere.center) / sphere.radius;\n            rec.mat = sphere.mat;\n            return true;\n        }\n\n        temp = (-b + sqrt(discriminant)) / a;\n\n        if (temp < t_max && temp > t_min){\n            rec.t = temp;\n            rec.p = ray.origin + rec.t * ray.direction;\n            rec.normal = (rec.p - sphere.center) / sphere.radius;\n            rec.mat = sphere.mat;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection(const vec3 n, inout float seed) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 modifyDirectionWithRoughness(const vec3 normal, const vec3 n, const float roughness, inout float seed) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY(const in vec3 p, const in float t) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nbool opU(inout vec2 d, float iResult, in Material mat) {\n    if (iResult < d.y) {\n        d.y = iResult;\n        return true;\n    }\n    return false;\n}\n\n//\n// Palette by Íñigo Quílez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(6.28318530718 * (c * t + d));\n}\n\nfloat checkerBoard(vec2 p) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nbool worldhit(in Ray ray, in vec2 dist, out Hit rec) {\n    Hit temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = dist.y;\n\n    for (int i = 0; i < sceneList.length(); i++) {\n        if (Sphere_hit(sceneList[i], ray, dist.x, closest_so_far, temp_rec)) {\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n\n\nvec3 getSkyColor(vec3 rd) {\n    vec3 col = mix(vec3(1), vec3(.5, .7, 1), .5 + .5 * rd.y);\n    col = vec3(0.);\n    float sun = clamp(dot(normalize(vec3(-0.3, .7, -.6)), rd), 0., 1.);\n    col += vec3(1, .6, .1) * (pow(sun, 4.) + 10. * pow(sun, 32.));\n    return col;\n}\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat reflectivity(float n1_over_n2, float cosTheta, float wavelenght) {\n    float r0 = (n1_over_n2 - 1.) / (n1_over_n2 + 1.);\n    r0 = r0*r0;\n    return r0 + (1. - r0) * pow((1. - cosTheta), 5.);\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1. - r0) * pow(abs(1. - cosine), 5.);\n}\n\nvec3 refract_mine(vec3 v, vec3 n, float ni_over_nt) {\n    float cos_theta = min(dot(-v, n), 1.0);\n    vec3 r_out_perp = ni_over_nt * (v + cos_theta * n);\n    vec3 r_out_parallel = -sqrt(abs(1. - dot(r_out_perp, r_out_perp))) * n;\n    return r_out_perp + r_out_parallel;\n}\n\nfloat skyColor(Ray ray) {\n\tvec3 sky = getSkyColor(ray.direction);\n    sky = RGB_2_XYZ * pow(sky, vec3(2.2));\n    return XYZ2WavelengthApprox(ray.wavelength, sky) * 0.5;\n}\n\nfloat n_wavelength(float lambda_nm) {\n    float lambda_um = lambda_nm / 1000.0;\n    \n    // Coefficients for Cauchy's equation, adjusted to fit the range 1 < n < 2 for visible spectrum\n    float A = 0.438;\n    float B = 0.316;\n    \n    // Calculate refractive index\n    float n_lambda = A + B / (lambda_um * lambda_um);\n    \n    return n_lambda;\n}\n\n\nfloat trace(in Ray ray, inout float seed) {\n    vec3 albedo = vec3(1.); \n    float roughness, type;\n    Material mat;\n    Hit rec;\n    float intensity = 1.;\n    \n    for (int i = 0; i < PATH_LENGTH; ++i) {    \n    \tbool didHit = worldhit(ray, vec2(.001, 100), rec);\n        float res = rec.t;\n        Material mat = rec.mat;\n\t\tif (didHit) {\n\t\t\tray.origin += ray.direction * res;\n            //ray.origin -= ray.direction * .0001;  // This should work, but it doesn't\n            \n            if (mat.materialType == LAMBERTIAN) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(rec.normal, ray.direction)), .04, mat.fuzz);\n                if (F > hash1(seed)) {\n                    ray.direction = modifyDirectionWithRoughness(rec.normal, reflect(ray.direction, rec.normal), mat.fuzz, seed);\n                } else {\n\t\t\t        ray.direction = cosWeightedRandomHemisphereDirection(rec.normal, seed);\n                }\n                intensity *= mat.albedo.x * max(0.0, dot(rec.normal, ray.direction) / PI) * PI;  // TODO: Make this more legible. attenuation * scatterPDF / pdf\n            } else if (mat.materialType == METAL) {\n                ray.direction = modifyDirectionWithRoughness(rec.normal, reflect(ray.direction, rec.normal), mat.fuzz, seed);            \n                intensity *= mat.albedo.x;  // TODO: Make this more legible.\n            } else { // DIELECTRIC\n                intensity *= 1.;\n                vec3 normal, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                float refractionIndex = mat.refractionIndex;\n                refractionIndex = n_wavelength(ray.wavelength);\n                // rec.normal is always pointing outwards\n                if (dot(ray.direction, rec.normal) > 0.) {\n                    // Ray is inside\n                    normal = - rec.normal;\n            \t\tni_over_nt = refractionIndex;\n                    cosine = dot(ray.direction, normal);\n                    cosine = sqrt(1. - (refractionIndex * refractionIndex) - (refractionIndex * refractionIndex) * cosine * cosine);\n                } else {\n                    normal = rec.normal;\n                    ni_over_nt = 1. / refractionIndex;\n                    cosine = - dot(ray.direction, normal);\n                }\n            \n\t            // Refract the ray.\n\t            refracted = refract(normalize(ray.direction), normal, ni_over_nt);\n    \t        \n        \t    // Handle total internal reflection.\n                if(refracted != vec3(0)) {\n                \tfloat r0 = (1. - ni_over_nt)/(1. + ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, mat.fuzz);\n                }\n                \n                ray.direction = hash1(seed) <= reflectProb ? reflect(ray.direction, normal) : refracted;\n                ray.direction = modifyDirectionWithRoughness(normal, ray.direction, roughness, seed);            \n            }\n        } else {\n            intensity *= skyColor(ray);\n\t\t\treturn intensity;\n        }\n    }  \n    return 0.;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 render(in Ray ray, inout float seed) {\n    vec3 col = vec3(0.);\n    // Loop over the wavelengths\n    for (int i = 0; i < NUM_WAVELENGTHS; i++) {\n        ray.wavelength = float(LOWER_BOUND + i * (UPPER_BOUND - LOWER_BOUND) / NUM_WAVELENGTHS);\n        float intensity = trace(ray, seed);\n        vec3 color = wavelength2XYZ(ray.wavelength);\n\n        col += color * intensity;\n    }\n    col = XYZ_2_RGB * col;\n    col /= float(NUM_WAVELENGTHS);\n    col /= 40.0;\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    vec3 ro = vec3(3., 0., 0.);\n    vec3 ta = vec3(1., 0., 0.);\n    \n    #ifdef MOVE_CAMERA\n        vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n                abs(iMouse.xy)/iResolution.xy - .5;\n            \n        data = texelFetch(iChannel0, ivec2(0), 0);\n        if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n            reset = true;\n        }\n        \n        ro = vec3(.5+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, -.5+2.5*sin(1.5+6.*mo.x));\n        ta = vec3(.5, -.4, -.5);\n    #endif\n\n    mat3 ca = setCamera(ro, ta, 0.);\n    Material mat;\n\n    float fpd = data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        Hit rec;\n        Ray focus_ray = Ray(ro, normalize(vec3(.5,0,-.5)-ro), 0.);\n        bool didHit = worldhit(focus_ray, vec2(0, 100), rec);\n        fragColor = vec4(rec.t, iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2. * fragCoord - 1.) / iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime))) / float(0xffffffffU);\n\n        // AA\n        p += 2. * hash2(seed) / iResolution.y;\n        vec3 rd = ca * normalize(vec3(p.xy, 1.6));  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.) * .02;\n        rd = normalize(fp - ro);\n\n        Ray ray = Ray(ro, rd, 0.);\n\n        vec3 col = render(ray, seed);\n\n        if (reset) {\n            fragColor = vec4(col, 1);\n        } else {\n            fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n            //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfsyz7.jpg", "access": "api", "license": "mit", "functions": [[228, 228, 285, 285, 569]], "test": "error"}
{"id": "4fsyR7", "name": "SDF,Light", "author": "vec2", "description": "[A] Draw Wall \n[R,G,B] Draw Light ( !Must Near Walls! )\n[C] Clear\n[V] Clear All\n[I] Res Init All\nDebug:\n[1] Light  and Wall\n[2]\n[3] SDF\n[4] \nTry {Sky}\nSky integral formula [url=/view/NttSW7]by Mathis[/url]", "tags": ["mouse", "interactive", "sdf", "global", "illumination", "light", "electro", "tracing", "drawing", "trace", "path", "radiance", "cascade"], "likes": 0, "viewed": 88, "published": 3, "date": "1720966832", "time_retrieved": "2024-07-18T23:33:53.747303", "image_code": "vec4 post(vec4 x, float k) {\nx=(2.0 / 3.141592653589793) * atan(k * x);\n//x=smoothstep(0.0,1.0,x);\n return x;\n}\nvoid mainImage( out vec4 C, in vec2 D )\n{\nC=vec4(0.0,0.0,0.0,0.0);\n\n\n\n\nif(key(49))C =texelFetch(iChannel0,ivec2(D),0)*0.1+texelFetch(iChannel0,ivec2(D),0).w*0.2;\nelse if(key(50))C.x =mod( sdfElectro(D-iResolution.xy*0.5,iResolution.y*0.3) *0.1,1.0)+0.3*sign(sdfElectro(D-iResolution.xy*0.5,iResolution.y*0.3) );\nelse if(key(51))C.x =mod( sqrt(texelFetch(iChannel1,ivec2(D),0).z)*0.1,1.0);\nelse if(key(52))C =texelFetch(iChannel2,ivec2(D),0);\nelse C = post( texelFetch(iChannel2,ivec2(D),0) ,1.0);\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid Draw(out vec4 C, const vec2 D, vec4 Mouse, vec4 Color, float size)\n{\n    if(length(Mouse.xy - D.xy) < size && Mouse.z > 0.0)\n    {\n        C += Color;\n    }\n    if(length(Mouse.xy - D.xy) < size + 5.0 && Mouse.z > 0.0)\n    {\n        C += Color * vec4(1., 1., 1., 0.);\n    }\n}\n\nvoid mainImage(out vec4 C, in vec2 D)\n{\n    C = texelFetch(iChannel0, ivec2(D), 0);\n    vec4 Mouse = iMouse;\n    vec4 Color;\n    float size = DrawingSize;\n     if(texelFetch(iChannel1, ivec2(86, 0), 0).x > 0.5){C =vec4(0.0);return;}\n       // if(texelFetch(iChannel1,ivec2(32,0),0).x>0.5)Color = vec4(1.0,0.0,0.0,0.0);//space\n    if(texelFetch(iChannel1, ivec2(82, 0), 0).x > 0.5)\n        Color = vec4(1.0, 0.0, 0.0, 0.0); //r\n    else if(texelFetch(iChannel1, ivec2(71, 0), 0).x > 0.5)\n        Color = vec4(0.0, 1.0, 0.0, 0.0); //g\n    else if(texelFetch(iChannel1, ivec2(66, 0), 0).x > 0.5)\n        Color = vec4(0.0, 0.0, 1.0, 0.0); //b\n    else if(texelFetch(iChannel1, ivec2(65, 0), 0).x > 0.5)\n        Color = vec4(0.0, 0.0, 0.0, 1.0); //a\n    else if(texelFetch(iChannel1, ivec2(67, 0), 0).x > 0.5)\n    {\n        Color = vec4(-1.0, -1.0, -1.0, -1.0);\n        size *= 2.0;\n    } //c\n    else\n        Mouse.z = -1.0;\n\n\n    if(iMouse.xy == vec2(-1110.0))\n    {\n        \n        float iTime = iTime * 3.0;\n        float t = iTime * 0.5;\n        Mouse.xy = vec2(\n            cos(3.14159 * t) + sin(0.72834 * t + 0.3),\n            sin(2.781374 * t + 3.47912) + cos(t)\n        ) * 0.25 + 0.5;\n        Mouse.xy *= R.xy;\n        Mouse.z = 1.0;\n        Color.xyz = cos(iTime + vec3(0, 2, 4));\n        Color.w = 1.0;\n        size = (cos(iTime * 0.1) + 2.0) * 10.0;\n        if(((iFrame / 30) & 1) == 1)\n        {\n            Color = vec4(-2.0);\n            size *= 2.0;\n        }\n        if(((iFrame / 60) & 1) == 1)\n        {\n            Color.xyz = vec3(-1.0);\n        }\n        Draw(C, D, Mouse, Color, size);\n        C = clamp(C, 0.0, 2.0);\n         \n    }\n    if(iFrame == 0||texelFetch(iChannel1, ivec2(73, 0), 0).x > 0.5)\n    {\n   \n    //    if(abs(sdfBox(D - R.xy * 0.5, R.xy * 0.5 - 10.0)) < 2.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n      //  if(sdfBox(D - R.xy * 0.5, R.xy * vec2(0.2, 0.005)) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n      //  if(sdfBox(D - R.xy * 0.5, R.xy * vec2(0.005, 0.3)) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.89, 0.05+0.1 ), R.xy * vec2(0.009, 0.2/3.0)) < 0.0)C += vec4(6.0, 0.0, 0.0, 0.0);\n        if(sdfBox(D - R.xy * vec2(0.89, 0.05+0.2 ), R.xy * vec2(0.009, 0.2/3.0)) < 0.0)C += vec4(0.0, 6.0, 0.0, 0.0);\n        if(sdfBox(D - R.xy * vec2(0.89, 0.05+0.3 ), R.xy * vec2(0.009, 0.2/3.0)) < 0.0)C += vec4(0.0, 0.0, 6.0, 0.0);\n        if(sdfBox(D - R.xy * vec2(0.903, 0.25), R.xy * vec2(0.009, 0.2)) < 0.0)C += vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.803, 0.25), R.x * vec2(0.02, 0.02)) < 0.0)C += vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.8, 0.75), R.x * vec2(0.1, 0.1)) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.79, 0.75), R.x * vec2(0.1, 0.09)) < 0.0)C = vec4(0.0, 2.0, 0.0, 0.0);\n        if(sdfElectro(D - R.xy * vec2(0.34, 0.50), R.x * 0.17) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfSphere(D - R.xy * vec2(0.34, 0.50), R.x * 0.05) < 0.0)C.xyz += vec3(0.2, 0.0, 2.0)*3.0;\n        if(sdfSphere(D - R.xy * vec2(0.34, 0.50), R.x * 0.16) < 0.0)C.xyz += vec3(1.0, 0.0, 2.0)*0.2;\n        if(abs(sdfSphere(D - R.xy * vec2(0.34, 0.50), R.x * 0.17)) < R.x * 0.01)C.xyz += vec3(0.3, 0.0, 2);\n        \n    }\n    \n    Draw(C, D, Mouse, Color, size);\n\n    C = max(C, 0.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nconst ivec2 offsets[] = ivec2[](\n    ivec2(-1,0), ivec2(1,0), ivec2(0,-1), ivec2(0,1),\n    ivec2(-1,1), ivec2(1,-1), ivec2(-1,-1), ivec2(1,1)\n);\n\nbool isOccupied(const ivec2 pos) {\n    return texelFetch(iChannel0, pos, 0).w > 0.5;\n}\n\nvoid mainImage(out vec4 color, in vec2 uv) {\n    if(iFrame%Debugsteptime!=0){color=texelFetch(iChannel1, ivec2(uv), 0);return;}\n    int iFrame=iFrame/Debugsteptime;\n\n    vec4 nearest = texelFetch(iChannel1, ivec2(uv), 0);\n    if (iFrame % lod ==0) {\n    color.w = sqrt(nearest.z);       \n    }else color.w =nearest.w;\n    \n    if (isOccupied(ivec2(uv)) && (iFrame%lod==0 || ShowAllFrame==1)) \n    {\n        color.xyz = vec3(uv, 0.0);\n        return;\n    }\n\n    if (iFrame == 0) \n    {\n        color.xyz = vec3(-1.0);\n        return;\n    }\n\n    \n    for (int i = 0; i < 8; ++i) {\n#ifdef UsePow2 \n        int step = 1 << (lod - 1 - (iFrame) % lod);\n#else\n        int step = int(pow(3.0,float(lod - 1 -(iFrame) % lod)));\n#endif\n        ivec2 pos = ivec2(uv) + offsets[i] * step;\n        if (!(pos.x >= 0 && pos.y >= 0 && pos.x < int(iResolution.x) && pos.y < int(iResolution.y))) continue;\n\n        vec4 candidate = texelFetch(iChannel1, pos, 0);\n        candidate.z = dot(candidate.xy - uv, candidate.xy - uv);\n        if (texelFetch(iChannel1,ivec2(candidate.xy),0).xy==candidate.xy&& (candidate.z < nearest.z || nearest.z < 0.0)) {\n            nearest = candidate;\n        }\n    }\n\n    if (!isOccupied(ivec2(nearest.xy))&& (iFrame%lod==0 || ShowAllFrame==1)) {\n        color.xyz = vec3(-1.0);\n        return;\n    }\n    color.xyz = nearest.xyz;\n \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Buffer:[A] the color[xyz] wall[w]\n// Buffer:[B] the MinDistancePixel[xy] DistanceSquare[z] Distance[w]\n// Buffer:[C] the Light[xyz]  \n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n\n\n\nconst float DrawingSize=12.;\nconst float angleStep = 1.0 / 16.0;\n#define ShowAllFrame 0\n#define Sky (0)\n\nconst int Debugsteptime=1;//30;\n\n// use pow 2 or pow 3\n//#define UsePow2\nconst int lod = 7;//2^10=1024\n\n#define LightSmooth (16.0)\n#define key(k) (texelFetch(iChannel3,ivec2(k,0),0).x>0.5)\n float hash1(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n float hash1(float p)\n{\n    return hash1(vec2(p, 0));\n}\n float hash1(vec4 p4)\n{\n    p4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n#define R iResolution\n\nfloat sdfBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nfloat sdfLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nfloat sdCircleArcTriangle(vec2 p, vec2 v1, vec2 v2, float r)\n{\n    float len = length(p);\n    float2 cp=(v1+v2)*0.5;\n    float le=length(cp);\n    return max(len-r, -dot(p,(cp)/le)+le );        \n}\nfloat sdCircleArcTriangle(vec2 p, vec2 a/*angle*/, float r)\n{\n    float2 v1 = float2(cos(a.x),sin(a.x))*r; \n    float2 v2 = float2(cos(a.y),sin(a.y))*r; \n    return sdCircleArcTriangle(p,v1,v2,r);        \n}\nfloat2 ComplexMul(const float2 z1, const float2 z2)\n{\n    return float2(\n        z1.x * z2.x - z1.y * z2.y,\n        z1.x * z2.y + z1.y * z2.x\n    );\n}\n\nfloat sdfSphere(float2 p, float r)\n{          \n    return length(p) - r;\n}\n#define PI2 2.0*3.141592653589793\n#define add(d,s) d=min(d,s)\n#define sub(d,s) d=max(d,-s)\n//雷标 by https://www.bilibili.com/video/BV1kqhieGE3H\nfloat sdfElectro(float2 p, float r) {\n    float d = uintBitsToFloat(0x7f7fffffu);\n    float d1 = uintBitsToFloat(0x7f7fffffu);\n    d = sdfSphere(p, r * 0.46 / 2.0);\n    for (float i = 0.0; i < PI2; i += PI2 / 3.0) {\n        float2 v = float2(cos(i), sin(i)) * r;\n        sub(d, sdfSphere(p - ComplexMul(v, float2(0.23, 0.398371685740842)), r * 0.388371685740842));\n    }\n    for (float i = 0.0; i < PI2; i += PI2 / 3.0) {\n        float2 v = float2(cos(i), sin(i)) * r;\n        add(d1, sdfSphere(p, r));\n        sub(d1, sdfSphere(p - ComplexMul(v, float2(-0.46, 0.0)), r * 1.171049240405192));\n        sub(d1, sdfSphere(p - ComplexMul(v, float2(0.193301270189222, -0.234807621135332)), r * 0.840177040641766));\n        float d2 = uintBitsToFloat(0x7f7fffffu);\n        add(d2, sdfSphere(p - ComplexMul(v, float2(0.236602540378444, 0.209807621135332)), r * 0.579721443061983));\n        sub(d2, sdfSphere(p - ComplexMul(v, float2(0.186698729810778, 0.423371685740842)), r * 0.415580291234265));\n        sub(d2, sdfSphere(p - ComplexMul(v, float2(0.193301270189222, -0.234807621135332)), r * 0.227658190923347));\n        sub(d2, sdfSphere(p - ComplexMul(v, float2(-1.0, 0.0)), r * 1.23));\n        add(d1, d2);\n        d = min(d, d1);\n    }\n    return d;\n}\n", "buffer_c_code": "const float PI = 3.1415927;\nvec3 integrateSkyRadiance_(vec2 angle) {\n    // Sky radiance helper function\n    float a1 = angle[1];\n    float a0 = angle[0];\n    \n    // Sky integral formula taken from\n    // Analytic Direct Illumination - Mathis\n    // https://www.shadertoy.com/view/NttSW7\n    const vec3 SkyColor = vec3(0.2,0.5,1.);\n    const vec3 SunColor = vec3(1.,0.7,0.1)*10.;\n    const float SunA = 2.0;\n    const float SunS = 64.0;\n    const float SSunS = sqrt(SunS);\n    const float ISSunS = 1./SSunS;\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;\n    return SI / 6.0;\n}\n\nvec3 integrateSkyRadiance(vec2 angle) {\n    // Integrate the radiance from the sky over an interval of directions\n    if (angle[1] < 2.0 * PI) {\n        return integrateSkyRadiance_(angle);\n    }\n    \n    return\n        integrateSkyRadiance_(vec2(angle[0], 2.0 * PI)) +\n        integrateSkyRadiance_(vec2(0.0, angle[1] - 2.0 * PI));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec4 traceRay(const vec2 origin, const vec2 direction) {\n    float depth = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec2 pos = origin + direction * depth;\n        float dist = texture(iChannel1, pos / iResolution.xy).w;\n        depth += dist;\n        if (dist < 2.0) {\n            vec3 color = texelFetch(iChannel2, ivec2(pos+direction*2.0  ), 0).xyz *1.5;\n            color += texelFetch(iChannel0, ivec2(pos-direction *2.0), 0).xyz * 0.8;\n            return vec4(color, depth);\n        }\n#if Sky\n        if(!(all(lessThan(vec2(0.0,0.0),pos))&&all(lessThan( pos,iResolution.xy))))\n        {\n         //Sky\n        return  vec4(vec3(10.0*pow(max( dot(direction,vec2(-0.74935529040989,0.662168142343551)),0.0),145.0)) ,10.0)+vec4(2.0*-integrateSkyRadiance(vec2(atan(direction.y,direction.x)+0.4,atan(direction.y,direction.x)-1.0)),10.0);\n        }\n#endif\n    }\n    return vec4(-1.0, -1.0, -1.0, -1.0); // HLSL need it\n}\nfloat randangle(in vec2 fragCoord)\n{\n \nreturn mod(texelFetch(iChannel3,ivec2(fragCoord)%textureSize(iChannel3,0),0).x+float(iFrame)*sqrt(2.0),1.0);\n// return hash1(vec4(vec2(fragCoord), iFrame, 0.0));\n//return float((iFrame*1)%int(LightSmooth))/LightSmooth;\n}\n#define PI 3.141592653589793\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n\n   \n    for (float angle = randangle(fragCoord)* PI * (angleStep) * 2.0; angle < PI * 2.0; angle += PI * (angleStep) * 2.0) {\n        vec2 dir = vec2(cos(angle), sin(angle));\n        vec4 hit = traceRay(fragCoord, dir);\n        if (hit.w > 0.0) {\n            result.xyz += hit.xyz * angleStep ;//* (exp(-hit.w * 0.00001));\n        }\n    }\n   \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor *=1.0- 1.0/LightSmooth;\n    fragColor += result * 1.0/LightSmooth;\n    // fragColor.xyz = fragColor.xyz * 2.0 - smoothstep(0.0, 1.0, fragColor.xyz);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 111], [112, 112, 153, 153, 610]], "test": "error"}
{"id": "4flcR7", "name": "bilateral - separable vs nonsep", "author": "jeyko", "description": ".", "tags": ["filter", "separable", "bilateral"], "likes": 6, "viewed": 181, "published": 3, "date": "1720956528", "time_retrieved": "2024-07-18T23:33:54.627948", "image_code": "// Radius and tolerance adjustable in Common tab\n// Left: separable\n// Right: non-separable\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 u = U/iResolution.xy;\n    //C -= C;\n    float offs = 0.5;\n    \n    if(iMouse.z > 0.0){\n        offs = iMouse.x/iResolution.x;\n    }\n    \n    if(u.x > offs){\n        C.rgb = do_bilateral_pass(u, iChannel0, false, iResolution.xy, 0);\n    } else {\n        C.rgb = texture(iChannel1,u).rgb;\n    }\n    C -= step(abs(u.x - offs),1./iResolution.x)*0.07;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define rad 10.\n#define tolerance 0.1\n\nfloat luma(vec3 col) {\n    return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n}\n\n\n\nvoid do_samp(vec2 u, sampler2D chan, inout float W, inout vec3 acc, float cent_lum){\n    float w = 1.0;\n    vec3 samp = texture(chan,u).rgb;\n    float samp_lum = luma(samp);\n    w *= 1.-smoothstep(0.,tolerance,abs(samp_lum - cent_lum));\n    acc += samp * w;\n    W += w;\n}\n\nvec3 do_bilateral_pass(vec2 u, sampler2D chan, bool separable, vec2 res, int iter){\n    vec3 C = vec3(0);\n    C = texture(chan,u).rgb;\n    float cent_lum = luma(C.rgb);\n    \n    vec2 st = 1./res.xy;\n    vec3 acc = vec3(0);\n    float W = 0.;\n    if(separable){\n        vec2 dir = vec2(0);\n        dir[iter] = 1.;\n        for(float x = -rad; x <= rad; x++){\n            do_samp(u + x*dir*st, chan, W, acc, cent_lum);\n\n        }\n    } else {\n        for(float y = -rad; y <= rad; y++){\n            for(float x = -rad; x <= rad; x++){\n                do_samp(u + vec2(x,y)*st, chan, W, acc, cent_lum);\n            \n            }\n        }\n    }\n    if(W > 0.0001){\n        C.rgb = acc/W;\n    }\n    return C;\n}", "buffer_a_code": "\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 u = U/iResolution.xy;\n    C = texture(iChannel0,u);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 u = U/iResolution.xy;    \n    C.rgb = do_bilateral_pass(u, iChannel0, true, iResolution.xy, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 u = U/iResolution.xy;    \n    C.rgb = do_bilateral_pass(u, iChannel0, true, iResolution.xy, 1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flcR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 133, 133, 491]], "test": "error"}
{"id": "lcfcR7", "name": "SDF,Drawing", "author": "vec2", "description": "[Space] Drawing\n[C] Clear\nAnd try [ShowAllFrame] or [Debugsteptime=30]", "tags": ["sdf", "drawing"], "likes": 2, "viewed": 76, "published": 3, "date": "1720952355", "time_retrieved": "2024-07-18T23:33:55.491639", "image_code": "\nfloat sdmap( in vec2 p) \n{\n#if ShowAllFrame\nfloat D = sqrt(texelFetch(iChannel1,ivec2(p),0).z);\n#else\nfloat D = (texelFetch(iChannel1,ivec2(p),0).w);\n#endif\n    return D==0.0?-0.0:D;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 iMouse=iMouse;\n    if (iMouse.xy == vec2(0.0)) \n    {\n        float t = iTime * 0.2;\n        iMouse.xy = vec2(\n            cos(3.14159 * t) + sin(0.72834 * t + 0.3),\n            sin(2.781374 * t + 3.47912) + cos(t)\n        ) * 0.25 + 0.5;\n        iMouse.xy *= iResolution.xy;\n        iMouse.z =1.0;\n    }\n\n    const float S=0.005;\n\tvec2 p = (2.0*fragCoord-iResolution.xy)*S;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)*S;\n\n\tfloat d =sdmap(fragCoord)*S;\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( texelFetch(iChannel2,ivec2(32,0),0).x<0.5&&texelFetch(iChannel2,ivec2(67,0),0).x<0.5)\n    {\n    d =sdmap(iMouse.xy)*2.0*S;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid Draw(out vec4 C,const vec2 D,vec4 Mouse,vec4 Color,float size)\n{\n    \n    if(length(Mouse.xy-D.xy)<size&&Mouse.z>0.0)\n    {      \n        C=Color;\n    }\n\n\n}\n\nvoid mainImage( out vec4 C, in vec2 D )\n{\nC=texelFetch(iChannel0,ivec2(D),0);\n    vec4 Mouse=iMouse;\nvec4 Color;\nfloat size=DrawingSize;\n\n        if(texelFetch(iChannel1,ivec2(32,0),0).x>0.5)Color = vec4(1.0,0.0,0.0,0.0);//space\n        //if(texelFetch(iChannel1,ivec2(82,0),0).x>0.5)Color = vec4(1.0,0.0,0.0,0.0);//r\n        //else if(texelFetch(iChannel1,ivec2(71,0),0).x>0.5)Color = vec4(0.0,1.0,0.0,0.0);//g\n        //else if(texelFetch(iChannel1,ivec2(66,0),0).x>0.5)Color = vec4(0.0,0.0,1.0,0.0);//b\n        //else if(texelFetch(iChannel1,ivec2(65,0),0).x>0.5)Color = vec4(0.0,0.0,0.0,1.0);//a\n        else if(texelFetch(iChannel1,ivec2(67,0),0).x>0.5){Color = vec4(0.0,0.0,0.0,0.0);size*=2.0;}//c\n        else Mouse.z=-1.0;\n\n\n    if (iMouse.xy == vec2(0.0)) \n    {\n        float t = iTime * 3.0;\n        Mouse.xy = vec2(\n            cos(3.14159 * t) + sin(0.72834 * t + 0.3),\n            sin(2.781374 * t + 3.47912) + cos(t)\n        ) * 0.25 + 0.5;\n        Mouse.xy *= iResolution.xy;\n        Mouse.z =1.0;\n        Color=vec4(float( int(iTime*5.0)&1) );\n        size=(cos(iTime*0.1)+2.0)*30.0/(Color.x+1.0);\n        \n        C=texture(iChannel2,(D)/iResolution.xy);\n        return;\n    }\n    \n    Draw(C,D,Mouse,Color,size);\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nconst ivec2 offsets[] = ivec2[](\n    ivec2(-1,0), ivec2(1,0), ivec2(0,-1), ivec2(0,1),\n    ivec2(-1,1), ivec2(1,-1), ivec2(-1,-1), ivec2(1,1)\n);\n\nbool isOccupied(const ivec2 pos) {\n    return texelFetch(iChannel0, pos, 0).x > 0.5;\n}\n\nvoid mainImage(out vec4 color, in vec2 uv) {\n    if(iFrame%Debugsteptime!=0){color=texelFetch(iChannel1, ivec2(uv), 0);return;}\n    int iFrame=iFrame/Debugsteptime;\n\n    vec4 nearest = texelFetch(iChannel1, ivec2(uv), 0);\n    if (iFrame % lod ==0) {\n    color.w = sqrt(nearest.z);       \n    }else color.w =nearest.w;\n    \n    if (isOccupied(ivec2(uv)) && (iFrame%lod==0 || ShowAllFrame==1)) \n    {\n        color.xyz = vec3(uv, 0.0);\n        return;\n    }\n\n    if (iFrame == 0) \n    {\n        color.xyz = vec3(-1.0);\n        return;\n    }\n\n    \n    for (int i = 0; i < 8; ++i) {\n#ifdef UsePow2 \n        int step = 1 << (lod - 1 - (iFrame) % lod);\n#else\n        int step = int(pow(3.0,float(lod - 1 -(iFrame) % lod)));\n#endif\n        ivec2 pos = ivec2(uv) + offsets[i] * step;\n        if (!(pos.x >= 0 && pos.y >= 0 && pos.x < int(iResolution.x) && pos.y < int(iResolution.y))) continue;\n\n        vec4 candidate = texelFetch(iChannel1, pos, 0);\n        candidate.z = dot(candidate.xy - uv, candidate.xy - uv);\n        if (texelFetch(iChannel1,ivec2(candidate.xy),0).xy==candidate.xy&& (candidate.z < nearest.z || nearest.z < 0.0)) {\n            nearest = candidate;\n        }\n    }\n\n    if (!isOccupied(ivec2(nearest.xy))&& (iFrame%lod==0 || ShowAllFrame==1)) {\n        color.xyz = vec3(-1.0);\n        return;\n    }\n    color.xyz = nearest.xyz;\n \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float DrawingSize=12.;\n\n#define ShowAllFrame 0\n\nconst int Debugsteptime=1;//30;\n\n// use pow 2 or pow 3\n// {{if want pow 3 just del it}}\n#define UsePow2\nconst int lod = 11;//2^10=1024\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfcR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 185], [186, 186, 243, 243, 1273]], "test": "error"}
{"id": "4fscRM", "name": "fractalic caleidoscope", "author": "nayk", "description": "originals https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/MdXSzS", "tags": ["fractal"], "likes": 3, "viewed": 71, "published": 3, "date": "1720951115", "time_retrieved": "2024-07-18T23:33:56.352339", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(23,223,21))*2.5+.5)\n#define time iTime\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec4 p2;\n    vec2 uv = (C.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    vec3 col = vec3(0);\n    vec3 n1,q\n    ,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1)); \n        \n      vec2 resolution = iResolution.xy;\n      vec2 p = 2.0*(C.xy / iResolution.xy )-1.0;\n\tvec3 Color = vec3(0.1, 0.3, 0.9);\n\tfloat col2 = -0.1;\n\tvec2 a = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution, resolution.y);\n    a*=ma;\n\tfor(float i=0.0;i<126.0;i++)\n\t{\n\t  float si = sin(time + i * 0.05)/0.5;\n\t  float co = cos(time + i * 0.05)*0.5;\n\t  col2 += 0.01 / abs(length(a + vec2(si , co * si )) - 0.1);\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat lt = 0.01;\n\t\tfloat a = float(i);\n\t\tvec2 b = vec2(1.5*sin(time+a),0.8*sin(time*0.77+a)); \n          b*=ma;\n\t\tif (abs(p.x) < b.x && abs(p.y) < b.y) {\n\t\t\tif (abs(p.x) > b.x-lt || abs(p.y) > b.y-lt )\n\t\t\t\t col = vec3(1);\n\t\t}\n\t}\n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        n1.zxy=g*d;\n  \n        a=20.;\n        n1=mod(n1-a,a*2.)-a;\n        s=7.;\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n            \n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            n1.y<n1.x?n1=n1.zyx:n1;\n            n1.xz*=ma;\n            s*=e=1.4+sin(iTime*.234)*.1;\n            n1=abs(n1+col)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )+col2;\n         }\n        g+=e=length(n1.yz)/s;\n        \n\n         g+=e=length(n1.yx)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fscRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 164, 164, 1908]], "test": "ok"}
{"id": "MfXyz7", "name": "frame t 2 ", "author": "shadertoyjiang", "description": "t", "tags": ["test", "bubbles", "coordinate", "invers"], "likes": 16, "viewed": 100, "published": 3, "date": "1720945924", "time_retrieved": "2024-07-18T23:33:57.196083", "image_code": "\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nint obj;\n\n// \nfloat sdinvFrame(vec3 p)\n{\n        float riv = 1.;\n        vec3 q = p,   y = iTime*vec3(1,3,7)*.1;\n        q = q * riv / dot(q,q);\n        q -= y;\n        vec3 i = round(q) ;\n        q = q - i;\n        vec3 a = abs(q), s = sign(q);//step(0., q);\n        vec3 m = step(a,a.yzx )*step(a,a.zxy);\n        q = q * m + s * (1. - m)*.5 + i+y;\n        q = q * riv / dot(q,q);\n        float d = length(p-q);\n        return d - .06;\n}\n\nfloat sdInvFace(vec3 p)\n{\n        float riv = 1.;\n        vec3 q = p,   y = iTime*vec3(1,3,7)*.1;\n        q = q * riv / dot(q,q);\n        q -= y;\n        vec3 i = round(q) ;\n        q = q - i;\n        vec3 a = abs(q), s = sign(q);\n        vec3 m = step(a.yzx,a )*step(a.zxy,a );\n        q = q * (1.-m) + s * m*.5 + i+y;\n        q = q * riv / dot(q,q);\n        float d = length(p-q);\n        return d - .0;\n}\n\nvec2 sdaaa(vec3 p)\n{\n        float d1 = sdinvFrame(p);\n        float d2 = sdInvFace(p);\n        obj=1;\n        if(d2<d1)obj=2;\n        return vec2(min(d1,d2),d2);\n}\n\nvec2 map(vec3 p)\n{\n        float t = iTime+5.;\n        vec2 ms = iMouse.xy/iResolution.xy*6.28+t;\n        p.xy = p.xy * rot(t +1.);\n        p.xz = p.xz * rot(ms.x);\n        p.yz = p.yz * rot(ms.y);\n        return sdaaa(p);\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        O = vec4(.75,.6,.1,1)*.2;\n        vec2 R = iResolution.xy,cd,\n             u = (U+U - R) / R.y;\n        vec3 eye = vec3(0, 0, -5),\n             dir = normalize(vec3(u, 2)),\n             sun = 5. * ( .2*cos(iTime+vec3(7,11,13)) + vec3(-1,2,-3)/3.74 ),\n             eps = vec3(0, .0001, 0),\n             nor, p;\n        float d , t=0., ki=1.;\n        for(int i=0; i<128 ;i++)\n        {\n                if(t>30.)break;\n                p = eye + dir * t;\n                cd = map(p);\n                d = cd.x;\n                if( d<.01 )\n                {       //  \n                        nor = normalize(vec3(map(p+eps.yxx).x, map(p+eps).x, map(p+eps.xxy).x)-d); \n                        vec3  sp = normalize(sun-p), ep=normalize(eye-p);\n                        float ln = max(0., dot(nor,sp)),               // light norm\n                              er = max(0., dot(ep, reflect(-sp,nor))); // eye ray\n                        float ambt=.3, difu=.6, spec=80.;\n                        vec4  lightClr = vec4(1,.5,0,1);\n                        \n\n                        if(obj==1){\n                          O = O     + lightClr * (ambt + difu*ln + pow(er, spec)) * ki     ;\n                            \n                          return;\n                        }\n                        ki*=.8 ;\n                }\n                O = O +    exp( -120.* cd.y )*vec4(.1,.1,.2,1)*.1;\n                t += max(.003, d * .4 ) ;\n        }\n        //O = log(1.+O);\n        //O = vec4(.5,0,0,1);\n}\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfXyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 70, 96, 96, 494], [496, 496, 521, 521, 903], [905, 905, 925, 925, 1069], [1071, 1071, 1089, 1089, 1295], [1297, 1297, 1333, 1333, 2831]], "test": "ok"}
{"id": "McXyzM", "name": "Raymarching, with LIGHTING", "author": "JOEMANFLAME", "description": "My first attempt at 3D lighting, again like my other published shaders, thanks to Inigo Quilez who's code I used to try and understand what everything is! Souce: https://www.shadertoy.com/view/XtycD1", "tags": ["basic", "raymarch", "lighting"], "likes": 1, "viewed": 52, "published": 3, "date": "1720933311", "time_retrieved": "2024-07-18T23:33:58.020878", "image_code": "//-------------------------------------------------------------------------------------------------------------------\n// Credit to Inigo Ouilez, whos code I was able to follow and arive at 'some' sort of understanding of what it does<3\n// This is a very simple raymarched sphere with a PITIFUL attempt at lighting, however I leraned alot in rendering\n// this so I'm excited for what's next :)\n\n// https://www.shadertoy.com/view/XtycD1    - code I followed for understanding\n// https://iquilezles.org/articles/         - also his website for those who have not yet 'seen the light'\n//                                                                                             ^\n//                                                                                             |\n//                                             see what i did there?... because lighting? ----- \n//-------------------------------------------------------------------------------------------------------------------\n\n// functions\n\n// returns a changing color palette (not used in this demo)\nvec3 palette( float t ) {\n    vec3 a = vec3(0.731, 1.098, 0.192);\n    vec3 b = vec3(0.358, 1.09, 0.657);\n    vec3 c = vec3(1.077, 0.360, 0.328);\n    vec3 d = vec3(0.965,2.265,0.837);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// rotates by angle\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n\n// SDFs\n\n// I was playing around with this, not used in this code\n// returns SDF of torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// returns SDF of sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n\n// geometry in scene\nfloat map ( vec3 pos ) {\n\n    float sphere = sdSphere(pos, 1.0);\n    return sphere;\n}\n\n// calculates normal given a position                         (don't ask me about the math, I'm in the middle of   \n// https://www.shadertoy.com/view/XtycD1 - copied from here    writing my thesis and I need to brush up on my math skills)\nvec3 calcNormal( in vec3 pos )\n{\n    float kk;\n    float eps = 0.0002;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx) );\n}\n\n// calculates distance to objects in the scene\nfloat intersect ( vec3 ro, vec3 rd, float mindist, float maxdist ) \n{\n    vec3 d;\n    float t = mindist;\n    for (int i = 0; i < 100; i++) {\n        d = ro + rd * t;\n        float h = map(d);\n        if (abs(h) < (0.0001*t) || t > maxdist){\n            break;\n        }\n        t += h;\n    }\n    return (t<maxdist)?t:-1.0;\n}\n\n// light position in world coords\nvec3 light = vec3(0.8, 0.5, -0.5);\n\n// takes in position matrix and normals and outputs pixel rgb value\nvec3 shadow ( vec3 pos , vec3 nor) {\n    // initialize rgb at 0 for easier calc\n    vec3 rgb = vec3(0.0,0.0,0.0);\n    // first matrix denotes light color, dot product of geom normals and light pos yields value btwn 0-1 giving\n    // amount of light to be drawn (clamp yields value of (function btwn y, z)\n    rgb += vec3(1.0, 0.925, 0.878) * clamp(dot(nor, light), 0.0, 1.0);\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    vec2 m = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    \n    // Set ray origin (ro) and ray direction (rd)\n    vec3 ro = vec3(0.0,0.0,-3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    // multiplies by a time factor\n    m = vec2(sin(iTime) - 1.2);\n    \n    // Background color\n    vec3 col = vec3(0.2,0.2,0.2);\n    \n    // Find distance to intersection btw ray and geometry\n    float dist = intersect(ro, rd, 0.001, 50.0);\n        // if the distancce is greater than 0\n        if (dist > 0.0) {\n            // position matrix\n            vec3 pos = ro + rd*dist;\n            \n            pos.xz *= rot2D(dist * m.x);\n            // find normals of position matrix\n            vec3 norm = calcNormal(pos);\n            // calculate lighting\n            col = shadow(pos, norm);\n    }  \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McXyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1005, 1065, 1090, 1090, 1291], [1293, 1313, 1338, 1338, 1422], [1552, 1633, 1666, 1666, 1731], [1733, 1758, 1793, 1793, 1817], [1938, 1959, 1983, 1983, 2044], [2046, 2285, 2317, 2317, 2548], [2550, 2597, 2666, 2666, 2921], [2993, 3061, 3097, 3140, 3454], [3456, 3456, 3513, 3563, 4492]], "test": "ok"}
{"id": "lcsczN", "name": "Ribbons_MHedit_v1", "author": "flatearthsociety", "description": "Some colored \"ribbons\" who are illuminated by the sound.", "tags": ["3d", "distancefield", "musicsync", "ribbons"], "likes": 1, "viewed": 69, "published": 3, "date": "1720900301", "time_retrieved": "2024-07-18T23:33:58.852655", "image_code": "// Fork of \"Ribbons\" by XT95. https://shadertoy.com/view/lds3zr\n// 2024-07-13 19:50:43\n\n\n//FXAA Shader taken from this great example by reinder - from https://www.shadertoy.com/view/ls3GWS\n//Original code - http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n\n#define ON\n\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv = fragCoord.xy / iResolution.xy;        \n    \n    #ifdef ON\n        fragColor.rgb = FxaaPixelShader( vec4( uv, uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT))), iChannel0, 1./iResolution.xy );\n        fragColor.a = texture( iChannel0, uv ).a;\n    #else\n    \tfragColor = texture(iChannel0, uv);\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//-----------------------------------------------------------------------------\n// Utils\n//-----------------------------------------------------------------------------\n#define t (iTime*.03)\n\nvec3 rotateY(vec3 v, float x)\n{\n    return vec3(\n        cos(x)*v.x - sin(x)*v.z,\n        v.y,\n        sin(x)*v.x + cos(x)*v.z\n    );\n}\n\nvec3 rotateX(vec3 v, float x)\n{\n    return vec3(\n        v.x,\n        v.y*cos(x) - v.z*sin(x),\n        v.y*sin(x) + v.z*cos(x)\n    );\n}\n\nvec3 rotateZ(vec3 v, float x)\n{\n    return vec3(\n        v.x*cos(x) - v.y*sin(x),\n        v.x*sin(x) + v.y*cos(x),\n        v.z\n    );\n}\n//-----------------------------------------------------------------------------\n// Scene/Objects\n//-----------------------------------------------------------------------------\nfloat box(vec3 p, vec3 pos, vec3 size)\n{\n\treturn max(max(abs(p.x-pos.x)-size.x,abs(p.y-pos.y)-size.y),abs(p.z-pos.z)-size.z);\n}\n\n\nfloat ribbon1(vec3 p)\n{\n\treturn box(p,vec3(cos(p.z)*2.5,sin(p.z+p.x)*.5,.0),vec3(.02,0.02,3.0+t));\n}\nfloat ribbon2(vec3 p)\n{\n\treturn box(p,vec3(cos(p.z+1.5+p.x)*.6,sin(p.z+1.)*.3,.0),vec3(.02,0.02,3.+t));\n}\nfloat ribbon3(vec3 p)\n{\n\treturn box(p,vec3(sin(p.z+p.y)*.4,cos(p.z+p.x)*.5,.0),vec3(.02,0.02,4.+t));\n}\nfloat ribbon4(vec3 p)\n{\n\treturn box(p,vec3(sin(p.z+1.5+p.x)*.5,cos(p.z+1.5)*.6,.0),vec3(.02,0.02,2.+t));\n}\nfloat scene(vec3 p)\n{\n\tfloat d = .5-abs(p.y);\n\td = min(d, ribbon1(p) );\n\td = min(d, ribbon2(p) );\n\td = min(d, ribbon3(p) );\n\td = min(d, ribbon4(p) );\n\t\n\treturn d;\n}\n\n//-----------------------------------------------------------------------------\n// Raymarching tools\n//-----------------------------------------------------------------------------\n//Raymarche by distance field\nvec3 Raymarche(vec3 org, vec3 dir, int step)\n{\n\tfloat d=0.0;\n\tvec3 p=org;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p);\n\t\tp += d * dir;\n\t}\n\t\n\treturn p;\n}\n//get Normal\nvec3 getN(vec3 p)\n{\n\tvec3 eps = vec3(0.01,0.0,0.0);\n\treturn normalize(vec3(\n\t\tscene(p+eps.xyy)-scene(p-eps.xyy),\n\t\tscene(p+eps.yxy)-scene(p-eps.yxy),\n\t\tscene(p+eps.yyx)-scene(p-eps.yyx)\n\t));\n}\n\n//Ambiant Occlusion\nfloat AO(vec3 p, vec3 n)\n{\n\tfloat dlt = 0.1;\n\tfloat oc = 0.0, d = 1.0;\n\tfor(int i = 0; i<6; i++)\n\t{\n\t\toc += (float(i) * dlt - scene(p + n * float(i) * dlt)) / d;\n\t\td *= 2.0;\n\t}\n\treturn clamp(1.0 - oc, 0.0, 1.0);\n}\n\n//-----------------------------------------------------------------------------\n// Main Loop\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 color = vec4(0.0);\n\tfloat bass = texture( iChannel0, vec2(20./256.,0.25) ).x*.75+texture( iChannel0, vec2(50./256.,0.25) ).x*.25;\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(texture( iChannel0, vec2(1./256.,0.25) ).x*.2+1.,+0.3+bass*.05,t+5.);\n\tvec3 dir = normalize(vec3(v.x,-v.y,2.));\n\tdir = rotateX(dir,.15);\n\tdir = rotateY(dir,2.8);\n\t\n\t\n\tvec3 p = Raymarche(org,dir,48);\n\tvec3 n = getN(p);\n\t\n\t\n    color = vec4( max( dot(n.xy*-1.,normalize(p.xy-vec2(.0,-.1))),.0)*.01 );\n\tcolor += vec4(1.0,0.0,0.25,1.0)/(ribbon1(p-n*.01)*20.+.75)*pow(bass,2.)*3.;\n\tcolor += vec4(0.0,0.0,0.0,0.0)/(ribbon2(p-n*.01)*20.+.75)*pow(texture( iChannel0, vec2(32.4/256.,0.25) ).x,2.)*2.;\n\tcolor += vec4(0.0,0.0,0.0,1.0)/(ribbon3(p-n*.01)*20.+.75)*pow(texture( iChannel0, vec2(64.8/256.,0.25) ).x,2.)*5.;\n\tcolor += vec4(0.0,0.0,0.0,0.0)/(ribbon4(p-n*.01)*20.+.75)*pow(texture( iChannel0, vec2(80./256.,0.25) ).x,2.)*5.;\n\tcolor *= AO(p,n);\n\tcolor = mix(color,vec4(0.),vec4((min(distance(org,p)*.05,1.0))));\n\t\n\t\n\tfragColor = color;\n\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcsczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[476, 476, 538, 538, 2193], [2196, 2196, 2253, 2253, 2606]], "test": "error"}
{"id": "McsyzN", "name": "Trick! + Loading... Typing...", "author": "fishy", "description": "I put the pattern from [url=https://www.shadertoy.com/view/dtfcWr]this[/url] into [url=https://www.shadertoy.com/view/wscXDr]this[/url]\n\nOnly works on light mode.", "tags": ["simple"], "likes": 4, "viewed": 65, "published": 3, "date": "1720897688", "time_retrieved": "2024-07-18T23:33:59.686426", "image_code": "#define PI 3.14159\n#define r(uv,lg) ( length(uv) / norm(lg))\n#define norm(v) ( (v) / iResolution.x )\n#define animate(t) ( 70.*sin(t)*step(-PI, -mod(t,2.*PI)) )\n\nfloat sdBox( in vec2 p, in vec2 b ) {\t//iq\n    p = p * iResolution.x/800.-vec2(.0,.07);\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - .3;\n}\nfloat getcoef(float theta) {\n\ttheta /= 2.*PI;\n    return theta*smoothstep(1.,.99,theta);\t//antialiasing\n}\nfloat circleloading(vec2 uv, float angle) {\n    float r = r(uv, 400.); \n\treturn mix( smoothstep(.07, .05, abs(r-.25)), .0, getcoef(angle) );\n}\nfloat pointsloading(vec2 uv) {\n\tfloat value = smoothstep( .1, .08, r(uv - norm( vec2(.0, animate(5.*iTime)) ), 450.) )\n        \t\t  + smoothstep( .1, .08, r(uv - norm( vec2(200., animate(5.*iTime-.6)) ), 450.) )\n        \t\t  + smoothstep( .1, .08, r(uv - norm( vec2(-200., animate(5.*iTime+.6)) ), 450.) );\n    return value;\n}\n\nfloat pattern(vec2 p)\n{\n    vec2 uv = p + 0.1*texture( iChannel1, 0.05*p ).xy;\n    return texture( iChannel0, 16.0*uv ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fa = pattern((fragCoord+0.0)/iChannelResolution[0].xy);\n    float fb = pattern((fragCoord-0.5)/iChannelResolution[0].xy);\n    \n    // uncomment for dark mode\n    //vec3 p = vec3(0.11 + 0.2*(fa-fb));\n    vec3 p = vec3(0.822 + 0.4*(fa-fb));\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float angle = atan(uv.y, uv.x);    \n    angle = mod(angle + PI + 5.*iTime, 2.*PI);\n    \n    vec3 color = vec3(0.);\n    float shape = mix( circleloading(uv, angle), \n                  smoothstep( .01, .0, sdBox( uv, vec2(.12,.0) ) ) * .7 * (1. - pointsloading(uv)),\n                  mod(floor(iTime/PI), 2.) );\n    color = mix(p, vec3(1.0), shape);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McsyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 198, 203, 337], [338, 338, 366, 366, 443], [444, 444, 487, 487, 586], [587, 587, 617, 617, 911], [913, 913, 936, 936, 1037], [1039, 1039, 1096, 1096, 1802]], "test": "error"}
{"id": "lclcz4", "name": "TriplePendulum", "author": "kosalos", "description": "three jointed pendulum", "tags": ["pendulummotiondemonstration"], "likes": 2, "viewed": 67, "published": 3, "date": "1720893847", "time_retrieved": "2024-07-18T23:34:00.563082", "image_code": "// -------------------------------------------------------------------------------------------------\n// Three segmented Pendulum\n// \n// Controls:\n// <Q>,<W> Length #1;   <E>,<R>  Mass #1\n// <A>,<S> Length #2;   <D>,<F>  Mass #2\n// <Z>,<X> Length #3;   <C>,<V>  Mass #3\n//\n// <T>,<Y> Gravity\n// <G>,<H> Speed\n//\n// <Spc>   Reset\n//\n// algorithm: https://github.com/micaeloliveira/physics-sandbox/blob/feature/new-styling/assets/javascripts/pendulum.js\n// -------------------------------------------------------------------------------------------------\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 fragColor,vec2 fragCoord) {\n    float d = ptLineDistance(fragCoord,p1,p2);\n    if(d < width) {\n        float d2 = ptLineDistance(fragCoord - vec2(-width * 0.5,width * 0.5),p1,p2);\n        fragColor.xyz = color - vec3(d2 / (width * 2.5));\n    }\n\n    if(abs(d - width)< 1.) fragColor.xyz = vec3(0.);\n}\n\nvoid xorRings(vec2 pos, float width,vec3 color, inout vec4 fragColor, in vec2 fragCoord) {\n    float w1,w2,dist = length(fragCoord - pos);     \n    for(int i=2;i<100;i+=2) {\n        w1 = width * float(i);\n        w2 = width * float(i+1);        \n        if(dist >= w1 && dist <= w2) fragColor.xyz = abs(fragColor.xyz - color / (dist * 0.005));\n    }\n}\n\nvoid drawCircle(vec2 pt, float radius, vec3 color,inout vec4 fragColor,vec2 fragCoord) {\n    float d = length(fragCoord-pt);\n    \n    if(d < 90.) fragColor.xyz += 1./(d * 0.2); // glow\n    \n    if(d < radius) {\n        float d2 = length(fragCoord - vec2(-radius * 0.5,radius * 0.5) - pt);\n        fragColor.xyz = color - vec3(d2 / (radius * 3.5));\n    }\n    if(abs(d - radius)< 1.) fragColor.xyz = vec3(0.);\n}\n\n// -------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.xyz = vec3(0.);\n    getSettings(iChannel0); \n\n    const float C1 = 0.7;\n    const float C2 = 0.65;\n    const float C3 = 0.63;\n    xorRings(qPos1,1.0 + qMass1 * 0.3,vec3(C1,C2,C3),fragColor,fragCoord);\n    xorRings(qPos2,1.0 + qMass2 * 0.3,vec3(C2,C3,C1),fragColor,fragCoord);\n    xorRings(qPos3,1.0 + qMass3 * 0.3,vec3(C3,C1,C2),fragColor,fragCoord);\n\n    vec2 center = iResolution.xy * 0.5;\n    const vec3 pColor = vec3(1.,1.,0.8);\n    drawLine(center,qPos1,4.,pColor,fragColor,fragCoord);\n    drawLine(qPos1,qPos2,4.,pColor,fragColor,fragCoord);\n    drawLine(qPos2,qPos3,4.,pColor,fragColor,fragCoord);\n\n    drawCircle(center,15.,pColor,fragColor,fragCoord);\n    drawCircle(qPos1,1.0 + qMass1 * 0.3,pColor,fragColor,fragCoord);\n    drawCircle(qPos2,1.0 + qMass2 * 0.3,pColor,fragColor,fragCoord);\n    drawCircle(qPos3,1.0 + qMass3 * 0.3,pColor,fragColor,fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void saveSettings(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor = q[i];\n            return;\n        }\n}\n\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(iFrame < 2 || keyClick(32,iChannel3)) {\n        qGravity = 60.;\n        qTime = 0.03;\n        qLength1 = 200.;\n        qLength2 = 200.;\n        qLength3 = 200.;\n        qMass1 = 50.;\n        qMass2 = 50.;\n        qMass3 = 50.;\n        qAccel1 = 0.;\n        qAccel2 = 0.;\n        qAccel3 = 0.;\n        qSpeed1 = 0.;\n        qSpeed2 = 0.;\n        qSpeed3 = 0.;\n        qAngle1 = 0.;\n        qAngle2 = 3.;\n        qAngle3 = 3.;\n        saveSettings(fragColor,fragCoord); \n        return;\n    }\n    \t\n    fragColor = fetchData(iChannel0, ivec2(fragCoord));\n    getSettings(iChannel0); \n    \n    // -----------------------------------------------------------------------------------\n    // necessary? Want all segments to be workinng with the same data.\n    \n    if((iFrame & 1) == 1) {\n        nAccel1 = qAccel1;\n        nSpeed1 = qSpeed1;\n        nAngle1 = qAngle1;\n        nAccel2 = qAccel2;\n        nSpeed2 = qSpeed2;\n        nAngle2 = qAngle2;\n        nAccel3 = qAccel3;\n        nSpeed3 = qSpeed3;\n        nAngle3 = qAngle3;\n        saveSettings(fragColor,fragCoord); \n        return;\n    }\n \n    // -----------------------------------------------------------------------------------\n    if(getKeyState(81,iChannel3)) qLength1 = clamp(qLength1 - 2.,5.,250.); // Q\n    if(getKeyState(87,iChannel3)) qLength1 = clamp(qLength1 + 2.,5.,250.); // W\n    if(getKeyState(65,iChannel3)) qLength2 = clamp(qLength2 - 2.,5.,250.); // A\n    if(getKeyState(83,iChannel3)) qLength2 = clamp(qLength2 + 2.,5.,250.); // S\n    if(getKeyState(90,iChannel3)) qLength3 = clamp(qLength3 - 2.,5.,250.); // Z\n    if(getKeyState(88,iChannel3)) qLength3 = clamp(qLength3 + 2.,5.,250.); // X\n    if(getKeyState(69,iChannel3)) qMass1 = clamp(qMass1 - 2.,5.,250.); // E\n    if(getKeyState(82,iChannel3)) qMass1 = clamp(qMass1 + 2.,5.,250.); // R\n    if(getKeyState(68,iChannel3)) qMass2 = clamp(qMass2 - 2.,5.,250.); // D\n    if(getKeyState(70,iChannel3)) qMass2 = clamp(qMass2 + 2.,5.,250.); // F\n    if(getKeyState(67,iChannel3)) qMass3 = clamp(qMass3 - 2.,5.,250.); // C\n    if(getKeyState(86,iChannel3)) qMass3 = clamp(qMass3 + 2.,5.,250.); // V\n    if(getKeyState(84,iChannel3)) qGravity = clamp(qGravity - 2.,1.,50.); // T\n    if(getKeyState(89,iChannel3)) qGravity = clamp(qGravity + 2.,1.,50.); // Y\n    if(getKeyState(71,iChannel3)) qTime = clamp(qTime - 0.001, 0.001,1.); // G\n    if(getKeyState(72,iChannel3)) qTime = clamp(qTime + 0.001, 0.001,1.); // H\n    // -----------------------------------------------------------------------------------\n\n    float mu = 1. + qMass1 / (qMass2 + qMass3);\n\tfloat mu2 = 1. + qMass2 / qMass3;\n\tfloat dAngle = nAngle1 - nAngle2;\n\tfloat dAngle2 = nAngle2 - nAngle3;\n\tfloat s1Sqr = nSpeed1 * nSpeed1;\n\tfloat s2Sqr = nSpeed2 * nSpeed2;\n\tfloat s3Sqr = nSpeed3 * nSpeed3;\n\tfloat s1 = sin(nAngle1);\n\tfloat s2 = sin(nAngle2);\n\tfloat s3 = sin(nAngle3);\n\tfloat cd = cos(dAngle);\n\tfloat sd = sin(dAngle);\n\tfloat cd2 = cos(dAngle2);\n\tfloat sd2 = sin(dAngle2);\n\t\n\tqAccel1 = (qGravity * (s2 * cd - mu * s1) - (qLength2 * s2Sqr + qLength1 * s1Sqr * cd) * sd) / (qLength1 * (mu - cd * cd));\n\tqAccel2 = (mu  * qGravity * (s1 * cd - s2) + (mu * qLength1 * s1Sqr + qLength2 * s2Sqr * cd) * sd) / (qLength2 * (mu - cd * cd));\n\tqAccel3 = (mu2 * qGravity * (s2 * cd2 - s3) + (mu2 * qLength2 * s2Sqr + qLength3 * s3Sqr * cd2) * sd2) / (qLength3 * (mu2 - cd2 * cd2));\n\n\tqSpeed1 += nAccel1 * qTime;\n\tqSpeed2 += nAccel2 * qTime;\n\tqSpeed3 += nAccel3 * qTime;\n\tqAngle1 += nSpeed1 * qTime;\n\tqAngle2 += nSpeed2 * qTime;\n\tqAngle3 += nSpeed3 * qTime;\n    \n\tvec2 a1 = vec2(sin(nAngle1),-cos(nAngle1));\n\tvec2 a2 = vec2(sin(nAngle2),-cos(nAngle2));\n\tvec2 a3 = vec2(sin(nAngle3),-cos(nAngle3));\n    vec2 anchor = iResolution.xy * 0.5;    \n    vec2 delta = a1 * qLength1;\n\tqPos1 = anchor + delta;\n    delta += a2 * qLength2;\n    qPos2 = anchor + delta;\n    delta += a3 * qLength3;\n\tqPos3 = anchor + delta;\n\n    saveSettings(fragColor,fragCoord); \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GRIDX 100  // terrain size\n#define GRIDY  60\n#define START      ivec2(1,GRIDY-2) // path start/end coordinates\n#define END        ivec2(GRIDX-2 ,2)\n#define UNASSIGNED -2.\n#define WALL       -1.\n\n#define STATE_RESET          1.\n#define STATE_ASSIGN_WEIGHTS 2.\n#define STATE_MARK_PATH      3.\n\n#define qGravity  q[0].x\n#define qTime     q[0].y\n\n#define qLength1  q[1].x \n#define qMass1    q[1].y   \n#define qAccel1   q[1].z\n#define qSpeed1   q[2].x\n#define qAngle1   q[2].y\n#define qPos1     q[2].zw\n\n#define qLength2  q[3].x \n#define qMass2    q[3].y   \n#define qAccel2   q[3].z\n#define qSpeed2   q[4].x\n#define qAngle2   q[4].y\n#define qPos2     q[4].zw\n\n#define qLength3  q[5].x \n#define qMass3    q[5].y   \n#define qAccel3   q[5].z\n#define qSpeed3   q[6].x\n#define qAngle3   q[6].y\n#define qPos3     q[6].zw\n\n#define nAccel1   q[7].x\n#define nSpeed1   q[7].y\n#define nAngle1   q[7].z\n#define nAccel2   q[8].x\n#define nSpeed2   q[8].y\n#define nAngle2   q[8].z\n#define nAccel3   q[9].x\n#define nSpeed3   q[9].y\n#define nAngle3   q[9].z\n\n#define ADDR_COUNT  10\nvec4[ADDR_COUNT] q;\n\nconst ivec2 Q0 = ivec2( 0,GRIDY+1);\nconst ivec2 Q1 = ivec2( 1,GRIDY+1);\nconst ivec2 Q2 = ivec2( 2,GRIDY+1);\nconst ivec2 Q3 = ivec2( 3,GRIDY+1);\nconst ivec2 Q4 = ivec2( 4,GRIDY+1);\nconst ivec2 Q5 = ivec2( 5,GRIDY+1);\nconst ivec2 Q6 = ivec2( 6,GRIDY+1);\nconst ivec2 Q7 = ivec2( 7,GRIDY+1);\nconst ivec2 Q8 = ivec2( 8,GRIDY+1);\nconst ivec2 Q9 = ivec2( 9,GRIDY+1);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i) \n        q[i] = texelFetch(channel, addrList[i],0);\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\treturn (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lclcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[553, 553, 608, 608, 838], [840, 840, 933, 933, 1205], [1207, 1207, 1297, 1297, 1558], [1560, 1560, 1648, 1648, 1969], [2073, 2073, 2130, 2130, 3014]], "test": "error"}
{"id": "McscR4", "name": "2D SDF Dance remake", "author": "nayk", "description": "originals https://www.shadertoy.com/view/MXK3WG", "tags": ["particles", "neon"], "likes": 3, "viewed": 87, "published": 3, "date": "1720881922", "time_retrieved": "2024-07-18T23:34:01.308090", "image_code": "#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define sum3(V) (V.x+V.y+V.z)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scaled so (0,0) is in center of screen, adjusted for aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    uv*=2.5;\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n    vec3 col = vec3(0.);\n\n    for (float i = 5.; i < 70.; i ++)\n        col += (.5+.5*sin(vec3(TAU/1.,TAU/2.,TAU*1./3.)+i*2.47) )// color\n          *.05/distance(uv+0.01*cos(i)*1.*trunc(iTime*1.1+i),\n            vec2(sin(iTime*i/13.-i)+cos(i),cos(iTime*i/13.+i))*0.8)+sin(i);\n\n    col = clamp(col,0.,3.5);\n\n   \n    col = sqrt(col)*2.-1.;\n\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McscR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 133, 206, 827]], "test": "ok"}
{"id": "lcscR4", "name": "sci-fi lines", "author": "nayk", "description": "originals https://www.shadertoy.com/view/mtyGWy https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/7ldyWn", "tags": ["fractal", "lines", "scifi"], "likes": 6, "viewed": 120, "published": 3, "date": "1720881419", "time_retrieved": "2024-07-18T23:34:02.066064", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat h(vec2 p)\n{\n\n\tvec3 a  = fract(vec3(p.yxy) * .2031);\n  \n    a += dot(a+sin(iTime*0.000002), a.yzx+cos(iTime*0.002) + 33.33);\n    \n    return fract((a.x+sin(iTime*0.001) + a.y+sin(iTime*0.001)) * a.z+sin(iTime*0.0002));\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 p2 = C / 40.;\n  \n     vec2 uv = (C * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n  \n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*0.4);\n\n        d = sin(d*8. + iTime*002.)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n  \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n       \n        a=20.;\n        p=mod(p-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    2.+cos(iTime*.0+.5*cos(iTime*.0))*3.,\n                    120,\n                    3.+cos(iTime*.0)*5.\n                 )+finalColor;\n         }\n \n         g+=e=length(p.yx*mat2(cos(iTime*0.51), sin(iTime*0.51), -sin(iTime*0.51),cos(iTime*0.51)))/s;\n    }\n      O*= vec4(step(abs(abs(fract(dot(vec2((floor(h(ceil(p2))*2.-.5)),1),p2))-.5)-.38),.06));\n       O*= vec4(finalColor*20., 1.0);\n      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcscR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 123, 123, 331], [332, 332, 357, 357, 541], [542, 542, 578, 578, 2003]], "test": "ok"}
{"id": "lXKSDV", "name": "2D SDF Dance II", "author": "dray", "description": "More colors, less “bloom”\nWhich do you like more?", "tags": ["sdf"], "likes": 4, "viewed": 86, "published": 3, "date": "1720881395", "time_retrieved": "2024-07-18T23:34:02.827030", "image_code": "#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define sum3(V) (V.x+V.y+V.z)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scaled so (0,0) is in center of screen, adjusted for aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    for (float i = 15.; i < 40.; i ++)\n        col += (.5+.5*sin(vec3(0.,TAU/3.,TAU*2./3.)+i*.87) )// color\n          *.02/distance(uv,\n            vec2(sin(iTime*i/5.),cos(iTime*i/13.))*.8);\n\n    col = clamp(col,0.,1.);\n\n    //col += (sum3(col)/2.-col)*.8;\n    col = sqrt(col)*2.-1.;\n\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lXKSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 133, 206, 618]], "test": "ok"}
{"id": "MflcRH", "name": "Sci Fi Pattern", "author": "leon", "description": "Sci Fi Pattern", "tags": ["abstract", "pattern", "scifi"], "likes": 6, "viewed": 148, "published": 3, "date": "1720864939", "time_retrieved": "2024-07-18T23:34:03.600961", "image_code": "\n// Sci Fi Pattern\n// 2024/07/13 Leon Denise\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    // coordinates distance\n    #define T(u) texture(iChannel0, uv+u/iResolution.xy).x\n    float z = T(0.);\n    \n    float edge = 0.;\n    float ao = 0.;\n    \n    const float count = 9.;\n    for (float a = 0.; a < count; ++a)\n    {\n        // blue noise scroll https://www.shadertoy.com/view/tlySzR\n        ivec2 pp = ivec2(fragCoord);\n        pp = (pp+(int(a))*ivec2(113,127)) & 1023;\n        vec3 blu = texelFetch(iChannel1,pp,0).xyz;\n        \n        // edge detection\n        float f = a/count;\n        float aa = 6.283*f;\n        vec2 xy = vec2(cos(aa),sin(aa));\n        edge += abs(T(xy)-T(-xy));\n        \n        // sort of ambient occlusion\n        float r = (.5+blu.z) * 10.;\n        xy = normalize(vec2(blu.xy-.5))*r;\n        ao += abs(z-T(xy))/r;\n    }\n    \n    vec3 color = vec3(edge+ao);\n    \n    // dots\n    //float screen = iResolution.x/1200.;\n    //color += smoothstep(.05,-.05,abs(length(frame.xy*20.*screen)-.2)-.05);\n    \n    fragColor = vec4(1.-color, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1);\n    vec4 frame = texture(iChannel0, uv);\n    \n    // timeline\n    float tick = mod(float(iFrame), 200.);\n    \n    // init\n    if (tick < 1.)\n    {\n        vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n        frame = vec4(p, max(abs(p.x),abs(p.y)), 0);\n    }\n    // iterate\n    else if (tick < 20.)\n    {\n        // previous coordinates\n        vec2 p = frame.xy;\n        \n        // seed\n        vec4 rng = hash41(tick+iDate.w+iDate.z+iDate.y+iDate.x);\n        \n        // rotate\n        p.xy *= rot(3.1415/2.);\n        \n        // translate\n        p.xy += (rng.xy-.5)*50./tick*max(0.1,rng.w);\n        \n        // keep result if closer\n        float dist = max(abs(p.x),abs(p.y));\n        if (dist < frame.z)\n        {\n            frame.xy = p.xy;\n            frame.z = dist;\n            frame.w = tick;\n        }\n    }\n    \n    fragColor = frame;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MflcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 1168]], "test": "error"}
{"id": "Xcsyz4", "name": "star rotation", "author": "nayk", "description": "star\n", "tags": ["fractal", "rotate", "star"], "likes": 4, "viewed": 116, "published": 3, "date": "1720860885", "time_retrieved": "2024-07-18T23:34:04.360929", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage(out vec4 O, vec2 C)\n{\nvec2 uv = ( C - .5*iResolution.xy ) / iResolution.y;\n uv.x+=0.3*cos(iTime);\n        uv.y+=0.3*sin(iTime);\n    O=vec4(0);\n    vec3 p,r=iResolution,n=vec3(-.5,-.707,.5),\n    d=normalize(vec3((C-.5*r.xy),r.y));  \n    for(float i=0.,e,g=0.;\n        ++i<99.;\n        O.xyz+=mix(vec3(1),H(length(p)*.5+iTime*0.),.7)*.05*exp(-.13*i*i*e)\n    )\n    {\n        p=g*d;\n       \n       p.x+=3.*cos(iTime);\n        p.y+=3.*sin(iTime);\n        p.z-=10.;\n         p.xz*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime));\n          p.yz*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime));\n        p=R(p,normalize(vec3(-1,10,2)),-iTime*3.0);\n        for(int j=0;j<15;j++)\n        \n             p.zy=abs((p.zy)),\n            p.xy=abs((p.xy)),\n            p-=2.*min(fract(p.x+p.z),dot(p,n))*n;\n        p.z=fract(log(p.z)+iTime*3.5)-.5;\n        g+=e=abs(min(length(p.yz),length(p.xz))-.03)+.001;\n    }\n    \n    \n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,.15)*3.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcsyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 145, 145, 291], [294, 294, 330, 330, 1370]], "test": "ok"}
{"id": "4flyz4", "name": "black cube in ", "author": "nayk", "description": "original from gaz fractal", "tags": ["fractal", "cube", "cineshader"], "likes": 3, "viewed": 80, "published": 3, "date": "1720860824", "time_retrieved": "2024-07-18T23:34:05.192706", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,n=vec3(-.5,-.707,.5),\n    d=normalize(vec3((C-.5*r.xy),r.y));  \n    for(float i=0.,e,g=0.;\n        ++i<99.;\n        O.xyz+=mix(vec3(1),H(length(p)*.5+iTime*3.),.7)*.05*exp(-.03*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=10.;\n        p=R(p,normalize(vec3(-1,0,2)),iTime*.5);\n        for(int j=0;j<4;j++)\n            p.xy=abs(ceil(p.xy)),\n            p-=2.*min(0.,dot(p,n))*n;\n        p.z=fract(log(p.z)-iTime*.5)-.5;\n        g+=e=abs(min(length(p.yz),length(p.xz))-.03)+.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 669]], "test": "ok"}
{"id": "4clyz4", "name": "spiralic rotation eye", "author": "nayk", "description": "from", "tags": ["spiral", "rotation"], "likes": 2, "viewed": 54, "published": 3, "date": "1720860732", "time_retrieved": "2024-07-18T23:34:06.000546", "image_code": "\n#define time iTime\n#define resolution iResolution.xy\n\n\n#define S 0.4\n\nbool inSquare(vec2 p, float d)\n{\n\treturn abs(p.x*ceil(p.y))<=d && abs(p.y)<=d;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(resolution.x, resolution.y);\n\tvec2 uv = ( 2.0*gl_FragCoord.xy - resolution.xy) / mx ;\n    vec2 uv2 = fragCoord/iResolution.xy-0.5;\n\tvec3 col = vec3(0.);\n    float buf;\n    vec2 pos = uv;\n\tconst float pi = 3.14159;\n\t float radius = 0.4+0.1*cos(iTime*1.3);\n\tconst float thickness = 0.03;\n\tconst float wave_offset = 0.2;\n\tconst float wave_interval = 5.;\n\tconst int line_count = 6;\n\tconst vec3 color = vec3(0.8, 0.15, 1);\n\n\tfloat r = distance(pos, vec2(0.));\n\tfloat angle = atan(pos.x, pos.y);\n\tfloat lightness = 0.;\n\n\tfor(int i = 0; i < line_count; i++) {\n\t\tfloat this_angle = angle * wave_interval + (time * float(i + 1));\n\t\tlightness += 1. - smoothstep(-thickness, thickness, abs(r - radius * (1. + wave_offset * sin(this_angle))));\n\t}\n\n  float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n\tfor (float i=0.; i<5.; i++) \n\t{\n    uv*=ma;\n\t\tuv.y = abs(uv.y)*ceil(uv.x*uv.y);\n\t\tuv.x = abs(uv.x);\n\t\tif (uv.y<uv.x)\n\t\t{\n\t;\t    buf = uv.x*ceil(uv.x);\n\t\t    uv.x = uv.y*ceil(uv.y);\n\t\t    uv.y = buf;\n\t\t}\n\t\tuv.x = uv.x + 2.*max(1./3.*S-uv.x,0.);\n\t\tuv -= 2./3.*S;\n\t\t\tuv *= 3.;\n\t}\n\tcol += inSquare(uv, S) ? 1.0 : 0.0;\n\t\n\t//col.xy += uv;\n\n\tfragColor = vec4( col*color+lightness*vec3(46, 230, 95)/255.0, 1.0 );\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor+= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.75)*0.05, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4clyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 103, 103, 151], [152, 152, 191, 191, 337], [338, 338, 395, 395, 1921]], "test": "ok"}
{"id": "4fsczr", "name": "ZombieWalk", "author": "kosalos", "description": "find least expensive path", "tags": ["pathfinding"], "likes": 6, "viewed": 90, "published": 3, "date": "1720834291", "time_retrieved": "2024-07-18T23:34:06.857256", "image_code": "// Demonstration of path finding algorhyithm\n// Walls are impassible barriers\n// Terrain height has effect on the 'shortest' path.\n//\n// Use mouse to move the walls\n// Press <Spc> to reset\n//\n// Cell contents: xyz = color;  w = terrain height (and wall markers)\n//--------------------------------------------------------------\n\nvoid highlight(ivec2 p1, ivec2 p2, inout vec4 fragColor) {\n    p1 -= p2;\n    float dist = sqrt(float(p1.x*p1.x) + float(p1.y*p1.y));\n    if(dist < 2.0) fragColor.xyz = vec3(1.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // screen coord -> grid\n    fragCoord /= iResolution.xy;  // 0 ... 1\n    ivec2 addr = ivec2(int(float(GRIDX) * fragCoord.x),int(float(GRIDY) * fragCoord.y));\n\n    fragColor = fetchData(iChannel0, addr); \n\n    getSettings(iChannel0);\n    if(qState == STATE_ASSIGN_WEIGHTS && fragColor.w > 0.) fragColor *= 1.2;\n    \n    // highlight the path start and end\n    if(qState == STATE_MARK_PATH) {\n        highlight(START,addr,fragColor);\n        highlight(END,addr,fragColor);\n    \n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void saveSettings(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor.xyz = settings[i];\n            return;\n        }\n}\n\n// ----------------------------------------------------------\n\nconst ivec2[] neighborOffsets = ivec2[](\n    ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),\n    ivec2(-1,0),ivec2(1,0),\n    ivec2(-1,1),ivec2(0,1),ivec2(1,1));   \n\nivec2 neighborCoord(ivec2 base, int offsetIndex) {\n    ivec2 ans = base + neighborOffsets[offsetIndex];\n    ans.x = min(max(ans.x,0),GRIDX-1);\n    ans.y = min(max(ans.y,0),GRIDY-1);\n    return ans;\n}\n\n// ----------------------------------------------------------\n\nvoid markPath(inout vec4 color,vec2 coord) {\n    // grid position previously marked as on the path\n    ivec2 adr = ivec2(coord);\n    if(adr == ivec2(qPosition.xy)) {\n        color.xyz = vec3(1.,0.,0.);\n        return;\n    }\n    \n    // from the current end of the path: scan all neighbors for the lowest terrain value.\n    // store that position for the next frame\n    if(adr == Q1) {  // qPosition storage\n        const float HIGHMARK = 99999.;\n        vec4 neighbor;\n        float lowestValue = HIGHMARK;\n        int lowestIndex = 0;\n\n        for(int i=0;i<8;++i) {\n            neighbor = fetchData(iChannel0,neighborCoord(ivec2(qPosition),i));\n            if(neighbor.w < 0.) continue;\n            if(neighbor.w == WALL) continue;\n\n            if(neighbor.w < lowestValue) {\n                lowestValue = neighbor.w;\n                lowestIndex = i;\n            }\n        }\n\n        qPosition = vec2(neighborCoord(ivec2(qPosition),lowestIndex));\n    }    \n}\n\n// ----------------------------------------------------------\n\nvoid assignTerrainWeights(inout vec4 color,vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    if(adr.x >= GRIDX || adr.y >= GRIDY) return;\n    \n    color = fetchData(iChannel0,adr);\n    if(color.w == WALL) return;       // walls don't count    \n    if(color.w != UNASSIGNED) return; // already assigned a weight\n    \n    // find lowest valued neighbor. our value = his value + our terrain penalty\n    const float HIGHMARK = 99999.;\n    vec4 neighbor;\n    float lowestValue = HIGHMARK;\n    \n    for(int i=0;i<8;++i) {\n        neighbor = fetchData(iChannel0,neighborCoord(adr,i));\n        if(neighbor.w == UNASSIGNED || neighbor.w == WALL) continue;\n        if(neighbor.w < lowestValue) lowestValue = neighbor.w;\n    }\n    \n    if(lowestValue == HIGHMARK) return; // have no neighbors yet\n    \n    color.w = 1. + lowestValue + (color.x + color.y + color.z) * 10.;\n}\n\n// ----------------------------------------------------------\n\n#define WALL_WIDTH 15\nconst vec4 WALLPIP   = vec4(1.0,0.0,0.9,WALL);\nconst vec4 WALLCOLOR = vec4(0.3,0.9,0.4,WALL);\n\nvoid horizontalWall(inout vec4 color,vec2 wall,ivec2 coord) {\n    if(coord.y != int(wall.y)) return;\n    \n    for(int x = -WALL_WIDTH; x <= +WALL_WIDTH; ++x) {\n        ivec2 pos = ivec2(int(wall.x)+x, int(wall.y));\n        if(pos == coord) color = (x == 0) ? WALLPIP : WALLCOLOR;\n    }\n}\n\nvoid verticalWall(inout vec4 color,vec2 wall,ivec2 coord) {\n    if(coord.x != int(wall.x)) return;\n    \n    for(int y = -WALL_WIDTH; y <= +WALL_WIDTH; ++y) {\n        ivec2 pos = ivec2(int(wall.x), int(wall.y)+y);\n        if(pos == coord) color = (y == 0) ? WALLPIP : WALLCOLOR;\n    }\n}\n\nvoid initializeCells(inout vec4 color,vec2 fragCoord) {\n    qState = STATE_RESET;\n    qFrame = float(iFrame);\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    if(coord.x < GRIDX && coord.y < GRIDY) {\n        vec2 uv = fragCoord / iResolution.xy + vec2(iTime * 0.01, iTime * 0.003);\n        color = vec4(vec3(texture(iChannel1,uv * 2.3)),UNASSIGNED);\n        \n        horizontalWall(color,qwall1,coord);\n        horizontalWall(color,qwall2,coord);\n        horizontalWall(color,qwall3,coord);\n        verticalWall(color,qwall4,coord);\n        verticalWall(color,qwall5,coord);\n        verticalWall(color,qwall6,coord);\n    }\n    \n    if(coord == END) color.w = 0.; // seed point for determining cell weights\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(iFrame < 30 || keyClick(32,iChannel3)) {\n        qwall1 = vec2(20.,20.);\n        qwall2 = vec2(50.,20.);\n        qwall3 = vec2(80.,20.);\n        qwall4 = vec2(20.,40.);\n        qwall5 = vec2(50.,40.);\n        qwall6 = vec2(80.,40.);\n        saveSettings(fragColor,fragCoord);\n\n        initializeCells(fragColor,fragCoord);\n        return;\n    }\n\n    getSettings(iChannel0); \n    fragColor = fetchData(iChannel0, ivec2(fragCoord));\n    \n    // -----------------------------------\n    // moving walls sets qState -> STATE_RESET\n       \n    if(iMouse.z > 0.) {     // mouse down or dragged\n        vec2 mPos = vec2(GRIDX,GRIDY) * iMouse.xy / iResolution.xy; // mouse as grid position\n    \n        if(iMouse.w > 0.) { // mouse down\n            float dist,bestDist = 999.;\n            int bestIndex = -1;\n            qMouseIndex = -1.; // assume click was too far away\n\n            for(int i=0;i<6;++i) {\n                dist = length(settings[2+i].xy - mPos);\n                if(dist < 10. && dist < bestDist) {\n                    bestDist = dist;\n                    bestIndex = i;\n                }\n            }\n\n            if(bestIndex >= 0) qMouseIndex = float(bestIndex);\n        }\n        \n        if(qMouseIndex >= 0. && iMouse.w < 0.) { // mouse drag\n            vec2 mPos = vec2(GRIDX,GRIDY) * iMouse.xy / iResolution.xy; // mouse as grid position\n            settings[2+ int(qMouseIndex)].xy = mPos;\n            initializeCells(fragColor, fragCoord);\n        }\n    }\n    \n    // -----------------------------------\n    \n    if(qState == STATE_RESET && qFrame != float(iFrame))\n        qState = STATE_ASSIGN_WEIGHTS;   \n        \n    if(qState == STATE_ASSIGN_WEIGHTS) {\n        vec4 color = fetchData(iChannel0,START);\n        if(color.w != UNASSIGNED) {\n            qState = STATE_MARK_PATH;\n            qPosition = vec2(START);\n        }\n        else\n            assignTerrainWeights(fragColor,fragCoord); \n    }\n\n    if(qState == STATE_MARK_PATH)\n        markPath(fragColor,fragCoord); \n\n    saveSettings(fragColor,fragCoord); \n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GRIDX 100  // terrain size\n#define GRIDY  60\n#define START      ivec2(1,GRIDY-2) // path start/end coordinates\n#define END        ivec2(GRIDX-2 ,2)\n#define UNASSIGNED -2.\n#define WALL       -1.\n\n#define STATE_RESET          1.\n#define STATE_ASSIGN_WEIGHTS 2.\n#define STATE_MARK_PATH      3.\n\n#define qState      settings[0].x\n#define qFrame      settings[0].y\n#define qMouseIndex settings[0].z\n#define qPosition settings[1].xy\n#define qwall1    settings[2].xy\n#define qwall2    settings[3].xy\n#define qwall3    settings[4].xy\n#define qwall4    settings[5].xy\n#define qwall5    settings[6].xy\n#define qwall6    settings[7].xy\nconst int ADDR_COUNT =     8;\n\nvec3[ADDR_COUNT] settings;\n\nconst ivec2 Q0 =  ivec2( 0,GRIDY+1);\nconst ivec2 Q1 =  ivec2( 1,GRIDY+1);\nconst ivec2 Q2 =  ivec2( 2,GRIDY+1);\nconst ivec2 Q3 =  ivec2( 3,GRIDY+1);\nconst ivec2 Q4 =  ivec2( 4,GRIDY+1);\nconst ivec2 Q5 =  ivec2( 5,GRIDY+1);\nconst ivec2 Q6 =  ivec2( 6,GRIDY+1);\nconst ivec2 Q7 =  ivec2( 7,GRIDY+1);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i) \n        settings[i] = texelFetch(channel, addrList[i],0).xyz;\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\treturn (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 328, 386, 386, 513], [515, 515, 572, 600, 1065]], "test": "error"}
{"id": "4cfyzN", "name": "Circle - SDF motion blur", "author": "jafam", "description": "WIP motion blur based on signed distance fields. More of a spaghettification than a true blur.\nToDo: Use Inigo's elongation operator on circle SDF instead of a segment.", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "segment"], "likes": 0, "viewed": 82, "published": 3, "date": "1720818030", "time_retrieved": "2024-07-18T23:34:07.686040", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec2 opElongate(vec2 p, vec2 h) {\n    return p-clamp(p,-h,h);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 ba, float r) {\n    vec2 pa = p-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-ba*h)-r;\n}\n\nvec4 hash4( float n ) { return fract(sin(vec4(n,n+1.0,n+2.0,n+3.0))*43758.5453123); }\n\nvec4 state(float t, vec4 id) {\n    const float speed = 10.0;\n    const vec2 box = vec2(0.5);\n    vec2 a = speed*(0.75+0.5*id.zw)*t+20.0*id.xy;\n    vec2 pos = box*vec2(sin(a.x),cos(a.y));\n    vec2 vel = box*vec2(cos(a.x),-sin(a.y));\n    vel *= speed;\n    return vec4(pos,vel);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec4 disc1 = state(t,hash4(0.0));\n    vec4 disc2 = state(t,hash4(13.13));\n    vec4 disc3 = state(t,hash4(26.26));\n    const float fps = 24.0;\n    const float r = 0.2;\n    float d1 = sdSegment(p, disc1.xy,disc1.zw/fps,r);\n    float d2 = sdSegment(p, disc2.xy,disc2.zw/fps,r);\n    float d3 = sdSegment(p, disc3.xy,disc3.zw/fps,r);\n    vec3 col = vec3(0.2+0.1*p.y);\n    col += clamp(-16.0*vec3(d1,d2,d3),0.0,1.0);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cfyzN.jpg", "access": "api", "license": "mit", "functions": [[1078, 1078, 1111, 1111, 1141], [1143, 1143, 1194, 1194, 1299], [1301, 1301, 1324, 1324, 1386], [1388, 1388, 1418, 1418, 1665], [1667, 1667, 1722, 1722, 2247]], "test": "ok"}
{"id": "McXyR4", "name": "MacOs Montegray yebjhar 972", "author": "yebjhar", "description": "MacOS Monterey wallpaper", "tags": ["wave", "wallpaper", "mac", "monterey"], "likes": 1, "viewed": 72, "published": 3, "date": "1720818028", "time_retrieved": "2024-07-18T23:34:08.446009", "image_code": "\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  fragColor = texture(iChannel0, uv);\n\n  fragColor.xyz *= (uv.y * 1.08 + 0.65);\n  // fragColor = vec4(col); // Output to screen\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvec3 sin_shape(in vec2 uv, in float offset_y) {\n  // Time varying pixel color\n  float y = sin((uv.x + iTime * -0.06 + offset_y) * 5.5);\n\n  float x = uv.x * 8.;\n  float a=1.;\n\tfor (int i=0; i<5; i++) {\n\t\tx*=0.53562;\n\t\tx+=6.56248;\n\t\ty+=sin(x)*a;\t\t\n\t\ta*=.5;\n\t}\n\n  float y0 = step(0.0, y * 0.08 - uv.y + offset_y);\n  return vec3(y0, y0, y0);\n}\n\nvec2 rotate(vec2 coord, float alpha) {\n  float cosA = cos(alpha);\n  float sinA = sin(alpha);\n  return vec2(coord.x * cosA - coord.y * sinA, coord.x * sinA + coord.y * cosA);\n}\n\nvec3 scene(in vec2 uv) {\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    col += sin_shape(uv, 0.3) * 0.2;\n    col += sin_shape(uv, 0.7) * 0.2;\n    col += sin_shape(uv, 1.1) * 0.2;\n\n    vec3 fragColor;\n\n    if (col.x >= 0.6 ) {\n      fragColor = vec3(0.28,0.36,0.36);\n    } else if (col.x >= 0.4) {\n      fragColor = vec3(0.49,0.55,0.56);\n    } else if (col.x >= 0.2) {\n      fragColor = vec3(0.33, 0.47, 0.49);\n    } else {\n      fragColor = vec3(0.24, 0.39, 0.4);\n    }\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = rotate(fragCoord + vec2(0.0, -300.0), 0.5);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col0 = scene((fragCoord * 2.0)/iResolution.xy);\n    vec3 col1 = scene(((fragCoord * 2.0) + vec2(1.0, 0.0))/iResolution.xy);\n    vec3 col2 = scene(((fragCoord * 2.0) + vec2(1.0, 1.0))/iResolution.xy);\n    vec3 col3 = scene(((fragCoord * 2.0) + vec2(0.0, 1.0))/iResolution.xy);\n\n    // Output to screen\n    fragColor = vec4((col0 + col1 + col2 + col2) / 4.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McXyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 57, 57, 225]], "test": "error"}
{"id": "4fXczN", "name": "Pre-built Raymarcher", "author": "JOEMANFLAME", "description": "This is a premade basic ray-marching algorithm. I made this as an easy way to start ray-marching renders, without coding every aspect from the ground up. It includes helpful comments throughout explaining what each step does (too the best of my knowledge)", "tags": ["raymarching", "utility", "premade"], "likes": 1, "viewed": 51, "published": 3, "date": "1720817050", "time_retrieved": "2024-07-18T23:34:09.196004", "image_code": "// Pre-setup ray-marcher, mostly for my own use but includes helpful\n// comments explaining each step in the process\n//--------------------------------------------------------------------------------------------------------------------\n\n// Global Variables\n\nfloat fov = 1.0;                                     // FOV adjuster (located in ray-direction intialization)\nint iter = 64;                                       // Iterations for ray-marcher to take\nvec3 rayOrig = vec3(0.0, 0.0, -3.0);                 // xyz-coordinates for ray-marcher to begin at\n\n//--------------------------------------------------------------------------------------------------------------------\n\n// Palette\n// Code originally from: https://iquilezles.org/articles/palettes\n\nvec3 palette( in float t ) \n{                      \n    vec3 a = vec3(0.5, 0.5, 0.5); \n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(1.000, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.577);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Functions\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Primitive SDFs (Geometry)\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//--------------------------------------------------------------------------------------------------------------------\n\n// Map\n\n// 'Draw objects' using signed distance functions, SDFs will\n// return negative values when inside geometry and positive\n// when outside, decreasing in value as it approaches geometry\n// Useful SDF functions at https://iquilezles.org/articles/distfunctions/\n\nfloat map(vec3 p)\n{\n    float sphere = sdSphere(p, 1.0);                    // Sets position values based on sphere SDF (defined above)\n    \n    return sphere;\n}\n\n//--------------------------------------------------------------------------------------------------------------------\n\n// Ray-Marcher\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDirection) \n{\n    \n    float t = 0.0;                                      // Distance ray has travelled\n    vec3 col = vec3(0.0);                               // Background (final) pixel color\n    float d;                                            // Distance to scene (will use map)\n    int i;\n    for (i = 0; i < iter; i++) {\n        \n        vec3 p = rayOrigin + rayDirection*t;            // Position along the ray w.r.t. the rays origin\n        d = map(p);                                     // Set d = distance to scene as given by p\n        \n        if (d < 0.001 || d > 100.0) {                   // If d is less than 0.01 (eg. close to geometry) or if d is\n            break;                                      // greater than 100 (eg. ray is going off to infinity then\n        }                                               // move to next ray cast\n        \n        // col += palette(t);                           // To color matrix add the output of the palette function\n        \n        t +=d;                                          // Move the ray forward in the scene by amount d\n    }\n    col = vec3(t * 0.2);                                // Returns color based on distance ray has travelled\n    \n    return vec4(col, 1.0);                              // return a vec4 containing our colored geometry positions\n}                    \n\n//--------------------------------------------------------------------------------------------------------------------\n// Output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates into uv coordinates, centered in the middle of the screen\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) /iResolution.y;\n    vec2 mouseInput = (iMouse.xy * 2.0 - iResolution.xy) /iResolution.y;\n    \n    // Initialization\n    vec3 r0 = vec3(rayOrig);                            // Ray-origin\n    vec3 rd = normalize(vec3(uv * fov, 1.0));           // Ray-direction (normalize to 1 so just get dir)\n    \n    // Mouse-click camera rotation (comment out if you don't want it)\n    // Vertical camera rotation (Goes first)\n    r0.yz *= rot2D(-mouseInput.y);                               // Y-component change for ray-origin\n    rd.yz *= rot2D(-mouseInput.y);                               // Y-component change for ray-direction\n    \n    // Horizontal camera rotation\n    r0.xz *= rot2D(-mouseInput.x);                               // Y-component change for ray-origin\n    rd.xz *= rot2D(-mouseInput.x);                               // Y-component change for ray-direction\n    \n    \n    //---------------------------------------------------\n    \n    // Perform any transformations you want before ray-march call\n    \n    //---------------------------------------------------\n    \n    \n    vec4 col = rayMarch(r0, rd);                        // Ray-marcher call\n    \n    \n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fXczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[758, 758, 787, 787, 1008], [1024, 1024, 1049, 1049, 1133], [1165, 1165, 1200, 1200, 1224], [1613, 1613, 1632, 1632, 1774], [1912, 1912, 1963, 1963, 3289], [3311, 3440, 3497, 3588, 4853]], "test": "ok"}
{"id": "Mclcz8", "name": "Ice Breaking", "author": "leon", "description": "the original intention of [url=https://www.shadertoy.com/view/XcsyRH]Mecharganic[url]", "tags": ["abstract", "glass", "ice", "break"], "likes": 31, "viewed": 220, "published": 3, "date": "1720798380", "time_retrieved": "2024-07-18T23:34:10.043738", "image_code": "\n// Ice Breaking\n// 2024/07/12 Leon Denise\n// the original intention of Mecharganic: https://www.shadertoy.com/view/XcsyRH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // coordinates distance\n    #define T(u) texture(iChannel0, uv+u/iResolution.xy).z\n    float z = T(0.);\n    \n    float edge = 0.;\n    float ao = 0.;\n    \n    const float count = 9.;\n    for (float a = 0.; a < count; ++a)\n    {\n        // blue noise scroll https://www.shadertoy.com/view/tlySzR\n        ivec2 pp = ivec2(fragCoord);\n        pp = (pp+(int(a))*ivec2(113,127)) & 1023;\n        vec3 blu = texelFetch(iChannel1,pp,0).xyz;\n        \n        // edge detection\n        float f = a/count;\n        float aa = 6.283*f;\n        vec2 xy = vec2(cos(aa),sin(aa));\n        edge += abs(z-T(xy));\n        \n        // sort of ambient occlusion\n        float r = (1.+blu.z) * 4.;\n        xy = normalize(vec2(blu.xy-.5))*r;\n        ao += abs(z-T(xy))/r;\n    }\n    \n    // I'm using 1200x675 frame so this is to keep it look similar at different resolution\n    float thin = .2*(675./iResolution.y); \n    vec3 color = vec3(smoothstep(thin,.01,edge)*(1.-ao));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1);\n    vec4 frame = texture(iChannel0, uv);\n    \n    // timeline\n    float tick = mod(float(iFrame), 200.);\n    \n    // init\n    if (tick < 1.)\n    {\n        vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n        frame = vec4(p, max(abs(p.x),abs(p.y)), 0);\n    }\n    // iterate\n    else if (tick < 20.)\n    {\n        // previous coordinates\n        vec2 p = frame.xy;\n        \n        // seed\n        vec4 rng = hash41(tick+iDate.w+iDate.z+iDate.y+iDate.x);\n        \n        // rotate\n        p.xy *= rot(rng.z*6.283);\n        \n        // translate\n        p.xy += (rng.xy-.5)*5./tick*max(0.1,rng.w);\n        \n        // keep result if closer\n        float dist = max(abs(p.x),abs(p.y));\n        if (dist < frame.z)\n        {\n            frame.xy = p.xy;\n            frame.z = dist;\n            frame.w = tick;\n        }\n    }\n    \n    fragColor = frame;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mclcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 181, 181, 1216]], "test": "error"}
{"id": "Mfscz8", "name": "flower_yellow", "author": "horus_2024", "description": "简单的黄色花", "tags": ["flower"], "likes": 2, "viewed": 57, "published": 3, "date": "1720798112", "time_retrieved": "2024-07-18T23:34:10.875514", "image_code": "float tree(vec2 p) {\n    // p.y -= 0.;  // Move tree down\n    float d = length(p);  // Distance to origin\n    float angle = atan(p.y, p.x);  // Angle of point from origin\n    float radius = 0.2 + 0.3 * pow(abs(cos(5.0 * angle)), 0.2);  // Radius of tree branches\n    return d - radius;  // Return distance from point to tree shape\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;  // Normalize pixel coordinates (from 0 to 1)\n    uv = uv * 2.0 - 1.0;  // Remap coordinates to the range -1 to 1\n    uv.x *= iResolution.x / iResolution.y;  // Correct aspect ratio\n\n    // Sample the tree function\n    float dist = tree(uv);\n    \n    // Create the tree shape\n    float treeShape = smoothstep(0.02, 0.04, -dist);\n\n    // Background color\n    vec3 bgColor = vec3(0.2, 0.7, 1.0);  // Sky blue\n    vec3 treeColor = vec3(1.0, 0.84, 0.1);  // Dark green\n\n    // Mix tree color and background color\n    vec3 color = mix(bgColor, treeColor, treeShape);\n\n    if (uv.x * uv.x + uv.y * uv.y < 0.04) {\n      fragColor = vec4(vec3(0.296, 0.157, 0.08), 1.0);\n    } else {\n      fragColor = vec4(color, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfscz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 57, 332], [333, 333, 388, 388, 1147]], "test": "ok"}
{"id": "XcsyRH", "name": "Mecharganic", "author": "leon", "description": "started as a breaking glass effect, ending up weird.", "tags": ["abstract", "organic"], "likes": 22, "viewed": 196, "published": 3, "date": "1720793307", "time_retrieved": "2024-07-18T23:34:11.632491", "image_code": "\n// Mecharganic\n// 2024/07/12 Leon Denise\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // coordinates distance\n    #define T(u) texture(iChannel0, uv+u/iResolution.xy).z\n    float z = T(0.);\n    \n    float edge = 0.;\n    float ao = 0.;\n    \n    const float count = 9.;\n    for (float a = 0.; a < count; ++a)\n    {\n        // blue noise scroll https://www.shadertoy.com/view/tlySzR\n        ivec2 pp = ivec2(fragCoord);\n        pp = (pp+(int(a))*ivec2(113,127)) & 1023;\n        vec3 blu = texelFetch(iChannel1,pp,0).xyz;\n        \n        // edge detection\n        float f = a/count;\n        float aa = 6.283*f;\n        vec2 xy = vec2(cos(aa),sin(aa));\n        edge += abs(z-T(xy));\n        \n        // sort of ambient occlusion\n        float r = (1.+blu.z) * 4.;\n        xy = normalize(vec2(blu.xy-.5))*r;\n        ao += abs(z-T(xy))/r;\n    }\n    \n    vec3 color = vec3((1.-edge) * (1.-ao));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1);\n    vec4 frame = texture(iChannel0, uv);\n    \n    // timeline\n    float tick = mod(float(iFrame), 200.);\n    \n    // init\n    if (tick < 1.)\n    {\n        vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n        frame = vec4(p, length(p), 0);\n        \n        // extra shape\n        //frame += step(frame.z, .9);\n    }\n    // iterate\n    else if (tick < 30.)\n    {\n        // previous coordinates\n        vec2 p = frame.xy;\n        \n        // seed\n        vec4 rng = hash41(tick+iDate.w+iDate.z+iDate.y+iDate.x);\n        \n        // rotate\n        p.xy *= rot(rng.z*6.283);\n        \n        // translate\n        p.xy += (rng.xy-.5)*2.;\n        \n        // curl\n        vec2 e = vec2(.001,0);\n        vec3 pos = vec3(p/2., length(p)/2.);\n        float x = (noise(pos+e.yxy)-noise(pos-e.yxy))/(2.*e.x);\n        float y = (noise(pos+e.xyy)-noise(pos-e.xyy))/(2.*e.x);\n        vec2 curl = vec2(y, -x);\n        p.xy += curl * .5 / tick; // comment this for sharp breaks\n        \n        // keep result if closer\n        float dist = length(p);\n        if (dist < frame.z)\n        {\n            frame.xy = p.xy;\n            frame.z = dist;\n            frame.w = tick;\n        }\n    }\n    \n    fragColor = frame;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\n\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat noise (vec3 p)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 3; ++i, a/=2.)\n    {\n        result += gyroid(p/a)*a;\n    }\n    return result;\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcsyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 100, 987]], "test": "error"}
{"id": "lcXyzH", "name": "rotating-rect", "author": "horus_2024", "description": "旋转的计算", "tags": ["rotation"], "likes": 2, "viewed": 76, "published": 3, "date": "1720766581", "time_retrieved": "2024-07-18T23:34:12.384481", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 获取分辨率和时间\n    vec2 u_resolution = iResolution.xy;\n    float u_time = iTime;\n    \n    // 将fragCoord标准化为[-1, 1]范围\n    vec2 uv = fragCoord / u_resolution;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= u_resolution.x / u_resolution.y; // 保持宽高比\n\n    // 转换为弧度\n    float angle = u_time;\n\n    // 旋转矩阵\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv = rotation * uv;\n\n    // 定义矩形的宽度和高度\n    float width = 1.0;\n    float height = 1.0;\n\n    // 检查点是否在矩形内部\n    if (abs(uv.x) < width / 2.0 && abs(uv.y) < height / 2.0)\n    {\n        fragColor = vec4(1, 0.1, 0.1, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(1, 1.0, 1.0, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 813]], "test": "ok"}
{"id": "4ffyz8", "name": "Fork cellnoise  tetrismegi 063", "author": "tetrismegistus", "description": "experimenting with presentations of simplex noise, most code here comes directly from the book of shaders or its sources", "tags": ["experiment", "learning", "simplexnoise"], "likes": 1, "viewed": 51, "published": 3, "date": "1720739494", "time_retrieved": "2024-07-18T23:34:13.138465", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec2 permute(const in vec2 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec3 permute(const in vec3 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec4 permute(const in vec4 v) { return mod289(((v * 34.0) + 1.0) * v); }\n\n#endif\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    return p;\n}\n#endif\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec2 snoise2( vec2 x ){\n    float s  = snoise(vec2( x ));\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n\n#endif\n\nvec2 random2( vec2 p ) { \n return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat sdHexagon(in vec2 p, in float r)\n{\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Calculate distance to hexagon\n    float hexagonDist = sdHexagon(st, 0.5);\n\n    // Anti-aliasing using smoothstep\n    float hexagon = smoothstep(-0.02, 0.02, -hexagonDist)  ;\n\n    float n = snoise(vec3(st.x, st.y, iTime * 0.5));\n    st += n;\n    \n    st *= 50.0;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    vec3 blue = vec3(0.455, 0.537, 0.753);\n    vec3 orange = vec3(0.961, 0.318, 0.035);\n    vec3 offWhite = vec3(0.941, 0.918, 0.776);\n\n    vec3 verGrad = mix(orange, blue, st.y);\n    vec3 horGrad = mix(offWhite, blue, st.x);\n    vec3 mixGrad = mix(verGrad, horGrad, sin(iTime));\n\n    vec3 color = mixGrad;\n\n    fragColor = vec4(color * hexagon, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ffyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8736, 8736, 8760, 8760, 8851], [8853, 8853, 8893, 8893, 9097], [9099, 9099, 9154, 9204, 9976]], "test": "error"}
{"id": "Mfsyzr", "name": "Easy Pixel Shader", "author": "ARtronClassic", "description": "the simplest implementation of a pixel shader.", "tags": ["pixel"], "likes": 2, "viewed": 71, "published": 3, "date": "1720730509", "time_retrieved": "2024-07-18T23:34:13.887462", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 pixel = floor(uv * vec2(50)) / vec2(50);\n    vec4 v = texture(iChannel0,pixel);\n    fragColor = v;\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfsyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 212]], "test": "error"}
{"id": "Mfsczn", "name": "cellnoise exp 2", "author": "tetrismegistus", "description": "experimenting with presentations of cellular noise, most code here comes directly from the book of shaders", "tags": ["experiment", "learning", "cellularnoise"], "likes": 5, "viewed": 70, "published": 3, "date": "1720726256", "time_retrieved": "2024-07-18T23:34:14.644439", "image_code": "vec2 random2( vec2 p ) { \n return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float hexagon = sdHexagon(st, .5);\n       \n    // Scale\n    st *= 50.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimum distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    vec3 blue = vec3(0.455,0.537,0.753);\n    vec3 orange = vec3(0.961,0.318,0.035);\n    vec3 offWhite = vec3(0.941,0.918,0.776);\n    \n    vec3 verGrad = mix(orange, blue, st.y);\n    vec3 horGrad = mix(offWhite, blue, st.x);\n    vec3 mixGrad = mix(verGrad, horGrad, sin(iTime));    \n  \n    \n    vec3 color = mixGrad - m_dist;\n    \n \n    fragColor = vec4(color * hexagon,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfsczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 115], [117, 117, 159, 159, 349], [352, 352, 409, 459, 1746]], "test": "ok"}
{"id": "Mflczn", "name": "spiralus materia", "author": "nayk", "description": "combination from glslssandbox spiral ", "tags": ["spiral", "rotate"], "likes": 2, "viewed": 51, "published": 3, "date": "1720724816", "time_retrieved": "2024-07-18T23:34:15.430338", "image_code": "uniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution.xy\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 p = 2.0*( gl_FragCoord.xy / resolution.xy )-1.0;\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n  p*=ma;\np.xy*=mat2(cos(iTime*1.),sin(iTime*1.),-sin(iTime*1.), cos(iTime*1.));\np.x *= resolution.x/resolution.y;\nvec3 col = vec3(0);\n\n\nfor (int i = 0; i < 100; i++) {\nfloat lt = 0.01;\nfloat a = float(i);\nvec2 b = vec2(1.5*sin(time+a),0.8*sin(time*0.77+a));\n       \nif (abs(p.x) < b.x && abs(p.y) < b.y) {\n       \nif (abs(p.x) > b.x-lt || abs(p.y) > b.y-lt )\ncol = vec3(1);\n}\n}\nfragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mflczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 182, 182, 798]], "test": "error"}
{"id": "lclczn", "name": "spiral way", "author": "nayk", "description": "original from glslsandbox and shadertoy", "tags": ["spiral", "rotating", "way"], "likes": 2, "viewed": 61, "published": 3, "date": "1720724674", "time_retrieved": "2024-07-18T23:34:16.175346", "image_code": "#define  time iTime\n#define resolution iResolution.xy\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 uv = fragCoord/iResolution.xy-0.5;\nvec2 pos = uv*0.5;\n    vec2 pos2 = uv*.02;\nfloat t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\nfloat si = sin(t3);\nfloat co = cos(t3);\nmat2 ma = mat2(co, si, -si, co);\n    pos*=ma;\nconst float pi = 85.14159;\nconst float n = 2.0;\n\n   \n \nconst float n2 = 16.0;\n\nfloat radius2 = length(pos2) *5.5 - 0.4;\nfloat t2 = atan(pos2.y, pos2.x);\n\nfloat color2 = 0.0;\n\nfor (float i = 9.0; i <= n2; i++){\ncolor2 += 0.012 / abs(0.2 * cos(\n3. * (t2+ i/n2 * +time *1.1)\n   ) + tan(dot(radius2,pi-tan(time*1.2)))\n);\n}\n   \nfloat radius = length(pos) * 2.0 - 0.4;\n    pos*=ma;\nfloat t = atan(pos.y, pos.x);\n\nfloat color = 0.025;\n\nfor (float i = 1.0; i <= n; i++){\ncolor += 0.051 / abs(1. * sin(\n4. * ((t) + i/n * time * .25)\n   ) - sqrt(ceil(radius))\n);\n}\n\nfragColor = vec4(vec3(1.5, 0.3, 1.15) * color, 8.);\n    fragColor+= vec4(vec3(.5, 0.5, 1.15) * color2, 9.);\n\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lclczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 112, 112, 1034]], "test": "error"}
{"id": "Mfsyzn", "name": "shining mandala", "author": "nayk", "description": "from glslsandbox", "tags": ["fractal", "stars", "cosmic"], "likes": 2, "viewed": 64, "published": 3, "date": "1720724554", "time_retrieved": "2024-07-18T23:34:16.923347", "image_code": "\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution.xy\nvec3 sim(vec3 p,float s);\nvec2 rot(vec2 p,float r);\nvec2 rotsim(vec2 p,float s);\n\n//nice stuff :)\nvec2 makeSymmetry(vec2 p){\n   vec2 ret=p;\n   ret=rotsim(ret,4.02002);\n   ret.x=abs(ret.x);\n   return ret;\n}\n\nfloat makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){\n   float xx=x+tan(t*fx)*sx;\n   float yy=y-tan(t*fy)*sy;\n   return 0.5/sqrt(abs(x*xx+yy*yy));\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random(vec2 pos){return fract(1.0*sin(pos.y+fract(100.0*sin(pos.x))));}\n\nfloat noise(vec2 pos) {\nvec2 i=floor(pos),f=fract(pos);\nfloat a=random(i+vec2(0.0,0.0)),b=random(i+vec2(1.0,0.0)),c=random(i+vec2(0.0,1.0)),d=random(i+vec2(1.0,1.0));vec2 u=f*f*(3.0-2.0*f);\nreturn mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n}\n\nfloat fbm(vec2 pos) {\nfloat v = 0.5;\nfloat a = 0.6;\nvec2 shift = vec2(100.0);\nmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.95), cos(0.5));\nfor (int i=0; i < 4; i++) {\nv += a * noise(pos);\npos = rot * pos * 2.0 + shift;\na *= 0.55;\n}\nreturn v;\n}\n\n\n//-----------------------\nfloat snow(vec2 uv,float scale)\n{\n\n\n    float w = smoothstep(3.,0., -uv.y *(scale / 10.));\n   \n    if(w < .1)return -0.;\n   \n    uv += time / scale / 2.4;\n    uv.y += time * 0./ scale;\n    uv.x += sin (uv.y + time*.05) / scale;\n    uv *= scale / 2.34;\n    vec2 s = floor(uv), f = fract(uv), p;\n    float k = 3., d;\n    p = .5 + .35 * sin(11.*fract(sin((s+p+scale) * mat2(7,3,6,5))*5.)) - f;\n    d = length(p);\n    k = min(d,k);\n    k = smoothstep(0., k, sin(f.x+f.y) * 0.02);\n        return k*w;\n}\n//_______________________________________________\n\n\n\n//util functions\nconst float PI=3.18052;\n\nvec3 sim(vec3 p,float s){\n   vec3 ret=p;\n   ret=p+s/2.2;\n   ret=fract(ret/s)*s-s/2.1;\n   return ret;\n}\n\nvec2 rot(vec2 p,float r){\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\nvec2 rotsim(vec2 p,float s){\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 p=(gl_FragCoord.xy/resolution.x)*2.0-vec2(1.0,resolution.y/resolution.x);\np.y=-p.y;\n   p=p*2.0;\n \n   p=makeSymmetry(p);\n   vec2 pos = (gl_FragCoord.xy / resolution);\n   \n\n    pos -= .4;\n    pos.x *= resolution.x / resolution.y;\n\nfloat f = fbm(pos * 1.0 * vec2(fbm(pos - (time / 8.0)), fbm(pos / 2.0 - (time / 8.0))));\nvec3 cx = vec3(3.5, 0.7, 0.4);\ncx = (f * .5) * cx;\n\nfloat a3 = atan(pos.x) * 0.10;\n\nvec3 finalColor=vec3(0);\n    float cc = 0.008;\n    cc+=snow(pos,-30.);\ncc+=snow(pos,-13.);\n    cc+=snow(rand(pos)*pos,72.);\n    cc+=snow(rand(pos)*pos,92.);\n    cc+=snow(pos,-78.);\n    finalColor=(vec3(cc));\n\n\n float col = abs( .24 / (-pos.y+0.05));\nvec3 dd = vec3(0.17, 0.39, 1.09);\n\nvec3 col2 = vec3(0.1, 1, 0);\nif (pos.y < 0.05) {\n col2 = dd;\n} else {\n    col *=5.;\n col2 = dd* vec3(0.2, 0.15, 7.);\n}\n\n   float x=p.x;\n   float y=p.y;\n   \n   float t=time*0.1618;\n\n   float a=\n       makePoint(x,y,3.3,2.9,0.3,0.3,t);\n   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,t);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,t);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,t);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,t);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,t);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,t);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,t);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,t);  \n   \n   float b=\n       makePoint(x,y,1.2,1.9,0.3,0.3,t);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,t);\n   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,t);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,t);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,t);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,t);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,t);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,t);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,t);\n\n   float c=\n       makePoint(x,y,3.7,0.3,0.3,0.3,t);\n   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,t);\n   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,t);\n   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,t);\n   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,t);\n   c=c+makePoint(x,y,0.3,0.3,0.4,0.4,t);\n   c=c+makePoint(x,y,1.4,0.8,0.4,0.5,t);\n   c=c+makePoint(x,y,0.2,0.6,0.6,0.3,t);\n   c=c+makePoint(x,y,1.3,0.5,0.5,0.4,t);\n   \n   vec3 d=vec3(a+b,b+c,c)/32.0;\n   \n   fragColor = vec4(d.x,d.y,d.z,1.0);\n  fragColor+=  col*vec4(col2*dd*finalColor*cx*col, 1.);\n   \n   }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfsyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 219, 245, 245, 326], [328, 328, 405, 405, 500], [503, 503, 523, 523, 593], [595, 595, 618, 618, 672], [674, 674, 697, 697, 920], [922, 922, 943, 943, 1163], [1166, 1192, 1225, 1225, 1689], [1785, 1785, 1810, 1810, 1887], [1889, 1889, 1914, 1914, 2008], [2010, 2010, 2038, 2038, 2149], [2151, 2151, 2207, 2207, 4373]], "test": "error"}
{"id": "msGXWc", "name": "Ray traced icosahedron", "author": "sbg97", "description": "Uses a bunch of math to ray trace a triangle. If it hits a triangle, it finds the corresponding texture coordinate and samples the texture.", "tags": ["raytracing", "icosahedron"], "likes": 2, "viewed": 73, "published": 3, "date": "1720718331", "time_retrieved": "2024-07-18T23:34:17.688301", "image_code": "// Icosahedron points\nvec3 p1 = vec3(1.,0.,0.);\nvec3 p2 = vec3(-1.,0.,0.);\nvec3 p3 = vec3(0.4472,0.8944,0.);\nvec3 p4 = vec3(-0.4472,-0.8944,0.);\nvec3 p5 = vec3(0.4472,0.2764,0.8507);\nvec3 p6 = vec3(0.4472,0.2764,-0.8507);\nvec3 p7 = vec3(-0.4472,-0.2764,0.8507);\nvec3 p8 = vec3(-0.4472,-0.2764,-0.8507);\nvec3 p9 = vec3(0.4472,-0.7236,0.5257);\nvec3 p10 = vec3(0.4472,-0.7236,-0.5257);\nvec3 p11 = vec3(-0.4472,0.7236,0.5257);\nvec3 p12 = vec3(-0.4472,0.7236,-0.5257);\n\nvec3 nohit = vec3(0.,0.,0.);\n\n// Returns 0,0,0 if no intersection, otherwise returns normal direction\nvec3 intersectsSphere( in vec3 sph_pos, in float sph_siz, in vec3 ray_pos, in vec3 ray_dir)\n{\n    // Adjust ray_pos so sph_pos is effectively 0 0 0\n    ray_pos -= sph_pos;\n    //float a = dot(ray_dir, ray_dir);\n    float b = 2.*dot(ray_pos, ray_dir);\n    float c = dot(ray_pos, ray_pos)-sph_siz*sph_siz;\n    float D=b*b-4./**a*/*c;\n    if(D<=0.){\n        return vec3(0.,0.,0.);\n    }\n    float t = (-b-sqrt(D))/(2./**a*/);\n    if(t<=0.){\n        return vec3(0.,0.,0.);\n    }\n    vec3 hit_pos = t*ray_dir + ray_pos;\n    vec3 normal_dir = vec3(2.*hit_pos.x, 2.*hit_pos.y, 2.*hit_pos.z);\n    return normalize(normal_dir);\n}\n\n// Returns 0,0,0 if no intersection, otherwise returns normal direction\nvec3 intersectsTriangle(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 ray_pos, in vec3 ray_dir)\n{\n    // calculate normal vector of the plane of the triangle\n    vec3 N = cross(p1-p0,p2-p0);\n    \n    // backface culling\n    if(dot(N,ray_dir)>=0.){\n        return nohit;\n    }\n    \n    vec4 L = vec4(N, -dot(N,p0));\n    \n    // see when the ray would intersect this plane\n    float t = -dot(L,vec4(ray_pos, 1.))/dot(L,vec4(ray_dir, 0.));\n    if(t<=0.){\n        return nohit;\n    }\n    \n    // intersection location\n    vec3 p = t*ray_dir + ray_pos;\n    vec3 R=p-p0;\n    vec3 Q1=p1-p0;\n    vec3 Q2=p2-p0;\n    \n    float Q1Q1 = dot(Q1,Q1);\n    float Q1Q2 = dot(Q1,Q2);\n    float Q2Q2 = dot(Q2,Q2);\n    float RQ1 = dot(R,Q1);\n    float RQ2 = dot(R,Q2);\n    \n    vec2 w1w2 = mat2(Q2Q2, -Q1Q2, -Q1Q2, Q1Q1)*vec2(RQ1,RQ2)/(Q1Q1*Q2Q2-Q1Q2*Q1Q2);\n    \n    float w1 = w1w2.x;\n    float w2 = w1w2.y;\n    float w0 = 1.-w1-w2;\n    \n    if(w1>0. && w2>0. && w0>0.){\n        return vec3(w0, w1, w2);\n    }\n    return nohit;\n    \n}\n\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 colorTheWorld(in vec3 start, in vec3 dir)\n{\n    if(intersectsSphere(vec3(0,0,0), 1., start, dir).x==0.){\n        return vec3(1.,0.,0.);\n    }\n    //return intersectsSphere(vec3(0,0,0), 1., start, dir);\n    vec2 uv0 = vec2(0.,0.);\n    vec2 uv1 = vec2(1.,0.);\n    vec2 uv2 = vec2(0.,1.);\n    \n    vec3 weights;\n    if((weights=intersectsTriangle(p7, p11, p2, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p2, p4, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p4, p9, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p9, p5, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p5, p11, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p12, p3, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p3, p1, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p1, p10, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p10, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p8, p12, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p11, p12, p2, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p11, p3, p12, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p5, p3, p11, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p1, p3, p5, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p9, p1, p5, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p9, p10, p1, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p9, p4, p10, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p10, p4, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p4, p2, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p2, p12, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else{\n        return vec3(1.,0.,0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xyPositionOfPixelInWindow = \n        ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    \n    vec3 eyePosition = vec3( 3.*sin(iTime), 0., 3.*cos(iTime));\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n    mat3 eyeTransformationMatrix = \n        calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. );\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( xyPositionOfPixelInWindow , 2. ) );\n\tvec3 color = colorTheWorld( eyePosition , rayComingOutOfEyeDirection );\n\tfragColor = vec4(color,1.0);\n    \n    \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 567, 660, 714, 1187], [1189, 1261, 1356, 1416, 2274], [2276, 2276, 2359, 2359, 2537], [2539, 2539, 2587, 2587, 6151], [6153, 6153, 6210, 6210, 6793]], "test": "error"}
{"id": "dt3yWX", "name": "Spheronoi III", "author": "domrally", "description": "Click & Drag!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["voronoi", "flat", "glitch", "cell", "tessellation"], "likes": 17, "viewed": 118, "published": 3, "date": "1720715011", "time_retrieved": "2024-07-18T23:34:18.435305", "image_code": "/*\nby Dom Mandy in 2024\n*/\n\n// rotation\nvec3 r(vec3 V, float a) {\n    V.xz = vec2(cos(a += atan(V.z, V.x)), sin(a)) * length(V.xz);\n    return V;\n}\n\nvoid mainImage(out vec4 M, vec2 C) {\n    // animation\n    M = iMouse;\n    float l, i, p,\n          n = 9.,\n          a = mix(iTime / 3., M.x / 2e2, sign(M.z));\n    vec3 P, X, N,\n         R = iResolution,\n         F = r(vec3(0, 0, 1), a),\n         E = r(vec3(1.1 * (C + C - R.xy) / R.y, -1), a),\n         L = r(normalize(vec3(1, 2, 3)), a);\n\n    // surface normals\n    for(; i < 256.;)\n        if (n > (p = dot(X -= F * dot(P *= sign(p = dot(P /= length(P = texture(iChannel0, vec2(iTime / 2e3, i++ / 256.)).rgb - .5), F)), X = P - E) / abs(p), X)))\n            n = p, N = P;\n\n    // lighting\n    l = pow(max(max(.9 * dot(L, N), .04), -dot(F, reflect(L, N))), inversesqrt(dot(F, N)));\n    M = sqrt(l + (l - l * l * l) * cos(atan(N.z, N.x) - vec4(0, 2, 4, 6)));\n}\n\n\n/*\nSEE ALSO\n\nhttps://en.wikipedia.org/wiki/Voronoi_diagram\nhttps://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n*/\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3yWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 40, 65, 65, 147], [149, 149, 185, 202, 910]], "test": "error"}
{"id": "XXVSzG", "name": "another regular polygon", "author": "jonasfrey", "description": "regular polygons", "tags": ["polygon"], "likes": 4, "viewed": 90, "published": 3, "date": "1720702995", "time_retrieved": "2024-07-18T23:34:19.184302", "image_code": "// signed distance to a n-star polygon with external angle en\nfloat f_n_sdist_rpolyg(in vec2 p, in float r, in int n )\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    vec2  acs = vec2(cos(an),sin(an));\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p.y += clamp( -p.y, 0.0, r*acs.y);\n    return length(p)*sign(p.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    o_trn*=2.;\n    float n_its = 33.;\n    \n    float n_tau = 6.2831;\n    vec4 o_col_min = vec4(0.);\n    vec4 o_col = vec4(0.);\n    float n_min = 1.;\n    float n_ang_nor = fract((atan(o_trn.y, o_trn.x)/n_tau));\n    for(float n_it_nor = .0; n_it_nor<1.;n_it_nor+=(1./n_its)){\n        \n        float n_radius = n_it_nor+(sin((iTime+n_it_nor*3.)*n_tau)*.5+.5)*(1./n_its/2.);\n        \n        \n        int n_lines = 5;\n        float n_rad = sin((iTime*.2+n_it_nor)*n_tau)*(1.-n_radius);\n        mat2 o_rot = mat2(-sin(n_rad), cos(n_rad), cos(n_rad), sin(n_rad));\n        vec2 o = o_trn * o_rot;\n        float n = f_n_sdist_rpolyg(\n            o, \n            n_radius,\n            n_lines\n        );\n        \n        n = abs(n);\n        n_min = min(n, n_min);\n        n = n/n_radius;\n        \n        n = pow(n, 1./n_its)*0.95;//*2.01;//*(1.+1./9.);\n        n = clamp(n, 0., 1.);\n        n = 1.-n;\n        //n = 1.-pow(abs(1.-n), 2.);\n        float n3 = (sin((iTime*.02+n_it_nor)*n_tau)*.5+.5);\n        o_col += vec4(n)*vec4(n3, 1.-n3, fract(.5+n3), 1.);\n        \n    }\n    \n    float n2 = pow(n_min, 1./4.);\n    fragColor = o_col*(1.-n2);\n    //fragColor = sqrt(fragColor);\n    //fragColor = vec4(n2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXVSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 120, 178, 481], [482, 482, 539, 589, 1855]], "test": "ok"}
{"id": "lcfyRr", "name": "Gothic Pentagramm", "author": "natas", "description": "a pentagramm shader", "tags": ["dark", "gothic", "pentagramm"], "likes": 2, "viewed": 59, "published": 3, "date": "1720696965", "time_retrieved": "2024-07-18T23:34:20.032036", "image_code": "// Shadertoy-Shader-Code\n\n// Hilfsfunktion zum Zeichnen einer Linie\nfloat line(vec2 p, vec2 a, vec2 b, float width) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - width;\n}\n\n// Hilfsfunktion zum Zeichnen des Pentagramms\nfloat pentagram(vec2 p, float size) {\n    float PI = 3.14159265359;\n    float angle = PI / 5.0;\n    float d = 1.0;\n    for (int i = 0; i < 5; i++) {\n        vec2 a = size * vec2(cos(angle * (2.0 * float(i) - 1.0)), sin(angle * (2.0 * float(i) - 1.0)));\n        vec2 b = size * vec2(cos(angle * (2.0 * float((i + 2) % 5) - 1.0)), sin(angle * (2.0 * float((i + 2) % 5) - 1.0)));\n        d = min(d, line(p, a, b, 0.02));\n    }\n    return d;\n}\n\n// Funktion zur Erstellung bunter Partikel\nvec3 particle(vec2 uv, vec2 pos, vec3 color, float timeOffset) {\n    float dist = length(uv - pos);\n    float alpha = smoothstep(0.05, 0.03, dist);\n    float pulse = 0.5 + 0.5 * sin((iTime + timeOffset) * 10.0);\n    return color * pulse * alpha;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Bildschirmkoordinaten\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Zeitvariable für Animationen\n    float t = iTime;\n\n    // Position und Größe des Pentagramms animieren\n    vec2 pos = vec2(sin(t * 0.5), cos(t * 0.5)) * 0.5;\n    float size = 0.5 + 0.1 * sin(t * 2.0);  // Vergrößerte Größe des Pentagramms\n\n    // Pentagramm auf dem Bildschirm zeichnen\n    float d = pentagram(uv - pos, size);\n\n    // Farben und Effekte\n    vec3 color = vec3(0.0);\n    if (d < 0.03) {  // Erhöhte Schwelle, um das Pentagramm deutlicher zu machen\n        color = mix(color, vec3(1.0, 1.0, 1.0), 1.0 - d / 0.03);  // Weißes Pentagramm\n    }\n\n    // Zufällige bunte Effekte hinzufügen\n    float noise = fract(sin(dot(uv * 100.0, vec2(12.9898, 78.233))) * 43758.5453);\n    if (noise > 0.99) {\n        color += vec3(0.5 + 0.5 * sin(t * 10.0), 0.5 + 0.5 * cos(t * 10.0), 0.5 + 0.5 * sin(t * 5.0));\n    }\n\n    // Hintergrundfarbe\n    vec3 bgColor = vec3(2.00, 2.00, 1.25);\n\n    // Partikel-Effekte hinzufügen\n    for (int i = 0; i < 5; i++) {\n        vec2 partPos = vec2(mod(iTime + float(i) * 0.4, 2.0) - 1.0, sin(iTime + float(i) * 1.0));\n        vec3 partColor = vec3(sin(float(i) * 2.0 + t), cos(float(i) * 1.5 + t), sin(float(i) * 3.0 + t));\n        color += particle(uv, partPos, partColor, float(i) * 0.5);\n    }\n\n    // Finale Farbgebung\n    fragColor = vec4(mix(bgColor, color, smoothstep(0.02, 0.03, d)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 68, 117, 117, 259], [261, 307, 344, 344, 746], [748, 791, 855, 855, 1038], [1040, 1040, 1095, 1124, 2587]], "test": "ok"}
{"id": "McfyRn", "name": "particle in square", "author": "nayk", "description": "from  https://glslsandbox.com/e#82116.0 https://glslsandbox.com/e#94360.0 and other", "tags": ["amaterasu"], "likes": 2, "viewed": 48, "published": 3, "date": "1720690090", "time_retrieved": "2024-07-18T23:34:20.812948", "image_code": "\n\n#define rotation 1\n\n\nuniform vec2 mouse;\n\n#define resolution iResolution.xy\n#define time iTime\n\n// stuff\n#define rot( a )\tmat2( cos(a), -sin(a), sin(a), cos(a) )\n#define res resolution\n#define nsin( a )       sin( a )*.5+.5\n\nfloat c = 0.0;\n\nfloat circle( vec2 p, float r )\n{\n\treturn step( length( p ), r);\n}\n\nvec2 translate(vec2 pos, vec2 translate) {\n\treturn pos + vec2(-translate.x, -translate.y);\n}\n\nmat2 rotate2D(float a) {\n\tfloat co = cos(a), si = sin(a);\n\treturn mat2(co, -si, si, co);\n}\n\nfloat sdBox(in vec2 p, in vec2 size) {\n\tp = abs(p) - size;\n\treturn length(max(p, 0.0)) + min(8.0, max(p.x, p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p;\n     \n \n    p = ( 2.*gl_FragCoord.xy - res )/min( res.x, res.y );\n\n   \n    p *= rot( time*5. );\n  \nhighp vec2 size = vec2(resolution.x, resolution.y);\n\t\n\tvec2 uv = (2.0 * gl_FragCoord.xy - size) / size.x;\n\tuv = translate(uv, vec2(0.0));\n\tuv *= rotate2D(1.1*time);\n\t\n\thighp vec3 color = vec3(0.0);\n\t\n\tfloat box = sdBox(uv, vec2(0.3));\n\t\n\tcolor = mix(color, vec3(1.0), 1.0-smoothstep(0.0,0.2, abs(box)));\n\tcolor.r *= 1.01;\n\t\n\tcolor = pow(color,vec3(32.0));\n    float dist = mod(sqrt( floor( time*30./52. ) ),6.0);\t\n  \n    float l = sqrt( 3. )/dist;\n    float s =     ( 1. )/dist;\n    float n =     ( 2. )/dist;\n\n    // well i guess here comes the hardcoded stuff\n    c = circle(  (p), 1.0 );\n    \n    float size2 = 0.05;\n\tfloat dist2 = 0.100;\n\tfloat ang = 0.0;\n\tvec2 pos = vec2(0.0,0.0);\n\tvec3 color2 = vec3(0.2);;\n\t\n\tfor(int i=0; i<50; i++){\n\t\tfloat r = 0.3;\n\t\tang += 3.14 / (float(50)*0.5)+(time/60.0);\n\t\tpos = vec2(cos(ang),sin(ang))*r*sin(time+ang/.3);\t\t\t\t  \n\t\tdist2 += size2 / distance(pos,uv);\n\t\tvec3 c2 = vec3(0.03, 0.05, 0.1);\n\t\tcolor2 = c2*dist2;\n\t}\t\n    p.x -= l;\n    p.y -= s;\n    c += circle(  (p), 1.0 );\n    p.x += l;\n    p.y -= s;\n    c += circle(  (p), 1.0 );\n    p.x += l;\n    p.y += s;\n    c += circle(  (p), 1.0 );\n    p.x -= 0.;\n    p.y += n;\n    c += circle( (p), 1.0 );\n    p.x -= l;\n    p.y += s;\n    c += circle(  (p), 1.0 );\n    p.x -= l;\n    p.y -= s;\n    c += circle(  (p), 1.0 );\n\t\n    // white + white = black\n    c = mod( ceil(c)+color.x, 2.0 );\n    \n    fragColor = vec4(c*color2.y, c*color2.z, c*color2.x, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McfyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 276, 276, 309], [311, 311, 353, 353, 403], [405, 405, 429, 429, 495], [497, 497, 535, 535, 612]], "test": "error"}
{"id": "4ffczr", "name": "star in space 4", "author": "nayk", "description": "originals  https://glslsandbox.com/e#80106.0 https://glslsandbox.com/e#80011.0 https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/mtyGWy", "tags": ["star", "space", "cosmos", "cineshader"], "likes": 10, "viewed": 172, "published": 3, "date": "1720688452", "time_retrieved": "2024-07-18T23:34:21.681626", "image_code": "\n#define time iTime\n#define resolution iResolution.xy\n\n\nuniform vec2 mouse;\n\n\nfloat snow(vec2 uv,float scale)\n{\n\n\tfloat _t = time*0.3;\n\t uv.x+=_t/scale; \n\tuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=40.,d;\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.003);\n    \treturn k;\n}\nfloat makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){\n   float xx=x+sin(t*fx)*sx;\n   float yy=y+cos(t*fy)*sy;\n   return 1.0/sqrt(xx*xx+yy*yy);\n}\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y); \n\tfloat dd = 1.0-length(uv);\nvec2 pos = uv;\nvec2 uv2 = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tconst float pi = 3.14159;\n\tconst float n = 16.0;\n\t \n    vec2 uv0 = uv2;\n    vec3 finalColor2 = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv2 = fract(uv2 * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor2 += col * d;\n    }\n\tfloat radius = length(pos) * 2.0 - 0.4;\n\tfloat t = atan(pos.y, pos.x);\n\t\n\tfloat color = 0.0;\n\tfloat color2 = 0.0;\n\tfor (float i = 9.0; i <= n; i++){\n\t\tcolor += 0.002 / abs(0.2 * sin(\n\t\t\t3. * (t + i/n * time * 2.1)\n\t\t    ) - radius\n\t\t);\n        \n        \n\t}\n    for (float i = 9.0; i <= n; i++){\n\t\tcolor2 += 0.005 / abs(0.2 * sin(\n\t\t\t5. * (t + i/n * time * 0.1)\n\t\t    ) - radius*0.5\n\t\t);\n        \n        \n\t}\n    \n    \n\tvec2 p=(gl_FragCoord.xy/resolution.x)*2.0-vec2(1.0,resolution.y/resolution.x);\n     p=p*2.0;\n   \n   float x=p.x;\n   float y=p.y;\n\n   float a=\n       makePoint(x,y,3.3,2.9,0.3,0.3,time);\n   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,time);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,time);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,time);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,time);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,time);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,time);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,time);   \n   \n   float b=\n       makePoint(x,y,1.2,1.9,0.3,0.3,time);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);\n   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);\n\n   float c=\n       makePoint(x,y,3.7,0.3,0.3,0.3,time);\n   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);\n   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);\n   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);\n   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);\n   c=c+makePoint(x,y,0.3,0.3,0.4,0.4,time);\n   c=c+makePoint(x,y,1.4,0.8,0.4,0.5,time);\n   c=c+makePoint(x,y,0.2,0.6,0.6,0.3,time);\n   c=c+makePoint(x,y,1.3,0.5,0.5,0.4,time);\n   vec3 d=vec3(a,b,c)/32.0;\n\tuv.y += sin(uv.x*1.4)*0.2;\n\tuv.x *= 0.79;\n\tfloat c2=snow(uv,30.)*.3;\n\tc2+=snow(uv,20.)*.5;\n\tc2+=snow(uv,15.)*.8;\n\tc2+=snow(uv,10.);\n\tc2+=snow(uv,8.);\n\tc2+=snow(uv,6.);\n\tc2+=snow(uv,5.);\n\tc2*=0.2/dd;\n\tvec3 finalColor=(vec3(0.0,0.8,5.9))*c2*color*3000.0+finalColor2;\n\tfragColor = vec4(finalColor*d*color2,1);\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor+= vec4(happy_star(uv, anim) * vec3(0.35,0.2,1.15)*1.75*finalColor2, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ffczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 111, 111, 353], [354, 354, 431, 431, 522], [524, 524, 549, 549, 733], [734, 734, 773, 773, 919], [921, 921, 977, 977, 3923]], "test": "error"}
{"id": "4fXczr", "name": "hexagon map", "author": "nayk", "description": "origianls from  https://www.shadertoy.com/view/lXVSWt https://www.shadertoy.com/view/X3KXWt", "tags": ["color", "hexagon", "cineshader"], "likes": 2, "viewed": 59, "published": 3, "date": "1720687459", "time_retrieved": "2024-07-18T23:34:22.469520", "image_code": "float sdHexagon( in vec2 p, in float r ){\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p+sin(iTime)/10.)*sign(p.y);\n}\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 uv = 10. * (2. * I - iResolution.xy) / iResolution.y;\n    \n    float sd = sdHexagon(uv,10.);\n    float val = cos(length(uv) - 4. * iTime + cos(2. * iTime*0.1) * (iTime*0.1 + 3. * atan(uv.y, uv.x)));\n    val = abs(val - 1.1);\n    vec3 col =  ceil(val-sd) * clamp(abs(mod((0.25 * iTime + 0.318309886184 * atan(uv.y,uv.x))*10.0+vec3(1.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fXczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 246], [247, 247, 286, 286, 690]], "test": "ok"}
{"id": "MXtXDf", "name": "Mouse Input (API Test)", "author": "brisingre", "description": "Red Dot is XY, updated every frame if LMB is down.\nGreen dot is ZW, updated only on the first frame LMB is clicked.\nBlue rectangles represent the signs of each channel. \n  XY+ always. \n  Z+ if LMB held. \n  W+ if LMB clicked this frame. ", "tags": ["apitesting"], "likes": 1, "viewed": 71, "published": 3, "date": "1720676089", "time_retrieved": "2024-07-18T23:34:23.302294", "image_code": "// Fork of \"Resolution (API Test)\" by brisingre. https://shadertoy.com/view/XXcXW7\n// 2024-06-30 06:32:49\n\n// Fork of \"Time (API Test)\" by brisingre. https://shadertoy.com/view/4XcXWM\n// 2024-06-22 22:38:59\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    \n    vec2 point1 = iMouse.xy;\n    vec2 point2 = abs(iMouse.zw);\n    \n    \n    float dist1 = 1.0 - distance(point1, uv)/256.0;\n    float dist2 = 1.0 - distance(point2, uv)/256.0;\n    float state = 0.0;\n    \n    if(uv.y < 100.0)\n    {\n    \n        if (uv.x < 50.0)\n        {\n            if(iMouse.x < 0.0)\n                state = 1.0;\n        }\n        else if (uv.x < 100.0)\n        {\n            if(iMouse.y < 0.0)\n                state = 1.0;\n        }\n        else if (uv.x < 150.0)\n        {\n            if(iMouse.z < 0.0)\n                state = 1.0;\n        }\n        else if (uv.x < 200.0)\n        {\n            if(iMouse.w < 0.0)\n                state = 1.0;\n        }\n    }\n    fragColor = vec4(dist1, dist2, state, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MXtXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 265, 265, 1026]], "test": "ok"}
{"id": "MXVXWd", "name": "introToRayMarching", "author": "JOEMANFLAME", "description": "Credit - kishimisu on YouTube for the tutorial and for introducing me into this beautiful, mystifying, entrancing rabbit hole that I may never come out from", "tags": ["raymarching", "fractal", "sdf", "etc", "custompalette"], "likes": 2, "viewed": 47, "published": 3, "date": "1720662233", "time_retrieved": "2024-07-18T23:34:24.139057", "image_code": "//--------------------------------------------------------------------------------------------------------------------\n// Geometry\n\n// Functions\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle) {\n    // Rodrigues' rotation formula\n    return mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n    \n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nfloat sUnion (float d1, float d2, float k) {\n        float h = clamp(0.5 + 0.5 *(d2-d1)/k, 0.0, 1.0);\n        return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nvec3 palette( in float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5); \n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(1.000, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.577);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n// Geometry SDFs\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - 1.0;             // SDF of a sphere of radius 1\n}\n\nfloat sdBox (vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);  // SDF of a box with xyz = b\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// Mapping\nfloat map(vec3 p) {\n    \n    p.z += iTime*.6;\n    \n    // Space Repetition\n    p.xy = fract(p.xy) - 0.5;     // Spacing = 1 ( -0.5 translates vec3 to center of unit square )\n    p.z = mod(p.z, 0.25) - 0.125;  // Spacing = 0.25\n    \n    float box = sdOctahedron(p, 0.15); // SDF of box\n    \n    // smooth union between the objeccts\n    return box;\n}\n\n//--------------------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;  // transform px coordinates into uv-space\n    vec2 m = ( iMouse.xy * 2.0 - iResolution.xy) / iResolution.y; // px coordinates into uv-space for mouse\n    \n    // Initialization\n    vec3 r0 = vec3(0, 0, -3.0); // ray origin\n    vec3 rd = normalize(vec3(uv*0.7, 1));  // ray direction NOTE: leverage use of UV coordinates being the xy axes of screen,\n                                       // can plug them into x and y of vec3, meaning each pixel has its own ray-Dir\n\n    vec3 col = vec3(0);                // final pixel color\n    \n    float t = 0.0;                     // Distance Travelled                                \n    int iter = 80;                     // ray-march iterations to perform (per pixel)\n    \n    //Vertical camera rotation (Goes first)\n    //r0.yz *= rot2D(-m.y);\n    //rd.yz *= rot2D(-m.y);\n    \n    //Horizontal camera rotation\n    //r0.xz *= rot2D(-m.x);\n    //rd.xz *= rot2D(-m.x);\n    \n    if (iMouse.z < 0.) m = vec2(cos(iTime*0.2), sin(iTime*0.2));\n    \n    // Raymarching\n    int i;\n    for (i = 0; i < iter; i++) {\n        vec3 p = r0 + rd * t;              // Position along the ray w.r.t. the rays origin\n        \n        p.xy *= rot2D(t*0.2 * m.x);    // rotate ray based on distance travelled\n        \n        p.y += sin(t*(m.y+1.0)*0.5)*0.35;  // add sin component w frequency of t (distance travelled)\n        \n        \n        float d = map(p);              // current distance to the scene\n\n        t += d;                        // \"march\" the ray\n        \n        // col = vec3(i) / float(iter);   // output color based on number of iterations performed\n        \n        if ( d < 0.001 || t > 100.0) break;       // stop ray-marching if sufficiently close to geometry or stop ray-marching if ray passes all geometry\n    }\n    \n    \n    // Coloring\n    col = palette(t*0.05 + float(i)*0.005);            // color based on distance the ray has travelled\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MXVXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 145, 170, 170, 254], [256, 256, 300, 335, 422], [424, 424, 465, 465, 543], [545, 545, 589, 589, 693], [695, 695, 723, 723, 922], [925, 942, 975, 975, 1048], [1050, 1050, 1080, 1080, 1201], [1203, 1203, 1241, 1241, 1294], [1296, 1307, 1326, 1326, 1655], [1657, 1776, 1833, 1833, 3834]], "test": "ok"}
{"id": "l3VXWd", "name": "shadows culegamer", "author": "CuleGamer", "description": "wow shadows are ez\nmove mouse", "tags": ["2d", "raymarching"], "likes": 3, "viewed": 83, "published": 3, "date": "1720661582", "time_retrieved": "2024-07-18T23:34:24.957868", "image_code": "float sdf(vec2 uv)\n{\n    return min(length(uv) - 1., abs(distance(uv, vec2(2.)) - 5.) - 0.25);\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = 4. * (2. * I - R) / R.y;\n    vec2 uvMouse = 4. * (2. * iMouse.xy - R) / R.y;\n    vec2 rayDir = normalize(uvMouse - uv);\n    vec2 rayPos = uv;\n    vec3 col;\n    if(sdf(uv) < 0.)\n    {\n        col = vec3(1.);\n    }\n    else\n    {\n        for(uint i; i < 16u; i++)\n        {\n            rayPos += rayDir * sdf(rayPos);\n        }\n        col = vec3(0.5 - step(1. - dot(uvMouse - rayPos, rayDir), 1.));\n    }\n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/l3VXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 96], [98, 98, 137, 137, 609]], "test": "ok"}
{"id": "lfjSRh", "name": "Floating Eye Monitor", "author": "TheBen27", "description": "This desktop monitoring software guarantees productivity at an affordable cost. No observable side effects. Designed for workplaces, call centers, computer labs. Limit continuous exposure 3hrs/day.", "tags": ["voronoi", "dither", "creepy"], "likes": 17, "viewed": 141, "published": 3, "date": "1720652396", "time_retrieved": "2024-07-18T23:34:25.823554", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord / iResolution.xy;\n    float zoomFactor = mix(1.35, 1.0, smoothstep(0.0, 1.0, distance(uv, vec2(0.5))));\n    uv -= 0.5;\n    uv /= zoomFactor;\n    uv += 0.5;\n    float c = texture(iChannel0, uv).r;\n    \n    vec3 blackColor = vec3(0.1, 0.125, 0.1);\n    vec3 whiteColor = vec3(0.98, 1.0, 0.9);\n    vec3 color = mix(blackColor, whiteColor, max(0.0, c));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sminCubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec2 noise(vec2 p) {\n    vec2 cc = floor(p);\n    vec2 cm = p - cc;\n    vec2 tl = hash22(cc);\n    vec2 tr = hash22(cc + vec2(1.0, 0.0));\n    vec2 bl = hash22(cc + vec2(0.0, 1.0));\n    vec2 br = hash22(cc + vec2(1.0, 1.0));\n    vec2 t = mix(tl, tr, cm.x);\n    vec2 b = mix(bl, br, cm.x);\n    return mix(t, b, cm.y);\n}\n\nvec2 noise_oct(vec2 p) {\n    vec2 value = vec2(0.0);\n    float total = 0.0;\n    float a = 1.0;\n    float f = 1.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        p *= rot(24.0);\n        value += noise(p * f) * a;\n        total += a;\n        a /= 2.0;\n        f *= 2.0;\n    }\n    return value / total;\n}\n\nfloat fmod(float x, float m) {\n    return x - m * floor(x / m);\n}\n\nfloat angleVoronoi(vec2 uv, vec2 scale, float smoothness, int octave, float twisting) {\n    float theta = 0.5 + atan(uv.y, uv.x) / (2.0 * acos(-1.0));\n    float phi = length(uv);\n    float speed = float(1 + octave) * 0.015;\n    theta += twisting * (0.25 * phi - speed * iTime);\n    vec2 auv = vec2(theta, phi);\n    \n    vec2 pos = auv * scale;\n    vec2 innerPos = mod(pos, 1.0);\n    vec2 index = floor(pos);\n \n    float minDistance = 1e3;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(float(x), float(y));\n            vec2 cellPos = offset + hash22(\n                vec2(\n                    fmod(index.x + offset.x, scale.x),\n                    index.y + offset.y\n                )\n            );\n            float cellDistance = distance(innerPos, cellPos);\n            minDistance = sminCubic(minDistance, cellDistance, smoothness);\n        }\n    }\n    return minDistance;\n}\n\nfloat dither_by(float value, float dither) {\n    return round(dither - 0.5 + value);\n}\n\nfloat vortex(vec2 uv, float dither) {\n    // Waviness\n    uv.x += 0.04 * sin(iTime + 4.0 * uv.y);\n    \n    float brightness;\n    float total = 0.0;\n    float a = 1.0;\n    vec2 f = vec2(6.0, 3.0);\n    int octaves = 6;\n    for (int i = 0; i < octaves; i++) {\n        brightness += a * angleVoronoi(uv, f, length(uv) * 0.5, i, 1.0);\n        total += a;\n        a *= 0.5;\n        f *= 2.0;\n    }\n    \n    brightness /= total;\n    \n    // Cheat by removing the center\n    float center = smoothstep(0.0, 0.2, length(uv));\n    brightness = mix(0.0, brightness, center);\n    \n    // Postersize and dither\n    brightness *= brightness;\n    brightness = max(0.0, brightness - 0.025);\n    brightness = dither_by(brightness, dither);\n    return brightness;\n}\n\nvec2 eye(vec2 uv, float dither) {\n    float size = 0.3;\n    float thick = 0.03;\n    // Float eye up and down\n    uv.y -= 0.02 * round(sin(iTime * 0.5) * 5.0) / 5.0;\n    float len = length(uv);\n    float alpha = 1.0 - smoothstep(size - thick, size + thick, len);\n    // Base\n    float value = 1.0;\n    vec2 idisp = 0.02 * (noise_oct(vec2(iTime)) - 0.5);\n    vec2 iuv = uv - idisp;\n    float ilen = length(iuv);\n    // Iris\n    float a = angleVoronoi(iuv, vec2(32.0, 3.0), 0.1, 0, 0.0);\n    value *= a;\n    // Black pupil\n    value *= smoothstep(0.1, 0.15, ilen);\n    // Black rim around the iris\n    value *= smoothstep(0.0, 0.025, abs(ilen - 0.2));\n    // Sclera\n    value = max(value, smoothstep(0.19, 0.21, ilen));\n    // White highlight\n    float cl = distance(uv, vec2(0.03, 0.07));\n    value = max(value, step(cl, 0.005));\n    \n    value = dither_by(value, dither);\n    alpha = dither_by(alpha, dither);\n    \n    return vec2(value, alpha);\n}\n\nfloat rift(vec2 uv, float dither) {\n    // Base shape\n    float amt = pow(1.0 - abs(uv.y), 1.5);\n    // Distortion\n    amt *= noise_oct(vec2(1.5 * uv.y + iTime, sign(uv.x))).x;\n    // Blink\n    float blinkTiming = 2.0 * max(0.0, mod(iTime, 5.0) - 4.5);\n    float blinkAmt = 0.5 + 0.5 * cos(blinkTiming * 2.0 * acos(-1.0));\n    amt *= blinkAmt * blinkAmt;\n    // Sharpen and dither\n    float value = smoothstep(amt * 0.4, amt, abs(uv.x));\n    return dither_by(value, dither);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float targetHeight = 720.0;\n    float downscale = max(1.0, floor(iResolution.y / targetHeight));\n    \n    vec2 uv = floor(fragCoord / downscale) / iResolution.xy * downscale;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dither = texelFetch(iChannel0, ivec2(mod(fragCoord / downscale, 8.0)), 0).r;\n    float bg_vortex = vortex(uv, dither);\n    vec2 fg_eye = eye(uv, dither);\n    float bg_rift = rift(uv, dither);\n    \n    float final = bg_vortex;\n    \n    final *= bg_rift;\n    final = mix(final, fg_eye.x, (1.0 - bg_rift) * fg_eye.y);\n    \n    // Output to screen\n    fragColor = vec4(vec3(final),1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfjSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 474]], "test": "error"}
{"id": "lXVSWt", "name": "cool pattern culegamer", "author": "CuleGamer", "description": "This is probably the worst code I have ever written; for some reason I just don't feel like making it better.\nI would love to see your golfs(is that the plural of golf?) of this.", "tags": ["worstcodeever"], "likes": 2, "viewed": 66, "published": 3, "date": "1720650273", "time_retrieved": "2024-07-18T23:34:26.667298", "image_code": "void mainImage(out vec4 O, in vec2 I)\n{\n    vec2 uv = 10. * (2. * I - iResolution.xy) / iResolution.y;\n    float val = cos(length(uv) - 4. * iTime + cos(2. * iTime) * cos(iTime + 3. * atan(uv.y, uv.x)));\n    val = abs(val - 0.5);\n    vec3 col = val * clamp(abs(mod((0.25 * iTime + 0.318309886184 * atan(uv.y,uv.x))*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lXVSWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 388]], "test": "ok"}
{"id": "4XVSWd", "name": "test_static_rng", "author": "tetrismegistus", "description": "a test of rng to make static on a per pixel basis", "tags": ["learning"], "likes": 2, "viewed": 71, "published": 3, "date": "1720642611", "time_retrieved": "2024-07-18T23:34:27.507053", "image_code": "#define hash_f_s(s)  ( float( hashi(uint(s)) ) / float( 0xffffffffU ) )\n#define hash_f()  ( float( seed = hashi(seed) ) / float( 0xffffffffU ) )\n#define hash_v2()  vec2(hash_f(),hash_f())\n#define hash_v3()  vec3(hash_f(),hash_f(),hash_f())\n#define hash_v4()  vec3(hash_f(),hash_f(),hash_f(),hash_f())\n\nuint seed;\nuint hashi(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;            \n    ivec2 i_coords = ivec2(fragCoord);    \n    float timeFractional = fract(iTime);\n    float timeIntegral = floor(iTime);        \n    int id = i_coords.x + i_coords.y * int(iResolution.x);\n    seed = 1235125u + uint(id) + uint(timeIntegral * 1000.0) + uint(timeFractional * 1000000.0);   \n    fragColor = vec4(vec3(hash_f()),  1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4XVSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 333, 333, 447], [449, 449, 506, 506, 925]], "test": "ok"}
