{"id": "XXGSRK", "name": "Shifting Spiral Doodle", "author": "TekF", "description": "I didn't know what I wanted to make so I just started messing with some integer rotation maths to get janky weird patterns.", "tags": ["doodle"], "likes": 0, "viewed": 12, "published": 3, "date": "1720134535", "time_retrieved": "2024-07-05T01:42:19.994367", "image_code": "void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    ivec2 ir = ivec2(iResolution.xy);\n\n    ivec2 ir2 = (ir * (1 + ((ivec2(50728129,77557187)*int(floor(iTime))) & 3))) / 6;\n\n    uv -= ir2;\n    uv = (uv*1002+uv.yx*ivec2(-1,1)*5)/1000;\n    uv += ir2;\n    fragColour = texelFetch(iChannel0,uv,0);\n    if ( min(uv.x,uv.y) < 0 || max(uv.x-ir.x,uv.y-ir.y) >= 0 )\n        fragColour = vec4(sin(vec3(7,8,9.7)*iTime),0);\n    if ( iFrame == 0 ) fragColour = vec4(vec3((uv.y&32)/32),1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXGSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 119]], "test": "ok"}
{"id": "MXVXRG", "name": "Falling Quads", "author": "BigETI", "description": "Some quads falling...", "tags": ["colors"], "likes": 0, "viewed": 4, "published": 3, "date": "1720133513", "time_retrieved": "2024-07-05T01:42:20.866047", "image_code": "//#define SCREENSHOT_MODE\n\nstruct Cell\n{\n    vec4 color;\n    float movementSpeedMultiplier;\n};\n\nconst Cell cells[] =\n    Cell[]\n    (\n        Cell(vec4(0.0, 0.0, 1.5, 1.0), 0.3),\n        Cell(vec4(0.0, 1.5, 0.0, 1.0), 0.4),\n        Cell(vec4(0.0, 0.0, 1.5, 1.0), 0.2),\n        Cell(vec4(0.0, 1.5, 0.0, 1.0), 0.5),\n        Cell(vec4(0.0, 0.0, 1.5, 1.0), 0.1)\n    );\n\nconst float startingHue = 1.0 - 0.0625;\n\nconst float minimalGridAxisCellCount = 5.0;\n\nconst float cellGlowSize = 0.0625;\n\nconst float cellGlowBoost = 1.5;\n\nconst float cellHueOffset = 0.05;\n\nconst vec3 topSkyColor = vec3(0.0, 0.0, 0.75);\n\nconst vec3 bottomSkyColor = vec3(0.0, 0.0, 0.25);\n\nconst float loopTimeInSeconds = 10.0;\n\nconst float hueShiftTimeInSeconds = 100.0;\n\nconst float e = 0.577215664901532860606512090082402431042159335;\n\n#if defined SCREENSHOT_MODE\nconst float screenshotTime = e * 2.0;\n#endif\n\nvec4 AlphaBlendColors(const vec4 baseColor, const vec4 appendColor)\n{\n    vec3 color = mix(baseColor.rgb, appendColor.rgb, appendColor.a);\n    return vec4(color.x, color.y, color.z, baseColor.a + ((1.0 - baseColor.a) * appendColor.a));\n}\n\nvec3 GetHSVFromRGB(vec3 rgb)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 GetRGBFromHSV(vec3 hsv)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n    return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);\n}\n\nvec3 GetNormalizedRGB(vec3 rgb)\n{\n    vec3 hsv = GetHSVFromRGB(rgb);\n    return (hsv.z > 1.0) ? GetRGBFromHSV(vec3(hsv.x, hsv.y / (hsv.z * hsv.z), 1.0)) : rgb;\n}\n\nvec4 DrawCell(const vec2 uv, vec4 emissiveColor, float glowSize, float glowBoost)\n{\n    vec4 ret;\n    float left = uv.y * 0.25;\n    float right = 0.75 + (uv.y * 0.25);\n    if\n    (\n        (uv.x >= (left - glowSize)) &&\n        (uv.x <= (right + glowSize)) &&\n        (uv.y >= -glowSize) &&\n        (uv.y <= 1.0)\n    )\n    {\n        float intensity =\n            (\n                (uv.x < left) ?\n                    (1.0 - ((left - uv.x) / glowSize)) :\n                    (\n                        (uv.x > right) ?\n                            (1.0 - ((uv.x - right) / glowSize)) :\n                            1.0\n                    )\n            ) *\n            (\n                (uv.y < 0.0) ?\n                    (1.0 - (-uv.y / glowSize)) :\n                    (\n                        (uv.x < left) ?\n                            1.0 :\n                            (\n                                (uv.x > right) ?\n                                    1.0 :\n                                    (uv.y / glowBoost)\n                            )\n                    )\n            ) * glowBoost;\n        vec3 color = GetNormalizedRGB(emissiveColor.rgb * emissiveColor.a * intensity);\n        ret.rgba = vec4(color.r, color.g, color.b, intensity * emissiveColor.a * (1.0 - uv.y));\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n#if defined SCREENSHOT_MODE\n    const float hue = startingHue;\n#else\n    float hue = startingHue + (iTime / hueShiftTimeInSeconds);\n#endif\n    vec2 uv = (fragmentCoordinates.xy - (iResolution.xy * 0.5)) / ((iResolution.x > iResolution.y) ? iResolution.y : iResolution.x);\n    vec3 sky_hsv = GetHSVFromRGB(mix(bottomSkyColor, topSkyColor, uv.y));\n    vec4 sky_color = vec4(GetRGBFromHSV(vec3(sky_hsv.x + hue, sky_hsv.y, sky_hsv.z)), 1.0);\n    vec4 color = vec4(clamp(sky_color.r, 0.0, 1.0), clamp(sky_color.g, 0.0, 1.0), clamp(sky_color.b, 0.0, 1.0), 1.0);\n#if defined SCREENSHOT_MODE\n    float y_movement = mod(screenshotTime, loopTimeInSeconds);\n#else\n    float y_movement = mod(iTime * 0.5, loopTimeInSeconds);\n#endif\n    float x_movement = y_movement * 0.25;\n    for (int cell_index = 0, x; cell_index < cells.length(); cell_index++)\n    {\n        Cell cell = cells[cell_index];\n        for (x = 0; x < 6; x++)\n        {\n            vec3 cell_hsv = GetHSVFromRGB(cell.color.rgb);\n            vec4 cell_color = vec4(GetRGBFromHSV(vec3(cell_hsv.x + hue + cellHueOffset, cell_hsv.y, cell_hsv.z)), cell.color.a);\n            color = AlphaBlendColors(color, DrawCell(vec2((uv.x + x_movement * cell.movementSpeedMultiplier) * minimalGridAxisCellCount + (4.0 - float(cell_index) * 2.0) + 0.75 * 0.5 - (minimalGridAxisCellCount * 0.25) * float(x), (uv.y + y_movement * cell.movementSpeedMultiplier) * minimalGridAxisCellCount + (-1.5 + float(cell_index)) - minimalGridAxisCellCount * float(x)), cell_color, cellGlowSize, cellGlowBoost));\n        }\n    }\n    fragmentColor = vec4(GetNormalizedRGB(color.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MXVXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 879, 948, 948, 1116], [1118, 1118, 1148, 1148, 1493], [1495, 1495, 1525, 1525, 1700], [1702, 1702, 1735, 1735, 1863], [1865, 1865, 1948, 1948, 3170], [3172, 3172, 3241, 3241, 4852]], "test": "error"}
{"id": "M3VXzy", "name": "(Re)animated", "author": "misol101", "description": "A number of non-moving shaders (4 out of 5 by shadertoyjiang) that I was curious to see with some simple animation.\n\nSee code for credits and links.\n", "tags": ["fractal", "flower", "animated", "collection", "reanimated"], "likes": 0, "viewed": 9, "published": 3, "date": "1720133180", "time_retrieved": "2024-07-05T01:42:21.637492", "image_code": "/* A number of static shaders (4 out of 5 by shadertoyjiang) that I was curious to see with some simple animation.\n\n1. Newton Flower 4 by shadertoyjiang (erased?)\n2. Third flower by shadertoyjiang (https://www.shadertoy.com/view/cd2fDG)\n3. Mandel by shadertoyjiang (erased?)\n4. Second flower by shadertoyjiang (https://www.shadertoy.com/view/DdSfRK)\n5. BC: Box Pattern by BackwardsCap (https://www.shadertoy.com/view/dtyczD)\n\n*/\n\n#define TIME_PER_FX 4\n\n// Newton Flower 4 by shadertoyjiang (erased?)\nvoid mainImage1( out vec4 O, vec2 u )\n{\n\tvec2 g,q,R=iResolution.xy,\n\tv=24.*(u+u-R)/R.y,h;//=v;\n\n\tfloat a,r,s,i;  //,p=5., l=1.;\n\n\tfor(;i++<10.   ;)\n\n\t\ta=atan(v.y, v.x)+.618,\n\n\t\tr=length(v)*.7,      //(p-1.5   )/p,\n\t\t\n        s=.2/r/r/r/r,     //s=l/(p*pow(r, p-l)),\t\t\n\n\t\tg=q,q=v, \n\n\t\tv=vec2(r*cos(a+sin(iTime)*0.25)-s*cos(-4.*a),   // -4.=1.-p\n\n\t\t       r*sin(a+cos(iTime*0.73)*0.25)-s*sin(-4.*a))\n               \n       /*可注销 // */  ,  i<3.       ? h = v : h \n           ;\n\n    g = abs(q - g);\n\th = abs(v - h);\n\ts =g.x * g.y;\n\n\tO = vec4( 1.7 * log(1. + s) - .8\n\t\t,     .25 * log(1. + h.x * h.y) - .4 \n\t\t,     .3  * log(1. + s * s) - .1\n\t\t, 1.);\n}\n\n\n// Third flower by shadertoyjiang (https://www.shadertoy.com/view/cd2fDG)\nvoid mainImage2( out vec4 O, vec2 u ){\n\n    float a,r,s,i;\n\n    vec2  g,h,q, R = iResolution.xy,\n\n          v = 2.1*(u+u-R)/R.y + vec2(5,7.7);\n\n    float time = iTime*0.6;\n\n    for (;i++<12.;) \n\n        a = atan(v.y, v.x) + .7,\n\n        r = length(v)* .5,\n\n        s = .1 / r / r,  \n\n        g = q, q = v,  // v, q, g = memory of v over 3 steps\n\n        v =  vec2(r * cos(a+sin(time)*0.25+0.2) - s * cos(a + a),  \n\n                  r * sin(a+sin(time*0.73)*0.25+0.2) + s * sin(a + a)),\n\n        i<2. ? h=v : h;\n\n    g = abs(q - g);\n\n    h = abs(v - h);\n\n    s = g.x * g.y;  \n\n    O = log(1.+vec4(s, h.x*h.y, s*s, 0 )) * vec4(4,.2,.1,1); O.r -= 2.8;\n}\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a)) // rot\n\n// Mandel by shadertoyjiang (erased?)\nvoid mainImage3( out vec4 O, in vec2 w ) {\n\tvec2 R = iResolution.xy,\n    \n         c = (.5 * R - w.xy ) / R.x * (3.+sin(iTime)*2.),\n\n         u,v,d;\n\n    c*=rot(iTime*0.4);\n\tc.x-=0.63;c.y-=0.0;\n\n\n\tfloat l = 1.,i,j,t,m = 99.,n = m + l ;  //,s = .5;\n\n\tfor(;i++<77.;)\n\t{\n\t\tu = vec2(u.x * u.x -u.y * u.y, 2. * u.x * u.y) + c;\n\n\t\tt = dot(u,u);\n\n\t\tif(t < m)\n\t\t{ \n\t\t\tn = m; m = t ;j++;\n\t\t} \n\t\telse if(t < n) n = t;\n\n\t\tif(t > 99.) break;\n\n\t}\n\n\tt= l /(pow (m, .5) + l);\n\n\ti= 1.4 * (m / n + t) * pow(t, .5);\n\n         O.xyz = .5 + .5 * cos(6.28 * pow(l / (l + i) + i,.5) + vec3(0.,.4,.7));\n}\n\n\n// Second flower by shadertoyjiang (https://www.shadertoy.com/view/DdSfRK)\nvoid mainImage4( out vec4 O, in vec2 u ){\n    float a,r,s;\n    vec2 g,h,q, R=iResolution.xy,\n                                                                                       //v= 36.*(u-.5*R)/R.y + vec2(22.,34.);\n    // 36.                                                                                   // v= 30.*(u-.5*R)/R.y + vec2(18., 32);\n    v = 32. * (u - .5 * R) / R.y \n        * mat2(1., -.05, .05, 1.)     // 可以不要，旋转图片\n        + vec2(21., 34); // (20., 34.);\n   \n    float time = iTime*0.6;\n    for (int i;i<12;i++) \n    { \n        a = atan(v.y, v.x) + .613;  //615\n                                                                                       // a += .01 * sin(iTime);\n        r = length(v) *.5;\n        s = .3 / r / r;                                                                //.333  1./3.           //  thanks to Observer // s = 1. / 3. / pow(r, 2.); \n                                                                                       // 原先想改 .333 ，但怕不够精确，试了 Observer 改的代码，居然可以 。 想到sqr()，没想到 r*r        \n        g = q; q = v; v =\n        vec2(r * cos(a+0.05+sin(time)*0.2) - s * cos(a + a),                                              // - s * cos(-2. * a);  thanks to Observer\n             r * sin(a+0.2+cos(time*0.73)*0.2) + s * sin(a + a));                                             // - s * sin(-2. * a) \n\n        if(i<1) h=v;\n    }\n    \n    g = abs(q - g);h = abs(v - h);\n    \n                      s = g.x * g.y;\n                          \n    O =vec4(4. * log(1. + s) - 3.,\n            .2 * log(1. + h.x * h.y) - .38, //调节树枝粗细\n            .1 * log(1. + s * s) ,          //调节红与粉  .1   .2\n            1.);\n}\n\n\n#define TAU 6.283\n#define pow(a,b) pow(abs(a),b)\n\nvec2 f(vec2 p)\n{\n    vec2 t = vec2(pow(p.x,2.)-pow(p.y,2.), -2.*p.x*p.y);\n    t *= sin(iTime*1.)*1. + 1.05;\n    float b = pow(p.x,4.) + pow(p.y,4.) + 2.*pow(p.x,2.)*pow(p.y,2.);\n    return (t/b)-(p/3.);\n}\n\nvec2 P(vec2 p, float i)\n{\n    vec2 v = f(f(f(f(f(f(p))))));\n    float ti = TAU * (i/3.0);\n    \n    #ifdef SHIFT\n    ti -= iTime - p.x * p.x * length(p);\n    #endif\n\n    return v - vec2(cos(ti),sin(ti));    \n}\n\n\n#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n// BC: Box Pattern by BackwardsCap (https://www.shadertoy.com/view/dtyczD)\nvoid mainImage5( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    uv *= R(iTime * 0.25);\n\n\n    float p0 = length(P(uv, 1.0)), p1=length(P(uv,2.0)), p2=length(P(uv,3.0));\n\n    \n\n    vec3 c = vec3(0);\n\n    \n\n    if(p0 <= min(p1,p2)) c = vec3(0.557,0.286,0.961);\n\n    if(p1 <= min(p2,p0)) c = vec3(0.000,0.114,0.643);\n\n    if(p2 <= min(p0,p1)) c = vec3(0.129,0.376,0.780);\n\n    fragColor = vec4(c,1.0);\n}\n\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    int i = (int(iTime) % (5 * TIME_PER_FX)) / TIME_PER_FX + 1;\n\n    switch(i) {\n        case 1: mainImage1(O, u); break;\n        case 2: mainImage2(O, u); break;\n        case 3: mainImage3(O, u); break;\n        case 4: mainImage4(O, u); break;\n        case 5: mainImage5(O, u); break;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/M3VXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 500, 539, 539, 1153], [1156, 1230, 1268, 1268, 1881], [1942, 1980, 2022, 2022, 2561], [2564, 2639, 2680, 2680, 4395], [4448, 4448, 4464, 4464, 4652], [4654, 4654, 4679, 4679, 4862], [4914, 4989, 5047, 5047, 5447], [5450, 5450, 5488, 5488, 5782]], "test": "ok"}
{"id": "lXVXRy", "name": "Fractal Fork Triangle Wiverse", "author": "spenceryonce", "description": "forked this from gaz, just playing around", "tags": ["fractal", "triangle", "gaz", "wiverse"], "likes": 1, "viewed": 16, "published": 3, "date": "1720130111", "time_retrieved": "2024-07-05T01:42:22.403469", "image_code": "// Fork of \"Fractal 29_gaz\" by gaz. https://shadertoy.com/view/wtGfRy\n// 2024-07-04 21:33:17\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 fc)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((fc-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*6.)))/dot(p,p)/e\n    )\n    {\n        p=g*d;\n        p.z+=iTime*0.3;\n        p=R(p,normalize(vec3(0,0,7)),.8);   \n        s=2.8;\n        p=abs(mod(p-1.,8.)-1.7)-1.6;\n        for(int j=0;j++<10;)\n            p=1.-abs(p-1.),\n            s*=e=-1.9/dot(p,p),\n            p=p*e-.7;\n            g+=e=abs(p.z)/s+.002;\n            p.b*=pow(sin(iTime),8.0);\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lXVXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 153, 190, 190, 725]], "test": "ok"}
{"id": "l3GSzy", "name": "Byt3-daily-006", "author": "byt3_m3chanic", "description": "Angled truchets / playing with some moving patterns. Started as an experiment with checking neighbors and ended up as this.", "tags": ["2d", "truchet", "pattern", "tile"], "likes": 7, "viewed": 30, "published": 3, "date": "1720126458", "time_retrieved": "2024-07-05T01:42:23.170922", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Byt3-daily-006\n    Angled truchets / playing with some moving patterns. Started as an experiment with\n    checking neighbors and ended up as this.\n     \n    07/04/2024  @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.54,35.45)))*4823.232);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\n\nmat2 r45;\n// @morgan3d https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv),f = fract(uv);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1,0));\n    float c = hash21(i + vec2(0,1));\n    float d = hash21(i + vec2(1,1));\n    vec2 u = f * f * (3.-2.*f);\n    float nn =  mix(a, b, u.x) + (c-a)* u.y * (1.-u.x) + (d-b)* u.x * u.y;\n    if(uv.y<1. && uv.y>-1.&&a>.5) nn = 0.;\n    return nn;\n}\n\nvec3 truchet(vec2 p) {\n    vec2 uv = p;\n    uv *= 12.; uv -= vec2(T*.75,.85*sin(T*.4));\n    \n    vec2 id = floor(uv), q = fract(uv)-.5, suv = q;\n    float hs = hash21(id);\n\n    const float sx = .35;\n    // cheap check of the hood\n    float ns = noise(id*sx);\n    vec4 hhs = vec4(\n        noise((id.xy+vec2(0,-1))*sx),\n        noise((id.xy+vec2(1,0))*sx),\n        noise((id.xy+vec2(0,1))*sx),\n        noise((id.xy+vec2(-1,0))*sx)\n    );\n    \n    float rnd = fract(hs*4324.79);\n    if(rnd>.5) q.xy*= rot(1.5707);\n    \n    const float pf = .353, wd = .13;\n    vec2 q2 = q; q *= r45;\n    \n    // main pattern\n    float pq = length(q.x+pf)<length(q.x-pf)? q.x+pf : q.x-pf;\n    float d = length(pq);\n    d = abs(d) - wd;\n    \n    // alt pattern\n    if(hs>.65) {\n        d = min(length(q2.x),length(q2.y))-(wd*1.4);\n        float xd = length(abs(q2.x)-(wd*1.5))-(wd*.12);\n        d = max(d,-xd);\n    }\n\n    // edge block check and patterns\n    const float thr = .35;\n    if(ns<thr) {\n        d = 1.;\n        // prob could do better with logic but first stab at it..\n        if(rnd>.5) { q2.xy*= rot(-1.5707); }\n        if(hhs.x>thr) d = min(min(box(q2+vec2(0,.5),vec2(wd*1.4)),length(q2+vec2(0,.32))-(wd*1.4)), d);\n        if(hhs.z>thr) d = min(min(box(q2-vec2(0,.5),vec2(wd*1.4)),length(q2-vec2(0,.32))-(wd*1.4)), d);\n        if(hhs.y>thr) d = min(min(box(q2-vec2(.5,0),vec2(wd*1.4)),length(q2-vec2(.32,0))-(wd*1.4)), d);\n        if(hhs.w>thr) d = min(min(box(q2+vec2(.5,0),vec2(wd*1.4)),length(q2+vec2(.32,0))-(wd*1.4)), d);\n        \n        float ck = mod(id.y+id.x,2.);\n        if(hhs.x<thr&&hhs.y>thr&&hhs.z<thr&&hhs.w<thr&&ck<1.) d = min(box(q2-vec2(.2,0),vec2(wd*3.4,wd*1.4)),length(q2+vec2(.2,0))-(wd*1.4));\n        if(hhs.x<thr&&hhs.y<thr&&hhs.z>thr&&hhs.w<thr&&ck<1.) d = min(box(q2-vec2(0,.2),vec2(wd*1.4,wd*3.5)),length(q2+vec2(0,.2))-(wd*1.4));\n        if(hhs.x<thr&&hhs.y<thr&&hhs.z<thr&&hhs.w>thr&&ck<1.) d = min(box(q2+vec2(.2,0),vec2(wd*3.4,wd*1.4)),length(q2-vec2(.2,0))-(wd*1.4));\n        if(hhs.x>thr&&hhs.y<thr&&hhs.z<thr&&hhs.w<thr&&ck<1.) d = min(box(q2+vec2(0,.2),vec2(wd*1.4,wd*3.4)),length(q2-vec2(0,.2))-(wd*1.4));\n      \n        if(hhs.z>thr&&hhs.x>thr&&hhs.y<thr&&hhs.w<thr) d = length(abs(q2.x))-(wd*1.39);\n        if(hhs.w>thr&&hhs.y>thr&&hhs.x<thr&&hhs.z<thr) d = length(abs(q2.y))-(wd*1.39);\n        \n        if(hhs.x>thr&&hhs.y>thr&&hhs.z<thr&&hhs.w<thr) d = rnd<.5? abs(length(q.y+pf) ) - wd : abs(length(q.x+pf) ) - wd;\n        if(hhs.z>thr&&hhs.w>thr&&hhs.x<thr&&hhs.y<thr) d = rnd<.5? abs(length(q.y-pf) ) - wd : abs(length(q.x-pf) ) - wd;\n        if(hhs.w>thr&&hhs.x>thr&&hhs.z<thr&&hhs.y<thr) d = rnd>.5? abs(length(q.y-pf) ) - wd : abs(length(q.x+pf) ) - wd;\n        if(hhs.z>thr&&hhs.y>thr&&hhs.w<thr&&hhs.x<thr) d = rnd>.5? abs(length(q.y+pf) ) - wd : abs(length(q.x-pf) ) - wd;\n    }\n\n    return vec3(d,uv);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    r45 = rot(.7853981634);\n    \n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y); \n    float px = fwidth(uv.x); \n\n\n    vec3 C = mix(vec3(.1),vec3(.5),clamp((uv.y+.5),0.,1.));\n    \n    vec3 dt = truchet(uv);\n    vec3 st = truchet(uv+vec2(uv.x/8.,uv.y/6.));\n    float d = dt.x;\n    float s = st.x;\n\n    // prep background and domain\n    const float sc = 42.;\n    vec2 id = floor(uv*sc);\n    float hs = hash21(id);\n    uv.x += .15*sin(id.y*.133+T*.66);\n    \n    id = floor(uv*sc);\n    uv = fract(uv*sc)-.5;\n    \n    // background dots\n    float d2 = length(uv)-.3;\n    if(mod(id.x+id.y,2.)<1.){\n    C = mix(C,vec3(.3),smoothstep(px,-px,d2));\n    C = mix(C,mix(vec3(.2),vec3(.6),uv.y),smoothstep(px,-px,abs(d2)-.035));\n    }\n\n    // truchet and accent\n    C = mix(C,C*.65,smoothstep(.1+px,-px,s+.01));\n    C = mix(C,C*.45,smoothstep(.05+px,-px,d-.04));\n    C = mix(C,clamp(C+.3,vec3(0),vec3(1)),smoothstep(px,-px,d));\n    C = mix(C,mix(vec3(0),vec3(.65),.5+.5*sin(dt.z*PI2+T*2.)),smoothstep(px,-px,abs(d+.02)-.02));\n\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/l3GSzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[0, 446, 465, 465, 508], [509, 509, 530, 530, 585], [586, 586, 613, 613, 676], [688, 739, 765, 765, 1106], [1108, 1108, 1130, 1130, 3954], [3956, 3956, 3997, 3997, 5075]], "test": "ok"}
{"id": "M3GSzy", "name": "cylinder in+out intersect", "author": "silica163", "description": "capped cylinder intersection function with inside intersect support", "tags": ["3d", "raycasting", "raytrace", "intersect", "cylinder"], "likes": 2, "viewed": 35, "published": 3, "date": "1720102514", "time_retrieved": "2024-07-05T01:42:23.935898", "image_code": "#define R iResolution\n#define MAX 50.\n#define PI 3.14159265\n#define CAM_ROT\n\nstruct Cylinder {\n    vec3 pos;\n    vec2 size; /*x: radius, y: height*/\n};\n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder c){\n    float h = -1.,n = MAX, f = MAX;\n    vec3 co = ro - c.pos;\n \n    vec2 rdxz = normalize(rd.xz);\n    float t = -dot(rdxz, co.xz);\n    vec2 rp = co.xz + rdxz * t;\n    float k = c.size.x*c.size.x - dot(rp,rp);\n\n    float lxz = length(rd.xz);\n    \n    // body near\n    n = t - sqrt(k);\n    n = n/lxz;\n\n    // body far\n    f = t + sqrt(k);\n    f = f/lxz;\n\n    // no intersection\n    if(k < 0. || f < 0. || f < n)\n        return -1.;\n\n    // y intersect position\n    float nph = rd.y * n + co.y;\n    float fph = rd.y * f + co.y;\n\n    // cap intersection\n    float ct = ( c.size.y - co.y)/rd.y;\n    float cb = (-c.size.y - co.y)/rd.y;\n    if(ct < 0.)ct = MAX;\n    if(cb < 0.)cb = MAX;\n\n    // far\n    if(abs(fph) <= c.size.y && (n < 0. || abs(nph) > c.size.y))\n        h = f;\n\n    // cap\n    if(fph <  c.size.y &&  c.size.y < nph) h = ct;\n    if(fph > -c.size.y && -c.size.y > nph) h = cb;\n    if(n < 0. && abs(co.y) < c.size.y)\n        h = min(min(ct,cb), f); // inside intersect\n    \n    // near\n    if(abs(nph) <= c.size.y && n >= 0.)\n        h = n;\n\n    return h;\n}\n\nvec3 nCylinder(vec3 rp, Cylinder c){\n    vec3 cp = rp - c.pos;\n    vec3 n = vec3(0);\n    if(abs(cp.y)+0.0001 >= c.size.y) n = vec3(0,1,0)*(cp.y/abs(cp.y));\n    else n.xz = normalize(cp.xz);\n    return n;\n}\n\nCylinder cy[2];\nvec2 intersect(vec3 ro, vec3 rd){\n    int mat = -1;\n    float d = MAX;\n    float cy = iCylinder(ro, rd, cy[0]);\n    if(cy < 0.)cy = MAX;\n    d = min(d,cy);\n    \n    if(d == cy)mat = 0;\n    if(d == MAX)mat = -1;\n    return vec2(d, mat);\n}\n\n// pattern from https://www.shadertoy.com/view/4lcSRn\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord - R.xy)/R.y;\n    vec2 m = (2.*iMouse.xy - R.xy)/R.y;\n    uv = mat2(sin(1.),cos(1.),-cos(1.),sin(1.))*uv;\n    vec3 c = vec3(0),\n         ro = vec3(0,0,5), \n         rd = normalize(vec3(uv/2.,-1)), \n         N = vec3(0);\n#ifdef CAM_ROT\n    if(iMouse.z <= 0.){\n        m.x = sin(iTime*.5)*.25;\n        m.y = sin(iTime*.5)*.5;\n    }\n    //m = mat2(sin(1.),cos(1.),-cos(1.),sin(1.))*m;\n    m *= PI*vec2(-1.,.6);\n    {\n        vec2 c = cos(m),s = sin(m);\n        rd = mat3(\n            c.x    ,   0,-s.x, \n            s.x*s.y, c.y, c.x*s.y, \n            c.y*s.x,-s.y, c.x*c.y\n        ) * rd ;\n        ro = mat3(\n            c.x    ,   0,-s.x, \n            s.x*s.y, c.y, c.x*s.y, \n            c.y*s.x,-s.y, c.x*c.y\n        ) * ro;\n    }\n\n#else\n    if(iMouse.z > 0.)\n        ro.xy += 2.*m;\n#endif\n\n    cy[0] = Cylinder(vec3(0),vec2(1,2));\n\n    vec2 i = intersect(ro, rd);\n    vec3 rp = ro + rd * i.x;\n   \n    switch(int(i.y)){\n        case 0:\n            N = nCylinder(rp, cy[0]);\n            c = pattern( vec2(12.0,12.0)*vec2(atan(rp.z,rp.x),rp.y))*.5;\n        default : \n            c += 0.5;\n            break;\n    }\n    \n    fragColor = vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/M3GSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 199, 199, 1264], [1266, 1266, 1302, 1302, 1471], [1489, 1489, 1522, 1522, 1726], [1728, 1782, 1810, 1810, 2000], [2002, 2002, 2056, 2056, 3231]], "test": "ok"}
{"id": "lXySRG", "name": "interpolation functions test", "author": "jonasfrey", "description": "a small experiment with the exponential function x*x\nhttps://www.desmos.com/calculator/w4itchoyml", "tags": ["exponent"], "likes": 5, "viewed": 42, "published": 3, "date": "1720091407", "time_retrieved": "2024-07-05T01:42:24.711824", "image_code": "float f_n_sin_interpolated(\n    float n_t\n){\n    float n_tau = 6.2831;\n    float a = -1.*cos(n_t*n_tau*.25);\n    float b = cos((n_t-1.)*n_tau*.25);\n    float c = n_t*b + (1.-n_t)*a;\n    return c;\n}\nfloat f_n_exp_interpolated(\n    float n_t \n){\n        float a = n_t*n_t;\n        float b = pow(n_t-1.,2.);\n        float c = n_t*b + (1.-n_t)*a; \n        return c;\n         \n}\n//https://www.desmos.com/calculator/khmgdiws0b\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n        \n    float n_its = 9.;\n    float n_tau = 6.2831;\n    vec4 o_col_min = vec4(0.);\n    vec4 o_col = vec4(0.);\n    o_trn*=1.5;\n    for(float n_it_nor = .0; n_it_nor<1.;n_it_nor+=(1./n_its)){\n\n        float n_ang_nor = fract((atan(o_trn.y, o_trn.x)/n_tau));\n        float n_ang_intensity = (n_ang_nor-.5);//(sin(n_ang_nor*2.)*.5+.5);\n        float c = f_n_sin_interpolated(sin(n_it_nor*n_tau+n_it_nor+iTime)*.5+.5);\n        float n_radius = n_it_nor+.2\n            +(sin(n_ang_nor*22.*n_tau))*.2*c;\n\n        float n = length(o_trn*(1./n_radius));\n        n = clamp(abs(n-.5)*2., 0., 1.);\n        float n_exponent = n_its;\n        n = pow(1.-n, n_exponent);\n\n        float nin2 = fract(n_it_nor+iTime*.2);\n        o_col += vec4(n)*vec4(\n            nin2,\n            1.-nin2,\n            fract(.5+nin2),\n           1.);\n        \n    }\n    fragColor = o_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lXySRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 197], [198, 198, 243, 243, 373], [374, 421, 478, 528, 1456]], "test": "ok"}
{"id": "XXyXRy", "name": "line change with synapsys", "author": "nayk", "description": "combination of sources  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/43GXRy", "tags": ["fractal", "line", "cosmos", "cineshader"], "likes": 2, "viewed": 62, "published": 3, "date": "1720082099", "time_retrieved": "2024-07-05T01:42:25.482282", "image_code": "\n\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);\n    return length(pa-ba*t);\n\n\n}\n\nfloat N21(vec2 p){\n    p=fract(p*vec2(233.34,851.73));\n    p+=dot(p,p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 N22(vec2 p){\n    float n=N21(p);\n    return vec2(n,N21(p+n));\n\n}\n\nvec2 GetPos(vec2 id,vec2 offs){\n    \n    \n    vec2 n = N22(id+offs)*iTime;\n    \n    return offs+cos(n)*sin(n)*.5;\n\n}\nfloat Line(vec2 p,vec2 a, vec2 b){\n    float d = DistLine(p,a,b);\n    float m = S(.06,.01,d);\n    float d2 = length(a-b);\n    m *= S(2.2, .8, d2)+S(.05,.03,abs(d2-.75));\n    return m;\n\n}\nfloat Layer(vec2 uv){\n    float m =0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.;y<=1.;y++){\n        for(float x=-1.;x<=1.;x++){\n            p[i++] = GetPos(id,vec2(x,y));\n            \n        }\n    \n    }\n    float t = iTime*10.0;\n    for(int i=0;i<9;i++){\n        m+= Line(gv,p[4],p[i]);\n        vec2 j = (p[i] - gv)*15.;\n        float sparkle = 1./dot(j,j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5+.5);\n    \n    }\n    m+= Line(gv,p[1],p[3]);\n    m+= Line(gv,p[1],p[5]);\n    m+= Line(gv,p[7],p[3]);\n    m+= Line(gv,p[7],p[5]);\n    return m;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.3-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define REFLECTION_NUMBER 40\n\nmat3 rotation(float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, -s, 0.,  s, c, 0.,  0., 0., 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec2 mo = length(iMouse.xy - vec2(0.0)) < 1.0 ? vec2(0.0) : (iMouse.xy - iResolution.xy*.5)/iResolution.y*3.;\n    \n   \n    vec3 huv = vec3(uv, 0.);\n    huv *= rotation(iTime*.2);\n    \n    vec3 axisOrigin = vec3(0., 0., 1.);\n    vec3 axisDirection = vec3(normalize(vec2(1., 1.)), 0.);\n    \n    for(int i = 0; i < REFLECTION_NUMBER; i++)\n    {\n        float offset = (3.1415 * 2. / float(REFLECTION_NUMBER) ) * float(i);\n        float axisRotation = offset;\n    \tvec3 tuv = (huv - axisOrigin) * rotation(-axisRotation);\n    \tif(tuv.y < 0.)\n    \t{\n    \t\tvec3 invuv = tuv;\n        \tinvuv.y = -invuv.y;\n        \tinvuv = (invuv * rotation(axisRotation)) + axisOrigin;\n        \thuv = invuv;\n    \t}\n    }\n    \n    vec3 col2 = vec3(texture(iChannel0, huv.xy - vec2(iTime *.2, 0.) ));\n    \n    vec3 sky = vec3(texture(iChannel1, huv.xy)).xyz;\n    \n    col2 = mix(sky, col2, abs(sin(iTime/2.0)));\n\n    float gradient = uv.y;\n    float m = 0.;\n    float t = iTime*.1;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c,-s,s,c);\n  ;\n\n    for( float i=0.;i<=1.;i+=1./7.){\n        float z=fract(i*i+t);\n        float size = mix(59.,.5,z);\n        float fade = S(0.,.2,z)*S(1.,.0,z);\n        m+=Layer(uv*size+i*200.)*fade;\n    }\n    vec3 base = sin(t*5.*vec3(.345,.456,.657))*.5+.6;\n    vec3 col = m*base;\n    col -=gradient*base;\n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XXyXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 332, 332, 453], [455, 455, 473, 473, 562], [564, 564, 581, 581, 633], [635, 635, 666, 666, 751], [752, 752, 786, 786, 938], [939, 939, 960, 960, 1566], [1568, 1568, 1646, 1674, 2560], [2591, 2591, 2619, 2619, 2723], [2724, 2724, 2781, 2809, 4377]], "test": "ok"}
{"id": "43yXRy", "name": "other matrix", "author": "nayk", "description": "original source https://www.shadertoy.com/view/4XGXRG", "tags": ["matrix"], "likes": 2, "viewed": 37, "published": 3, "date": "1720081395", "time_retrieved": "2024-07-05T01:42:26.334015", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n#define PI 3.1415926535\n\n#define PI 3.1415926535\n\nfloat sdCircle( in vec2 p, in float r){\n    return length(p) -r;\n}\n\nvec2 rotate ( in vec2 p, in float theta ){\n    vec2 pos;\n    pos.x = cos(theta) * p.x - sin(theta) * p.y;\n    pos.y = sin(theta) * p.x + cos(theta) * p.y;\n    return pos;\n}\n\nfloat text(vec2 fragCoord){\n    vec2 uv = mod(fragCoord.xy, 16.)*.0625;\n    vec2 block = fragCoord*.0625 - uv;\n    uv = (uv*.65 + floor(texture(iChannel1, block/iChannelResolution[1].xy + iTime*.0001).xy * 16.))*-.9;\n    uv *= -.0625;\n    \n    return texture(iChannel0, uv).r;\n}\nfloat text2(vec2 fragCoord){\n    vec2 uv = mod(fragCoord.xy, 16.)*.0625;\n    vec2 block = fragCoord*.0625 - uv;\n    uv = (uv*.65 + floor(texture(iChannel1, block/iChannelResolution[1].xy + iTime*.0001).xy * 16.))*-.9;\n    uv *= -.0625;\n    \n    return texture(iChannel0, uv).r;\n}\n\nvec3 rain(vec2 fragCoord){\n    fragCoord.x -= mod(fragCoord.x, 10.);\n    \n    float offset=sin(fragCoord.x*15.);\n    float speed=cos(fragCoord.x*3.)*.3+.4;\n   \n    float x = fract(fragCoord.x/iResolution.x + iTime*speed);\n    return vec3(1.1,2.,.7) / x*.2;\n}\n\nvec3 rain2(vec2 fragCoord){\n    fragCoord.y -= mod(fragCoord.y, 30.);\n    \n    float offset=sin(fragCoord.y*15.);\n    float speed=cos(fragCoord.y*3.)*.3+.4;\n   \n    float x = fract(fragCoord.x/iResolution.x + iTime*1.1*speed);\n     float y = fract(fragCoord.y/iResolution.y + iTime*1.1*speed);\n    return vec3(1.1,2.,.7) / x*.2;\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec4 fragColor=O;\n    vec2 fragCoord = C;\n    \n    vec4 base = vec4(text(fragCoord)*rain(fragCoord),1.0);\n    vec4 base1 = vec4(text(fragCoord + 200.)*rain(fragCoord + 200.),1.0);\n      vec4 base3 = vec4(text2(fragCoord)*rain2(fragCoord),1.0);\n    fragColor = mix(base, base1+base3, 1.5);\n    //fragColor = base;\n    \n    vec2 lightPos = rotate(vec2(800.,0.),PI/20.);\n    vec4 lightCol = fragColor;\n       fragColor = mix(fragColor, lightCol,.5);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n   \n    O+=fragColor;\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/43yXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 196, 196, 223], [225, 225, 267, 267, 397], [399, 399, 426, 426, 677], [678, 678, 706, 706, 957], [959, 959, 985, 985, 1217], [1219, 1219, 1246, 1246, 1549], [1550, 1550, 1586, 1586, 2148]], "test": "ok"}
{"id": "43GXRy", "name": "line-change", "author": "yujack", "description": "关于线段的变化", "tags": [], "likes": 1, "viewed": 38, "published": 3, "date": "1720080165", "time_retrieved": "2024-07-05T01:42:27.108953", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);\n    return length(pa-ba*t);\n\n\n}\n\nfloat N21(vec2 p){\n    p=fract(p*vec2(233.34,851.73));\n    p+=dot(p,p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 N22(vec2 p){\n    float n=N21(p);\n    return vec2(n,N21(p+n));\n\n}\n\nvec2 GetPos(vec2 id,vec2 offs){\n    \n    \n    vec2 n = N22(id+offs)*iTime;\n    \n    return offs+cos(n)*sin(n)*.5;\n\n}\nfloat Line(vec2 p,vec2 a, vec2 b){\n    float d = DistLine(p,a,b);\n    float m = S(.03,.01,d);\n    float d2 = length(a-b);\n    m *= S(1.2, .8, d2)+S(.05,.03,abs(d2-.75));\n    return m;\n\n}\nfloat Layer(vec2 uv){\n    float m =0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.;y<=1.;y++){\n        for(float x=-1.;x<=1.;x++){\n            p[i++] = GetPos(id,vec2(x,y));\n            \n        }\n    \n    }\n    float t = iTime*10.0;\n    for(int i=0;i<9;i++){\n        m+= Line(gv,p[4],p[i]);\n        vec2 j = (p[i] - gv)*15.;\n        float sparkle = 1./dot(j,j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5+.5);\n    \n    }\n    m+= Line(gv,p[1],p[3]);\n    m+= Line(gv,p[1],p[5]);\n    m+= Line(gv,p[7],p[3]);\n    m+= Line(gv,p[7],p[5]);\n    return m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n    float gradient = uv.y;\n    float m = 0.;\n    float t = iTime*.1;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c,-s,s,c);\n    uv *= rot;\n    mouse *= rot;\n    for( float i=0.;i<=1.;i+=1./4.){\n        float z=fract(i+t);\n        float size = mix(10.,.5,z);\n        float fade = S(0.,.2,z)*S(1.,.0,z);\n        m+=Layer(uv*size+i*20.+mouse)*fade;\n    }\n    vec3 base = sin(t*5.*vec3(.345,.456,.657))*.5+.6;\n    vec3 col = m*base;\n    col -=gradient*base;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/43GXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 75, 75, 196], [198, 198, 216, 216, 305], [307, 307, 324, 324, 376], [378, 378, 409, 409, 494], [495, 495, 529, 529, 681], [682, 682, 703, 703, 1309], [1310, 1310, 1367, 1417, 2032]], "test": "ok"}
